; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30133.0 

	TITLE	\\VBOXSVR\_stoneage\repos\ssm-sacli\Release\winlua.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?ptActMenuWinLua@@3PAUaction@@A			; ptActMenuWinLua
PUBLIC	??_C@_03IBJHJIAF@lua@				; `string'
PUBLIC	?MYLua@@3UtagMYLua@@A				; MYLua
PUBLIC	??_C@_03DEBJKBHO@Win@				; `string'
PUBLIC	??_C@_08GBGCLPL@lssproto@			; `string'
PUBLIC	??_C@_02CKOPKKAC@sa@				; `string'
PUBLIC	??_C@_0L@KPCNOBPE@ServerList@			; `string'
PUBLIC	??_C@_08MIFFGPAF@ChengHao@			; `string'
PUBLIC	??_C@_09IOBHABKN@GuangHuan@			; `string'
PUBLIC	??_C@_04GBLPADGB@PiFu@				; `string'
PUBLIC	??_C@_04PJOLNDGD@data@				; `string'
EXTRN	?luaopen_Win@@YAHPAUlua_State@@@Z:PROC		; luaopen_Win
EXTRN	?luaopen_Lssproto@@YAHPAUlua_State@@@Z:PROC	; luaopen_Lssproto
EXTRN	?luaopen_Sa@@YAHPAUlua_State@@@Z:PROC		; luaopen_Sa
EXTRN	?luaopen_ServerList@@YAHPAUlua_State@@@Z:PROC	; luaopen_ServerList
EXTRN	?luaopen_Data@@YAHPAUlua_State@@@Z:PROC		; luaopen_Data
EXTRN	?luaopen_ChenghaoList@@YAHPAUlua_State@@@Z:PROC	; luaopen_ChenghaoList
EXTRN	?luaopen_GuangHuanList@@YAHPAUlua_State@@@Z:PROC ; luaopen_GuangHuanList
EXTRN	?luaopen_PiFuList@@YAHPAUlua_State@@@Z:PROC	; luaopen_PiFuList
_BSS	SEGMENT
?ptActMenuWinLua@@3PAUaction@@A DD 01H DUP (?)		; ptActMenuWinLua
?MYLua@@3UtagMYLua@@A DB 0cH DUP (?)			; MYLua
_BSS	ENDS
;	COMDAT ??_C@_04PJOLNDGD@data@
CONST	SEGMENT
??_C@_04PJOLNDGD@data@ DB 'data', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GBLPADGB@PiFu@
CONST	SEGMENT
??_C@_04GBLPADGB@PiFu@ DB 'PiFu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09IOBHABKN@GuangHuan@
CONST	SEGMENT
??_C@_09IOBHABKN@GuangHuan@ DB 'GuangHuan', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MIFFGPAF@ChengHao@
CONST	SEGMENT
??_C@_08MIFFGPAF@ChengHao@ DB 'ChengHao', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KPCNOBPE@ServerList@
CONST	SEGMENT
??_C@_0L@KPCNOBPE@ServerList@ DB 'ServerList', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02CKOPKKAC@sa@
CONST	SEGMENT
??_C@_02CKOPKKAC@sa@ DB 'sa', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08GBGCLPL@lssproto@
CONST	SEGMENT
??_C@_08GBGCLPL@lssproto@ DB 'lssproto', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DEBJKBHO@Win@
CONST	SEGMENT
??_C@_03DEBJKBHO@Win@ DB 'Win', 00H			; `string'
CONST	ENDS
CONST	SEGMENT
?lualibs@@3QBUluaL_Reg@@B DD FLAT:??_C@_03DEBJKBHO@Win@	; lualibs
	DD	FLAT:?luaopen_Win@@YAHPAUlua_State@@@Z
	DD	FLAT:??_C@_08GBGCLPL@lssproto@
	DD	FLAT:?luaopen_Lssproto@@YAHPAUlua_State@@@Z
	DD	FLAT:??_C@_02CKOPKKAC@sa@
	DD	FLAT:?luaopen_Sa@@YAHPAUlua_State@@@Z
	DD	FLAT:??_C@_0L@KPCNOBPE@ServerList@
	DD	FLAT:?luaopen_ServerList@@YAHPAUlua_State@@@Z
	DD	FLAT:??_C@_08MIFFGPAF@ChengHao@
	DD	FLAT:?luaopen_ChenghaoList@@YAHPAUlua_State@@@Z
	DD	FLAT:??_C@_09IOBHABKN@GuangHuan@
	DD	FLAT:?luaopen_GuangHuanList@@YAHPAUlua_State@@@Z
	DD	FLAT:??_C@_04GBLPADGB@PiFu@
	DD	FLAT:?luaopen_PiFuList@@YAHPAUlua_State@@@Z
	DD	FLAT:??_C@_04PJOLNDGD@data@
	DD	FLAT:?luaopen_Data@@YAHPAUlua_State@@@Z
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ??_C@_03IBJHJIAF@lua@
CONST	SEGMENT
??_C@_03IBJHJIAF@lua@ DB 'lua', 00H			; `string'
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	_printf
PUBLIC	?myluaload@@YAHPAD@Z				; myluaload
PUBLIC	?remyluaload@@YAHPAD@Z				; remyluaload
PUBLIC	?LoadStoneAgeLUA@@YAXPAD@Z			; LoadStoneAgeLUA
PUBLIC	?closemyluaload@@YAHXZ				; closemyluaload
PUBLIC	?dofile@@YAHPAUlua_State@@PBD@Z			; dofile
PUBLIC	?docall@@YAHPAUlua_State@@HH@Z			; docall
PUBLIC	?getArrayInt@@YAHPAUlua_State@@H@Z		; getArrayInt
PUBLIC	?luaAB_openlibs@@YAXPAUlua_State@@@Z		; luaAB_openlibs
PUBLIC	?FindLua@@YAPAUlua_State@@PAD@Z			; FindLua
PUBLIC	?FindWinIntLua@@YAPAUlua_State@@HPAD@Z		; FindWinIntLua
PUBLIC	?FreeCreateWinTypeLua@@YAPAUaction@@PAUlua_State@@@Z ; FreeCreateWinTypeLua
PUBLIC	?FreeServerWinTypeLua@@YAPAUaction@@PAUlua_State@@@Z ; FreeServerWinTypeLua
PUBLIC	?ReLoadStoneAgeLUA@@YAXPAD@Z			; ReLoadStoneAgeLUA
PUBLIC	?FreeGetBattleMap@@YAHH@Z			; FreeGetBattleMap
PUBLIC	??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ		; sprintf_s<256>
PUBLIC	?decryptLUA@@YAHPAUlua_State@@PAD@Z		; decryptLUA
PUBLIC	?decryptLUA2@@YAHPAUlua_State@@PAD@Z		; decryptLUA2
PUBLIC	?NewLoadStoneAgeLUA@@YAXPAD@Z			; NewLoadStoneAgeLUA
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_06BHFGNFJA@?4?1?1lua@			; `string'
PUBLIC	??_C@_0BA@IALLELID@?$CFs?1?1win?1?1?$CFd?4lua@	; `string'
PUBLIC	??_C@_0L@MBJJKKFJ@WindowInit@			; `string'
PUBLIC	??_C@_0O@OFCFMCFI@CreateWinType@		; `string'
PUBLIC	??_C@_0CJ@EGHDEEMJ@?l?$PN?O?$KC?$KD?$LKFreeCreateWinTypeLua?5?$DP?$DP?$DP?i@ ; `string'
PUBLIC	??_C@_0BB@ELCOHPIG@ServerWindowType@		; `string'
PUBLIC	??_C@_0CJ@EEFCGKJC@?l?$PN?O?$KC?$KD?$LKFreeServerWinTypeLua?5?$DP?$DP?$DP?i@ ; `string'
PUBLIC	??_C@_04PFAOODAA@?$CFs?3?5@			; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6@			; `string'
PUBLIC	??_C@_0BP@LIDEPBBI@?$CIerror?5object?5is?5not?5a?5string?$CJ@ ; `string'
PUBLIC	??_C@_05GFCDIDHO@debug@				; `string'
PUBLIC	??_C@_09GPFEECNC@traceback@			; `string'
PUBLIC	??_C@_0BL@FFJEDJPI@?l?$PN?O?$KC?$KD?$LKdocall?5?$DP?$DP?$DP?i?$LL?3?$CFd?$CI?$CFs?$CJ?6@ ; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0DE@DIDENEII@?2VBOXSVR?2_stoneage?2repos?2ssm?9sa@ ; `string'
PUBLIC	??_C@_0BN@MOHPFDBB@?Y?$PO?K?l?$KD?$LK?$CFs?5?$DP?$DP?p?$KL?c?F?$KD?$LK?$CFs?5?z?$LM?$DP?$KD?$LK?$CFd?6@ ; `string'
PUBLIC	??_C@_04GHJNJNPO@main@				; `string'
PUBLIC	??_C@_03ILJCGOLJ@?6?$CFs@			; `string'
PUBLIC	??_C@_01KMDKNFGN@?1@				; `string'
PUBLIC	??_C@_03EMIMMIHL@?$CK?4?$CK@			; `string'
PUBLIC	??_C@_06PDPEOAFG@?$CFs?1?1?$CFs@		; `string'
PUBLIC	??_C@_04BIAACBGB@?4lua@				; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0BH@EIPJDOPB@?$CFs?1?1map?1?1battlemap?4lua@ ; `string'
PUBLIC	??_C@_0BB@BDENLLEH@FreeGetBattleMap@		; `string'
PUBLIC	??_C@_0BN@LFGCKIJG@FreeGetBattleMap?5?$DP?$DP?$DP?i?$LL?5?$CI?$CFs?$CJ?6@ ; `string'
PUBLIC	??_C@_0CF@OPCDIGNC@?l?$PN?O?$KC?$KD?$LKFreeGetBattleMap?5?$DP?$DP?$DP?i?$LL?3?$CFd@ ; `string'
EXTRN	??2@YAPAXIHPBDH@Z:PROC				; operator new
EXTRN	??_U@YAPAXIHPBDH@Z:PROC				; operator new[]
EXTRN	_strstr:PROC
EXTRN	__imp__FindClose@4:PROC
EXTRN	__imp__FindFirstFileA@8:PROC
EXTRN	__imp__FindNextFileA@8:PROC
EXTRN	__imp__lstrcpyA@8:PROC
EXTRN	__imp__lstrcatA@8:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	_fopen_s:PROC
EXTRN	_fclose:PROC
EXTRN	_fflush:PROC
EXTRN	_fread:PROC
EXTRN	_fseek:PROC
EXTRN	_ftell:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	___stdio_common_vsprintf_s:PROC
EXTRN	_lua_close:PROC
EXTRN	_lua_gettop:PROC
EXTRN	_lua_settop:PROC
EXTRN	_lua_pushvalue:PROC
EXTRN	_lua_remove:PROC
EXTRN	_lua_insert:PROC
EXTRN	_lua_isnumber:PROC
EXTRN	_lua_isstring:PROC
EXTRN	_lua_type:PROC
EXTRN	_lua_tonumber:PROC
EXTRN	_lua_tolstring:PROC
EXTRN	_lua_pushnumber:PROC
EXTRN	_lua_pushinteger:PROC
EXTRN	_lua_pushstring:PROC
EXTRN	_lua_pushcclosure:PROC
EXTRN	_lua_gettable:PROC
EXTRN	_lua_getfield:PROC
EXTRN	_lua_call:PROC
EXTRN	_lua_pcall:PROC
EXTRN	_lua_gc:PROC
EXTRN	_luaL_loadfile:PROC
EXTRN	_luaL_loadstring:PROC
EXTRN	_luaL_newstate:PROC
EXTRN	_luaL_openlibs:PROC
EXTRN	?strcmptail@@YAHPAD0@Z:PROC			; strcmptail
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_C@_0CF@OPCDIGNC@?l?$PN?O?$KC?$KD?$LKFreeGetBattleMap?5?$DP?$DP?$DP?i?$LL?3?$CFd@
CONST	SEGMENT
??_C@_0CF@OPCDIGNC@?l?$PN?O?$KC?$KD?$LKFreeGetBattleMap?5?$DP?$DP?$DP?i?$LL?3?$CFd@ DB 0ecH
	DB	0fdH, 0cfH, 0a2H, 0a3H, 0baH, 'FreeGetBattleMap ???', 0e9H, 0bbH
	DB	':%d(%s)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LFGCKIJG@FreeGetBattleMap?5?$DP?$DP?$DP?i?$LL?5?$CI?$CFs?$CJ?6@
CONST	SEGMENT
??_C@_0BN@LFGCKIJG@FreeGetBattleMap?5?$DP?$DP?$DP?i?$LL?5?$CI?$CFs?$CJ?6@ DB 'F'
	DB	'reeGetBattleMap ???', 0e9H, 0bbH, ' (%s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BDENLLEH@FreeGetBattleMap@
CONST	SEGMENT
??_C@_0BB@BDENLLEH@FreeGetBattleMap@ DB 'FreeGetBattleMap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EIPJDOPB@?$CFs?1?1map?1?1battlemap?4lua@
CONST	SEGMENT
??_C@_0BH@EIPJDOPB@?$CFs?1?1map?1?1battlemap?4lua@ DB '%s//map//battlemap'
	DB	'.lua', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BIAACBGB@?4lua@
CONST	SEGMENT
??_C@_04BIAACBGB@?4lua@ DB '.lua', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06PDPEOAFG@?$CFs?1?1?$CFs@
CONST	SEGMENT
??_C@_06PDPEOAFG@?$CFs?1?1?$CFs@ DB '%s//%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03EMIMMIHL@?$CK?4?$CK@
CONST	SEGMENT
??_C@_03EMIMMIHL@?$CK?4?$CK@ DB '*.*', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ILJCGOLJ@?6?$CFs@
CONST	SEGMENT
??_C@_03ILJCGOLJ@?6?$CFs@ DB 0aH, '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GHJNJNPO@main@
CONST	SEGMENT
??_C@_04GHJNJNPO@main@ DB 'main', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MOHPFDBB@?Y?$PO?K?l?$KD?$LK?$CFs?5?$DP?$DP?p?$KL?c?F?$KD?$LK?$CFs?5?z?$LM?$DP?$KD?$LK?$CFd?6@
CONST	SEGMENT
??_C@_0BN@MOHPFDBB@?Y?$PO?K?l?$KD?$LK?$CFs?5?$DP?$DP?p?$KL?c?F?$KD?$LK?$CFs?5?z?$LM?$DP?$KD?$LK?$CFd?6@ DB 0d9H
	DB	0feH, 0cbH, 0ecH, 0a3H, 0baH, '%s ??', 0f0H, 0abH, 0e3H, 0c6H, 0a3H
	DB	0baH, '%s ', 0faH, 0bcH, '?', 0a3H, 0baH, '%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@DIDENEII@?2VBOXSVR?2_stoneage?2repos?2ssm?9sa@
CONST	SEGMENT
??_C@_0DE@DIDENEII@?2VBOXSVR?2_stoneage?2repos?2ssm?9sa@ DB '\VBOXSVR\_st'
	DB	'oneage\repos\ssm-sacli\mylua\winlua.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FFJEDJPI@?l?$PN?O?$KC?$KD?$LKdocall?5?$DP?$DP?$DP?i?$LL?3?$CFd?$CI?$CFs?$CJ?6@
CONST	SEGMENT
??_C@_0BL@FFJEDJPI@?l?$PN?O?$KC?$KD?$LKdocall?5?$DP?$DP?$DP?i?$LL?3?$CFd?$CI?$CFs?$CJ?6@ DB 0ecH
	DB	0fdH, 0cfH, 0a2H, 0a3H, 0baH, 'docall ???', 0e9H, 0bbH, ':%d(%'
	DB	's)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09GPFEECNC@traceback@
CONST	SEGMENT
??_C@_09GPFEECNC@traceback@ DB 'traceback', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFCDIDHO@debug@
CONST	SEGMENT
??_C@_05GFCDIDHO@debug@ DB 'debug', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LIDEPBBI@?$CIerror?5object?5is?5not?5a?5string?$CJ@
CONST	SEGMENT
??_C@_0BP@LIDEPBBI@?$CIerror?5object?5is?5not?5a?5string?$CJ@ DB '(error '
	DB	'object is not a string)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PFAOODAA@?$CFs?3?5@
CONST	SEGMENT
??_C@_04PFAOODAA@?$CFs?3?5@ DB '%s: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@EEFCGKJC@?l?$PN?O?$KC?$KD?$LKFreeServerWinTypeLua?5?$DP?$DP?$DP?i@
CONST	SEGMENT
??_C@_0CJ@EEFCGKJC@?l?$PN?O?$KC?$KD?$LKFreeServerWinTypeLua?5?$DP?$DP?$DP?i@ DB 0ecH
	DB	0fdH, 0cfH, 0a2H, 0a3H, 0baH, 'FreeServerWinTypeLua ???', 0e9H
	DB	0bbH, ':%d(%s)', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ELCOHPIG@ServerWindowType@
CONST	SEGMENT
??_C@_0BB@ELCOHPIG@ServerWindowType@ DB 'ServerWindowType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@EGHDEEMJ@?l?$PN?O?$KC?$KD?$LKFreeCreateWinTypeLua?5?$DP?$DP?$DP?i@
CONST	SEGMENT
??_C@_0CJ@EGHDEEMJ@?l?$PN?O?$KC?$KD?$LKFreeCreateWinTypeLua?5?$DP?$DP?$DP?i@ DB 0ecH
	DB	0fdH, 0cfH, 0a2H, 0a3H, 0baH, 'FreeCreateWinTypeLua ???', 0e9H
	DB	0bbH, ':%d(%s)', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OFCFMCFI@CreateWinType@
CONST	SEGMENT
??_C@_0O@OFCFMCFI@CreateWinType@ DB 'CreateWinType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MBJJKKFJ@WindowInit@
CONST	SEGMENT
??_C@_0L@MBJJKKFJ@WindowInit@ DB 'WindowInit', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IALLELID@?$CFs?1?1win?1?1?$CFd?4lua@
CONST	SEGMENT
??_C@_0BA@IALLELID@?$CFs?1?1win?1?1?$CFd?4lua@ DB '%s//win//%d.lua', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BHFGNFJA@?4?1?1lua@
CONST	SEGMENT
??_C@_06BHFGNFJA@?4?1?1lua@ DB './/lua', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
?progname@@3PBDB DD FLAT:??_C@_03IBJHJIAF@lua@		; progname
_DATA	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\mylua\winlua.cpp
;	COMDAT ?NewLoadStoneAgeLUA@@YAXPAD@Z
_TEXT	SEGMENT
tv66 = -264						; size = 4
_token$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
?NewLoadStoneAgeLUA@@YAXPAD@Z PROC			; NewLoadStoneAgeLUA, COMDAT

; 370  : void NewLoadStoneAgeLUA(char *filename){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 55 08	 mov	 edx, DWORD PTR _filename$[ebp]

; 371  : 	char token[256];
; 372  : 	if(strlen(filename)>0){

  00016	8b ca		 mov	 ecx, edx
  00018	56		 push	 esi
  00019	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  0001c	0f 1f 40 00	 npad	 4
$LL5@NewLoadSto:
  00020	8a 01		 mov	 al, BYTE PTR [ecx]
  00022	41		 inc	 ecx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL5@NewLoadSto
  00027	2b ce		 sub	 ecx, esi
  00029	5e		 pop	 esi
  0002a	74 34		 je	 SHORT $LN2@NewLoadSto

; 373  : 		sprintf_s(token, "%s//%s", _LUA_PATCH_,filename);

  0002c	52		 push	 edx
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_06BHFGNFJA@?4?1?1lua@
  00032	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _token$[ebp]
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_06PDPEOAFG@?$CFs?1?1?$CFs@
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ; sprintf_s<256>

; 374  : 		myluaload(token);

  00043	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _token$[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ?myluaload@@YAHPAD@Z	; myluaload
  0004f	83 c4 14	 add	 esp, 20			; 00000014H

; 377  : 	}
; 378  : }

  00052	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00055	33 cd		 xor	 ecx, ebp
  00057	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
$LN2@NewLoadSto:

; 375  : 	}else{
; 376  : 		LoadStoneAgeLUA(_LUA_PATCH_);

  00060	68 00 00 00 00	 push	 OFFSET ??_C@_06BHFGNFJA@?4?1?1lua@
  00065	e8 00 00 00 00	 call	 ?LoadStoneAgeLUA@@YAXPAD@Z ; LoadStoneAgeLUA

; 377  : 	}
; 378  : }

  0006a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006d	83 c4 04	 add	 esp, 4
  00070	33 cd		 xor	 ecx, ebp
  00072	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?NewLoadStoneAgeLUA@@YAXPAD@Z ENDP			; NewLoadStoneAgeLUA
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\mylua\winlua.cpp
;	COMDAT ?decryptLUA2@@YAHPAUlua_State@@PAD@Z
_TEXT	SEGMENT
_f$ = -264						; size = 4
_loadfilename$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_L$ = 8							; size = 4
_filename$ = 12						; size = 4
?decryptLUA2@@YAHPAUlua_State@@PAD@Z PROC		; decryptLUA2, COMDAT

; 212  : int decryptLUA2(lua_State *L, char *filename){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 213  : 	FILE *f;
; 214  : 	char loadfilename[256];
; 215  : 	int luamaxlen = 0;
; 216  : 	unsigned char *luabuff;
; 217  : 	strcpy(loadfilename, filename);

  00013	8b 45 0c	 mov	 eax, DWORD PTR _filename$[ebp]
  00016	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _loadfilename$[ebp]
  0001c	53		 push	 ebx
  0001d	8b 5d 08	 mov	 ebx, DWORD PTR _L$[ebp]
  00020	2b d0		 sub	 edx, eax
$LL5@decryptLUA:
  00022	8a 08		 mov	 cl, BYTE PTR [eax]
  00024	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00027	88 4c 02 ff	 mov	 BYTE PTR [edx+eax-1], cl
  0002b	84 c9		 test	 cl, cl
  0002d	75 f3		 jne	 SHORT $LL5@decryptLUA

; 218  : 	fopen_s(&f,loadfilename,"rb");//打开补丁1

  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  00034	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _loadfilename$[ebp]
  0003a	50		 push	 eax
  0003b	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _f$[ebp]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _fopen_s

; 219  : 	if (f!=NULL){

  00047	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _f$[ebp]
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00050	85 c0		 test	 eax, eax
  00052	0f 84 af 00 00
	00		 je	 $LN2@decryptLUA

; 220  : 		fseek(f,0,SEEK_END);

  00058	56		 push	 esi
  00059	57		 push	 edi
  0005a	6a 02		 push	 2
  0005c	6a 00		 push	 0
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 _fseek

; 221  : 		luamaxlen = ftell(f);

  00064	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _f$[ebp]
  0006a	e8 00 00 00 00	 call	 _ftell
  0006f	8b f0		 mov	 esi, eax

; 222  : 		luabuff = (unsigned char*)malloc(luamaxlen+1);

  00071	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 _malloc

; 223  : 		fseek(f,0,SEEK_SET);

  0007a	6a 00		 push	 0
  0007c	6a 00		 push	 0
  0007e	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _f$[ebp]
  00084	8b f8		 mov	 edi, eax
  00086	e8 00 00 00 00	 call	 _fseek

; 224  : 		fread(luabuff, 1, luamaxlen, f);

  0008b	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _f$[ebp]
  00091	56		 push	 esi
  00092	6a 01		 push	 1
  00094	57		 push	 edi
  00095	e8 00 00 00 00	 call	 _fread

; 225  : 		fclose(f);

  0009a	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _f$[ebp]
  000a0	e8 00 00 00 00	 call	 _fclose

; 226  : 		luabuff[luamaxlen]=0;
; 227  : 	}else{
; 228  : 		return -100;
; 229  : 	}
; 230  : #ifdef _LUA加密
; 231  : VMProtectBegin("lua");
; 232  : 	TEA解密((long*)luabuff,(luamaxlen/4),(long *)_LUA_KEY_);
; 233  : VMProtectEnd();
; 234  : #endif
; 235  : 	int status = luaL_dostring(L,(const char *)luabuff);

  000a5	57		 push	 edi
  000a6	53		 push	 ebx
  000a7	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
  000ab	e8 00 00 00 00	 call	 _luaL_loadstring
  000b0	83 c4 3c	 add	 esp, 60			; 0000003cH
  000b3	85 c0		 test	 eax, eax
  000b5	75 2f		 jne	 SHORT $LN6@decryptLUA
  000b7	50		 push	 eax
  000b8	6a ff		 push	 -1
  000ba	50		 push	 eax
  000bb	53		 push	 ebx
  000bc	e8 00 00 00 00	 call	 _lua_pcall
  000c1	83 c4 10	 add	 esp, 16			; 00000010H
  000c4	85 c0		 test	 eax, eax
  000c6	75 1e		 jne	 SHORT $LN6@decryptLUA

; 236  : 	free(luabuff);

  000c8	57		 push	 edi
  000c9	33 f6		 xor	 esi, esi
  000cb	e8 00 00 00 00	 call	 _free
  000d0	83 c4 04	 add	 esp, 4

; 237  : 	return status;

  000d3	8b c6		 mov	 eax, esi
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx

; 238  : }

  000d8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000db	33 cd		 xor	 ecx, ebp
  000dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c3		 ret	 0
$LN6@decryptLUA:

; 236  : 	free(luabuff);

  000e6	57		 push	 edi
  000e7	be 01 00 00 00	 mov	 esi, 1
  000ec	e8 00 00 00 00	 call	 _free
  000f1	83 c4 04	 add	 esp, 4

; 237  : 	return status;

  000f4	8b c6		 mov	 eax, esi
  000f6	5f		 pop	 edi
  000f7	5e		 pop	 esi
  000f8	5b		 pop	 ebx

; 238  : }

  000f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fc	33 cd		 xor	 ecx, ebp
  000fe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c3		 ret	 0
$LN2@decryptLUA:
  00107	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010a	b8 9c ff ff ff	 mov	 eax, -100		; ffffff9cH
  0010f	33 cd		 xor	 ecx, ebp
  00111	5b		 pop	 ebx
  00112	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c3		 ret	 0
?decryptLUA2@@YAHPAUlua_State@@PAD@Z ENDP		; decryptLUA2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\mylua\winlua.cpp
;	COMDAT ?decryptLUA@@YAHPAUlua_State@@PAD@Z
_TEXT	SEGMENT
_f$ = -264						; size = 4
_loadfilename$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_L$ = 8							; size = 4
_filename$ = 12						; size = 4
?decryptLUA@@YAHPAUlua_State@@PAD@Z PROC		; decryptLUA, COMDAT

; 184  : int decryptLUA(lua_State *L, char *filename){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 185  : 	FILE *f;
; 186  : 	char loadfilename[256];
; 187  : 	int luamaxlen = 0;
; 188  : 	unsigned char *luabuff;
; 189  : 	strcpy(loadfilename, filename);

  00013	8b 45 0c	 mov	 eax, DWORD PTR _filename$[ebp]
  00016	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _loadfilename$[ebp]
  0001c	53		 push	 ebx
  0001d	8b 5d 08	 mov	 ebx, DWORD PTR _L$[ebp]
  00020	2b d0		 sub	 edx, eax
$LL5@decryptLUA:
  00022	8a 08		 mov	 cl, BYTE PTR [eax]
  00024	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00027	88 4c 02 ff	 mov	 BYTE PTR [edx+eax-1], cl
  0002b	84 c9		 test	 cl, cl
  0002d	75 f3		 jne	 SHORT $LL5@decryptLUA

; 190  : 	fopen_s(&f,loadfilename,"rb");//打开补丁1

  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  00034	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _loadfilename$[ebp]
  0003a	50		 push	 eax
  0003b	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _f$[ebp]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _fopen_s

; 191  : 	if (f!=NULL){

  00047	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _f$[ebp]
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00050	85 c0		 test	 eax, eax
  00052	0f 84 af 00 00
	00		 je	 $LN2@decryptLUA

; 192  : 		fseek(f,0,SEEK_END);

  00058	56		 push	 esi
  00059	57		 push	 edi
  0005a	6a 02		 push	 2
  0005c	6a 00		 push	 0
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 _fseek

; 193  : 		luamaxlen = ftell(f);

  00064	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _f$[ebp]
  0006a	e8 00 00 00 00	 call	 _ftell
  0006f	8b f0		 mov	 esi, eax

; 194  : 		luabuff = (unsigned char*)malloc(luamaxlen+1);

  00071	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 _malloc

; 195  : 		fseek(f,0,SEEK_SET);

  0007a	6a 00		 push	 0
  0007c	6a 00		 push	 0
  0007e	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _f$[ebp]
  00084	8b f8		 mov	 edi, eax
  00086	e8 00 00 00 00	 call	 _fseek

; 196  : 		fread(luabuff, 1, luamaxlen, f);

  0008b	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _f$[ebp]
  00091	56		 push	 esi
  00092	6a 01		 push	 1
  00094	57		 push	 edi
  00095	e8 00 00 00 00	 call	 _fread

; 197  : 		fclose(f);

  0009a	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _f$[ebp]
  000a0	e8 00 00 00 00	 call	 _fclose

; 198  : 		luabuff[luamaxlen]=0;
; 199  : 	}else{
; 200  : 		return -100;
; 201  : 	}
; 202  : #ifdef _LUA加密
; 203  : VMProtectBegin("lua");
; 204  : 	TEA解密((long*)luabuff,(luamaxlen/4),(long *)VMProtectDecryptStringA(_LUA_KEY_));
; 205  : VMProtectEnd();
; 206  : #endif
; 207  : 	int status = luaL_dostring(L,(const char *)luabuff);

  000a5	57		 push	 edi
  000a6	53		 push	 ebx
  000a7	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
  000ab	e8 00 00 00 00	 call	 _luaL_loadstring
  000b0	83 c4 3c	 add	 esp, 60			; 0000003cH
  000b3	85 c0		 test	 eax, eax
  000b5	75 2f		 jne	 SHORT $LN6@decryptLUA
  000b7	50		 push	 eax
  000b8	6a ff		 push	 -1
  000ba	50		 push	 eax
  000bb	53		 push	 ebx
  000bc	e8 00 00 00 00	 call	 _lua_pcall
  000c1	83 c4 10	 add	 esp, 16			; 00000010H
  000c4	85 c0		 test	 eax, eax
  000c6	75 1e		 jne	 SHORT $LN6@decryptLUA

; 208  : 	free(luabuff);

  000c8	57		 push	 edi
  000c9	33 f6		 xor	 esi, esi
  000cb	e8 00 00 00 00	 call	 _free
  000d0	83 c4 04	 add	 esp, 4

; 209  : 	return status;

  000d3	8b c6		 mov	 eax, esi
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx

; 210  : }

  000d8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000db	33 cd		 xor	 ecx, ebp
  000dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c3		 ret	 0
$LN6@decryptLUA:

; 208  : 	free(luabuff);

  000e6	57		 push	 edi
  000e7	be 01 00 00 00	 mov	 esi, 1
  000ec	e8 00 00 00 00	 call	 _free
  000f1	83 c4 04	 add	 esp, 4

; 209  : 	return status;

  000f4	8b c6		 mov	 eax, esi
  000f6	5f		 pop	 edi
  000f7	5e		 pop	 esi
  000f8	5b		 pop	 ebx

; 210  : }

  000f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fc	33 cd		 xor	 ecx, ebp
  000fe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c3		 ret	 0
$LN2@decryptLUA:
  00107	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010a	b8 9c ff ff ff	 mov	 eax, -100		; ffffff9cH
  0010f	33 cd		 xor	 ecx, ebp
  00111	5b		 pop	 ebx
  00112	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c3		 ret	 0
?decryptLUA@@YAHPAUlua_State@@PAD@Z ENDP		; decryptLUA
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\mylua\winlua.cpp
;	COMDAT ?traceback@@YAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?traceback@@YAHPAUlua_State@@@Z PROC			; traceback, COMDAT

; 142  : static int traceback (lua_State *L) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 143  :   if (!lua_isstring(L, 1))  /* 'message' not a string? */

  00004	8b 75 08	 mov	 esi, DWORD PTR _L$[ebp]
  00007	6a 01		 push	 1
  00009	56		 push	 esi
  0000a	e8 00 00 00 00	 call	 _lua_isstring
  0000f	83 c4 08	 add	 esp, 8
  00012	85 c0		 test	 eax, eax
  00014	0f 84 80 00 00
	00		 je	 $LN6@traceback

; 144  :     return 1;  /* keep it intact */
; 145  :   lua_getfield(L, LUA_GLOBALSINDEX, "debug");

  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_05GFCDIDHO@debug@
  0001f	68 ee d8 ff ff	 push	 -10002			; ffffd8eeH
  00024	56		 push	 esi
  00025	e8 00 00 00 00	 call	 _lua_getfield

; 146  :   if (!lua_istable(L, -1)) {

  0002a	6a ff		 push	 -1
  0002c	56		 push	 esi
  0002d	e8 00 00 00 00	 call	 _lua_type
  00032	83 c4 14	 add	 esp, 20			; 00000014H
  00035	83 f8 05	 cmp	 eax, 5
  00038	74 13		 je	 SHORT $LN3@traceback

; 147  :     lua_pop(L, 1);

  0003a	6a fe		 push	 -2			; fffffffeH
  0003c	56		 push	 esi
  0003d	e8 00 00 00 00	 call	 _lua_settop
  00042	83 c4 08	 add	 esp, 8

; 158  :   return 1;
; 159  : }

  00045	b8 01 00 00 00	 mov	 eax, 1
  0004a	5e		 pop	 esi
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN3@traceback:

; 148  :     return 1;
; 149  :   }
; 150  :   lua_getfield(L, -1, "traceback");

  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_09GPFEECNC@traceback@
  00052	6a ff		 push	 -1
  00054	56		 push	 esi
  00055	e8 00 00 00 00	 call	 _lua_getfield

; 151  :   if (!lua_isfunction(L, -1)) {

  0005a	6a ff		 push	 -1
  0005c	56		 push	 esi
  0005d	e8 00 00 00 00	 call	 _lua_type
  00062	83 c4 14	 add	 esp, 20			; 00000014H
  00065	83 f8 06	 cmp	 eax, 6
  00068	74 13		 je	 SHORT $LN4@traceback

; 152  :     lua_pop(L, 2);

  0006a	6a fd		 push	 -3			; fffffffdH
  0006c	56		 push	 esi
  0006d	e8 00 00 00 00	 call	 _lua_settop
  00072	83 c4 08	 add	 esp, 8

; 158  :   return 1;
; 159  : }

  00075	b8 01 00 00 00	 mov	 eax, 1
  0007a	5e		 pop	 esi
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
$LN4@traceback:

; 153  :     return 1;
; 154  :   }
; 155  :   lua_pushvalue(L, 1);  /* pass error message */

  0007d	6a 01		 push	 1
  0007f	56		 push	 esi
  00080	e8 00 00 00 00	 call	 _lua_pushvalue

; 156  :   lua_pushinteger(L, 2);  /* skip this function and traceback */

  00085	6a 02		 push	 2
  00087	56		 push	 esi
  00088	e8 00 00 00 00	 call	 _lua_pushinteger

; 157  :   lua_call(L, 2, 1);  /* call debug.traceback */

  0008d	6a 01		 push	 1
  0008f	6a 02		 push	 2
  00091	56		 push	 esi
  00092	e8 00 00 00 00	 call	 _lua_call
  00097	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN6@traceback:

; 158  :   return 1;
; 159  : }

  0009a	b8 01 00 00 00	 mov	 eax, 1
  0009f	5e		 pop	 esi
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
?traceback@@YAHPAUlua_State@@@Z ENDP			; traceback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\mylua\winlua.cpp
;	COMDAT ?report@@YAHPAUlua_State@@H@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_status$ = 12						; size = 4
?report@@YAHPAUlua_State@@H@Z PROC			; report, COMDAT

; 132  : static int report (lua_State *L, int status) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 133  :   if (status && !lua_isnil(L, -1)) {

  00004	8b 75 0c	 mov	 esi, DWORD PTR _status$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 44		 je	 SHORT $LN5@report
  0000b	57		 push	 edi
  0000c	8b 7d 08	 mov	 edi, DWORD PTR _L$[ebp]
  0000f	6a ff		 push	 -1
  00011	57		 push	 edi
  00012	e8 00 00 00 00	 call	 _lua_type
  00017	83 c4 08	 add	 esp, 8
  0001a	85 c0		 test	 eax, eax
  0001c	74 2b		 je	 SHORT $LN6@report

; 134  :     const char *msg = lua_tostring(L, -1);

  0001e	6a 00		 push	 0
  00020	6a ff		 push	 -1
  00022	57		 push	 edi
  00023	e8 00 00 00 00	 call	 _lua_tolstring

; 135  :     if (msg == NULL) msg = "(error object is not a string)";

  00028	85 c0		 test	 eax, eax
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BP@LIDEPBBI@?$CIerror?5object?5is?5not?5a?5string?$CJ@
  0002f	0f 45 c8	 cmovne	 ecx, eax

; 136  :     l_message(progname, msg);

  00032	51		 push	 ecx
  00033	ff 35 00 00 00
	00		 push	 DWORD PTR ?progname@@3PBDB
  00039	e8 00 00 00 00	 call	 ?l_message@@YAXPBD0@Z	; l_message

; 137  :     lua_pop(L, 1);

  0003e	6a fe		 push	 -2			; fffffffeH
  00040	57		 push	 edi
  00041	e8 00 00 00 00	 call	 _lua_settop
  00046	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN6@report:

; 138  :   }
; 139  :   return status;

  00049	5f		 pop	 edi
  0004a	8b c6		 mov	 eax, esi
  0004c	5e		 pop	 esi

; 140  : }

  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
$LN5@report:

; 138  :   }
; 139  :   return status;

  0004f	8b c6		 mov	 eax, esi
  00051	5e		 pop	 esi

; 140  : }

  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?report@@YAHPAUlua_State@@H@Z ENDP			; report
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\mylua\winlua.cpp
;	COMDAT ?l_message@@YAXPBD0@Z
_TEXT	SEGMENT
_pname$ = 8						; size = 4
_msg$ = 12						; size = 4
?l_message@@YAXPBD0@Z PROC				; l_message, COMDAT

; 126  : static void l_message (const char *pname, const char *msg) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 127  :   if (pname) fprintf(stderr, "%s: ", pname);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pname$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 19		 je	 SHORT $LN2@l_message
  0000a	50		 push	 eax
  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_04PFAOODAA@?$CFs?3?5@
  00010	6a 02		 push	 2
  00012	e8 00 00 00 00	 call	 ___acrt_iob_func
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _fprintf
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@l_message:

; 128  :   fprintf(stderr, "%s\n", msg);

  00023	ff 75 0c	 push	 DWORD PTR _msg$[ebp]
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
  0002b	6a 02		 push	 2
  0002d	e8 00 00 00 00	 call	 ___acrt_iob_func
  00032	83 c4 04	 add	 esp, 4
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _fprintf

; 129  :   fflush(stderr);

  0003b	6a 02		 push	 2
  0003d	e8 00 00 00 00	 call	 ___acrt_iob_func
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _fflush
  00048	83 c4 14	 add	 esp, 20			; 00000014H

; 130  : }

  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?l_message@@YAXPBD0@Z ENDP				; l_message
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ PROC		; sprintf_s<256>, COMDAT

; 1840 :         )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1491 :         int const _Result = __stdio_common_vsprintf_s(

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	68 00 01 00 00	 push	 256			; 00000100H
  00011	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00014	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	ff 30		 push	 DWORD PTR [eax]
  0001e	e8 00 00 00 00	 call	 ___stdio_common_vsprintf_s

; 1492 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1493 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1494 : 
; 1495 :         return _Result < 0 ? -1 : _Result;

  00023	83 c9 ff	 or	 ecx, -1
  00026	83 c4 1c	 add	 esp, 28			; 0000001cH
  00029	85 c0		 test	 eax, eax
  0002b	0f 48 c1	 cmovs	 eax, ecx

; 1496 :     }
; 1497 :     #endif
; 1498 : 
; 1499 :     #if __STDC_WANT_SECURE_LIB__
; 1500 : 
; 1501 :         _Success_(return >= 0)
; 1502 :         _Check_return_opt_
; 1503 :         _CRT_STDIO_INLINE int __CRTDECL vsprintf_s(
; 1504 :             _Out_writes_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
; 1505 :             _In_                                          size_t      const _BufferCount,
; 1506 :             _In_z_ _Printf_format_string_                 char const* const _Format,
; 1507 :                                                           va_list           _ArgList
; 1508 :             )
; 1509 :     #if defined _NO_CRT_STDIO_INLINE
; 1510 :     ;
; 1511 :     #else
; 1512 :         {
; 1513 :             return _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1514 :         }
; 1515 :     #endif
; 1516 : 
; 1517 :         __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
; 1518 :             _Success_(return >= 0)
; 1519 :             int, vsprintf_s,
; 1520 :             _Always_(_Post_z_)            char,        _Buffer,
; 1521 :             _In_z_ _Printf_format_string_ char const*, _Format,
; 1522 :                                           va_list,     _ArgList
; 1523 :             )
; 1524 : 
; 1525 :     #endif
; 1526 : 
; 1527 :     _Success_(return >= 0)
; 1528 :     _Check_return_opt_
; 1529 :     _CRT_STDIO_INLINE int __CRTDECL _vsprintf_p_l(
; 1530 :         _Out_writes_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
; 1531 :         _In_                                          size_t      const _BufferCount,
; 1532 :         _In_z_ _Printf_format_string_params_(2)       char const* const _Format,
; 1533 :         _In_opt_                                      _locale_t   const _Locale,
; 1534 :                                                       va_list           _ArgList
; 1535 :         )
; 1536 :     #if defined _NO_CRT_STDIO_INLINE
; 1537 :     ;
; 1538 :     #else
; 1539 :     {
; 1540 :         int const _Result = __stdio_common_vsprintf_p(
; 1541 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1542 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1543 : 
; 1544 :         return _Result < 0 ? -1 : _Result;
; 1545 :     }
; 1546 :     #endif
; 1547 : 
; 1548 :     _Success_(return >= 0)
; 1549 :     _Check_return_opt_
; 1550 :     _CRT_STDIO_INLINE int __CRTDECL _vsprintf_p(
; 1551 :         _Out_writes_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
; 1552 :         _In_                                          size_t      const _BufferCount,
; 1553 :         _In_z_ _Printf_format_string_                 char const* const _Format,
; 1554 :                                                       va_list           _ArgList
; 1555 :         )
; 1556 :     #if defined _NO_CRT_STDIO_INLINE
; 1557 :     ;
; 1558 :     #else
; 1559 :     {
; 1560 :         return _vsprintf_p_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1561 :     }
; 1562 :     #endif
; 1563 : 
; 1564 :     _Success_(return >= 0)
; 1565 :     _Check_return_opt_
; 1566 :     _CRT_STDIO_INLINE int __CRTDECL _vsnprintf_s_l(
; 1567 :         _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
; 1568 :         _In_                                              size_t      const _BufferCount,
; 1569 :         _In_                                              size_t      const _MaxCount,
; 1570 :         _In_z_ _Printf_format_string_params_(2)           char const* const _Format,
; 1571 :         _In_opt_                                          _locale_t   const _Locale,
; 1572 :                                                           va_list          _ArgList
; 1573 :         )
; 1574 :     #if defined _NO_CRT_STDIO_INLINE
; 1575 :     ;
; 1576 :     #else
; 1577 :     {
; 1578 :         int const _Result = __stdio_common_vsnprintf_s(
; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;
; 1583 :     }
; 1584 :     #endif
; 1585 : 
; 1586 :     _Success_(return >= 0)
; 1587 :     _Check_return_opt_
; 1588 :     _CRT_STDIO_INLINE int __CRTDECL _vsnprintf_s(
; 1589 :         _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
; 1590 :         _In_                                              size_t      const _BufferCount,
; 1591 :         _In_                                              size_t      const _MaxCount,
; 1592 :         _In_z_ _Printf_format_string_                     char const* const _Format,
; 1593 :                                                           va_list           _ArgList
; 1594 :         )
; 1595 :     #if defined _NO_CRT_STDIO_INLINE
; 1596 :     ;
; 1597 :     #else
; 1598 :     {
; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);
; 1600 :     }
; 1601 :     #endif
; 1602 : 
; 1603 :     __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(
; 1604 :         _Success_(return >= 0)
; 1605 :         int, _vsnprintf_s,
; 1606 :         _Always_(_Post_z_)            char,        _Buffer,
; 1607 :         _In_                          size_t,      _BufferCount,
; 1608 :         _In_z_ _Printf_format_string_ char const*, _Format,
; 1609 :                                       va_list,     _ArgList
; 1610 :         )
; 1611 : 
; 1612 :     #if __STDC_WANT_SECURE_LIB__
; 1613 : 
; 1614 :         _Success_(return >= 0)
; 1615 :         _Check_return_opt_
; 1616 :         _CRT_STDIO_INLINE int __CRTDECL vsnprintf_s(
; 1617 :             _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
; 1618 :             _In_                                              size_t      const _BufferCount,
; 1619 :             _In_                                              size_t      const _MaxCount,
; 1620 :             _In_z_ _Printf_format_string_                     char const* const _Format,
; 1621 :                                                               va_list           _ArgList
; 1622 :             )
; 1623 :     #if defined _NO_CRT_STDIO_INLINE
; 1624 :     ;
; 1625 :     #else
; 1626 :         {
; 1627 :             return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);
; 1628 :         }
; 1629 :     #endif
; 1630 : 
; 1631 :         __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(
; 1632 :             _Success_(return >= 0)
; 1633 :             int, vsnprintf_s,
; 1634 :             _Always_(_Post_z_)            char,        _Buffer,
; 1635 :             _In_                          size_t,      _BufferCount,
; 1636 :             _In_z_ _Printf_format_string_ char const*, _Format,
; 1637 :                                           va_list,     _ArgList
; 1638 :             )
; 1639 : 
; 1640 :     #endif
; 1641 : 
; 1642 :     _Check_return_opt_
; 1643 :     _CRT_STDIO_INLINE int __CRTDECL _vscprintf_l(
; 1644 :         _In_z_ _Printf_format_string_params_(2) char const* const _Format,
; 1645 :         _In_opt_                                _locale_t   const _Locale,
; 1646 :                                                 va_list           _ArgList
; 1647 :         )
; 1648 :     #if defined _NO_CRT_STDIO_INLINE
; 1649 :     ;
; 1650 :     #else
; 1651 :     {
; 1652 :         int const _Result = __stdio_common_vsprintf(
; 1653 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1654 :             NULL, 0, _Format, _Locale, _ArgList);
; 1655 : 
; 1656 :         return _Result < 0 ? -1 : _Result;
; 1657 :     }
; 1658 :     #endif
; 1659 : 
; 1660 :     _Check_return_
; 1661 :     _CRT_STDIO_INLINE int __CRTDECL _vscprintf(
; 1662 :         _In_z_ _Printf_format_string_ char const* const _Format,
; 1663 :                                       va_list           _ArgList
; 1664 :         )
; 1665 :     #if defined _NO_CRT_STDIO_INLINE
; 1666 :     ;
; 1667 :     #else
; 1668 :     {
; 1669 :         return _vscprintf_l(_Format, NULL, _ArgList);
; 1670 :     }
; 1671 :     #endif
; 1672 : 
; 1673 :     _Check_return_opt_
; 1674 :     _CRT_STDIO_INLINE int __CRTDECL _vscprintf_p_l(
; 1675 :         _In_z_ _Printf_format_string_params_(2) char const* const _Format,
; 1676 :         _In_opt_                                _locale_t   const _Locale,
; 1677 :                                                 va_list           _ArgList
; 1678 :         )
; 1679 :     #if defined _NO_CRT_STDIO_INLINE
; 1680 :     ;
; 1681 :     #else
; 1682 :     {
; 1683 :         int const _Result = __stdio_common_vsprintf_p(
; 1684 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1685 :             NULL, 0, _Format, _Locale, _ArgList);
; 1686 : 
; 1687 :         return _Result < 0 ? -1 : _Result;
; 1688 :     }
; 1689 :     #endif
; 1690 : 
; 1691 :     _Check_return_
; 1692 :     _CRT_STDIO_INLINE int __CRTDECL _vscprintf_p(
; 1693 :         _In_z_ _Printf_format_string_ char const* const _Format,
; 1694 :                                       va_list           _ArgList
; 1695 :         )
; 1696 :     #if defined _NO_CRT_STDIO_INLINE
; 1697 :     ;
; 1698 :     #else
; 1699 :     {
; 1700 :         return _vscprintf_p_l(_Format, NULL, _ArgList);
; 1701 :     }
; 1702 :     #endif
; 1703 : 
; 1704 :     _Check_return_opt_
; 1705 :     _CRT_STDIO_INLINE int __CRTDECL _vsnprintf_c_l(
; 1706 :         _Out_writes_opt_(_BufferCount)          char*       const _Buffer,
; 1707 :         _In_                                    size_t      const _BufferCount,
; 1708 :         _In_z_ _Printf_format_string_params_(2) char const* const _Format,
; 1709 :         _In_opt_                                _locale_t   const _Locale,
; 1710 :                                                 va_list           _ArgList
; 1711 :         )
; 1712 :     #if defined _NO_CRT_STDIO_INLINE
; 1713 :     ;
; 1714 :     #else
; 1715 :     {
; 1716 :         int const _Result = __stdio_common_vsprintf(
; 1717 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1718 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1719 : 
; 1720 :         return _Result < 0 ? -1 : _Result;
; 1721 :     }
; 1722 :     #endif
; 1723 : 
; 1724 :     _Success_(return >= 0)
; 1725 :     _Check_return_opt_
; 1726 :     _CRT_STDIO_INLINE int __CRTDECL _vsnprintf_c(
; 1727 :         _Out_writes_opt_(_BufferCount) char*       const _Buffer,
; 1728 :         _In_                           size_t      const _BufferCount,
; 1729 :         _In_z_ _Printf_format_string_  char const* const _Format,
; 1730 :                                        va_list           _ArgList
; 1731 :         )
; 1732 :     #if defined _NO_CRT_STDIO_INLINE
; 1733 :     ;
; 1734 :     #else
; 1735 :     {
; 1736 :         return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1737 :     }
; 1738 :     #endif
; 1739 : 
; 1740 :     _Success_(return >= 0)
; 1741 :     _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_sprintf_s_l)
; 1742 :     _CRT_STDIO_INLINE int __CRTDECL _sprintf_l(
; 1743 :         _Pre_notnull_ _Always_(_Post_z_)        char*       const _Buffer,
; 1744 :         _In_z_ _Printf_format_string_params_(0) char const* const _Format,
; 1745 :         _In_opt_                                _locale_t   const _Locale,
; 1746 :         ...)
; 1747 :     #if defined _NO_CRT_STDIO_INLINE
; 1748 :     ;
; 1749 :     #else
; 1750 :     {
; 1751 :         int _Result;
; 1752 :         va_list _ArgList;
; 1753 :         __crt_va_start(_ArgList, _Locale);
; 1754 : 
; 1755 :         _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);
; 1756 : 
; 1757 :         __crt_va_end(_ArgList);
; 1758 :         return _Result;
; 1759 :     }
; 1760 :     #endif
; 1761 : 
; 1762 :     _Success_(return >= 0)
; 1763 :     _Check_return_opt_
; 1764 :     _CRT_STDIO_INLINE int __CRTDECL sprintf(
; 1765 :         _Pre_notnull_ _Always_(_Post_z_) char*       const _Buffer,
; 1766 :         _In_z_ _Printf_format_string_    char const* const _Format,
; 1767 :         ...)
; 1768 :     #if defined _NO_CRT_STDIO_INLINE
; 1769 :     ;
; 1770 :     #else
; 1771 :     {
; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);
; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1777 : 
; 1778 :         __crt_va_end(_ArgList);
; 1779 :         return _Result;
; 1780 :     }
; 1781 :     #endif
; 1782 : 
; 1783 :     __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST(
; 1784 :         _Success_(return >= 0)
; 1785 :         int, __RETURN_POLICY_SAME, __EMPTY_DECLSPEC, __CRTDECL, sprintf, vsprintf,
; 1786 :         _Pre_notnull_ _Always_(_Post_z_), char,        _Buffer,
; 1787 :         _In_z_ _Printf_format_string_     char const*, _Format
; 1788 :         )
; 1789 : 
; 1790 :     _Success_(return >= 0)
; 1791 :     _Check_return_opt_
; 1792 :     _CRT_STDIO_INLINE int __CRTDECL _sprintf_s_l(
; 1793 :         _Out_writes_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
; 1794 :         _In_                                          size_t      const _BufferCount,
; 1795 :         _In_z_ _Printf_format_string_params_(0)       char const* const _Format,
; 1796 :         _In_opt_                                      _locale_t   const _Locale,
; 1797 :         ...)
; 1798 :     #if defined _NO_CRT_STDIO_INLINE
; 1799 :     ;
; 1800 :     #else
; 1801 :     {
; 1802 :         int _Result;
; 1803 :         va_list _ArgList;
; 1804 :         __crt_va_start(_ArgList, _Locale);
; 1805 :         _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1806 :         __crt_va_end(_ArgList);
; 1807 :         return _Result;
; 1808 :     }
; 1809 :     #endif
; 1810 : 
; 1811 :     #if __STDC_WANT_SECURE_LIB__
; 1812 : 
; 1813 :         _Success_(return >= 0)
; 1814 :         _Check_return_opt_
; 1815 :         _CRT_STDIO_INLINE int __CRTDECL sprintf_s(
; 1816 :             _Out_writes_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
; 1817 :             _In_                                          size_t      const _BufferCount,
; 1818 :             _In_z_ _Printf_format_string_                 char const* const _Format,
; 1819 :             ...)
; 1820 :     #if defined _NO_CRT_STDIO_INLINE
; 1821 :     ;
; 1822 :     #else
; 1823 :         {
; 1824 :             int _Result;
; 1825 :             va_list _ArgList;
; 1826 :             __crt_va_start(_ArgList, _Format);
; 1827 :             _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1828 :             __crt_va_end(_ArgList);
; 1829 :             return _Result;
; 1830 :         }
; 1831 :     #endif
; 1832 : 
; 1833 :     #endif
; 1834 : 
; 1835 :     __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ENDP		; sprintf_s<256>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\mylua\winlua.cpp
;	COMDAT ?FreeGetBattleMap@@YAHH@Z
_TEXT	SEGMENT
tv148 = -268						; size = 8
_filename$1 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_floor$ = 8						; size = 4
?FreeGetBattleMap@@YAHH@Z PROC				; FreeGetBattleMap, COMDAT

; 397  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	57		 push	 edi

; 398  : 	lua_State *lua = NULL;
; 399  : 	if (lua == NULL){
; 400  : 		char filename[256];
; 401  : #ifdef _LUA加密
; 402  : 		sprintf_s(filename, "%s//map//battlemap.sq",_LUA_PATCH_);
; 403  : #else
; 404  : 		sprintf_s(filename, "%s//map//battlemap.lua",_LUA_PATCH_);

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_06BHFGNFJA@?4?1?1lua@
  0001a	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _filename$1[ebp]
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@EIPJDOPB@?$CFs?1?1map?1?1battlemap?4lua@
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ; sprintf_s<256>

; 405  : #endif
; 406  : 		lua = FindLua(filename);

  0002b	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _filename$1[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ?FindLua@@YAPAUlua_State@@PAD@Z ; FindLua
  00037	8b f8		 mov	 edi, eax
  00039	83 c4 10	 add	 esp, 16			; 00000010H

; 407  : 		if (lua == NULL)return NULL;

  0003c	85 ff		 test	 edi, edi
  0003e	74 40		 je	 SHORT $LN8@FreeGetBat

; 408  : 	}
; 409  : 	lua_getglobal(lua, "FreeGetBattleMap");

  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@BDENLLEH@FreeGetBattleMap@
  00045	68 ee d8 ff ff	 push	 -10002			; ffffd8eeH
  0004a	57		 push	 edi
  0004b	e8 00 00 00 00	 call	 _lua_getfield

; 410  : 	if (!lua_isfunction(lua, -1)) {

  00050	6a ff		 push	 -1
  00052	57		 push	 edi
  00053	e8 00 00 00 00	 call	 _lua_type
  00058	83 c4 14	 add	 esp, 20			; 00000014H
  0005b	83 f8 06	 cmp	 eax, 6
  0005e	74 32		 je	 SHORT $LN4@FreeGetBat

; 411  : 		printf("FreeGetBattleMap 错误内容 (%s)\n", lua_tostring(lua, -1));

  00060	6a 00		 push	 0
  00062	6a ff		 push	 -1
  00064	57		 push	 edi
  00065	e8 00 00 00 00	 call	 _lua_tolstring
  0006a	50		 push	 eax
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@LFGCKIJG@FreeGetBattleMap?5?$DP?$DP?$DP?i?$LL?5?$CI?$CFs?$CJ?6@
  00070	e8 00 00 00 00	 call	 _printf

; 412  : 		lua_pop(lua, 1);

  00075	6a fe		 push	 -2			; fffffffeH
  00077	57		 push	 edi
  00078	e8 00 00 00 00	 call	 _lua_settop
  0007d	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN8@FreeGetBat:

; 427  : 	return ret;
; 428  : }

  00080	5f		 pop	 edi
  00081	33 c0		 xor	 eax, eax
  00083	5e		 pop	 esi
  00084	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00087	33 cd		 xor	 ecx, ebp
  00089	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
$LN4@FreeGetBat:
  00092	66 0f 6e 45 08	 movd	 xmm0, DWORD PTR _floor$[ebp]

; 413  : 		return NULL;
; 414  : 	}
; 415  : 	lua_pushnumber(lua, floor); 

  00097	83 ec 08	 sub	 esp, 8
  0009a	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0009e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000a3	57		 push	 edi
  000a4	e8 00 00 00 00	 call	 _lua_pushnumber

; 416  : 	int TM_Ret = lua_pcall(lua, 1, 1, 0);

  000a9	6a 00		 push	 0
  000ab	6a 01		 push	 1
  000ad	6a 01		 push	 1
  000af	57		 push	 edi
  000b0	e8 00 00 00 00	 call	 _lua_pcall
  000b5	8b f0		 mov	 esi, eax
  000b7	83 c4 1c	 add	 esp, 28			; 0000001cH

; 417  : 
; 418  : 	if (TM_Ret != 0){

  000ba	85 f6		 test	 esi, esi
  000bc	74 33		 je	 SHORT $LN5@FreeGetBat

; 419  : 		printf("入口：FreeGetBattleMap 错误内容:%d(%s)\n", TM_Ret, lua_tostring(lua, -1));

  000be	6a 00		 push	 0
  000c0	6a ff		 push	 -1
  000c2	57		 push	 edi
  000c3	e8 00 00 00 00	 call	 _lua_tolstring
  000c8	50		 push	 eax
  000c9	56		 push	 esi
  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@OPCDIGNC@?l?$PN?O?$KC?$KD?$LKFreeGetBattleMap?5?$DP?$DP?$DP?i?$LL?3?$CFd@
  000cf	e8 00 00 00 00	 call	 _printf

; 420  : 		lua_pop(lua, 1);

  000d4	6a fe		 push	 -2			; fffffffeH
  000d6	57		 push	 edi
  000d7	e8 00 00 00 00	 call	 _lua_settop
  000dc	83 c4 20	 add	 esp, 32			; 00000020H

; 427  : 	return ret;
; 428  : }

  000df	33 c0		 xor	 eax, eax
  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi
  000e3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e6	33 cd		 xor	 ecx, ebp
  000e8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c3		 ret	 0
$LN5@FreeGetBat:

; 421  : 		return NULL;
; 422  : 	}
; 423  : 	if (!lua_isnumber(lua, -1))

  000f1	6a ff		 push	 -1
  000f3	57		 push	 edi
  000f4	e8 00 00 00 00	 call	 _lua_isnumber
  000f9	83 c4 08	 add	 esp, 8
  000fc	85 c0		 test	 eax, eax
  000fe	74 80		 je	 SHORT $LN8@FreeGetBat

; 424  : 		return NULL;
; 425  : 	int ret = (int)lua_tonumber(lua, -1);

  00100	6a ff		 push	 -1
  00102	57		 push	 edi
  00103	e8 00 00 00 00	 call	 _lua_tonumber

; 426  : 	lua_pop(lua, 1);

  00108	6a fe		 push	 -2			; fffffffeH
  0010a	dd 9d f4 fe ff
	ff		 fstp	 QWORD PTR tv148[ebp]
  00110	f2 0f 2c b5 f4
	fe ff ff	 cvttsd2si esi, QWORD PTR tv148[ebp]
  00118	57		 push	 edi
  00119	e8 00 00 00 00	 call	 _lua_settop

; 427  : 	return ret;
; 428  : }

  0011e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00121	83 c4 10	 add	 esp, 16			; 00000010H
  00124	8b c6		 mov	 eax, esi
  00126	33 cd		 xor	 ecx, ebp
  00128	5f		 pop	 edi
  00129	5e		 pop	 esi
  0012a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c3		 ret	 0
?FreeGetBattleMap@@YAHH@Z ENDP				; FreeGetBattleMap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\mylua\winlua.cpp
;	COMDAT ?ReLoadStoneAgeLUA@@YAXPAD@Z
_TEXT	SEGMENT
_filename$ = 8						; size = 4
?ReLoadStoneAgeLUA@@YAXPAD@Z PROC			; ReLoadStoneAgeLUA, COMDAT

; 366  : 	//printf("\n%s",filename);
; 367  : 	remyluaload(filename);

  00000	e9 00 00 00 00	 jmp	 ?remyluaload@@YAHPAD@Z	; remyluaload
?ReLoadStoneAgeLUA@@YAXPAD@Z ENDP			; ReLoadStoneAgeLUA
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\mylua\winlua.cpp
;	COMDAT ?FreeServerWinTypeLua@@YAPAUaction@@PAUlua_State@@@Z
_TEXT	SEGMENT
tv129 = -8						; size = 8
_lua$ = 8						; size = 4
?FreeServerWinTypeLua@@YAPAUaction@@PAUlua_State@@@Z PROC ; FreeServerWinTypeLua, COMDAT

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi

; 75   : 	if (lua == NULL){

  00008	8b 7d 08	 mov	 edi, DWORD PTR _lua$[ebp]
  0000b	85 ff		 test	 edi, edi
  0000d	74 46		 je	 SHORT $LN6@FreeServer

; 76   : 		return NULL;
; 77   : 	}
; 78   : 	lua_getglobal(lua, "ServerWindowType");

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@ELCOHPIG@ServerWindowType@
  00014	68 ee d8 ff ff	 push	 -10002			; ffffd8eeH
  00019	57		 push	 edi
  0001a	e8 00 00 00 00	 call	 _lua_getfield

; 79   : 	int TM_Ret = lua_pcall(lua, 0, 1, 0);

  0001f	6a 00		 push	 0
  00021	6a 01		 push	 1
  00023	6a 00		 push	 0
  00025	57		 push	 edi
  00026	e8 00 00 00 00	 call	 _lua_pcall
  0002b	8b f0		 mov	 esi, eax
  0002d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 80   : 
; 81   : 	if (TM_Ret != 0){

  00030	85 f6		 test	 esi, esi
  00032	74 29		 je	 SHORT $LN3@FreeServer

; 82   : 		printf("入口：FreeServerWinTypeLua 错误内容:%d(%s)\n", TM_Ret, lua_tostring(lua, -1));

  00034	6a 00		 push	 0
  00036	6a ff		 push	 -1
  00038	57		 push	 edi
  00039	e8 00 00 00 00	 call	 _lua_tolstring
  0003e	50		 push	 eax
  0003f	56		 push	 esi
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@EEFCGKJC@?l?$PN?O?$KC?$KD?$LKFreeServerWinTypeLua?5?$DP?$DP?$DP?i@
  00045	e8 00 00 00 00	 call	 _printf

; 83   : 		lua_pop(lua, 1);

  0004a	6a fe		 push	 -2			; fffffffeH
  0004c	57		 push	 edi
  0004d	e8 00 00 00 00	 call	 _lua_settop
  00052	83 c4 20	 add	 esp, 32			; 00000020H
$LN6@FreeServer:

; 91   : }

  00055	5f		 pop	 edi
  00056	33 c0		 xor	 eax, eax
  00058	5e		 pop	 esi
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
$LN3@FreeServer:

; 84   : 		return NULL;
; 85   : 	}
; 86   : 	if (!lua_isnumber(lua, -1))

  0005d	6a ff		 push	 -1
  0005f	57		 push	 edi
  00060	e8 00 00 00 00	 call	 _lua_isnumber
  00065	83 c4 08	 add	 esp, 8
  00068	85 c0		 test	 eax, eax
  0006a	74 e9		 je	 SHORT $LN6@FreeServer

; 87   : 		return NULL;
; 88   : 	int ret = (int)lua_tonumber(lua, -1);

  0006c	6a ff		 push	 -1
  0006e	57		 push	 edi
  0006f	e8 00 00 00 00	 call	 _lua_tonumber

; 89   : 	lua_pop(lua, 1);

  00074	6a fe		 push	 -2			; fffffffeH
  00076	dd 5d f8	 fstp	 QWORD PTR tv129[ebp]
  00079	f2 0f 2c 75 f8	 cvttsd2si esi, QWORD PTR tv129[ebp]
  0007e	57		 push	 edi
  0007f	e8 00 00 00 00	 call	 _lua_settop
  00084	83 c4 10	 add	 esp, 16			; 00000010H

; 90   : 	return (ACTION *)ret;

  00087	8b c6		 mov	 eax, esi
  00089	5f		 pop	 edi

; 91   : }

  0008a	5e		 pop	 esi
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
?FreeServerWinTypeLua@@YAPAUaction@@PAUlua_State@@@Z ENDP ; FreeServerWinTypeLua
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\mylua\winlua.cpp
;	COMDAT ?FreeCreateWinTypeLua@@YAPAUaction@@PAUlua_State@@@Z
_TEXT	SEGMENT
tv160 = -8						; size = 8
_lua$ = 8						; size = 4
?FreeCreateWinTypeLua@@YAPAUaction@@PAUlua_State@@@Z PROC ; FreeCreateWinTypeLua, COMDAT

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi

; 46   : 	if (lua == NULL){

  00008	8b 7d 08	 mov	 edi, DWORD PTR _lua$[ebp]
  0000b	85 ff		 test	 edi, edi
  0000d	74 2b		 je	 SHORT $LN7@FreeCreate

; 47   : 		return NULL;
; 48   : 	}
; 49   : 
; 50   : 	lua_getglobal(lua, "CreateWinType");

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@OFCFMCFI@CreateWinType@
  00014	68 ee d8 ff ff	 push	 -10002			; ffffd8eeH
  00019	57		 push	 edi
  0001a	e8 00 00 00 00	 call	 _lua_getfield

; 51   : 
; 52   : 	if (!lua_isfunction(lua, -1)) {

  0001f	6a ff		 push	 -1
  00021	57		 push	 edi
  00022	e8 00 00 00 00	 call	 _lua_type
  00027	83 c4 14	 add	 esp, 20			; 00000014H
  0002a	83 f8 06	 cmp	 eax, 6
  0002d	74 13		 je	 SHORT $LN3@FreeCreate

; 53   : 		lua_pop(lua, 1);

  0002f	6a fe		 push	 -2			; fffffffeH
  00031	57		 push	 edi
  00032	e8 00 00 00 00	 call	 _lua_settop
  00037	83 c4 08	 add	 esp, 8
$LN7@FreeCreate:

; 71   : }

  0003a	5f		 pop	 edi
  0003b	33 c0		 xor	 eax, eax
  0003d	5e		 pop	 esi
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
$LN3@FreeCreate:

; 54   : 		return NULL;
; 55   : 	}
; 56   : 
; 57   : 	int TM_Ret = lua_pcall(lua, 0, 1, 0);

  00042	6a 00		 push	 0
  00044	6a 01		 push	 1
  00046	6a 00		 push	 0
  00048	57		 push	 edi
  00049	e8 00 00 00 00	 call	 _lua_pcall
  0004e	8b f0		 mov	 esi, eax
  00050	83 c4 10	 add	 esp, 16			; 00000010H

; 58   : 
; 59   : 	if (TM_Ret != 0){

  00053	85 f6		 test	 esi, esi
  00055	74 29		 je	 SHORT $LN4@FreeCreate

; 60   : 		printf("入口：FreeCreateWinTypeLua 错误内容:%d(%s)\n", TM_Ret, lua_tostring(lua, -1));

  00057	6a 00		 push	 0
  00059	6a ff		 push	 -1
  0005b	57		 push	 edi
  0005c	e8 00 00 00 00	 call	 _lua_tolstring
  00061	50		 push	 eax
  00062	56		 push	 esi
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@EGHDEEMJ@?l?$PN?O?$KC?$KD?$LKFreeCreateWinTypeLua?5?$DP?$DP?$DP?i@
  00068	e8 00 00 00 00	 call	 _printf

; 61   : 		lua_pop(lua, 1);

  0006d	6a fe		 push	 -2			; fffffffeH
  0006f	57		 push	 edi
  00070	e8 00 00 00 00	 call	 _lua_settop
  00075	83 c4 20	 add	 esp, 32			; 00000020H

; 71   : }

  00078	33 c0		 xor	 eax, eax
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
$LN4@FreeCreate:

; 62   : 		return NULL;
; 63   : 	}
; 64   : 
; 65   : 	if (!lua_isnumber(lua, -1))

  00080	6a ff		 push	 -1
  00082	57		 push	 edi
  00083	e8 00 00 00 00	 call	 _lua_isnumber
  00088	83 c4 08	 add	 esp, 8
  0008b	85 c0		 test	 eax, eax
  0008d	74 ab		 je	 SHORT $LN7@FreeCreate

; 66   : 		return NULL;
; 67   : 
; 68   : 	int ret = (int)lua_tonumber(lua, -1);

  0008f	6a ff		 push	 -1
  00091	57		 push	 edi
  00092	e8 00 00 00 00	 call	 _lua_tonumber

; 69   : 	lua_pop(lua, 1);

  00097	6a fe		 push	 -2			; fffffffeH
  00099	dd 5d f8	 fstp	 QWORD PTR tv160[ebp]
  0009c	f2 0f 2c 75 f8	 cvttsd2si esi, QWORD PTR tv160[ebp]
  000a1	57		 push	 edi
  000a2	e8 00 00 00 00	 call	 _lua_settop
  000a7	83 c4 10	 add	 esp, 16			; 00000010H

; 70   : 	return (ACTION *)ret;

  000aa	8b c6		 mov	 eax, esi
  000ac	5f		 pop	 edi

; 71   : }

  000ad	5e		 pop	 esi
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
?FreeCreateWinTypeLua@@YAPAUaction@@PAUlua_State@@@Z ENDP ; FreeCreateWinTypeLua
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\mylua\winlua.cpp
;	COMDAT ?FindWinIntLua@@YAPAUlua_State@@HPAD@Z
_TEXT	SEGMENT
_filename$1 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_wintype$ = 8						; size = 4
_data$ = 12						; size = 4
?FindWinIntLua@@YAPAUlua_State@@HPAD@Z PROC		; FindWinIntLua, COMDAT

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	57		 push	 edi

; 23   : 	lua_State *lua = NULL;
; 24   : 	if (lua == NULL){
; 25   : 		char filename[256];
; 26   : #ifdef _LUA加密
; 27   : 		sprintf_s(filename, "%s//win//%d.sq", _LUA_PATCH_, wintype);
; 28   : #else
; 29   : 		sprintf_s(filename, "%s//win//%d.lua", _LUA_PATCH_, wintype);

  00015	ff 75 08	 push	 DWORD PTR _wintype$[ebp]
  00018	8b 7d 0c	 mov	 edi, DWORD PTR _data$[ebp]
  0001b	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _filename$1[ebp]
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_06BHFGNFJA@?4?1?1lua@
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@IALLELID@?$CFs?1?1win?1?1?$CFd?4lua@
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ; sprintf_s<256>

; 30   : #endif
; 31   : 		lua = FindLua(filename);

  00031	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _filename$1[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?FindLua@@YAPAUlua_State@@PAD@Z ; FindLua
  0003d	8b f0		 mov	 esi, eax
  0003f	83 c4 14	 add	 esp, 20			; 00000014H

; 32   : 		if (lua == NULL)return NULL;

  00042	85 f6		 test	 esi, esi
  00044	74 2b		 je	 SHORT $LN6@FindWinInt

; 33   : 	}
; 34   : 	lua_getglobal(lua, "WindowInit");

  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MBJJKKFJ@WindowInit@
  0004b	68 ee d8 ff ff	 push	 -10002			; ffffd8eeH
  00050	56		 push	 esi
  00051	e8 00 00 00 00	 call	 _lua_getfield

; 35   : 	if (!lua_isfunction(lua, -1)){

  00056	6a ff		 push	 -1
  00058	56		 push	 esi
  00059	e8 00 00 00 00	 call	 _lua_type
  0005e	83 c4 14	 add	 esp, 20			; 00000014H
  00061	83 f8 06	 cmp	 eax, 6
  00064	74 1d		 je	 SHORT $LN4@FindWinInt

; 36   : 		lua_pop(lua, 1);

  00066	6a fe		 push	 -2			; fffffffeH
  00068	56		 push	 esi
  00069	e8 00 00 00 00	 call	 _lua_settop
  0006e	83 c4 08	 add	 esp, 8
$LN6@FindWinInt:

; 41   : 	return lua;
; 42   : }

  00071	5f		 pop	 edi
  00072	33 c0		 xor	 eax, eax
  00074	5e		 pop	 esi
  00075	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00078	33 cd		 xor	 ecx, ebp
  0007a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
$LN4@FindWinInt:

; 37   : 		return NULL;
; 38   : 	}
; 39   : 	lua_pushstring(lua, data); 

  00083	57		 push	 edi
  00084	56		 push	 esi
  00085	e8 00 00 00 00	 call	 _lua_pushstring

; 40   : 	docall(lua, 1, 1);

  0008a	6a 01		 push	 1
  0008c	6a 01		 push	 1
  0008e	56		 push	 esi
  0008f	e8 00 00 00 00	 call	 ?docall@@YAHPAUlua_State@@HH@Z ; docall

; 41   : 	return lua;
; 42   : }

  00094	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	8b c6		 mov	 eax, esi
  0009c	33 cd		 xor	 ecx, ebp
  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
?FindWinIntLua@@YAPAUlua_State@@HPAD@Z ENDP		; FindWinIntLua
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\mylua\winlua.cpp
;	COMDAT ?FindLua@@YAPAUlua_State@@PAD@Z
_TEXT	SEGMENT
_newfilename$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
?FindLua@@YAPAUlua_State@@PAD@Z PROC			; FindLua, COMDAT

; 381  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00016	56		 push	 esi

; 382  : 	MY_Lua *salua = &MYLua;
; 383  : 	char newfilename[256];
; 384  : 	sprintf_s(newfilename, "%s", filename);

  00017	50		 push	 eax
  00018	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _newfilename$[ebp]
  0001e	be 00 00 00 00	 mov	 esi, OFFSET ?MYLua@@3UtagMYLua@@A ; MYLua
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ; sprintf_s<256>
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 385  : 	while(salua->next != NULL){

  00031	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR ?MYLua@@3UtagMYLua@@A+8, 0
  00038	74 48		 je	 SHORT $LN3@FindLua
  0003a	66 0f 1f 44 00
	00		 npad	 6
$LL2@FindLua:

; 386  : 		if(strcmp(newfilename, salua->luapath) == 0){

  00040	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00043	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _newfilename$[ebp]
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL11@FindLua:
  00050	8a 11		 mov	 dl, BYTE PTR [ecx]
  00052	3a 10		 cmp	 dl, BYTE PTR [eax]
  00054	75 1a		 jne	 SHORT $LN12@FindLua
  00056	84 d2		 test	 dl, dl
  00058	74 12		 je	 SHORT $LN13@FindLua
  0005a	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0005d	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  00060	75 0e		 jne	 SHORT $LN12@FindLua
  00062	83 c1 02	 add	 ecx, 2
  00065	83 c0 02	 add	 eax, 2
  00068	84 d2		 test	 dl, dl
  0006a	75 e4		 jne	 SHORT $LL11@FindLua
$LN13@FindLua:
  0006c	33 c0		 xor	 eax, eax
  0006e	eb 05		 jmp	 SHORT $LN14@FindLua
$LN12@FindLua:
  00070	1b c0		 sbb	 eax, eax
  00072	83 c8 01	 or	 eax, 1
$LN14@FindLua:
  00075	85 c0		 test	 eax, eax
  00077	74 1a		 je	 SHORT $LN7@FindLua

; 387  : 			return salua->lua;
; 388  : 		}
; 389  : 		salua = salua->next;

  00079	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  0007c	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  00080	75 be		 jne	 SHORT $LL2@FindLua
$LN3@FindLua:

; 390  : 	}
; 391  : 	return NULL;

  00082	33 c0		 xor	 eax, eax
  00084	5e		 pop	 esi

; 392  : }

  00085	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00088	33 cd		 xor	 ecx, ebp
  0008a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
$LN7@FindLua:
  00093	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00096	8b 06		 mov	 eax, DWORD PTR [esi]
  00098	33 cd		 xor	 ecx, ebp
  0009a	5e		 pop	 esi
  0009b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
?FindLua@@YAPAUlua_State@@PAD@Z ENDP			; FindLua
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\mylua\winlua.cpp
;	COMDAT ?luaAB_openlibs@@YAXPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?luaAB_openlibs@@YAXPAUlua_State@@@Z PROC		; luaAB_openlibs, COMDAT

; 108  : LUALIB_API void luaAB_openlibs (lua_State *L) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 109  : 	const luaL_Reg *lib = lualibs;

  00005	8b 7d 08	 mov	 edi, DWORD PTR _L$[ebp]
  00008	be 00 00 00 00	 mov	 esi, OFFSET ?lualibs@@3QBUluaL_Reg@@B
  0000d	b8 00 00 00 00	 mov	 eax, OFFSET ?luaopen_Win@@YAHPAUlua_State@@@Z ; luaopen_Win
$LL4@luaAB_open:

; 110  : 	for (; lib->func; lib++) {
; 111  : 		lua_pushcfunction(L, lib->func);

  00012	6a 00		 push	 0
  00014	50		 push	 eax
  00015	57		 push	 edi
  00016	e8 00 00 00 00	 call	 _lua_pushcclosure

; 112  : 		lua_pushstring(L, lib->name);

  0001b	ff 36		 push	 DWORD PTR [esi]
  0001d	57		 push	 edi
  0001e	e8 00 00 00 00	 call	 _lua_pushstring

; 113  : 		lua_call(L, 1, 0);

  00023	6a 00		 push	 0
  00025	6a 01		 push	 1
  00027	57		 push	 edi
  00028	e8 00 00 00 00	 call	 _lua_call
  0002d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00030	8d 76 08	 lea	 esi, DWORD PTR [esi+8]
  00033	83 c4 20	 add	 esp, 32			; 00000020H
  00036	85 c0		 test	 eax, eax
  00038	75 d8		 jne	 SHORT $LL4@luaAB_open

; 114  : 	}
; 115  : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?luaAB_openlibs@@YAXPAUlua_State@@@Z ENDP		; luaAB_openlibs
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\mylua\winlua.cpp
;	COMDAT ?getArrayInt@@YAHPAUlua_State@@H@Z
_TEXT	SEGMENT
tv78 = -8						; size = 8
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
?getArrayInt@@YAHPAUlua_State@@H@Z PROC			; getArrayInt, COMDAT

; 117  : int getArrayInt(lua_State *L, int idx) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 118  : 	int result = 0;
; 119  :   lua_pushnumber(L, idx + 1);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _idx$[ebp]
  00009	40		 inc	 eax
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b 7d 08	 mov	 edi, DWORD PTR _L$[ebp]
  0000f	83 ec 08	 sub	 esp, 8
  00012	66 0f 6e c0	 movd	 xmm0, eax
  00016	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0001a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0001f	57		 push	 edi
  00020	e8 00 00 00 00	 call	 _lua_pushnumber

; 120  :   lua_gettable(L, -2);

  00025	6a fe		 push	 -2			; fffffffeH
  00027	57		 push	 edi
  00028	e8 00 00 00 00	 call	 _lua_gettable

; 121  :   result = (int)lua_tonumber(L, -1);

  0002d	6a ff		 push	 -1
  0002f	57		 push	 edi
  00030	e8 00 00 00 00	 call	 _lua_tonumber

; 122  :   lua_pop(L, 1);

  00035	6a fe		 push	 -2			; fffffffeH
  00037	dd 5d f8	 fstp	 QWORD PTR tv78[ebp]
  0003a	f2 0f 2c 75 f8	 cvttsd2si esi, QWORD PTR tv78[ebp]
  0003f	57		 push	 edi
  00040	e8 00 00 00 00	 call	 _lua_settop
  00045	83 c4 24	 add	 esp, 36			; 00000024H

; 123  :   return result;

  00048	8b c6		 mov	 eax, esi
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi

; 124  : }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?getArrayInt@@YAHPAUlua_State@@H@Z ENDP			; getArrayInt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\mylua\winlua.cpp
;	COMDAT ?docall@@YAHPAUlua_State@@HH@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_narg$ = 12						; size = 4
_clear$ = 16						; size = 4
?docall@@YAHPAUlua_State@@HH@Z PROC			; docall, COMDAT

; 162  : int docall (lua_State *L, int narg, int clear) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 163  :   int status;
; 164  :   int base = lua_gettop(L) - narg;  /* function index */

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _L$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	53		 push	 ebx
  0000a	e8 00 00 00 00	 call	 _lua_gettop
  0000f	8b 75 0c	 mov	 esi, DWORD PTR _narg$[ebp]
  00012	8b f8		 mov	 edi, eax

; 165  :   lua_pushcfunction(L, traceback);  /* push traceback function */

  00014	6a 00		 push	 0
  00016	68 00 00 00 00	 push	 OFFSET ?traceback@@YAHPAUlua_State@@@Z ; traceback
  0001b	53		 push	 ebx
  0001c	2b fe		 sub	 edi, esi
  0001e	e8 00 00 00 00	 call	 _lua_pushcclosure

; 166  :   lua_insert(L, base);  /* put it under chunk and args */

  00023	57		 push	 edi
  00024	53		 push	 ebx
  00025	e8 00 00 00 00	 call	 _lua_insert

; 167  :   status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);

  0002a	8b 45 10	 mov	 eax, DWORD PTR _clear$[ebp]
  0002d	f7 d8		 neg	 eax
  0002f	57		 push	 edi
  00030	1b c0		 sbb	 eax, eax
  00032	f7 d8		 neg	 eax
  00034	48		 dec	 eax
  00035	50		 push	 eax
  00036	56		 push	 esi
  00037	53		 push	 ebx
  00038	e8 00 00 00 00	 call	 _lua_pcall

; 168  :   lua_remove(L, base);

  0003d	57		 push	 edi
  0003e	53		 push	 ebx
  0003f	8b f0		 mov	 esi, eax
  00041	e8 00 00 00 00	 call	 _lua_remove
  00046	83 c4 30	 add	 esp, 48			; 00000030H

; 169  :   if(status != 0){

  00049	85 f6		 test	 esi, esi
  0004b	74 35		 je	 SHORT $LN4@docall

; 170  : 	printf("入口：docall 错误内容:%d(%s)\n", status, lua_tostring(L, -1));

  0004d	6a 00		 push	 0
  0004f	6a ff		 push	 -1
  00051	53		 push	 ebx
  00052	e8 00 00 00 00	 call	 _lua_tolstring
  00057	50		 push	 eax
  00058	56		 push	 esi
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@FFJEDJPI@?l?$PN?O?$KC?$KD?$LKdocall?5?$DP?$DP?$DP?i?$LL?3?$CFd?$CI?$CFs?$CJ?6@
  0005e	e8 00 00 00 00	 call	 _printf

; 171  : 	int iTop = lua_gettop(L);

  00063	53		 push	 ebx
  00064	e8 00 00 00 00	 call	 _lua_gettop

; 172  : 	lua_pop(L,iTop);

  00069	83 c9 ff	 or	 ecx, -1
  0006c	2b c8		 sub	 ecx, eax
  0006e	51		 push	 ecx
  0006f	53		 push	 ebx
  00070	e8 00 00 00 00	 call	 _lua_settop

; 173  : 	lua_gc(L, LUA_GCCOLLECT, 0);

  00075	6a 00		 push	 0
  00077	6a 02		 push	 2
  00079	53		 push	 ebx
  0007a	e8 00 00 00 00	 call	 _lua_gc
  0007f	83 c4 30	 add	 esp, 48			; 00000030H
$LN4@docall:

; 174  :   }
; 175  : 
; 176  :   return status;
; 177  : }

  00082	5f		 pop	 edi
  00083	8b c6		 mov	 eax, esi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?docall@@YAHPAUlua_State@@HH@Z ENDP			; docall
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\mylua\winlua.cpp
;	COMDAT ?dofile@@YAHPAUlua_State@@PBD@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_name$ = 12						; size = 4
?dofile@@YAHPAUlua_State@@PBD@Z PROC			; dofile, COMDAT

; 179  : int dofile (lua_State *L, const char *name) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 180  :   int status = luaL_loadfile(L, name) || docall(L, 0, 1);

  00004	ff 75 0c	 push	 DWORD PTR _name$[ebp]
  00007	8b 75 08	 mov	 esi, DWORD PTR _L$[ebp]
  0000a	56		 push	 esi
  0000b	e8 00 00 00 00	 call	 _luaL_loadfile
  00010	83 c4 08	 add	 esp, 8
  00013	85 c0		 test	 eax, eax
  00015	75 1d		 jne	 SHORT $LN3@dofile
  00017	6a 01		 push	 1
  00019	50		 push	 eax
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ?docall@@YAHPAUlua_State@@HH@Z ; docall
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	85 c0		 test	 eax, eax
  00025	75 0d		 jne	 SHORT $LN3@dofile

; 181  :   return report(L, status);

  00027	50		 push	 eax
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ?report@@YAHPAUlua_State@@H@Z ; report
  0002e	83 c4 08	 add	 esp, 8
  00031	5e		 pop	 esi

; 182  : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
$LN3@dofile:

; 180  :   int status = luaL_loadfile(L, name) || docall(L, 0, 1);

  00034	b8 01 00 00 00	 mov	 eax, 1

; 181  :   return report(L, status);

  00039	50		 push	 eax
  0003a	56		 push	 esi
  0003b	e8 00 00 00 00	 call	 ?report@@YAHPAUlua_State@@H@Z ; report
  00040	83 c4 08	 add	 esp, 8
  00043	5e		 pop	 esi

; 182  : }

  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?dofile@@YAHPAUlua_State@@PBD@Z ENDP			; dofile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\mylua\winlua.cpp
;	COMDAT ?closemyluaload@@YAHXZ
_TEXT	SEGMENT
?closemyluaload@@YAHXZ PROC				; closemyluaload, COMDAT

; 318  : 	MY_Lua *salua = &MYLua;
; 319  : 	while(salua->next!=NULL){

  00000	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR ?MYLua@@3UtagMYLua@@A+8, 0
  00007	56		 push	 esi
  00008	be 00 00 00 00	 mov	 esi, OFFSET ?MYLua@@3UtagMYLua@@A ; MYLua
  0000d	74 25		 je	 SHORT $LN9@closemylua
  0000f	57		 push	 edi
  00010	bf 08 00 00 00	 mov	 edi, OFFSET ?MYLua@@3UtagMYLua@@A+8
$LL2@closemylua:

; 320  : 		lua_pop(salua->lua, 1);

  00015	6a fe		 push	 -2			; fffffffeH
  00017	ff 36		 push	 DWORD PTR [esi]
  00019	e8 00 00 00 00	 call	 _lua_settop

; 321  : 		lua_close(salua->lua);

  0001e	ff 36		 push	 DWORD PTR [esi]
  00020	e8 00 00 00 00	 call	 _lua_close

; 322  : 		salua = salua->next;

  00025	8b 37		 mov	 esi, DWORD PTR [edi]
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002a	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  0002e	8d 7e 08	 lea	 edi, DWORD PTR [esi+8]
  00031	75 e2		 jne	 SHORT $LL2@closemylua

; 323  : 	}
; 324  : 	
; 325  :   return EXIT_SUCCESS;

  00033	5f		 pop	 edi
$LN9@closemylua:

; 326  : }

  00034	33 c0		 xor	 eax, eax
  00036	5e		 pop	 esi
  00037	c3		 ret	 0
?closemyluaload@@YAHXZ ENDP				; closemyluaload
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\mylua\winlua.cpp
;	COMDAT ?LoadStoneAgeLUA@@YAXPAD@Z
_TEXT	SEGMENT
_wfd$ = -836						; size = 320
_filename$1 = -516					; size = 256
_filename$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_path$ = 8						; size = 4
?LoadStoneAgeLUA@@YAXPAD@Z PROC				; LoadStoneAgeLUA, COMDAT

; 328  : void LoadStoneAgeLUA(char *path){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 44 03 00
	00		 sub	 esp, 836		; 00000344H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _path$[ebp]

; 329  : 	char filename[256];
; 330  : 
; 331  : 	WIN32_FIND_DATA wfd; 
; 332  : 	HANDLE hFind; 
; 333  : 	lstrcpy(filename, path); 

  00018	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _filename$[ebp]
  0001e	57		 push	 edi
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8

; 334  : 	lstrcat(filename, "/"); 

  00026	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__lstrcatA@8
  0002c	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _filename$[ebp]
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_01KMDKNFGN@?1@
  00037	50		 push	 eax
  00038	ff d6		 call	 esi

; 335  : 	lstrcat(filename, "*.*"); // 找所有文件 

  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_03EMIMMIHL@?$CK?4?$CK@
  0003f	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _filename$[ebp]
  00045	50		 push	 eax
  00046	ff d6		 call	 esi

; 336  : 	
; 337  : 	hFind = FindFirstFile(filename, &wfd); 

  00048	8d 85 bc fc ff
	ff		 lea	 eax, DWORD PTR _wfd$[ebp]
  0004e	50		 push	 eax
  0004f	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _filename$[ebp]
  00055	50		 push	 eax
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindFirstFileA@8
  0005c	8b f0		 mov	 esi, eax

; 338  : 	if (hFind == INVALID_HANDLE_VALUE) // 如果没有找到或查找失败 

  0005e	83 fe ff	 cmp	 esi, -1
  00061	0f 84 af 00 00
	00		 je	 $LN1@LoadStoneA
  00067	53		 push	 ebx
  00068	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__FindNextFileA@8
  0006e	66 90		 npad	 2
$LL4@LoadStoneA:

; 339  : 		return; 
; 340  : 	do{
; 341  : 		
; 342  : 		if (wfd.cFileName[0] == '.') 

  00070	80 bd e8 fc ff
	ff 2e		 cmp	 BYTE PTR _wfd$[ebp+44], 46 ; 0000002eH
  00077	0f 84 7f 00 00
	00		 je	 $LN2@LoadStoneA

; 343  : 			continue; // 过滤这两个目录 
; 344  : 		if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY){ 

  0007d	f6 85 bc fc ff
	ff 10		 test	 BYTE PTR _wfd$[ebp], 16	; 00000010H
  00084	8d 85 e8 fc ff
	ff		 lea	 eax, DWORD PTR _wfd$[ebp+44]
  0008a	74 24		 je	 SHORT $LN7@LoadStoneA

; 345  : 			sprintf_s(filename, "%s//%s", path, wfd.cFileName);

  0008c	50		 push	 eax
  0008d	57		 push	 edi
  0008e	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _filename$[ebp]
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_06PDPEOAFG@?$CFs?1?1?$CFs@
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ; sprintf_s<256>

; 346  : 			LoadStoneAgeLUA(filename);

  0009f	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _filename$[ebp]
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 ?LoadStoneAgeLUA@@YAXPAD@Z ; LoadStoneAgeLUA
  000ab	83 c4 14	 add	 esp, 20			; 00000014H

; 347  : 		}else{

  000ae	eb 4c		 jmp	 SHORT $LN2@LoadStoneA
$LN7@LoadStoneA:

; 348  : 			extern int strcmptail(char *s1, char *s2);
; 349  : #ifdef _LUA加密
; 350  : 			if( strcmptail( wfd.cFileName, ".sq" ) == 0)
; 351  : #else
; 352  : 			if( strcmptail( wfd.cFileName, ".lua" ) == 0)

  000b0	68 00 00 00 00	 push	 OFFSET ??_C@_04BIAACBGB@?4lua@
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 ?strcmptail@@YAHPAD0@Z	; strcmptail
  000bb	83 c4 08	 add	 esp, 8
  000be	85 c0		 test	 eax, eax
  000c0	75 3a		 jne	 SHORT $LN2@LoadStoneA

; 353  : #endif
; 354  : 			{
; 355  : 				char filename[256];
; 356  : 				memset(filename, 0, 256);

  000c2	68 00 01 00 00	 push	 256			; 00000100H
  000c7	50		 push	 eax
  000c8	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _filename$1[ebp]
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 _memset

; 357  : 				sprintf_s(filename, "%s//%s", path, wfd.cFileName);

  000d4	8d 85 e8 fc ff
	ff		 lea	 eax, DWORD PTR _wfd$[ebp+44]
  000da	50		 push	 eax
  000db	57		 push	 edi
  000dc	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _filename$1[ebp]
  000e2	68 00 00 00 00	 push	 OFFSET ??_C@_06PDPEOAFG@?$CFs?1?1?$CFs@
  000e7	50		 push	 eax
  000e8	e8 00 00 00 00	 call	 ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ; sprintf_s<256>

; 358  : 				myluaload(filename);

  000ed	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _filename$1[ebp]
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 ?myluaload@@YAHPAD@Z	; myluaload
  000f9	83 c4 20	 add	 esp, 32			; 00000020H
$LN2@LoadStoneA:

; 359  : 			}
; 360  : 		}
; 361  : 	}while (FindNextFile(hFind, &wfd)); 

  000fc	8d 85 bc fc ff
	ff		 lea	 eax, DWORD PTR _wfd$[ebp]
  00102	50		 push	 eax
  00103	56		 push	 esi
  00104	ff d3		 call	 ebx
  00106	85 c0		 test	 eax, eax
  00108	0f 85 62 ff ff
	ff		 jne	 $LL4@LoadStoneA

; 362  : 	FindClose(hFind); // 关闭查找句柄 

  0010e	56		 push	 esi
  0010f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindClose@4
  00115	5b		 pop	 ebx
$LN1@LoadStoneA:

; 363  : }

  00116	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00119	5f		 pop	 edi
  0011a	33 cd		 xor	 ecx, ebp
  0011c	5e		 pop	 esi
  0011d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00122	8b e5		 mov	 esp, ebp
  00124	5d		 pop	 ebp
  00125	c3		 ret	 0
?LoadStoneAgeLUA@@YAXPAD@Z ENDP				; LoadStoneAgeLUA
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\mylua\winlua.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\mylua\winlua.cpp
;	COMDAT ?remyluaload@@YAHPAD@Z
_TEXT	SEGMENT
tv73 = -4						; size = 4
tv69 = -4						; size = 4
_filename$ = 8						; size = 4
?remyluaload@@YAHPAD@Z PROC				; remyluaload, COMDAT

; 290  : int remyluaload (char *filename){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 291  : 	MY_Lua *salua = &MYLua;
; 292  : 	while(salua->next!=NULL){

  00004	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR ?MYLua@@3UtagMYLua@@A+8, 0
  0000b	56		 push	 esi
  0000c	be 00 00 00 00	 mov	 esi, OFFSET ?MYLua@@3UtagMYLua@@A ; MYLua
  00011	0f 84 be 00 00
	00		 je	 $LN19@remylualoa
  00017	53		 push	 ebx
  00018	8b 5d 08	 mov	 ebx, DWORD PTR _filename$[ebp]
  0001b	57		 push	 edi
  0001c	0f 1f 40 00	 npad	 4
$LL2@remylualoa:

; 293  : 		if(strlen(salua->luapath) > 0){

  00020	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00023	8b ca		 mov	 ecx, edx
  00025	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
$LL17@remylualoa:
  00028	8a 01		 mov	 al, BYTE PTR [ecx]
  0002a	41		 inc	 ecx
  0002b	84 c0		 test	 al, al
  0002d	75 f9		 jne	 SHORT $LL17@remylualoa
  0002f	2b cf		 sub	 ecx, edi
  00031	0f 84 8d 00 00
	00		 je	 $LN7@remylualoa

; 294  : 			if(strlen(filename)>0){

  00037	8b c3		 mov	 eax, ebx
  00039	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0003c	0f 1f 40 00	 npad	 4
$LL18@remylualoa:
  00040	8a 08		 mov	 cl, BYTE PTR [eax]
  00042	40		 inc	 eax
  00043	84 c9		 test	 cl, cl
  00045	75 f9		 jne	 SHORT $LL18@remylualoa
  00047	2b c7		 sub	 eax, edi
  00049	74 0e		 je	 SHORT $LN15@remylualoa
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h

; 520  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  0004b	53		 push	 ebx
  0004c	52		 push	 edx
  0004d	e8 00 00 00 00	 call	 _strstr
  00052	83 c4 08	 add	 esp, 8
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\mylua\winlua.cpp

; 295  : 				if(strstr(salua->luapath, filename) == 0){

  00055	85 c0		 test	 eax, eax
  00057	74 6b		 je	 SHORT $LN7@remylualoa
$LN15@remylualoa:

; 296  : 					salua = salua->next;
; 297  : 					continue;
; 298  : 				}
; 299  : 			}
; 300  : 			lua_gc(salua->lua, LUA_GCSTOP, 0); 

  00059	6a 00		 push	 0
  0005b	6a 00		 push	 0
  0005d	ff 36		 push	 DWORD PTR [esi]
  0005f	e8 00 00 00 00	 call	 _lua_gc

; 301  : 			luaL_openlibs(salua->lua); 

  00064	ff 36		 push	 DWORD PTR [esi]
  00066	e8 00 00 00 00	 call	 _luaL_openlibs

; 302  : 			luaAB_openlibs(salua->lua);

  0006b	ff 36		 push	 DWORD PTR [esi]
  0006d	e8 00 00 00 00	 call	 ?luaAB_openlibs@@YAXPAUlua_State@@@Z ; luaAB_openlibs

; 303  : 			lua_gc(salua->lua, LUA_GCRESTART, 0);

  00072	6a 00		 push	 0
  00074	6a 01		 push	 1
  00076	ff 36		 push	 DWORD PTR [esi]
  00078	e8 00 00 00 00	 call	 _lua_gc

; 304  : 			dofile(salua->lua, salua->luapath);

  0007d	ff 76 04	 push	 DWORD PTR [esi+4]
  00080	ff 36		 push	 DWORD PTR [esi]
  00082	e8 00 00 00 00	 call	 ?dofile@@YAHPAUlua_State@@PBD@Z ; dofile

; 305  : 			printf("\n%s",salua->luapath);

  00087	ff 76 04	 push	 DWORD PTR [esi+4]
  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_03ILJCGOLJ@?6?$CFs@
  0008f	e8 00 00 00 00	 call	 _printf

; 306  : 			lua_getglobal(salua->lua, "data");

  00094	68 00 00 00 00	 push	 OFFSET ??_C@_04PJOLNDGD@data@
  00099	68 ee d8 ff ff	 push	 -10002			; ffffd8eeH
  0009e	ff 36		 push	 DWORD PTR [esi]
  000a0	e8 00 00 00 00	 call	 _lua_getfield

; 307  : 			if (lua_isfunction(salua->lua, -1)){

  000a5	6a ff		 push	 -1
  000a7	ff 36		 push	 DWORD PTR [esi]
  000a9	e8 00 00 00 00	 call	 _lua_type
  000ae	83 c4 44	 add	 esp, 68			; 00000044H
  000b1	83 f8 06	 cmp	 eax, 6
  000b4	75 0e		 jne	 SHORT $LN7@remylualoa

; 308  : 				docall(salua->lua, 0, 1);

  000b6	6a 01		 push	 1
  000b8	6a 00		 push	 0
  000ba	ff 36		 push	 DWORD PTR [esi]
  000bc	e8 00 00 00 00	 call	 ?docall@@YAHPAUlua_State@@HH@Z ; docall
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@remylualoa:

; 291  : 	MY_Lua *salua = &MYLua;
; 292  : 	while(salua->next!=NULL){

  000c4	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000c7	8b f0		 mov	 esi, eax
  000c9	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  000cd	0f 85 4d ff ff
	ff		 jne	 $LL2@remylualoa

; 309  : 			}
; 310  : 		}
; 311  : 		salua = salua->next;
; 312  : 	}
; 313  :   return EXIT_SUCCESS;

  000d3	5f		 pop	 edi
  000d4	5b		 pop	 ebx
$LN19@remylualoa:

; 314  : }

  000d5	33 c0		 xor	 eax, eax
  000d7	5e		 pop	 esi
  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c3		 ret	 0
?remyluaload@@YAHPAD@Z ENDP				; remyluaload
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\mylua\winlua.cpp
;	COMDAT ?myluaload@@YAHPAD@Z
_TEXT	SEGMENT
_buf$1 = -104						; size = 100
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
?myluaload@@YAHPAD@Z PROC				; myluaload, COMDAT

; 242  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 243  : 	MY_Lua *salua = &MYLua;
; 244  : 	while(salua->next!=NULL){

  00010	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR ?MYLua@@3UtagMYLua@@A+8, 0
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	8b 7d 08	 mov	 edi, DWORD PTR _filename$[ebp]
  0001c	be 00 00 00 00	 mov	 esi, OFFSET ?MYLua@@3UtagMYLua@@A ; MYLua
  00021	74 3b		 je	 SHORT $LN3@myluaload
$LL2@myluaload:

; 245  : 		if(strcmp(salua->luapath, filename) == 0){

  00023	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00026	8b c7		 mov	 eax, edi
$LL20@myluaload:
  00028	8a 11		 mov	 dl, BYTE PTR [ecx]
  0002a	3a 10		 cmp	 dl, BYTE PTR [eax]
  0002c	75 1a		 jne	 SHORT $LN21@myluaload
  0002e	84 d2		 test	 dl, dl
  00030	74 12		 je	 SHORT $LN22@myluaload
  00032	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  00035	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  00038	75 0e		 jne	 SHORT $LN21@myluaload
  0003a	83 c1 02	 add	 ecx, 2
  0003d	83 c0 02	 add	 eax, 2
  00040	84 d2		 test	 dl, dl
  00042	75 e4		 jne	 SHORT $LL20@myluaload
$LN22@myluaload:
  00044	33 c0		 xor	 eax, eax
  00046	eb 05		 jmp	 SHORT $LN23@myluaload
$LN21@myluaload:
  00048	1b c0		 sbb	 eax, eax
  0004a	83 c8 01	 or	 eax, 1
$LN23@myluaload:
  0004d	85 c0		 test	 eax, eax
  0004f	0f 84 a5 00 00
	00		 je	 $LN19@myluaload

; 246  : 			return FALSE;
; 247  : 		}
; 248  : 		salua = salua->next;

  00055	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  00058	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  0005c	75 c5		 jne	 SHORT $LL2@myluaload
$LN3@myluaload:

; 249  : 	}
; 250  : 	salua->luapath = new char[strlen(filename)+1];

  0005e	8b cf		 mov	 ecx, edi
  00060	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL24@myluaload:
  00063	8a 01		 mov	 al, BYTE PTR [ecx]
  00065	41		 inc	 ecx
  00066	84 c0		 test	 al, al
  00068	75 f9		 jne	 SHORT $LL24@myluaload
  0006a	53		 push	 ebx
  0006b	2b ca		 sub	 ecx, edx
  0006d	68 fa 00 00 00	 push	 250			; 000000faH
  00072	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@DIDENEII@?2VBOXSVR?2_stoneage?2repos?2ssm?9sa@
  00077	6a 01		 push	 1
  00079	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ??_U@YAPAXIHPBDH@Z	; operator new[]

; 251  : 	memset( salua->luapath, 0 , strlen(filename)+1);

  00082	8b cf		 mov	 ecx, edi
  00084	8b d0		 mov	 edx, eax
  00086	83 c4 10	 add	 esp, 16			; 00000010H
  00089	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0008c	8d 59 01	 lea	 ebx, DWORD PTR [ecx+1]
  0008f	90		 npad	 1
$LL25@myluaload:
  00090	8a 01		 mov	 al, BYTE PTR [ecx]
  00092	41		 inc	 ecx
  00093	84 c0		 test	 al, al
  00095	75 f9		 jne	 SHORT $LL25@myluaload
  00097	2b cb		 sub	 ecx, ebx
  00099	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0009c	50		 push	 eax
  0009d	6a 00		 push	 0
  0009f	52		 push	 edx
  000a0	e8 00 00 00 00	 call	 _memset

; 252  : 	strcpy(salua->luapath, filename);

  000a5	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000a8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ab	8b cf		 mov	 ecx, edi
  000ad	5b		 pop	 ebx
  000ae	66 90		 npad	 2
$LL10@myluaload:
  000b0	8a 01		 mov	 al, BYTE PTR [ecx]
  000b2	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  000b5	88 02		 mov	 BYTE PTR [edx], al
  000b7	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  000ba	84 c0		 test	 al, al
  000bc	75 f2		 jne	 SHORT $LL10@myluaload

; 253  : 	salua->next = (tagMYLua *)new MY_Lua;

  000be	68 fd 00 00 00	 push	 253			; 000000fdH
  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@DIDENEII@?2VBOXSVR?2_stoneage?2repos?2ssm?9sa@
  000c8	6a 01		 push	 1
  000ca	6a 0c		 push	 12			; 0000000cH
  000cc	e8 00 00 00 00	 call	 ??2@YAPAXIHPBDH@Z	; operator new
  000d1	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000d4	0f 57 c0	 xorps	 xmm0, xmm0
  000d7	83 c4 10	 add	 esp, 16			; 00000010H

; 254  : 	memset( salua->next, 0 , sizeof(MY_Lua) );

  000da	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  000de	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 255  : 	if(salua->next == NULL)return EXIT_FAILURE;

  000e5	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  000e9	0f 84 af 00 00
	00		 je	 $LN8@myluaload

; 256  : 
; 257  : 	salua->lua = lua_open();

  000ef	e8 00 00 00 00	 call	 _luaL_newstate
  000f4	89 06		 mov	 DWORD PTR [esi], eax

; 258  : 	if (salua->lua == NULL) {

  000f6	85 c0		 test	 eax, eax
  000f8	75 12		 jne	 SHORT $LN6@myluaload
$LN19@myluaload:
  000fa	5f		 pop	 edi

; 259  : 		return FALSE;

  000fb	33 c0		 xor	 eax, eax

; 286  : 	}
; 287  : 	return TRUE;
; 288  : }

  000fd	5e		 pop	 esi
  000fe	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00101	33 cd		 xor	 ecx, ebp
  00103	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c3		 ret	 0
$LN6@myluaload:

; 260  : 	}
; 261  : 	lua_gc(salua->lua, LUA_GCSTOP, 0);

  0010c	6a 00		 push	 0
  0010e	6a 00		 push	 0
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 _lua_gc

; 262  : 	luaL_openlibs(salua->lua);

  00116	ff 36		 push	 DWORD PTR [esi]
  00118	e8 00 00 00 00	 call	 _luaL_openlibs

; 263  : 	luaAB_openlibs(salua->lua);

  0011d	ff 36		 push	 DWORD PTR [esi]
  0011f	e8 00 00 00 00	 call	 ?luaAB_openlibs@@YAXPAUlua_State@@@Z ; luaAB_openlibs

; 264  : 	lua_gc(salua->lua, LUA_GCRESTART, 0);

  00124	6a 00		 push	 0
  00126	6a 01		 push	 1
  00128	ff 36		 push	 DWORD PTR [esi]
  0012a	e8 00 00 00 00	 call	 _lua_gc

; 265  : #ifdef _LUA加密
; 266  : 	int re = decryptLUA(salua->lua, filename);
; 267  : 	if(re != 0){
; 268  : 		if(re==-100) return TRUE;
; 269  : 		printf("文件：%s 错误提示：%s 行数：%d\n",filename,(char *)lua_tostring(salua->lua, -1),re);
; 270  : 		lua_gc(salua->lua, LUA_GCCOLLECT, 0);
; 271  : 		return TRUE;
; 272  : 	}
; 273  : #else
; 274  : 	int re = decryptLUA2(salua->lua, filename);

  0012f	57		 push	 edi
  00130	ff 36		 push	 DWORD PTR [esi]
  00132	e8 00 00 00 00	 call	 ?decryptLUA2@@YAHPAUlua_State@@PAD@Z ; decryptLUA2
  00137	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00139	83 c4 28	 add	 esp, 40			; 00000028H

; 275  : 	if(re!=0){

  0013c	85 c0		 test	 eax, eax
  0013e	74 2f		 je	 SHORT $LN7@myluaload

; 276  : 		char buf[100];
; 277  : 		wsprintfA(buf, "文件：%s 错误提示：%s 行数：%d\n", filename, (char *)lua_tostring(salua->lua, -1), re);

  00140	50		 push	 eax
  00141	6a 00		 push	 0
  00143	6a ff		 push	 -1
  00145	51		 push	 ecx
  00146	e8 00 00 00 00	 call	 _lua_tolstring
  0014b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0014e	50		 push	 eax
  0014f	57		 push	 edi
  00150	8d 45 98	 lea	 eax, DWORD PTR _buf$1[ebp]
  00153	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@MOHPFDBB@?Y?$PO?K?l?$KD?$LK?$CFs?5?$DP?$DP?p?$KL?c?F?$KD?$LK?$CFs?5?z?$LM?$DP?$KD?$LK?$CFd?6@
  00158	50		 push	 eax
  00159	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 278  : 	//	printf("文件：%s 错误提示：%s 行数：%d\n",filename,(char *)lua_tostring(salua->lua, -1),re);
; 279  : 		lua_gc(salua->lua, LUA_GCCOLLECT, 0);

  0015f	6a 00		 push	 0
  00161	6a 02		 push	 2
  00163	ff 36		 push	 DWORD PTR [esi]
  00165	e8 00 00 00 00	 call	 _lua_gc
  0016a	83 c4 20	 add	 esp, 32			; 00000020H

; 280  : 		return TRUE;	

  0016d	eb 2f		 jmp	 SHORT $LN8@myluaload
$LN7@myluaload:

; 281  : 	}
; 282  : #endif
; 283  : 	lua_getglobal(salua->lua, "main");

  0016f	68 00 00 00 00	 push	 OFFSET ??_C@_04GHJNJNPO@main@
  00174	68 ee d8 ff ff	 push	 -10002			; ffffd8eeH
  00179	51		 push	 ecx
  0017a	e8 00 00 00 00	 call	 _lua_getfield

; 284  : 	if (lua_isfunction(salua->lua, -1)) {

  0017f	6a ff		 push	 -1
  00181	ff 36		 push	 DWORD PTR [esi]
  00183	e8 00 00 00 00	 call	 _lua_type
  00188	83 c4 14	 add	 esp, 20			; 00000014H
  0018b	83 f8 06	 cmp	 eax, 6
  0018e	75 0e		 jne	 SHORT $LN8@myluaload

; 285  : 		docall(salua->lua, 0, 1);

  00190	6a 01		 push	 1
  00192	6a 00		 push	 0
  00194	ff 36		 push	 DWORD PTR [esi]
  00196	e8 00 00 00 00	 call	 ?docall@@YAHPAUlua_State@@HH@Z ; docall
  0019b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@myluaload:

; 286  : 	}
; 287  : 	return TRUE;
; 288  : }

  0019e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a1	b8 01 00 00 00	 mov	 eax, 1
  001a6	5f		 pop	 edi
  001a7	33 cd		 xor	 ecx, ebp
  001a9	5e		 pop	 esi
  001aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001af	8b e5		 mov	 esp, ebp
  001b1	5d		 pop	 ebp
  001b2	c3		 ret	 0
?myluaload@@YAHPAD@Z ENDP				; myluaload
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 956  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);
; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Format$[ebp]
  00007	6a 01		 push	 1
  00009	e8 00 00 00 00	 call	 ___acrt_iob_func
  0000e	83 c4 04	 add	 esp, 4

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00011	8d 4d 0c	 lea	 ecx, DWORD PTR __Format$[ebp+4]
  00014	51		 push	 ecx
  00015	6a 00		 push	 0
  00017	56		 push	 esi
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001e	ff 70 04	 push	 DWORD PTR [eax+4]
  00021	ff 30		 push	 DWORD PTR [eax]
  00023	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  00028	83 c4 18	 add	 esp, 24			; 00000018H

; 961  :         __crt_va_end(_ArgList);
; 962  :         return _Result;

  0002b	5e		 pop	 esi

; 963  :     }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 837  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Stream$[ebp]
  0000f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00014	ff 70 04	 push	 DWORD PTR [eax+4]
  00017	ff 30		 push	 DWORD PTR [eax]
  00019	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);
; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 842  :         __crt_va_end(_ArgList);
; 843  :         return _Result;
; 844  :     }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
