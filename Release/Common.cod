; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30133.0 

	TITLE	\\VBOXSVR\_stoneage\repos\ssm-sacli\Release\Common.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?dwServer@@3KA					; dwServer
PUBLIC	?iWGS@@3HA					; iWGS
PUBLIC	?szWGS@@3PADA					; szWGS
PUBLIC	?wWGS@@3GA					; wWGS
PUBLIC	?szCSIP@@3PADA					; szCSIP
PUBLIC	?wCS@@3GA					; wCS
PUBLIC	?szError@@3PADA					; szError
PUBLIC	?szPid@@3PADA					; szPid
PUBLIC	?szAnnouncement@@3PADA				; szAnnouncement
PUBLIC	?szPlain@@3PADA					; szPlain
PUBLIC	?szCipher@@3PADA				; szCipher
PUBLIC	?P_Key@@3PADA					; P_Key
PUBLIC	?P_Key1@@3PADA					; P_Key1
PUBLIC	?gmgroup@@3PAUgamegroup@@A			; gmgroup
_BSS	SEGMENT
?dwServer@@3KA DD 01H DUP (?)				; dwServer
?iWGS@@3HA DD	01H DUP (?)				; iWGS
?szCSIP@@3PADA DB 07dH DUP (?)				; szCSIP
	ALIGN	4

?wCS@@3GA DW	01H DUP (?)				; wCS
	ALIGN	4

?szError@@3PADA DB 0400H DUP (?)			; szError
?szPid@@3PADA DB 0aH DUP (?)				; szPid
	ALIGN	4

?szAnnouncement@@3PADA DB 0400H DUP (?)			; szAnnouncement
?szPlain@@3PADA DB 050H DUP (?)				; szPlain
?szCipher@@3PADA DB 050H DUP (?)			; szCipher
?P_Key@@3PADA DB 08H DUP (?)				; P_Key
?P_Key1@@3PADA DB 0100H DUP (?)				; P_Key1
_BSS	ENDS
_DATA	SEGMENT
?szWGS@@3PADA DB '210.64.97.28', 00H			; szWGS
	ORG $+3
?wWGS@@3GA DW	032cdH					; wWGS
	ORG $+6
?gmgroup@@3PAUgamegroup@@A DB 031H			; gmgroup
	DB	0eH
	DB	00H
	DB	'ABC', 00H
	ORG $+57
	ORG $+1152
_DATA	ENDS
PUBLIC	?GetIP_PORT@@YAHPAUParameter@@@Z		; GetIP_PORT
PUBLIC	?GetEncrypt@@YAXPAUParameter@@@Z		; GetEncrypt
PUBLIC	?PKey_Init@@YAXXZ				; PKey_Init
PUBLIC	?ipAddressAnalyze@@YAXXZ			; ipAddressAnalyze
PUBLIC	?ReadWGSMessage@@YAHPADAAH@Z			; ReadWGSMessage
PUBLIC	?DoHellow@@YAXXZ				; DoHellow
PUBLIC	?DoSKey@@YAXXZ					; DoSKey
PUBLIC	?SetTestServer@@YAXXZ				; SetTestServer
PUBLIC	??_C@_04JFFKLGJF@?$CF02X@			; `string'
PUBLIC	??_C@_07LDMIILLH@8904001@			; `string'
PUBLIC	??_C@_05HDEIOAAC@?$DP?$DP?S?$NO?$DP@		; `string'
PUBLIC	??_C@_09PFCHIMEP@127?40?40?41@			; `string'
PUBLIC	??_C@_05PKCEPLOA@?$DP?$DP?l?i?$DP@		; `string'
PUBLIC	??_C@_04DIMBHGPH@7001@				; `string'
PUBLIC	??_C@_0BA@KLCEACOB@114?4215?4158?4113@		; `string'
PUBLIC	??_C@_05IHCJPDPG@?$DP?$DP?l?$KD?$DP@		; `string'
PUBLIC	??_C@_0O@KGEINEL@192?4168?40?4104@		; `string'
PUBLIC	??_C@_05HIFDGNPO@?$DP?$DP?$NP?$LC?$DP@		; `string'
PUBLIC	??_C@_0BD@PJBIDGKH@my?4gamma7happy?4com@	; `string'
PUBLIC	??_C@_05JOIAEPMB@?$DP?$DP?$NO?L?$DP@		; `string'
PUBLIC	??_C@_05MBDEGLCK@ERROR@				; `string'
PUBLIC	??_C@_09NGJPPDAN@?t?x?c?$LH?$PL?y?c?w?$DP@	; `string'
PUBLIC	??_C@_0BP@JBCHKPGG@Software?2Waei?2?$OA?$LE?P?o?$DP?S?$NL?25?400?4000@ ; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3@				; `string'
PUBLIC	??_C@_01LFCBOECM@?4@				; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_strcat_s:PROC
EXTRN	_strtok_s:PROC
EXTRN	_strncpy:PROC
EXTRN	__imp__lstrcpyA@8:PROC
EXTRN	__imp__lstrcatA@8:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	__imp__RegOpenKeyExA@20:PROC
EXTRN	_srand:PROC
EXTRN	_rand:PROC
EXTRN	_atoi:PROC
EXTRN	__imp__CoUninitialize@0:PROC
EXTRN	__imp__CoInitialize@4:PROC
EXTRN	__time64:PROC
EXTRN	?AddParamForFormat@@YAXPADHK@Z:PROC		; AddParamForFormat
EXTRN	?AddParamForFormat@@YAXDK@Z:PROC		; AddParamForFormat
EXTRN	?GetString@@YAPADAAHPAD@Z:PROC			; GetString
EXTRN	?AnalyzeMessage@@YAKPADH@Z:PROC			; AnalyzeMessage
EXTRN	?ReleaseMessHeadParam@@YAPAUParameter@@XZ:PROC	; ReleaseMessHeadParam
EXTRN	?RemoveMessHead@@YAXXZ:PROC			; RemoveMessHead
EXTRN	?ReleaseMessList@@YAXXZ:PROC			; ReleaseMessList
EXTRN	?GetCafeNumber@@YAKXZ:PROC			; GetCafeNumber
EXTRN	?appendWriteBuf@@YAHHPADH@Z:PROC		; appendWriteBuf
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
EXTRN	?RET_OK@@3KB:DWORD				; RET_OK
EXTRN	?messHead@@3PAUMessNode@@A:DWORD		; messHead
EXTRN	?iEncrypt@@3HA:DWORD				; iEncrypt
EXTRN	?idKey@@3USTR_BUFFER@@A:BYTE			; idKey
EXTRN	?passwd@@3USTR_BUFFER@@A:BYTE			; passwd
EXTRN	?gmsv@@3PAUgameserver@@A:BYTE			; gmsv
EXTRN	?nGroup@@3HA:DWORD				; nGroup
EXTRN	___security_cookie:DWORD
;	COMDAT ??_C@_01LFCBOECM@?4@
CONST	SEGMENT
??_C@_01LFCBOECM@?4@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JBCHKPGG@Software?2Waei?2?$OA?$LE?P?o?$DP?S?$NL?25?400?4000@
CONST	SEGMENT
??_C@_0BP@JBCHKPGG@Software?2Waei?2?$OA?$LE?P?o?$DP?S?$NL?25?400?4000@ DB 'S'
	DB	'oftware\Waei\', 0e0H, 0b4H, 0d0H, 0efH, '?', 0d3H, 0dbH, '\5.'
	DB	'00.000', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09NGJPPDAN@?t?x?c?$LH?$PL?y?c?w?$DP@
CONST	SEGMENT
??_C@_09NGJPPDAN@?t?x?c?$LH?$PL?y?c?w?$DP@ DB 0f4H, 0f8H, 0e3H, 0b7H, 0fbH
	DB	0f9H, 0e3H, 0f7H, '?', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MBDEGLCK@ERROR@
CONST	SEGMENT
??_C@_05MBDEGLCK@ERROR@ DB 'ERROR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05JOIAEPMB@?$DP?$DP?$NO?L?$DP@
CONST	SEGMENT
??_C@_05JOIAEPMB@?$DP?$DP?$NO?L?$DP@ DB '??', 0deH, 0ccH, '?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJBIDGKH@my?4gamma7happy?4com@
CONST	SEGMENT
??_C@_0BD@PJBIDGKH@my?4gamma7happy?4com@ DB 'my.gamma7happy.com', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05HIFDGNPO@?$DP?$DP?$NP?$LC?$DP@
CONST	SEGMENT
??_C@_05HIFDGNPO@?$DP?$DP?$NP?$LC?$DP@ DB '??', 0dfH, 0b2H, '?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KGEINEL@192?4168?40?4104@
CONST	SEGMENT
??_C@_0O@KGEINEL@192?4168?40?4104@ DB '192.168.0.104', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05IHCJPDPG@?$DP?$DP?l?$KD?$DP@
CONST	SEGMENT
??_C@_05IHCJPDPG@?$DP?$DP?l?$KD?$DP@ DB '??', 0ecH, 0a3H, '?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KLCEACOB@114?4215?4158?4113@
CONST	SEGMENT
??_C@_0BA@KLCEACOB@114?4215?4158?4113@ DB '114.215.158.113', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04DIMBHGPH@7001@
CONST	SEGMENT
??_C@_04DIMBHGPH@7001@ DB '7001', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PKCEPLOA@?$DP?$DP?l?i?$DP@
CONST	SEGMENT
??_C@_05PKCEPLOA@?$DP?$DP?l?i?$DP@ DB '??', 0ecH, 0e9H, '?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PFCHIMEP@127?40?40?41@
CONST	SEGMENT
??_C@_09PFCHIMEP@127?40?40?41@ DB '127.0.0.1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05HDEIOAAC@?$DP?$DP?S?$NO?$DP@
CONST	SEGMENT
??_C@_05HDEIOAAC@?$DP?$DP?S?$NO?$DP@ DB '??', 0d3H, 0deH, '?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LDMIILLH@8904001@
CONST	SEGMENT
??_C@_07LDMIILLH@8904001@ DB '8904001', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JFFKLGJF@?$CF02X@
CONST	SEGMENT
??_C@_04JFFKLGJF@?$CF02X@ DB '%02X', 00H		; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\Wgs\Common.cpp
;	COMDAT ?SetTestServer@@YAXXZ
_TEXT	SEGMENT
?SetTestServer@@YAXXZ PROC				; SetTestServer, COMDAT

; 212  : 	ZeroMemory(gmsv, sizeof(gameserver)*MAX_GMSV);

  00000	68 00 96 00 00	 push	 38400			; 00009600H
  00005	6a 00		 push	 0
  00007	68 00 00 00 00	 push	 OFFSET ?gmsv@@3PAUgameserver@@A
  0000c	e8 00 00 00 00	 call	 _memset

; 213  : 	ZeroMemory(gmgroup, sizeof(gamegroup)*MAX_GMGROUP);

  00011	68 c0 04 00 00	 push	 1216			; 000004c0H
  00016	6a 00		 push	 0
  00018	68 00 00 00 00	 push	 OFFSET ?gmgroup@@3PAUgamegroup@@A ; gmgroup
  0001d	e8 00 00 00 00	 call	 _memset

; 214  : 
; 215  : 	nGroup = 2;
; 216  : 	strcpy( gmgroup[0].name, "测试区");
; 217  : 	gmgroup[0].num = 2;
; 218  : 	gmgroup[0].startindex = 0;
; 219  : 	gmgroup[0].used = 1;
; 220  : 	strcpy( gmgroup[1].name, "测试大区");

  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_05HDEIOAAC@?$DP?$DP?S?$NO?$DP@
  00027	83 c4 18	 add	 esp, 24			; 00000018H
  0002a	a3 43 00 00 00	 mov	 DWORD PTR ?gmgroup@@3PAUgamegroup@@A+67, eax
  0002f	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_05HDEIOAAC@?$DP?$DP?S?$NO?$DP@+4

; 221  : 	gmgroup[1].num = 2;
; 222  : 	gmgroup[1].startindex = 2;
; 223  : 	gmgroup[1].used = 1;
; 224  : 
; 225  : 	strcpy( gmsv[0].ipaddr, "127.0.0.1");

  00036	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_09PFCHIMEP@127?40?40?41@
  0003e	66 a3 47 00 00
	00		 mov	 WORD PTR ?gmgroup@@3PAUgamegroup@@A+71, ax
  00044	0f b7 05 08 00
	00 00		 movzx	 eax, WORD PTR ??_C@_09PFCHIMEP@127?40?40?41@+8
  0004b	66 a3 09 00 00
	00		 mov	 WORD PTR ?gmsv@@3PAUgameserver@@A+9, ax

; 226  : 	strcpy( gmsv[0].name, "测试一线");

  00051	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_05PKCEPLOA@?$DP?$DP?l?i?$DP@
  00056	a3 c0 00 00 00	 mov	 DWORD PTR ?gmsv@@3PAUgameserver@@A+192, eax
  0005b	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_05PKCEPLOA@?$DP?$DP?l?i?$DP@+4

; 227  : 	strcpy( gmsv[0].port, "7001");

  00062	8a 0d 04 00 00
	00		 mov	 cl, BYTE PTR ??_C@_04DIMBHGPH@7001@+4
  00068	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ??_C@_04DIMBHGPH@7001@
  0006e	66 a3 c4 00 00
	00		 mov	 WORD PTR ?gmsv@@3PAUgameserver@@A+196, ax

; 228  : 	gmsv[0].used = '1';
; 229  : 
; 230  : 	strcpy( gmsv[1].ipaddr, "114.215.158.113");
; 231  : 	strcpy( gmsv[1].name, "测试二线");

  00074	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_05IHCJPDPG@?$DP?$DP?l?$KD?$DP@
  00079	a3 c0 01 00 00	 mov	 DWORD PTR ?gmsv@@3PAUgameserver@@A+448, eax
  0007e	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_05IHCJPDPG@?$DP?$DP?l?$KD?$DP@+4
  00085	66 a3 c4 01 00
	00		 mov	 WORD PTR ?gmsv@@3PAUgameserver@@A+452, ax

; 232  : 	strcpy( gmsv[1].port, "7001");
; 233  : 	gmsv[1].used = '1';
; 234  : 
; 235  : 	strcpy( gmsv[2].ipaddr, "192.168.0.104");

  0008b	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0O@KGEINEL@192?4168?40?4104@+8
  00090	a3 09 02 00 00	 mov	 DWORD PTR ?gmsv@@3PAUgameserver@@A+521, eax
  00095	0f b7 05 0c 00
	00 00		 movzx	 eax, WORD PTR ??_C@_0O@KGEINEL@192?4168?40?4104@+12
  0009c	66 a3 0d 02 00
	00		 mov	 WORD PTR ?gmsv@@3PAUgameserver@@A+525, ax

; 236  : 	strcpy( gmsv[2].name, "测试三线");

  000a2	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_05HIFDGNPO@?$DP?$DP?$NP?$LC?$DP@
  000a7	a3 c0 02 00 00	 mov	 DWORD PTR ?gmsv@@3PAUgameserver@@A+704, eax
  000ac	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_05HIFDGNPO@?$DP?$DP?$NP?$LC?$DP@+4
  000b3	66 0f d6 05 01
	00 00 00	 movq	 QWORD PTR ?gmsv@@3PAUgameserver@@A+1, xmm0
  000bb	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0BA@KLCEACOB@114?4215?4158?4113@
  000c2	66 a3 c4 02 00
	00		 mov	 WORD PTR ?gmsv@@3PAUgameserver@@A+708, ax

; 237  : 	strcpy( gmsv[2].port, "7001");
; 238  : 	gmsv[2].used = '1';
; 239  : 
; 240  : 	strcpy( gmsv[3].ipaddr, "my.gamma7happy.com");

  000c8	0f b7 05 10 00
	00 00		 movzx	 eax, WORD PTR ??_C@_0BD@PJBIDGKH@my?4gamma7happy?4com@+16
  000cf	66 a3 11 03 00
	00		 mov	 WORD PTR ?gmsv@@3PAUgameserver@@A+785, ax
  000d5	a0 12 00 00 00	 mov	 al, BYTE PTR ??_C@_0BD@PJBIDGKH@my?4gamma7happy?4com@+18
  000da	0f 11 05 01 01
	00 00		 movups	 XMMWORD PTR ?gmsv@@3PAUgameserver@@A+257, xmm0
  000e1	a2 13 03 00 00	 mov	 BYTE PTR ?gmsv@@3PAUgameserver@@A+787, al
  000e6	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0O@KGEINEL@192?4168?40?4104@

; 241  : 	strcpy( gmsv[3].name, "测试四线");

  000ee	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_05JOIAEPMB@?$DP?$DP?$NO?L?$DP@
  000f3	66 0f d6 05 01
	02 00 00	 movq	 QWORD PTR ?gmsv@@3PAUgameserver@@A+513, xmm0
  000fb	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0BD@PJBIDGKH@my?4gamma7happy?4com@
  00102	a3 c0 03 00 00	 mov	 DWORD PTR ?gmsv@@3PAUgameserver@@A+960, eax
  00107	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_05JOIAEPMB@?$DP?$DP?$NO?L?$DP@+4

; 242  : 	strcpy( gmsv[3].port, "7001");
; 243  : 	gmsv[3].used = '1';
; 244  : 
; 245  : 	HRESULT hr = ::CoInitialize(NULL);

  0010e	6a 00		 push	 0
  00110	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?nGroup@@3HA, 2 ; nGroup
  0011a	c7 05 03 00 00
	00 3f 3f 3f 00	 mov	 DWORD PTR ?gmgroup@@3PAUgamegroup@@A+3, 4144959 ; 003f3f3fH
  00124	66 c7 05 01 00
	00 00 02 00	 mov	 WORD PTR ?gmgroup@@3PAUgamegroup@@A+1, 2
  0012d	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?gmgroup@@3PAUgamegroup@@A, 1
  00134	66 c7 05 41 00
	00 00 02 02	 mov	 WORD PTR ?gmgroup@@3PAUgamegroup@@A+65, 514 ; 00000202H
  0013d	c6 05 40 00 00
	00 01		 mov	 BYTE PTR ?gmgroup@@3PAUgamegroup@@A+64, 1
  00144	89 15 80 00 00
	00		 mov	 DWORD PTR ?gmsv@@3PAUgameserver@@A+128, edx
  0014a	88 0d 84 00 00
	00		 mov	 BYTE PTR ?gmsv@@3PAUgameserver@@A+132, cl
  00150	c6 05 00 00 00
	00 31		 mov	 BYTE PTR ?gmsv@@3PAUgameserver@@A, 49 ; 00000031H
  00157	89 15 80 01 00
	00		 mov	 DWORD PTR ?gmsv@@3PAUgameserver@@A+384, edx
  0015d	88 0d 84 01 00
	00		 mov	 BYTE PTR ?gmsv@@3PAUgameserver@@A+388, cl
  00163	c6 05 00 01 00
	00 31		 mov	 BYTE PTR ?gmsv@@3PAUgameserver@@A+256, 49 ; 00000031H
  0016a	89 15 80 02 00
	00		 mov	 DWORD PTR ?gmsv@@3PAUgameserver@@A+640, edx
  00170	88 0d 84 02 00
	00		 mov	 BYTE PTR ?gmsv@@3PAUgameserver@@A+644, cl
  00176	c6 05 00 02 00
	00 31		 mov	 BYTE PTR ?gmsv@@3PAUgameserver@@A+512, 49 ; 00000031H
  0017d	0f 11 05 01 03
	00 00		 movups	 XMMWORD PTR ?gmsv@@3PAUgameserver@@A+769, xmm0
  00184	66 a3 c4 03 00
	00		 mov	 WORD PTR ?gmsv@@3PAUgameserver@@A+964, ax
  0018a	89 15 80 03 00
	00		 mov	 DWORD PTR ?gmsv@@3PAUgameserver@@A+896, edx
  00190	88 0d 84 03 00
	00		 mov	 BYTE PTR ?gmsv@@3PAUgameserver@@A+900, cl
  00196	c6 05 00 03 00
	00 31		 mov	 BYTE PTR ?gmsv@@3PAUgameserver@@A+768, 49 ; 00000031H
  0019d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoInitialize@4

; 246  : 	if (FAILED(hr))

  001a3	85 c0		 test	 eax, eax
  001a5	79 15		 jns	 SHORT $LN2@SetTestSer

; 247  : 	{
; 248  : 		MessageBoxA(NULL, "初始化失败", "ERROR", MB_OK);

  001a7	6a 00		 push	 0
  001a9	68 00 00 00 00	 push	 OFFSET ??_C@_05MBDEGLCK@ERROR@
  001ae	68 00 00 00 00	 push	 OFFSET ??_C@_09NGJPPDAN@?t?x?c?$LH?$PL?y?c?w?$DP@
  001b3	6a 00		 push	 0
  001b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 252  : 
; 253  : }

  001bb	c3		 ret	 0
$LN2@SetTestSer:

; 249  : 		return;
; 250  : 	}
; 251  : 	::CoUninitialize();

  001bc	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__CoUninitialize@0
?SetTestServer@@YAXXZ ENDP				; SetTestServer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\Wgs\Common.cpp
;	COMDAT ?DoSKey@@YAXXZ
_TEXT	SEGMENT
_iLen$ = -4						; size = 4
?DoSKey@@YAXXZ PROC					; DoSKey, COMDAT

; 172  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 173  : 	int iLen;
; 174  : 	AddParamForFormat(M_SKEY,FORMAT_START);

  00004	6a 01		 push	 1
  00006	6a 53		 push	 83			; 00000053H
  00008	e8 00 00 00 00	 call	 ?AddParamForFormat@@YAXDK@Z ; AddParamForFormat

; 175  : 	PKey_Init();

  0000d	e8 00 00 00 00	 call	 ?PKey_Init@@YAXXZ	; PKey_Init

; 176  : 	AddParamForFormat(P_Key1,32,FORMAT_FINISH);

  00012	6a 02		 push	 2
  00014	6a 20		 push	 32			; 00000020H
  00016	68 00 00 00 00	 push	 OFFSET ?P_Key1@@3PADA	; P_Key1
  0001b	e8 00 00 00 00	 call	 ?AddParamForFormat@@YAXPADHK@Z ; AddParamForFormat

; 177  : 	LPTSTR lpstr=GetString(iLen,SZ_ECB);

  00020	8d 45 fc	 lea	 eax, DWORD PTR _iLen$[ebp]
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_07LDMIILLH@8904001@
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?GetString@@YAPADAAHPAD@Z ; GetString

; 178  : 	appendWriteBuf(NULL,lpstr,iLen);

  0002e	ff 75 fc	 push	 DWORD PTR _iLen$[ebp]
  00031	50		 push	 eax
  00032	6a 00		 push	 0
  00034	e8 00 00 00 00	 call	 ?appendWriteBuf@@YAHHPADH@Z ; appendWriteBuf
  00039	83 c4 28	 add	 esp, 40			; 00000028H

; 179  : }

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?DoSKey@@YAXXZ ENDP					; DoSKey
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\Wgs\Common.cpp
;	COMDAT ?DoHellow@@YAXXZ
_TEXT	SEGMENT
_iLen$ = -4						; size = 4
?DoHellow@@YAXXZ PROC					; DoHellow, COMDAT

; 162  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 163  : 	AddParamForFormat(M_HELO2,FORMAT_START);

  00004	6a 01		 push	 1
  00006	6a 4a		 push	 74			; 0000004aH
  00008	e8 00 00 00 00	 call	 ?AddParamForFormat@@YAXDK@Z ; AddParamForFormat

; 164  : 	AddParamForFormat(idKey.buffer,idKey.cnt,NULL);

  0000d	0f b6 05 07 01
	00 00		 movzx	 eax, BYTE PTR ?idKey@@3USTR_BUFFER@@A+263
  00014	6a 00		 push	 0
  00016	50		 push	 eax
  00017	68 00 00 00 00	 push	 OFFSET ?idKey@@3USTR_BUFFER@@A ; idKey
  0001c	e8 00 00 00 00	 call	 ?AddParamForFormat@@YAXPADHK@Z ; AddParamForFormat

; 165  : 	AddParamForFormat(passwd.buffer,passwd.cnt,FORMAT_FINISH);

  00021	0f b6 05 07 01
	00 00		 movzx	 eax, BYTE PTR ?passwd@@3USTR_BUFFER@@A+263
  00028	6a 02		 push	 2
  0002a	50		 push	 eax
  0002b	68 00 00 00 00	 push	 OFFSET ?passwd@@3USTR_BUFFER@@A ; passwd
  00030	e8 00 00 00 00	 call	 ?AddParamForFormat@@YAXPADHK@Z ; AddParamForFormat

; 166  : 	int iLen;
; 167  : 	LPTSTR lpstr=GetString(iLen,P_Key);

  00035	8d 45 fc	 lea	 eax, DWORD PTR _iLen$[ebp]
  00038	68 00 00 00 00	 push	 OFFSET ?P_Key@@3PADA	; P_Key
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?GetString@@YAPADAAHPAD@Z ; GetString

; 168  : 	appendWriteBuf(NULL,lpstr,iLen);

  00043	ff 75 fc	 push	 DWORD PTR _iLen$[ebp]
  00046	50		 push	 eax
  00047	6a 00		 push	 0
  00049	e8 00 00 00 00	 call	 ?appendWriteBuf@@YAHHPADH@Z ; appendWriteBuf
  0004e	83 c4 34	 add	 esp, 52			; 00000034H

; 169  : }

  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?DoHellow@@YAXXZ ENDP					; DoHellow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\Wgs\Common.cpp
;	COMDAT ?ReadWGSMessage@@YAHPADAAH@Z
_TEXT	SEGMENT
_lpstr$ = 8						; size = 4
_iStrLen$ = 12						; size = 4
?ReadWGSMessage@@YAHPADAAH@Z PROC			; ReadWGSMessage, COMDAT

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 57   : 	TCHAR cMessage=0;
; 58   : 	Parameter *param;
; 59   : 	if(RET_OK==AnalyzeMessage(lpstr,iStrLen)){

  00004	8b 7d 0c	 mov	 edi, DWORD PTR _iStrLen$[ebp]
  00007	ff 37		 push	 DWORD PTR [edi]
  00009	ff 75 08	 push	 DWORD PTR _lpstr$[ebp]
  0000c	e8 00 00 00 00	 call	 ?AnalyzeMessage@@YAKPADH@Z ; AnalyzeMessage
  00011	83 c4 08	 add	 esp, 8
  00014	39 05 00 00 00
	00		 cmp	 DWORD PTR ?RET_OK@@3KB, eax ; RET_OK
  0001a	0f 85 91 01 00
	00		 jne	 $LN6@ReadWGSMes

; 60   : 		if(WGS==dwServer){

  00020	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?dwServer@@3KA, 1 ; dwServer
  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ?messHead@@3PAUMessNode@@A ; messHead
  0002c	53		 push	 ebx
  0002d	56		 push	 esi
  0002e	0f 85 bc 00 00
	00		 jne	 $LN27@ReadWGSMes

; 61   : 			while(messHead){

  00034	85 c0		 test	 eax, eax
  00036	0f 84 65 01 00
	00		 je	 $LN5@ReadWGSMes
  0003c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__lstrcpyA@8
$LL2@ReadWGSMes:

; 62   : 				cMessage=*messHead->param->lpstrParam;

  00042	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	8a 18		 mov	 bl, BYTE PTR [eax]

; 63   : 				param=ReleaseMessHeadParam();

  00049	e8 00 00 00 00	 call	 ?ReleaseMessHeadParam@@YAPAUParameter@@XZ ; ReleaseMessHeadParam

; 64   : 				if(M_REDI==cMessage){

  0004e	80 fb 52	 cmp	 bl, 82			; 00000052H
  00051	75 1e		 jne	 SHORT $LN10@ReadWGSMes

; 65   : 					if(GetIP_PORT(param)){

  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?GetIP_PORT@@YAHPAUParameter@@@Z ; GetIP_PORT
  00059	83 c4 04	 add	 esp, 4
  0005c	85 c0		 test	 eax, eax
  0005e	74 72		 je	 SHORT $LN16@ReadWGSMes

; 66   : 						iWGS=2;

  00060	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?iWGS@@3HA, 2	; iWGS

; 67   : 						ReleaseMessList();

  0006a	e8 00 00 00 00	 call	 ?ReleaseMessList@@YAXXZ	; ReleaseMessList

; 68   : 					}

  0006f	eb 61		 jmp	 SHORT $LN16@ReadWGSMes
$LN10@ReadWGSMes:

; 69   : 				}else if(M_PKEY==cMessage){

  00071	80 fb 54	 cmp	 bl, 84			; 00000054H
  00074	75 33		 jne	 SHORT $LN13@ReadWGSMes

; 70   : 					iEncrypt=E_ECB;
; 71   : 					dwServer=CS;
; 72   : 					GetEncrypt(param);

  00076	50		 push	 eax
  00077	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?iEncrypt@@3HA, 1 ; iEncrypt
  00081	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 2 ; dwServer
  0008b	e8 00 00 00 00	 call	 ?GetEncrypt@@YAXPAUParameter@@@Z ; GetEncrypt
  00090	83 c4 04	 add	 esp, 4

; 73   : 					PKey_Init();

  00093	e8 00 00 00 00	 call	 ?PKey_Init@@YAXXZ	; PKey_Init

; 74   : 					iWGS=4;

  00098	c7 05 00 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?iWGS@@3HA, 4	; iWGS

; 75   : 					ReleaseMessList();

  000a2	e8 00 00 00 00	 call	 ?ReleaseMessList@@YAXXZ	; ReleaseMessList
  000a7	eb 29		 jmp	 SHORT $LN16@ReadWGSMes
$LN13@ReadWGSMes:

; 76   : 				}else if(M_ERRO==cMessage){

  000a9	80 fb 45	 cmp	 bl, 69			; 00000045H
  000ac	75 24		 jne	 SHORT $LN16@ReadWGSMes

; 77   : 					iWGS=9;
; 78   : 					if(messHead->param && messHead->param->lpstrParam)

  000ae	a1 00 00 00 00	 mov	 eax, DWORD PTR ?messHead@@3PAUMessNode@@A ; messHead
  000b3	c7 05 00 00 00
	00 09 00 00 00	 mov	 DWORD PTR ?iWGS@@3HA, 9	; iWGS
  000bd	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c0	85 c0		 test	 eax, eax
  000c2	74 0e		 je	 SHORT $LN16@ReadWGSMes
  000c4	8b 00		 mov	 eax, DWORD PTR [eax]
  000c6	85 c0		 test	 eax, eax
  000c8	74 08		 je	 SHORT $LN16@ReadWGSMes

; 79   : 						lstrcpy(szError,messHead->param->lpstrParam);

  000ca	50		 push	 eax
  000cb	68 00 00 00 00	 push	 OFFSET ?szError@@3PADA	; szError
  000d0	ff d6		 call	 esi
$LN16@ReadWGSMes:

; 80   : 				}
; 81   : 				RemoveMessHead();

  000d2	e8 00 00 00 00	 call	 ?RemoveMessHead@@YAXXZ	; RemoveMessHead
  000d7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?messHead@@3PAUMessNode@@A ; messHead
  000dc	85 c0		 test	 eax, eax
  000de	0f 85 5e ff ff
	ff		 jne	 $LL2@ReadWGSMes

; 109  : 	iStrLen=0;
; 110  : 	return TRUE;

  000e4	5e		 pop	 esi
  000e5	89 07		 mov	 DWORD PTR [edi], eax
  000e7	b8 01 00 00 00	 mov	 eax, 1
  000ec	5b		 pop	 ebx
  000ed	5f		 pop	 edi

; 111  : }

  000ee	5d		 pop	 ebp
  000ef	c3		 ret	 0
$LN27@ReadWGSMes:

; 82   : 			}
; 83   : 		}else{
; 84   : 			while(messHead){

  000f0	85 c0		 test	 eax, eax
  000f2	0f 84 a9 00 00
	00		 je	 $LN5@ReadWGSMes
  000f8	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__lstrcpyA@8
  000fe	66 90		 npad	 2
$LL4@ReadWGSMes:

; 85   : 				cMessage=*messHead->param->lpstrParam;

  00100	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00103	8b 00		 mov	 eax, DWORD PTR [eax]
  00105	8a 18		 mov	 bl, BYTE PTR [eax]

; 86   : 				param=ReleaseMessHeadParam();

  00107	e8 00 00 00 00	 call	 ?ReleaseMessHeadParam@@YAPAUParameter@@XZ ; ReleaseMessHeadParam

; 87   : 				if(M_PKEY==cMessage){

  0010c	80 fb 54	 cmp	 bl, 84			; 00000054H
  0010f	75 1f		 jne	 SHORT $LN17@ReadWGSMes

; 88   : 					iEncrypt=E_ECB;
; 89   : 					GetEncrypt(param);

  00111	50		 push	 eax
  00112	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?iEncrypt@@3HA, 1 ; iEncrypt
  0011c	e8 00 00 00 00	 call	 ?GetEncrypt@@YAXPAUParameter@@@Z ; GetEncrypt
  00121	83 c4 04	 add	 esp, 4

; 90   : 					iWGS=4;

  00124	c7 05 00 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?iWGS@@3HA, 4	; iWGS
  0012e	eb 5f		 jmp	 SHORT $LN23@ReadWGSMes
$LN17@ReadWGSMes:

; 91   : 				}else if(M_CONT==cMessage){

  00130	80 fb 55	 cmp	 bl, 85			; 00000055H
  00133	75 0c		 jne	 SHORT $LN19@ReadWGSMes

; 92   : 					iWGS=6;

  00135	c7 05 00 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?iWGS@@3HA, 6	; iWGS
  0013f	eb 4e		 jmp	 SHORT $LN23@ReadWGSMes
$LN19@ReadWGSMes:

; 93   : 				}else if(M_GOTO==cMessage){

  00141	80 fb 47	 cmp	 bl, 71			; 00000047H
  00144	75 1b		 jne	 SHORT $LN21@ReadWGSMes

; 94   : 					iWGS=8;

  00146	c7 05 00 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?iWGS@@3HA, 8	; iWGS

; 95   : 					iEncrypt=E_NO;

  00150	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?iEncrypt@@3HA, 2 ; iEncrypt

; 96   : 					ipAddressAnalyze();

  0015a	e8 00 00 00 00	 call	 ?ipAddressAnalyze@@YAXXZ ; ipAddressAnalyze

; 97   : 					ReleaseMessList();

  0015f	eb 29		 jmp	 SHORT $LN24@ReadWGSMes
$LN21@ReadWGSMes:

; 98   : 				}else if(M_ERRO==cMessage){

  00161	80 fb 45	 cmp	 bl, 69			; 00000045H
  00164	75 29		 jne	 SHORT $LN23@ReadWGSMes

; 99   : 					iWGS=9;
; 100  : 					if(messHead->param && messHead->param->lpstrParam)

  00166	a1 00 00 00 00	 mov	 eax, DWORD PTR ?messHead@@3PAUMessNode@@A ; messHead
  0016b	c7 05 00 00 00
	00 09 00 00 00	 mov	 DWORD PTR ?iWGS@@3HA, 9	; iWGS
  00175	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00178	85 c0		 test	 eax, eax
  0017a	74 0e		 je	 SHORT $LN24@ReadWGSMes
  0017c	8b 00		 mov	 eax, DWORD PTR [eax]
  0017e	85 c0		 test	 eax, eax
  00180	74 08		 je	 SHORT $LN24@ReadWGSMes

; 101  : 						lstrcpy(szError,messHead->param->lpstrParam);

  00182	50		 push	 eax
  00183	68 00 00 00 00	 push	 OFFSET ?szError@@3PADA	; szError
  00188	ff d6		 call	 esi
$LN24@ReadWGSMes:

; 102  : 					ReleaseMessList();
; 103  : 				}
; 104  : 				RemoveMessHead();

  0018a	e8 00 00 00 00	 call	 ?ReleaseMessList@@YAXXZ	; ReleaseMessList
$LN23@ReadWGSMes:
  0018f	e8 00 00 00 00	 call	 ?RemoveMessHead@@YAXXZ	; RemoveMessHead
  00194	a1 00 00 00 00	 mov	 eax, DWORD PTR ?messHead@@3PAUMessNode@@A ; messHead
  00199	85 c0		 test	 eax, eax
  0019b	0f 85 5f ff ff
	ff		 jne	 $LL4@ReadWGSMes
$LN5@ReadWGSMes:

; 109  : 	iStrLen=0;
; 110  : 	return TRUE;

  001a1	5e		 pop	 esi
  001a2	5b		 pop	 ebx
  001a3	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  001a9	b8 01 00 00 00	 mov	 eax, 1
  001ae	5f		 pop	 edi

; 111  : }

  001af	5d		 pop	 ebp
  001b0	c3		 ret	 0
$LN6@ReadWGSMes:

; 105  : 			}
; 106  : 		}
; 107  : 	}else
; 108  : 		return FALSE;

  001b1	33 c0		 xor	 eax, eax
  001b3	5f		 pop	 edi

; 111  : }

  001b4	5d		 pop	 ebp
  001b5	c3		 ret	 0
?ReadWGSMessage@@YAHPADAAH@Z ENDP			; ReadWGSMessage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\Wgs\Common.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\Wgs\Common.cpp
;	COMDAT ?ipAddressAnalyze@@YAXXZ
_TEXT	SEGMENT
_sss$1 = -84						; size = 4
_sss$2 = -80						; size = 4
_hkey$ = -76						; size = 4
_dwCafeKey$1$ = -72					; size = 4
_j$1$ = -68						; size = 4
_indexgm$1$ = -64					; size = 4
_nGroup1$2$ = -60					; size = 4
_szIP$ = -56						; size = 50
__$ArrayPad$ = -4					; size = 4
?ipAddressAnalyze@@YAXXZ PROC				; ipAddressAnalyze, COMDAT

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 257  : 	char szIP[50];
; 258  : 	DWORD dwLevel = 0;

  00013	33 db		 xor	 ebx, ebx

; 259  : 	DWORD dwID, dwResult;
; 260  : 	int nGroup1, indexgm;
; 261  : 	LPSTR lpstrTemp;
; 262  : 	DWORD dwCafeKey = GetCafeNumber();

  00015	e8 00 00 00 00	 call	 ?GetCafeNumber@@YAKXZ	; GetCafeNumber

; 263  : 	Parameter *param = messHead->param;

  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?messHead@@3PAUMessNode@@A ; messHead
  00020	8b f8		 mov	 edi, eax

; 264  : 	HKEY		hkey;
; 265  : 	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Software\\Waei\\石器时代\\5.00.000", 0, KEY_READ, &hkey) == ERROR_SUCCESS) {

  00022	8d 45 b4	 lea	 eax, DWORD PTR _hkey$[ebp]
  00025	89 7d b8	 mov	 DWORD PTR _dwCafeKey$1$[ebp], edi
  00028	50		 push	 eax
  00029	68 19 00 02 00	 push	 131097			; 00020019H
  0002e	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00031	53		 push	 ebx
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@JBCHKPGG@Software?2Waei?2?$OA?$LE?P?o?$DP?S?$NL?25?400?4000@
  00037	68 02 00 00 80	 push	 -2147483646		; 80000002H
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00042	85 c0		 test	 eax, eax
  00044	75 0f		 jne	 SHORT $LN8@ipAddressA

; 266  : 		dwCafeKey |= 0x02;
; 267  : 		RegCloseKey(hkey);

  00046	ff 75 b4	 push	 DWORD PTR _hkey$[ebp]
  00049	83 cf 02	 or	 edi, 2
  0004c	89 7d b8	 mov	 DWORD PTR _dwCafeKey$1$[ebp], edi
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN8@ipAddressA:

; 268  : 	}
; 269  : 	if (param && param->lpstrParam) {

  00055	85 f6		 test	 esi, esi
  00057	0f 84 de 02 00
	00		 je	 $LN29@ipAddressA
  0005d	39 1e		 cmp	 DWORD PTR [esi], ebx
  0005f	0f 84 d6 02 00
	00		 je	 $LN29@ipAddressA

; 270  : 		nGroup = 0;//
; 271  : 		indexgm = 0;
; 272  : 		ZeroMemory(gmsv, sizeof(gameserver)*MAX_GMSV);

  00065	68 00 96 00 00	 push	 38400			; 00009600H
  0006a	6a 00		 push	 0
  0006c	68 00 00 00 00	 push	 OFFSET ?gmsv@@3PAUgameserver@@A
  00071	89 1d 00 00 00
	00		 mov	 DWORD PTR ?nGroup@@3HA, ebx ; nGroup
  00077	89 5d c0	 mov	 DWORD PTR _indexgm$1$[ebp], ebx
  0007a	e8 00 00 00 00	 call	 _memset

; 273  : 		ZeroMemory(gmgroup, sizeof(gamegroup)*MAX_GMGROUP);

  0007f	68 c0 04 00 00	 push	 1216			; 000004c0H
  00084	6a 00		 push	 0
  00086	68 00 00 00 00	 push	 OFFSET ?gmgroup@@3PAUgamegroup@@A ; gmgroup
  0008b	e8 00 00 00 00	 call	 _memset

; 274  : 		nGroup1 = atoi(param->lpstrParam);

  00090	ff 36		 push	 DWORD PTR [esi]
  00092	e8 00 00 00 00	 call	 _atoi
  00097	8b f0		 mov	 esi, eax
  00099	83 c4 1c	 add	 esp, 28			; 0000001cH
  0009c	89 75 c4	 mov	 DWORD PTR _nGroup1$2$[ebp], esi

; 275  : 		if (nGroup1 > MAX_GMGROUP)

  0009f	83 fe 13	 cmp	 esi, 19			; 00000013H
  000a2	7e 11		 jle	 SHORT $LN10@ipAddressA

; 276  : 			nGroup1 = MAX_GMGROUP;

  000a4	be 13 00 00 00	 mov	 esi, 19			; 00000013H
  000a9	89 75 c4	 mov	 DWORD PTR _nGroup1$2$[ebp], esi
  000ac	e8 00 00 00 00	 call	 ?ReleaseMessHeadParam@@YAPAUParameter@@XZ ; ReleaseMessHeadParam
  000b1	8b d0		 mov	 edx, eax
  000b3	eb 0f		 jmp	 SHORT $LL77@ipAddressA
$LN10@ipAddressA:

; 277  : 		param = ReleaseMessHeadParam();

  000b5	e8 00 00 00 00	 call	 ?ReleaseMessHeadParam@@YAPAUParameter@@XZ ; ReleaseMessHeadParam
  000ba	8b d0		 mov	 edx, eax

; 278  : 
; 279  : #ifdef _SHOW_COUNT						// WON ADD 秀服务器流量
; 280  : 		if (param && param->lpstrParam) {
; 281  : 			param = ReleaseMessHeadParam();
; 282  : 		}
; 283  : #endif
; 284  : 
; 285  : 		for (int i = 0; i < nGroup1; i++) {

  000bc	85 f6		 test	 esi, esi
  000be	0f 8e 39 02 00
	00		 jle	 $LN3@ipAddressA
$LL77@ipAddressA:

; 286  : 			if (param && param->lpstrParam) {

  000c4	85 d2		 test	 edx, edx
  000c6	0f 84 25 02 00
	00		 je	 $LN2@ipAddressA
  000cc	8b 02		 mov	 eax, DWORD PTR [edx]
  000ce	85 c0		 test	 eax, eax
  000d0	74 2a		 je	 SHORT $LN76@ipAddressA

; 287  : 				dwID = atoi(param->lpstrParam);

  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 _atoi
  000d8	83 c4 04	 add	 esp, 4
  000db	8b f0		 mov	 esi, eax

; 288  : 				param = ReleaseMessHeadParam();

  000dd	e8 00 00 00 00	 call	 ?ReleaseMessHeadParam@@YAPAUParameter@@XZ ; ReleaseMessHeadParam
  000e2	8b d0		 mov	 edx, eax

; 289  : 				dwResult = dwID & dwCafeKey;
; 290  : 				dwLevel = 1;				//可以选

  000e4	bb 01 00 00 00	 mov	 ebx, 1

; 291  : 				if (dwCafeKey) {

  000e9	85 ff		 test	 edi, edi
  000eb	75 07		 jne	 SHORT $LN14@ipAddressA

; 292  : 					// 只要有小地球就可以看到所有星系
; 293  : 					/*if(dwID){
; 294  : 					if( 0 == dwResult)
; 295  : 					dwLevel = 0;	//看不到
; 296  : 					}*/
; 297  : 				}
; 298  : 				else {
; 299  : 					if (dwID) {

  000ed	33 c0		 xor	 eax, eax
  000ef	85 f6		 test	 esi, esi
  000f1	0f 45 d8	 cmovne	 ebx, eax
$LN14@ipAddressA:

; 300  : 						dwLevel = 0;//看不到						
; 301  : 					}
; 302  : #ifdef _8_TEST
; 303  : 					if (dwID == 2)
; 304  : 						dwLevel = 1;
; 305  : 					else
; 306  : 						dwLevel = 0;
; 307  : #endif
; 308  : 				}
; 309  : 				/*
; 310  : 				dwLevel = 1;	//可以选
; 311  : 				if( 0 == dwResult){
; 312  : 				if( dwID > 1)
; 313  : 				dwLevel = 2;	//只能看不能选
; 314  : 				else if( 1 == dwID)
; 315  : 				dwLevel = 0;	//看不到
; 316  : 				}
; 317  : 				*/
; 318  : 			}
; 319  : 			if (param && param->lpstrParam) {

  000f4	85 d2		 test	 edx, edx
  000f6	0f 84 f2 01 00
	00		 je	 $LN86@ipAddressA
$LN76@ipAddressA:
  000fc	8b 32		 mov	 esi, DWORD PTR [edx]
  000fe	85 f6		 test	 esi, esi
  00100	74 30		 je	 SHORT $LN75@ipAddressA

; 320  : 				if (dwLevel)

  00102	85 db		 test	 ebx, ebx
  00104	74 1d		 je	 SHORT $LN16@ipAddressA

; 321  : 					strcpy(gmgroup[nGroup].name, param->lpstrParam);

  00106	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nGroup@@3HA ; nGroup
  0010c	c1 e1 06	 shl	 ecx, 6
  0010f	81 c1 03 00 00
	00		 add	 ecx, OFFSET ?gmgroup@@3PAUgamegroup@@A+3
$LL31@ipAddressA:
  00115	8a 06		 mov	 al, BYTE PTR [esi]
  00117	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  0011a	88 01		 mov	 BYTE PTR [ecx], al
  0011c	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  0011f	84 c0		 test	 al, al
  00121	75 f2		 jne	 SHORT $LL31@ipAddressA
$LN16@ipAddressA:

; 322  : 				param = ReleaseMessHeadParam();

  00123	e8 00 00 00 00	 call	 ?ReleaseMessHeadParam@@YAPAUParameter@@XZ ; ReleaseMessHeadParam
  00128	8b d0		 mov	 edx, eax

; 323  : 			}
; 324  : 			if (param && param->lpstrParam) {

  0012a	85 d2		 test	 edx, edx
  0012c	0f 84 bc 01 00
	00		 je	 $LN86@ipAddressA
$LN75@ipAddressA:
  00132	8b 02		 mov	 eax, DWORD PTR [edx]
  00134	85 c0		 test	 eax, eax
  00136	74 27		 je	 SHORT $LN74@ipAddressA

; 325  : 				gmgroup[nGroup].num = atoi(param->lpstrParam);

  00138	50		 push	 eax
  00139	e8 00 00 00 00	 call	 _atoi
  0013e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nGroup@@3HA ; nGroup
  00144	83 c4 04	 add	 esp, 4
  00147	c1 e1 06	 shl	 ecx, 6
  0014a	88 81 01 00 00
	00		 mov	 BYTE PTR ?gmgroup@@3PAUgamegroup@@A[ecx+1], al

; 326  : 				param = ReleaseMessHeadParam();

  00150	e8 00 00 00 00	 call	 ?ReleaseMessHeadParam@@YAPAUParameter@@XZ ; ReleaseMessHeadParam
  00155	8b d0		 mov	 edx, eax

; 327  : 			}
; 328  : 			if (param && param->lpstrParam) {

  00157	85 d2		 test	 edx, edx
  00159	0f 84 8f 01 00
	00		 je	 $LN86@ipAddressA
$LN74@ipAddressA:
  0015f	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00161	85 c9		 test	 ecx, ecx
  00163	0f 84 85 01 00
	00		 je	 $LN86@ipAddressA

; 329  : 				strcpy(szIP, param->lpstrParam);

  00169	8d 55 c8	 lea	 edx, DWORD PTR _szIP$[ebp]
  0016c	2b d1		 sub	 edx, ecx
  0016e	66 90		 npad	 2
$LL32@ipAddressA:
  00170	8a 01		 mov	 al, BYTE PTR [ecx]
  00172	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00175	88 44 11 ff	 mov	 BYTE PTR [ecx+edx-1], al
  00179	84 c0		 test	 al, al
  0017b	75 f3		 jne	 SHORT $LL32@ipAddressA

; 330  : 				param = ReleaseMessHeadParam();

  0017d	e8 00 00 00 00	 call	 ?ReleaseMessHeadParam@@YAPAUParameter@@XZ ; ReleaseMessHeadParam

; 331  : 				gmgroup[nGroup].startindex = indexgm;

  00182	8b 4d c0	 mov	 ecx, DWORD PTR _indexgm$1$[ebp]
  00185	8b d0		 mov	 edx, eax
  00187	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nGroup@@3HA ; nGroup

; 332  : 
; 333  : #ifdef _SHOW_COUNT						// WON ADD 秀服务器流量
; 334  : 				if (param && param->lpstrParam) {
; 335  : 					param = ReleaseMessHeadParam();
; 336  : 				}
; 337  : #endif
; 338  : 
; 339  : 
; 340  : 				for (int j = 0; j<gmgroup[nGroup].num && indexgm < MAX_GMSV; j++, indexgm++) {

  0018c	33 f6		 xor	 esi, esi
  0018e	c1 e0 06	 shl	 eax, 6
  00191	89 75 bc	 mov	 DWORD PTR _j$1$[ebp], esi
  00194	88 88 02 00 00
	00		 mov	 BYTE PTR ?gmgroup@@3PAUgamegroup@@A[eax+2], cl
  0019a	80 b8 01 00 00
	00 00		 cmp	 BYTE PTR ?gmgroup@@3PAUgamegroup@@A[eax+1], 0
  001a1	0f 8e 2f 01 00
	00		 jle	 $LN6@ipAddressA

; 330  : 				param = ReleaseMessHeadParam();

  001a7	8b f9		 mov	 edi, ecx
  001a9	c1 e7 08	 shl	 edi, 8
  001ac	81 c7 01 00 00
	00		 add	 edi, OFFSET ?gmsv@@3PAUgameserver@@A+1
$LL7@ipAddressA:

; 332  : 
; 333  : #ifdef _SHOW_COUNT						// WON ADD 秀服务器流量
; 334  : 				if (param && param->lpstrParam) {
; 335  : 					param = ReleaseMessHeadParam();
; 336  : 				}
; 337  : #endif
; 338  : 
; 339  : 
; 340  : 				for (int j = 0; j<gmgroup[nGroup].num && indexgm < MAX_GMSV; j++, indexgm++) {

  001b2	81 ff 01 96 00
	00		 cmp	 edi, OFFSET ?gmsv@@3PAUgameserver@@A+38401
  001b8	0f 8d 15 01 00
	00		 jge	 $LN80@ipAddressA

; 341  : 					if (param && param->lpstrParam) {

  001be	85 d2		 test	 edx, edx
  001c0	0f 84 e8 00 00
	00		 je	 $LN5@ipAddressA
  001c6	8b 0a		 mov	 ecx, DWORD PTR [edx]
  001c8	85 c9		 test	 ecx, ecx
  001ca	74 27		 je	 SHORT $LN73@ipAddressA

; 342  : 						if (dwLevel)

  001cc	85 db		 test	 ebx, ebx
  001ce	74 14		 je	 SHORT $LN20@ipAddressA

; 343  : 							strcpy(gmsv[indexgm].name, param->lpstrParam);

  001d0	8d 97 bf 00 00
	00		 lea	 edx, DWORD PTR [edi+191]
$LL33@ipAddressA:
  001d6	8a 01		 mov	 al, BYTE PTR [ecx]
  001d8	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  001db	88 02		 mov	 BYTE PTR [edx], al
  001dd	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  001e0	84 c0		 test	 al, al
  001e2	75 f2		 jne	 SHORT $LL33@ipAddressA
$LN20@ipAddressA:

; 344  : 						param = ReleaseMessHeadParam();

  001e4	e8 00 00 00 00	 call	 ?ReleaseMessHeadParam@@YAPAUParameter@@XZ ; ReleaseMessHeadParam
  001e9	8b d0		 mov	 edx, eax

; 345  : 					}
; 346  : 					if (param && param->lpstrParam) {

  001eb	85 d2		 test	 edx, edx
  001ed	0f 84 b8 00 00
	00		 je	 $LN84@ipAddressA
$LN73@ipAddressA:
  001f3	8b 02		 mov	 eax, DWORD PTR [edx]
  001f5	85 c0		 test	 eax, eax
  001f7	0f 84 ae 00 00
	00		 je	 $LN84@ipAddressA

; 347  : 						if (dwLevel) {

  001fd	85 db		 test	 ebx, ebx
  001ff	0f 84 9f 00 00
	00		 je	 $LN26@ipAddressA

; 348  : 							char *sss;
; 349  : 							if (lpstrTemp = strtok_s(param->lpstrParam, ":", &sss)) {

  00205	8d 4d b0	 lea	 ecx, DWORD PTR _sss$2[ebp]
  00208	51		 push	 ecx
  00209	68 00 00 00 00	 push	 OFFSET ??_C@_01JLIPDDHJ@?3@
  0020e	50		 push	 eax
  0020f	e8 00 00 00 00	 call	 _strtok_s
  00214	8b f0		 mov	 esi, eax
  00216	83 c4 0c	 add	 esp, 12			; 0000000cH
  00219	85 f6		 test	 esi, esi
  0021b	0f 84 80 00 00
	00		 je	 $LN82@ipAddressA

; 350  : 								if (szIP[0]) {	//同一group在同一C class的范围

  00221	80 7d c8 00	 cmp	 BYTE PTR _szIP$[ebp], 0
  00225	74 31		 je	 SHORT $LN24@ipAddressA

; 351  : 									strcpy(gmsv[indexgm].ipaddr, szIP);

  00227	8d 4d c8	 lea	 ecx, DWORD PTR _szIP$[ebp]
  0022a	8b d7		 mov	 edx, edi
  0022c	8b c1		 mov	 eax, ecx
  0022e	2b d0		 sub	 edx, eax
$LL34@ipAddressA:
  00230	8a 01		 mov	 al, BYTE PTR [ecx]
  00232	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00235	88 44 11 ff	 mov	 BYTE PTR [ecx+edx-1], al
  00239	84 c0		 test	 al, al
  0023b	75 f3		 jne	 SHORT $LL34@ipAddressA
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h

; 83   : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(

  0023d	68 00 00 00 00	 push	 OFFSET ??_C@_01LFCBOECM@?4@
  00242	6a 7f		 push	 127			; 0000007fH
  00244	57		 push	 edi
  00245	e8 00 00 00 00	 call	 _strcat_s
  0024a	56		 push	 esi
  0024b	6a 7f		 push	 127			; 0000007fH
  0024d	57		 push	 edi
  0024e	e8 00 00 00 00	 call	 _strcat_s
  00253	83 c4 18	 add	 esp, 24			; 00000018H
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\Wgs\Common.cpp

; 354  : 								}

  00256	eb 15		 jmp	 SHORT $LN25@ipAddressA
$LN24@ipAddressA:

; 355  : 								else			//Copy 完整的IP address
; 356  : 									strcpy(gmsv[indexgm].ipaddr, lpstrTemp);

  00258	8b cf		 mov	 ecx, edi
  0025a	2b ce		 sub	 ecx, esi
  0025c	0f 1f 40 00	 npad	 4
$LL35@ipAddressA:
  00260	8a 06		 mov	 al, BYTE PTR [esi]
  00262	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  00265	88 44 31 ff	 mov	 BYTE PTR [ecx+esi-1], al
  00269	84 c0		 test	 al, al
  0026b	75 f3		 jne	 SHORT $LL35@ipAddressA
$LN25@ipAddressA:

; 357  : 								char *sss;
; 358  : 								if (lpstrTemp = strtok_s(NULL, ":", &sss)) {

  0026d	8d 45 ac	 lea	 eax, DWORD PTR _sss$1[ebp]
  00270	50		 push	 eax
  00271	68 00 00 00 00	 push	 OFFSET ??_C@_01JLIPDDHJ@?3@
  00276	6a 00		 push	 0
  00278	e8 00 00 00 00	 call	 _strtok_s
  0027d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00280	85 c0		 test	 eax, eax
  00282	74 1d		 je	 SHORT $LN82@ipAddressA

; 359  : 									strcpy(gmsv[indexgm].port, lpstrTemp);

  00284	8b d7		 mov	 edx, edi
  00286	2b d0		 sub	 edx, eax
  00288	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL36@ipAddressA:
  00290	8a 08		 mov	 cl, BYTE PTR [eax]
  00292	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00295	88 4c 02 7e	 mov	 BYTE PTR [edx+eax+126], cl
  00299	84 c9		 test	 cl, cl
  0029b	75 f3		 jne	 SHORT $LL36@ipAddressA

; 360  : 									gmsv[indexgm].used = '1';

  0029d	c6 47 ff 31	 mov	 BYTE PTR [edi-1], 49	; 00000031H
$LN82@ipAddressA:

; 361  : 								}
; 362  : 							}
; 363  : 						}
; 364  : 						param = ReleaseMessHeadParam();

  002a1	8b 75 bc	 mov	 esi, DWORD PTR _j$1$[ebp]
$LN26@ipAddressA:
  002a4	e8 00 00 00 00	 call	 ?ReleaseMessHeadParam@@YAPAUParameter@@XZ ; ReleaseMessHeadParam
  002a9	8b d0		 mov	 edx, eax
$LN84@ipAddressA:

; 332  : 
; 333  : #ifdef _SHOW_COUNT						// WON ADD 秀服务器流量
; 334  : 				if (param && param->lpstrParam) {
; 335  : 					param = ReleaseMessHeadParam();
; 336  : 				}
; 337  : #endif
; 338  : 
; 339  : 
; 340  : 				for (int j = 0; j<gmgroup[nGroup].num && indexgm < MAX_GMSV; j++, indexgm++) {

  002ab	8b 4d c0	 mov	 ecx, DWORD PTR _indexgm$1$[ebp]
$LN5@ipAddressA:
  002ae	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nGroup@@3HA ; nGroup
  002b3	46		 inc	 esi
  002b4	c1 e0 06	 shl	 eax, 6
  002b7	41		 inc	 ecx
  002b8	81 c7 00 01 00
	00		 add	 edi, 256		; 00000100H
  002be	89 75 bc	 mov	 DWORD PTR _j$1$[ebp], esi
  002c1	89 4d c0	 mov	 DWORD PTR _indexgm$1$[ebp], ecx
  002c4	0f be 80 01 00
	00 00		 movsx	 eax, BYTE PTR ?gmgroup@@3PAUgamegroup@@A[eax+1]
  002cb	3b f0		 cmp	 esi, eax
  002cd	0f 8c df fe ff
	ff		 jl	 $LL7@ipAddressA
$LN80@ipAddressA:
  002d3	8b 7d b8	 mov	 edi, DWORD PTR _dwCafeKey$1$[ebp]
$LN6@ipAddressA:

; 365  : 					}
; 366  : #ifdef _SHOW_COUNT						// WON ADD 秀服务器流量
; 367  : 					if (param && param->lpstrParam) {
; 368  : 						strcpy(gmsv[indexgm].count, param->lpstrParam);
; 369  : 						param = ReleaseMessHeadParam();
; 370  : 					}
; 371  : #endif
; 372  : 				}
; 373  : 				if (dwLevel) {

  002d6	85 db		 test	 ebx, ebx
  002d8	74 14		 je	 SHORT $LN86@ipAddressA

; 374  : 					gmgroup[nGroup].used = (char)dwLevel;

  002da	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nGroup@@3HA ; nGroup
  002df	c1 e0 06	 shl	 eax, 6

; 375  : 					nGroup++;

  002e2	ff 05 00 00 00
	00		 inc	 DWORD PTR ?nGroup@@3HA	; nGroup
  002e8	88 98 00 00 00
	00		 mov	 BYTE PTR ?gmgroup@@3PAUgamegroup@@A[eax], bl
$LN86@ipAddressA:

; 278  : 
; 279  : #ifdef _SHOW_COUNT						// WON ADD 秀服务器流量
; 280  : 		if (param && param->lpstrParam) {
; 281  : 			param = ReleaseMessHeadParam();
; 282  : 		}
; 283  : #endif
; 284  : 
; 285  : 		for (int i = 0; i < nGroup1; i++) {

  002ee	8b 75 c4	 mov	 esi, DWORD PTR _nGroup1$2$[ebp]
$LN2@ipAddressA:
  002f1	83 ee 01	 sub	 esi, 1
  002f4	89 75 c4	 mov	 DWORD PTR _nGroup1$2$[ebp], esi
  002f7	0f 85 c7 fd ff
	ff		 jne	 $LL77@ipAddressA
$LN3@ipAddressA:

; 376  : 				}
; 377  : 			}
; 378  : 		}
; 379  : 		if (param && param->lpstrParam) {

  002fd	85 d2		 test	 edx, edx
  002ff	74 33		 je	 SHORT $LN28@ipAddressA
  00301	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00303	85 c9		 test	 ecx, ecx
  00305	74 2d		 je	 SHORT $LN28@ipAddressA

; 380  : 			strcpy(szAnnouncement, param->lpstrParam);

  00307	ba 00 00 00 00	 mov	 edx, OFFSET ?szAnnouncement@@3PADA ; szAnnouncement
  0030c	0f 1f 40 00	 npad	 4
$LL37@ipAddressA:
  00310	8a 01		 mov	 al, BYTE PTR [ecx]
  00312	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00315	88 02		 mov	 BYTE PTR [edx], al
  00317	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  0031a	84 c0		 test	 al, al
  0031c	75 f2		 jne	 SHORT $LL37@ipAddressA

; 381  : 			param = ReleaseMessHeadParam();

  0031e	e8 00 00 00 00	 call	 ?ReleaseMessHeadParam@@YAPAUParameter@@XZ ; ReleaseMessHeadParam
  00323	5f		 pop	 edi

; 385  : 	}
; 386  : }

  00324	5e		 pop	 esi
  00325	5b		 pop	 ebx
  00326	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00329	33 cd		 xor	 ecx, ebp
  0032b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00330	8b e5		 mov	 esp, ebp
  00332	5d		 pop	 ebp
  00333	c3		 ret	 0
$LN28@ipAddressA:

; 382  : 		}
; 383  : 		else
; 384  : 			szAnnouncement[0] = '\0';

  00334	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szAnnouncement@@3PADA, 0
$LN29@ipAddressA:

; 385  : 	}
; 386  : }

  0033b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0033e	5f		 pop	 edi
  0033f	5e		 pop	 esi
  00340	33 cd		 xor	 ecx, ebp
  00342	5b		 pop	 ebx
  00343	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00348	8b e5		 mov	 esp, ebp
  0034a	5d		 pop	 ebp
  0034b	c3		 ret	 0
?ipAddressAnalyze@@YAXXZ ENDP				; ipAddressAnalyze
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\Wgs\Common.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\time.h
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\Wgs\Common.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\time.h
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\Wgs\Common.cpp
;	COMDAT ?PKey_Init@@YAXXZ
_TEXT	SEGMENT
_szTemp1$ = -28						; size = 3
_szTemp$ = -24						; size = 17
__$ArrayPad$ = -4					; size = 4
?PKey_Init@@YAXXZ PROC					; PKey_Init, COMDAT

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\time.h

; 522  :             return _time64(_Time);

  00013	6a 00		 push	 0
  00015	e8 00 00 00 00	 call	 __time64
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\Wgs\Common.cpp

; 142  : 	srand((unsigned)time(NULL));

  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _srand
  00020	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\time.h

; 522  :             return _time64(_Time);

  00023	33 f6		 xor	 esi, esi
$LL4@PKey_Init:
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\Wgs\Common.cpp

; 145  : 		szTemp[i]=P_Key[i]=rand()%256;

  00025	e8 00 00 00 00	 call	 _rand
  0002a	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  0002f	79 07		 jns	 SHORT $LN30@PKey_Init
  00031	48		 dec	 eax
  00032	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  00037	40		 inc	 eax
$LN30@PKey_Init:
  00038	88 86 00 00 00
	00		 mov	 BYTE PTR ?P_Key@@3PADA[esi], al
  0003e	88 44 35 e8	 mov	 BYTE PTR _szTemp$[ebp+esi], al
  00042	46		 inc	 esi
  00043	83 fe 07	 cmp	 esi, 7
  00046	7c dd		 jl	 SHORT $LL4@PKey_Init

; 146  : 	P_Key[7]='\0';

  00048	c6 05 07 00 00
	00 00		 mov	 BYTE PTR ?P_Key@@3PADA+7, 0
  0004f	be 07 00 00 00	 mov	 esi, 7
$LL7@PKey_Init:

; 147  : 	for(i=7;i<16;i++)
; 148  : 		szTemp[i]=rand()%256;

  00054	e8 00 00 00 00	 call	 _rand
  00059	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  0005e	79 07		 jns	 SHORT $LN31@PKey_Init
  00060	48		 dec	 eax
  00061	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  00066	40		 inc	 eax
$LN31@PKey_Init:
  00067	88 44 35 e8	 mov	 BYTE PTR _szTemp$[ebp+esi], al
  0006b	46		 inc	 esi
  0006c	83 fe 10	 cmp	 esi, 16			; 00000010H
  0006f	7c e3		 jl	 SHORT $LL7@PKey_Init

; 149  : 	P_Key1[0]='\0';

  00071	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__wsprintfA
  00077	33 f6		 xor	 esi, esi
  00079	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__lstrcatA@8
  0007f	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?P_Key1@@3PADA, 0
$LL10@PKey_Init:

; 150  : 	for(i=0;i<16;i++){
; 151  : 		wsprintf(szTemp1,"%02X",(unsigned char)~szTemp[i]);

  00086	8a 44 35 e8	 mov	 al, BYTE PTR _szTemp$[ebp+esi]
  0008a	f6 d0		 not	 al
  0008c	0f b6 c0	 movzx	 eax, al
  0008f	50		 push	 eax
  00090	8d 45 e4	 lea	 eax, DWORD PTR _szTemp1$[ebp]
  00093	68 00 00 00 00	 push	 OFFSET ??_C@_04JFFKLGJF@?$CF02X@
  00098	50		 push	 eax
  00099	ff d7		 call	 edi
  0009b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 152  : 		lstrcat(P_Key1,szTemp1);

  0009e	8d 45 e4	 lea	 eax, DWORD PTR _szTemp1$[ebp]
  000a1	50		 push	 eax
  000a2	68 00 00 00 00	 push	 OFFSET ?P_Key1@@3PADA	; P_Key1
  000a7	ff d3		 call	 ebx
  000a9	46		 inc	 esi
  000aa	83 fe 10	 cmp	 esi, 16			; 00000010H
  000ad	7c d7		 jl	 SHORT $LL10@PKey_Init

; 153  : 	}
; 154  : }

  000af	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	33 cd		 xor	 ecx, ebp
  000b6	5b		 pop	 ebx
  000b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c3		 ret	 0
?PKey_Init@@YAXXZ ENDP					; PKey_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\Wgs\Common.cpp
;	COMDAT ?GetEncrypt@@YAXPAUParameter@@@Z
_TEXT	SEGMENT
_param$ = 8						; size = 4
?GetEncrypt@@YAXPAUParameter@@@Z PROC			; GetEncrypt, COMDAT

; 129  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 130  : 	if(param && param->lpstrParam){

  00004	8b 7d 08	 mov	 edi, DWORD PTR _param$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 4a		 je	 SHORT $LN2@GetEncrypt
  0000b	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 44		 je	 SHORT $LN2@GetEncrypt

; 131  : 		int iLen=strlen(param->lpstrParam);

  00011	56		 push	 esi
  00012	8b f1		 mov	 esi, ecx
  00014	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
$LL10@GetEncrypt:
  00017	8a 06		 mov	 al, BYTE PTR [esi]
  00019	46		 inc	 esi
  0001a	84 c0		 test	 al, al
  0001c	75 f9		 jne	 SHORT $LL10@GetEncrypt
  0001e	2b f2		 sub	 esi, edx

; 132  : 		iLen>>=1;

  00020	d1 fe		 sar	 esi, 1

; 133  : 		strncpy(szPlain,param->lpstrParam,iLen);

  00022	56		 push	 esi
  00023	51		 push	 ecx
  00024	68 00 00 00 00	 push	 OFFSET ?szPlain@@3PADA	; szPlain
  00029	e8 00 00 00 00	 call	 _strncpy
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 134  : 		szPlain[iLen]='\0';

  00031	83 fe 50	 cmp	 esi, 80			; 00000050H
  00034	73 22		 jae	 SHORT $LN4@GetEncrypt
  00036	c6 86 00 00 00
	00 00		 mov	 BYTE PTR ?szPlain@@3PADA[esi], 0

; 135  : 		strcpy(szCipher,param->lpstrParam+iLen);

  0003d	ba 00 00 00 00	 mov	 edx, OFFSET ?szCipher@@3PADA ; szCipher
  00042	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00044	03 ce		 add	 ecx, esi
  00046	5e		 pop	 esi
$LL6@GetEncrypt:
  00047	8a 01		 mov	 al, BYTE PTR [ecx]
  00049	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  0004c	88 02		 mov	 BYTE PTR [edx], al
  0004e	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00051	84 c0		 test	 al, al
  00053	75 f2		 jne	 SHORT $LL6@GetEncrypt
$LN2@GetEncrypt:
  00055	5f		 pop	 edi

; 136  : 	}
; 137  : }

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
$LN4@GetEncrypt:

; 134  : 		szPlain[iLen]='\0';

  00058	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN11@GetEncrypt:
  0005d	cc		 int	 3
?GetEncrypt@@YAXPAUParameter@@@Z ENDP			; GetEncrypt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\Wgs\Common.cpp
;	COMDAT ?GetIP_PORT@@YAHPAUParameter@@@Z
_TEXT	SEGMENT
_param$ = 8						; size = 4
?GetIP_PORT@@YAHPAUParameter@@@Z PROC			; GetIP_PORT, COMDAT

; 114  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 115  : 	if((param)&&(param->lpstrParam)){

  00003	8b 45 08	 mov	 eax, DWORD PTR _param$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 52		 je	 SHORT $LN4@GetIP_PORT
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	85 c0		 test	 eax, eax
  0000e	74 4c		 je	 SHORT $LN4@GetIP_PORT

; 116  : 		lstrcpy(szCSIP,param->lpstrParam);

  00010	50		 push	 eax
  00011	68 00 00 00 00	 push	 OFFSET ?szCSIP@@3PADA	; szCSIP
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8

; 117  : 		if((param=ReleaseMessHeadParam())&&(param->lpstrParam)){

  0001c	e8 00 00 00 00	 call	 ?ReleaseMessHeadParam@@YAPAUParameter@@XZ ; ReleaseMessHeadParam
  00021	85 c0		 test	 eax, eax
  00023	74 37		 je	 SHORT $LN4@GetIP_PORT
  00025	8b 00		 mov	 eax, DWORD PTR [eax]
  00027	85 c0		 test	 eax, eax
  00029	74 31		 je	 SHORT $LN4@GetIP_PORT

; 118  : 			wCS=(WORD)atoi(param->lpstrParam);

  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _atoi
  00031	83 c4 04	 add	 esp, 4
  00034	66 a3 00 00 00
	00		 mov	 WORD PTR ?wCS@@3GA, ax	; wCS

; 119  : 			if((param=ReleaseMessHeadParam())&&(param->lpstrParam)){

  0003a	e8 00 00 00 00	 call	 ?ReleaseMessHeadParam@@YAPAUParameter@@XZ ; ReleaseMessHeadParam
  0003f	85 c0		 test	 eax, eax
  00041	74 19		 je	 SHORT $LN4@GetIP_PORT
  00043	8b 00		 mov	 eax, DWORD PTR [eax]
  00045	85 c0		 test	 eax, eax
  00047	74 13		 je	 SHORT $LN4@GetIP_PORT

; 120  : 				lstrcpy(szPid,param->lpstrParam);

  00049	50		 push	 eax
  0004a	68 00 00 00 00	 push	 OFFSET ?szPid@@3PADA	; szPid
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8

; 121  : 				return TRUE;

  00055	b8 01 00 00 00	 mov	 eax, 1

; 126  : }

  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
$LN4@GetIP_PORT:

; 122  : 			}
; 123  : 		}
; 124  : 	}
; 125  : 	return FALSE;

  0005c	33 c0		 xor	 eax, eax

; 126  : }

  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?GetIP_PORT@@YAHPAUParameter@@@Z ENDP			; GetIP_PORT
_TEXT	ENDS
END
