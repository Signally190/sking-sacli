; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29336.0 

	TITLE	C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?FontZenkauWidth@@3HA				; FontZenkauWidth
PUBLIC	?FontHankakuWidth@@3HA				; FontHankakuWidth
PUBLIC	?FontBuffer@@3PAUFONT_BUFFER@@A			; FontBuffer
PUBLIC	?FontCnt@@3HA					; FontCnt
PUBLIC	?FontSizeHdc@@3PAUHDC__@@A			; FontSizeHdc
PUBLIC	?hScrDC@@3PAUHDC__@@A				; hScrDC
_BSS	SEGMENT
?FontZenkauWidth@@3HA DD 01H DUP (?)			; FontZenkauWidth
?FontHankakuWidth@@3HA DD 01H DUP (?)			; FontHankakuWidth
?FontBuffer@@3PAUFONT_BUFFER@@A DB 044000H DUP (?)	; FontBuffer
?FontCnt@@3HA DD 01H DUP (?)				; FontCnt
?FontSizeHdc@@3PAUHDC__@@A DD 01H DUP (?)		; FontSizeHdc
?hScrDC@@3PAUHDC__@@A DD 01H DUP (?)			; hScrDC
_BSS	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_sprintf
PUBLIC	?sunday@@YAPADPAD0@Z				; sunday
PUBLIC	?NewStockFontBuffer@@YAXPAU_CHAT_BUFFER@@HEPADHH@Z ; NewStockFontBuffer
PUBLIC	?delFontBuffer@@YAXPAU_CHAT_BUFFER@@@Z		; delFontBuffer
PUBLIC	?StockFontBuffer@@YAHHHDHPADH@Z			; StockFontBuffer
PUBLIC	?StockFontBufferExt@@YAHHHDHPADHH@Z		; StockFontBufferExt
PUBLIC	?StockFontBuffer2@@YAXPAUSTR_BUFFER@@@Z		; StockFontBuffer2
PUBLIC	?StockFontBuffer3@@YAHPAUSTR_BUFFER@@@Z		; StockFontBuffer3
PUBLIC	?CreatFontHdc@@YAXXZ				; CreatFontHdc
PUBLIC	?getTextLength@@YAHPAD@Z			; getTextLength
PUBLIC	?getStrColor@@YAHPAD@Z				; getStrColor
PUBLIC	?getStrStr@@YAXPAD0@Z				; getStrStr
PUBLIC	?getStrPos@@YA_NPADPAU_CHAT_BUFFER@@@Z		; getStrPos
PUBLIC	?getStrPetindex@@YAHPAD@Z			; getStrPetindex
PUBLIC	?getStrPet@@YA_NPADPAU_CHAT_BUFFER@@@Z		; getStrPet
PUBLIC	?getStrExtraData@@YA_NPAD0@Z			; getStrExtraData
PUBLIC	?MyNewStockFontBuffer@@YAXPAU_CHAT_BUFFER@@HEPADHH@Z ; MyNewStockFontBuffer
PUBLIC	?StockFontBufferFamily@@YAXPAUSTR_BUFFER@@@Z	; StockFontBufferFamily
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_07GJNDNEJP@FontHdc@			; `string'
PUBLIC	??_C@_0BD@HLAEMJFN@Microsoft?5JhengHei@		; `string'
PUBLIC	??_C@_06MFMMLLPC@?$LB?$LM?$LI?$LC?C?$LM@	; `string'
PUBLIC	??_C@_0BB@NLNMPB@?$KD?S?$KD?t?$KD?o?$KD?n?$KD?e?$KD?A?$KD?g?$KD?e@ ; `string'
PUBLIC	??_C@_0L@GONBBDGE@?$DP?K?oHDC?$DP?$DP?$KD?$KB@	; `string'
PUBLIC	??_C@_06CDHFECOP@color?$DN@			; `string'
PUBLIC	??_C@_04FOGPFBLG@str?$DN@			; `string'
PUBLIC	??_C@_01CELHOKLL@?$HN@				; `string'
PUBLIC	??_C@_04JPBFJBMP@pos?$DN@			; `string'
PUBLIC	??_C@_0FG@MOFDFNBM@C?3?2Users?2gg862?2OneDrive?2?$LJ?Y?E?A?5?H?$KN@ ; `string'
PUBLIC	??_C@_04PFOHGHCO@pet?$DN@			; `string'
PUBLIC	??_C@_01HCONENDN@?$HL@				; `string'
PUBLIC	??_C@_05ELILFBDN@item?$DN@			; `string'
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	___report_rangecheckfailure:PROC
EXTRN	??_U@YAPAXIHPBDH@Z:PROC				; operator new[]
EXTRN	_strncpy_s:PROC
EXTRN	__imp__lstrlenA@4:PROC
EXTRN	__imp__CreateCompatibleDC@4:PROC
EXTRN	__imp__CreateDCA@16:PROC
EXTRN	__imp__CreateFontA@56:PROC
EXTRN	__imp__GetTextExtentPoint32A@16:PROC
EXTRN	__imp__SelectObject@8:PROC
EXTRN	__imp__LCMapStringA@24:PROC
EXTRN	_calloc:PROC
EXTRN	_free:PROC
EXTRN	_exit:PROC
EXTRN	_atoi:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	?split_damage@@YAHPADDPAHI@Z:PROC		; split_damage
EXTRN	?GetStrLastByte@@YAHPAD@Z:PROC			; GetStrLastByte
EXTRN	?MessageBoxNew@@YAHPAUHWND__@@PBD1I@Z:PROC	; MessageBoxNew
EXTRN	?GB2312ToBIG5@@YAPADPBD@Z:PROC			; GB2312ToBIG5
EXTRN	?GB2312ToBIG5@@YAPADPBD@Z:PROC			; GB2312ToBIG5
EXTRN	?GB2312ToBIG5@@YAPADPBD@Z:PROC			; GB2312ToBIG5
EXTRN	?GB2312ToBIG5@@YAPADPBD@Z:PROC			; GB2312ToBIG5
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	???@@3HA:DWORD					; ??
EXTRN	?€Â???@@3HA:DWORD				; €Â???
EXTRN	???@@3HA:DWORD					; ??
EXTRN	???@@3HA:DWORD					; ??
EXTRN	???@@3HA:DWORD					; ??
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_C@_05ELILFBDN@item?$DN@
CONST	SEGMENT
??_C@_05ELILFBDN@item?$DN@ DB 'item=', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01HCONENDN@?$HL@
CONST	SEGMENT
??_C@_01HCONENDN@?$HL@ DB '{', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PFOHGHCO@pet?$DN@
CONST	SEGMENT
??_C@_04PFOHGHCO@pet?$DN@ DB 'pet=', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@MOFDFNBM@C?3?2Users?2gg862?2OneDrive?2?$LJ?Y?E?A?5?H?$KN@
CONST	SEGMENT
??_C@_0FG@MOFDFNBM@C?3?2Users?2gg862?2OneDrive?2?$LJ?Y?E?A?5?H?$KN@ DB 'C'
	DB	':\Users\gg862\OneDrive\', 0b9H, 0d9H, 0c5H, 0c1H, ' ', 0c8H, 0adH
	DB	0b8H, 0e9H, '\', 0b8H, 0beH, 0c4H, 0edH, 0bfH, 0cfH, 0b7H, 0e1H
	DB	'\Client Source Code1.31', 0c0H, 0cfH, 0baH, 0bbH, '\system\fo'
	DB	'nt.cpp', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04JPBFJBMP@pos?$DN@
CONST	SEGMENT
??_C@_04JPBFJBMP@pos?$DN@ DB 'pos=', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CELHOKLL@?$HN@
CONST	SEGMENT
??_C@_01CELHOKLL@?$HN@ DB '}', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FOGPFBLG@str?$DN@
CONST	SEGMENT
??_C@_04FOGPFBLG@str?$DN@ DB 'str=', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CDHFECOP@color?$DN@
CONST	SEGMENT
??_C@_06CDHFECOP@color?$DN@ DB 'color=', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GONBBDGE@?$DP?K?oHDC?$DP?$DP?$KD?$KB@
CONST	SEGMENT
??_C@_0L@GONBBDGE@?$DP?K?oHDC?$DP?$DP?$KD?$KB@ DB '?', 0cbH, 0efH, 'HDC??'
	DB	0a3H, 0a1H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NLNMPB@?$KD?S?$KD?t?$KD?o?$KD?n?$KD?e?$KD?A?$KD?g?$KD?e@
CONST	SEGMENT
??_C@_0BB@NLNMPB@?$KD?S?$KD?t?$KD?o?$KD?n?$KD?e?$KD?A?$KD?g?$KD?e@ DB 0a3H
	DB	0d3H, 0a3H, 0f4H, 0a3H, 0efH, 0a3H, 0eeH, 0a3H, 0e5H, 0a3H, 0c1H
	DB	0a3H, 0e7H, 0a3H, 0e5H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06MFMMLLPC@?$LB?$LM?$LI?$LC?C?$LM@
CONST	SEGMENT
??_C@_06MFMMLLPC@?$LB?$LM?$LI?$LC?C?$LM@ DB 0b1H, 0bcH, 0b8H, 0b2H, 0c3H, 0bcH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HLAEMJFN@Microsoft?5JhengHei@
CONST	SEGMENT
??_C@_0BD@HLAEMJFN@Microsoft?5JhengHei@ DB 'Microsoft JhengHei', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GJNDNEJP@FontHdc@
CONST	SEGMENT
??_C@_07GJNDNEJP@FontHdc@ DB 'FontHdc', 00H		; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp
;	COMDAT ?StockFontBufferFamily@@YAXPAUSTR_BUFFER@@@Z
_TEXT	SEGMENT
_bakSplitPoint$1$ = -284				; size = 4
_cursor$1$ = -280					; size = 4
_SetCursor$1$ = -276					; size = 4
tv1030 = -272						; size = 4
tv1000 = -272						; size = 4
tv1016 = -268						; size = 4
tv996 = -268						; size = 4
_˙ºÌÆ?$1$ = -264					; size = 4
_splitStr$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_strBuffer$ = 8						; size = 4
?StockFontBufferFamily@@YAXPAUSTR_BUFFER@@@Z PROC	; StockFontBufferFamily, COMDAT

; 593  : void StockFontBufferFamily(STR_BUFFER *strBuffer){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 1c 01 00
	00		 sub	 esp, 284		; 0000011cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx

; 594  : 	int lineDist = 0; //Ë°åË∑ù
; 595  : 	int splitPoint = 0;
; 596  : 	int bakSplitPoint, cursor;
; 597  : 	BOOL SetCursor = FALSE;

  00014	33 c0		 xor	 eax, eax
  00016	33 db		 xor	 ebx, ebx
  00018	56		 push	 esi
  00019	8b 75 08	 mov	 esi, DWORD PTR _strBuffer$[ebp]
  0001c	57		 push	 edi
  0001d	89 85 ec fe ff
	ff		 mov	 DWORD PTR _SetCursor$1$[ebp], eax
  00023	33 ff		 xor	 edi, edi

; 598  : 	char splitStr[256];
; 599  : 	if (FontCnt >= FONT_BUFFER_SIZE) {

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ?FontCnt@@3HA ; FontCnt
  0002a	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  0002f	7c 1b		 jl	 SHORT $LN7@StockFontB

; 600  : 		strBuffer->hitFontNo = -2;

  00031	5f		 pop	 edi
  00032	c7 86 24 01 00
	00 fe ff ff ff	 mov	 DWORD PTR [esi+292], -2	; fffffffeH

; 683  : 		strBuffer->imeY = strBuffer->y;
; 684  : 		strBuffer->hitFontNo = FontCnt++;
; 685  : 		}
; 686  : 	}

  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00041	33 cd		 xor	 ecx, ebp
  00043	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
$LN7@StockFontB:

; 601  : 		return;
; 602  : 	}
; 603  : 	int Ë°åÂ≠óÊï∞;
; 604  : 	if (strBuffer->lineLen != 0) {

  0004c	38 9e 05 01 00
	00		 cmp	 BYTE PTR [esi+261], bl
  00052	0f 84 df 01 00
	00		 je	 $LN8@StockFontB

; 605  : 		cursor = strBuffer->cursor;

  00058	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]

; 606  : 		if (lineDist) Ë°åÂ≠óÊï∞ = strBuffer->lineLen;
; 607  : 		else Ë°åÂ≠óÊï∞ = 38;
; 608  : 		while (strlen(strBuffer->buffer + splitPoint) >= Ë°åÂ≠óÊï∞) {

  0005f	8b ce		 mov	 ecx, esi
  00061	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _cursor$1$[ebp], eax
  00067	ba 26 00 00 00	 mov	 edx, 38			; 00000026H
  0006c	89 95 f8 fe ff
	ff		 mov	 DWORD PTR _˙ºÌÆ?$1$[ebp], edx
  00072	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00075	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv996[ebp], eax
  0007b	0f 1f 44 00 00	 npad	 5
$LL51@StockFontB:
  00080	8a 01		 mov	 al, BYTE PTR [ecx]
  00082	41		 inc	 ecx
  00083	84 c0		 test	 al, al
  00085	75 f9		 jne	 SHORT $LL51@StockFontB
  00087	2b 8d f4 fe ff
	ff		 sub	 ecx, DWORD PTR tv996[ebp]
  0008d	3b ca		 cmp	 ecx, edx
  0008f	0f 82 31 01 00
	00		 jb	 $LN49@StockFontB
$LL2@StockFontB:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h

; 331  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(

  00095	52		 push	 edx
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp

; 611  : 			strncpy_s(splitStr, strBuffer->buffer + splitPoint, Ë°åÂ≠óÊï∞);

  00096	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
  00099	89 9d f0 fe ff
	ff		 mov	 DWORD PTR tv1030[ebp], ebx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h

; 331  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(

  0009f	50		 push	 eax
  000a0	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _splitStr$[ebp]
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp

; 609  : 			bakSplitPoint = splitPoint;

  000a6	89 9d e4 fe ff
	ff		 mov	 DWORD PTR _bakSplitPoint$1$[ebp], ebx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h

; 331  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(

  000ac	68 00 01 00 00	 push	 256			; 00000100H
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 _strncpy_s
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp

; 613  : 			if (GetStrLastByte(splitStr) == 3) {

  000b7	03 9d f8 fe ff
	ff		 add	 ebx, DWORD PTR _˙ºÌÆ?$1$[ebp]
  000bd	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _splitStr$[ebp]
  000c3	03 8d f8 fe ff
	ff		 add	 ecx, DWORD PTR _˙ºÌÆ?$1$[ebp]
  000c9	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _splitStr$[ebp]
  000cf	50		 push	 eax
  000d0	89 8d f4 fe ff
	ff		 mov	 DWORD PTR tv1016[ebp], ecx
  000d6	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000d9	e8 00 00 00 00	 call	 ?GetStrLastByte@@YAHPAD@Z ; GetStrLastByte
  000de	83 c4 14	 add	 esp, 20			; 00000014H
  000e1	83 f8 03	 cmp	 eax, 3
  000e4	75 0b		 jne	 SHORT $LN12@StockFontB

; 614  : 				//ÂàÜÂâ≤Âà∞‰∏≠DBCSÊó∂ÔºåÈÄÄÂõû‰∏Ä‰∏™byte
; 615  : 				splitPoint = Ë°åÂ≠óÊï∞ - 1 + splitPoint;
; 616  : 				*(splitStr + Ë°åÂ≠óÊï∞ - 1) = NULL;

  000e6	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR tv1016[ebp]
  000ec	4b		 dec	 ebx
  000ed	c6 40 ff 00	 mov	 BYTE PTR [eax-1], 0
$LN12@StockFontB:

; 617  : 			}else
; 618  : 				splitPoint = Ë°åÂ≠óÊï∞ + splitPoint;
; 619  : 			if (lineDist)

  000f1	8b 8e 0c 01 00
	00		 mov	 ecx, DWORD PTR [esi+268]

; 620  : 				StockFontBuffer(strBuffer->x - 60, strBuffer->y + lineDist, strBuffer->fontPrio, 0, splitStr, 0);
; 621  : 			else
; 622  : 				StockFontBuffer(strBuffer->x, strBuffer->y + lineDist, strBuffer->fontPrio, 0, splitStr, 0);
; 623  : 			if (cursor >= bakSplitPoint && cursor<splitPoint) {

  000f7	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _splitStr$[ebp]
  000fd	6a 00		 push	 0
  000ff	50		 push	 eax
  00100	0f b6 86 1c 01
	00 00		 movzx	 eax, BYTE PTR [esi+284]
  00107	6a 00		 push	 0
  00109	50		 push	 eax
  0010a	8b 86 10 01 00
	00		 mov	 eax, DWORD PTR [esi+272]
  00110	03 c7		 add	 eax, edi
  00112	85 ff		 test	 edi, edi
  00114	50		 push	 eax
  00115	8d 41 c4	 lea	 eax, DWORD PTR [ecx-60]
  00118	0f 44 c1	 cmove	 eax, ecx
  0011b	50		 push	 eax
  0011c	e8 00 00 00 00	 call	 ?StockFontBuffer@@YAHHHDHPADH@Z ; StockFontBuffer
  00121	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _cursor$1$[ebp]
  00127	83 c4 18	 add	 esp, 24			; 00000018H
  0012a	3b 85 e4 fe ff
	ff		 cmp	 eax, DWORD PTR _bakSplitPoint$1$[ebp]
  00130	7c 3f		 jl	 SHORT $LN16@StockFontB
  00132	3b c3		 cmp	 eax, ebx
  00134	7d 3b		 jge	 SHORT $LN16@StockFontB

; 624  : 				if (lineDist)

  00136	2b 85 f0 fe ff
	ff		 sub	 eax, DWORD PTR tv1030[ebp]

; 625  : 					strBuffer->imeX = strBuffer->x - 60 + (cursor - bakSplitPoint)*(FONT_SIZE >> 1);
; 626  : 				else
; 627  : 					strBuffer->imeX = strBuffer->x + (cursor - bakSplitPoint)*(FONT_SIZE >> 1);
; 628  : 				strBuffer->imeY = strBuffer->y + lineDist;
; 629  : 				SetCursor = TRUE;

  0013c	c7 85 ec fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _SetCursor$1$[ebp], 1
  00146	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0014d	2b c8		 sub	 ecx, eax
  0014f	03 8e 0c 01 00
	00		 add	 ecx, DWORD PTR [esi+268]
  00155	85 ff		 test	 edi, edi
  00157	8d 41 c4	 lea	 eax, DWORD PTR [ecx-60]
  0015a	0f 44 c1	 cmove	 eax, ecx
  0015d	89 86 14 01 00
	00		 mov	 DWORD PTR [esi+276], eax
  00163	8b 86 10 01 00
	00		 mov	 eax, DWORD PTR [esi+272]
  00169	03 c7		 add	 eax, edi
  0016b	89 86 18 01 00
	00		 mov	 DWORD PTR [esi+280], eax
$LN16@StockFontB:

; 630  : 			}
; 631  : 			lineDist += strBuffer->lineDist;

  00171	0f b6 86 06 01
	00 00		 movzx	 eax, BYTE PTR [esi+262]
  00178	03 f8		 add	 edi, eax

; 632  : 			if (lineDist) Ë°åÂ≠óÊï∞ = strBuffer->lineLen;

  0017a	74 09		 je	 SHORT $LN19@StockFontB
  0017c	0f b6 96 05 01
	00 00		 movzx	 edx, BYTE PTR [esi+261]
  00183	eb 05		 jmp	 SHORT $LN53@StockFontB
$LN19@StockFontB:

; 633  : 			else Ë°åÂ≠óÊï∞ = 38;

  00185	ba 26 00 00 00	 mov	 edx, 38			; 00000026H
$LN53@StockFontB:

; 606  : 		if (lineDist) Ë°åÂ≠óÊï∞ = strBuffer->lineLen;
; 607  : 		else Ë°åÂ≠óÊï∞ = 38;
; 608  : 		while (strlen(strBuffer->buffer + splitPoint) >= Ë°åÂ≠óÊï∞) {

  0018a	8d 0c 1e	 lea	 ecx, DWORD PTR [esi+ebx]
  0018d	89 95 f8 fe ff
	ff		 mov	 DWORD PTR _˙ºÌÆ?$1$[ebp], edx
  00193	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00196	89 85 f0 fe ff
	ff		 mov	 DWORD PTR tv1000[ebp], eax
  0019c	0f 1f 40 00	 npad	 4
$LL52@StockFontB:
  001a0	8a 01		 mov	 al, BYTE PTR [ecx]
  001a2	41		 inc	 ecx
  001a3	84 c0		 test	 al, al
  001a5	75 f9		 jne	 SHORT $LL52@StockFontB
  001a7	2b 8d f0 fe ff
	ff		 sub	 ecx, DWORD PTR tv1000[ebp]
  001ad	3b ca		 cmp	 ecx, edx
  001af	0f 83 e0 fe ff
	ff		 jae	 $LL2@StockFontB

; 634  : 		}
; 635  : 		if (!SetCursor) {

  001b5	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _SetCursor$1$[ebp], 0
  001bc	74 08		 je	 SHORT $LN49@StockFontB

; 637  : 				strBuffer->imeX = strBuffer->x - 60 + (strBuffer->cursor - splitPoint)*(FONT_SIZE >> 1);
; 638  : 			else
; 639  : 				strBuffer->imeX = strBuffer->x + (strBuffer->cursor - splitPoint)*(FONT_SIZE >> 1);
; 640  : 			strBuffer->imeY = strBuffer->y + lineDist;

  001be	8b 96 10 01 00
	00		 mov	 edx, DWORD PTR [esi+272]
  001c4	eb 35		 jmp	 SHORT $LN44@StockFontB
$LN49@StockFontB:

; 636  : 			if (lineDist)

  001c6	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  001cd	2b c3		 sub	 eax, ebx
  001cf	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  001d6	2b c8		 sub	 ecx, eax
  001d8	03 8e 0c 01 00
	00		 add	 ecx, DWORD PTR [esi+268]

; 637  : 				strBuffer->imeX = strBuffer->x - 60 + (strBuffer->cursor - splitPoint)*(FONT_SIZE >> 1);
; 638  : 			else
; 639  : 				strBuffer->imeX = strBuffer->x + (strBuffer->cursor - splitPoint)*(FONT_SIZE >> 1);
; 640  : 			strBuffer->imeY = strBuffer->y + lineDist;

  001de	85 ff		 test	 edi, edi
  001e0	8d 41 c4	 lea	 eax, DWORD PTR [ecx-60]
  001e3	0f 44 c1	 cmove	 eax, ecx
  001e6	89 86 14 01 00
	00		 mov	 DWORD PTR [esi+276], eax
  001ec	8b 96 10 01 00
	00		 mov	 edx, DWORD PTR [esi+272]
  001f2	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  001f5	89 86 18 01 00
	00		 mov	 DWORD PTR [esi+280], eax
$LN44@StockFontB:

; 641  : 		}
; 642  : 		if (lineDist)

  001fb	8b 8e 0c 01 00
	00		 mov	 ecx, DWORD PTR [esi+268]
  00201	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]

; 643  : 			StockFontBuffer(strBuffer->x - 60, strBuffer->y + lineDist, strBuffer->fontPrio, 0, strBuffer->buffer + splitPoint, 0);
; 644  : 		else
; 645  : 			StockFontBuffer(strBuffer->x, strBuffer->y + lineDist, strBuffer->fontPrio, 0, strBuffer->buffer + splitPoint, 0);
; 646  : 	}else {

  00204	6a 00		 push	 0
  00206	50		 push	 eax
  00207	0f b6 86 1c 01
	00 00		 movzx	 eax, BYTE PTR [esi+284]
  0020e	85 ff		 test	 edi, edi
  00210	6a 00		 push	 0
  00212	50		 push	 eax
  00213	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  00216	50		 push	 eax
  00217	8d 41 c4	 lea	 eax, DWORD PTR [ecx-60]
  0021a	0f 44 c1	 cmove	 eax, ecx
  0021d	50		 push	 eax
  0021e	e8 00 00 00 00	 call	 ?StockFontBuffer@@YAHHHDHPADH@Z ; StockFontBuffer
  00223	83 c4 18	 add	 esp, 24			; 00000018H
  00226	5f		 pop	 edi

; 683  : 		strBuffer->imeY = strBuffer->y;
; 684  : 		strBuffer->hitFontNo = FontCnt++;
; 685  : 		}
; 686  : 	}

  00227	5e		 pop	 esi
  00228	5b		 pop	 ebx
  00229	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0022c	33 cd		 xor	 ecx, ebp
  0022e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00233	8b e5		 mov	 esp, ebp
  00235	5d		 pop	 ebp
  00236	c3		 ret	 0
$LN8@StockFontB:

; 647  : 		FontBuffer[FontCnt].x = strBuffer->x;

  00237	69 f8 10 01 00
	00		 imul	 edi, eax, 272
  0023d	0f b7 86 0c 01
	00 00		 movzx	 eax, WORD PTR [esi+268]
  00244	66 89 87 00 00
	00 00		 mov	 WORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[edi], ax

; 648  : 		FontBuffer[FontCnt].y = strBuffer->y;

  0024b	0f b7 86 10 01
	00 00		 movzx	 eax, WORD PTR [esi+272]
  00252	66 89 87 02 00
	00 00		 mov	 WORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[edi+2], ax

; 649  : 		FontBuffer[FontCnt].fontPrio = strBuffer->fontPrio;

  00259	0f b6 86 1c 01
	00 00		 movzx	 eax, BYTE PTR [esi+284]
  00260	88 87 05 01 00
	00		 mov	 BYTE PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[edi+261], al

; 650  : 		FontBuffer[FontCnt].color = strBuffer->color;

  00266	0f b6 86 08 01
	00 00		 movzx	 eax, BYTE PTR [esi+264]
  0026d	88 87 04 00 00
	00		 mov	 BYTE PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[edi+4], al

; 651  : 		FontBuffer[FontCnt].hitFlag = 0;

  00273	89 9f 08 01 00
	00		 mov	 DWORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[edi+264], ebx

; 652  : #ifdef _FONT_SIZE
; 653  : 		FontBuffer[FontCnt].size = 0;

  00279	89 9f 0c 01 00
	00		 mov	 DWORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[edi+268], ebx

; 654  : #endif
; 655  : 		//ÂÆö‰πâHook_typeÁî®Êù•Â§ÑÁêÜÊòüÂè∑‰∫ßÁîü
; 656  : #ifdef _SAHOOK //Syu ADD HookÁ®ãÂºè
; 657  : 		if (strBuffer->filterFlag == HOOK_TYPE) {
; 658  : 			extern int HOOK_PASSWD_NUM;
; 659  : 			for (int i = 0; i < HOOK_PASSWD_NUM; i++)
; 660  : 				FontBuffer[FontCnt].str[i] = '*';
; 661  : 			FontBuffer[FontCnt].str[i] = NULL;
; 662  : 			strBuffer->cursor = HOOK_PASSWD_NUM;
; 663  : 		}
; 664  : 		else if (strBuffer->filterFlag == BLIND_TYPE) {
; 665  : #else
; 666  : 		if (strBuffer->filterFlag == BLIND_TYPE) {

  0027f	83 be 20 01 00
	00 01		 cmp	 DWORD PTR [esi+288], 1
  00286	75 33		 jne	 SHORT $LN26@StockFontB

; 667  : #endif
; 668  : 			int i;
; 669  : 			for (i = 0; i < strBuffer->cnt; i++)

  00288	33 c9		 xor	 ecx, ecx
  0028a	38 8e 07 01 00
	00		 cmp	 BYTE PTR [esi+263], cl
  00290	76 20		 jbe	 SHORT $LN5@StockFontB
  00292	8d 97 05 00 00
	00		 lea	 edx, DWORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[edi+5]
  00298	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL6@StockFontB:

; 670  : 				FontBuffer[FontCnt].str[i] = '*';

  002a0	c6 02 2a	 mov	 BYTE PTR [edx], 42	; 0000002aH
  002a3	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  002a6	0f b6 86 07 01
	00 00		 movzx	 eax, BYTE PTR [esi+263]
  002ad	41		 inc	 ecx
  002ae	3b c8		 cmp	 ecx, eax
  002b0	7c ee		 jl	 SHORT $LL6@StockFontB
$LN5@StockFontB:

; 671  : 			FontBuffer[FontCnt].str[i] = NULL;

  002b2	88 9c 0f 05 00
	00 00		 mov	 BYTE PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[edi+ecx+5], bl

; 672  : 		}

  002b9	eb 55		 jmp	 SHORT $LN29@StockFontB
$LN26@StockFontB:

; 673  : 		else {
; 674  : 			extern int ÁºñÁ†Å;
; 675  : 			if (ÁºñÁ†Å == 950) {

  002bb	81 3d 00 00 00
	00 b6 03 00 00	 cmp	 DWORD PTR ???@@3HA, 950	; ??, 000003b6H
  002c5	75 2a		 jne	 SHORT $LN28@StockFontB

; 676  : 				extern char* GB2312ToBIG5(const char* szBIG5String);
; 677  : 				strcpy(FontBuffer[FontCnt].str, GB2312ToBIG5((const char *)strBuffer->buffer));

  002c7	56		 push	 esi
  002c8	e8 00 00 00 00	 call	 ?GB2312ToBIG5@@YAPADPBD@Z ; GB2312ToBIG5
  002cd	69 0d 00 00 00
	00 10 01 00 00	 imul	 ecx, DWORD PTR ?FontCnt@@3HA, 272 ; FontCnt
  002d7	83 c4 04	 add	 esp, 4
  002da	2b c8		 sub	 ecx, eax
  002dc	8d 91 05 00 00
	00		 lea	 edx, DWORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[ecx+5]
$LL31@StockFontB:
  002e2	8a 08		 mov	 cl, BYTE PTR [eax]
  002e4	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  002e7	88 4c 10 ff	 mov	 BYTE PTR [eax+edx-1], cl
  002eb	84 c9		 test	 cl, cl
  002ed	75 f3		 jne	 SHORT $LL31@StockFontB

; 678  : 			}

  002ef	eb 1f		 jmp	 SHORT $LN29@StockFontB
$LN28@StockFontB:

; 679  : 			else
; 680  : 				strcpy(FontBuffer[FontCnt].str, strBuffer->buffer);

  002f1	8b ce		 mov	 ecx, esi
  002f3	2b fe		 sub	 edi, esi
  002f5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL32@StockFontB:
  00300	8a 01		 mov	 al, BYTE PTR [ecx]
  00302	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00305	88 84 39 04 00
	00 00		 mov	 BYTE PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[ecx+edi+4], al
  0030c	84 c0		 test	 al, al
  0030e	75 f0		 jne	 SHORT $LL32@StockFontB
$LN29@StockFontB:

; 681  : 		}
; 682  : 		strBuffer->imeX = strBuffer->x - 60 + strBuffer->cursor*(FONT_SIZE >> 1);

  00310	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00317	5f		 pop	 edi
  00318	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0031f	2b c8		 sub	 ecx, eax
  00321	8b 86 0c 01 00
	00		 mov	 eax, DWORD PTR [esi+268]
  00327	83 c0 c4	 add	 eax, -60		; ffffffc4H
  0032a	03 c1		 add	 eax, ecx

; 683  : 		strBuffer->imeY = strBuffer->y;
; 684  : 		strBuffer->hitFontNo = FontCnt++;
; 685  : 		}
; 686  : 	}

  0032c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0032f	89 86 14 01 00
	00		 mov	 DWORD PTR [esi+276], eax
  00335	33 cd		 xor	 ecx, ebp
  00337	8b 86 10 01 00
	00		 mov	 eax, DWORD PTR [esi+272]
  0033d	89 86 18 01 00
	00		 mov	 DWORD PTR [esi+280], eax
  00343	a1 00 00 00 00	 mov	 eax, DWORD PTR ?FontCnt@@3HA ; FontCnt
  00348	89 86 24 01 00
	00		 mov	 DWORD PTR [esi+292], eax
  0034e	ff 05 00 00 00
	00		 inc	 DWORD PTR ?FontCnt@@3HA	; FontCnt
  00354	5e		 pop	 esi
  00355	5b		 pop	 ebx
  00356	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0035b	8b e5		 mov	 esp, ebp
  0035d	5d		 pop	 ebp
  0035e	c3		 ret	 0
?StockFontBufferFamily@@YAXPAUSTR_BUFFER@@@Z ENDP	; StockFontBufferFamily
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp
;	COMDAT ?MyNewStockFontBuffer@@YAXPAU_CHAT_BUFFER@@HEPADHH@Z
_TEXT	SEGMENT
_strl$1$ = -544						; size = 4
_pTextStr$1$ = -540					; size = 4
_pTextPet$1$ = -536					; size = 4
_c$1$ = -532						; size = 4
_fontsize$1 = -528					; size = 8
_fontsize$2 = -528					; size = 8
_fontsize$3 = -528					; size = 8
_fontsize$4 = -528					; size = 8
_fontsize$5 = -528					; size = 8
_fontsize$6 = -528					; size = 8
_pTextPos$1$ = -524					; size = 4
_temp1$1$ = -520					; size = 4
_outText$ = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_chatbuffer$ = 8					; size = 4
_x$ = 12						; size = 4
_color$ = 16						; size = 1
_str$ = 20						; size = 4
_size$ = 24						; size = 4
_id$ = 28						; size = 4
?MyNewStockFontBuffer@@YAXPAU_CHAT_BUFFER@@HEPADHH@Z PROC ; MyNewStockFontBuffer, COMDAT

; 248  : void MyNewStockFontBuffer(CHAT_BUFFER *chatbuffer, int x, unsigned char color, char *str, int size, int id){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 02 00
	00		 sub	 esp, 544		; 00000220H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _chatbuffer$[ebp]
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	8b 7d 14	 mov	 edi, DWORD PTR _str$[ebp]

; 249  : 	//  1„ÄÅ‰πãÂâçÁöÑË°®ÊÉÖ #1 Âèò‰∏∫{ #1 }
; 250  : 	//	3„ÄÅ{ c = 2,pet = Í≥†Î•¥Í≥†Î•¥ | Áß∞Âè∑ | Êîª | Èò≤...,str = ÂçñÎπ®Í∞Ñ Ìò∏ÎûëÏù¥ } Ë°®Á§∫Ôºöc‰∏∫colorÔºåstr‰∏∫ÊòæÁ§∫ÊñáÂ≠óÔºåpet‰∏∫Èº†Ê†áÁßªÂä®‰∏äÂéªÔºåÊòæÁ§∫Áõ∏ÂÖ≥ÁöÑÂõæÊ°£ÂèäÈôÑÂä†‰ø°ÊÅØ
; 251  : 	//	3„ÄÅ{ c = 2,item = Â∞èÁöÑÊû™ | Áß∞Âè∑ | Êîª | Èò≤...,str = Â∞èÁöÑÊû™ } Ë°®Á§∫Ôºöc‰∏∫colorÔºåstr‰∏∫ÊòæÁ§∫ÊñáÂ≠óÔºåitem‰∏∫Èº†Ê†áÁßªÂä®‰∏äÂéªÔºåÊòæÁ§∫Áõ∏ÂÖ≥ÁöÑÂõæÊ°£ÂèäÈôÑÂä†‰ø°ÊÅØ
; 252  : 	//	4„ÄÅ{ c = 2,pos = map,x,y,str = xxÂùêÊ†á } Ë°®Á§∫Ôºöc‰∏∫colorÔºåstr‰∏∫ÊòæÁ§∫ÊñáÂ≠óÔºåpos‰∏∫Èº†Ê†áÁÇπÂáªÂèØÂØªË∑Ø
; 253  : 
; 254  : 	if (!str[0])return;

  0001c	80 3f 00	 cmp	 BYTE PTR [edi], 0
  0001f	0f 84 88 05 00
	00		 je	 $LN7@MyNewStock

; 255  : 	memset(chatbuffer, 0, sizeof(CHAT_BUFFER));

  00025	68 4c 01 00 00	 push	 332			; 0000014cH
  0002a	6a 00		 push	 0
  0002c	53		 push	 ebx
  0002d	e8 00 00 00 00	 call	 _memset

; 256  : 	chatbuffer->fontsize = size;

  00032	8b 45 18	 mov	 eax, DWORD PTR _size$[ebp]
  00035	89 83 48 01 00
	00		 mov	 DWORD PTR [ebx+328], eax

; 257  : 	chatbuffer->id = id;

  0003b	8b 45 1c	 mov	 eax, DWORD PTR _id$[ebp]

; 258  : 	char outText[512];
; 259  : 	//Êü•Êâæ { 
; 260  : 	char *temp1 = sunday(str, "{");

  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_01HCONENDN@?$HL@
  00043	57		 push	 edi
  00044	89 83 08 01 00
	00		 mov	 DWORD PTR [ebx+264], eax
  0004a	e8 00 00 00 00	 call	 ?sunday@@YAPADPAD0@Z	; sunday
  0004f	83 c4 14	 add	 esp, 20			; 00000014H
  00052	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _temp1$1$[ebp], eax

; 261  : 	if (temp1){

  00058	85 c0		 test	 eax, eax
  0005a	0f 84 2a 05 00
	00		 je	 $LN6@MyNewStock

; 262  : 		if (temp1 == str){

  00060	3b c7		 cmp	 eax, edi
  00062	0f 85 8d 04 00
	00		 jne	 $LN69@MyNewStock

; 263  : 			char *temp2 = sunday(str, "}");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_01CELHOKLL@?$HN@
  0006d	57		 push	 edi
  0006e	e8 00 00 00 00	 call	 ?sunday@@YAPADPAD0@Z	; sunday
  00073	8b f0		 mov	 esi, eax
  00075	83 c4 08	 add	 esp, 8

; 264  : 			if (temp2){

  00078	85 f6		 test	 esi, esi
  0007a	0f 84 c6 00 00
	00		 je	 $LN11@MyNewStock

; 265  : 				int strl = temp2 - str;

  00080	2b f7		 sub	 esi, edi

; 266  : 				memcpy(outText, str + 1, strl );   //outText‰∏∫#‰πãÂâçÁöÑÊã∑Ë¥ù

  00082	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  00085	56		 push	 esi
  00086	51		 push	 ecx
  00087	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _outText$[ebp]
  0008d	89 b5 e0 fd ff
	ff		 mov	 DWORD PTR _strl$1$[ebp], esi
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 _memcpy

; 267  : 				outText[strl-1] = 0x0;

  00099	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009f	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  000a4	0f 83 14 05 00
	00		 jae	 $LN31@MyNewStock
  000aa	c6 84 05 fc fd
	ff ff 00	 mov	 BYTE PTR _outText$[ebp+eax], 0

; 268  : 				char* pStr = outText;
; 269  : 				if (*pStr == '#'){

  000b2	80 bd fc fd ff
	ff 23		 cmp	 BYTE PTR _outText$[ebp], 35 ; 00000023H
  000b9	0f 85 41 01 00
	00		 jne	 $LN10@MyNewStock

; 270  : 					//Ê£ÄÊµãË°®ÊÉÖ
; 271  : 					int cnt_int = 0;

  000bf	33 c9		 xor	 ecx, ecx

; 272  : 					int i = 1;

  000c1	ba 01 00 00 00	 mov	 edx, 1
  000c6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@MyNewStock:

; 273  : 					for (i; i<4; i++) {
; 274  : 						if (pStr[i] >= '0'&& pStr[i] <= '9') {

  000d0	8a a4 15 fc fd
	ff ff		 mov	 ah, BYTE PTR _outText$[ebp+edx]
  000d7	8a c4		 mov	 al, ah
  000d9	2c 30		 sub	 al, 48			; 00000030H
  000db	3c 09		 cmp	 al, 9
  000dd	77 12		 ja	 SHORT $LN12@MyNewStock

; 275  : 							cnt_int *= 10;

  000df	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]

; 276  : 							cnt_int += pStr[i] - '0';

  000e2	0f be c4	 movsx	 eax, ah
  000e5	42		 inc	 edx
  000e6	8d 49 e8	 lea	 ecx, DWORD PTR [ecx-24]
  000e9	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000ec	83 fa 04	 cmp	 edx, 4
  000ef	7c df		 jl	 SHORT $LL4@MyNewStock
$LN12@MyNewStock:

; 277  : 						}else{
; 278  : 							break;
; 279  : 						}
; 280  : 					}
; 281  : 
; 282  : 					if (cnt_int>0 && cnt_int <= EXPRESSION_NOID_NUM + 1) {

  000f1	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  000f4	83 f8 62	 cmp	 eax, 98			; 00000062H
  000f7	77 5f		 ja	 SHORT $LN14@MyNewStock

; 283  : 						chatbuffer->x = x;

  000f9	8b 75 0c	 mov	 esi, DWORD PTR _x$[ebp]

; 284  : 						chatbuffer->BmpNo = EXPRESSION_NOID_START + cnt_int - 1;

  000fc	8d 81 4c d7 00
	00		 lea	 eax, DWORD PTR [ecx+55116]

; 285  : 						pStr += i;
; 286  : 						x += 26;   //Ë°®ÊÉÖÁöÑÂÆΩÂ∫¶
; 287  : 						chatbuffer->NextChatBuffer = (CHAT_BUFFER *)calloc(1, sizeof(CHAT_BUFFER));

  00102	68 4c 01 00 00	 push	 332			; 0000014cH
  00107	89 b3 10 01 00
	00		 mov	 DWORD PTR [ebx+272], esi
  0010d	83 c6 1a	 add	 esi, 26			; 0000001aH
  00110	6a 01		 push	 1
  00112	89 83 0c 01 00
	00		 mov	 DWORD PTR [ebx+268], eax
  00118	e8 00 00 00 00	 call	 _calloc

; 288  : 						MyNewStockFontBuffer(chatbuffer->NextChatBuffer, x , color, temp1 + strl + 1, size, id);  //Â∞ÜÂêéÁª≠ÊñáÂ≠óÁªßÁª≠ÈÅçÂéÜËæìÂá∫

  0011d	ff 75 1c	 push	 DWORD PTR _id$[ebp]
  00120	8b 95 f8 fd ff
	ff		 mov	 edx, DWORD PTR _temp1$1$[ebp]
  00126	ff 75 18	 push	 DWORD PTR _size$[ebp]
  00129	8b 8d e0 fd ff
	ff		 mov	 ecx, DWORD PTR _strl$1$[ebp]
  0012f	42		 inc	 edx
  00130	03 ca		 add	 ecx, edx
  00132	89 83 14 01 00
	00		 mov	 DWORD PTR [ebx+276], eax
  00138	51		 push	 ecx
  00139	ff 75 10	 push	 DWORD PTR _color$[ebp]
  0013c	56		 push	 esi
$LN74@MyNewStock:

; 369  : 				}
; 370  : 
; 371  : 			
; 372  : 			}
; 373  : 			__asm nop;

  0013d	50		 push	 eax
  0013e	e8 00 00 00 00	 call	 ?MyNewStockFontBuffer@@YAXPAU_CHAT_BUFFER@@HEPADHH@Z ; MyNewStockFontBuffer
  00143	83 c4 20	 add	 esp, 32			; 00000020H
$LN11@MyNewStock:
  00146	90		 npad	 1
  00147	5f		 pop	 edi

; 393  : 	}
; 394  : 
; 395  : 
; 396  : }

  00148	5e		 pop	 esi
  00149	5b		 pop	 ebx
  0014a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014d	33 cd		 xor	 ecx, ebp
  0014f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00154	8b e5		 mov	 esp, ebp
  00156	5d		 pop	 ebp
  00157	c3		 ret	 0
$LN14@MyNewStock:

; 289  : 					}else{
; 290  : 						//Â¶ÇÊûú‰∏çÊòØË°®ÊÉÖÔºåÂàôÊää{#xxx}ËæìÂá∫
; 291  : 						memcpy(outText, str, strl+1);   

  00158	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0015b	50		 push	 eax
  0015c	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _outText$[ebp]
  00162	57		 push	 edi
  00163	50		 push	 eax
  00164	e8 00 00 00 00	 call	 _memcpy

; 292  : 						outText[strl+1] = 0x0;

  00169	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0016c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0016f	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  00174	0f 83 44 04 00
	00		 jae	 $LN31@MyNewStock

; 293  : 						SIZE fontsize;
; 294  : 						GetTextExtentPoint32(FontSizeHdc, (LPCSTR)outText, strl+1, (LPSIZE)&fontsize);

  0017a	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _fontsize$6[ebp]
  00180	c6 84 05 fc fd
	ff ff 00	 mov	 BYTE PTR _outText$[ebp+eax], 0
  00188	51		 push	 ecx
  00189	50		 push	 eax
  0018a	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _outText$[ebp]
  00190	50		 push	 eax
  00191	ff 35 00 00 00
	00		 push	 DWORD PTR ?FontSizeHdc@@3PAUHDC__@@A ; FontSizeHdc
  00197	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTextExtentPoint32A@16

; 295  : 						chatbuffer->color = color;

  0019d	8b 45 10	 mov	 eax, DWORD PTR _color$[ebp]

; 296  : 						chatbuffer->x = x;
; 297  : 						strcpy(chatbuffer->buffer, outText);

  001a0	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _outText$[ebp]
  001a6	8b 7d 0c	 mov	 edi, DWORD PTR _x$[ebp]
  001a9	8b d3		 mov	 edx, ebx
  001ab	88 83 05 01 00
	00		 mov	 BYTE PTR [ebx+261], al
  001b1	8b c1		 mov	 eax, ecx
  001b3	89 bb 10 01 00
	00		 mov	 DWORD PTR [ebx+272], edi
  001b9	2b d0		 sub	 edx, eax
  001bb	0f 1f 44 00 00	 npad	 5
$LL33@MyNewStock:
  001c0	8a 01		 mov	 al, BYTE PTR [ecx]
  001c2	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  001c5	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  001c9	84 c0		 test	 al, al
  001cb	75 f3		 jne	 SHORT $LL33@MyNewStock

; 298  : 						chatbuffer->NextChatBuffer = (CHAT_BUFFER *)calloc(1, sizeof(CHAT_BUFFER));

  001cd	68 4c 01 00 00	 push	 332			; 0000014cH
  001d2	6a 01		 push	 1
  001d4	e8 00 00 00 00	 call	 _calloc

; 299  : 						MyNewStockFontBuffer(chatbuffer->NextChatBuffer, x + fontsize.cx, color, temp1+ strl+1, size, id);  //Â∞ÜÂêéÁª≠ÊñáÂ≠óÁªßÁª≠ÈÅçÂéÜËæìÂá∫

  001d9	ff 75 1c	 push	 DWORD PTR _id$[ebp]
  001dc	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR _temp1$1$[ebp]
  001e2	ff 75 18	 push	 DWORD PTR _size$[ebp]
  001e5	41		 inc	 ecx
  001e6	89 83 14 01 00
	00		 mov	 DWORD PTR [ebx+276], eax
  001ec	03 ce		 add	 ecx, esi
  001ee	51		 push	 ecx
  001ef	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _fontsize$6[ebp]
  001f5	ff 75 10	 push	 DWORD PTR _color$[ebp]
  001f8	03 cf		 add	 ecx, edi
  001fa	51		 push	 ecx

; 300  : 					}
; 301  : 				}else{

  001fb	e9 3d ff ff ff	 jmp	 $LN74@MyNewStock
$LN10@MyNewStock:

; 302  : 					//Â¶ÇÊûú‰∏çÊòØË°®ÊÉÖÁöÑ#
; 303  : 					int c = getStrColor(outText);

  00200	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _outText$[ebp]
  00206	50		 push	 eax
  00207	e8 00 00 00 00	 call	 ?getStrColor@@YAHPAD@Z	; getStrColor
  0020c	83 c4 04	 add	 esp, 4
  0020f	89 85 ec fd ff
	ff		 mov	 DWORD PTR _c$1$[ebp], eax

; 304  : 					if (c == -1)c = color;

  00215	83 f8 ff	 cmp	 eax, -1
  00218	75 0c		 jne	 SHORT $LN16@MyNewStock
  0021a	8b 45 10	 mov	 eax, DWORD PTR _color$[ebp]
  0021d	0f b6 c0	 movzx	 eax, al
  00220	89 85 ec fd ff
	ff		 mov	 DWORD PTR _c$1$[ebp], eax
$LN16@MyNewStock:

; 305  : 					char* pTextStr = sunday(str, "str=");

  00226	68 00 00 00 00	 push	 OFFSET ??_C@_04FOGPFBLG@str?$DN@
  0022b	57		 push	 edi
  0022c	e8 00 00 00 00	 call	 ?sunday@@YAPADPAD0@Z	; sunday

; 306  : 					char* pTextPos = sunday(str, "pos=");

  00231	68 00 00 00 00	 push	 OFFSET ??_C@_04JPBFJBMP@pos?$DN@
  00236	57		 push	 edi
  00237	89 85 e4 fd ff
	ff		 mov	 DWORD PTR _pTextStr$1$[ebp], eax
  0023d	e8 00 00 00 00	 call	 ?sunday@@YAPADPAD0@Z	; sunday

; 307  : #ifdef _NB_ÁßÄÂÆ†Áâ©
; 308  : 					char* pTextPet = sunday(str, "pet=");

  00242	68 00 00 00 00	 push	 OFFSET ??_C@_04PFOHGHCO@pet?$DN@
  00247	57		 push	 edi
  00248	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _pTextPos$1$[ebp], eax
  0024e	e8 00 00 00 00	 call	 ?sunday@@YAPADPAD0@Z	; sunday

; 309  : #endif
; 310  : 					char* pTextItem = sunday(str, "item=");

  00253	68 00 00 00 00	 push	 OFFSET ??_C@_05ELILFBDN@item?$DN@
  00258	57		 push	 edi
  00259	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _pTextPet$1$[ebp], eax
  0025f	e8 00 00 00 00	 call	 ?sunday@@YAPADPAD0@Z	; sunday

; 311  : 
; 312  : 					if (!pTextPos && !pTextPet && !pTextItem && pTextStr){

  00264	8b 8d f4 fd ff
	ff		 mov	 ecx, DWORD PTR _pTextPos$1$[ebp]
  0026a	83 c4 20	 add	 esp, 32			; 00000020H
  0026d	8b d0		 mov	 edx, eax
  0026f	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _pTextPet$1$[ebp]
  00275	85 c9		 test	 ecx, ecx
  00277	0f 85 ca 00 00
	00		 jne	 $LN20@MyNewStock
  0027d	85 c0		 test	 eax, eax
  0027f	0f 85 c2 00 00
	00		 jne	 $LN20@MyNewStock
  00285	85 d2		 test	 edx, edx
  00287	0f 85 ba 00 00
	00		 jne	 $LN20@MyNewStock
  0028d	39 95 e4 fd ff
	ff		 cmp	 DWORD PTR _pTextStr$1$[ebp], edx
  00293	0f 84 b7 00 00
	00		 je	 $LN19@MyNewStock

; 313  : 						//Â¶ÇÊûúÂè™ÊúâstrÔºåÂàôÂèòËâ≤ËæìÂá∫
; 314  : 						getStrStr(str, outText);

  00299	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _outText$[ebp]
  0029f	50		 push	 eax
  002a0	57		 push	 edi
  002a1	e8 00 00 00 00	 call	 ?getStrStr@@YAXPAD0@Z	; getStrStr
  002a6	83 c4 08	 add	 esp, 8

; 315  : 						SIZE fontsize;
; 316  : 						GetTextExtentPoint32(FontSizeHdc, (LPCSTR)outText, lstrlen(outText), (LPSIZE)&fontsize);

  002a9	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _fontsize$5[ebp]
  002af	50		 push	 eax
  002b0	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _outText$[ebp]
  002b6	50		 push	 eax
  002b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  002bd	50		 push	 eax
  002be	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _outText$[ebp]
  002c4	50		 push	 eax
  002c5	ff 35 00 00 00
	00		 push	 DWORD PTR ?FontSizeHdc@@3PAUHDC__@@A ; FontSizeHdc
  002cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTextExtentPoint32A@16

; 317  : 						chatbuffer->color = c;

  002d1	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _c$1$[ebp]

; 318  : 						chatbuffer->x = x;
; 319  : 						strcpy(chatbuffer->buffer, outText);

  002d7	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _outText$[ebp]
  002dd	8b 7d 0c	 mov	 edi, DWORD PTR _x$[ebp]
  002e0	8b d3		 mov	 edx, ebx
  002e2	88 83 05 01 00
	00		 mov	 BYTE PTR [ebx+261], al
  002e8	8b c1		 mov	 eax, ecx
  002ea	89 bb 10 01 00
	00		 mov	 DWORD PTR [ebx+272], edi
  002f0	2b d0		 sub	 edx, eax
$LL34@MyNewStock:
  002f2	8a 01		 mov	 al, BYTE PTR [ecx]
  002f4	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  002f7	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  002fb	84 c0		 test	 al, al
  002fd	75 f3		 jne	 SHORT $LL34@MyNewStock
$LN75@MyNewStock:

; 393  : 	}
; 394  : 
; 395  : 
; 396  : }

  002ff	68 4c 01 00 00	 push	 332			; 0000014cH
  00304	6a 01		 push	 1
  00306	e8 00 00 00 00	 call	 _calloc
  0030b	ff 75 1c	 push	 DWORD PTR _id$[ebp]
  0030e	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR _temp1$1$[ebp]
  00314	ff 75 18	 push	 DWORD PTR _size$[ebp]
  00317	41		 inc	 ecx
  00318	03 ce		 add	 ecx, esi
  0031a	51		 push	 ecx
  0031b	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _fontsize$5[ebp]
  00321	03 cf		 add	 ecx, edi
$LN77@MyNewStock:
  00323	ff 75 10	 push	 DWORD PTR _color$[ebp]
  00326	89 83 14 01 00
	00		 mov	 DWORD PTR [ebx+276], eax
  0032c	51		 push	 ecx
  0032d	50		 push	 eax
  0032e	e8 00 00 00 00	 call	 ?MyNewStockFontBuffer@@YAXPAU_CHAT_BUFFER@@HEPADHH@Z ; MyNewStockFontBuffer
  00333	83 c4 20	 add	 esp, 32			; 00000020H
  00336	5f		 pop	 edi
  00337	5e		 pop	 esi
  00338	5b		 pop	 ebx
  00339	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0033c	33 cd		 xor	 ecx, ebp
  0033e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00343	8b e5		 mov	 esp, ebp
  00345	5d		 pop	 ebp
  00346	c3		 ret	 0
$LN20@MyNewStock:

; 320  : 						chatbuffer->NextChatBuffer = (CHAT_BUFFER *)calloc(1, sizeof(CHAT_BUFFER));
; 321  : 						MyNewStockFontBuffer(chatbuffer->NextChatBuffer, x + fontsize.cx, color, temp1 + strl + 1, size, id);  //Â∞ÜÂêéÁª≠ÊñáÂ≠óÁªßÁª≠ÈÅçÂéÜËæìÂá∫
; 322  : 						return;
; 323  : 					}
; 324  : 
; 325  : 					if (!pTextPos && !pTextPet && !pTextItem || pTextStr == NULL){

  00347	83 bd e4 fd ff
	ff 00		 cmp	 DWORD PTR _pTextStr$1$[ebp], 0
  0034e	75 78		 jne	 SHORT $LN18@MyNewStock
$LN19@MyNewStock:

; 326  : 						//Â¶ÇÊûúÊâæ‰∏çÂà∞ÂØπÂ∫îÊñáÊú¨ÔºåÂàôËßÜ‰∏∫ÊôÆÈÄöÁöÑÊñáÊú¨ÔºåÁÖßÂ∏∏ËæìÂá∫
; 327  : 						memcpy(outText, str, strl + 1);   

  00350	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00353	50		 push	 eax
  00354	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _outText$[ebp]
  0035a	57		 push	 edi
  0035b	50		 push	 eax
  0035c	e8 00 00 00 00	 call	 _memcpy

; 328  : 						outText[strl + 1] = 0x0;

  00361	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00364	83 c4 0c	 add	 esp, 12			; 0000000cH
  00367	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  0036c	0f 83 4c 02 00
	00		 jae	 $LN31@MyNewStock

; 329  : 						SIZE fontsize;
; 330  : 						GetTextExtentPoint32(FontSizeHdc, (LPCSTR)outText, strl + 1, (LPSIZE)&fontsize);

  00372	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _fontsize$4[ebp]
  00378	c6 84 05 fc fd
	ff ff 00	 mov	 BYTE PTR _outText$[ebp+eax], 0
  00380	51		 push	 ecx
  00381	50		 push	 eax
  00382	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _outText$[ebp]
  00388	50		 push	 eax
  00389	ff 35 00 00 00
	00		 push	 DWORD PTR ?FontSizeHdc@@3PAUHDC__@@A ; FontSizeHdc
  0038f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTextExtentPoint32A@16

; 331  : 						chatbuffer->color = c;

  00395	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _c$1$[ebp]

; 332  : 						chatbuffer->x = x;
; 333  : 						strcpy(chatbuffer->buffer, outText);

  0039b	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _outText$[ebp]
  003a1	8b 7d 0c	 mov	 edi, DWORD PTR _x$[ebp]
  003a4	8b d3		 mov	 edx, ebx
  003a6	88 83 05 01 00
	00		 mov	 BYTE PTR [ebx+261], al
  003ac	8b c1		 mov	 eax, ecx
  003ae	89 bb 10 01 00
	00		 mov	 DWORD PTR [ebx+272], edi
  003b4	2b d0		 sub	 edx, eax
$LL37@MyNewStock:
  003b6	8a 01		 mov	 al, BYTE PTR [ecx]
  003b8	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  003bb	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  003bf	84 c0		 test	 al, al
  003c1	75 f3		 jne	 SHORT $LL37@MyNewStock

; 334  : 						chatbuffer->NextChatBuffer = (CHAT_BUFFER *)calloc(1, sizeof(CHAT_BUFFER));
; 335  : 						MyNewStockFontBuffer(chatbuffer->NextChatBuffer, x + fontsize.cx, color, temp1 + strl + 1, size, id);  //Â∞ÜÂêéÁª≠ÊñáÂ≠óÁªßÁª≠ÈÅçÂéÜËæìÂá∫
; 336  : 						return;

  003c3	e9 37 ff ff ff	 jmp	 $LN75@MyNewStock
$LN18@MyNewStock:

; 337  : 					}
; 338  : 
; 339  : 					if (pTextPos){

  003c8	85 c9		 test	 ecx, ecx
  003ca	74 7d		 je	 SHORT $LN21@MyNewStock

; 340  : 						//Ëé∑ÂèñÂùêÊ†á
; 341  : 						if (getStrPos(str, chatbuffer)){

  003cc	53		 push	 ebx
  003cd	57		 push	 edi
  003ce	e8 00 00 00 00	 call	 ?getStrPos@@YA_NPADPAU_CHAT_BUFFER@@@Z ; getStrPos
  003d3	83 c4 08	 add	 esp, 8
  003d6	84 c0		 test	 al, al
  003d8	0f 84 11 01 00
	00		 je	 $LN24@MyNewStock

; 342  : 							getStrStr(str, outText);

  003de	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _outText$[ebp]
  003e4	50		 push	 eax
  003e5	57		 push	 edi
  003e6	e8 00 00 00 00	 call	 ?getStrStr@@YAXPAD0@Z	; getStrStr
  003eb	83 c4 08	 add	 esp, 8

; 343  : 							SIZE fontsize;
; 344  : 							GetTextExtentPoint32(FontSizeHdc, (LPCSTR)outText, lstrlen(outText), (LPSIZE)&fontsize);

  003ee	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _fontsize$3[ebp]
  003f4	50		 push	 eax
  003f5	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _outText$[ebp]
  003fb	50		 push	 eax
  003fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  00402	50		 push	 eax
  00403	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _outText$[ebp]
  00409	50		 push	 eax
  0040a	ff 35 00 00 00
	00		 push	 DWORD PTR ?FontSizeHdc@@3PAUHDC__@@A ; FontSizeHdc
  00410	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTextExtentPoint32A@16

; 345  : 							chatbuffer->color = c;

  00416	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _c$1$[ebp]

; 346  : 							chatbuffer->x = x;
; 347  : 							strcpy(chatbuffer->buffer, outText);

  0041c	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _outText$[ebp]
  00422	8b 7d 0c	 mov	 edi, DWORD PTR _x$[ebp]
  00425	8b d3		 mov	 edx, ebx
  00427	88 83 05 01 00
	00		 mov	 BYTE PTR [ebx+261], al
  0042d	8b c1		 mov	 eax, ecx
  0042f	89 bb 10 01 00
	00		 mov	 DWORD PTR [ebx+272], edi
  00435	2b d0		 sub	 edx, eax
$LL38@MyNewStock:
  00437	8a 01		 mov	 al, BYTE PTR [ecx]
  00439	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  0043c	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  00440	84 c0		 test	 al, al
  00442	75 f3		 jne	 SHORT $LL38@MyNewStock

; 348  : 							chatbuffer->NextChatBuffer = (CHAT_BUFFER *)calloc(1, sizeof(CHAT_BUFFER));
; 349  : 							MyNewStockFontBuffer(chatbuffer->NextChatBuffer, x + fontsize.cx, color, temp1 + strl + 1, size, id);  //Â∞ÜÂêéÁª≠ÊñáÂ≠óÁªßÁª≠ÈÅçÂéÜËæìÂá∫
; 350  : 							return;

  00444	e9 b6 fe ff ff	 jmp	 $LN75@MyNewStock
$LN21@MyNewStock:

; 351  : 						}
; 352  : #ifdef _NB_ÁßÄÂÆ†Áâ©
; 353  : 					}else if (pTextPet){//Ëé∑ÂèñÂÆ†Áâ©

  00449	85 c0		 test	 eax, eax
  0044b	0f 84 9e 00 00
	00		 je	 $LN24@MyNewStock

; 354  : 						int ÂÆ†Áâ©Á¥¢Âºï = getStrPetindex(str);

  00451	57		 push	 edi
  00452	e8 00 00 00 00	 call	 ?getStrPetindex@@YAHPAD@Z ; getStrPetindex
  00457	8b f0		 mov	 esi, eax

; 355  : 						getStrStr(str, outText);

  00459	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _outText$[ebp]
  0045f	50		 push	 eax
  00460	57		 push	 edi
  00461	e8 00 00 00 00	 call	 ?getStrStr@@YAXPAD0@Z	; getStrStr
  00466	83 c4 0c	 add	 esp, 12			; 0000000cH

; 356  : 						chatbuffer->image = ÂÆ†Áâ©Á¥¢Âºï;

  00469	89 b3 40 01 00
	00		 mov	 DWORD PTR [ebx+320], esi

; 357  : 						SIZE fontsize;
; 358  : 						GetTextExtentPoint32(FontSizeHdc, (LPCSTR)outText, lstrlen(outText), (LPSIZE)&fontsize);

  0046f	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _fontsize$2[ebp]
  00475	50		 push	 eax
  00476	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _outText$[ebp]
  0047c	50		 push	 eax
  0047d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  00483	50		 push	 eax
  00484	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _outText$[ebp]
  0048a	50		 push	 eax
  0048b	ff 35 00 00 00
	00		 push	 DWORD PTR ?FontSizeHdc@@3PAUHDC__@@A ; FontSizeHdc
  00491	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTextExtentPoint32A@16

; 359  : 						chatbuffer->color = 11;
; 360  : 						chatbuffer->x = x;

  00497	8b 75 0c	 mov	 esi, DWORD PTR _x$[ebp]

; 361  : 						strcpy(chatbuffer->buffer, outText);

  0049a	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _outText$[ebp]
  004a0	8b d3		 mov	 edx, ebx
  004a2	c6 83 05 01 00
	00 0b		 mov	 BYTE PTR [ebx+261], 11	; 0000000bH
  004a9	8b c1		 mov	 eax, ecx
  004ab	89 b3 10 01 00
	00		 mov	 DWORD PTR [ebx+272], esi
  004b1	2b d0		 sub	 edx, eax
$LL39@MyNewStock:
  004b3	8a 01		 mov	 al, BYTE PTR [ecx]
  004b5	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  004b8	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  004bc	84 c0		 test	 al, al
  004be	75 f3		 jne	 SHORT $LL39@MyNewStock

; 362  : 						chatbuffer->NextChatBuffer = (CHAT_BUFFER *)calloc(1, sizeof(CHAT_BUFFER));

  004c0	68 4c 01 00 00	 push	 332			; 0000014cH
  004c5	6a 01		 push	 1
  004c7	e8 00 00 00 00	 call	 _calloc

; 363  : 						MyNewStockFontBuffer(chatbuffer->NextChatBuffer, x + fontsize.cx, color, temp1 + strl + 1, size, id);  //Â∞ÜÂêéÁª≠ÊñáÂ≠óÁªßÁª≠ÈÅçÂéÜËæìÂá∫

  004cc	ff 75 1c	 push	 DWORD PTR _id$[ebp]
  004cf	8b 95 f8 fd ff
	ff		 mov	 edx, DWORD PTR _temp1$1$[ebp]
  004d5	8b 8d e0 fd ff
	ff		 mov	 ecx, DWORD PTR _strl$1$[ebp]
  004db	42		 inc	 edx
  004dc	ff 75 18	 push	 DWORD PTR _size$[ebp]
  004df	03 ca		 add	 ecx, edx
  004e1	51		 push	 ecx
  004e2	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _fontsize$2[ebp]
  004e8	03 ce		 add	 ecx, esi

; 364  : 						return;

  004ea	e9 34 fe ff ff	 jmp	 $LN77@MyNewStock
$LN24@MyNewStock:

; 365  : #endif
; 366  : 					}else if (pTextItem){//Ëé∑ÂèñÈÅìÂÖ∑
; 367  : 					}
; 368  : 					__asm nop;

  004ef	90		 npad	 1
  004f0	e9 51 fc ff ff	 jmp	 $LN11@MyNewStock
$LN69@MyNewStock:

; 374  : 		}
; 375  : 		if (temp1 != str){//Â¶ÇÊûú‰∏çÁõ∏Á≠âÔºåÂàô{‰πãÂâçÁöÑÊñáÂ≠óË¶ÅÂÖàËæìÂá∫
; 376  : 			int strl = temp1 - str;

  004f5	8b f0		 mov	 esi, eax

; 377  : 			memcpy(outText, str, strl);   //outText‰∏∫#‰πãÂâçÁöÑÊã∑Ë¥ù

  004f7	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _outText$[ebp]
  004fd	2b f7		 sub	 esi, edi
  004ff	56		 push	 esi
  00500	57		 push	 edi
  00501	50		 push	 eax
  00502	e8 00 00 00 00	 call	 _memcpy
  00507	83 c4 0c	 add	 esp, 12			; 0000000cH

; 378  : 			outText[strl] = 0x0;

  0050a	81 fe 00 02 00
	00		 cmp	 esi, 512		; 00000200H
  00510	0f 83 a8 00 00
	00		 jae	 $LN31@MyNewStock

; 379  : 			SIZE fontsize;
; 380  : 			GetTextExtentPoint32(FontSizeHdc, (LPCSTR)outText, strl, (LPSIZE)&fontsize);

  00516	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _fontsize$1[ebp]
  0051c	c6 84 35 fc fd
	ff ff 00	 mov	 BYTE PTR _outText$[ebp+esi], 0
  00524	50		 push	 eax
  00525	56		 push	 esi
  00526	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _outText$[ebp]
  0052c	50		 push	 eax
  0052d	ff 35 00 00 00
	00		 push	 DWORD PTR ?FontSizeHdc@@3PAUHDC__@@A ; FontSizeHdc
  00533	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTextExtentPoint32A@16

; 381  : 			chatbuffer->color = color;

  00539	8b 45 10	 mov	 eax, DWORD PTR _color$[ebp]

; 382  : 			chatbuffer->x = x;
; 383  : 			strcpy(chatbuffer->buffer, outText);

  0053c	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _outText$[ebp]
  00542	8b 75 0c	 mov	 esi, DWORD PTR _x$[ebp]
  00545	8b d3		 mov	 edx, ebx
  00547	88 83 05 01 00
	00		 mov	 BYTE PTR [ebx+261], al
  0054d	8b c1		 mov	 eax, ecx
  0054f	89 b3 10 01 00
	00		 mov	 DWORD PTR [ebx+272], esi
  00555	2b d0		 sub	 edx, eax
$LL42@MyNewStock:
  00557	8a 01		 mov	 al, BYTE PTR [ecx]
  00559	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  0055c	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  00560	84 c0		 test	 al, al
  00562	75 f3		 jne	 SHORT $LL42@MyNewStock

; 384  : 			chatbuffer->NextChatBuffer = (CHAT_BUFFER *)calloc(1, sizeof(CHAT_BUFFER));

  00564	68 4c 01 00 00	 push	 332			; 0000014cH
  00569	6a 01		 push	 1
  0056b	e8 00 00 00 00	 call	 _calloc

; 385  : 			MyNewStockFontBuffer(chatbuffer->NextChatBuffer, x + fontsize.cx, color, temp1, size, id);  //Â∞ÜÂêéÁª≠ÊñáÂ≠óÁªßÁª≠ÈÅçÂéÜËæìÂá∫

  00570	ff 75 1c	 push	 DWORD PTR _id$[ebp]
  00573	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _fontsize$1[ebp]
  00579	ff 75 18	 push	 DWORD PTR _size$[ebp]
  0057c	8b 95 f8 fd ff
	ff		 mov	 edx, DWORD PTR _temp1$1$[ebp]
  00582	03 ce		 add	 ecx, esi
  00584	52		 push	 edx

; 386  : 			return;

  00585	e9 99 fd ff ff	 jmp	 $LN77@MyNewStock
$LN6@MyNewStock:

; 387  : 		}
; 388  : 	}else{
; 389  : 		//Â¶ÇÊûúÊ≤°Êúâ{ÂàôÊ≠£Â∏∏ËæìÂá∫ËØ•ÊÆµÊñáÂ≠ó
; 390  : 		chatbuffer->color = color;

  0058a	8a 45 10	 mov	 al, BYTE PTR _color$[ebp]
  0058d	88 83 05 01 00
	00		 mov	 BYTE PTR [ebx+261], al

; 391  : 		chatbuffer->x = x;

  00593	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00596	89 83 10 01 00
	00		 mov	 DWORD PTR [ebx+272], eax
  0059c	2b df		 sub	 ebx, edi
  0059e	66 90		 npad	 2
$LL43@MyNewStock:

; 392  : 		strcpy(chatbuffer->buffer, str);

  005a0	8a 07		 mov	 al, BYTE PTR [edi]
  005a2	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  005a5	88 44 3b ff	 mov	 BYTE PTR [ebx+edi-1], al
  005a9	84 c0		 test	 al, al
  005ab	75 f3		 jne	 SHORT $LL43@MyNewStock
$LN7@MyNewStock:

; 393  : 	}
; 394  : 
; 395  : 
; 396  : }

  005ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005b0	5f		 pop	 edi
  005b1	5e		 pop	 esi
  005b2	33 cd		 xor	 ecx, ebp
  005b4	5b		 pop	 ebx
  005b5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005ba	8b e5		 mov	 esp, ebp
  005bc	5d		 pop	 ebp
  005bd	c3		 ret	 0
$LN31@MyNewStock:
  005be	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN73@MyNewStock:
  005c3	cc		 int	 3
?MyNewStockFontBuffer@@YAXPAU_CHAT_BUFFER@@HEPADHH@Z ENDP ; MyNewStockFontBuffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp
;	COMDAT ?getStrExtraData@@YA_NPAD0@Z
_TEXT	SEGMENT
_strIn$ = 8						; size = 4
_strOut$ = 12						; size = 4
?getStrExtraData@@YA_NPAD0@Z PROC			; getStrExtraData, COMDAT

; 244  : 	return false;

  00000	32 c0		 xor	 al, al

; 245  : }

  00002	c3		 ret	 0
?getStrExtraData@@YA_NPAD0@Z ENDP			; getStrExtraData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp
;	COMDAT ?getStrPet@@YA_NPADPAU_CHAT_BUFFER@@@Z
_TEXT	SEGMENT
_chatbuffer$GSCopy$1$ = -52				; size = 4
_array$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_str$ = 8						; size = 4
_chatbuffer$ = 12					; size = 4
?getStrPet@@YA_NPADPAU_CHAT_BUFFER@@@Z PROC		; getStrPet, COMDAT

; 217  : bool getStrPet(char* str, CHAT_BUFFER *chatbuffer){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _chatbuffer$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _str$[ebp]
  00017	56		 push	 esi
  00018	57		 push	 edi

; 218  : 	//Áß∞Âè∑|100872|0|140|1735|452|202|258|,str=‰Ω©Èú≤Â§è}
; 219  : 	char *temp1 = sunday(str, "pet=");
; 220  : 	int len = lstrlen(str);

  00019	53		 push	 ebx
  0001a	89 45 cc	 mov	 DWORD PTR _chatbuffer$GSCopy$1$[ebp], eax
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  00023	8b f8		 mov	 edi, eax

; 221  : 	char *pbuf = new char[len + 1];

  00025	68 dd 00 00 00	 push	 221			; 000000ddH
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0FG@MOFDFNBM@C?3?2Users?2gg862?2OneDrive?2?$LJ?Y?E?A?5?H?$KN@
  0002f	6a 01		 push	 1
  00031	8d 77 01	 lea	 esi, DWORD PTR [edi+1]
  00034	56		 push	 esi
  00035	e8 00 00 00 00	 call	 ??_U@YAPAXIHPBDH@Z	; operator new[]

; 222  : 	memset(pbuf, 0, len + 1);

  0003a	56		 push	 esi
  0003b	8b f0		 mov	 esi, eax
  0003d	6a 00		 push	 0
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 _memset

; 223  : 	memcpy(pbuf, str, len);

  00045	57		 push	 edi
  00046	53		 push	 ebx
  00047	56		 push	 esi
  00048	e8 00 00 00 00	 call	 _memcpy

; 224  : 
; 225  : 	char* array[10];
; 226  : 	int count = split_damage(pbuf + 5, '|', (int*)array, 8);

  0004d	6a 08		 push	 8
  0004f	8d 45 d4	 lea	 eax, DWORD PTR _array$[ebp]
  00052	50		 push	 eax
  00053	8d 46 05	 lea	 eax, DWORD PTR [esi+5]
  00056	6a 7c		 push	 124			; 0000007cH
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?split_damage@@YAHPADDPAHI@Z ; split_damage
  0005e	83 c4 38	 add	 esp, 56			; 00000038H

; 227  : 	if (count != 8){

  00061	83 f8 08	 cmp	 eax, 8
  00064	74 1c		 je	 SHORT $LN2@getStrPet

; 228  : 		delete[] pbuf;

  00066	56		 push	 esi
  00067	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0006c	83 c4 04	 add	 esp, 4

; 229  : 		return false;

  0006f	32 c0		 xor	 al, al
  00071	5f		 pop	 edi

; 238  : 
; 239  : 	return true;
; 240  : 
; 241  : }

  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00077	33 cd		 xor	 ecx, ebp
  00079	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
$LN2@getStrPet:

; 230  : 	}
; 231  : 	chatbuffer->image = atoi(array[1]);

  00082	ff 75 d8	 push	 DWORD PTR _array$[ebp+4]
  00085	e8 00 00 00 00	 call	 _atoi
  0008a	8b 5d cc	 mov	 ebx, DWORD PTR _chatbuffer$GSCopy$1$[ebp]

; 232  : 	chatbuffer->reborn = atoi(array[2]);

  0008d	ff 75 dc	 push	 DWORD PTR _array$[ebp+8]
  00090	89 83 40 01 00
	00		 mov	 DWORD PTR [ebx+320], eax
  00096	e8 00 00 00 00	 call	 _atoi

; 233  : 	chatbuffer->lv = atoi(array[3]);

  0009b	ff 75 e0	 push	 DWORD PTR _array$[ebp+12]
  0009e	66 89 83 34 01
	00 00		 mov	 WORD PTR [ebx+308], ax
  000a5	e8 00 00 00 00	 call	 _atoi

; 234  : 	chatbuffer->hp = atoi(array[4]);

  000aa	ff 75 e4	 push	 DWORD PTR _array$[ebp+16]
  000ad	66 89 83 36 01
	00 00		 mov	 WORD PTR [ebx+310], ax
  000b4	e8 00 00 00 00	 call	 _atoi

; 235  : 	chatbuffer->gong = atoi(array[5]);

  000b9	ff 75 e8	 push	 DWORD PTR _array$[ebp+20]
  000bc	66 89 83 38 01
	00 00		 mov	 WORD PTR [ebx+312], ax
  000c3	e8 00 00 00 00	 call	 _atoi

; 236  : 	chatbuffer->fang = atoi(array[6]);

  000c8	ff 75 ec	 push	 DWORD PTR _array$[ebp+24]
  000cb	66 89 83 3a 01
	00 00		 mov	 WORD PTR [ebx+314], ax
  000d2	e8 00 00 00 00	 call	 _atoi

; 237  : 	chatbuffer->min = atoi(array[7]);

  000d7	ff 75 f0	 push	 DWORD PTR _array$[ebp+28]
  000da	66 89 83 3c 01
	00 00		 mov	 WORD PTR [ebx+316], ax
  000e1	e8 00 00 00 00	 call	 _atoi

; 238  : 
; 239  : 	return true;
; 240  : 
; 241  : }

  000e6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e9	83 c4 1c	 add	 esp, 28			; 0000001cH
  000ec	66 89 83 3e 01
	00 00		 mov	 WORD PTR [ebx+318], ax
  000f3	33 cd		 xor	 ecx, ebp
  000f5	b0 01		 mov	 al, 1
  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi
  000f9	5b		 pop	 ebx
  000fa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
?getStrPet@@YA_NPADPAU_CHAT_BUFFER@@@Z ENDP		; getStrPet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp
;	COMDAT ?getStrPetindex@@YAHPAD@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
?getStrPetindex@@YAHPAD@Z PROC				; getStrPetindex, COMDAT

; 208  : int getStrPetindex(char* str){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 209  : 	int index = -1;
; 210  : 	char *temp1 = sunday(str, "pet=");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_04PFOHGHCO@pet?$DN@
  00008	ff 75 08	 push	 DWORD PTR _str$[ebp]
  0000b	e8 00 00 00 00	 call	 ?sunday@@YAPADPAD0@Z	; sunday
  00010	83 c4 08	 add	 esp, 8

; 211  : 	if (temp1){

  00013	85 c0		 test	 eax, eax
  00015	74 0c		 je	 SHORT $LN4@getStrPeti

; 212  : 		index = atoi(temp1 + 4);

  00017	83 c0 04	 add	 eax, 4
  0001a	89 45 08	 mov	 DWORD PTR _str$[ebp], eax

; 215  : }

  0001d	5d		 pop	 ebp

; 212  : 		index = atoi(temp1 + 4);

  0001e	e9 00 00 00 00	 jmp	 _atoi
$LN4@getStrPeti:

; 213  : 	}
; 214  : 	return index;

  00023	83 c8 ff	 or	 eax, -1

; 215  : }

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?getStrPetindex@@YAHPAD@Z ENDP				; getStrPetindex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp
;	COMDAT ?getStrPos@@YA_NPADPAU_CHAT_BUFFER@@@Z
_TEXT	SEGMENT
_chatbuffer$GSCopy$1$ = -32				; size = 4
_array$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_str$ = 8						; size = 4
_chatbuffer$ = 12					; size = 4
?getStrPos@@YA_NPADPAU_CHAT_BUFFER@@@Z PROC		; getStrPos, COMDAT

; 187  : bool getStrPos(char* str, CHAT_BUFFER *chatbuffer){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _chatbuffer$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _str$[ebp]
  00017	56		 push	 esi
  00018	57		 push	 edi

; 188  : 	//printf("\n%s",str);
; 189  : 	char *temp1 = sunday(str, "pos=");
; 190  : 	int len = lstrlen(str);

  00019	53		 push	 ebx
  0001a	89 45 e0	 mov	 DWORD PTR _chatbuffer$GSCopy$1$[ebp], eax
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  00023	8b f8		 mov	 edi, eax

; 191  : 	char *pbuf = new char[len + 1];

  00025	68 bf 00 00 00	 push	 191			; 000000bfH
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0FG@MOFDFNBM@C?3?2Users?2gg862?2OneDrive?2?$LJ?Y?E?A?5?H?$KN@
  0002f	6a 01		 push	 1
  00031	8d 77 01	 lea	 esi, DWORD PTR [edi+1]
  00034	56		 push	 esi
  00035	e8 00 00 00 00	 call	 ??_U@YAPAXIHPBDH@Z	; operator new[]

; 192  : 	memset(pbuf, 0, len + 1);

  0003a	56		 push	 esi
  0003b	8b f0		 mov	 esi, eax
  0003d	6a 00		 push	 0
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 _memset

; 193  : 	memcpy(pbuf, str, len);

  00045	57		 push	 edi
  00046	53		 push	 ebx
  00047	56		 push	 esi
  00048	e8 00 00 00 00	 call	 _memcpy

; 194  : 
; 195  : 	char* array[5];
; 196  : 	int count = split_damage(pbuf + 4, ',', (int*)array, 3);

  0004d	6a 03		 push	 3
  0004f	8d 45 e8	 lea	 eax, DWORD PTR _array$[ebp]
  00052	50		 push	 eax
  00053	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00056	6a 2c		 push	 44			; 0000002cH
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?split_damage@@YAHPADDPAHI@Z ; split_damage
  0005e	83 c4 38	 add	 esp, 56			; 00000038H

; 197  : 	if (count != 3){

  00061	83 f8 03	 cmp	 eax, 3
  00064	74 1c		 je	 SHORT $LN2@getStrPos

; 198  : 		delete[] pbuf;

  00066	56		 push	 esi
  00067	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0006c	83 c4 04	 add	 esp, 4

; 199  : 		return false;

  0006f	32 c0		 xor	 al, al
  00071	5f		 pop	 edi

; 205  : 	return true;
; 206  : }

  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00077	33 cd		 xor	 ecx, ebp
  00079	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
$LN2@getStrPos:

; 200  : 	}
; 201  : 	chatbuffer->map = atoi(array[0]+1);  //Ë∑≥Ëøá=Á¨¶Âè∑

  00082	8b 45 e8	 mov	 eax, DWORD PTR _array$[ebp]
  00085	40		 inc	 eax
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _atoi
  0008c	8b 5d e0	 mov	 ebx, DWORD PTR _chatbuffer$GSCopy$1$[ebp]

; 202  : 	chatbuffer->posx = atoi(array[1]);

  0008f	ff 75 ec	 push	 DWORD PTR _array$[ebp+4]
  00092	89 83 18 01 00
	00		 mov	 DWORD PTR [ebx+280], eax
  00098	e8 00 00 00 00	 call	 _atoi

; 203  : 	chatbuffer->posy = atoi(array[2]);

  0009d	ff 75 f0	 push	 DWORD PTR _array$[ebp+8]
  000a0	66 89 83 1c 01
	00 00		 mov	 WORD PTR [ebx+284], ax
  000a7	e8 00 00 00 00	 call	 _atoi

; 204  : 	delete[] pbuf;

  000ac	56		 push	 esi
  000ad	66 89 83 1e 01
	00 00		 mov	 WORD PTR [ebx+286], ax
  000b4	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 205  : 	return true;
; 206  : }

  000b9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000bc	83 c4 10	 add	 esp, 16			; 00000010H
  000bf	33 cd		 xor	 ecx, ebp
  000c1	b0 01		 mov	 al, 1
  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx
  000c6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
?getStrPos@@YA_NPADPAU_CHAT_BUFFER@@@Z ENDP		; getStrPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp
;	COMDAT ?getStrStr@@YAXPAD0@Z
_TEXT	SEGMENT
_strIn$ = 8						; size = 4
_strOut$ = 12						; size = 4
?getStrStr@@YAXPAD0@Z PROC				; getStrStr, COMDAT

; 179  : void getStrStr(char* strIn, char* strOut){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 180  : 	char *temp1 = sunday(strIn, "str=");

  00005	68 00 00 00 00	 push	 OFFSET ??_C@_04FOGPFBLG@str?$DN@
  0000a	ff 75 08	 push	 DWORD PTR _strIn$[ebp]
  0000d	e8 00 00 00 00	 call	 ?sunday@@YAPADPAD0@Z	; sunday
  00012	8b f0		 mov	 esi, eax

; 181  : 	char* temp2 = sunday(temp1, "}");

  00014	68 00 00 00 00	 push	 OFFSET ??_C@_01CELHOKLL@?$HN@
  00019	56		 push	 esi
  0001a	e8 00 00 00 00	 call	 ?sunday@@YAPADPAD0@Z	; sunday
  0001f	bf fc ff ff ff	 mov	 edi, -4			; fffffffcH

; 182  : 	int a = temp2 - temp1 - 4;
; 183  : 	memcpy(strOut, temp1+4,a);

  00024	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00027	2b fe		 sub	 edi, esi
  00029	8b 75 0c	 mov	 esi, DWORD PTR _strOut$[ebp]
  0002c	03 f8		 add	 edi, eax
  0002e	57		 push	 edi
  0002f	51		 push	 ecx
  00030	56		 push	 esi
  00031	e8 00 00 00 00	 call	 _memcpy
  00036	83 c4 1c	 add	 esp, 28			; 0000001cH

; 184  : 	strOut[a] = 0;

  00039	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi

; 185  : }

  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?getStrStr@@YAXPAD0@Z ENDP				; getStrStr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp
;	COMDAT ?getStrColor@@YAHPAD@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
?getStrColor@@YAHPAD@Z PROC				; getStrColor, COMDAT

; 169  : int getStrColor(char* str){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 	int color = -1;
; 171  : 	char *temp1 = sunday(str, "color=");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_06CDHFECOP@color?$DN@
  00008	ff 75 08	 push	 DWORD PTR _str$[ebp]
  0000b	e8 00 00 00 00	 call	 ?sunday@@YAPADPAD0@Z	; sunday
  00010	83 c4 08	 add	 esp, 8

; 172  : 	if (temp1){

  00013	85 c0		 test	 eax, eax
  00015	74 0c		 je	 SHORT $LN4@getStrColo

; 173  : 		color = atoi(temp1 + 6);

  00017	83 c0 06	 add	 eax, 6
  0001a	89 45 08	 mov	 DWORD PTR _str$[ebp], eax

; 177  : }

  0001d	5d		 pop	 ebp

; 173  : 		color = atoi(temp1 + 6);

  0001e	e9 00 00 00 00	 jmp	 _atoi
$LN4@getStrColo:

; 174  : 	}
; 175  : 
; 176  : 	return color;

  00023	83 c8 ff	 or	 eax, -1

; 177  : }

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?getStrColor@@YAHPAD@Z ENDP				; getStrColor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp
;	COMDAT ?getTextLength@@YAHPAD@Z
_TEXT	SEGMENT
_fontsize$ = -8						; size = 8
_str$ = 8						; size = 4
?getTextLength@@YAHPAD@Z PROC				; getTextLength, COMDAT

; 148  : int getTextLength(char * str){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 149  : 	SIZE fontsize;
; 150  : 	GetTextExtentPoint32(FontSizeHdc, (LPCSTR)str, strlen(str), (LPSIZE)&fontsize);

  00003	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	8b c2		 mov	 eax, edx
  0000b	56		 push	 esi
  0000c	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0000f	90		 npad	 1
$LL3@getTextLen:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL3@getTextLen
  00017	8d 4d f8	 lea	 ecx, DWORD PTR _fontsize$[ebp]
  0001a	2b c6		 sub	 eax, esi
  0001c	51		 push	 ecx
  0001d	50		 push	 eax
  0001e	52		 push	 edx
  0001f	ff 35 00 00 00
	00		 push	 DWORD PTR ?FontSizeHdc@@3PAUHDC__@@A ; FontSizeHdc
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTextExtentPoint32A@16

; 151  : 	return fontsize.cx;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _fontsize$[ebp]
  0002e	5e		 pop	 esi

; 152  : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?getTextLength@@YAHPAD@Z ENDP				; getTextLength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp
;	COMDAT ?CreatFontHdc@@YAXXZ
_TEXT	SEGMENT
_strfame$1 = -132					; size = 128
__$ArrayPad$ = -4					; size = 4
?CreatFontHdc@@YAXXZ PROC				; CreatFontHdc, COMDAT

; 106  : void CreatFontHdc(){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 107  : 	hScrDC = CreateDC("FontHdc", NULL, NULL, NULL);

  00013	6a 00		 push	 0
  00015	6a 00		 push	 0
  00017	6a 00		 push	 0
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_07GJNDNEJP@FontHdc@
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDCA@16

; 108  : 	FontSizeHdc = CreateCompatibleDC(hScrDC);

  00024	50		 push	 eax
  00025	a3 00 00 00 00	 mov	 DWORD PTR ?hScrDC@@3PAUHDC__@@A, eax ; hScrDC
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  00030	a3 00 00 00 00	 mov	 DWORD PTR ?FontSizeHdc@@3PAUHDC__@@A, eax ; FontSizeHdc

; 109  : 	if (FontSizeHdc) {

  00035	85 c0		 test	 eax, eax
  00037	0f 84 8d 00 00
	00		 je	 $LN2@CreatFontH

; 110  : #ifdef _NEWFONT_
; 111  : 		extern int ÁºñÁ†Å;
; 112  : 		char strfame[128];
; 113  : 		if (ÁºñÁ†Å == 950) {
; 114  : 			sprintf(strfame, "Microsoft JhengHei");
; 115  : 		}
; 116  : 		else {
; 117  : 			sprintf(strfame, "Microsoft JhengHei");
; 118  : 		}
; 119  : 		HFONT font = CreateFont(FONT_SIZE1, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, 1,
; 120  : 			0, 0, 0, 17, TEXT("Íµ¥Î¶ºÏ≤¥"));
; 121  : #else
; 122  : 		extern int ÁºñÁ†Å;
; 123  : 		char strfame[128];
; 124  : 		HFONT font;
; 125  : 		if (ÁºñÁ†Å == 950) {

  0003d	81 3d 00 00 00
	00 b6 03 00 00	 cmp	 DWORD PTR ???@@3HA, 950	; ??, 000003b6H
  00047	75 3b		 jne	 SHORT $LN4@CreatFontH

; 126  : 			sprintf(strfame, "Microsoft JhengHei");

  00049	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _strfame$1[ebp]
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@HLAEMJFN@Microsoft?5JhengHei@
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 _sprintf
  0005a	83 c4 08	 add	 esp, 8

; 127  : 			font = CreateFont(FONT_SIZE2, 0, 0, 0, FW_NORMAL, HANGUL_CHARSET, FALSE, FALSE, 1,

  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_06MFMMLLPC@?$LB?$LM?$LI?$LC?C?$LM@
  00062	6a 11		 push	 17			; 00000011H
  00064	6a 00		 push	 0
  00066	6a 00		 push	 0
  00068	6a 00		 push	 0
  0006a	6a 01		 push	 1
  0006c	6a 00		 push	 0
  0006e	6a 00		 push	 0
  00070	68 81 00 00 00	 push	 129			; 00000081H
  00075	68 90 01 00 00	 push	 400			; 00000190H
  0007a	6a 00		 push	 0
  0007c	6a 00		 push	 0
  0007e	6a 00		 push	 0
  00080	6a 13		 push	 19			; 00000013H

; 128  : 				0, 0, 0, 17, TEXT("Íµ¥Î¶ºÏ≤¥"));
; 129  : 		}

  00082	eb 25		 jmp	 SHORT $LN8@CreatFontH
$LN4@CreatFontH:

; 130  : 		else {
; 131  : #ifdef Âä†ËΩΩÊñ∞Â≠ó‰Ωì
; 132  : 			HFONT JL_FONT();
; 133  : 			font = JL_FONT();
; 134  : #else
; 135  : 			//font = CreateFont(FONT_SIZE1, 8, 0, 0, 200, FALSE, FALSE, FALSE, 134,OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_MODERN, (LPCTSTR)"Ê•∑‰Ωì");
; 136  : 			font = CreateFont(FONT_SIZE1, 0, 0, 0, 400, FALSE, FALSE, FALSE, HANGUL_CHARSET,OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, FIXED_PITCH | FF_ROMAN, TEXT("Íµ¥Î¶ºÏ≤¥"));

  00084	68 00 00 00 00	 push	 OFFSET ??_C@_06MFMMLLPC@?$LB?$LM?$LI?$LC?C?$LM@
  00089	6a 11		 push	 17			; 00000011H
  0008b	6a 00		 push	 0
  0008d	6a 00		 push	 0
  0008f	6a 00		 push	 0
  00091	68 81 00 00 00	 push	 129			; 00000081H
  00096	6a 00		 push	 0
  00098	6a 00		 push	 0
  0009a	6a 00		 push	 0
  0009c	68 90 01 00 00	 push	 400			; 00000190H
  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	6a 00		 push	 0
  000a7	6a 0e		 push	 14			; 0000000eH
$LN8@CreatFontH:

; 137  : #endif
; 138  : 		}
; 139  : 
; 140  : 
; 141  : #endif
; 142  : 		SelectObject(FontSizeHdc, font);

  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFontA@56
  000af	50		 push	 eax
  000b0	ff 35 00 00 00
	00		 push	 DWORD PTR ?FontSizeHdc@@3PAUHDC__@@A ; FontSizeHdc
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 146  : 	}
; 147  : }

  000bc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000bf	33 cd		 xor	 ecx, ebp
  000c1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c3		 ret	 0
$LN2@CreatFontH:

; 143  : 	}else {
; 144  : 		MessageBoxNew(NULL, "ÂàõÂª∫HDCÈîôËØØÔºÅ", "Ôº≥ÔΩîÔΩèÔΩéÔΩÖÔº°ÔΩáÔΩÖ", NULL);

  000ca	6a 00		 push	 0
  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@NLNMPB@?$KD?S?$KD?t?$KD?o?$KD?n?$KD?e?$KD?A?$KD?g?$KD?e@
  000d1	68 00 00 00 00	 push	 OFFSET ??_C@_0L@GONBBDGE@?$DP?K?oHDC?$DP?$DP?$KD?$KB@
  000d6	6a 00		 push	 0
  000d8	e8 00 00 00 00	 call	 ?MessageBoxNew@@YAHPAUHWND__@@PBD1I@Z ; MessageBoxNew
  000dd	83 c4 10	 add	 esp, 16			; 00000010H

; 145  : 		exit(0);

  000e0	6a 00		 push	 0
  000e2	e8 00 00 00 00	 call	 _exit
$LN7@CreatFontH:
  000e7	cc		 int	 3
?CreatFontHdc@@YAXXZ ENDP				; CreatFontHdc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp
;	COMDAT ?StockFontBuffer3@@YAHPAUSTR_BUFFER@@@Z
_TEXT	SEGMENT
_splitStr$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_strBuffer$ = 8						; size = 4
?StockFontBuffer3@@YAHPAUSTR_BUFFER@@@Z PROC		; StockFontBuffer3, COMDAT

; 560  : int StockFontBuffer3(STR_BUFFER *strBuffer){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _strBuffer$[ebp]

; 561  : 	int lineDist = 0; //Ë°åË∑ù
; 562  : 	int splitPoint = 0;
; 563  : 	int bakSplitPoint, cursor;
; 564  : 	BOOL SetCursor = FALSE;
; 565  : 	char splitStr[256];
; 566  : 
; 567  : 	cursor = strBuffer->cursor;
; 568  : 	//ÈúÄË¶ÅÂàÜË°åÊó∂
; 569  : 	while (strlen(strBuffer->buffer + splitPoint) >= (unsigned)strBuffer->lineLen - 1) {

  00018	8b ce		 mov	 ecx, esi
  0001a	57		 push	 edi
  0001b	0f b6 be 09 01
	00 00		 movzx	 edi, BYTE PTR [esi+265]
  00022	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL12@StockFontB:
  00025	8a 01		 mov	 al, BYTE PTR [ecx]
  00027	41		 inc	 ecx
  00028	84 c0		 test	 al, al
  0002a	75 f9		 jne	 SHORT $LL12@StockFontB
  0002c	0f b6 9e 05 01
	00 00		 movzx	 ebx, BYTE PTR [esi+261]
  00033	2b ca		 sub	 ecx, edx
  00035	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00038	3b c8		 cmp	 ecx, eax
  0003a	72 7f		 jb	 SHORT $LN3@StockFontB

; 570  : 		bakSplitPoint = splitPoint;
; 571  : 		strcpy(splitStr, strBuffer->buffer + splitPoint);  //‰∏Ä‰∏™Â≠ó

  0003c	8b ce		 mov	 ecx, esi
  0003e	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _splitStr$[ebp]
$LL7@StockFontB:
  00044	8a 01		 mov	 al, BYTE PTR [ecx]
  00046	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00049	88 02		 mov	 BYTE PTR [edx], al
  0004b	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  0004e	84 c0		 test	 al, al
  00050	75 f2		 jne	 SHORT $LL7@StockFontB

; 572  : 		*(splitStr + strBuffer->lineLen) = NULL;  //ÊåáÂêëÊúÄÂêé
; 573  : 		splitPoint = strBuffer->lineLen + splitPoint;
; 574  : 		StockFontBuffer(strBuffer->x, strBuffer->y, strBuffer->fontPrio, 0, splitStr, 0);

  00052	6a 00		 push	 0
  00054	88 84 1d fc fe
	ff ff		 mov	 BYTE PTR _splitStr$[ebp+ebx], al
  0005b	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _splitStr$[ebp]
  00061	50		 push	 eax
  00062	0f b6 86 1c 01
	00 00		 movzx	 eax, BYTE PTR [esi+284]
  00069	6a 00		 push	 0
  0006b	50		 push	 eax
  0006c	ff b6 10 01 00
	00		 push	 DWORD PTR [esi+272]
  00072	ff b6 0c 01 00
	00		 push	 DWORD PTR [esi+268]
  00078	e8 00 00 00 00	 call	 ?StockFontBuffer@@YAHHHDHPADH@Z ; StockFontBuffer
  0007d	83 c4 18	 add	 esp, 24			; 00000018H

; 575  : 
; 576  : 		if (cursor >= bakSplitPoint && cursor<splitPoint) {

  00080	3b fb		 cmp	 edi, ebx
  00082	73 21		 jae	 SHORT $LN4@StockFontB

; 577  : 			strBuffer->imeX = strBuffer->x + (cursor - bakSplitPoint)*(FONT_SIZE >> 1);

  00084	8d 04 fd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*8]
  0008b	2b c7		 sub	 eax, edi
  0008d	03 86 0c 01 00
	00		 add	 eax, DWORD PTR [esi+268]
  00093	89 86 14 01 00
	00		 mov	 DWORD PTR [esi+276], eax

; 578  : 			strBuffer->imeY = strBuffer->y + lineDist;

  00099	8b 86 10 01 00
	00		 mov	 eax, DWORD PTR [esi+272]
  0009f	89 86 18 01 00
	00		 mov	 DWORD PTR [esi+280], eax
$LN4@StockFontB:

; 589  : 	return 0;
; 590  : }

  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	b8 01 00 00 00	 mov	 eax, 1
  000ac	5b		 pop	 ebx
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b0	33 cd		 xor	 ecx, ebp
  000b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
$LN3@StockFontB:

; 579  : 			SetCursor = TRUE;
; 580  : 		}
; 581  : 		lineDist += strBuffer->lineDist;
; 582  : 		return 1;
; 583  : 	}
; 584  : 	if (!SetCursor) {  // Ê∏∏Ê†á‰∏çÈúÄÊç¢Ë°å
; 585  : 		strBuffer->imeX = strBuffer->x + (strBuffer->cursor - splitPoint)*(FONT_SIZE >> 1);

  000bb	8b 96 0c 01 00
	00		 mov	 edx, DWORD PTR [esi+268]
  000c1	8d 04 fd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*8]

; 586  : 		strBuffer->imeY = strBuffer->y + lineDist;

  000c8	8b 8e 10 01 00
	00		 mov	 ecx, DWORD PTR [esi+272]
  000ce	2b c7		 sub	 eax, edi

; 587  : 	}
; 588  : 	StockFontBuffer(strBuffer->x, strBuffer->y + lineDist, strBuffer->fontPrio, 0, strBuffer->buffer + splitPoint, 0);

  000d0	6a 00		 push	 0
  000d2	03 c2		 add	 eax, edx
  000d4	89 8e 18 01 00
	00		 mov	 DWORD PTR [esi+280], ecx
  000da	56		 push	 esi
  000db	89 86 14 01 00
	00		 mov	 DWORD PTR [esi+276], eax
  000e1	0f b6 86 1c 01
	00 00		 movzx	 eax, BYTE PTR [esi+284]
  000e8	6a 00		 push	 0
  000ea	50		 push	 eax
  000eb	51		 push	 ecx
  000ec	52		 push	 edx
  000ed	e8 00 00 00 00	 call	 ?StockFontBuffer@@YAHHHDHPADH@Z ; StockFontBuffer

; 589  : 	return 0;
; 590  : }

  000f2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f5	83 c4 18	 add	 esp, 24			; 00000018H
  000f8	33 cd		 xor	 ecx, ebp
  000fa	33 c0		 xor	 eax, eax
  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
?StockFontBuffer3@@YAHPAUSTR_BUFFER@@@Z ENDP		; StockFontBuffer3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp
;	COMDAT ?StockFontBuffer2@@YAXPAUSTR_BUFFER@@@Z
_TEXT	SEGMENT
tv639 = -276						; size = 4
_cursor$1$ = -272					; size = 4
_SetCursor$1$ = -268					; size = 4
tv609 = -264						; size = 4
_bakSplitPoint$1$ = -264				; size = 4
_splitStr$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_strBuffer$ = 8						; size = 4
?StockFontBuffer2@@YAXPAUSTR_BUFFER@@@Z PROC		; StockFontBuffer2, COMDAT

; 461  : void StockFontBuffer2(STR_BUFFER *strBuffer){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx

; 462  : 	int lineDist = 0; //Ë°åË∑ù
; 463  : 	int splitPoint = 0;
; 464  : 	int bakSplitPoint, cursor;
; 465  : 	BOOL SetCursor = FALSE;

  00014	33 c0		 xor	 eax, eax
  00016	33 db		 xor	 ebx, ebx
  00018	56		 push	 esi
  00019	8b 75 08	 mov	 esi, DWORD PTR _strBuffer$[ebp]
  0001c	57		 push	 edi
  0001d	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _SetCursor$1$[ebp], eax
  00023	33 ff		 xor	 edi, edi

; 466  : 	char splitStr[256];
; 467  : 	if (FontCnt >= FONT_BUFFER_SIZE) {

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ?FontCnt@@3HA ; FontCnt
  0002a	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  0002f	7c 1b		 jl	 SHORT $LN7@StockFontB

; 468  : 		strBuffer->hitFontNo = -2;

  00031	5f		 pop	 edi
  00032	c7 86 24 01 00
	00 fe ff ff ff	 mov	 DWORD PTR [esi+292], -2	; fffffffeH

; 556  : 		strBuffer->hitFontNo = FontCnt++;
; 557  : 		}
; 558  : 	}

  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00041	33 cd		 xor	 ecx, ebp
  00043	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
$LN7@StockFontB:

; 469  : 		return;
; 470  : 	}
; 471  : 	//ÈúÄË¶ÅÂàÜË°åÊó∂
; 472  : 	if (strBuffer->lineLen != 0) {

  0004c	8a 96 05 01 00
	00		 mov	 dl, BYTE PTR [esi+261]
  00052	84 d2		 test	 dl, dl
  00054	0f 84 a4 01 00
	00		 je	 $LN8@StockFontB

; 473  : 		cursor = strBuffer->cursor;

  0005a	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]

; 474  : 		while (strlen(strBuffer->buffer + splitPoint) >= strBuffer->lineLen) {

  00061	8b ce		 mov	 ecx, esi
  00063	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _cursor$1$[ebp], eax
  00069	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0006c	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv609[ebp], eax
$LL39@StockFontB:
  00072	8a 01		 mov	 al, BYTE PTR [ecx]
  00074	41		 inc	 ecx
  00075	84 c0		 test	 al, al
  00077	75 f9		 jne	 SHORT $LL39@StockFontB
  00079	2b 8d f8 fe ff
	ff		 sub	 ecx, DWORD PTR tv609[ebp]
  0007f	0f b6 c2	 movzx	 eax, dl
  00082	3b c8		 cmp	 ecx, eax
  00084	0f 82 17 01 00
	00		 jb	 $LN38@StockFontB
  0008a	66 0f 1f 44 00
	00		 npad	 6
$LL2@StockFontB:

; 477  : 			strncpy_s(splitStr, strBuffer->buffer + splitPoint, strBuffer->lineLen);

  00090	0f b6 c2	 movzx	 eax, dl
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h

; 331  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(

  00093	50		 push	 eax
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp

; 477  : 			strncpy_s(splitStr, strBuffer->buffer + splitPoint, strBuffer->lineLen);

  00094	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  00097	89 bd ec fe ff
	ff		 mov	 DWORD PTR tv639[ebp], edi
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h

; 331  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(

  0009d	50		 push	 eax
  0009e	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _splitStr$[ebp]
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp

; 475  : 			bakSplitPoint = splitPoint;

  000a4	89 bd f8 fe ff
	ff		 mov	 DWORD PTR _bakSplitPoint$1$[ebp], edi
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h

; 331  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(

  000aa	68 00 01 00 00	 push	 256			; 00000100H
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 _strncpy_s
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp

; 478  : 			*(splitStr + strBuffer->lineLen) = NULL;

  000b5	0f b6 86 05 01
	00 00		 movzx	 eax, BYTE PTR [esi+261]
  000bc	c6 84 05 fc fe
	ff ff 00	 mov	 BYTE PTR _splitStr$[ebp+eax], 0

; 479  : 			if (GetStrLastByte(splitStr) == 3) {

  000c4	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _splitStr$[ebp]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ?GetStrLastByte@@YAHPAD@Z ; GetStrLastByte
  000d0	8a 8e 05 01 00
	00		 mov	 cl, BYTE PTR [esi+261]
  000d6	83 c4 14	 add	 esp, 20			; 00000014H
  000d9	83 f8 03	 cmp	 eax, 3
  000dc	0f b6 c1	 movzx	 eax, cl
  000df	75 09		 jne	 SHORT $LN10@StockFontB

; 480  : 				//ÂàÜÂâ≤Âà∞‰∏≠DBCSÊó∂ÔºåÈÄÄÂõû‰∏Ä‰∏™byte
; 481  : 				splitPoint = strBuffer->lineLen - 1 + splitPoint;

  000e1	4f		 dec	 edi

; 482  : 				*(splitStr + strBuffer->lineLen - 1) = NULL;

  000e2	c6 84 05 fb fe
	ff ff 00	 mov	 BYTE PTR _splitStr$[ebp+eax-1], 0
$LN10@StockFontB:

; 483  : 			}
; 484  : 			else
; 485  : 				splitPoint = strBuffer->lineLen + splitPoint;
; 486  : 			StockFontBuffer(strBuffer->x, strBuffer->y + lineDist, strBuffer->fontPrio, 0, splitStr, 0);

  000ea	03 f8		 add	 edi, eax
  000ec	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _splitStr$[ebp]
  000f2	6a 00		 push	 0
  000f4	50		 push	 eax
  000f5	0f b6 86 1c 01
	00 00		 movzx	 eax, BYTE PTR [esi+284]
  000fc	6a 00		 push	 0
  000fe	50		 push	 eax
  000ff	8b 86 10 01 00
	00		 mov	 eax, DWORD PTR [esi+272]
  00105	03 c3		 add	 eax, ebx
  00107	50		 push	 eax
  00108	ff b6 0c 01 00
	00		 push	 DWORD PTR [esi+268]
  0010e	e8 00 00 00 00	 call	 ?StockFontBuffer@@YAHHHDHPADH@Z ; StockFontBuffer

; 487  : 			if (cursor >= bakSplitPoint && cursor<splitPoint) {

  00113	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _cursor$1$[ebp]
  00119	83 c4 18	 add	 esp, 24			; 00000018H
  0011c	3b 85 f8 fe ff
	ff		 cmp	 eax, DWORD PTR _bakSplitPoint$1$[ebp]
  00122	7c 39		 jl	 SHORT $LN12@StockFontB
  00124	3b c7		 cmp	 eax, edi
  00126	7d 35		 jge	 SHORT $LN12@StockFontB

; 488  : 				strBuffer->imeX = strBuffer->x + (cursor - bakSplitPoint)*(FONT_SIZE >> 1);

  00128	8b c8		 mov	 ecx, eax

; 489  : 				strBuffer->imeY = strBuffer->y + lineDist;
; 490  : 				SetCursor = TRUE;

  0012a	c7 85 f4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _SetCursor$1$[ebp], 1
  00134	2b 8d ec fe ff
	ff		 sub	 ecx, DWORD PTR tv639[ebp]
  0013a	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  00141	2b c1		 sub	 eax, ecx
  00143	03 86 0c 01 00
	00		 add	 eax, DWORD PTR [esi+268]
  00149	89 86 14 01 00
	00		 mov	 DWORD PTR [esi+276], eax
  0014f	8b 86 10 01 00
	00		 mov	 eax, DWORD PTR [esi+272]
  00155	03 c3		 add	 eax, ebx
  00157	89 86 18 01 00
	00		 mov	 DWORD PTR [esi+280], eax
$LN12@StockFontB:

; 491  : 			}
; 492  : 			lineDist += strBuffer->lineDist;

  0015d	0f b6 86 06 01
	00 00		 movzx	 eax, BYTE PTR [esi+262]
  00164	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]
  00167	03 d8		 add	 ebx, eax
  00169	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0016c	0f 1f 40 00	 npad	 4
$LL40@StockFontB:

; 474  : 		while (strlen(strBuffer->buffer + splitPoint) >= strBuffer->lineLen) {

  00170	8a 01		 mov	 al, BYTE PTR [ecx]
  00172	41		 inc	 ecx
  00173	84 c0		 test	 al, al
  00175	75 f9		 jne	 SHORT $LL40@StockFontB
  00177	2b ca		 sub	 ecx, edx
  00179	8a 96 05 01 00
	00		 mov	 dl, BYTE PTR [esi+261]
  0017f	0f b6 c2	 movzx	 eax, dl
  00182	3b c8		 cmp	 ecx, eax
  00184	0f 83 06 ff ff
	ff		 jae	 $LL2@StockFontB

; 493  : 		}
; 494  : 		if (!SetCursor) {

  0018a	83 bd f4 fe ff
	ff 00		 cmp	 DWORD PTR _SetCursor$1$[ebp], 0
  00191	74 0e		 je	 SHORT $LN38@StockFontB

; 496  : 			strBuffer->imeY = strBuffer->y + lineDist;

  00193	8b 8e 10 01 00
	00		 mov	 ecx, DWORD PTR [esi+272]
  00199	8b 96 0c 01 00
	00		 mov	 edx, DWORD PTR [esi+268]
  0019f	eb 2f		 jmp	 SHORT $LN13@StockFontB
$LN38@StockFontB:

; 495  : 			strBuffer->imeX = strBuffer->x + (strBuffer->cursor - splitPoint)*(FONT_SIZE >> 1);

  001a1	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  001a8	8b 96 0c 01 00
	00		 mov	 edx, DWORD PTR [esi+268]
  001ae	2b cf		 sub	 ecx, edi
  001b0	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  001b7	2b c1		 sub	 eax, ecx

; 496  : 			strBuffer->imeY = strBuffer->y + lineDist;

  001b9	8b 8e 10 01 00
	00		 mov	 ecx, DWORD PTR [esi+272]
  001bf	03 c2		 add	 eax, edx
  001c1	89 86 14 01 00
	00		 mov	 DWORD PTR [esi+276], eax
  001c7	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  001ca	89 86 18 01 00
	00		 mov	 DWORD PTR [esi+280], eax
$LN13@StockFontB:

; 497  : 		}
; 498  : 		StockFontBuffer(strBuffer->x, strBuffer->y + lineDist, strBuffer->fontPrio, 0, strBuffer->buffer + splitPoint, 0);

  001d0	6a 00		 push	 0
  001d2	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  001d5	50		 push	 eax
  001d6	0f b6 86 1c 01
	00 00		 movzx	 eax, BYTE PTR [esi+284]
  001dd	6a 00		 push	 0
  001df	50		 push	 eax
  001e0	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  001e3	50		 push	 eax
  001e4	52		 push	 edx
  001e5	e8 00 00 00 00	 call	 ?StockFontBuffer@@YAHHHDHPADH@Z ; StockFontBuffer
  001ea	83 c4 18	 add	 esp, 24			; 00000018H
  001ed	5f		 pop	 edi

; 556  : 		strBuffer->hitFontNo = FontCnt++;
; 557  : 		}
; 558  : 	}

  001ee	5e		 pop	 esi
  001ef	5b		 pop	 ebx
  001f0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f3	33 cd		 xor	 ecx, ebp
  001f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001fa	8b e5		 mov	 esp, ebp
  001fc	5d		 pop	 ebp
  001fd	c3		 ret	 0
$LN8@StockFontB:

; 499  : 	}else {
; 500  : 		FontBuffer[FontCnt].x = strBuffer->x;

  001fe	69 f8 10 01 00
	00		 imul	 edi, eax, 272
  00204	0f b7 86 0c 01
	00 00		 movzx	 eax, WORD PTR [esi+268]
  0020b	66 89 87 00 00
	00 00		 mov	 WORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[edi], ax

; 501  : 		FontBuffer[FontCnt].y = strBuffer->y;

  00212	0f b7 86 10 01
	00 00		 movzx	 eax, WORD PTR [esi+272]
  00219	66 89 87 02 00
	00 00		 mov	 WORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[edi+2], ax

; 502  : 		FontBuffer[FontCnt].fontPrio = strBuffer->fontPrio;

  00220	0f b6 86 1c 01
	00 00		 movzx	 eax, BYTE PTR [esi+284]
  00227	88 87 05 01 00
	00		 mov	 BYTE PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[edi+261], al

; 503  : 		FontBuffer[FontCnt].color = strBuffer->color;

  0022d	0f b6 86 08 01
	00 00		 movzx	 eax, BYTE PTR [esi+264]
  00234	88 87 04 00 00
	00		 mov	 BYTE PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[edi+4], al

; 504  : 		FontBuffer[FontCnt].hitFlag = 0;

  0023a	89 9f 08 01 00
	00		 mov	 DWORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[edi+264], ebx

; 505  : #ifdef _FONT_SIZE
; 506  : 		FontBuffer[FontCnt].size = 0;

  00240	89 9f 0c 01 00
	00		 mov	 DWORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[edi+268], ebx

; 507  : #endif
; 508  : 		//ÂÆö‰πâHook_typeÁî®Êù•Â§ÑÁêÜÊòüÂè∑‰∫ßÁîü
; 509  : #ifdef _SAHOOK //Syu ADD HookÁ®ãÂºè
; 510  : 		if (strBuffer->filterFlag == HOOK_TYPE) {
; 511  : 			extern int HOOK_PASSWD_NUM;
; 512  : 			for (int i = 0; i < HOOK_PASSWD_NUM; i++)
; 513  : 				FontBuffer[FontCnt].str[i] = '*';
; 514  : 			FontBuffer[FontCnt].str[i] = NULL;
; 515  : 			strBuffer->cursor = HOOK_PASSWD_NUM;
; 516  : 		}
; 517  : 		else if (strBuffer->filterFlag == BLIND_TYPE) {
; 518  : #else
; 519  : 		if (strBuffer->filterFlag == BLIND_TYPE) {

  00246	83 be 20 01 00
	00 01		 cmp	 DWORD PTR [esi+288], 1
  0024d	75 2c		 jne	 SHORT $LN14@StockFontB

; 520  : #endif
; 521  : 			int i;
; 522  : 			for (i = 0; i < strBuffer->cnt; i++)

  0024f	33 c9		 xor	 ecx, ecx
  00251	38 8e 07 01 00
	00		 cmp	 BYTE PTR [esi+263], cl
  00257	76 19		 jbe	 SHORT $LN5@StockFontB
  00259	8d 97 05 00 00
	00		 lea	 edx, DWORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[edi+5]
  0025f	90		 npad	 1
$LL6@StockFontB:

; 523  : 				FontBuffer[FontCnt].str[i] = '*';

  00260	c6 02 2a	 mov	 BYTE PTR [edx], 42	; 0000002aH
  00263	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00266	0f b6 86 07 01
	00 00		 movzx	 eax, BYTE PTR [esi+263]
  0026d	41		 inc	 ecx
  0026e	3b c8		 cmp	 ecx, eax
  00270	7c ee		 jl	 SHORT $LL6@StockFontB
$LN5@StockFontB:

; 524  : 			FontBuffer[FontCnt].str[i] = NULL;

  00272	88 9c 0f 05 00
	00 00		 mov	 BYTE PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[edi+ecx+5], bl

; 525  : 		}else {

  00279	eb 55		 jmp	 SHORT $LN17@StockFontB
$LN14@StockFontB:

; 526  : 			extern int ÁºñÁ†Å;
; 527  : 			if (ÁºñÁ†Å == 950) {

  0027b	81 3d 00 00 00
	00 b6 03 00 00	 cmp	 DWORD PTR ???@@3HA, 950	; ??, 000003b6H
  00285	75 2a		 jne	 SHORT $LN16@StockFontB

; 528  : 				extern char* GB2312ToBIG5(const char* szBIG5String);
; 529  : 				strcpy(FontBuffer[FontCnt].str, GB2312ToBIG5((const char *)strBuffer->buffer));

  00287	56		 push	 esi
  00288	e8 00 00 00 00	 call	 ?GB2312ToBIG5@@YAPADPBD@Z ; GB2312ToBIG5
  0028d	69 0d 00 00 00
	00 10 01 00 00	 imul	 ecx, DWORD PTR ?FontCnt@@3HA, 272 ; FontCnt
  00297	83 c4 04	 add	 esp, 4
  0029a	2b c8		 sub	 ecx, eax
  0029c	8d 91 05 00 00
	00		 lea	 edx, DWORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[ecx+5]
$LL19@StockFontB:
  002a2	8a 08		 mov	 cl, BYTE PTR [eax]
  002a4	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  002a7	88 4c 02 ff	 mov	 BYTE PTR [edx+eax-1], cl
  002ab	84 c9		 test	 cl, cl
  002ad	75 f3		 jne	 SHORT $LL19@StockFontB

; 530  : 			}

  002af	eb 1f		 jmp	 SHORT $LN17@StockFontB
$LN16@StockFontB:

; 531  : 			else
; 532  : 				strcpy(FontBuffer[FontCnt].str, strBuffer->buffer);

  002b1	8b ce		 mov	 ecx, esi
  002b3	2b fe		 sub	 edi, esi
  002b5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL20@StockFontB:
  002c0	8a 01		 mov	 al, BYTE PTR [ecx]
  002c2	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  002c5	88 84 0f 04 00
	00 00		 mov	 BYTE PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[edi+ecx+4], al
  002cc	84 c0		 test	 al, al
  002ce	75 f0		 jne	 SHORT $LL20@StockFontB
$LN17@StockFontB:

; 533  : 		}
; 534  : #ifdef _NEWFONT_
; 535  : 		char strtemp[512];
; 536  : 		char *ptempstr;
; 537  : 		if (strBuffer->filterFlag == BLIND_TYPE) {
; 538  : 			ptempstr = FontBuffer[FontCnt].str;
; 539  : 		}
; 540  : 		else {
; 541  : 			ptempstr = strBuffer->buffer;
; 542  : 		}
; 543  : 		if (strBuffer->cursor == 0) {
; 544  : 			strBuffer->imeX = strBuffer->x;
; 545  : 		}
; 546  : 		else {
; 547  : 			memcpy(strtemp, ptempstr, strBuffer->cursor);
; 548  : 			strtemp[strBuffer->cursor] = 0;
; 549  : 			strBuffer->imeX = strBuffer->x + GetStrWidth(strtemp);
; 550  : 
; 551  : 		}
; 552  : #else
; 553  : 		strBuffer->imeX = strBuffer->x + strBuffer->cursor*(FONT_SIZE >> 1);

  002d0	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  002d7	5f		 pop	 edi
  002d8	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  002df	2b c8		 sub	 ecx, eax

; 554  : #endif
; 555  : 		strBuffer->imeY = strBuffer->y;

  002e1	8b 86 10 01 00
	00		 mov	 eax, DWORD PTR [esi+272]
  002e7	03 8e 0c 01 00
	00		 add	 ecx, DWORD PTR [esi+268]
  002ed	89 8e 14 01 00
	00		 mov	 DWORD PTR [esi+276], ecx

; 556  : 		strBuffer->hitFontNo = FontCnt++;
; 557  : 		}
; 558  : 	}

  002f3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002f6	89 86 18 01 00
	00		 mov	 DWORD PTR [esi+280], eax
  002fc	33 cd		 xor	 ecx, ebp
  002fe	a1 00 00 00 00	 mov	 eax, DWORD PTR ?FontCnt@@3HA ; FontCnt
  00303	89 86 24 01 00
	00		 mov	 DWORD PTR [esi+292], eax
  00309	ff 05 00 00 00
	00		 inc	 DWORD PTR ?FontCnt@@3HA	; FontCnt
  0030f	5e		 pop	 esi
  00310	5b		 pop	 ebx
  00311	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00316	8b e5		 mov	 esp, ebp
  00318	5d		 pop	 ebp
  00319	c3		 ret	 0
?StockFontBuffer2@@YAXPAUSTR_BUFFER@@@Z ENDP		; StockFontBuffer2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp
;	COMDAT ?StockFontBufferExt@@YAHHHDHPADHH@Z
_TEXT	SEGMENT
_€Â?$1 = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_fontPrio$ = 16						; size = 1
_color$ = 20						; size = 4
_str$ = 24						; size = 4
_hitFlag$ = 28						; size = 4
_size$ = 32						; size = 4
?StockFontBufferExt@@YAHHHDHPADHH@Z PROC		; StockFontBufferExt, COMDAT

; 48   : int StockFontBufferExt(int x, int y, char fontPrio, int color, char *str, BOOL hitFlag, int size){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 04 00
	00		 sub	 esp, 1028		; 00000404H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 18	 mov	 esi, DWORD PTR _str$[ebp]
  00017	57		 push	 edi

; 49   : 	if (FontCnt >= FONT_BUFFER_SIZE) return -2;

  00018	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?FontCnt@@3HA ; FontCnt
  0001e	81 ff 00 04 00
	00		 cmp	 edi, 1024		; 00000400H
  00024	7c 15		 jl	 SHORT $LN2@StockFontB
  00026	5f		 pop	 edi
  00027	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 76   : }

  0002c	5e		 pop	 esi
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00030	33 cd		 xor	 ecx, ebp
  00032	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
$LN2@StockFontB:

; 50   : 	FontBuffer[FontCnt].x = x;

  0003b	66 8b 45 08	 mov	 ax, WORD PTR _x$[ebp]
  0003f	69 d7 10 01 00
	00		 imul	 edx, edi, 272

; 51   : 	FontBuffer[FontCnt].y = y;
; 52   : 	FontBuffer[FontCnt].fontPrio = fontPrio;
; 53   : 	FontBuffer[FontCnt].color = color;
; 54   : 	FontBuffer[FontCnt].hitFlag = hitFlag;
; 55   : 	extern int ÁºñÁ†Å;
; 56   : 	extern int ÁπÅ‰ΩìÂºÄÂÖ≥;
; 57   : 	if (ÁπÅ‰ΩìÂºÄÂÖ≥) {

  00045	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?€Â???@@3HA, 0 ; €Â???
  0004c	66 89 82 00 00
	00 00		 mov	 WORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[edx], ax
  00053	66 8b 45 0c	 mov	 ax, WORD PTR _y$[ebp]
  00057	66 89 82 02 00
	00 00		 mov	 WORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[edx+2], ax
  0005e	8a 45 10	 mov	 al, BYTE PTR _fontPrio$[ebp]
  00061	88 82 05 01 00
	00		 mov	 BYTE PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[edx+261], al
  00067	8a 45 14	 mov	 al, BYTE PTR _color$[ebp]
  0006a	88 82 04 00 00
	00		 mov	 BYTE PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[edx+4], al
  00070	8b 45 1c	 mov	 eax, DWORD PTR _hitFlag$[ebp]
  00073	89 82 08 01 00
	00		 mov	 DWORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[edx+264], eax
  00079	0f 84 c0 00 00
	00		 je	 $LN3@StockFontB

; 58   : 		char ÁπÅ‰Ωì[1024] = { 0 };

  0007f	68 00 04 00 00	 push	 1024			; 00000400H
  00084	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _€Â?$1[ebp]
  0008a	6a 00		 push	 0
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _memset

; 59   : 		LCMapString(0x804, 0x4000000, str, strlen(str), ÁπÅ‰Ωì, 1024);

  00092	8b ce		 mov	 ecx, esi
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH
  00097	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0009a	66 0f 1f 44 00
	00		 npad	 6
$LL26@StockFontB:
  000a0	8a 01		 mov	 al, BYTE PTR [ecx]
  000a2	41		 inc	 ecx
  000a3	84 c0		 test	 al, al
  000a5	75 f9		 jne	 SHORT $LL26@StockFontB
  000a7	68 00 04 00 00	 push	 1024			; 00000400H
  000ac	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _€Â?$1[ebp]
  000b2	2b ca		 sub	 ecx, edx
  000b4	50		 push	 eax
  000b5	51		 push	 ecx
  000b6	56		 push	 esi
  000b7	68 00 00 00 04	 push	 67108864		; 04000000H
  000bc	68 04 08 00 00	 push	 2052			; 00000804H
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LCMapStringA@24

; 60   : 		if (ÁºñÁ†Å == 950) {

  000c7	81 3d 00 00 00
	00 b6 03 00 00	 cmp	 DWORD PTR ???@@3HA, 950	; ??, 000003b6H
  000d1	75 3f		 jne	 SHORT $LN5@StockFontB

; 61   : 			extern char* GB2312ToBIG5(const char* szBIG5String);
; 62   : 			strcpy(FontBuffer[FontCnt].str, GB2312ToBIG5((const char *)ÁπÅ‰Ωì));

  000d3	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _€Â?$1[ebp]
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 ?GB2312ToBIG5@@YAPADPBD@Z ; GB2312ToBIG5
  000df	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?FontCnt@@3HA ; FontCnt
  000e5	8b c8		 mov	 ecx, eax
  000e7	69 d7 10 01 00
	00		 imul	 edx, edi, 272
  000ed	83 c4 04	 add	 esp, 4
  000f0	8b c2		 mov	 eax, edx
  000f2	2b c1		 sub	 eax, ecx
  000f4	8d b0 05 00 00
	00		 lea	 esi, DWORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[eax+5]
  000fa	66 0f 1f 44 00
	00		 npad	 6
$LL10@StockFontB:
  00100	8a 01		 mov	 al, BYTE PTR [ecx]
  00102	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00105	88 44 0e ff	 mov	 BYTE PTR [esi+ecx-1], al
  00109	84 c0		 test	 al, al
  0010b	75 f3		 jne	 SHORT $LL10@StockFontB

; 63   : 		}

  0010d	e9 8b 00 00 00	 jmp	 $LN8@StockFontB
$LN5@StockFontB:

; 64   : 		else
; 65   : 			strcpy(FontBuffer[FontCnt].str, ÁπÅ‰Ωì);

  00112	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?FontCnt@@3HA ; FontCnt
  00118	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _€Â?$1[ebp]
  0011e	69 d7 10 01 00
	00		 imul	 edx, edi, 272
  00124	8b f1		 mov	 esi, ecx
  00126	8b c2		 mov	 eax, edx
  00128	2b c6		 sub	 eax, esi
  0012a	8d b0 05 00 00
	00		 lea	 esi, DWORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[eax+5]
$LL11@StockFontB:
  00130	8a 01		 mov	 al, BYTE PTR [ecx]
  00132	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00135	88 44 0e ff	 mov	 BYTE PTR [esi+ecx-1], al
  00139	84 c0		 test	 al, al
  0013b	75 f3		 jne	 SHORT $LL11@StockFontB

; 66   : 	}else {

  0013d	eb 5e		 jmp	 SHORT $LN8@StockFontB
$LN3@StockFontB:

; 67   : 		if (ÁºñÁ†Å == 950) {

  0013f	81 3d 00 00 00
	00 b6 03 00 00	 cmp	 DWORD PTR ???@@3HA, 950	; ??, 000003b6H
  00149	75 34		 jne	 SHORT $LN7@StockFontB

; 68   : 			extern char* GB2312ToBIG5(const char* szBIG5String);
; 69   : 			strcpy(FontBuffer[FontCnt].str, GB2312ToBIG5((const char *)str));

  0014b	56		 push	 esi
  0014c	e8 00 00 00 00	 call	 ?GB2312ToBIG5@@YAPADPBD@Z ; GB2312ToBIG5
  00151	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?FontCnt@@3HA ; FontCnt
  00157	8b c8		 mov	 ecx, eax
  00159	69 d7 10 01 00
	00		 imul	 edx, edi, 272
  0015f	83 c4 04	 add	 esp, 4
  00162	8b c2		 mov	 eax, edx
  00164	2b c1		 sub	 eax, ecx
  00166	8d b0 05 00 00
	00		 lea	 esi, DWORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[eax+5]
  0016c	0f 1f 40 00	 npad	 4
$LL12@StockFontB:
  00170	8a 01		 mov	 al, BYTE PTR [ecx]
  00172	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00175	88 44 0e ff	 mov	 BYTE PTR [esi+ecx-1], al
  00179	84 c0		 test	 al, al
  0017b	75 f3		 jne	 SHORT $LL12@StockFontB

; 70   : 		}

  0017d	eb 1e		 jmp	 SHORT $LN8@StockFontB
$LN7@StockFontB:

; 71   : 		else
; 72   : 			strcpy(FontBuffer[FontCnt].str, str);

  0017f	8b c2		 mov	 eax, edx
  00181	2b c6		 sub	 eax, esi
  00183	8d 88 05 00 00
	00		 lea	 ecx, DWORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[eax+5]
  00189	0f 1f 80 00 00
	00 00		 npad	 7
$LL13@StockFontB:
  00190	8a 06		 mov	 al, BYTE PTR [esi]
  00192	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  00195	88 44 31 ff	 mov	 BYTE PTR [ecx+esi-1], al
  00199	84 c0		 test	 al, al
  0019b	75 f3		 jne	 SHORT $LL13@StockFontB
$LN8@StockFontB:

; 73   : 	}
; 74   : 	FontBuffer[FontCnt].size = size;

  0019d	8b 4d 20	 mov	 ecx, DWORD PTR _size$[ebp]

; 75   : 	return FontCnt++;

  001a0	8b c7		 mov	 eax, edi
  001a2	89 8a 0c 01 00
	00		 mov	 DWORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[edx+268], ecx
  001a8	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  001ab	89 0d 00 00 00
	00		 mov	 DWORD PTR ?FontCnt@@3HA, ecx ; FontCnt

; 76   : }

  001b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b4	5f		 pop	 edi
  001b5	33 cd		 xor	 ecx, ebp
  001b7	5e		 pop	 esi
  001b8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001bd	8b e5		 mov	 esp, ebp
  001bf	5d		 pop	 ebp
  001c0	c3		 ret	 0
?StockFontBufferExt@@YAHHHDHPADHH@Z ENDP		; StockFontBufferExt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp
;	COMDAT ?StockFontBuffer@@YAHHHDHPADH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_fontPrio$ = 16						; size = 1
_color$ = 20						; size = 4
_str$ = 24						; size = 4
_hitFlag$ = 28						; size = 4
?StockFontBuffer@@YAHHHDHPADH@Z PROC			; StockFontBuffer, COMDAT

; 78   : int StockFontBuffer(int x, int y, char fontPrio, int color, char *str, BOOL hitFlag){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return StockFontBufferExt(x, y, fontPrio, color, str, hitFlag, 0);

  00003	6a 00		 push	 0
  00005	ff 75 1c	 push	 DWORD PTR _hitFlag$[ebp]
  00008	ff 75 18	 push	 DWORD PTR _str$[ebp]
  0000b	ff 75 14	 push	 DWORD PTR _color$[ebp]
  0000e	ff 75 10	 push	 DWORD PTR _fontPrio$[ebp]
  00011	ff 75 0c	 push	 DWORD PTR _y$[ebp]
  00014	ff 75 08	 push	 DWORD PTR _x$[ebp]
  00017	e8 00 00 00 00	 call	 ?StockFontBufferExt@@YAHHHDHPADHH@Z ; StockFontBufferExt
  0001c	83 c4 1c	 add	 esp, 28			; 0000001cH

; 80   : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?StockFontBuffer@@YAHHHDHPADH@Z ENDP			; StockFontBuffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp
;	COMDAT ?delFontBuffer@@YAXPAU_CHAT_BUFFER@@@Z
_TEXT	SEGMENT
_chatbuffer$ = 8					; size = 4
?delFontBuffer@@YAXPAU_CHAT_BUFFER@@@Z PROC		; delFontBuffer, COMDAT

; 156  : void delFontBuffer(CHAT_BUFFER *chatbuffer){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 157  : 
; 158  : 	CHAT_BUFFER *pNextBuffer = chatbuffer->NextChatBuffer;

  00005	8b 7d 08	 mov	 edi, DWORD PTR _chatbuffer$[ebp]
  00008	8b b7 14 01 00
	00		 mov	 esi, DWORD PTR [edi+276]

; 159  : 	while (pNextBuffer){//Â¶ÇÊûúÈìæ‰∏≠ËøòÂ≠òÂú®ÁªìÁÇπ

  0000e	85 f6		 test	 esi, esi
  00010	74 13		 je	 SHORT $LN9@delFontBuf
$LL2@delFontBuf:

; 160  : 		CHAT_BUFFER* pTemp;
; 161  : 		pTemp = pNextBuffer;
; 162  : 		pNextBuffer = pNextBuffer->NextChatBuffer;
; 163  : 		free(pTemp);

  00012	56		 push	 esi
  00013	8b b6 14 01 00
	00		 mov	 esi, DWORD PTR [esi+276]
  00019	e8 00 00 00 00	 call	 _free
  0001e	83 c4 04	 add	 esp, 4
  00021	85 f6		 test	 esi, esi
  00023	75 ed		 jne	 SHORT $LL2@delFontBuf
$LN9@delFontBuf:

; 164  : 		pTemp = NULL;
; 165  : 	}
; 166  : 	chatbuffer->NextChatBuffer = NULL;
; 167  : }

  00025	c7 87 14 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+276], 0
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?delFontBuffer@@YAXPAU_CHAT_BUFFER@@@Z ENDP		; delFontBuffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp
;	COMDAT ?NewStockFontBuffer@@YAXPAU_CHAT_BUFFER@@HEPADHH@Z
_TEXT	SEGMENT
_chatbuffer$ = 8					; size = 4
_x$ = 12						; size = 4
_color$ = 16						; size = 1
_str$ = 20						; size = 4
_size$ = 24						; size = 4
_id$ = 28						; size = 4
?NewStockFontBuffer@@YAXPAU_CHAT_BUFFER@@HEPADHH@Z PROC	; NewStockFontBuffer, COMDAT

; 399  : void NewStockFontBuffer(CHAT_BUFFER *chatbuffer, int x, unsigned char color, char *str, int size,int id){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 08	 mov	 ecx, DWORD PTR _chatbuffer$[ebp]
  00006	8b 45 14	 mov	 eax, DWORD PTR _str$[ebp]

; 400  : 	MyNewStockFontBuffer(chatbuffer, x, color, str, size, id);

  00009	89 45 14	 mov	 DWORD PTR _str$[ebp], eax
  0000c	89 4d 08	 mov	 DWORD PTR _chatbuffer$[ebp], ecx

; 401  : 	return;
; 402  : 	if (!str[0]) {
; 403  : 		return;
; 404  : 	}
; 405  : 	memset(chatbuffer, 0, sizeof(CHAT_BUFFER));
; 406  : 	chatbuffer->fontsize = size;
; 407  : 	chatbuffer->id = id;
; 408  : 	char outText[512];
; 409  : 	char *temp = sunday(str, "#");
; 410  : 	if (temp) {
; 411  : 		if (temp != str) {
; 412  : 			int strl = temp - str;
; 413  : 			memcpy(outText, str, strl);   //outText‰∏∫#‰πãÂâçÁöÑÊã∑Ë¥ù
; 414  : 			outText[strl] = 0x0;
; 415  : 			SIZE fontsize;
; 416  : 			GetTextExtentPoint32(FontSizeHdc, (LPCSTR)outText, strl, (LPSIZE)&fontsize);
; 417  : 			chatbuffer->color = color;
; 418  : 			chatbuffer->x = x;
; 419  : 			strcpy(chatbuffer->buffer, outText);
; 420  : 			chatbuffer->NextChatBuffer = (CHAT_BUFFER *)calloc(1, sizeof(CHAT_BUFFER));
; 421  : 			NewStockFontBuffer(chatbuffer->NextChatBuffer, x + fontsize.cx, color, temp, size,id);
; 422  : 		}else{
; 423  : 			int cnt_int = 0;
; 424  : 			int i = 1;
; 425  : 			for (i; i<4; i++) {
; 426  : 				if (temp[i] >= '0'&& temp[i] <= '9') {
; 427  : 					cnt_int *= 10;
; 428  : 					cnt_int += temp[i] - '0';
; 429  : 				}
; 430  : 				else {
; 431  : 					break;
; 432  : 				}
; 433  : 			}
; 434  : 			if (cnt_int>0 && cnt_int <= EXPRESSION_NOID_NUM + 1) {
; 435  : 				chatbuffer->x = x;
; 436  : 				chatbuffer->BmpNo = EXPRESSION_NOID_START + cnt_int - 1;
; 437  : 				temp += i;
; 438  : 				x += 26;   //Ë°®ÊÉÖÁöÑÂÆΩÂ∫¶
; 439  : 			}else{
; 440  : 				memcpy(outText, temp, i);
; 441  : 				outText[i] = 0x0;
; 442  : 				SIZE fontsize;
; 443  : 				GetTextExtentPoint32(FontSizeHdc, (LPCSTR)outText, i, (LPSIZE)&fontsize);
; 444  : 				chatbuffer->color = color;
; 445  : 				chatbuffer->x = x;
; 446  : 				strcpy(chatbuffer->buffer, outText);
; 447  : 				x += fontsize.cx;
; 448  : 				temp += i;
; 449  : 			}
; 450  : 			chatbuffer->NextChatBuffer = (CHAT_BUFFER *)calloc(1, sizeof(CHAT_BUFFER));
; 451  : 			NewStockFontBuffer(chatbuffer->NextChatBuffer, x, color, temp, size,id);
; 452  : 		}
; 453  : 	}else{
; 454  : 		chatbuffer->color = color;
; 455  : 		chatbuffer->x = x;
; 456  : 		strcpy(chatbuffer->buffer, str);
; 457  : 	}
; 458  : }

  0000f	5d		 pop	 ebp

; 400  : 	MyNewStockFontBuffer(chatbuffer, x, color, str, size, id);

  00010	e9 00 00 00 00	 jmp	 ?MyNewStockFontBuffer@@YAXPAU_CHAT_BUFFER@@HEPADHH@Z ; MyNewStockFontBuffer
?NewStockFontBuffer@@YAXPAU_CHAT_BUFFER@@HEPADHH@Z ENDP	; NewStockFontBuffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\font.cpp
;	COMDAT ?sunday@@YAPADPAD0@Z
_TEXT	SEGMENT
_strLen$1$ = -1036					; size = 4
_subStr$GSCopy$1$ = -1032				; size = 4
_next$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_str$ = 8						; size = 4
_subStr$ = 12						; size = 4
?sunday@@YAPADPAD0@Z PROC				; sunday, COMDAT

; 16   : char* sunday(char* str, char* subStr){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 04 00
	00		 sub	 esp, 1036		; 0000040cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR _subStr$[ebp]
  00018	57		 push	 edi

; 17   : 	const int maxSize = 256;
; 18   : 	int next[maxSize];
; 19   : 	int strLen = strlen(str);

  00019	8b 7d 08	 mov	 edi, DWORD PTR _str$[ebp]
  0001c	8b df		 mov	 ebx, edi
  0001e	89 b5 f8 fb ff
	ff		 mov	 DWORD PTR _subStr$GSCopy$1$[ebp], esi
  00024	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
$LL41@sunday:
  00027	8a 03		 mov	 al, BYTE PTR [ebx]
  00029	43		 inc	 ebx
  0002a	84 c0		 test	 al, al
  0002c	75 f9		 jne	 SHORT $LL41@sunday

; 20   : 	int subLen = strlen(subStr);

  0002e	8b d6		 mov	 edx, esi
  00030	2b d9		 sub	 ebx, ecx
  00032	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
$LL42@sunday:
  00035	8a 02		 mov	 al, BYTE PTR [edx]
  00037	42		 inc	 edx
  00038	84 c0		 test	 al, al
  0003a	75 f9		 jne	 SHORT $LL42@sunday
  0003c	2b d1		 sub	 edx, ecx
  0003e	33 c9		 xor	 ecx, ecx
  00040	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00043	66 0f 6e c0	 movd	 xmm0, eax
  00047	66 0f 70 c0 00	 pshufd	 xmm0, xmm0, 0
  0004c	0f 1f 40 00	 npad	 4
$LL4@sunday:

; 21   : 	int i, j, pos;
; 22   : 	for (i = 0; i<maxSize; i++){
; 23   : 		next[i] = subLen + 1;

  00050	0f 11 84 8d fc
	fb ff ff	 movups	 XMMWORD PTR _next$[ebp+ecx*4], xmm0
  00058	0f 11 84 8d 0c
	fc ff ff	 movups	 XMMWORD PTR _next$[ebp+ecx*4+16], xmm0
  00060	0f 11 84 8d 1c
	fc ff ff	 movups	 XMMWORD PTR _next$[ebp+ecx*4+32], xmm0
  00068	0f 11 84 8d 2c
	fc ff ff	 movups	 XMMWORD PTR _next$[ebp+ecx*4+48], xmm0
  00070	83 c1 10	 add	 ecx, 16			; 00000010H
  00073	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  00079	7c d5		 jl	 SHORT $LL4@sunday

; 24   : 	}
; 25   : 	for (i = 0; i<subLen; i++){

  0007b	33 c9		 xor	 ecx, ecx
  0007d	85 d2		 test	 edx, edx
  0007f	7e 16		 jle	 SHORT $LN6@sunday
  00081	8b fa		 mov	 edi, edx
$LL7@sunday:

; 26   : 		next[(unsigned char)subStr[i]] = subLen - i;//ËÆ°ÁÆóÂ≠ê‰∏≤‰∏≠ÁöÑÂ≠óÁ¨¶Âà∞Â≠óÁ¨¶‰∏≤ÁªìÂ∞æÁöÑ\0‰πãÈó¥ÁöÑË∑ùÁ¶ª

  00083	0f b6 04 0e	 movzx	 eax, BYTE PTR [esi+ecx]
  00087	41		 inc	 ecx
  00088	89 bc 85 fc fb
	ff ff		 mov	 DWORD PTR _next$[ebp+eax*4], edi
  0008f	4f		 dec	 edi
  00090	3b ca		 cmp	 ecx, edx
  00092	7c ef		 jl	 SHORT $LL7@sunday
  00094	8b 7d 08	 mov	 edi, DWORD PTR _str$[ebp]
$LN6@sunday:

; 27   : 	}
; 28   : 	pos = 0;

  00097	33 f6		 xor	 esi, esi

; 29   : 	while (pos <= (strLen - subLen)){

  00099	2b da		 sub	 ebx, edx
  0009b	89 9d f4 fb ff
	ff		 mov	 DWORD PTR _strLen$1$[ebp], ebx
  000a1	78 31		 js	 SHORT $LN9@sunday
$LL8@sunday:

; 31   : 		for (j = 0; j<subLen; j++, i++){

  000a3	33 c0		 xor	 eax, eax
  000a5	85 d2		 test	 edx, edx
  000a7	7e 20		 jle	 SHORT $LN11@sunday

; 30   : 		i = pos;

  000a9	03 fe		 add	 edi, esi
  000ab	0f 1f 44 00 00	 npad	 5
$LL12@sunday:

; 32   : 			if (str[i] != subStr[j]){

  000b0	8b 9d f8 fb ff
	ff		 mov	 ebx, DWORD PTR _subStr$GSCopy$1$[ebp]
  000b6	8a 0c 07	 mov	 cl, BYTE PTR [edi+eax]
  000b9	3a 0c 03	 cmp	 cl, BYTE PTR [ebx+eax]
  000bc	8b 9d f4 fb ff
	ff		 mov	 ebx, DWORD PTR _strLen$1$[ebp]
  000c2	75 23		 jne	 SHORT $LN20@sunday

; 31   : 		for (j = 0; j<subLen; j++, i++){

  000c4	40		 inc	 eax
  000c5	3b c2		 cmp	 eax, edx
  000c7	7c e7		 jl	 SHORT $LL12@sunday
$LN11@sunday:

; 34   : 				break;
; 35   : 			}
; 36   : 
; 37   : 		}
; 38   : 		if (j == subLen){//ÊâæÂà∞Â≠ó‰∏≤ÔºåËøîÂõû

  000c9	3b c2		 cmp	 eax, edx
  000cb	74 2d		 je	 SHORT $LN21@sunday
  000cd	8b 7d 08	 mov	 edi, DWORD PTR _str$[ebp]
$LN40@sunday:

; 29   : 	while (pos <= (strLen - subLen)){

  000d0	3b f3		 cmp	 esi, ebx
  000d2	7e cf		 jle	 SHORT $LL8@sunday
$LN9@sunday:
  000d4	5f		 pop	 edi

; 40   : 		}
; 41   : 	}
; 42   : 	return NULL;
; 43   : }

  000d5	5e		 pop	 esi
  000d6	33 c0		 xor	 eax, eax
  000d8	5b		 pop	 ebx
  000d9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dc	33 cd		 xor	 ecx, ebp
  000de	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c3		 ret	 0
$LN20@sunday:

; 33   : 				pos += next[(unsigned char)str[pos + subLen]];//ÂêëÂêéÁßªÂä®

  000e7	8b 7d 08	 mov	 edi, DWORD PTR _str$[ebp]
  000ea	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  000ed	0f b6 04 38	 movzx	 eax, BYTE PTR [eax+edi]
  000f1	03 b4 85 fc fb
	ff ff		 add	 esi, DWORD PTR _next$[ebp+eax*4]
  000f8	eb d6		 jmp	 SHORT $LN40@sunday
$LN21@sunday:

; 39   : 			return str + pos;

  000fa	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]

; 40   : 		}
; 41   : 	}
; 42   : 	return NULL;
; 43   : }

  000fd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00100	03 c6		 add	 eax, esi
  00102	5f		 pop	 edi
  00103	5e		 pop	 esi
  00104	33 cd		 xor	 ecx, ebp
  00106	5b		 pop	 ebx
  00107	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010c	8b e5		 mov	 esp, ebp
  0010e	5d		 pop	 ebp
  0010f	c3		 ret	 0
?sunday@@YAPADPAD0@Z ENDP				; sunday
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1781 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1782 :         int _Result;
; 1783 :         va_list _ArgList;
; 1784 :         __crt_va_start(_ArgList, _Format);
; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1789 :         #pragma warning(pop)
; 1790 : 
; 1791 :         __crt_va_end(_ArgList);
; 1792 :         return _Result;
; 1793 :     }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
