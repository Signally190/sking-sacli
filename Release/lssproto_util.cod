; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30133.0 

	TITLE	\\VBOXSVR\_stoneage\repos\ssm-sacli\Release\lssproto_util.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?lssproto@@3Ulssproto_@@A			; lssproto
PUBLIC	?lssproto_stringwrapper@@3PAPADA		; lssproto_stringwrapper
PUBLIC	?lssproto_readlogfilename@@3PADA		; lssproto_readlogfilename
PUBLIC	?lssproto_writelogfilename@@3PADA		; lssproto_writelogfilename
PUBLIC	?SendCount@@3HA					; SendCount
PUBLIC	?lssproto_charset@@3PADA			; lssproto_charset
PUBLIC	?lssproto_reversecharset@@3PADA			; lssproto_reversecharset
PUBLIC	?lssproto_modifymask_first@@3PAY08HA		; lssproto_modifymask_first
PUBLIC	?lssproto_modifymask_second@@3PAY08HA		; lssproto_modifymask_second
PUBLIC	?bitstream_maxbyte@@3HA				; bitstream_maxbyte
PUBLIC	?bitstream_bitaddr@@3HA				; bitstream_bitaddr
PUBLIC	?bitstream_buf@@3PADA				; bitstream_buf
_BSS	SEGMENT
?lssproto_stringwrapper@@3PAPADA DD 01H DUP (?)		; lssproto_stringwrapper
?lssproto_readlogfilename@@3PADA DB 0400H DUP (?)	; lssproto_readlogfilename
?lssproto_writelogfilename@@3PADA DB 0400H DUP (?)	; lssproto_writelogfilename
?SendCount@@3HA DD 01H DUP (?)				; SendCount
?bitstream_maxbyte@@3HA DD 01H DUP (?)			; bitstream_maxbyte
?bitstream_bitaddr@@3HA DD 01H DUP (?)			; bitstream_bitaddr
?bitstream_buf@@3PADA DD 01H DUP (?)			; bitstream_buf
_BSS	ENDS
_DATA	SEGMENT
?lssproto@@3Ulssproto_@@A DD 00H			; lssproto
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	ORG $+4
?lssproto_charset@@3PADA DB 041H			; lssproto_charset
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	047H
	DB	048H
	DB	049H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	04dH
	DB	04eH
	DB	04fH
	DB	050H
	DB	051H
	DB	052H
	DB	053H
	DB	054H
	DB	055H
	DB	056H
	DB	057H
	DB	058H
	DB	059H
	DB	05aH
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	02bH
	DB	02dH
?lssproto_reversecharset@@3PADA DB 00H			; lssproto_reversecharset
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	03eH
	DB	00H
	DB	03fH
	DB	00H
	DB	00H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	03cH
	DB	03dH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	02aH
	DB	02bH
	DB	02cH
	DB	02dH
	DB	02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
?lssproto_modifymask_first@@3PAY08HA DD 00H		; lssproto_modifymask_first
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	00H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	0ffH
	DD	00H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	00H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	00H
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	00H
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	00H
	DD	07fH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	00H
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
?lssproto_modifymask_second@@3PAY08HA DD 00H		; lssproto_modifymask_second
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	03H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	03H
	DD	07H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	00H
	DD	00H
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	_sprintf
PUBLIC	?lssproto_escapeString@@YAPADPAD@Z		; lssproto_escapeString
PUBLIC	?lssproto_descapeString@@YAPADPAD@Z		; lssproto_descapeString
PUBLIC	?lssproto_splitString@@YAXPAD@Z			; lssproto_splitString
PUBLIC	?lssproto_strcpysafe@@YAXPAD0H@Z		; lssproto_strcpysafe
PUBLIC	?lssproto_strcatsafe@@YAXPAD0H@Z		; lssproto_strcatsafe
PUBLIC	?lssproto_mkstr_int@@YAPADH@Z			; lssproto_mkstr_int
PUBLIC	?lssproto_mkstr_u_int@@YAPADI@Z			; lssproto_mkstr_u_int
PUBLIC	?lssproto_mkstr_long@@YAPADJ@Z			; lssproto_mkstr_long
PUBLIC	?lssproto_mkstr_u_long@@YAPADK@Z		; lssproto_mkstr_u_long
PUBLIC	?lssproto_mkstr_short@@YAPADF@Z			; lssproto_mkstr_short
PUBLIC	?lssproto_mkstr_u_short@@YAPADF@Z		; lssproto_mkstr_u_short
PUBLIC	?lssproto_mkstr_char@@YAPADD@Z			; lssproto_mkstr_char
PUBLIC	?lssproto_mkstr_u_char@@YAPADD@Z		; lssproto_mkstr_u_char
PUBLIC	?lssproto_mkstr_string@@YAPADPAD@Z		; lssproto_mkstr_string
PUBLIC	?lssproto_mkstr_float@@YAPADM@Z			; lssproto_mkstr_float
PUBLIC	?lssproto_mkstr_double@@YAPADN@Z		; lssproto_mkstr_double
PUBLIC	?lssproto_mkstr_int_array@@YAPADHPAH@Z		; lssproto_mkstr_int_array
PUBLIC	?lssproto_mkstr_u_int_array@@YAPADHPAH@Z	; lssproto_mkstr_u_int_array
PUBLIC	?lssproto_mkstr_short_array@@YAPADHPAF@Z	; lssproto_mkstr_short_array
PUBLIC	?lssproto_mkstr_u_short_array@@YAPADHPAF@Z	; lssproto_mkstr_u_short_array
PUBLIC	?lssproto_mkstr_char_array@@YAPADHPAD@Z		; lssproto_mkstr_char_array
PUBLIC	?lssproto_mkstr_u_char_array@@YAPADHPAE@Z	; lssproto_mkstr_u_char_array
PUBLIC	?lssproto_mkstr_float_array@@YAPADHPAM@Z	; lssproto_mkstr_float_array
PUBLIC	?lssproto_mkstr_double_array@@YAPADHPAN@Z	; lssproto_mkstr_double_array
PUBLIC	?lssproto_demkstr_int@@YAHPAD@Z			; lssproto_demkstr_int
PUBLIC	?lssproto_demkstr_u_int@@YAIPAD@Z		; lssproto_demkstr_u_int
PUBLIC	?lssproto_demkstr_long@@YAJPAD@Z		; lssproto_demkstr_long
PUBLIC	?lssproto_demkstr_u_long@@YAKPAD@Z		; lssproto_demkstr_u_long
PUBLIC	?lssproto_demkstr_short@@YAFPAD@Z		; lssproto_demkstr_short
PUBLIC	?lssproto_demkstr_u_short@@YAGPAD@Z		; lssproto_demkstr_u_short
PUBLIC	?lssproto_demkstr_char@@YADPAD@Z		; lssproto_demkstr_char
PUBLIC	?lssproto_demkstr_u_char@@YAEPAD@Z		; lssproto_demkstr_u_char
PUBLIC	?lssproto_demkstr_float@@YAMPAD@Z		; lssproto_demkstr_float
PUBLIC	?lssproto_demkstr_double@@YANPAD@Z		; lssproto_demkstr_double
PUBLIC	?lssproto_demkstr_string@@YAPADPAD@Z		; lssproto_demkstr_string
PUBLIC	?lssproto_demkstr_int_array@@YAPAHPAPADPAHHH@Z	; lssproto_demkstr_int_array
PUBLIC	?lssproto_demkstr_u_int_array@@YAPAHPAPADPAHHH@Z ; lssproto_demkstr_u_int_array
PUBLIC	?lssproto_demkstr_long_array@@YAPAIPAPADPAIHH@Z	; lssproto_demkstr_long_array
PUBLIC	?lssproto_demkstr_u_long_array@@YAPAKPAPADPAKHH@Z ; lssproto_demkstr_u_long_array
PUBLIC	?lssproto_demkstr_short_array@@YAPAFPAPADPAFHH@Z ; lssproto_demkstr_short_array
PUBLIC	?lssproto_demkstr_u_short_array@@YAPAGPAPADPAGHH@Z ; lssproto_demkstr_u_short_array
PUBLIC	?lssproto_demkstr_char_array@@YAPADPAPADPADHH@Z	; lssproto_demkstr_char_array
PUBLIC	?lssproto_demkstr_u_char_array@@YAPAEPAPADPAEHH@Z ; lssproto_demkstr_u_char_array
PUBLIC	?lssproto_demkstr_float_array@@YAPAMPAPADPAMHH@Z ; lssproto_demkstr_float_array
PUBLIC	?lssproto_demkstr_u_double_array@@YAPANPAPADPANHH@Z ; lssproto_demkstr_u_double_array
PUBLIC	?lssproto_wrapStringAddr@@YAPADPADH0@Z		; lssproto_wrapStringAddr
PUBLIC	?lssproto_GetMessageInfo@@YAXPAHPADHPAPAD@Z	; lssproto_GetMessageInfo
PUBLIC	?lssproto_consumeLine@@YAXPADH@Z		; lssproto_consumeLine
PUBLIC	?lssproto_copyLine@@YAXPAD0H@Z			; lssproto_copyLine
PUBLIC	?lssproto_Send@@YAXHPAD@Z			; lssproto_Send
PUBLIC	?lssproto_AllocateCommonWork@@YAHH@Z		; lssproto_AllocateCommonWork
PUBLIC	?lssproto_GetNewMessageID@@YAIXZ		; lssproto_GetNewMessageID
PUBLIC	?lssproto_CreateHeader@@YAXPAD0@Z		; lssproto_CreateHeader
PUBLIC	?lssproto_CreateHeaderID@@YAXPADK0@Z		; lssproto_CreateHeaderID
PUBLIC	?lssproto_default_write_wrap@@YAHHPADH@Z	; lssproto_default_write_wrap
PUBLIC	?lssproto_bzero@@YAXPADH@Z			; lssproto_bzero
PUBLIC	?lssproto_bcopy@@YAXPAD0H@Z			; lssproto_bcopy
PUBLIC	?lssproto_Ltoa@@YAPADJ@Z			; lssproto_Ltoa
PUBLIC	?lssproto_Ultoa@@YAPADK@Z			; lssproto_Ultoa
PUBLIC	?lssproto_DebugSend@@YAXHPAD@Z			; lssproto_DebugSend
PUBLIC	?lssproto_cnv10to62@@YAPADHPADH@Z		; lssproto_cnv10to62
PUBLIC	?lssproto_a62toi@@YAHPAD@Z			; lssproto_a62toi
PUBLIC	?lssproto_ringoCompressor@@YAJPAEJ0J@Z		; lssproto_ringoCompressor
PUBLIC	?lssproto_ringoDecompressor@@YAJPAEJ0J@Z	; lssproto_ringoDecompressor
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_03JAIJOMNP@?$CFf?5@			; `string'
PUBLIC	??_C@_02DPNLHKJD@a?$CL@				; `string'
PUBLIC	??_C@_0L@INAHAGEI@?b?$KF?S?p?$KD?$LK?7?$CFs?6@	; `string'
PUBLIC	??_C@_06DBOHCIGL@?$CFu?5?$CFs?5@		; `string'
PUBLIC	??_C@_02GMHACPFF@?$CFu@				; `string'
PUBLIC	??_C@_0CF@NBLKNCEA@lsgen?3?5badly?5configured?5work?5bu@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0BH@GCBPDGEH@LSRPC?3?5too?5short?3?$FL?$CFs?$FN?6@ ; `string'
PUBLIC	??_C@_0DP@CCELEMID@0123456789abcdefghijklmnopqrstu@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
EXTRN	__imp__IsDBCSLeadByte@4:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_exit:PROC
EXTRN	_atof:PROC
EXTRN	_strtod:PROC
EXTRN	_strtol:PROC
EXTRN	_strtoul:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	?bNewServer@@3HA:DWORD				; bNewServer
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?bInit@?1??lssproto_AllocateCommonWork@@YAHH@Z@4HA
_BSS	SEGMENT
?bInit@?1??lssproto_AllocateCommonWork@@YAHH@Z@4HA DD 01H DUP (?) ; `lssproto_AllocateCommonWork'::`2'::bInit
_BSS	ENDS
;	COMDAT ?_ltoa_out@?1??lssproto_Ltoa@@YAPADJ@Z@4PADA
_BSS	SEGMENT
?_ltoa_out@?1??lssproto_Ltoa@@YAPADJ@Z@4PADA DB 040H DUP (?) ; `lssproto_Ltoa'::`2'::_ltoa_out
_BSS	ENDS
;	COMDAT ?_ultoa_out@?1??lssproto_Ultoa@@YAPADK@Z@4PADA
_BSS	SEGMENT
?_ultoa_out@?1??lssproto_Ultoa@@YAPADK@Z@4PADA DB 040H DUP (?) ; `lssproto_Ultoa'::`2'::_ultoa_out
_BSS	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0DP@CCELEMID@0123456789abcdefghijklmnopqrstu@
CONST	SEGMENT
??_C@_0DP@CCELEMID@0123456789abcdefghijklmnopqrstu@ DB '0123456789abcdefg'
	DB	'hijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GCBPDGEH@LSRPC?3?5too?5short?3?$FL?$CFs?$FN?6@
CONST	SEGMENT
??_C@_0BH@GCBPDGEH@LSRPC?3?5too?5short?3?$FL?$CFs?$FN?6@ DB 'LSRPC: too s'
	DB	'hort:[%s]', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NBLKNCEA@lsgen?3?5badly?5configured?5work?5bu@
CONST	SEGMENT
??_C@_0CF@NBLKNCEA@lsgen?3?5badly?5configured?5work?5bu@ DB 'lsgen: badly'
	DB	' configured work buflen', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMHACPFF@?$CFu@
CONST	SEGMENT
??_C@_02GMHACPFF@?$CFu@ DB '%u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06DBOHCIGL@?$CFu?5?$CFs?5@
CONST	SEGMENT
??_C@_06DBOHCIGL@?$CFu?5?$CFs?5@ DB '%u %s ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@INAHAGEI@?b?$KF?S?p?$KD?$LK?7?$CFs?6@
CONST	SEGMENT
??_C@_0L@INAHAGEI@?b?$KF?S?p?$KD?$LK?7?$CFs?6@ DB 0e2H, 0a5H, 0d3H, 0f0H, 0a3H
	DB	0baH, 09H, '%s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPNLHKJD@a?$CL@
CONST	SEGMENT
??_C@_02DPNLHKJD@a?$CL@ DB 'a+', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JAIJOMNP@?$CFf?5@
CONST	SEGMENT
??_C@_03JAIJOMNP@?$CFf?5@ DB '%f ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?writeOutputBitStream@@YAHHI@Z
_TEXT	SEGMENT
_bwidth$ = 8						; size = 4
_dat$ = 12						; size = 4
?writeOutputBitStream@@YAHHI@Z PROC			; writeOutputBitStream, COMDAT

; 1278 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1279 :     int ret;
; 1280 :     if( bwidth <= 0){

  00004	8b 75 08	 mov	 esi, DWORD PTR _bwidth$[ebp]
  00007	57		 push	 edi
  00008	85 f6		 test	 esi, esi
  0000a	0f 8e b7 00 00
	00		 jle	 $LN16@writeOutpu

; 1281 :         return -1;
; 1282 :     } else if( bwidth >= 1 && bwidth <= 8 ){

  00010	83 fe 08	 cmp	 esi, 8
  00013	7f 09		 jg	 SHORT $LN25@writeOutpu

; 1283 :         if((ret=writeOutputBitStreamBody( bwidth , (unsigned char)dat))<0)return -1;

  00015	ff 75 0c	 push	 DWORD PTR _dat$[ebp]
  00018	56		 push	 esi
  00019	e9 9d 00 00 00	 jmp	 $LN27@writeOutpu
$LN25@writeOutpu:

; 1284 :     } else if( bwidth > 8 && bwidth <= 16 ){

  0001e	83 fe 10	 cmp	 esi, 16			; 00000010H
  00021	7f 1e		 jg	 SHORT $LN24@writeOutpu

; 1285 :         if(writeOutputBitStreamBody( 8 , (unsigned char)(dat&0xff))<0)return -1;

  00023	8b 7d 0c	 mov	 edi, DWORD PTR _dat$[ebp]
  00026	57		 push	 edi
  00027	6a 08		 push	 8
  00029	e8 00 00 00 00	 call	 ?writeOutputBitStreamBody@@YAHHE@Z ; writeOutputBitStreamBody
  0002e	83 c4 08	 add	 esp, 8
  00031	85 c0		 test	 eax, eax
  00033	0f 88 8e 00 00
	00		 js	 $LN16@writeOutpu

; 1286 :         if((ret=writeOutputBitStreamBody( bwidth - 8 , ( unsigned char)((dat>>8)&0xff)))<0)return -1;

  00039	c1 ef 08	 shr	 edi, 8
  0003c	8d 46 f8	 lea	 eax, DWORD PTR [esi-8]
  0003f	eb 78		 jmp	 SHORT $LN28@writeOutpu
$LN24@writeOutpu:

; 1287 :     } else if( bwidth > 16 && bwidth <= 24 ){

  00041	83 fe 18	 cmp	 esi, 24			; 00000018H
  00044	7f 2e		 jg	 SHORT $LN23@writeOutpu

; 1288 :         if(writeOutputBitStreamBody( 8 , (unsigned char)(dat&0xff))<0)return -1;

  00046	8b 7d 0c	 mov	 edi, DWORD PTR _dat$[ebp]
  00049	57		 push	 edi
  0004a	6a 08		 push	 8
  0004c	e8 00 00 00 00	 call	 ?writeOutputBitStreamBody@@YAHHE@Z ; writeOutputBitStreamBody
  00051	83 c4 08	 add	 esp, 8
  00054	85 c0		 test	 eax, eax
  00056	78 6f		 js	 SHORT $LN16@writeOutpu

; 1289 :         if(writeOutputBitStreamBody( 8 , (unsigned char)((dat>>8)&0xff))<0)return -1;

  00058	8b c7		 mov	 eax, edi
  0005a	c1 e8 08	 shr	 eax, 8
  0005d	50		 push	 eax
  0005e	6a 08		 push	 8
  00060	e8 00 00 00 00	 call	 ?writeOutputBitStreamBody@@YAHHE@Z ; writeOutputBitStreamBody
  00065	83 c4 08	 add	 esp, 8
  00068	85 c0		 test	 eax, eax
  0006a	78 5b		 js	 SHORT $LN16@writeOutpu

; 1290 :         if((ret=writeOutputBitStreamBody( bwidth-16,(unsigned char)((dat>>16)&0xff)))<0)return -1;

  0006c	c1 ef 10	 shr	 edi, 16			; 00000010H
  0006f	8d 46 f0	 lea	 eax, DWORD PTR [esi-16]

; 1296 :     } else {
; 1297 :         return -1;

  00072	eb 45		 jmp	 SHORT $LN28@writeOutpu
$LN23@writeOutpu:

; 1291 :     } else if( bwidth > 24 && bwidth <= 32 ){

  00074	83 fe 20	 cmp	 esi, 32			; 00000020H
  00077	7f 4e		 jg	 SHORT $LN16@writeOutpu

; 1292 :         if(writeOutputBitStreamBody( 8 , (unsigned char)(dat&0xff))<0)return -1;

  00079	8b 7d 0c	 mov	 edi, DWORD PTR _dat$[ebp]
  0007c	57		 push	 edi
  0007d	6a 08		 push	 8
  0007f	e8 00 00 00 00	 call	 ?writeOutputBitStreamBody@@YAHHE@Z ; writeOutputBitStreamBody
  00084	83 c4 08	 add	 esp, 8
  00087	85 c0		 test	 eax, eax
  00089	78 3c		 js	 SHORT $LN16@writeOutpu

; 1293 :         if(writeOutputBitStreamBody( 8 , (unsigned char)((dat>>8)&0xff))<0)return -1;

  0008b	8b c7		 mov	 eax, edi
  0008d	c1 e8 08	 shr	 eax, 8
  00090	50		 push	 eax
  00091	6a 08		 push	 8
  00093	e8 00 00 00 00	 call	 ?writeOutputBitStreamBody@@YAHHE@Z ; writeOutputBitStreamBody
  00098	83 c4 08	 add	 esp, 8
  0009b	85 c0		 test	 eax, eax
  0009d	78 28		 js	 SHORT $LN16@writeOutpu

; 1294 :         if(writeOutputBitStreamBody( 8 , (unsigned char)((dat>>16)&0xff))<0)return -1;

  0009f	8b c7		 mov	 eax, edi
  000a1	c1 e8 10	 shr	 eax, 16			; 00000010H
  000a4	50		 push	 eax
  000a5	6a 08		 push	 8
  000a7	e8 00 00 00 00	 call	 ?writeOutputBitStreamBody@@YAHHE@Z ; writeOutputBitStreamBody
  000ac	83 c4 08	 add	 esp, 8
  000af	85 c0		 test	 eax, eax
  000b1	78 14		 js	 SHORT $LN16@writeOutpu

; 1295 :         if((ret=writeOutputBitStreamBody( bwidth-24,(unsigned char)((dat>>24)&0xff)))<0)return -1;

  000b3	c1 ef 18	 shr	 edi, 24			; 00000018H
  000b6	8d 46 e8	 lea	 eax, DWORD PTR [esi-24]
$LN28@writeOutpu:

; 1296 :     } else {
; 1297 :         return -1;

  000b9	57		 push	 edi
  000ba	50		 push	 eax
$LN27@writeOutpu:
  000bb	e8 00 00 00 00	 call	 ?writeOutputBitStreamBody@@YAHHE@Z ; writeOutputBitStreamBody
  000c0	83 c4 08	 add	 esp, 8
  000c3	85 c0		 test	 eax, eax
  000c5	79 03		 jns	 SHORT $LN1@writeOutpu
$LN16@writeOutpu:
  000c7	83 c8 ff	 or	 eax, -1
$LN1@writeOutpu:
  000ca	5f		 pop	 edi

; 1298 :     }
; 1299 :     return ret;
; 1300 : }

  000cb	5e		 pop	 esi
  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
?writeOutputBitStream@@YAHHI@Z ENDP			; writeOutputBitStream
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?writeOutputBitStreamBody@@YAHHE@Z
_TEXT	SEGMENT
tv242 = -12						; size = 4
_byteaddr$1$ = -8					; size = 4
_mod$1$ = -4						; size = 4
_bwidth$ = 8						; size = 4
_b$ = 12						; size = 1
?writeOutputBitStreamBody@@YAHHE@Z PROC			; writeOutputBitStreamBody, COMDAT

; 1261 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1262 :     int mod = bitstream_bitaddr % 8;

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bitstream_bitaddr@@3HA ; bitstream_bitaddr
  00008	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000b	8b c8		 mov	 ecx, eax
  0000d	81 e1 07 00 00
	80		 and	 ecx, -2147483641	; 80000007H
  00013	79 05		 jns	 SHORT $LN4@writeOutpu
  00015	49		 dec	 ecx
  00016	83 c9 f8	 or	 ecx, -8			; fffffff8H
  00019	41		 inc	 ecx
$LN4@writeOutpu:

; 1263 :     int byteaddr = bitstream_bitaddr / 8;

  0001a	99		 cdq
  0001b	83 e2 07	 and	 edx, 7
  0001e	89 4d fc	 mov	 DWORD PTR _mod$1$[ebp], ecx
  00021	03 d0		 add	 edx, eax
  00023	c1 fa 03	 sar	 edx, 3
  00026	89 55 f8	 mov	 DWORD PTR _byteaddr$1$[ebp], edx

; 1264 :     /* return error if excess */
; 1265 :     if( bitstream_maxbyte <= (byteaddr+1)) return -1;

  00029	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0002c	89 45 f4	 mov	 DWORD PTR tv242[ebp], eax
  0002f	39 05 00 00 00
	00		 cmp	 DWORD PTR ?bitstream_maxbyte@@3HA, eax ; bitstream_maxbyte
  00035	7f 07		 jg	 SHORT $LN2@writeOutpu
  00037	83 c8 ff	 or	 eax, -1

; 1272 : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN2@writeOutpu:
  0003e	53		 push	 ebx

; 1266 :     bitstream_buf[byteaddr] &= lssproto_modifymask_first[mod][bwidth];
; 1267 :     bitstream_buf[byteaddr] |= (b << mod) & lssproto_modifymask_first[mod][bwidth];

  0003f	8a 5d 0c	 mov	 bl, BYTE PTR _b$[ebp]
  00042	56		 push	 esi
  00043	57		 push	 edi
  00044	8b 7d 08	 mov	 edi, DWORD PTR _bwidth$[ebp]
  00047	8d 34 cf	 lea	 esi, DWORD PTR [edi+ecx*8]
  0004a	03 f1		 add	 esi, ecx
  0004c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?bitstream_buf@@3PADA ; bitstream_buf
  00052	0f b6 04 b5 00
	00 00 00	 movzx	 eax, BYTE PTR ?lssproto_modifymask_first@@3PAY08HA[esi*4]
  0005a	20 04 11	 and	 BYTE PTR [ecx+edx], al
  0005d	8a c3		 mov	 al, bl
  0005f	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?bitstream_buf@@3PADA ; bitstream_buf
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _mod$1$[ebp]
  00068	d2 e0		 shl	 al, cl
  0006a	22 04 b5 00 00
	00 00		 and	 al, BYTE PTR ?lssproto_modifymask_first@@3PAY08HA[esi*4]
  00071	08 02		 or	 BYTE PTR [edx], al

; 1268 :     bitstream_buf[byteaddr+1] &= lssproto_modifymask_second[mod][bwidth];

  00073	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?bitstream_buf@@3PADA ; bitstream_buf
  00079	8b 55 f8	 mov	 edx, DWORD PTR _byteaddr$1$[ebp]
  0007c	0f b6 04 b5 00
	00 00 00	 movzx	 eax, BYTE PTR ?lssproto_modifymask_second@@3PAY08HA[esi*4]
  00084	20 44 11 01	 and	 BYTE PTR [ecx+edx+1], al

; 1269 :     bitstream_buf[byteaddr+1] |= (b>>(8-mod))& lssproto_modifymask_second[mod][bwidth];

  00088	b1 08		 mov	 cl, 8
  0008a	2a 4d fc	 sub	 cl, BYTE PTR _mod$1$[ebp]
  0008d	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?bitstream_buf@@3PADA ; bitstream_buf

; 1270 :     bitstream_bitaddr += bwidth;
; 1271 :     return byteaddr+1;

  00093	8b 45 f4	 mov	 eax, DWORD PTR tv242[ebp]
  00096	d2 eb		 shr	 bl, cl
  00098	22 1c b5 00 00
	00 00		 and	 bl, BYTE PTR ?lssproto_modifymask_second@@3PAY08HA[esi*4]
  0009f	08 5a 01	 or	 BYTE PTR [edx+1], bl
  000a2	01 3d 00 00 00
	00		 add	 DWORD PTR ?bitstream_bitaddr@@3HA, edi ; bitstream_bitaddr
  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi
  000aa	5b		 pop	 ebx

; 1272 : }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
?writeOutputBitStreamBody@@YAHHE@Z ENDP			; writeOutputBitStreamBody
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?readInputBitStream@@YAIH@Z
_TEXT	SEGMENT
_bwidth$ = 8						; size = 4
?readInputBitStream@@YAIH@Z PROC			; readInputBitStream, COMDAT

; 1233 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1234 :     if( bwidth <= 0 ){

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _bwidth$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	85 db		 test	 ebx, ebx
  0000b	0f 8e b5 00 00
	00		 jle	 $LN10@readInputB

; 1235 :         return 0;
; 1236 :     } else if( bwidth >= 1 && bwidth <= 8 ){

  00011	83 fb 08	 cmp	 ebx, 8
  00014	7f 0e		 jg	 SHORT $LN4@readInputB

; 1237 :         return readInputBitStreamBody( bwidth );

  00016	53		 push	 ebx
  00017	e8 00 00 00 00	 call	 ?readInputBitStreamBody@@YAIH@Z ; readInputBitStreamBody
  0001c	83 c4 04	 add	 esp, 4
  0001f	5f		 pop	 edi

; 1253 :     }
; 1254 : 	return 0;
; 1255 : }

  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
$LN4@readInputB:

; 1238 :     } else if( bwidth >= 9 && bwidth <= 16 ){

  00024	8d 43 f7	 lea	 eax, DWORD PTR [ebx-9]
  00027	83 f8 07	 cmp	 eax, 7
  0002a	77 1f		 ja	 SHORT $LN6@readInputB

; 1239 :         unsigned int first = readInputBitStreamBody(8);

  0002c	6a 08		 push	 8
  0002e	e8 00 00 00 00	 call	 ?readInputBitStreamBody@@YAIH@Z ; readInputBitStreamBody

; 1240 :         unsigned int second = readInputBitStreamBody( bwidth-8);

  00033	8d 4b f8	 lea	 ecx, DWORD PTR [ebx-8]
  00036	8b f0		 mov	 esi, eax
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ?readInputBitStreamBody@@YAIH@Z ; readInputBitStreamBody
  0003e	83 c4 08	 add	 esp, 8

; 1241 :         return first + (second << 8 );

  00041	c1 e0 08	 shl	 eax, 8
  00044	03 c6		 add	 eax, esi
  00046	5f		 pop	 edi

; 1253 :     }
; 1254 : 	return 0;
; 1255 : }

  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
$LN6@readInputB:

; 1242 :     } else if( bwidth >= 17 && bwidth <= 24 ){

  0004b	8d 43 ef	 lea	 eax, DWORD PTR [ebx-17]
  0004e	83 f8 07	 cmp	 eax, 7
  00051	77 2d		 ja	 SHORT $LN8@readInputB

; 1243 :         unsigned int first = readInputBitStreamBody(8);

  00053	6a 08		 push	 8
  00055	e8 00 00 00 00	 call	 ?readInputBitStreamBody@@YAIH@Z ; readInputBitStreamBody

; 1244 :         unsigned int second = readInputBitStreamBody(8);

  0005a	6a 08		 push	 8
  0005c	8b f8		 mov	 edi, eax
  0005e	e8 00 00 00 00	 call	 ?readInputBitStreamBody@@YAIH@Z ; readInputBitStreamBody

; 1245 :         unsigned int third = readInputBitStreamBody(bwidth-8);

  00063	8d 4b f8	 lea	 ecx, DWORD PTR [ebx-8]
  00066	8b f0		 mov	 esi, eax
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 ?readInputBitStreamBody@@YAIH@Z ; readInputBitStreamBody

; 1246 :         return first + ( second << 8 ) + ( third << 16 );

  0006e	c1 e0 08	 shl	 eax, 8
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH
  00074	03 c6		 add	 eax, esi
  00076	c1 e0 08	 shl	 eax, 8
  00079	03 c7		 add	 eax, edi
  0007b	5f		 pop	 edi

; 1253 :     }
; 1254 : 	return 0;
; 1255 : }

  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
$LN8@readInputB:

; 1247 :     } else if( bwidth >= 25 && bwidth <= 32 ){

  00080	8d 43 e7	 lea	 eax, DWORD PTR [ebx-25]
  00083	83 f8 07	 cmp	 eax, 7
  00086	77 3e		 ja	 SHORT $LN10@readInputB

; 1248 :         unsigned int first = readInputBitStreamBody(8);

  00088	6a 08		 push	 8
  0008a	e8 00 00 00 00	 call	 ?readInputBitStreamBody@@YAIH@Z ; readInputBitStreamBody

; 1249 :         unsigned int second = readInputBitStreamBody(8);

  0008f	6a 08		 push	 8
  00091	8b d8		 mov	 ebx, eax
  00093	e8 00 00 00 00	 call	 ?readInputBitStreamBody@@YAIH@Z ; readInputBitStreamBody

; 1250 :         unsigned int third = readInputBitStreamBody(8);

  00098	6a 08		 push	 8
  0009a	8b f8		 mov	 edi, eax
  0009c	e8 00 00 00 00	 call	 ?readInputBitStreamBody@@YAIH@Z ; readInputBitStreamBody

; 1251 :         unsigned int forth = readInputBitStreamBody(bwidth-8);

  000a1	8b 4d 08	 mov	 ecx, DWORD PTR _bwidth$[ebp]
  000a4	8b f0		 mov	 esi, eax
  000a6	83 c1 f8	 add	 ecx, -8			; fffffff8H
  000a9	51		 push	 ecx
  000aa	e8 00 00 00 00	 call	 ?readInputBitStreamBody@@YAIH@Z ; readInputBitStreamBody

; 1252 :         return first + ( second << 8 ) + ( third << 16 ) + ( forth << 24 );

  000af	c1 e0 08	 shl	 eax, 8
  000b2	83 c4 10	 add	 esp, 16			; 00000010H
  000b5	03 c6		 add	 eax, esi
  000b7	c1 e0 08	 shl	 eax, 8
  000ba	03 c7		 add	 eax, edi
  000bc	5f		 pop	 edi
  000bd	c1 e0 08	 shl	 eax, 8

; 1253 :     }
; 1254 : 	return 0;
; 1255 : }

  000c0	5e		 pop	 esi
  000c1	03 c3		 add	 eax, ebx
  000c3	5b		 pop	 ebx
  000c4	5d		 pop	 ebp
  000c5	c3		 ret	 0
$LN10@readInputB:
  000c6	5f		 pop	 edi
  000c7	5e		 pop	 esi
  000c8	33 c0		 xor	 eax, eax
  000ca	5b		 pop	 ebx
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
?readInputBitStream@@YAIH@Z ENDP			; readInputBitStream
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?readInputBitStreamBody@@YAIH@Z
_TEXT	SEGMENT
_bwidth$ = 8						; size = 4
?readInputBitStreamBody@@YAIH@Z PROC			; readInputBitStreamBody, COMDAT

; 1214 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1215 :     int mod = bitstream_bitaddr % 8;

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bitstream_bitaddr@@3HA ; bitstream_bitaddr
  00008	53		 push	 ebx
  00009	8b d8		 mov	 ebx, eax
  0000b	81 e3 07 00 00
	80		 and	 ebx, -2147483641	; 80000007H
  00011	79 05		 jns	 SHORT $LN6@readInputB
  00013	4b		 dec	 ebx
  00014	83 cb f8	 or	 ebx, -8			; fffffff8H
  00017	43		 inc	 ebx
$LN6@readInputB:

; 1216 :     int byteaddr = bitstream_bitaddr / 8;

  00018	99		 cdq
  00019	83 e2 07	 and	 edx, 7
  0001c	03 d0		 add	 edx, eax
  0001e	c1 fa 03	 sar	 edx, 3

; 1217 :     /* return if excess */
; 1218 :     if( byteaddr >= bitstream_maxbyte)return 0;

  00021	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?bitstream_maxbyte@@3HA ; bitstream_maxbyte
  00027	7d 4c		 jge	 SHORT $LN3@readInputB

; 1219 :     if( bwidth >= 1 && bwidth <= 8){

  00029	8b 45 08	 mov	 eax, DWORD PTR _bwidth$[ebp]
  0002c	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  0002f	83 f9 07	 cmp	 ecx, 7
  00032	77 41		 ja	 SHORT $LN3@readInputB

; 1220 :         int b1 = (( bitstream_buf[byteaddr] & lssproto_modifymask_first[mod][bwidth] )>>mod);

  00034	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?bitstream_buf@@3PADA ; bitstream_buf
  0003a	8b cb		 mov	 ecx, ebx
  0003c	56		 push	 esi
  0003d	8d 34 d8	 lea	 esi, DWORD PTR [eax+ebx*8]
  00040	03 f3		 add	 esi, ebx
  00042	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00045	57		 push	 edi
  00046	8b 3c b5 00 00
	00 00		 mov	 edi, DWORD PTR ?lssproto_modifymask_first@@3PAY08HA[esi*4]
  0004d	23 f8		 and	 edi, eax

; 1221 :         int b2 = (( bitstream_buf[byteaddr+1] & lssproto_modifymask_second[mod][bwidth])<<(8-mod));

  0004f	0f be 42 01	 movsx	 eax, BYTE PTR [edx+1]
  00053	23 04 b5 00 00
	00 00		 and	 eax, DWORD PTR ?lssproto_modifymask_second@@3PAY08HA[esi*4]
  0005a	d3 ff		 sar	 edi, cl
  0005c	b9 08 00 00 00	 mov	 ecx, 8
  00061	2b cb		 sub	 ecx, ebx
  00063	d3 e0		 shl	 eax, cl

; 1222 :         bitstream_bitaddr += bwidth;

  00065	8b 4d 08	 mov	 ecx, DWORD PTR _bwidth$[ebp]
  00068	01 0d 00 00 00
	00		 add	 DWORD PTR ?bitstream_bitaddr@@3HA, ecx ; bitstream_bitaddr

; 1223 :         return  b1 | b2;

  0006e	0b c7		 or	 eax, edi
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx

; 1226 :     }
; 1227 : }

  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
$LN3@readInputB:

; 1224 :     } else {
; 1225 :         return 0;

  00075	33 c0		 xor	 eax, eax
  00077	5b		 pop	 ebx

; 1226 :     }
; 1227 : }

  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?readInputBitStreamBody@@YAIH@Z ENDP			; readInputBitStreamBody
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?initInputBitStream@@YAHPADH@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_buflen$ = 12						; size = 4
?initInputBitStream@@YAHPADH@Z PROC			; initInputBitStream, COMDAT

; 1203 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1204 :     bitstream_bitaddr = 0;
; 1205 :     bitstream_maxbyte = buflen;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _buflen$[ebp]
  00006	a3 00 00 00 00	 mov	 DWORD PTR ?bitstream_maxbyte@@3HA, eax ; bitstream_maxbyte

; 1206 :     bitstream_buf = buf;

  0000b	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0000e	a3 00 00 00 00	 mov	 DWORD PTR ?bitstream_buf@@3PADA, eax ; bitstream_buf

; 1207 :     return 0;

  00013	33 c0		 xor	 eax, eax
  00015	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bitstream_bitaddr@@3HA, 0 ; bitstream_bitaddr

; 1208 : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?initInputBitStream@@YAHPADH@Z ENDP			; initInputBitStream
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?initOutputBitStream@@YAHPADH@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_buflen$ = 12						; size = 4
?initOutputBitStream@@YAHPADH@Z PROC			; initOutputBitStream, COMDAT

; 1194 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1195 :     bitstream_bitaddr = 0;
; 1196 :     bitstream_maxbyte = buflen;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _buflen$[ebp]

; 1197 :     bitstream_buf = buf;

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]

; 1198 :     memset( buf,0, buflen);

  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	51		 push	 ecx
  0000d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bitstream_bitaddr@@3HA, 0 ; bitstream_bitaddr
  00017	a3 00 00 00 00	 mov	 DWORD PTR ?bitstream_maxbyte@@3HA, eax ; bitstream_maxbyte
  0001c	89 0d 00 00 00
	00		 mov	 DWORD PTR ?bitstream_buf@@3PADA, ecx ; bitstream_buf
  00022	e8 00 00 00 00	 call	 _memset
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1199 :     return 0;

  0002a	33 c0		 xor	 eax, eax

; 1200 : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?initOutputBitStream@@YAHPADH@Z ENDP			; initOutputBitStream
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_jEncode@@YAXPADHH0PAHH@Z
_TEXT	SEGMENT
tv431 = -4						; size = 4
_src$ = 8						; size = 4
tv447 = 12						; size = 4
_src$1$ = 12						; size = 4
_srclen$ = 12						; size = 4
_key$ = 16						; size = 4
_encoded$ = 20						; size = 4
_encodedlen$ = 24					; size = 4
tv423 = 28						; size = 4
_maxencodedlen$ = 28					; size = 4
?lssproto_jEncode@@YAXPADHH0PAHH@Z PROC			; lssproto_jEncode, COMDAT

; 868  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 869  : 	char sum=0;
; 870  : 	int i;
; 871  : 	if(srclen+1 > maxencodedlen){

  00004	8b 4d 1c	 mov	 ecx, DWORD PTR _maxencodedlen$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 7d 0c	 mov	 edi, DWORD PTR _srclen$[ebp]
  0000d	32 ff		 xor	 bh, bh
  0000f	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00012	3b c1		 cmp	 eax, ecx
  00014	7e 2f		 jle	 SHORT $LN38@lssproto_j

; 872  : 		*encodedlen = maxencodedlen;

  00016	8b 7d 18	 mov	 edi, DWORD PTR _encodedlen$[ebp]

; 873  : 		for(i=0;i<(*encodedlen);i++)encoded[i] = src[i];

  00019	33 d2		 xor	 edx, edx
  0001b	89 0f		 mov	 DWORD PTR [edi], ecx
  0001d	85 c9		 test	 ecx, ecx
  0001f	0f 8e 2e 01 00
	00		 jle	 $LN9@lssproto_j
  00025	8b 75 08	 mov	 esi, DWORD PTR _src$[ebp]
  00028	8b 4d 14	 mov	 ecx, DWORD PTR _encoded$[ebp]
  0002b	2b f1		 sub	 esi, ecx
  0002d	0f 1f 00	 npad	 3
$LL4@lssproto_j:
  00030	8a 04 0e	 mov	 al, BYTE PTR [esi+ecx]
  00033	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00036	88 41 ff	 mov	 BYTE PTR [ecx-1], al
  00039	42		 inc	 edx
  0003a	3b 17		 cmp	 edx, DWORD PTR [edi]
  0003c	7c f2		 jl	 SHORT $LL4@lssproto_j

; 885  : 		}
; 886  : 	}
; 887  : }

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
$LN38@lssproto_j:

; 874  : 	}
; 875  : 	if(srclen+1 <= maxencodedlen){
; 876  : 		*encodedlen=srclen+1;

  00045	8b 4d 18	 mov	 ecx, DWORD PTR _encodedlen$[ebp]
  00048	33 f6		 xor	 esi, esi
  0004a	89 01		 mov	 DWORD PTR [ecx], eax

; 877  : 		for(i=0;i<srclen;i++){

  0004c	8b 4d 10	 mov	 ecx, DWORD PTR _key$[ebp]
  0004f	85 ff		 test	 edi, edi
  00051	7e 77		 jle	 SHORT $LN6@lssproto_j
  00053	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00058	f7 e9		 imul	 ecx
  0005a	03 d1		 add	 edx, ecx
  0005c	c1 fa 02	 sar	 edx, 2
  0005f	8b ca		 mov	 ecx, edx
  00061	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00064	03 ca		 add	 ecx, edx
  00066	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0006d	2b c1		 sub	 eax, ecx
  0006f	8b 4d 10	 mov	 ecx, DWORD PTR _key$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00077	89 4d 0c	 mov	 DWORD PTR tv447[ebp], ecx
  0007a	66 0f 1f 44 00
	00		 npad	 6
$LL25@lssproto_j:

; 878  : 			sum = sum + src[i];

  00080	8a 1c 06	 mov	 bl, BYTE PTR [esi+eax]

; 879  : 			if(((key%7) == (i%5))||((key%2) == (i%2))) src[i] = ~src[i];

  00083	8b ce		 mov	 ecx, esi
  00085	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  0008a	02 fb		 add	 bh, bl
  0008c	f7 e6		 mul	 esi
  0008e	c1 ea 02	 shr	 edx, 2
  00091	8d 04 92	 lea	 eax, DWORD PTR [edx+edx*4]
  00094	2b c8		 sub	 ecx, eax
  00096	39 4d 0c	 cmp	 DWORD PTR tv447[ebp], ecx
  00099	74 18		 je	 SHORT $LN26@lssproto_j
  0009b	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  0009e	8b ce		 mov	 ecx, esi
  000a0	83 e1 01	 and	 ecx, 1
  000a3	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  000a8	79 05		 jns	 SHORT $LN43@lssproto_j
  000aa	48		 dec	 eax
  000ab	83 c8 fe	 or	 eax, -2			; fffffffeH
  000ae	40		 inc	 eax
$LN43@lssproto_j:
  000af	3b c1		 cmp	 eax, ecx
  000b1	75 0a		 jne	 SHORT $LN42@lssproto_j
$LN26@lssproto_j:
  000b3	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  000b6	f6 d3		 not	 bl
  000b8	88 1c 06	 mov	 BYTE PTR [esi+eax], bl
  000bb	eb 03		 jmp	 SHORT $LN39@lssproto_j
$LN42@lssproto_j:
  000bd	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
$LN39@lssproto_j:

; 877  : 		for(i=0;i<srclen;i++){

  000c0	46		 inc	 esi
  000c1	3b f7		 cmp	 esi, edi
  000c3	7c bb		 jl	 SHORT $LL25@lssproto_j

; 879  : 			if(((key%7) == (i%5))||((key%2) == (i%2))) src[i] = ~src[i];

  000c5	8b 45 18	 mov	 eax, DWORD PTR _encodedlen$[ebp]
  000c8	8b 00		 mov	 eax, DWORD PTR [eax]
$LN6@lssproto_j:

; 880  : 		}
; 881  : 		for(i=0;i<(*encodedlen);i++){

  000ca	33 c9		 xor	 ecx, ecx
  000cc	85 c0		 test	 eax, eax
  000ce	0f 8e 7f 00 00
	00		 jle	 $LN9@lssproto_j

; 879  : 			if(((key%7) == (i%5))||((key%2) == (i%2))) src[i] = ~src[i];

  000d4	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  000d7	99		 cdq
  000d8	f7 ff		 idiv	 edi
  000da	c7 45 1c 03 00
	00 00		 mov	 DWORD PTR tv423[ebp], 3

; 882  : 			if(abs((key%srclen)) > i) encoded[i] = src[i] + sum*((i*i)%3); 

  000e1	8b c2		 mov	 eax, edx
  000e3	c7 45 fc 07 00
	00 00		 mov	 DWORD PTR tv431[ebp], 7
  000ea	99		 cdq
  000eb	8b f8		 mov	 edi, eax
  000ed	8b 45 14	 mov	 eax, DWORD PTR _encoded$[ebp]
  000f0	33 fa		 xor	 edi, edx
  000f2	2b fa		 sub	 edi, edx
  000f4	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  000f7	2b d0		 sub	 edx, eax
  000f9	89 55 0c	 mov	 DWORD PTR _src$1$[ebp], edx
  000fc	8b 55 18	 mov	 edx, DWORD PTR _encodedlen$[ebp]
  000ff	90		 npad	 1
$LL10@lssproto_j:
  00100	3b f9		 cmp	 edi, ecx
  00102	7e 1d		 jle	 SHORT $LN41@lssproto_j
  00104	8d 34 01	 lea	 esi, DWORD PTR [ecx+eax]
  00107	8b c1		 mov	 eax, ecx
  00109	0f af c1	 imul	 eax, ecx
  0010c	99		 cdq
  0010d	f7 7d 1c	 idiv	 DWORD PTR tv423[ebp]
  00110	0f be c7	 movsx	 eax, bh
  00113	0f be d2	 movsx	 edx, dl
  00116	0f af d0	 imul	 edx, eax
  00119	8b 45 0c	 mov	 eax, DWORD PTR _src$1$[ebp]
  0011c	02 14 30	 add	 dl, BYTE PTR [eax+esi]
  0011f	eb 25		 jmp	 SHORT $LN44@lssproto_j
$LN41@lssproto_j:

; 883  : 			if(abs((key%srclen)) == i) encoded[i] = sum;

  00121	75 05		 jne	 SHORT $LN16@lssproto_j
  00123	88 3c 01	 mov	 BYTE PTR [ecx+eax], bh
  00126	eb 26		 jmp	 SHORT $LN8@lssproto_j
$LN16@lssproto_j:

; 884  : 			if(abs((key%srclen)) < i) encoded[i] = src[i-1] + sum*((i*i)%7);	

  00128	7d 24		 jge	 SHORT $LN8@lssproto_j
  0012a	8d 34 01	 lea	 esi, DWORD PTR [ecx+eax]
  0012d	8b c1		 mov	 eax, ecx
  0012f	0f af c1	 imul	 eax, ecx
  00132	99		 cdq
  00133	f7 7d fc	 idiv	 DWORD PTR tv431[ebp]
  00136	0f be c7	 movsx	 eax, bh
  00139	0f be d2	 movsx	 edx, dl
  0013c	0f af d0	 imul	 edx, eax
  0013f	8b 45 0c	 mov	 eax, DWORD PTR _src$1$[ebp]
  00142	02 54 30 ff	 add	 dl, BYTE PTR [eax+esi-1]
$LN44@lssproto_j:

; 880  : 		}
; 881  : 		for(i=0;i<(*encodedlen);i++){

  00146	8b 45 14	 mov	 eax, DWORD PTR _encoded$[ebp]
  00149	88 16		 mov	 BYTE PTR [esi], dl
  0014b	8b 55 18	 mov	 edx, DWORD PTR _encodedlen$[ebp]
$LN8@lssproto_j:
  0014e	41		 inc	 ecx
  0014f	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00151	7c ad		 jl	 SHORT $LL10@lssproto_j
$LN9@lssproto_j:
  00153	5f		 pop	 edi

; 885  : 		}
; 886  : 	}
; 887  : }

  00154	5e		 pop	 esi
  00155	5b		 pop	 ebx
  00156	8b e5		 mov	 esp, ebp
  00158	5d		 pop	 ebp
  00159	c3		 ret	 0
?lssproto_jEncode@@YAXPADHH0PAHH@Z ENDP			; lssproto_jEncode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_jDecode@@YAXPADHH0PAH@Z
_TEXT	SEGMENT
tv365 = -8						; size = 4
$T1 = -4						; size = 4
_src$ = 8						; size = 4
_srclen$ = 12						; size = 4
_key$ = 16						; size = 4
_decoded$ = 20						; size = 4
_decodedlen$ = 24					; size = 4
_sum$1$ = 27						; size = 1
?lssproto_jDecode@@YAXPADHH0PAH@Z PROC			; lssproto_jDecode, COMDAT

; 889  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	8b 5d 18	 mov	 ebx, DWORD PTR _decodedlen$[ebp]
  0000a	56		 push	 esi

; 890  : 	char sum=0;
; 891  : 	int i;
; 892  : 	*decodedlen=srclen-1;

  0000b	8b 75 0c	 mov	 esi, DWORD PTR _srclen$[ebp]
  0000e	83 c6 ff	 add	 esi, -1
  00011	89 33		 mov	 DWORD PTR [ebx], esi

; 893  : 	if( *decodedlen == 0 ){

  00013	0f 84 31 01 00
	00		 je	 $LN6@lssproto_j

; 894  : 		return;		/* return error if length is 0 */
; 895  : 	}
; 896  : 	sum = src[abs(key%(*decodedlen))];

  00019	8b 4d 10	 mov	 ecx, DWORD PTR _key$[ebp]
  0001c	8b c1		 mov	 eax, ecx
  0001e	99		 cdq
  0001f	f7 fe		 idiv	 esi
  00021	57		 push	 edi
  00022	8b c2		 mov	 eax, edx
  00024	33 ff		 xor	 edi, edi
  00026	99		 cdq
  00027	33 c2		 xor	 eax, edx
  00029	2b c2		 sub	 eax, edx
  0002b	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  0002e	8a 04 10	 mov	 al, BYTE PTR [eax+edx]
  00031	88 45 1b	 mov	 BYTE PTR _sum$1$[ebp], al

; 897  : 	for(i=0;i<srclen;i++){

  00034	39 7d 0c	 cmp	 DWORD PTR _srclen$[ebp], edi
  00037	0f 8e 9c 00 00
	00		 jle	 $LN3@lssproto_j

; 894  : 		return;		/* return error if length is 0 */
; 895  : 	}
; 896  : 	sum = src[abs(key%(*decodedlen))];

  0003d	8b 75 14	 mov	 esi, DWORD PTR _decoded$[ebp]
  00040	2b d6		 sub	 edx, esi
  00042	89 55 08	 mov	 DWORD PTR _src$[ebp], edx

; 897  : 	for(i=0;i<srclen;i++){

  00045	eb 03		 jmp	 SHORT $LN4@lssproto_j
$LL24@lssproto_j:
  00047	8b 75 14	 mov	 esi, DWORD PTR _decoded$[ebp]
$LN4@lssproto_j:

; 898  : 		if(abs((key%(*decodedlen))) > i) decoded[i] = src[i] - sum*((i*i)%3);

  0004a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0004c	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0004f	8b c7		 mov	 eax, edi
  00051	0f af c7	 imul	 eax, edi
  00054	89 45 f8	 mov	 DWORD PTR tv365[ebp], eax
  00057	8b c1		 mov	 eax, ecx
  00059	99		 cdq
  0005a	f7 3b		 idiv	 DWORD PTR [ebx]
  0005c	8b c2		 mov	 eax, edx
  0005e	99		 cdq
  0005f	33 c2		 xor	 eax, edx
  00061	2b c2		 sub	 eax, edx
  00063	3b c7		 cmp	 eax, edi
  00065	7e 2b		 jle	 SHORT $LN21@lssproto_j
  00067	8b 45 f8	 mov	 eax, DWORD PTR tv365[ebp]
  0006a	b9 03 00 00 00	 mov	 ecx, 3
  0006f	99		 cdq
  00070	03 f7		 add	 esi, edi
  00072	f7 f9		 idiv	 ecx
  00074	0f be 45 1b	 movsx	 eax, BYTE PTR _sum$1$[ebp]
  00078	0f be ca	 movsx	 ecx, dl
  0007b	0f af c8	 imul	 ecx, eax
  0007e	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00081	8a 04 30	 mov	 al, BYTE PTR [eax+esi]
  00084	2a c1		 sub	 al, cl
  00086	8b 4d 10	 mov	 ecx, DWORD PTR _key$[ebp]
  00089	88 06		 mov	 BYTE PTR [esi], al
  0008b	8b 33		 mov	 esi, DWORD PTR [ebx]
  0008d	89 75 fc	 mov	 DWORD PTR $T1[ebp], esi
  00090	eb 02		 jmp	 SHORT $LN9@lssproto_j
$LN21@lssproto_j:
  00092	8b 33		 mov	 esi, DWORD PTR [ebx]
$LN9@lssproto_j:

; 899  : 		if(abs((key%(*decodedlen))) < i) decoded[i-1] = src[i] - sum*((i*i)%7);

  00094	8b c1		 mov	 eax, ecx
  00096	99		 cdq
  00097	f7 7d fc	 idiv	 DWORD PTR $T1[ebp]
  0009a	8b c2		 mov	 eax, edx
  0009c	99		 cdq
  0009d	33 c2		 xor	 eax, edx
  0009f	2b c2		 sub	 eax, edx
  000a1	3b c7		 cmp	 eax, edi
  000a3	7d 2a		 jge	 SHORT $LN2@lssproto_j
  000a5	8b 45 f8	 mov	 eax, DWORD PTR tv365[ebp]
  000a8	b9 07 00 00 00	 mov	 ecx, 7
  000ad	99		 cdq
  000ae	f7 f9		 idiv	 ecx
  000b0	0f be 45 1b	 movsx	 eax, BYTE PTR _sum$1$[ebp]
  000b4	8b 75 14	 mov	 esi, DWORD PTR _decoded$[ebp]
  000b7	03 f7		 add	 esi, edi
  000b9	0f be ca	 movsx	 ecx, dl
  000bc	0f af c8	 imul	 ecx, eax
  000bf	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  000c2	8a 04 30	 mov	 al, BYTE PTR [eax+esi]
  000c5	2a c1		 sub	 al, cl
  000c7	8b 4d 10	 mov	 ecx, DWORD PTR _key$[ebp]
  000ca	88 46 ff	 mov	 BYTE PTR [esi-1], al
  000cd	8b 33		 mov	 esi, DWORD PTR [ebx]
$LN2@lssproto_j:

; 897  : 	for(i=0;i<srclen;i++){

  000cf	47		 inc	 edi
  000d0	3b 7d 0c	 cmp	 edi, DWORD PTR _srclen$[ebp]
  000d3	0f 8c 6e ff ff
	ff		 jl	 $LL24@lssproto_j
$LN3@lssproto_j:

; 900  : 	}
; 901  : 	for(i=0;i<(*decodedlen);i++){

  000d9	33 c9		 xor	 ecx, ecx
  000db	85 f6		 test	 esi, esi
  000dd	7e 6a		 jle	 SHORT $LN25@lssproto_j
  000df	8b 7d 10	 mov	 edi, DWORD PTR _key$[ebp]
  000e2	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  000e7	f7 ef		 imul	 edi
  000e9	03 d7		 add	 edx, edi
  000eb	c1 fa 02	 sar	 edx, 2
  000ee	8b f2		 mov	 esi, edx
  000f0	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  000f3	03 f2		 add	 esi, edx
  000f5	8d 04 f5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*8]
  000fc	2b c6		 sub	 eax, esi
  000fe	8b f7		 mov	 esi, edi
  00100	2b f0		 sub	 esi, eax
$LL7@lssproto_j:

; 902  : 		if(((key%7) == (i%5))||((key%2) == (i%2)))decoded[i] = ~decoded[i];

  00102	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00107	f7 e9		 imul	 ecx
  00109	d1 fa		 sar	 edx, 1
  0010b	8b c2		 mov	 eax, edx
  0010d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00110	03 c2		 add	 eax, edx
  00112	8b d1		 mov	 edx, ecx
  00114	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00117	2b d0		 sub	 edx, eax
  00119	3b f2		 cmp	 esi, edx
  0011b	74 21		 je	 SHORT $LN12@lssproto_j
  0011d	8b d1		 mov	 edx, ecx
  0011f	81 e2 01 00 00
	80		 and	 edx, -2147483647	; 80000001H
  00125	79 05		 jns	 SHORT $LN26@lssproto_j
  00127	4a		 dec	 edx
  00128	83 ca fe	 or	 edx, -2			; fffffffeH
  0012b	42		 inc	 edx
$LN26@lssproto_j:
  0012c	8b c7		 mov	 eax, edi
  0012e	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00133	79 05		 jns	 SHORT $LN27@lssproto_j
  00135	48		 dec	 eax
  00136	83 c8 fe	 or	 eax, -2			; fffffffeH
  00139	40		 inc	 eax
$LN27@lssproto_j:
  0013a	3b c2		 cmp	 eax, edx
  0013c	75 06		 jne	 SHORT $LN5@lssproto_j
$LN12@lssproto_j:
  0013e	8b 55 14	 mov	 edx, DWORD PTR _decoded$[ebp]
  00141	f6 14 11	 not	 BYTE PTR [ecx+edx]
$LN5@lssproto_j:

; 900  : 	}
; 901  : 	for(i=0;i<(*decodedlen);i++){

  00144	41		 inc	 ecx
  00145	3b 0b		 cmp	 ecx, DWORD PTR [ebx]
  00147	7c b9		 jl	 SHORT $LL7@lssproto_j
$LN25@lssproto_j:
  00149	5f		 pop	 edi
$LN6@lssproto_j:
  0014a	5e		 pop	 esi

; 903  : 	}
; 904  : }

  0014b	5b		 pop	 ebx
  0014c	8b e5		 mov	 esp, ebp
  0014e	5d		 pop	 ebp
  0014f	c3		 ret	 0
?lssproto_jDecode@@YAXPADHH0PAH@Z ENDP			; lssproto_jDecode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_decode64@@YAHPAE0@Z
_TEXT	SEGMENT
tv685 = 8						; size = 4
_in$ = 8						; size = 4
_out$ = 12						; size = 4
?lssproto_decode64@@YAHPAE0@Z PROC			; lssproto_decode64, COMDAT

; 818  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 825  :         if( in[i] == 0 ){

  00004	8b 75 08	 mov	 esi, DWORD PTR _in$[ebp]
  00007	33 c0		 xor	 eax, eax
  00009	38 06		 cmp	 BYTE PTR [esi], al
  0000b	0f 84 bf 00 00
	00		 je	 $LN20@lssproto_d

; 819  :     unsigned char in1 , in2 , in3 , in4;
; 820  :     unsigned char out1 , out2 , out3;
; 821  :     int use_bytes;
; 822  :     int address= 0;
; 823  :     int i;
; 824  :     for(i=0;;i+=4 ){

  00011	83 c6 02	 add	 esi, 2
  00014	53		 push	 ebx
  00015	89 75 08	 mov	 DWORD PTR tv685[ebp], esi
  00018	57		 push	 edi
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@lssproto_d:

; 826  :             break;
; 827  :         } else if( in[i+1] == 0 ){   /* the last letter */

  00020	8a 5e ff	 mov	 bl, BYTE PTR [esi-1]
  00023	84 db		 test	 bl, bl
  00025	0f 84 a3 00 00
	00		 je	 $LN30@lssproto_d

; 828  :             break;
; 829  :         } else if( in[i+2] == 0 ){   /* the last 2 letters */

  0002b	8a 0e		 mov	 cl, BYTE PTR [esi]
  0002d	84 c9		 test	 cl, cl
  0002f	75 0b		 jne	 SHORT $LN9@lssproto_d

; 830  :             in1 = lssproto_reversecharset[in[i]];
; 831  :             in2 = lssproto_reversecharset[in[i+1]];
; 832  :             in3 = in4 = 0;

  00031	32 f6		 xor	 dh, dh

; 833  :             use_bytes = 1;

  00033	bf 01 00 00 00	 mov	 edi, 1
  00038	32 ff		 xor	 bh, bh
  0003a	eb 29		 jmp	 SHORT $LN12@lssproto_d
$LN9@lssproto_d:

; 834  :         } else if( in[i+3] == 0 ){   /* the last  3 letters */

  0003c	8a 56 01	 mov	 dl, BYTE PTR [esi+1]
  0003f	0f b6 c9	 movzx	 ecx, cl
  00042	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?lssproto_reversecharset@@3PADA ; lssproto_reversecharset
  00048	8a 39		 mov	 bh, BYTE PTR [ecx]
  0004a	84 d2		 test	 dl, dl
  0004c	75 09		 jne	 SHORT $LN11@lssproto_d

; 835  :             in1 = lssproto_reversecharset[in[i]];
; 836  :             in2 = lssproto_reversecharset[in[i+1]];
; 837  :             in3 = lssproto_reversecharset[in[i+2]];
; 838  :             in4 = 0;

  0004e	32 f6		 xor	 dh, dh

; 839  :             use_bytes = 2;

  00050	bf 02 00 00 00	 mov	 edi, 2

; 840  :         } else {   /* process 4 letters */

  00055	eb 0e		 jmp	 SHORT $LN12@lssproto_d
$LN11@lssproto_d:

; 841  :             in1 = lssproto_reversecharset[in[i]];
; 842  :             in2 = lssproto_reversecharset[in[i+1]];
; 843  :             in3 = lssproto_reversecharset[in[i+2]];
; 844  :             in4 = lssproto_reversecharset[in[i+3]];

  00057	0f b6 ca	 movzx	 ecx, dl

; 845  :             use_bytes = 3;

  0005a	bf 03 00 00 00	 mov	 edi, 3
  0005f	8a b1 00 00 00
	00		 mov	 dh, BYTE PTR ?lssproto_reversecharset@@3PADA[ecx]
$LN12@lssproto_d:

; 846  :         }
; 847  :         out1 =  (in1<<2) | (((in2 & 0x30)>>4)&0x0f) ;
; 848  :         out2 =  ((in2 & 0x0f )<<4) | ((( in3 & 0x3c)>>2)&0x0f);

  00065	0f b6 cb	 movzx	 ecx, bl

; 849  :         out3 =  ( (in3 &0x03)<<6) |  ( in4 & 0x3f );

  00068	80 e6 3f	 and	 dh, 63			; 0000003fH
  0006b	8a 99 00 00 00
	00		 mov	 bl, BYTE PTR ?lssproto_reversecharset@@3PADA[ecx]
  00071	0f b6 4e fe	 movzx	 ecx, BYTE PTR [esi-2]

; 850  :         if( use_bytes >= 1 ){
; 851  :             out[address++] = out1;

  00075	8b 75 0c	 mov	 esi, DWORD PTR _out$[ebp]
  00078	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR ?lssproto_reversecharset@@3PADA[ecx]
  0007e	8a cb		 mov	 cl, bl
  00080	c0 eb 04	 shr	 bl, 4
  00083	8a ef		 mov	 ch, bh
  00085	80 e3 03	 and	 bl, 3
  00088	c0 ed 02	 shr	 ch, 2
  0008b	c0 e2 02	 shl	 dl, 2
  0008e	80 e5 0f	 and	 ch, 15			; 0000000fH
  00091	0a da		 or	 bl, dl
  00093	c0 e7 06	 shl	 bh, 6
  00096	c0 e1 04	 shl	 cl, 4
  00099	0a f7		 or	 dh, bh
  0009b	88 1c 30	 mov	 BYTE PTR [eax+esi], bl
  0009e	0a e9		 or	 ch, cl

; 852  :         }
; 853  :         if( use_bytes >= 2 ){

  000a0	8b 75 08	 mov	 esi, DWORD PTR tv685[ebp]
  000a3	40		 inc	 eax
  000a4	8b 5d 0c	 mov	 ebx, DWORD PTR _out$[ebp]
  000a7	83 ff 02	 cmp	 edi, 2
  000aa	72 04		 jb	 SHORT $LN14@lssproto_d

; 854  :             out[address++] = out2;

  000ac	88 2c 18	 mov	 BYTE PTR [eax+ebx], ch
  000af	40		 inc	 eax
$LN14@lssproto_d:

; 855  :         }
; 856  :         if( use_bytes >= 3 ){

  000b0	83 ff 03	 cmp	 edi, 3
  000b3	72 19		 jb	 SHORT $LN30@lssproto_d

; 857  :             out[address++] = out3;

  000b5	88 34 18	 mov	 BYTE PTR [eax+ebx], dh
  000b8	40		 inc	 eax

; 858  :         }
; 859  :         if( use_bytes != 3 ){

  000b9	83 ff 03	 cmp	 edi, 3
  000bc	75 10		 jne	 SHORT $LN30@lssproto_d

; 819  :     unsigned char in1 , in2 , in3 , in4;
; 820  :     unsigned char out1 , out2 , out3;
; 821  :     int use_bytes;
; 822  :     int address= 0;
; 823  :     int i;
; 824  :     for(i=0;;i+=4 ){

  000be	83 c6 04	 add	 esi, 4
  000c1	89 75 08	 mov	 DWORD PTR tv685[ebp], esi

; 825  :         if( in[i] == 0 ){

  000c4	80 7e fe 00	 cmp	 BYTE PTR [esi-2], 0
  000c8	0f 85 52 ff ff
	ff		 jne	 $LL4@lssproto_d
$LN30@lssproto_d:
  000ce	5f		 pop	 edi
  000cf	5b		 pop	 ebx
$LN20@lssproto_d:
  000d0	5e		 pop	 esi

; 860  :             break;
; 861  :         }
; 862  :     }
; 863  :     return address;
; 864  : }

  000d1	5d		 pop	 ebp
  000d2	c3		 ret	 0
?lssproto_decode64@@YAHPAE0@Z ENDP			; lssproto_decode64
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_encode64@@YAXPAEH0@Z
_TEXT	SEGMENT
_in$ = 8						; size = 4
_len$ = 12						; size = 4
_out$ = 16						; size = 4
_out3$1$ = 19						; size = 1
?lssproto_encode64@@YAXPAEH0@Z PROC			; lssproto_encode64, COMDAT

; 765  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 766  :     int i;
; 767  :     int use_bytes;
; 768  :     int address = 0;
; 769  :     out[0] = 0;

  00003	8b 45 10	 mov	 eax, DWORD PTR _out$[ebp]
  00006	57		 push	 edi

; 771  :         unsigned char in1 , in2 , in3;
; 772  :         unsigned char out1 ,out2 , out3 , out4;
; 773  :         if( i >= len ) break;

  00007	8b 7d 0c	 mov	 edi, DWORD PTR _len$[ebp]
  0000a	c6 00 00	 mov	 BYTE PTR [eax], 0
  0000d	85 ff		 test	 edi, edi
  0000f	0f 8e c6 00 00
	00		 jle	 $LN16@lssproto_e

; 766  :     int i;
; 767  :     int use_bytes;
; 768  :     int address = 0;
; 769  :     out[0] = 0;

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _in$[ebp]
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	8d 5f ff	 lea	 ebx, DWORD PTR [edi-1]
  0001d	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  00020	f7 d1		 not	 ecx
  00022	89 4d 08	 mov	 DWORD PTR _in$[ebp], ecx
$LL4@lssproto_e:

; 774  :         if( i >= (len-1)){   /* the last letter ( to be thrown away ) */

  00025	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  00028	3b d3		 cmp	 edx, ebx
  0002a	7c 0b		 jl	 SHORT $LN6@lssproto_e

; 775  :             in1 = in[i] & 0xff;
; 776  :             in2 = in3 = 0;

  0002c	32 db		 xor	 bl, bl

; 777  :             use_bytes = 2;

  0002e	bf 02 00 00 00	 mov	 edi, 2
  00033	32 ff		 xor	 bh, bh
  00035	eb 1a		 jmp	 SHORT $LN9@lssproto_e
$LN6@lssproto_e:

; 778  :         } else if( i >= (len-2)){ /* the last 2 letters ( process only 1 byte)*/

  00037	8a 3e		 mov	 bh, BYTE PTR [esi]
  00039	8d 4f fe	 lea	 ecx, DWORD PTR [edi-2]
  0003c	3b d1		 cmp	 edx, ecx
  0003e	7c 09		 jl	 SHORT $LN8@lssproto_e

; 779  :             in1 = in[i] & 0xff;
; 780  :             in2 = in[i+1] & 0xff;
; 781  :             in3 = 0;

  00040	32 db		 xor	 bl, bl

; 782  :             use_bytes = 3;

  00042	bf 03 00 00 00	 mov	 edi, 3

; 783  :         } else {                /* there are more or equal than 3 letters */

  00047	eb 08		 jmp	 SHORT $LN9@lssproto_e
$LN8@lssproto_e:

; 784  :             in1 = in[i] & 0xff;
; 785  :             in2 = in[i+1] & 0xff;
; 786  :             in3 = in[i+2] & 0xff;

  00049	8a 5e 01	 mov	 bl, BYTE PTR [esi+1]

; 787  :             use_bytes = 4;

  0004c	bf 04 00 00 00	 mov	 edi, 4
$LN9@lssproto_e:

; 788  :         }
; 789  :         out1 = ((in1 & 0xfc)>>2) & 0x3f;
; 790  :         out2 = ((in1 & 0x03)<<4) | ((( in2 & 0xf0)>>4)&0x0f);
; 791  :         out3 = ((in2 & 0x0f)<<2) | ((( in3 & 0xc0)>>6)&0x03);

  00051	8a 56 ff	 mov	 dl, BYTE PTR [esi-1]
  00054	8a ef		 mov	 ch, bh
  00056	80 e5 0f	 and	 ch, 15			; 0000000fH
  00059	8a cb		 mov	 cl, bl
  0005b	c0 e9 06	 shr	 cl, 6

; 792  :         out4 = (in3 & 0x3f );

  0005e	80 e3 3f	 and	 bl, 63			; 0000003fH
  00061	c0 e5 02	 shl	 ch, 2
  00064	0a e9		 or	 ch, cl
  00066	88 6d 13	 mov	 BYTE PTR _out3$1$[ebp], ch
  00069	0f b6 ca	 movzx	 ecx, dl
  0006c	80 e2 03	 and	 dl, 3
  0006f	c1 e9 02	 shr	 ecx, 2
  00072	c0 e2 04	 shl	 dl, 4
  00075	0f b6 d2	 movzx	 edx, dl

; 793  :         if( use_bytes >= 2 ){
; 794  :             out[address++] = lssproto_charset[out1];

  00078	8a 89 00 00 00
	00		 mov	 cl, BYTE PTR ?lssproto_charset@@3PADA[ecx]
  0007e	88 08		 mov	 BYTE PTR [eax], cl
  00080	0f b6 cf	 movzx	 ecx, bh
  00083	c1 e9 04	 shr	 ecx, 4
  00086	0b d1		 or	 edx, ecx

; 795  :             out[address++] = lssproto_charset[out2];

  00088	8a 8a 00 00 00
	00		 mov	 cl, BYTE PTR ?lssproto_charset@@3PADA[edx]
  0008e	88 48 01	 mov	 BYTE PTR [eax+1], cl
  00091	83 c0 02	 add	 eax, 2

; 796  :             out[address]=0;

  00094	c6 00 00	 mov	 BYTE PTR [eax], 0

; 797  :         }
; 798  :         if( use_bytes >= 3 ){

  00097	83 ff 03	 cmp	 edi, 3
  0009a	72 10		 jb	 SHORT $LN11@lssproto_e

; 799  :             out[address++] = lssproto_charset[out3];

  0009c	0f b6 4d 13	 movzx	 ecx, BYTE PTR _out3$1$[ebp]
  000a0	8a 89 00 00 00
	00		 mov	 cl, BYTE PTR ?lssproto_charset@@3PADA[ecx]
  000a6	88 08		 mov	 BYTE PTR [eax], cl
  000a8	40		 inc	 eax

; 800  :             out[address]=0;

  000a9	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN11@lssproto_e:

; 801  :         }
; 802  :         if( use_bytes >= 4 ){

  000ac	83 ff 04	 cmp	 edi, 4
  000af	72 0f		 jb	 SHORT $LN2@lssproto_e

; 803  :             out[address++] = lssproto_charset[out4];

  000b1	0f b6 cb	 movzx	 ecx, bl
  000b4	8a 89 00 00 00
	00		 mov	 cl, BYTE PTR ?lssproto_charset@@3PADA[ecx]
  000ba	88 08		 mov	 BYTE PTR [eax], cl
  000bc	40		 inc	 eax

; 804  :             out[address]=0;

  000bd	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN2@lssproto_e:

; 770  :     for(i=0;;i+=3){

  000c0	8b 7d 0c	 mov	 edi, DWORD PTR _len$[ebp]
  000c3	83 c6 03	 add	 esi, 3

; 771  :         unsigned char in1 , in2 , in3;
; 772  :         unsigned char out1 ,out2 , out3 , out4;
; 773  :         if( i >= len ) break;

  000c6	8b 4d 08	 mov	 ecx, DWORD PTR _in$[ebp]
  000c9	03 ce		 add	 ecx, esi
  000cb	3b cf		 cmp	 ecx, edi
  000cd	8b 4d 08	 mov	 ecx, DWORD PTR _in$[ebp]
  000d0	8d 5f ff	 lea	 ebx, DWORD PTR [edi-1]
  000d3	0f 8c 4c ff ff
	ff		 jl	 $LL4@lssproto_e
  000d9	5e		 pop	 esi
  000da	5b		 pop	 ebx
$LN16@lssproto_e:
  000db	5f		 pop	 edi

; 805  :         }
; 806  :     }
; 807  : }

  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
?lssproto_encode64@@YAXPAEH0@Z ENDP			; lssproto_encode64
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_encodeString@@YAXPAD0H@Z
_TEXT	SEGMENT
_jencodedlen$ = -4					; size = 4
_src$ = 8						; size = 4
_out$ = 12						; size = 4
_maxoutlen$ = 16					; size = 4
?lssproto_encodeString@@YAXPAD0H@Z PROC			; lssproto_encodeString, COMDAT

; 654  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 655  :     int jencodedlen=0;
; 656  :     long compressed_l = 0;
; 657  : 	int srclen = strlen( src ) + 1;

  00007	8b 7d 08	 mov	 edi, DWORD PTR _src$[ebp]
  0000a	8b cf		 mov	 ecx, edi
  0000c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _jencodedlen$[ebp], 0
  00013	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL10@lssproto_e:
  00016	8a 01		 mov	 al, BYTE PTR [ecx]
  00018	41		 inc	 ecx
  00019	84 c0		 test	 al, al
  0001b	75 f9		 jne	 SHORT $LL10@lssproto_e
  0001d	2b ca		 sub	 ecx, edx
  0001f	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]

; 658  :     int flag=srclen;

  00022	8b da		 mov	 ebx, edx

; 659  : 	if( srclen < 100 ){

  00024	83 fa 64	 cmp	 edx, 100		; 00000064H
  00027	7d 4a		 jge	 SHORT $LN2@lssproto_e

; 660  : 		if( (int)srclen > (int)( lssproto.workbufsize*3-2) ){

  00029	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  0002e	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00031	83 c0 fe	 add	 eax, -2			; fffffffeH
  00034	3b d0		 cmp	 edx, eax
  00036	0f 8f e3 00 00
	00		 jg	 $LN15@lssproto_e

; 663  : 		}
; 664  : 		if( (flag%2) == 1 ) flag ++;

  0003c	8b c2		 mov	 eax, edx
  0003e	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00043	79 05		 jns	 SHORT $LN12@lssproto_e
  00045	48		 dec	 eax
  00046	83 c8 fe	 or	 eax, -2			; fffffffeH
  00049	40		 inc	 eax
$LN12@lssproto_e:
  0004a	83 f8 01	 cmp	 eax, 1
  0004d	75 07		 jne	 SHORT $LN9@lssproto_e
  0004f	8d 5a 01	 lea	 ebx, DWORD PTR [edx+1]
  00052	8b f3		 mov	 esi, ebx
  00054	eb 03		 jmp	 SHORT $LN5@lssproto_e
$LN9@lssproto_e:
  00056	8d 71 02	 lea	 esi, DWORD PTR [ecx+2]
$LN5@lssproto_e:

; 665  : 		lssproto.compresswork[0] = flag;

  00059	a1 28 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+40

; 666  : 		memcpy( lssproto.compresswork+1,src,srclen );

  0005e	52		 push	 edx
  0005f	57		 push	 edi
  00060	88 18		 mov	 BYTE PTR [eax], bl
  00062	a1 28 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+40
  00067	40		 inc	 eax
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 _memcpy
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 667  : 		compressed_l = srclen + 1;
; 668  : 	} else {

  00071	eb 3c		 jmp	 SHORT $LN3@lssproto_e
$LN2@lssproto_e:

; 669  : 		if((flag%2)==0)flag++;
; 670  : 		lssproto.compresswork[0] = flag;

  00073	a1 28 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+40
  00078	f6 d2		 not	 dl
  0007a	80 e2 01	 and	 dl, 1
  0007d	fe c1		 inc	 cl
  0007f	02 d1		 add	 dl, cl

; 671  :         compressed_l = lssproto_ringoCompressor(

  00081	8b cf		 mov	 ecx, edi
  00083	88 10		 mov	 BYTE PTR [eax], dl
  00085	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL11@lssproto_e:
  00088	8a 01		 mov	 al, BYTE PTR [ecx]
  0008a	41		 inc	 ecx
  0008b	84 c0		 test	 al, al
  0008d	75 f9		 jne	 SHORT $LL11@lssproto_e
  0008f	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00094	2b ca		 sub	 ecx, edx
  00096	51		 push	 ecx
  00097	57		 push	 edi
  00098	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0009b	48		 dec	 eax
  0009c	50		 push	 eax
  0009d	a1 28 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+40
  000a2	40		 inc	 eax
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 ?lssproto_ringoCompressor@@YAJPAEJ0J@Z ; lssproto_ringoCompressor
  000a9	83 c4 10	 add	 esp, 16			; 00000010H
  000ac	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$LN3@lssproto_e:

; 672  :             (unsigned char*)lssproto.compresswork + 1 ,
; 673  : 		    (long)lssproto.workbufsize*3 - 1,
; 674  :             (unsigned char*)src ,
; 675  :            (long)strlen(src) ) + 1;    /* be careful! */
; 676  : 	}
; 677  : 	/* return empty line if error or buffer excess */
; 678  : 	if( compressed_l <= 0 ){

  000af	85 f6		 test	 esi, esi
  000b1	7f 1a		 jg	 SHORT $LN7@lssproto_e

; 679  : 		lssproto_strcpysafe( out , "\n" , maxoutlen );

  000b3	ff 75 10	 push	 DWORD PTR _maxoutlen$[ebp]
  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  000bb	ff 75 0c	 push	 DWORD PTR _out$[ebp]
  000be	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe
  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c6	5f		 pop	 edi

; 686  : }

  000c7	5e		 pop	 esi
  000c8	5b		 pop	 ebx
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
$LN7@lssproto_e:

; 680  : 		return;
; 681  : 	}
; 682  :     memcpy( lssproto.jencodecopy ,lssproto.compresswork ,compressed_l );

  000cd	56		 push	 esi
  000ce	ff 35 28 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+40
  000d4	ff 35 20 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+32
  000da	e8 00 00 00 00	 call	 _memcpy

; 683  :     lssproto_jEncode( lssproto.jencodecopy , compressed_l , JENCODE_KEY ,

  000df	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  000e4	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  000e7	48		 dec	 eax
  000e8	50		 push	 eax
  000e9	8d 45 fc	 lea	 eax, DWORD PTR _jencodedlen$[ebp]
  000ec	50		 push	 eax
  000ed	ff 35 24 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+36
  000f3	68 13 3d 12 03	 push	 51526931		; 03123d13H
  000f8	56		 push	 esi
  000f9	ff 35 20 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+32
  000ff	e8 00 00 00 00	 call	 ?lssproto_jEncode@@YAXPADHH0PAHH@Z ; lssproto_jEncode

; 684  : 	    lssproto.jencodeout, &jencodedlen , lssproto.workbufsize*3 -1 );
; 685  :     lssproto_encode64( (unsigned char*)lssproto.jencodeout , jencodedlen,  (unsigned char*)out );

  00104	ff 75 0c	 push	 DWORD PTR _out$[ebp]
  00107	ff 75 fc	 push	 DWORD PTR _jencodedlen$[ebp]
  0010a	ff 35 24 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+36
  00110	e8 00 00 00 00	 call	 ?lssproto_encode64@@YAXPAEH0@Z ; lssproto_encode64
  00115	83 c4 30	 add	 esp, 48			; 00000030H
  00118	5f		 pop	 edi

; 686  : }

  00119	5e		 pop	 esi
  0011a	5b		 pop	 ebx
  0011b	8b e5		 mov	 esp, ebp
  0011d	5d		 pop	 ebp
  0011e	c3		 ret	 0
$LN15@lssproto_e:

; 661  : 			fprintf( stderr, "lsgen: badly configured work buflen\n" );

  0011f	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NBLKNCEA@lsgen?3?5badly?5configured?5work?5bu@
  00124	6a 02		 push	 2
  00126	e8 00 00 00 00	 call	 ___acrt_iob_func
  0012b	83 c4 04	 add	 esp, 4
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 _fprintf
  00134	83 c4 08	 add	 esp, 8

; 662  : 			exit(1);

  00137	6a 01		 push	 1
  00139	e8 00 00 00 00	 call	 _exit
$LN13@lssproto_e:
  0013e	cc		 int	 3
?lssproto_encodeString@@YAXPAD0H@Z ENDP			; lssproto_encodeString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_decodeString@@YAXPAD0@Z
_TEXT	SEGMENT
_compressed_l$ = -4					; size = 4
_src$ = 8						; size = 4
_out$ = 12						; size = 4
?lssproto_decodeString@@YAXPAD0@Z PROC			; lssproto_decodeString, COMDAT

; 689  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 690  :     int compressed_l =0, outlen64;
; 691  :     int l;
; 692  :     long decompressed_l = 0;
; 693  :     /* copy src to copybuffer because jencoder modifies the input buffer */
; 694  :     l = strlen( src );

  00005	8b 75 08	 mov	 esi, DWORD PTR _src$[ebp]
  00008	8b ce		 mov	 ecx, esi
  0000a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _compressed_l$[ebp], 0
  00011	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL11@lssproto_d:
  00014	8a 01		 mov	 al, BYTE PTR [ecx]
  00016	41		 inc	 ecx
  00017	84 c0		 test	 al, al
  00019	75 f9		 jne	 SHORT $LL11@lssproto_d
  0001b	2b ca		 sub	 ecx, edx

; 695  :     if( src[l-1]=='\n' || src[l-1]=='\r' )src[l-1]=0;

  0001d	8a 44 31 ff	 mov	 al, BYTE PTR [ecx+esi-1]
  00021	3c 0a		 cmp	 al, 10			; 0000000aH
  00023	74 04		 je	 SHORT $LN3@lssproto_d
  00025	3c 0d		 cmp	 al, 13			; 0000000dH
  00027	75 05		 jne	 SHORT $LN2@lssproto_d
$LN3@lssproto_d:
  00029	c6 44 31 ff 00	 mov	 BYTE PTR [ecx+esi-1], 0
$LN2@lssproto_d:

; 696  :     if( src[l-2]=='\n' || src[l-2]=='\r' )src[l-2]=0;

  0002e	8a 44 31 fe	 mov	 al, BYTE PTR [ecx+esi-2]
  00032	3c 0a		 cmp	 al, 10			; 0000000aH
  00034	74 04		 je	 SHORT $LN5@lssproto_d
  00036	3c 0d		 cmp	 al, 13			; 0000000dH
  00038	75 05		 jne	 SHORT $LN4@lssproto_d
$LN5@lssproto_d:
  0003a	c6 44 31 fe 00	 mov	 BYTE PTR [ecx+esi-2], 0
$LN4@lssproto_d:

; 697  :     outlen64 = lssproto_decode64( (unsigned char*)src , (unsigned char*)lssproto.jencodecopy );

  0003f	ff 35 20 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+32
  00045	56		 push	 esi
  00046	e8 00 00 00 00	 call	 ?lssproto_decode64@@YAHPAE0@Z ; lssproto_decode64

; 698  :     lssproto_jDecode( lssproto.jencodecopy , outlen64 , JENCODE_KEY,

  0004b	8d 4d fc	 lea	 ecx, DWORD PTR _compressed_l$[ebp]
  0004e	51		 push	 ecx
  0004f	ff 35 28 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+40
  00055	68 13 3d 12 03	 push	 51526931		; 03123d13H
  0005a	50		 push	 eax
  0005b	ff 35 20 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+32
  00061	e8 00 00 00 00	 call	 ?lssproto_jDecode@@YAXPADHH0PAH@Z ; lssproto_jDecode

; 699  : 			lssproto.compresswork , &compressed_l);
; 700  :     /*out[outlen]=0;  PENDING*/
; 701  :     if( (lssproto.compresswork[0] % 2 ) == 0 ){

  00066	8b 0d 28 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+40
  0006c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0006f	f6 01 01	 test	 BYTE PTR [ecx], 1
  00072	75 4f		 jne	 SHORT $LN6@lssproto_d

; 702  : 	    if( compressed_l <= 0 ){

  00074	57		 push	 edi
  00075	8b 7d fc	 mov	 edi, DWORD PTR _compressed_l$[ebp]
  00078	85 ff		 test	 edi, edi
  0007a	7f 28		 jg	 SHORT $LN8@lssproto_d

; 703  : 			decompressed_l = 0;
; 704  : 			fprintf( stderr, "LSRPC: too short:[%s]\n", src );

  0007c	56		 push	 esi
  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@GCBPDGEH@LSRPC?3?5too?5short?3?$FL?$CFs?$FN?6@
  00082	6a 02		 push	 2
  00084	33 ff		 xor	 edi, edi
  00086	e8 00 00 00 00	 call	 ___acrt_iob_func
  0008b	83 c4 04	 add	 esp, 4
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 _fprintf

; 711  : 			lssproto_ringoDecompressor( (unsigned char*)out ,
; 712  :                   	(long)lssproto.workbufsize ,
; 713  : 					(unsigned char*)lssproto.compresswork+1 ,
; 714  : 					(long)compressed_l -1 );
; 715  : 	}
; 716  :     out[decompressed_l] = 0;

  00094	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  00097	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009a	c6 04 07 00	 mov	 BYTE PTR [edi+eax], 0
  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi

; 717  : }

  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
$LN8@lssproto_d:

; 705  : 		} else {
; 706  : 			memcpy( out, lssproto.compresswork+1, compressed_l -1 );

  000a4	8b 75 0c	 mov	 esi, DWORD PTR _out$[ebp]
  000a7	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  000aa	50		 push	 eax
  000ab	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  000ae	50		 push	 eax
  000af	56		 push	 esi
  000b0	e8 00 00 00 00	 call	 _memcpy
  000b5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 711  : 			lssproto_ringoDecompressor( (unsigned char*)out ,
; 712  :                   	(long)lssproto.workbufsize ,
; 713  : 					(unsigned char*)lssproto.compresswork+1 ,
; 714  : 					(long)compressed_l -1 );
; 715  : 	}
; 716  :     out[decompressed_l] = 0;

  000b8	c6 44 37 ff 00	 mov	 BYTE PTR [edi+esi-1], 0
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi

; 717  : }

  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
$LN6@lssproto_d:

; 707  : 			decompressed_l = compressed_l -1;
; 708  : 		}
; 709  : 	} else {
; 710  :         decompressed_l =

  000c3	8b 45 fc	 mov	 eax, DWORD PTR _compressed_l$[ebp]
  000c6	8b 75 0c	 mov	 esi, DWORD PTR _out$[ebp]
  000c9	48		 dec	 eax
  000ca	50		 push	 eax
  000cb	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  000ce	50		 push	 eax
  000cf	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  000d5	56		 push	 esi
  000d6	e8 00 00 00 00	 call	 ?lssproto_ringoDecompressor@@YAJPAEJ0J@Z ; lssproto_ringoDecompressor
  000db	83 c4 10	 add	 esp, 16			; 00000010H

; 711  : 			lssproto_ringoDecompressor( (unsigned char*)out ,
; 712  :                   	(long)lssproto.workbufsize ,
; 713  : 					(unsigned char*)lssproto.compresswork+1 ,
; 714  : 					(long)compressed_l -1 );
; 715  : 	}
; 716  :     out[decompressed_l] = 0;

  000de	c6 04 30 00	 mov	 BYTE PTR [eax+esi], 0
  000e2	5e		 pop	 esi

; 717  : }

  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c3		 ret	 0
?lssproto_decodeString@@YAXPAD0@Z ENDP			; lssproto_decodeString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_ringoDecompressor@@YAJPAEJ0J@Z
_TEXT	SEGMENT
_rv$1$ = -10264						; size = 4
_text$GSCopy$1$ = -10260				; size = 4
tv516 = -10256						; size = 4
_w$1$ = -10252						; size = 4
_freeNode$1$ = -10248					; size = 4
_node$ = -10244						; size = 8192
_stack$ = -2052						; size = 2048
__$ArrayPad$ = -4					; size = 4
_text$ = 8						; size = 4
_textlen$ = 12						; size = 4
_code$ = 16						; size = 4
_codelen$ = 20						; size = 4
?lssproto_ringoDecompressor@@YAJPAEJ0J@Z PROC		; lssproto_ringoDecompressor, COMDAT

; 1378 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 18 28 00 00	 mov	 eax, 10264		; 00002818H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	8b 45 08	 mov	 eax, DWORD PTR _text$[ebp]
  0001a	89 85 ec d7 ff
	ff		 mov	 DWORD PTR _text$GSCopy$1$[ebp], eax

; 1379 :     NODE node[NODE_SIZE];
; 1380 :     int stack[NODE_SIZE];
; 1381 :     int sp;
; 1382 :     int freeNode;
; 1383 :     int len;
; 1384 :     int i;
; 1385 :     int k = 0;
; 1386 :     int w = 0;

  00020	33 c0		 xor	 eax, eax
  00022	53		 push	 ebx
  00023	89 85 f4 d7 ff
	ff		 mov	 DWORD PTR _w$1$[ebp], eax
  00029	33 db		 xor	 ebx, ebx

; 1387 :     if( codelen <= 0 ) return -1;

  0002b	8b 45 14	 mov	 eax, DWORD PTR _codelen$[ebp]
  0002e	56		 push	 esi
  0002f	57		 push	 edi
  00030	85 c0		 test	 eax, eax
  00032	0f 8e bb 01 00
	00		 jle	 $LN34@lssproto_r

; 1388 :     initInputBitStream( (char*)code , codelen );

  00038	50		 push	 eax
  00039	ff 75 10	 push	 DWORD PTR _code$[ebp]
  0003c	e8 00 00 00 00	 call	 ?initInputBitStream@@YAHPADH@Z ; initInputBitStream
  00041	83 c4 08	 add	 esp, 8
  00044	8d 85 04 d8 ff
	ff		 lea	 eax, DWORD PTR _node$[ebp+8]

; 1389 :     for(i=0;i<CHAR_SIZE;i++){

  0004a	33 c9		 xor	 ecx, ecx
  0004c	0f 1f 40 00	 npad	 4
$LL4@lssproto_r:

; 1390 :         node[i].chr = (unsigned char)i;

  00050	88 48 f8	 mov	 BYTE PTR [eax-8], cl
  00053	8d 40 10	 lea	 eax, DWORD PTR [eax+16]

; 1391 :         node[i].brother = i+1;

  00056	41		 inc	 ecx

; 1392 :         node[i].parent = 0;

  00057	89 58 ec	 mov	 DWORD PTR [eax-20], ebx
  0005a	89 48 f0	 mov	 DWORD PTR [eax-16], ecx

; 1393 :         node[i].child = 0;

  0005d	89 58 f4	 mov	 DWORD PTR [eax-12], ebx
  00060	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  00066	7c e8		 jl	 SHORT $LL4@lssproto_r

; 1397 :     len=0;  /* index to text buffer */
; 1398 :     sp=0;   /* stack pointer */
; 1399 :     while(1){
; 1400 :         int rv = 0;
; 1401 :         rv = readInputBitStream( BITS_LEN );

  00068	6a 09		 push	 9
  0006a	89 9d 04 e8 ff
	ff		 mov	 DWORD PTR _node$[ebp+4104], ebx
  00070	33 ff		 xor	 edi, edi
  00072	c7 85 f8 d7 ff
	ff 01 01 00 00	 mov	 DWORD PTR _freeNode$1$[ebp], 257 ; 00000101H
  0007c	33 f6		 xor	 esi, esi
  0007e	e8 00 00 00 00	 call	 ?readInputBitStream@@YAIH@Z ; readInputBitStream
  00083	83 c4 04	 add	 esp, 4
  00086	89 85 e8 d7 ff
	ff		 mov	 DWORD PTR _rv$1$[ebp], eax

; 1402 :         /* return OK if EOF */
; 1403 :         if( rv == CHAR_SIZE ) break;        

  0008c	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00091	0f 84 49 01 00
	00		 je	 $LN31@lssproto_r

; 1394 :     }
; 1395 :     node[CHAR_SIZE].brother = 0;
; 1396 :     freeNode = CHAR_SIZE + 1;

  00097	8d 8d 0c e8 ff
	ff		 lea	 ecx, DWORD PTR _node$[ebp+4112]
  0009d	89 8d f0 d7 ff
	ff		 mov	 DWORD PTR tv516[ebp], ecx
$LL5@lssproto_r:

; 1404 :         if( rv >= freeNode ){

  000a3	3b 85 f8 d7 ff
	ff		 cmp	 eax, DWORD PTR _freeNode$1$[ebp]
  000a9	7c 1e		 jl	 SHORT $LN13@lssproto_r

; 1405 :             stack[sp++] = k;            /* exception */

  000ab	89 9c b5 fc f7
	ff ff		 mov	 DWORD PTR _stack$[ebp+esi*4], ebx
  000b2	46		 inc	 esi

; 1406 :             if( sp >=( sizeof( stack ) /sizeof(stack[0] )) )return -1;   

  000b3	81 fe 00 02 00
	00		 cmp	 esi, 512		; 00000200H
  000b9	0f 83 34 01 00
	00		 jae	 $LN34@lssproto_r

; 1407 :             k = w;

  000bf	8b 95 f4 d7 ff
	ff		 mov	 edx, DWORD PTR _w$1$[ebp]
  000c5	8b da		 mov	 ebx, edx

; 1408 :         } else {

  000c7	eb 08		 jmp	 SHORT $LN26@lssproto_r
$LN13@lssproto_r:
  000c9	8b 95 f4 d7 ff
	ff		 mov	 edx, DWORD PTR _w$1$[ebp]

; 1409 :             k = rv;

  000cf	8b d8		 mov	 ebx, eax
$LN26@lssproto_r:

; 1410 :         }
; 1411 :         while(k> CHAR_SIZE ){

  000d1	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  000d7	7e 40		 jle	 SHORT $LN8@lssproto_r
  000d9	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@lssproto_r:

; 1412 :             if( k >= (sizeof(node)/sizeof(node[0]))) return -1;

  000e0	81 fb 00 02 00
	00		 cmp	 ebx, 512		; 00000200H
  000e6	0f 83 07 01 00
	00		 jae	 $LN34@lssproto_r

; 1413 :             stack[sp++] = node[k].chr;

  000ec	03 db		 add	 ebx, ebx
  000ee	0f b6 84 dd fc
	d7 ff ff	 movzx	 eax, BYTE PTR _node$[ebp+ebx*8]

; 1414 :             k = node[k].parent;

  000f6	8b 9c dd 00 d8
	ff ff		 mov	 ebx, DWORD PTR _node$[ebp+ebx*8+4]
  000fd	89 84 b5 fc f7
	ff ff		 mov	 DWORD PTR _stack$[ebp+esi*4], eax
  00104	46		 inc	 esi

; 1415 :             if( sp >=( sizeof( stack ) /sizeof(stack[0] )) ) return -1;

  00105	81 fe 00 02 00
	00		 cmp	 esi, 512		; 00000200H
  0010b	0f 83 e2 00 00
	00		 jae	 $LN34@lssproto_r

; 1410 :         }
; 1411 :         while(k> CHAR_SIZE ){

  00111	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  00117	7f c7		 jg	 SHORT $LL7@lssproto_r
$LN8@lssproto_r:

; 1416 :         }
; 1417 :         stack[sp++] = k;

  00119	89 9c b5 fc f7
	ff ff		 mov	 DWORD PTR _stack$[ebp+esi*4], ebx
  00120	46		 inc	 esi

; 1418 :         if( sp >= ( sizeof( stack ) /sizeof(stack[0] )) ) return -1;

  00121	81 fe 00 02 00
	00		 cmp	 esi, 512		; 00000200H
  00127	0f 83 c6 00 00
	00		 jae	 $LN34@lssproto_r

; 1419 :         /* output to text buffer from stack.*/
; 1420 :         while(sp){

  0012d	85 f6		 test	 esi, esi
  0012f	74 34		 je	 SHORT $LN10@lssproto_r
  00131	8b 8d ec d7 ff
	ff		 mov	 ecx, DWORD PTR _text$GSCopy$1$[ebp]
  00137	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL9@lssproto_r:

; 1421 :             if( ++len > textlen ) return -1;

  00140	47		 inc	 edi
  00141	3b 7d 0c	 cmp	 edi, DWORD PTR _textlen$[ebp]
  00144	0f 8f a9 00 00
	00		 jg	 $LN34@lssproto_r

; 1422 :             *text++ = stack[--sp];

  0014a	8a 84 b5 f8 f7
	ff ff		 mov	 al, BYTE PTR _stack$[ebp+esi*4-4]
  00151	4e		 dec	 esi
  00152	88 01		 mov	 BYTE PTR [ecx], al
  00154	41		 inc	 ecx
  00155	89 8d ec d7 ff
	ff		 mov	 DWORD PTR _text$GSCopy$1$[ebp], ecx
  0015b	85 f6		 test	 esi, esi
  0015d	75 e1		 jne	 SHORT $LL9@lssproto_r
  0015f	8b 8d f0 d7 ff
	ff		 mov	 ecx, DWORD PTR tv516[ebp]
$LN10@lssproto_r:

; 1423 :         }
; 1424 :         /* register the pattern 'wk'*/
; 1425 :         if( len > 1 && freeNode < NODE_SIZE ){

  00165	83 ff 01	 cmp	 edi, 1
  00168	7e 49		 jle	 SHORT $LN20@lssproto_r
  0016a	81 bd f8 d7 ff
	ff 00 02 00 00	 cmp	 DWORD PTR _freeNode$1$[ebp], 512 ; 00000200H
  00174	7d 3d		 jge	 SHORT $LN20@lssproto_r

; 1426 :             node[freeNode].parent = w;

  00176	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 1427 :             node[freeNode].chr = k;

  00179	88 19		 mov	 BYTE PTR [ecx], bl

; 1428 :             if( w >= (sizeof(node)/sizeof(node[0])))return -1;

  0017b	81 fa 00 02 00
	00		 cmp	 edx, 512		; 00000200H
  00181	73 70		 jae	 SHORT $LN34@lssproto_r

; 1429 :             node[freeNode].brother = node[w].child;

  00183	03 d2		 add	 edx, edx
  00185	8b 84 d5 08 d8
	ff ff		 mov	 eax, DWORD PTR _node$[ebp+edx*8+12]
  0018c	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1430 :             node[freeNode].child = 0;
; 1431 :             node[w].child = freeNode;

  0018f	8b 85 f8 d7 ff
	ff		 mov	 eax, DWORD PTR _freeNode$1$[ebp]
  00195	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  0019c	89 84 d5 08 d8
	ff ff		 mov	 DWORD PTR _node$[ebp+edx*8+12], eax

; 1432 :             freeNode++;

  001a3	40		 inc	 eax
  001a4	83 c1 10	 add	 ecx, 16			; 00000010H
  001a7	89 85 f8 d7 ff
	ff		 mov	 DWORD PTR _freeNode$1$[ebp], eax
  001ad	89 8d f0 d7 ff
	ff		 mov	 DWORD PTR tv516[ebp], ecx
$LN20@lssproto_r:

; 1433 :         }
; 1434 :         w = rv;

  001b3	8b 85 e8 d7 ff
	ff		 mov	 eax, DWORD PTR _rv$1$[ebp]
  001b9	6a 09		 push	 9
  001bb	89 85 f4 d7 ff
	ff		 mov	 DWORD PTR _w$1$[ebp], eax
  001c1	e8 00 00 00 00	 call	 ?readInputBitStream@@YAIH@Z ; readInputBitStream
  001c6	8b 8d f0 d7 ff
	ff		 mov	 ecx, DWORD PTR tv516[ebp]
  001cc	83 c4 04	 add	 esp, 4
  001cf	89 85 e8 d7 ff
	ff		 mov	 DWORD PTR _rv$1$[ebp], eax
  001d5	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  001da	0f 85 c3 fe ff
	ff		 jne	 $LL5@lssproto_r
$LN31@lssproto_r:

; 1435 :     }
; 1436 :     return len;

  001e0	8b c7		 mov	 eax, edi
  001e2	5f		 pop	 edi

; 1437 : }

  001e3	5e		 pop	 esi
  001e4	5b		 pop	 ebx
  001e5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e8	33 cd		 xor	 ecx, ebp
  001ea	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ef	8b e5		 mov	 esp, ebp
  001f1	5d		 pop	 ebp
  001f2	c3		 ret	 0
$LN34@lssproto_r:
  001f3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f6	83 c8 ff	 or	 eax, -1
  001f9	5f		 pop	 edi
  001fa	5e		 pop	 esi
  001fb	33 cd		 xor	 ecx, ebp
  001fd	5b		 pop	 ebx
  001fe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00203	8b e5		 mov	 esp, ebp
  00205	5d		 pop	 ebp
  00206	c3		 ret	 0
?lssproto_ringoDecompressor@@YAJPAEJ0J@Z ENDP		; lssproto_ringoDecompressor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_ringoCompressor@@YAJPAEJ0J@Z
_TEXT	SEGMENT
tv482 = -8216						; size = 4
_position$1$ = -8212					; size = 4
_text$GSCopy$1$ = -8208					; size = 4
tv466 = -8204						; size = 4
_freeNode$1$ = -8200					; size = 4
_node$ = -8196						; size = 8192
__$ArrayPad$ = -4					; size = 4
_code$ = 8						; size = 4
_codelen$ = 12						; size = 4
_text$ = 16						; size = 4
_textlen$ = 20						; size = 4
?lssproto_ringoCompressor@@YAJPAEJ0J@Z PROC		; lssproto_ringoCompressor, COMDAT

; 1312 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 18 20 00 00	 mov	 eax, 8216		; 00002018H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	8b 4d 10	 mov	 ecx, DWORD PTR _text$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR _code$[ebp]
  0001d	53		 push	 ebx

; 1313 :     NODE node[NODE_SIZE];
; 1314 :     int freeNode;        
; 1315 :     int w,k;        /* used in this algo */
; 1316 :     int textind;    /* index to text buffer */
; 1317 :     int i;
; 1318 :     int position = 0;   /* indicates the last byte of code buffer */
; 1319 :     if( textlen <= 0 ) return -1;

  0001e	8b 5d 14	 mov	 ebx, DWORD PTR _textlen$[ebp]
  00021	89 8d f0 df ff
	ff		 mov	 DWORD PTR _text$GSCopy$1$[ebp], ecx
  00027	33 c9		 xor	 ecx, ecx
  00029	89 8d ec df ff
	ff		 mov	 DWORD PTR _position$1$[ebp], ecx
  0002f	56		 push	 esi
  00030	57		 push	 edi
  00031	85 db		 test	 ebx, ebx
  00033	0f 8e 3c 01 00
	00		 jle	 $LN27@lssproto_r

; 1320 :     initOutputBitStream((char*) code,codelen);

  00039	ff 75 0c	 push	 DWORD PTR _codelen$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ?initOutputBitStream@@YAHPADH@Z ; initOutputBitStream
  00042	83 c4 08	 add	 esp, 8
  00045	8d 85 04 e0 ff
	ff		 lea	 eax, DWORD PTR _node$[ebp+8]

; 1321 :     /* fill characters ( 0 ~ 255 ) in the beggining part of
; 1322 :        Node list */
; 1323 :     for(i=0; i<= CHAR_SIZE; i++){

  0004b	33 c9		 xor	 ecx, ecx
  0004d	0f 1f 00	 npad	 3
$LL4@lssproto_r:

; 1324 :         node[i].chr = (unsigned char)i;

  00050	88 48 f8	 mov	 BYTE PTR [eax-8], cl
  00053	8d 40 10	 lea	 eax, DWORD PTR [eax+16]

; 1325 :         node[i].brother = i + 1;

  00056	41		 inc	 ecx

; 1326 :         node[i].parent = 0;

  00057	c7 40 ec 00 00
	00 00		 mov	 DWORD PTR [eax-20], 0
  0005e	89 48 f0	 mov	 DWORD PTR [eax-16], ecx

; 1327 :         node[i].child = 0;

  00061	c7 40 f4 00 00
	00 00		 mov	 DWORD PTR [eax-12], 0
  00068	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  0006e	7e e0		 jle	 SHORT $LL4@lssproto_r

; 1328 :     }
; 1329 :     node[CHAR_SIZE].brother = 0;
; 1330 :     freeNode = CHAR_SIZE + 1;
; 1331 :     w = text[0];

  00070	8b 8d f0 df ff
	ff		 mov	 ecx, DWORD PTR _text$GSCopy$1$[ebp]
  00076	8d 85 0c f0 ff
	ff		 lea	 eax, DWORD PTR _node$[ebp+4112]
  0007c	c7 85 04 f0 ff
	ff 00 00 00 00	 mov	 DWORD PTR _node$[ebp+4104], 0

; 1332 :     textind = 1;

  00086	be 01 00 00 00	 mov	 esi, 1
  0008b	c7 85 f8 df ff
	ff 01 01 00 00	 mov	 DWORD PTR _freeNode$1$[ebp], 257 ; 00000101H
  00095	89 85 f4 df ff
	ff		 mov	 DWORD PTR tv466[ebp], eax
  0009b	0f b6 39	 movzx	 edi, BYTE PTR [ecx]
  0009e	66 90		 npad	 2
$LL5@lssproto_r:

; 1333 :     while(1){
; 1334 :         int rv;
; 1335 :         if( textind >= textlen ){

  000a0	3b f3		 cmp	 esi, ebx

; 1336 :             k = CHAR_SIZE;      /* indicates EOF */

  000a2	bb 00 01 00 00	 mov	 ebx, 256		; 00000100H
  000a7	7d 04		 jge	 SHORT $LN11@lssproto_r

; 1337 :         } else {
; 1338 :             k = text[textind];

  000a9	0f b6 1c 31	 movzx	 ebx, BYTE PTR [ecx+esi]
$LN11@lssproto_r:

; 1339 :         }
; 1340 :         /* search if pattern 'wk' is registered or not. */
; 1341 :         rv = node[w].child;

  000ad	8b c7		 mov	 eax, edi
  000af	8d 95 08 e0 ff
	ff		 lea	 edx, DWORD PTR _node$[ebp+12]
  000b5	c1 e0 04	 shl	 eax, 4
  000b8	03 c2		 add	 eax, edx
  000ba	89 85 e8 df ff
	ff		 mov	 DWORD PTR tv482[ebp], eax
  000c0	8b 10		 mov	 edx, DWORD PTR [eax]

; 1342 :         while(1){
; 1343 :             if( rv <= 0 ) break;

  000c2	85 d2		 test	 edx, edx
  000c4	7e 25		 jle	 SHORT $LN14@lssproto_r
  000c6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL7@lssproto_r:

; 1344 :             if( node[rv].chr == k ) break;

  000d0	8b c2		 mov	 eax, edx
  000d2	03 c0		 add	 eax, eax
  000d4	0f b6 8c c5 fc
	df ff ff	 movzx	 ecx, BYTE PTR _node$[ebp+eax*8]
  000dc	3b cb		 cmp	 ecx, ebx
  000de	74 7a		 je	 SHORT $LN39@lssproto_r

; 1345 :             rv = node[rv].brother;

  000e0	8b 94 c5 04 e0
	ff ff		 mov	 edx, DWORD PTR _node$[ebp+eax*8+8]
  000e7	85 d2		 test	 edx, edx
  000e9	7f e5		 jg	 SHORT $LL7@lssproto_r
$LN14@lssproto_r:

; 1351 :             position = writeOutputBitStream( BITS_LEN ,w  );

  000eb	57		 push	 edi
  000ec	6a 09		 push	 9
  000ee	e8 00 00 00 00	 call	 ?writeOutputBitStream@@YAHHI@Z ; writeOutputBitStream
  000f3	83 c4 08	 add	 esp, 8
  000f6	89 85 ec df ff
	ff		 mov	 DWORD PTR _position$1$[ebp], eax

; 1352 :             /* return if buffer excession  */
; 1353 :             if( position > codelen ) return -1;

  000fc	3b 45 0c	 cmp	 eax, DWORD PTR _codelen$[ebp]
  000ff	7f 74		 jg	 SHORT $LN27@lssproto_r

; 1354 :             /* register pattern 'wk' in the dictionary */
; 1355 :             if( freeNode < NODE_SIZE ){

  00101	81 bd f8 df ff
	ff 00 02 00 00	 cmp	 DWORD PTR _freeNode$1$[ebp], 512 ; 00000200H
  0010b	7d 35		 jge	 SHORT $LN38@lssproto_r

; 1356 :                 node[freeNode].parent = w;

  0010d	8b 85 f4 df ff
	ff		 mov	 eax, DWORD PTR tv466[ebp]

; 1357 :                 node[freeNode].chr = k;
; 1358 :                 node[freeNode].brother = node[w].child;

  00113	8b 95 e8 df ff
	ff		 mov	 edx, DWORD PTR tv482[ebp]
  00119	89 78 04	 mov	 DWORD PTR [eax+4], edi
  0011c	88 18		 mov	 BYTE PTR [eax], bl
  0011e	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00120	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1359 :                 node[freeNode].child = 0;
; 1360 :                 node[w].child = freeNode;

  00123	8b 8d f8 df ff
	ff		 mov	 ecx, DWORD PTR _freeNode$1$[ebp]
  00129	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00130	89 0a		 mov	 DWORD PTR [edx], ecx

; 1361 :                 freeNode++;

  00132	41		 inc	 ecx
  00133	83 c0 10	 add	 eax, 16			; 00000010H
  00136	89 8d f8 df ff
	ff		 mov	 DWORD PTR _freeNode$1$[ebp], ecx
  0013c	89 85 f4 df ff
	ff		 mov	 DWORD PTR tv466[ebp], eax
$LN38@lssproto_r:

; 1362 :             }
; 1363 :             w = k;

  00142	8b fb		 mov	 edi, ebx
$LN15@lssproto_r:

; 1364 :         }
; 1365 :         if( textind == ( textlen + 1 )  ) break;

  00144	8b 5d 14	 mov	 ebx, DWORD PTR _textlen$[ebp]
  00147	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  0014a	3b f0		 cmp	 esi, eax
  0014c	74 10		 je	 SHORT $LN28@lssproto_r

; 1366 :         textind++;

  0014e	8b 8d f0 df ff
	ff		 mov	 ecx, DWORD PTR _text$GSCopy$1$[ebp]
  00154	46		 inc	 esi
  00155	e9 46 ff ff ff	 jmp	 $LL5@lssproto_r
$LN39@lssproto_r:

; 1346 :         }
; 1347 :         if( rv > 0 ){
; 1348 :             /* found it */
; 1349 :             w = rv;

  0015a	8b fa		 mov	 edi, edx

; 1350 :         } else {

  0015c	eb e6		 jmp	 SHORT $LN15@lssproto_r
$LN28@lssproto_r:

; 1367 :     }
; 1368 :     return position;

  0015e	8b 85 ec df ff
	ff		 mov	 eax, DWORD PTR _position$1$[ebp]
  00164	5f		 pop	 edi

; 1369 : }

  00165	5e		 pop	 esi
  00166	5b		 pop	 ebx
  00167	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016a	33 cd		 xor	 ecx, ebp
  0016c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00171	8b e5		 mov	 esp, ebp
  00173	5d		 pop	 ebp
  00174	c3		 ret	 0
$LN27@lssproto_r:
  00175	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00178	83 c8 ff	 or	 eax, -1
  0017b	5f		 pop	 edi
  0017c	5e		 pop	 esi
  0017d	33 cd		 xor	 ecx, ebp
  0017f	5b		 pop	 ebx
  00180	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00185	8b e5		 mov	 esp, ebp
  00187	5d		 pop	 ebp
  00188	c3		 ret	 0
?lssproto_ringoCompressor@@YAJPAEJ0J@Z ENDP		; lssproto_ringoCompressor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_a62toi@@YAHPAD@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?lssproto_a62toi@@YAHPAD@Z PROC				; lssproto_a62toi, COMDAT

; 1442 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]

; 1443 : 	int ret = 0;

  00006	33 c9		 xor	 ecx, ecx
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	57		 push	 edi

; 1444 : 	int minus ;
; 1445 : 	if( a[0] == '-' ){

  0000b	8a 1a		 mov	 bl, BYTE PTR [edx]
  0000d	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  00010	75 08		 jne	 SHORT $LN4@lssproto_a

; 1446 : 		minus = -1;
; 1447 :         a++;

  00012	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00015	83 cf ff	 or	 edi, -1

; 1448 : 	} else {

  00018	eb 07		 jmp	 SHORT $LN13@lssproto_a
$LN4@lssproto_a:

; 1449 : 		minus = 1;

  0001a	bf 01 00 00 00	 mov	 edi, 1
  0001f	8a c3		 mov	 al, bl
$LN13@lssproto_a:

; 1450 : 	}
; 1451 : 	
; 1452 : 	while( *a != '\0' )

  00021	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  00024	8d 72 01	 lea	 esi, DWORD PTR [edx+1]
  00027	0f 45 f2	 cmovne	 esi, edx
  0002a	84 c0		 test	 al, al
  0002c	74 43		 je	 SHORT $LN3@lssproto_a
  0002e	66 90		 npad	 2
$LL2@lssproto_a:

; 1453 : 	{
; 1454 : 		ret *= 62;

  00030	8b d1		 mov	 edx, ecx
  00032	c1 e2 05	 shl	 edx, 5
  00035	2b d1		 sub	 edx, ecx

; 1455 : 		if( '0' <= (*a) && (*a) <= '9' )

  00037	8d 48 d0	 lea	 ecx, DWORD PTR [eax-48]
  0003a	03 d2		 add	 edx, edx
  0003c	80 f9 09	 cmp	 cl, 9
  0003f	77 08		 ja	 SHORT $LN6@lssproto_a

; 1456 : 			ret += (*a)-'0';

  00041	0f be c8	 movsx	 ecx, al
  00044	83 c1 d0	 add	 ecx, -48		; ffffffd0H
  00047	eb 1e		 jmp	 SHORT $LN17@lssproto_a
$LN6@lssproto_a:

; 1457 : 		else
; 1458 : 		if( 'a' <= (*a) && (*a) <= 'z' )

  00049	8d 48 9f	 lea	 ecx, DWORD PTR [eax-97]
  0004c	80 f9 19	 cmp	 cl, 25			; 00000019H
  0004f	77 08		 ja	 SHORT $LN8@lssproto_a

; 1459 : 			ret += (*a)-'a'+10;

  00051	0f be c8	 movsx	 ecx, al
  00054	83 c1 a9	 add	 ecx, -87		; ffffffa9H
  00057	eb 0e		 jmp	 SHORT $LN17@lssproto_a
$LN8@lssproto_a:

; 1460 : 		else
; 1461 : 		if( 'A' <= (*a) && (*a) <= 'Z' )

  00059	8d 48 bf	 lea	 ecx, DWORD PTR [eax-65]
  0005c	80 f9 19	 cmp	 cl, 25			; 00000019H
  0005f	77 1a		 ja	 SHORT $LN10@lssproto_a

; 1462 : 			ret += (*a)-'A'+36;

  00061	0f be c8	 movsx	 ecx, al
  00064	83 c1 e3	 add	 ecx, -29		; ffffffe3H
$LN17@lssproto_a:

; 1463 : 		else
; 1464 : 			return 0;
; 1465 : 		a++;

  00067	8a 46 01	 mov	 al, BYTE PTR [esi+1]
  0006a	46		 inc	 esi
  0006b	03 ca		 add	 ecx, edx
  0006d	84 c0		 test	 al, al
  0006f	75 bf		 jne	 SHORT $LL2@lssproto_a
$LN3@lssproto_a:

; 1466 : 	}
; 1467 : 	return ret * minus;

  00071	0f af f9	 imul	 edi, ecx
  00074	8b c7		 mov	 eax, edi
  00076	5f		 pop	 edi

; 1468 : }

  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
$LN10@lssproto_a:
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	33 c0		 xor	 eax, eax
  0007f	5b		 pop	 ebx
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
?lssproto_a62toi@@YAHPAD@Z ENDP				; lssproto_a62toi
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_cnv10to62@@YAPADHPADH@Z
_TEXT	SEGMENT
tv401 = -328						; size = 4
_tmp$ = -324						; size = 256
_base$ = -68						; size = 63
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_out$ = 12						; size = 4
_outlen$ = 16						; size = 4
?lssproto_cnv10to62@@YAPADHPADH@Z PROC			; lssproto_cnv10to62, COMDAT

; 1472 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1473 : 	int		i, j;
; 1474 :     char    base[] = { "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"};

  00016	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  0001b	8b 5d 0c	 mov	 ebx, DWORD PTR _out$[ebp]
  0001e	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0DP@CCELEMID@0123456789abcdefghijklmnopqrstu@
  00023	8d 7d bc	 lea	 edi, DWORD PTR _base$[ebp]
  00026	f3 a5		 rep movsd
  00028	66 a5		 movsw
  0002a	a4		 movsb

; 1475 :     int     tmp[64];
; 1476 :     int     src;
; 1477 :     int minus;
; 1478 : 	int baselen = sizeof( base)-1;
; 1479 :     if( a < 0 ){
; 1480 : 		minus = 1;
; 1481 : 		a *= -1;
; 1482 : 	} else {
; 1483 : 		minus = 0;
; 1484 : 	}
; 1485 :     /* special case */					   
; 1486 :     if( a < baselen) {

  0002b	8b 7d 08	 mov	 edi, DWORD PTR _a$[ebp]
  0002e	8b c7		 mov	 eax, edi
  00030	99		 cdq
  00031	33 c2		 xor	 eax, edx
  00033	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00036	2b c2		 sub	 eax, edx
  00038	83 f8 3e	 cmp	 eax, 62			; 0000003eH
  0003b	7d 3e		 jge	 SHORT $LN15@lssproto_c

; 1487 : 		if( minus ){

  0003d	8a 44 05 bc	 mov	 al, BYTE PTR _base$[ebp+eax]
  00041	85 ff		 test	 edi, edi
  00043	74 1d		 je	 SHORT $LN14@lssproto_c

; 1488 : 			*(out) = '-';
; 1489 : 			*(out+1) = base[a];

  00045	5f		 pop	 edi
  00046	88 43 01	 mov	 BYTE PTR [ebx+1], al

; 1519 :     return( out);
; 1520 : }

  00049	8b c3		 mov	 eax, ebx
  0004b	5e		 pop	 esi
  0004c	c6 03 2d	 mov	 BYTE PTR [ebx], 45	; 0000002dH
  0004f	c6 43 02 00	 mov	 BYTE PTR [ebx+2], 0
  00053	5b		 pop	 ebx
  00054	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00057	33 cd		 xor	 ecx, ebp
  00059	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
$LN14@lssproto_c:
  00062	5f		 pop	 edi

; 1490 : 			*(out+2) = '\0';
; 1491 : 			return (out);
; 1492 : 		} else {
; 1493 : 			*out = base[a];

  00063	88 03		 mov	 BYTE PTR [ebx], al

; 1519 :     return( out);
; 1520 : }

  00065	8b c3		 mov	 eax, ebx
  00067	5e		 pop	 esi
  00068	c6 43 01 00	 mov	 BYTE PTR [ebx+1], 0
  0006c	5b		 pop	 ebx
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00070	33 cd		 xor	 ecx, ebp
  00072	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
$LN15@lssproto_c:

; 1494 : 			*(out+1) = '\0';
; 1495 : 			return( out);
; 1496 : 		}
; 1497 :     }
; 1498 :     src = a;
; 1499 :     for( i = 0; src >= baselen; i ++ ) {

  0007b	33 c9		 xor	 ecx, ecx
  0007d	c7 85 b8 fe ff
	ff 3e 00 00 00	 mov	 DWORD PTR tv401[ebp], 62 ; 0000003eH
  00087	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL4@lssproto_c:

; 1500 :         tmp[i] = src % baselen;

  00090	33 d2		 xor	 edx, edx
  00092	8b f1		 mov	 esi, ecx
  00094	f7 b5 b8 fe ff
	ff		 div	 DWORD PTR tv401[ebp]
  0009a	89 94 8d bc fe
	ff ff		 mov	 DWORD PTR _tmp$[ebp+ecx*4], edx
  000a1	41		 inc	 ecx
  000a2	83 f8 3e	 cmp	 eax, 62			; 0000003eH
  000a5	7d e9		 jge	 SHORT $LL4@lssproto_c

; 1501 :         src /= baselen;
; 1502 :     }
; 1503 :     i--;

  000a7	8a 44 05 bc	 mov	 al, BYTE PTR _base$[ebp+eax]

; 1504 :     if( minus ){

  000ab	85 ff		 test	 edi, edi
  000ad	74 44		 je	 SHORT $LN16@lssproto_c

; 1505 : 		*out = '-';
; 1506 :      	*(out+1) = base[src];

  000af	88 43 01	 mov	 BYTE PTR [ebx+1], al

; 1507 : 		for( j = 2; i >= 0; i --, j ++ ) {

  000b2	b8 02 00 00 00	 mov	 eax, 2
  000b7	c6 03 2d	 mov	 BYTE PTR [ebx], 45	; 0000002dH
  000ba	85 f6		 test	 esi, esi
  000bc	78 1e		 js	 SHORT $LN9@lssproto_c
  000be	8b 55 10	 mov	 edx, DWORD PTR _outlen$[ebp]
  000c1	83 c2 fe	 add	 edx, -2			; fffffffeH
$LL7@lssproto_c:

; 1508 : 			if( j > outlen - 2 ) return NULL;

  000c4	3b c2		 cmp	 eax, edx
  000c6	7f 56		 jg	 SHORT $LN25@lssproto_c

; 1509 : 			*(out+j) = base[tmp[i]];

  000c8	8b 8c b5 bc fe
	ff ff		 mov	 ecx, DWORD PTR _tmp$[ebp+esi*4]
  000cf	8a 4c 0d bc	 mov	 cl, BYTE PTR _base$[ebp+ecx]
  000d3	88 0c 03	 mov	 BYTE PTR [ebx+eax], cl
  000d6	40		 inc	 eax
  000d7	83 ee 01	 sub	 esi, 1
  000da	79 e8		 jns	 SHORT $LL7@lssproto_c
$LN9@lssproto_c:
  000dc	5f		 pop	 edi

; 1516 : 		}		
; 1517 : 	}
; 1518 : 	*(out+j) = '\0';

  000dd	c6 04 03 00	 mov	 BYTE PTR [ebx+eax], 0

; 1519 :     return( out);
; 1520 : }

  000e1	8b c3		 mov	 eax, ebx
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx
  000e5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e8	33 cd		 xor	 ecx, ebp
  000ea	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c3		 ret	 0
$LN16@lssproto_c:

; 1510 : 		}		
; 1511 : 	} else {
; 1512 :      	*out = base[src];

  000f3	88 03		 mov	 BYTE PTR [ebx], al

; 1513 : 		for( j = 1; i >= 0; i --, j ++ ) {

  000f5	b8 01 00 00 00	 mov	 eax, 1
  000fa	85 f6		 test	 esi, esi
  000fc	78 de		 js	 SHORT $LN9@lssproto_c
  000fe	8b 55 10	 mov	 edx, DWORD PTR _outlen$[ebp]
  00101	83 c2 fe	 add	 edx, -2			; fffffffeH
$LL10@lssproto_c:

; 1514 : 			if( j > outlen - 2 ) return NULL;

  00104	3b c2		 cmp	 eax, edx
  00106	7f 16		 jg	 SHORT $LN25@lssproto_c

; 1515 : 			*(out+j) = base[tmp[i]];

  00108	8b 8c b5 bc fe
	ff ff		 mov	 ecx, DWORD PTR _tmp$[ebp+esi*4]
  0010f	8a 4c 0d bc	 mov	 cl, BYTE PTR _base$[ebp+ecx]
  00113	88 0c 03	 mov	 BYTE PTR [ebx+eax], cl
  00116	40		 inc	 eax
  00117	83 ee 01	 sub	 esi, 1
  0011a	79 e8		 jns	 SHORT $LL10@lssproto_c

; 1514 : 			if( j > outlen - 2 ) return NULL;

  0011c	eb be		 jmp	 SHORT $LN9@lssproto_c
$LN25@lssproto_c:

; 1519 :     return( out);
; 1520 : }

  0011e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00121	33 c0		 xor	 eax, eax
  00123	5f		 pop	 edi
  00124	5e		 pop	 esi
  00125	33 cd		 xor	 ecx, ebp
  00127	5b		 pop	 ebx
  00128	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012d	8b e5		 mov	 esp, ebp
  0012f	5d		 pop	 ebp
  00130	c3		 ret	 0
?lssproto_cnv10to62@@YAPADHPADH@Z ENDP			; lssproto_cnv10to62
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_DebugSend@@YAXHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_msg$ = 12						; size = 4
?lssproto_DebugSend@@YAXHPAD@Z PROC			; lssproto_DebugSend, COMDAT

; 543  : 	lssproto_Send( fd, msg );

  00000	e9 00 00 00 00	 jmp	 ?lssproto_Send@@YAXHPAD@Z ; lssproto_Send
?lssproto_DebugSend@@YAXHPAD@Z ENDP			; lssproto_DebugSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_Ultoa@@YAPADK@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?lssproto_Ultoa@@YAPADK@Z PROC				; lssproto_Ultoa, COMDAT

; 595  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 596  : 	static char _ultoa_out[64];
; 597  : 	sprintf( _ultoa_out , "%u" , (unsigned int)v );

  00003	ff 75 08	 push	 DWORD PTR _v$[ebp]
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  0000b	68 00 00 00 00	 push	 OFFSET ?_ultoa_out@?1??lssproto_Ultoa@@YAPADK@Z@4PADA
  00010	e8 00 00 00 00	 call	 _sprintf
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 598  : 	return _ultoa_out;

  00018	b8 00 00 00 00	 mov	 eax, OFFSET ?_ultoa_out@?1??lssproto_Ultoa@@YAPADK@Z@4PADA

; 599  : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?lssproto_Ultoa@@YAPADK@Z ENDP				; lssproto_Ultoa
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_Ltoa@@YAPADJ@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?lssproto_Ltoa@@YAPADJ@Z PROC				; lssproto_Ltoa, COMDAT

; 588  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 589  : 	static char _ltoa_out[64];
; 590  : 	lssproto_cnv10to62( (int)v , _ltoa_out , sizeof( _ltoa_out ));

  00003	6a 40		 push	 64			; 00000040H
  00005	68 00 00 00 00	 push	 OFFSET ?_ltoa_out@?1??lssproto_Ltoa@@YAPADJ@Z@4PADA
  0000a	ff 75 08	 push	 DWORD PTR _v$[ebp]
  0000d	e8 00 00 00 00	 call	 ?lssproto_cnv10to62@@YAPADHPADH@Z ; lssproto_cnv10to62
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 591  : /*	sprintf( _ltoa_out , "%d" , (int)v );*/
; 592  : 	return _ltoa_out;

  00015	b8 00 00 00 00	 mov	 eax, OFFSET ?_ltoa_out@?1??lssproto_Ltoa@@YAPADJ@Z@4PADA

; 593  : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?lssproto_Ltoa@@YAPADJ@Z ENDP				; lssproto_Ltoa
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_bcopy@@YAXPAD0H@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_d$ = 12						; size = 4
_siz$ = 16						; size = 4
?lssproto_bcopy@@YAXPAD0H@Z PROC			; lssproto_bcopy, COMDAT

; 627  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 631  :     pd = (int*)d;
; 632  :     for(i=0;i<siz/sizeof(int);i++) {

  00004	8b 5d 10	 mov	 ebx, DWORD PTR _siz$[ebp]
  00007	8b d3		 mov	 edx, ebx
  00009	c1 ea 02	 shr	 edx, 2
  0000c	56		 push	 esi
  0000d	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  00010	85 d2		 test	 edx, edx
  00012	74 1b		 je	 SHORT $LN3@lssproto_b

; 628  :     unsigned int i;
; 629  :     int *ps,*pd;
; 630  :     ps = (int*)s;

  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _d$[ebp]
  00017	57		 push	 edi
  00018	8b fe		 mov	 edi, esi
  0001a	2b f9		 sub	 edi, ecx
  0001c	0f 1f 40 00	 npad	 4
$LL13@lssproto_b:

; 633  :         *(pd+i) = *(ps+i);

  00020	8b 04 0f	 mov	 eax, DWORD PTR [edi+ecx]
  00023	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  00026	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
  00029	83 ea 01	 sub	 edx, 1
  0002c	75 f2		 jne	 SHORT $LL13@lssproto_b
  0002e	5f		 pop	 edi
$LN3@lssproto_b:

; 634  :     }
; 635  :     for(i=0;i<siz%sizeof(int);i++) {

  0002f	8b d3		 mov	 edx, ebx
  00031	83 e2 03	 and	 edx, 3
  00034	76 18		 jbe	 SHORT $LN6@lssproto_b
  00036	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00039	03 45 0c	 add	 eax, DWORD PTR _d$[ebp]
  0003c	2b 75 0c	 sub	 esi, DWORD PTR _d$[ebp]
  0003f	90		 npad	 1
$LL7@lssproto_b:

; 636  :         *(d+siz-1-i)=*(s+siz-1-i);

  00040	8a 0c 30	 mov	 cl, BYTE PTR [eax+esi]
  00043	8d 40 ff	 lea	 eax, DWORD PTR [eax-1]
  00046	88 48 01	 mov	 BYTE PTR [eax+1], cl
  00049	83 ea 01	 sub	 edx, 1
  0004c	75 f2		 jne	 SHORT $LL7@lssproto_b
$LN6@lssproto_b:
  0004e	5e		 pop	 esi

; 637  :     }
; 638  : }

  0004f	5b		 pop	 ebx
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?lssproto_bcopy@@YAXPAD0H@Z ENDP			; lssproto_bcopy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_bzero@@YAXPADH@Z
_TEXT	SEGMENT
_b$ = 8							; size = 4
_siz$ = 12						; size = 4
?lssproto_bzero@@YAXPADH@Z PROC				; lssproto_bzero, COMDAT

; 612  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 616  : 	for(i=0;i<siz/sizeof(int);i++) {

  00003	8b 55 0c	 mov	 edx, DWORD PTR _siz$[ebp]
  00006	8b ca		 mov	 ecx, edx
  00008	c1 e9 02	 shr	 ecx, 2
  0000b	56		 push	 esi
  0000c	8b 75 08	 mov	 esi, DWORD PTR _b$[ebp]
  0000f	85 c9		 test	 ecx, ecx
  00011	74 08		 je	 SHORT $LN3@lssproto_b

; 613  : 	unsigned int i;
; 614  : 	int *p;
; 615  : 	p = (int*)b;

  00013	57		 push	 edi
  00014	33 c0		 xor	 eax, eax
  00016	8b fe		 mov	 edi, esi
  00018	f3 ab		 rep stosd
  0001a	5f		 pop	 edi
$LN3@lssproto_b:

; 617  : 		*(p+i)=0;
; 618  : 	}
; 619  : 	for(i=0;i<siz%sizeof(int);i++) {

  0001b	8b ca		 mov	 ecx, edx
  0001d	83 e1 03	 and	 ecx, 3
  00020	76 10		 jbe	 SHORT $LN6@lssproto_b
  00022	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  00025	03 c6		 add	 eax, esi
$LL7@lssproto_b:

; 620  : 		*(b+siz-1-i)=0;

  00027	c6 00 00	 mov	 BYTE PTR [eax], 0
  0002a	8d 40 ff	 lea	 eax, DWORD PTR [eax-1]
  0002d	83 e9 01	 sub	 ecx, 1
  00030	75 f5		 jne	 SHORT $LL7@lssproto_b
$LN6@lssproto_b:
  00032	5e		 pop	 esi

; 621  : 	}
; 622  : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?lssproto_bzero@@YAXPADH@Z ENDP				; lssproto_bzero
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_default_write_wrap@@YAHHPADH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_buf$ = 12						; size = 4
_size$ = 16						; size = 4
?lssproto_default_write_wrap@@YAHHPADH@Z PROC		; lssproto_default_write_wrap, COMDAT

; 496  : #ifndef WIN32
; 497  : 	return write( fd , buf , size );
; 498  : #else
; 499  : 	return 0;

  00000	33 c0		 xor	 eax, eax

; 500  : #endif
; 501  : }

  00002	c3		 ret	 0
?lssproto_default_write_wrap@@YAHHPADH@Z ENDP		; lssproto_default_write_wrap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_CreateHeaderID@@YAXPADK0@Z
_TEXT	SEGMENT
_out$ = 8						; size = 4
_msgid$ = 12						; size = 4
_fname$ = 16						; size = 4
?lssproto_CreateHeaderID@@YAXPADK0@Z PROC		; lssproto_CreateHeaderID, COMDAT

; 584  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 585  : 	sprintf( out ,"%u %s " , (unsigned int)msgid , fname );

  00003	ff 75 10	 push	 DWORD PTR _fname$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _msgid$[ebp]
  00009	68 00 00 00 00	 push	 OFFSET ??_C@_06DBOHCIGL@?$CFu?5?$CFs?5@
  0000e	ff 75 08	 push	 DWORD PTR _out$[ebp]
  00011	e8 00 00 00 00	 call	 _sprintf
  00016	83 c4 10	 add	 esp, 16			; 00000010H

; 586  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?lssproto_CreateHeaderID@@YAXPADK0@Z ENDP		; lssproto_CreateHeaderID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_CreateHeader@@YAXPAD0@Z
_TEXT	SEGMENT
_out$ = 8						; size = 4
_fname$ = 12						; size = 4
?lssproto_CreateHeader@@YAXPAD0@Z PROC			; lssproto_CreateHeader, COMDAT

; 580  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 581  : 	sprintf( out ,"%u %s " , lssproto_GetNewMessageID() , fname );

  00003	ff 75 0c	 push	 DWORD PTR _fname$[ebp]
  00006	e8 00 00 00 00	 call	 ?lssproto_GetNewMessageID@@YAIXZ ; lssproto_GetNewMessageID
  0000b	50		 push	 eax
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_06DBOHCIGL@?$CFu?5?$CFs?5@
  00011	ff 75 08	 push	 DWORD PTR _out$[ebp]
  00014	e8 00 00 00 00	 call	 _sprintf
  00019	83 c4 10	 add	 esp, 16			; 00000010H

; 582  : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?lssproto_CreateHeader@@YAXPAD0@Z ENDP			; lssproto_CreateHeader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_GetNewMessageID@@YAIXZ
_TEXT	SEGMENT
?lssproto_GetNewMessageID@@YAIXZ PROC			; lssproto_GetNewMessageID, COMDAT

; 535  : 	return lssproto.message_id++;

  00000	a1 30 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+48
  00005	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00008	89 0d 30 00 00
	00		 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+48, ecx

; 536  : }

  0000e	c3		 ret	 0
?lssproto_GetNewMessageID@@YAIXZ ENDP			; lssproto_GetNewMessageID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_AllocateCommonWork@@YAHH@Z
_TEXT	SEGMENT
_bufsiz$ = 8						; size = 4
?lssproto_AllocateCommonWork@@YAHH@Z PROC		; lssproto_AllocateCommonWork, COMDAT

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 28   : // Terry add for 因为程式重覆呼叫此function会造成memory leak 所以要设一个旗标来了解是否已被呼叫过
; 29   : 	static BOOL bInit;
; 30   : // Terry end
; 31   : 	// Nuke start
; 32   : 	/*int i;
; 33   : 	NJT_dummy=(char *)MALLOC(time(NULL)%bufsiz);
; 34   : 	for (i=0;i<NJT_MAX;i++) {
; 35   : 		NJT[i]=NULL;
; 36   : 		NJT[i]=(char *)MALLOC(bufsiz);
; 37   : 	}
; 38   : 	for (i=0;i<NJT_MAX;i++) if (NJT[i]) break;
; 39   : 	if (i==NJT_MAX) return -1;*/
; 40   : 	// Nuke end
; 41   : // Terry modify 把底下mark的code搬到这并修正
; 42   : 	if(bInit){

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bInit@?1??lssproto_AllocateCommonWork@@YAHH@Z@4HA, 0
  0000a	0f 84 b2 00 00
	00		 je	 $LN2@lssproto_A

; 43   : 		if(lssproto.work) FREE( lssproto.work);

  00010	a1 08 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+8
  00015	85 c0		 test	 eax, eax
  00017	74 09		 je	 SHORT $LN3@lssproto_A
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _free
  0001f	83 c4 04	 add	 esp, 4
$LN3@lssproto_A:

; 44   : 		if(lssproto.arraywork) FREE( lssproto.arraywork );

  00022	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  00027	85 c0		 test	 eax, eax
  00029	74 09		 je	 SHORT $LN4@lssproto_A
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _free
  00031	83 c4 04	 add	 esp, 4
$LN4@lssproto_A:

; 45   : 		if(lssproto.escapework) FREE( lssproto.escapework);

  00034	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  00039	85 c0		 test	 eax, eax
  0003b	74 09		 je	 SHORT $LN5@lssproto_A
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _free
  00043	83 c4 04	 add	 esp, 4
$LN5@lssproto_A:

; 46   : 		if(lssproto.val_str) FREE( lssproto.val_str);

  00046	a1 14 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  0004b	85 c0		 test	 eax, eax
  0004d	74 09		 je	 SHORT $LN6@lssproto_A
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _free
  00055	83 c4 04	 add	 esp, 4
$LN6@lssproto_A:

; 47   : 		if(lssproto.token_list) FREE( lssproto.token_list);

  00058	a1 2c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+44
  0005d	85 c0		 test	 eax, eax
  0005f	74 09		 je	 SHORT $LN7@lssproto_A
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 _free
  00067	83 c4 04	 add	 esp, 4
$LN7@lssproto_A:

; 48   : 		if(lssproto.cryptwork) FREE( lssproto.cryptwork );

  0006a	a1 1c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+28
  0006f	85 c0		 test	 eax, eax
  00071	74 09		 je	 SHORT $LN8@lssproto_A
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 _free
  00079	83 c4 04	 add	 esp, 4
$LN8@lssproto_A:

; 49   : 		if(lssproto.jencodecopy) FREE( lssproto.jencodecopy );

  0007c	a1 20 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+32
  00081	85 c0		 test	 eax, eax
  00083	74 09		 je	 SHORT $LN9@lssproto_A
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 _free
  0008b	83 c4 04	 add	 esp, 4
$LN9@lssproto_A:

; 50   : 		if(lssproto.jencodeout) FREE( lssproto.jencodeout );

  0008e	a1 24 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+36
  00093	85 c0		 test	 eax, eax
  00095	74 09		 je	 SHORT $LN10@lssproto_A
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 _free
  0009d	83 c4 04	 add	 esp, 4
$LN10@lssproto_A:

; 51   : 		if(lssproto.compresswork) FREE( lssproto.compresswork );

  000a0	a1 28 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+40
  000a5	85 c0		 test	 eax, eax
  000a7	74 09		 je	 SHORT $LN11@lssproto_A
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 _free
  000af	83 c4 04	 add	 esp, 4
$LN11@lssproto_A:

; 52   : 		bInit = !bInit;

  000b2	33 c0		 xor	 eax, eax
  000b4	39 05 00 00 00
	00		 cmp	 DWORD PTR ?bInit@?1??lssproto_AllocateCommonWork@@YAHH@Z@4HA, eax
  000ba	0f 94 c0	 sete	 al
  000bd	a3 00 00 00 00	 mov	 DWORD PTR ?bInit@?1??lssproto_AllocateCommonWork@@YAHH@Z@4HA, eax
$LN2@lssproto_A:

; 53   : 	}
; 54   : // end
; 55   : 	lssproto.workbufsize = bufsiz;

  000c2	8b 45 08	 mov	 eax, DWORD PTR _bufsiz$[ebp]
  000c5	0f 57 c0	 xorps	 xmm0, xmm0

; 56   : //	lssproto.work = NJT[i];
; 57   : 	lssproto.arraywork = NULL;
; 58   : 	lssproto.escapework = NULL;
; 59   : 	lssproto.val_str = NULL;
; 60   : 	lssproto.token_list = NULL;
; 61   : 	lssproto.cryptwork = NULL;
; 62   : 	lssproto.jencodecopy = NULL;
; 63   : 	lssproto.jencodeout = NULL;
; 64   : 	lssproto.compresswork = NULL;
; 65   : 	lssproto.work = (char*)MALLOC( lssproto.workbufsize );

  000c8	50		 push	 eax
  000c9	a3 04 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4, eax
  000ce	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+12, 0
  000d8	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+16, 0
  000e2	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+20, 0
  000ec	c7 05 2c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+44, 0
  000f6	0f 11 05 1c 00
	00 00		 movups	 XMMWORD PTR ?lssproto@@3Ulssproto_@@A+28, xmm0
  000fd	e8 00 00 00 00	 call	 _malloc

; 66   : 	lssproto.arraywork = (char*)MALLOC( lssproto.workbufsize );

  00102	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00108	a3 08 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+8, eax
  0010d	e8 00 00 00 00	 call	 _malloc

; 67   : 	lssproto.escapework = (char*)MALLOC( lssproto.workbufsize );

  00112	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00118	a3 0c 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+12, eax
  0011d	e8 00 00 00 00	 call	 _malloc

; 68   : 	lssproto.val_str = (char*)MALLOC( lssproto.workbufsize );

  00122	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00128	a3 10 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+16, eax
  0012d	e8 00 00 00 00	 call	 _malloc
  00132	a3 14 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+20, eax

; 69   : 	lssproto.token_list = (char**)MALLOC( lssproto.workbufsize *sizeof( char** ) );

  00137	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  0013c	c1 e0 02	 shl	 eax, 2
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 _malloc
  00145	a3 2c 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+44, eax

; 70   : 	lssproto.cryptwork = (char*)MALLOC( lssproto.workbufsize * 3 );

  0014a	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  0014f	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00152	50		 push	 eax
  00153	e8 00 00 00 00	 call	 _malloc
  00158	a3 1c 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+28, eax

; 71   : 	lssproto.jencodecopy = (char*)MALLOC( lssproto.workbufsize * 3 );

  0015d	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00162	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00165	50		 push	 eax
  00166	e8 00 00 00 00	 call	 _malloc
  0016b	a3 20 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+32, eax

; 72   : 	lssproto.jencodeout = (char*)MALLOC( lssproto.workbufsize * 3 );

  00170	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00175	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00178	50		 push	 eax
  00179	e8 00 00 00 00	 call	 _malloc
  0017e	a3 24 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+36, eax

; 73   : 	lssproto.compresswork = (char*)MALLOC( lssproto.workbufsize * 3 );

  00183	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00188	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0018b	50		 push	 eax
  0018c	e8 00 00 00 00	 call	 _malloc

; 74   : 	memset( lssproto.work , 0, lssproto.workbufsize );

  00191	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00197	a3 28 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+40, eax
  0019c	6a 00		 push	 0
  0019e	ff 35 08 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+8
  001a4	e8 00 00 00 00	 call	 _memset

; 75   : 	memset( lssproto.arraywork , 0, lssproto.workbufsize );

  001a9	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  001af	6a 00		 push	 0
  001b1	ff 35 0c 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  001b7	e8 00 00 00 00	 call	 _memset

; 76   : 	memset( lssproto.escapework , 0, lssproto.workbufsize );

  001bc	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  001c2	6a 00		 push	 0
  001c4	ff 35 10 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  001ca	e8 00 00 00 00	 call	 _memset
  001cf	83 c4 48	 add	 esp, 72			; 00000048H

; 77   : 	memset( lssproto.val_str , 0, lssproto.workbufsize );

  001d2	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  001d8	6a 00		 push	 0
  001da	ff 35 14 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  001e0	e8 00 00 00 00	 call	 _memset

; 78   : 	memset( (char*)lssproto.token_list ,0,  lssproto.workbufsize*sizeof(char**) );

  001e5	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  001ea	c1 e0 02	 shl	 eax, 2
  001ed	50		 push	 eax
  001ee	6a 00		 push	 0
  001f0	ff 35 2c 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+44
  001f6	e8 00 00 00 00	 call	 _memset

; 79   : 	memset( lssproto.cryptwork , 0, lssproto.workbufsize*3 );

  001fb	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00200	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00203	50		 push	 eax
  00204	6a 00		 push	 0
  00206	ff 35 1c 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+28
  0020c	e8 00 00 00 00	 call	 _memset

; 80   : 	memset( lssproto.jencodecopy , 0, lssproto.workbufsize*3 );

  00211	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00216	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00219	50		 push	 eax
  0021a	6a 00		 push	 0
  0021c	ff 35 20 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+32
  00222	e8 00 00 00 00	 call	 _memset

; 81   : 	memset( lssproto.jencodeout , 0, lssproto.workbufsize*3 );

  00227	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  0022c	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0022f	50		 push	 eax
  00230	6a 00		 push	 0
  00232	ff 35 24 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+36
  00238	e8 00 00 00 00	 call	 _memset

; 82   : 	memset( lssproto.compresswork , 0, lssproto.workbufsize*3 );

  0023d	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00242	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00245	50		 push	 eax
  00246	6a 00		 push	 0
  00248	ff 35 28 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+40
  0024e	e8 00 00 00 00	 call	 _memset

; 83   : // Terry modify 搬到上面并修正
; 84   : 	bInit = !bInit;

  00253	33 c0		 xor	 eax, eax
  00255	83 c4 48	 add	 esp, 72			; 00000048H
  00258	39 05 00 00 00
	00		 cmp	 DWORD PTR ?bInit@?1??lssproto_AllocateCommonWork@@YAHH@Z@4HA, eax
  0025e	0f 94 c0	 sete	 al
  00261	a3 00 00 00 00	 mov	 DWORD PTR ?bInit@?1??lssproto_AllocateCommonWork@@YAHH@Z@4HA, eax

; 85   : /*	if( lssproto.work == NULL ||
; 86   : 	   lssproto.arraywork == NULL ||
; 87   : 	   lssproto.escapework == NULL ||
; 88   : 	   lssproto.val_str == NULL ||
; 89   : 	   lssproto.token_list == NULL ||
; 90   : 	   lssproto.cryptwork == NULL ||
; 91   : 	   lssproto.jencodecopy == NULL ||
; 92   : 	   lssproto.jencodeout == NULL ||
; 93   : 	   lssproto.compresswork == NULL ){
; 94   : 	    FREE( lssproto.work);FREE( lssproto.val_str);
; 95   : 	    FREE( lssproto.escapework);FREE( lssproto.arraywork );
; 96   : 	    FREE( lssproto.token_list);FREE( lssproto.cryptwork );
; 97   : 	    FREE( lssproto.jencodecopy);FREE( lssproto.jencodeout );
; 98   : 	    FREE( lssproto.compresswork );
; 99   : 	    return -1;
; 100  : 	}
; 101  : */
; 102  : // Terry end
; 103  : 	return 0;

  00266	33 c0		 xor	 eax, eax

; 104  : }

  00268	5d		 pop	 ebp
  00269	c3		 ret	 0
?lssproto_AllocateCommonWork@@YAHH@Z ENDP		; lssproto_AllocateCommonWork
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_Send@@YAXHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_msg$ = 12						; size = 4
?lssproto_Send@@YAXHPAD@Z PROC				; lssproto_Send, COMDAT

; 546  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 547  : 	char *encoded;
; 548  : #ifdef lssproto__ENCRYPT
; 549  : 	if( !bNewServer){

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bNewServer@@3HA, 0 ; bNewServer
  0000a	56		 push	 esi
  0000b	75 21		 jne	 SHORT $LN2@lssproto_S

; 550  : 		encoded = lssproto.cryptwork;

  0000d	8b 35 1c 00 00
	00		 mov	 esi, DWORD PTR ?lssproto@@3Ulssproto_@@A+28

; 551  : 
; 552  : 		//JL fix 原登时崩
; 553  : 		if (encoded == NULL) return;

  00013	85 f6		 test	 esi, esi
  00015	74 49		 je	 SHORT $LN1@lssproto_S

; 554  : 
; 555  : 		lssproto_encodeString( msg , encoded , lssproto.workbufsize*3 );

  00017	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  0001c	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0001f	50		 push	 eax
  00020	56		 push	 esi
  00021	ff 75 0c	 push	 DWORD PTR _msg$[ebp]
  00024	e8 00 00 00 00	 call	 ?lssproto_encodeString@@YAXPAD0H@Z ; lssproto_encodeString
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH

; 556  : 	}else

  0002c	eb 03		 jmp	 SHORT $LN3@lssproto_S
$LN2@lssproto_S:

; 557  : 		encoded = msg;

  0002e	8b 75 0c	 mov	 esi, DWORD PTR _msg$[ebp]
$LN3@lssproto_S:

; 558  : #else
; 559  :     encoded = msg;
; 560  : #endif
; 561  : 	{
; 562  : 		/* add a newline character*/
; 563  : 		unsigned int l = strlen( encoded );

  00031	8b ce		 mov	 ecx, esi
  00033	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL7@lssproto_S:
  00036	8a 01		 mov	 al, BYTE PTR [ecx]
  00038	41		 inc	 ecx
  00039	84 c0		 test	 al, al
  0003b	75 f9		 jne	 SHORT $LL7@lssproto_S

; 564  : 		if( l < lssproto.workbufsize *3){

  0003d	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00042	2b ca		 sub	 ecx, edx
  00044	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00047	3b c8		 cmp	 ecx, eax
  00049	73 07		 jae	 SHORT $LN5@lssproto_S

; 565  : //#ifndef __NEW_PROTOCOL
; 566  : 			encoded[l] = '\n';

  0004b	66 c7 04 31 0a
	00		 mov	 WORD PTR [ecx+esi], 10	; 0000000aH

; 567  : 			encoded[l+1] = 0;
; 568  : 			l++;

  00051	41		 inc	 ecx
$LN5@lssproto_S:

; 569  : //#else
; 570  : //			encoded[l] = 0;
; 571  : //#endif
; 572  : 		}
; 573  : 		lssproto.write_func( fd , encoded , l);

  00052	51		 push	 ecx
  00053	56		 push	 esi
  00054	ff 75 08	 push	 DWORD PTR _fd$[ebp]
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR ?lssproto@@3Ulssproto_@@A
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@lssproto_S:
  00060	5e		 pop	 esi

; 574  : 	}
; 575  : }

  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?lssproto_Send@@YAXHPAD@Z ENDP				; lssproto_Send
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_copyLine@@YAXPAD0H@Z
_TEXT	SEGMENT
_src$ = 8						; size = 4
_out$ = 12						; size = 4
_outlen$ = 16						; size = 4
?lssproto_copyLine@@YAXPAD0H@Z PROC			; lssproto_copyLine, COMDAT

; 521  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 524  : 		out[i] = src[i];

  00003	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00006	33 d2		 xor	 edx, edx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 7d 0c	 mov	 edi, DWORD PTR _out$[ebp]
  0000d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00010	88 0f		 mov	 BYTE PTR [edi], cl

; 525  : 		if( src[i] == '\n' ){

  00012	8a 08		 mov	 cl, BYTE PTR [eax]
  00014	80 f9 0a	 cmp	 cl, 10			; 0000000aH
  00017	74 1b		 je	 SHORT $LN10@lssproto_c

; 524  : 		out[i] = src[i];

  00019	8b f7		 mov	 esi, edi
  0001b	2b f0		 sub	 esi, eax
  0001d	0f 1f 00	 npad	 3
$LL4@lssproto_c:

; 527  : 			return;
; 528  : 		}
; 529  : 		if( src[i] == '\0' )return;

  00020	84 c9		 test	 cl, cl
  00022	74 15		 je	 SHORT $LN11@lssproto_c

; 522  : 	int i;
; 523  : 	for(i=0;;i++){

  00024	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00028	40		 inc	 eax
  00029	42		 inc	 edx

; 524  : 		out[i] = src[i];

  0002a	88 0c 06	 mov	 BYTE PTR [esi+eax], cl

; 525  : 		if( src[i] == '\n' ){

  0002d	8a 08		 mov	 cl, BYTE PTR [eax]
  0002f	80 f9 0a	 cmp	 cl, 10			; 0000000aH
  00032	75 ec		 jne	 SHORT $LL4@lssproto_c
$LN10@lssproto_c:

; 526  : 			out[i+1] = '\0' ;

  00034	c6 44 3a 01 00	 mov	 BYTE PTR [edx+edi+1], 0
$LN11@lssproto_c:
  00039	5f		 pop	 edi

; 530  : 	}
; 531  : 	lssproto_strcpysafe( out , "" , outlen );
; 532  : }

  0003a	5e		 pop	 esi
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?lssproto_copyLine@@YAXPAD0H@Z ENDP			; lssproto_copyLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_consumeLine@@YAXPADH@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_offset$ = 12						; size = 4
?lssproto_consumeLine@@YAXPADH@Z PROC			; lssproto_consumeLine, COMDAT

; 504  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 505  : 	int i;
; 506  : 	int shift=0;
; 507  : 	buf+= offset;

  00003	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]

; 508  : 	for(i=0;;i++){

  00006	33 c9		 xor	 ecx, ecx
  00008	03 45 0c	 add	 eax, DWORD PTR _offset$[ebp]

; 509  : 		if( buf[i] == '\n' ){

  0000b	80 38 0a	 cmp	 BYTE PTR [eax], 10	; 0000000aH
  0000e	74 07		 je	 SHORT $LN15@lssproto_c
$LL4@lssproto_c:

; 508  : 	for(i=0;;i++){

  00010	41		 inc	 ecx

; 509  : 		if( buf[i] == '\n' ){

  00011	80 3c 01 0a	 cmp	 BYTE PTR [ecx+eax], 10	; 0000000aH
  00015	75 f9		 jne	 SHORT $LL4@lssproto_c
$LN15@lssproto_c:

; 510  : 			shift = i + 1;

  00017	83 c1 01	 add	 ecx, 1

; 511  : 			break;
; 512  : 		}
; 513  : 	}
; 514  :     if( shift == 0 )return;

  0001a	74 24		 je	 SHORT $LN16@lssproto_c

; 515  : 	for(i=shift;;i++){
; 516  : 		buf[i - shift] = buf[i];

  0001c	8d 14 01	 lea	 edx, DWORD PTR [ecx+eax]
  0001f	8a 0a		 mov	 cl, BYTE PTR [edx]
  00021	88 08		 mov	 BYTE PTR [eax], cl

; 517  : 		if( buf[i] == '\0')break;

  00023	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00026	74 18		 je	 SHORT $LN16@lssproto_c
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL7@lssproto_c:

; 515  : 	for(i=shift;;i++){
; 516  : 		buf[i - shift] = buf[i];

  00030	8a 4a 01	 mov	 cl, BYTE PTR [edx+1]
  00033	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00036	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00039	88 08		 mov	 BYTE PTR [eax], cl

; 517  : 		if( buf[i] == '\0')break;

  0003b	80 3a 00	 cmp	 BYTE PTR [edx], 0
  0003e	75 f0		 jne	 SHORT $LL7@lssproto_c
$LN16@lssproto_c:

; 518  : 	}
; 519  : }

  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?lssproto_consumeLine@@YAXPADH@Z ENDP			; lssproto_consumeLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_GetMessageInfo@@YAXPAHPADHPAPAD@Z
_TEXT	SEGMENT
_id$ = 8						; size = 4
_funcname$ = 12						; size = 4
_len$ = 16						; size = 4
_tk$ = 20						; size = 4
?lssproto_GetMessageInfo@@YAXPAHPADHPAPAD@Z PROC	; lssproto_GetMessageInfo, COMDAT

; 109  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 110  : 	if( tk[0] == NULL || tk[1] == NULL ){

  00004	8b 75 14	 mov	 esi, DWORD PTR _tk$[ebp]
  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	85 c0		 test	 eax, eax
  0000b	74 29		 je	 SHORT $LN3@lssproto_G
  0000d	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00011	74 23		 je	 SHORT $LN3@lssproto_G

; 113  : 		return;
; 114  : 	}
; 115  : 	*id =  strtoul( tk[0] ,NULL,10);

  00013	6a 0a		 push	 10			; 0000000aH
  00015	6a 00		 push	 0
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 _strtoul
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]

; 116  : 	lssproto_strcpysafe( funcname , tk[1] , len );

  00020	ff 75 10	 push	 DWORD PTR _len$[ebp]
  00023	89 01		 mov	 DWORD PTR [ecx], eax
  00025	ff 76 04	 push	 DWORD PTR [esi+4]
  00028	ff 75 0c	 push	 DWORD PTR _funcname$[ebp]
  0002b	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe
  00030	83 c4 18	 add	 esp, 24			; 00000018H
  00033	5e		 pop	 esi

; 117  : 	return;
; 118  : }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN3@lssproto_G:

; 111  : 		*id = 0;
; 112  : 		lssproto_strcpysafe( funcname , "" , len );

  00036	ff 75 10	 push	 DWORD PTR _len$[ebp]
  00039	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  00041	ff 75 0c	 push	 DWORD PTR _funcname$[ebp]
  00044	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0004a	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00052	5e		 pop	 esi

; 117  : 	return;
; 118  : }

  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?lssproto_GetMessageInfo@@YAXPAHPADHPAPAD@Z ENDP	; lssproto_GetMessageInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_wrapStringAddr@@YAPADPADH0@Z
_TEXT	SEGMENT
_copy$ = 8						; size = 4
_maxcopylen$ = 12					; size = 4
_src$ = 16						; size = 4
?lssproto_wrapStringAddr@@YAPADPADH0@Z PROC		; lssproto_wrapStringAddr, COMDAT

; 604  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 605  : 	lssproto_strcpysafe( copy , src , maxcopylen );

  00003	ff 75 0c	 push	 DWORD PTR _maxcopylen$[ebp]
  00006	ff 75 10	 push	 DWORD PTR _src$[ebp]
  00009	ff 75 08	 push	 DWORD PTR _copy$[ebp]
  0000c	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe

; 606  : 	return copy;

  00011	8b 45 08	 mov	 eax, DWORD PTR _copy$[ebp]
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 607  : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?lssproto_wrapStringAddr@@YAPADPADH0@Z ENDP		; lssproto_wrapStringAddr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_u_double_array@@YAPANPAPADPANHH@Z
_TEXT	SEGMENT
__real@0000000000000000$1$ = -16			; size = 8
$T1 = -8						; size = 8
_tk$ = 8						; size = 4
_buf$ = 12						; size = 4
_start$ = 16						; size = 4
_size$ = 20						; size = 4
?lssproto_demkstr_u_double_array@@YAPANPAPADPANHH@Z PROC ; lssproto_demkstr_u_double_array, COMDAT

; 374  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 375  : 	DEMKSTR_ARRAYMACRO( lssproto_demkstr_double , (double)0.0);

  00007	8b 5d 14	 mov	 ebx, DWORD PTR _size$[ebp]
  0000a	56		 push	 esi
  0000b	8b 75 10	 mov	 esi, DWORD PTR _start$[ebp]
  0000e	03 de		 add	 ebx, esi
  00010	3b f3		 cmp	 esi, ebx
  00012	7d 3c		 jge	 SHORT $LN12@lssproto_d
  00014	8b 45 08	 mov	 eax, DWORD PTR _tk$[ebp]
  00017	0f 57 c0	 xorps	 xmm0, xmm0
  0001a	57		 push	 edi
  0001b	8b 7d 0c	 mov	 edi, DWORD PTR _buf$[ebp]
  0001e	f2 0f 11 45 f0	 movsd	 QWORD PTR __real@0000000000000000$1$[ebp], xmm0
$LL4@lssproto_d:
  00023	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00026	85 c0		 test	 eax, eax
  00028	74 11		 je	 SHORT $LN2@lssproto_d
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?lssproto_demkstr_double@@YANPAD@Z ; lssproto_demkstr_double
  00030	dd 5d f8	 fstp	 QWORD PTR $T1[ebp]
  00033	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR $T1[ebp]
  00038	83 c4 04	 add	 esp, 4
$LN2@lssproto_d:
  0003b	8b 45 08	 mov	 eax, DWORD PTR _tk$[ebp]
  0003e	46		 inc	 esi
  0003f	f2 0f 11 07	 movsd	 QWORD PTR [edi], xmm0
  00043	83 c7 08	 add	 edi, 8
  00046	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR __real@0000000000000000$1$[ebp]
  0004b	3b f3		 cmp	 esi, ebx
  0004d	7c d4		 jl	 SHORT $LL4@lssproto_d
  0004f	5f		 pop	 edi
$LN12@lssproto_d:

; 376  : }

  00050	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?lssproto_demkstr_u_double_array@@YAPANPAPADPANHH@Z ENDP ; lssproto_demkstr_u_double_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_float_array@@YAPAMPAPADPAMHH@Z
_TEXT	SEGMENT
_tk$ = 8						; size = 4
_buf$ = 12						; size = 4
$T1 = 16						; size = 4
_start$ = 16						; size = 4
_size$ = 20						; size = 4
?lssproto_demkstr_float_array@@YAPAMPAPADPAMHH@Z PROC	; lssproto_demkstr_float_array, COMDAT

; 370  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 371  : 	DEMKSTR_ARRAYMACRO( lssproto_demkstr_float , (float)0.0);

  00004	8b 5d 14	 mov	 ebx, DWORD PTR _size$[ebp]
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _start$[ebp]
  0000b	03 de		 add	 ebx, esi
  0000d	3b f3		 cmp	 esi, ebx
  0000f	7d 3a		 jge	 SHORT $LN12@lssproto_d
  00011	8b 45 08	 mov	 eax, DWORD PTR _tk$[ebp]
  00014	0f 57 c0	 xorps	 xmm0, xmm0
  00017	57		 push	 edi
  00018	8b 7d 0c	 mov	 edi, DWORD PTR _buf$[ebp]
  0001b	0f 1f 44 00 00	 npad	 5
$LL4@lssproto_d:
  00020	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00023	85 c0		 test	 eax, eax
  00025	74 11		 je	 SHORT $LN2@lssproto_d
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?lssproto_demkstr_float@@YAMPAD@Z ; lssproto_demkstr_float
  0002d	d9 5d 10	 fstp	 DWORD PTR $T1[ebp]
  00030	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR $T1[ebp]
  00035	83 c4 04	 add	 esp, 4
$LN2@lssproto_d:
  00038	8b 45 08	 mov	 eax, DWORD PTR _tk$[ebp]
  0003b	46		 inc	 esi
  0003c	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0
  00040	83 c7 04	 add	 edi, 4
  00043	0f 57 c0	 xorps	 xmm0, xmm0
  00046	3b f3		 cmp	 esi, ebx
  00048	7c d6		 jl	 SHORT $LL4@lssproto_d
  0004a	5f		 pop	 edi
$LN12@lssproto_d:

; 372  : }

  0004b	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?lssproto_demkstr_float_array@@YAPAMPAPADPAMHH@Z ENDP	; lssproto_demkstr_float_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_u_char_array@@YAPAEPAPADPAEHH@Z
_TEXT	SEGMENT
_tk$ = 8						; size = 4
_buf$ = 12						; size = 4
_start$ = 16						; size = 4
_size$ = 20						; size = 4
?lssproto_demkstr_u_char_array@@YAPAEPAPADPAEHH@Z PROC	; lssproto_demkstr_u_char_array, COMDAT

; 366  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 367  : 	DEMKSTR_ARRAYMACRO( lssproto_demkstr_u_char , 0);

  00004	8b 5d 14	 mov	 ebx, DWORD PTR _size$[ebp]
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _start$[ebp]
  0000b	03 de		 add	 ebx, esi
  0000d	3b f3		 cmp	 esi, ebx
  0000f	7d 2f		 jge	 SHORT $LN12@lssproto_d
  00011	8b 45 08	 mov	 eax, DWORD PTR _tk$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 0c	 mov	 edi, DWORD PTR _buf$[ebp]
  00018	2b fe		 sub	 edi, esi
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL4@lssproto_d:
  00020	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $LN5@lssproto_d
  00027	32 c0		 xor	 al, al
  00029	eb 09		 jmp	 SHORT $LN2@lssproto_d
$LN5@lssproto_d:
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?lssproto_demkstr_u_char@@YAEPAD@Z ; lssproto_demkstr_u_char
  00031	83 c4 04	 add	 esp, 4
$LN2@lssproto_d:
  00034	88 04 37	 mov	 BYTE PTR [edi+esi], al
  00037	46		 inc	 esi
  00038	8b 45 08	 mov	 eax, DWORD PTR _tk$[ebp]
  0003b	3b f3		 cmp	 esi, ebx
  0003d	7c e1		 jl	 SHORT $LL4@lssproto_d
  0003f	5f		 pop	 edi
$LN12@lssproto_d:

; 368  : }

  00040	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?lssproto_demkstr_u_char_array@@YAPAEPAPADPAEHH@Z ENDP	; lssproto_demkstr_u_char_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_char_array@@YAPADPAPADPADHH@Z
_TEXT	SEGMENT
_tk$ = 8						; size = 4
_buf$ = 12						; size = 4
_start$ = 16						; size = 4
_size$ = 20						; size = 4
?lssproto_demkstr_char_array@@YAPADPAPADPADHH@Z PROC	; lssproto_demkstr_char_array, COMDAT

; 361  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 362  : 	DEMKSTR_ARRAYMACRO( lssproto_demkstr_u_char , 0);

  00004	8b 5d 14	 mov	 ebx, DWORD PTR _size$[ebp]
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _start$[ebp]
  0000b	03 de		 add	 ebx, esi
  0000d	3b f3		 cmp	 esi, ebx
  0000f	7d 2f		 jge	 SHORT $LN12@lssproto_d
  00011	8b 45 08	 mov	 eax, DWORD PTR _tk$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 0c	 mov	 edi, DWORD PTR _buf$[ebp]
  00018	2b fe		 sub	 edi, esi
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL4@lssproto_d:
  00020	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $LN5@lssproto_d
  00027	32 c0		 xor	 al, al
  00029	eb 09		 jmp	 SHORT $LN2@lssproto_d
$LN5@lssproto_d:
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?lssproto_demkstr_u_char@@YAEPAD@Z ; lssproto_demkstr_u_char
  00031	83 c4 04	 add	 esp, 4
$LN2@lssproto_d:
  00034	88 04 37	 mov	 BYTE PTR [edi+esi], al
  00037	46		 inc	 esi
  00038	8b 45 08	 mov	 eax, DWORD PTR _tk$[ebp]
  0003b	3b f3		 cmp	 esi, ebx
  0003d	7c e1		 jl	 SHORT $LL4@lssproto_d
  0003f	5f		 pop	 edi
$LN12@lssproto_d:

; 363  : }

  00040	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?lssproto_demkstr_char_array@@YAPADPAPADPADHH@Z ENDP	; lssproto_demkstr_char_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_u_short_array@@YAPAGPAPADPAGHH@Z
_TEXT	SEGMENT
_tk$ = 8						; size = 4
_buf$ = 12						; size = 4
_start$ = 16						; size = 4
_size$ = 20						; size = 4
?lssproto_demkstr_u_short_array@@YAPAGPAPADPAGHH@Z PROC	; lssproto_demkstr_u_short_array, COMDAT

; 357  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 358  : 	DEMKSTR_ARRAYMACRO( lssproto_demkstr_u_short , 0);

  00004	8b 5d 14	 mov	 ebx, DWORD PTR _size$[ebp]
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _start$[ebp]
  0000b	03 de		 add	 ebx, esi
  0000d	3b f3		 cmp	 esi, ebx
  0000f	7d 29		 jge	 SHORT $LN12@lssproto_d
  00011	8b 45 08	 mov	 eax, DWORD PTR _tk$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 0c	 mov	 edi, DWORD PTR _buf$[ebp]
$LL4@lssproto_d:
  00018	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  0001b	85 c0		 test	 eax, eax
  0001d	74 0c		 je	 SHORT $LN2@lssproto_d
$LN5@lssproto_d:
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?lssproto_demkstr_u_short@@YAGPAD@Z ; lssproto_demkstr_u_short
  00025	83 c4 04	 add	 esp, 4
  00028	0f b7 c0	 movzx	 eax, ax
$LN2@lssproto_d:
  0002b	66 89 07	 mov	 WORD PTR [edi], ax
  0002e	46		 inc	 esi
  0002f	8b 45 08	 mov	 eax, DWORD PTR _tk$[ebp]
  00032	83 c7 02	 add	 edi, 2
  00035	3b f3		 cmp	 esi, ebx
  00037	7c df		 jl	 SHORT $LL4@lssproto_d
  00039	5f		 pop	 edi
$LN12@lssproto_d:

; 359  : }

  0003a	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?lssproto_demkstr_u_short_array@@YAPAGPAPADPAGHH@Z ENDP	; lssproto_demkstr_u_short_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_short_array@@YAPAFPAPADPAFHH@Z
_TEXT	SEGMENT
_tk$ = 8						; size = 4
_buf$ = 12						; size = 4
_start$ = 16						; size = 4
_size$ = 20						; size = 4
?lssproto_demkstr_short_array@@YAPAFPAPADPAFHH@Z PROC	; lssproto_demkstr_short_array, COMDAT

; 352  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 353  : 	DEMKSTR_ARRAYMACRO( lssproto_demkstr_short , 0);

  00004	8b 5d 14	 mov	 ebx, DWORD PTR _size$[ebp]
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _start$[ebp]
  0000b	03 de		 add	 ebx, esi
  0000d	3b f3		 cmp	 esi, ebx
  0000f	7d 29		 jge	 SHORT $LN12@lssproto_d
  00011	8b 45 08	 mov	 eax, DWORD PTR _tk$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 0c	 mov	 edi, DWORD PTR _buf$[ebp]
$LL4@lssproto_d:
  00018	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  0001b	85 c0		 test	 eax, eax
  0001d	74 0c		 je	 SHORT $LN2@lssproto_d
$LN5@lssproto_d:
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?lssproto_demkstr_short@@YAFPAD@Z ; lssproto_demkstr_short
  00025	83 c4 04	 add	 esp, 4
  00028	0f b7 c0	 movzx	 eax, ax
$LN2@lssproto_d:
  0002b	66 89 07	 mov	 WORD PTR [edi], ax
  0002e	46		 inc	 esi
  0002f	8b 45 08	 mov	 eax, DWORD PTR _tk$[ebp]
  00032	83 c7 02	 add	 edi, 2
  00035	3b f3		 cmp	 esi, ebx
  00037	7c df		 jl	 SHORT $LL4@lssproto_d
  00039	5f		 pop	 edi
$LN12@lssproto_d:

; 354  : }

  0003a	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?lssproto_demkstr_short_array@@YAPAFPAPADPAFHH@Z ENDP	; lssproto_demkstr_short_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_u_long_array@@YAPAKPAPADPAKHH@Z
_TEXT	SEGMENT
_tk$ = 8						; size = 4
_buf$ = 12						; size = 4
_start$ = 16						; size = 4
_size$ = 20						; size = 4
?lssproto_demkstr_u_long_array@@YAPAKPAPADPAKHH@Z PROC	; lssproto_demkstr_u_long_array, COMDAT

; 348  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 349  : 	DEMKSTR_ARRAYMACRO( lssproto_demkstr_u_long , 0);

  00004	8b 5d 14	 mov	 ebx, DWORD PTR _size$[ebp]
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _start$[ebp]
  0000b	03 de		 add	 ebx, esi
  0000d	3b f3		 cmp	 esi, ebx
  0000f	7d 25		 jge	 SHORT $LN12@lssproto_d
  00011	8b 45 08	 mov	 eax, DWORD PTR _tk$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 0c	 mov	 edi, DWORD PTR _buf$[ebp]
$LL4@lssproto_d:
  00018	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  0001b	85 c0		 test	 eax, eax
  0001d	74 09		 je	 SHORT $LN2@lssproto_d
$LN5@lssproto_d:
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?lssproto_demkstr_u_long@@YAKPAD@Z ; lssproto_demkstr_u_long
  00025	83 c4 04	 add	 esp, 4
$LN2@lssproto_d:
  00028	89 07		 mov	 DWORD PTR [edi], eax
  0002a	46		 inc	 esi
  0002b	8b 45 08	 mov	 eax, DWORD PTR _tk$[ebp]
  0002e	83 c7 04	 add	 edi, 4
  00031	3b f3		 cmp	 esi, ebx
  00033	7c e3		 jl	 SHORT $LL4@lssproto_d
  00035	5f		 pop	 edi
$LN12@lssproto_d:

; 350  : }

  00036	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?lssproto_demkstr_u_long_array@@YAPAKPAPADPAKHH@Z ENDP	; lssproto_demkstr_u_long_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_long_array@@YAPAIPAPADPAIHH@Z
_TEXT	SEGMENT
_tk$ = 8						; size = 4
_buf$ = 12						; size = 4
_start$ = 16						; size = 4
_size$ = 20						; size = 4
?lssproto_demkstr_long_array@@YAPAIPAPADPAIHH@Z PROC	; lssproto_demkstr_long_array, COMDAT

; 343  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 344  : 	DEMKSTR_ARRAYMACRO( lssproto_demkstr_long  , 0);

  00004	8b 5d 14	 mov	 ebx, DWORD PTR _size$[ebp]
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _start$[ebp]
  0000b	03 de		 add	 ebx, esi
  0000d	3b f3		 cmp	 esi, ebx
  0000f	7d 25		 jge	 SHORT $LN12@lssproto_d
  00011	8b 45 08	 mov	 eax, DWORD PTR _tk$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 0c	 mov	 edi, DWORD PTR _buf$[ebp]
$LL4@lssproto_d:
  00018	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  0001b	85 c0		 test	 eax, eax
  0001d	74 09		 je	 SHORT $LN2@lssproto_d
$LN5@lssproto_d:
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?lssproto_demkstr_long@@YAJPAD@Z ; lssproto_demkstr_long
  00025	83 c4 04	 add	 esp, 4
$LN2@lssproto_d:
  00028	89 07		 mov	 DWORD PTR [edi], eax
  0002a	46		 inc	 esi
  0002b	8b 45 08	 mov	 eax, DWORD PTR _tk$[ebp]
  0002e	83 c7 04	 add	 edi, 4
  00031	3b f3		 cmp	 esi, ebx
  00033	7c e3		 jl	 SHORT $LL4@lssproto_d
  00035	5f		 pop	 edi
$LN12@lssproto_d:

; 345  : }

  00036	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?lssproto_demkstr_long_array@@YAPAIPAPADPAIHH@Z ENDP	; lssproto_demkstr_long_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_u_int_array@@YAPAHPAPADPAHHH@Z
_TEXT	SEGMENT
_tk$ = 8						; size = 4
_buf$ = 12						; size = 4
_start$ = 16						; size = 4
_size$ = 20						; size = 4
?lssproto_demkstr_u_int_array@@YAPAHPAPADPAHHH@Z PROC	; lssproto_demkstr_u_int_array, COMDAT

; 338  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 339  : 	DEMKSTR_ARRAYMACRO( lssproto_demkstr_u_int , 0 );

  00004	8b 5d 14	 mov	 ebx, DWORD PTR _size$[ebp]
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _start$[ebp]
  0000b	03 de		 add	 ebx, esi
  0000d	3b f3		 cmp	 esi, ebx
  0000f	7d 25		 jge	 SHORT $LN12@lssproto_d
  00011	8b 45 08	 mov	 eax, DWORD PTR _tk$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 0c	 mov	 edi, DWORD PTR _buf$[ebp]
$LL4@lssproto_d:
  00018	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  0001b	85 c0		 test	 eax, eax
  0001d	74 09		 je	 SHORT $LN2@lssproto_d
$LN5@lssproto_d:
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?lssproto_demkstr_u_int@@YAIPAD@Z ; lssproto_demkstr_u_int
  00025	83 c4 04	 add	 esp, 4
$LN2@lssproto_d:
  00028	89 07		 mov	 DWORD PTR [edi], eax
  0002a	46		 inc	 esi
  0002b	8b 45 08	 mov	 eax, DWORD PTR _tk$[ebp]
  0002e	83 c7 04	 add	 edi, 4
  00031	3b f3		 cmp	 esi, ebx
  00033	7c e3		 jl	 SHORT $LL4@lssproto_d
  00035	5f		 pop	 edi
$LN12@lssproto_d:

; 340  : }

  00036	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?lssproto_demkstr_u_int_array@@YAPAHPAPADPAHHH@Z ENDP	; lssproto_demkstr_u_int_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_int_array@@YAPAHPAPADPAHHH@Z
_TEXT	SEGMENT
_tk$ = 8						; size = 4
_buf$ = 12						; size = 4
_start$ = 16						; size = 4
_size$ = 20						; size = 4
?lssproto_demkstr_int_array@@YAPAHPAPADPAHHH@Z PROC	; lssproto_demkstr_int_array, COMDAT

; 322  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 323  : #define DEMKSTR_ARRAYMACRO( func, defaultvalue )          \
; 324  :     {\
; 325  :         int i;\
; 326  :         for(i=start;i<(start+size);i++){\
; 327  :             if( tk[i] == NULL ){   \
; 328  : 		        buf[i-start]=defaultvalue ;\
; 329  :             } else {\
; 330  :      	 	    buf[i-start] = func( tk[i] );\
; 331  :             }\
; 332  : 	    }\
; 333  :         return buf;\
; 334  :     }
; 335  :     DEMKSTR_ARRAYMACRO( lssproto_demkstr_int , 0 );

  00004	8b 5d 14	 mov	 ebx, DWORD PTR _size$[ebp]
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _start$[ebp]
  0000b	03 de		 add	 ebx, esi
  0000d	3b f3		 cmp	 esi, ebx
  0000f	7d 25		 jge	 SHORT $LN12@lssproto_d
  00011	8b 45 08	 mov	 eax, DWORD PTR _tk$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 0c	 mov	 edi, DWORD PTR _buf$[ebp]
$LL4@lssproto_d:
  00018	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  0001b	85 c0		 test	 eax, eax
  0001d	74 09		 je	 SHORT $LN2@lssproto_d
$LN5@lssproto_d:
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?lssproto_demkstr_int@@YAHPAD@Z ; lssproto_demkstr_int
  00025	83 c4 04	 add	 esp, 4
$LN2@lssproto_d:
  00028	89 07		 mov	 DWORD PTR [edi], eax
  0002a	46		 inc	 esi
  0002b	8b 45 08	 mov	 eax, DWORD PTR _tk$[ebp]
  0002e	83 c7 04	 add	 edi, 4
  00031	3b f3		 cmp	 esi, ebx
  00033	7c e3		 jl	 SHORT $LL4@lssproto_d
  00035	5f		 pop	 edi
$LN12@lssproto_d:

; 336  : }

  00036	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?lssproto_demkstr_int_array@@YAPAHPAPADPAHHH@Z ENDP	; lssproto_demkstr_int_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_string@@YAPADPAD@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?lssproto_demkstr_string@@YAPADPAD@Z PROC		; lssproto_demkstr_string, COMDAT

; 314  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 315  : 	if( a == (char*)NULL){

  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 20		 jne	 SHORT $LN2@lssproto_d

; 316  : 		lssproto_strcpysafe( lssproto.escapework , "" , lssproto.workbufsize );

  0000a	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  00015	ff 35 10 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  0001b	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe

; 317  : 		return lssproto.escapework;

  00020	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH

; 320  : }

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
$LN2@lssproto_d:

; 318  : 	}
; 319  : 	return lssproto_descapeString( a );

  0002a	89 45 08	 mov	 DWORD PTR _a$[ebp], eax

; 320  : }

  0002d	5d		 pop	 ebp

; 318  : 	}
; 319  : 	return lssproto_descapeString( a );

  0002e	e9 00 00 00 00	 jmp	 ?lssproto_descapeString@@YAPADPAD@Z ; lssproto_descapeString
?lssproto_demkstr_string@@YAPADPAD@Z ENDP		; lssproto_demkstr_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_double@@YANPAD@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?lssproto_demkstr_double@@YANPAD@Z PROC			; lssproto_demkstr_double, COMDAT

; 309  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 310  : 	if( a == (char*)NULL)return 0.0F;

  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN2@lssproto_d
  0000a	d9 ee		 fldz

; 312  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN2@lssproto_d:

; 311  : 	return (double) strtod( a , NULL );

  0000e	6a 00		 push	 0
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 _strtod
  00016	83 c4 08	 add	 esp, 8

; 312  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?lssproto_demkstr_double@@YANPAD@Z ENDP			; lssproto_demkstr_double
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_float@@YAMPAD@Z
_TEXT	SEGMENT
tv69 = 8						; size = 4
_a$ = 8							; size = 4
?lssproto_demkstr_float@@YAMPAD@Z PROC			; lssproto_demkstr_float, COMDAT

; 304  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 305  : 	if( a == (char*)NULL)return 0.0F;

  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN2@lssproto_d
  0000a	d9 ee		 fldz

; 307  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN2@lssproto_d:

; 306  : 	return (float) atof( a);

  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _atof
  00014	d9 5d 08	 fstp	 DWORD PTR tv69[ebp]
  00017	d9 45 08	 fld	 DWORD PTR tv69[ebp]
  0001a	83 c4 04	 add	 esp, 4

; 307  : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?lssproto_demkstr_float@@YAMPAD@Z ENDP			; lssproto_demkstr_float
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_u_char@@YAEPAD@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?lssproto_demkstr_u_char@@YAEPAD@Z PROC			; lssproto_demkstr_u_char, COMDAT

; 299  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 300  : 	if( a == (char*)NULL)return 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN2@lssproto_d
  0000a	32 c0		 xor	 al, al

; 302  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN2@lssproto_d:

; 301  : 	return (unsigned char ) strtoul( a,NULL , 10 );

  0000e	6a 0a		 push	 10			; 0000000aH
  00010	6a 00		 push	 0
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _strtoul
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 302  : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?lssproto_demkstr_u_char@@YAEPAD@Z ENDP			; lssproto_demkstr_u_char
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_char@@YADPAD@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?lssproto_demkstr_char@@YADPAD@Z PROC			; lssproto_demkstr_char, COMDAT

; 294  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 295  : 	if( a == (char*)NULL)return 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN2@lssproto_d
  0000a	32 c0		 xor	 al, al

; 297  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN2@lssproto_d:

; 296  : 	return (char) strtol(  a  , NULL , 10 );

  0000e	6a 0a		 push	 10			; 0000000aH
  00010	6a 00		 push	 0
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _strtol
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 297  : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?lssproto_demkstr_char@@YADPAD@Z ENDP			; lssproto_demkstr_char
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_u_short@@YAGPAD@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?lssproto_demkstr_u_short@@YAGPAD@Z PROC		; lssproto_demkstr_u_short, COMDAT

; 289  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 290  : 	if( a == (char*)NULL)return 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 02		 jne	 SHORT $LN2@lssproto_d

; 292  : }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
$LN2@lssproto_d:

; 291  : 	return (unsigned short) strtoul( a , NULL , 10 );

  0000c	6a 0a		 push	 10			; 0000000aH
  0000e	6a 00		 push	 0
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 _strtoul
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 292  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?lssproto_demkstr_u_short@@YAGPAD@Z ENDP		; lssproto_demkstr_u_short
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_short@@YAFPAD@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?lssproto_demkstr_short@@YAFPAD@Z PROC			; lssproto_demkstr_short, COMDAT

; 284  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 285  : 	if( a == (char*)NULL)return 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 02		 jne	 SHORT $LN2@lssproto_d

; 287  : }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
$LN2@lssproto_d:

; 286  : 	return (short) strtol( a , NULL , 10 );

  0000c	6a 0a		 push	 10			; 0000000aH
  0000e	6a 00		 push	 0
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 _strtol
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 287  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?lssproto_demkstr_short@@YAFPAD@Z ENDP			; lssproto_demkstr_short
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_u_long@@YAKPAD@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?lssproto_demkstr_u_long@@YAKPAD@Z PROC			; lssproto_demkstr_u_long, COMDAT

; 279  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	if( a == (char*)NULL)return 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 02		 jne	 SHORT $LN2@lssproto_d

; 282  : }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
$LN2@lssproto_d:

; 281  : 	return (unsigned long ) strtoul( a , NULL , 10 ) ;

  0000c	6a 0a		 push	 10			; 0000000aH
  0000e	6a 00		 push	 0
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 _strtoul
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 282  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?lssproto_demkstr_u_long@@YAKPAD@Z ENDP			; lssproto_demkstr_u_long
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_long@@YAJPAD@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?lssproto_demkstr_long@@YAJPAD@Z PROC			; lssproto_demkstr_long, COMDAT

; 274  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 275  : 	if( a == (char*)NULL)return 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 02		 jne	 SHORT $LN2@lssproto_d

; 277  : }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
$LN2@lssproto_d:

; 276  : 	return (long)strtol( a , NULL , 10 );

  0000c	6a 0a		 push	 10			; 0000000aH
  0000e	6a 00		 push	 0
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 _strtol
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 277  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?lssproto_demkstr_long@@YAJPAD@Z ENDP			; lssproto_demkstr_long
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_u_int@@YAIPAD@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?lssproto_demkstr_u_int@@YAIPAD@Z PROC			; lssproto_demkstr_u_int, COMDAT

; 269  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 270  : 	if( a == (char*)NULL)return 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 02		 jne	 SHORT $LN2@lssproto_d

; 272  : }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
$LN2@lssproto_d:

; 271  : 	return (unsigned int ) strtoul( a ,NULL,10);

  0000c	6a 0a		 push	 10			; 0000000aH
  0000e	6a 00		 push	 0
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 _strtoul
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 272  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?lssproto_demkstr_u_int@@YAIPAD@Z ENDP			; lssproto_demkstr_u_int
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_int@@YAHPAD@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?lssproto_demkstr_int@@YAHPAD@Z PROC			; lssproto_demkstr_int, COMDAT

; 263  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 264  : 	if( a == (char*)NULL)return 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 02		 jne	 SHORT $LN2@lssproto_d

; 267  : }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
$LN2@lssproto_d:

; 265  : /*	return (int)strtol( a ,NULL , 10);*/
; 266  : 	return lssproto_a62toi( a );

  0000c	89 45 08	 mov	 DWORD PTR _a$[ebp], eax

; 267  : }

  0000f	5d		 pop	 ebp

; 265  : /*	return (int)strtol( a ,NULL , 10);*/
; 266  : 	return lssproto_a62toi( a );

  00010	e9 00 00 00 00	 jmp	 ?lssproto_a62toi@@YAHPAD@Z ; lssproto_a62toi
?lssproto_demkstr_int@@YAHPAD@Z ENDP			; lssproto_demkstr_int
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_double_array@@YAPADHPAN@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
_array$ = 12						; size = 4
?lssproto_mkstr_double_array@@YAPADHPAN@Z PROC		; lssproto_mkstr_double_array, COMDAT

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 257  : 	MKSTR_ARRAYMACRO( lssproto_mkstr_double );

  00003	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR _size$[ebp]
  0000d	33 f6		 xor	 esi, esi
  0000f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00012	85 ff		 test	 edi, edi
  00014	7e 3a		 jle	 SHORT $LN10@lssproto_m
  00016	53		 push	 ebx
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _array$[ebp]
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL4@lssproto_m:
  00020	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00026	f2 0f 10 04 f3	 movsd	 xmm0, QWORD PTR [ebx+esi*8]
  0002b	83 ec 08	 sub	 esp, 8
  0002e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00033	e8 00 00 00 00	 call	 ?lssproto_mkstr_double@@YAPADN@Z ; lssproto_mkstr_double
  00038	83 c4 08	 add	 esp, 8
  0003b	50		 push	 eax
  0003c	ff 35 0c 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  00042	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  00047	46		 inc	 esi
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004b	3b f7		 cmp	 esi, edi
  0004d	7c d1		 jl	 SHORT $LL4@lssproto_m
  0004f	5b		 pop	 ebx
$LN10@lssproto_m:

; 258  : }

  00050	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?lssproto_mkstr_double_array@@YAPADHPAN@Z ENDP		; lssproto_mkstr_double_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_float_array@@YAPADHPAM@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
_array$ = 12						; size = 4
?lssproto_mkstr_float_array@@YAPADHPAM@Z PROC		; lssproto_mkstr_float_array, COMDAT

; 252  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 253  : 	MKSTR_ARRAYMACRO( lssproto_mkstr_float );

  00003	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR _size$[ebp]
  0000d	33 f6		 xor	 esi, esi
  0000f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00012	85 ff		 test	 edi, edi
  00014	7e 38		 jle	 SHORT $LN10@lssproto_m
  00016	53		 push	 ebx
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _array$[ebp]
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL4@lssproto_m:
  00020	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00026	f3 0f 10 04 b3	 movss	 xmm0, DWORD PTR [ebx+esi*4]
  0002b	51		 push	 ecx
  0002c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00031	e8 00 00 00 00	 call	 ?lssproto_mkstr_float@@YAPADM@Z ; lssproto_mkstr_float
  00036	83 c4 04	 add	 esp, 4
  00039	50		 push	 eax
  0003a	ff 35 0c 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  00040	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  00045	46		 inc	 esi
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH
  00049	3b f7		 cmp	 esi, edi
  0004b	7c d3		 jl	 SHORT $LL4@lssproto_m
  0004d	5b		 pop	 ebx
$LN10@lssproto_m:

; 254  : }

  0004e	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?lssproto_mkstr_float_array@@YAPADHPAM@Z ENDP		; lssproto_mkstr_float_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_u_char_array@@YAPADHPAE@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
_array$ = 12						; size = 4
?lssproto_mkstr_u_char_array@@YAPADHPAE@Z PROC		; lssproto_mkstr_u_char_array, COMDAT

; 248  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 249  : 	MKSTR_ARRAYMACRO( lssproto_mkstr_u_char );

  00003	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR _size$[ebp]
  0000d	33 f6		 xor	 esi, esi
  0000f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00012	85 ff		 test	 edi, edi
  00014	7e 32		 jle	 SHORT $LN10@lssproto_m
  00016	53		 push	 ebx
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _array$[ebp]
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL4@lssproto_m:
  00020	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00026	0f b6 04 1e	 movzx	 eax, BYTE PTR [esi+ebx]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?lssproto_mkstr_u_char@@YAPADD@Z ; lssproto_mkstr_u_char
  00030	83 c4 04	 add	 esp, 4
  00033	50		 push	 eax
  00034	ff 35 0c 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  0003a	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  0003f	46		 inc	 esi
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	3b f7		 cmp	 esi, edi
  00045	7c d9		 jl	 SHORT $LL4@lssproto_m
  00047	5b		 pop	 ebx
$LN10@lssproto_m:

; 250  : }

  00048	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
?lssproto_mkstr_u_char_array@@YAPADHPAE@Z ENDP		; lssproto_mkstr_u_char_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_char_array@@YAPADHPAD@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
_array$ = 12						; size = 4
?lssproto_mkstr_char_array@@YAPADHPAD@Z PROC		; lssproto_mkstr_char_array, COMDAT

; 244  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 245  : 	MKSTR_ARRAYMACRO( lssproto_mkstr_char );

  00003	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR _size$[ebp]
  0000d	33 f6		 xor	 esi, esi
  0000f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00012	85 ff		 test	 edi, edi
  00014	7e 32		 jle	 SHORT $LN10@lssproto_m
  00016	53		 push	 ebx
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _array$[ebp]
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL4@lssproto_m:
  00020	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00026	0f b6 04 1e	 movzx	 eax, BYTE PTR [esi+ebx]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?lssproto_mkstr_char@@YAPADD@Z ; lssproto_mkstr_char
  00030	83 c4 04	 add	 esp, 4
  00033	50		 push	 eax
  00034	ff 35 0c 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  0003a	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  0003f	46		 inc	 esi
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	3b f7		 cmp	 esi, edi
  00045	7c d9		 jl	 SHORT $LL4@lssproto_m
  00047	5b		 pop	 ebx
$LN10@lssproto_m:

; 246  : }

  00048	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
?lssproto_mkstr_char_array@@YAPADHPAD@Z ENDP		; lssproto_mkstr_char_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_u_short_array@@YAPADHPAF@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
_array$ = 12						; size = 4
?lssproto_mkstr_u_short_array@@YAPADHPAF@Z PROC		; lssproto_mkstr_u_short_array, COMDAT

; 240  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 241  : 	MKSTR_ARRAYMACRO( lssproto_mkstr_u_short );

  00003	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR _size$[ebp]
  0000d	33 f6		 xor	 esi, esi
  0000f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00012	85 ff		 test	 edi, edi
  00014	7e 32		 jle	 SHORT $LN10@lssproto_m
  00016	53		 push	 ebx
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _array$[ebp]
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL4@lssproto_m:
  00020	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00026	0f b7 04 73	 movzx	 eax, WORD PTR [ebx+esi*2]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?lssproto_mkstr_u_short@@YAPADF@Z ; lssproto_mkstr_u_short
  00030	83 c4 04	 add	 esp, 4
  00033	50		 push	 eax
  00034	ff 35 0c 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  0003a	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  0003f	46		 inc	 esi
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	3b f7		 cmp	 esi, edi
  00045	7c d9		 jl	 SHORT $LL4@lssproto_m
  00047	5b		 pop	 ebx
$LN10@lssproto_m:

; 242  : }

  00048	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
?lssproto_mkstr_u_short_array@@YAPADHPAF@Z ENDP		; lssproto_mkstr_u_short_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_short_array@@YAPADHPAF@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
_array$ = 12						; size = 4
?lssproto_mkstr_short_array@@YAPADHPAF@Z PROC		; lssproto_mkstr_short_array, COMDAT

; 236  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 237  : 	MKSTR_ARRAYMACRO( lssproto_mkstr_short );

  00003	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR _size$[ebp]
  0000d	33 f6		 xor	 esi, esi
  0000f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00012	85 ff		 test	 edi, edi
  00014	7e 32		 jle	 SHORT $LN10@lssproto_m
  00016	53		 push	 ebx
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _array$[ebp]
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL4@lssproto_m:
  00020	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00026	0f b7 04 73	 movzx	 eax, WORD PTR [ebx+esi*2]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?lssproto_mkstr_short@@YAPADF@Z ; lssproto_mkstr_short
  00030	83 c4 04	 add	 esp, 4
  00033	50		 push	 eax
  00034	ff 35 0c 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  0003a	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  0003f	46		 inc	 esi
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	3b f7		 cmp	 esi, edi
  00045	7c d9		 jl	 SHORT $LL4@lssproto_m
  00047	5b		 pop	 ebx
$LN10@lssproto_m:

; 238  : }

  00048	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
?lssproto_mkstr_short_array@@YAPADHPAF@Z ENDP		; lssproto_mkstr_short_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_u_int_array@@YAPADHPAH@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
_array$ = 12						; size = 4
?lssproto_mkstr_u_int_array@@YAPADHPAH@Z PROC		; lssproto_mkstr_u_int_array, COMDAT

; 232  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 233  : 	MKSTR_ARRAYMACRO( lssproto_mkstr_u_int );

  00003	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR _size$[ebp]
  0000d	33 f6		 xor	 esi, esi
  0000f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00012	85 ff		 test	 edi, edi
  00014	7e 30		 jle	 SHORT $LN10@lssproto_m
  00016	53		 push	 ebx
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _array$[ebp]
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL4@lssproto_m:
  00020	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00026	ff 34 b3	 push	 DWORD PTR [ebx+esi*4]
  00029	e8 00 00 00 00	 call	 ?lssproto_mkstr_u_int@@YAPADI@Z ; lssproto_mkstr_u_int
  0002e	83 c4 04	 add	 esp, 4
  00031	50		 push	 eax
  00032	ff 35 0c 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  00038	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  0003d	46		 inc	 esi
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00041	3b f7		 cmp	 esi, edi
  00043	7c db		 jl	 SHORT $LL4@lssproto_m
  00045	5b		 pop	 ebx
$LN10@lssproto_m:

; 234  : }

  00046	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?lssproto_mkstr_u_int_array@@YAPADHPAH@Z ENDP		; lssproto_mkstr_u_int_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_int_array@@YAPADHPAH@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
_array$ = 12						; size = 4
?lssproto_mkstr_int_array@@YAPADHPAH@Z PROC		; lssproto_mkstr_int_array, COMDAT

; 218  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 219  : #define MKSTR_ARRAYMACRO( func) \
; 220  : 	{\
; 221  : 		 int i;\
; 222  :          lssproto.arraywork[0] = '\0';\
; 223  : 		 for(i=0;i<size;i++){   \
; 224  :              lssproto_strcatsafe( lssproto.arraywork , func(array[i]) , lssproto.workbufsize );\
; 225  : 		 }\
; 226  :          return lssproto.arraywork;\
; 227  :     }\
; 228  : 
; 229  : 	MKSTR_ARRAYMACRO( lssproto_mkstr_int );

  00003	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR _size$[ebp]
  0000d	33 f6		 xor	 esi, esi
  0000f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00012	85 ff		 test	 edi, edi
  00014	7e 30		 jle	 SHORT $LN10@lssproto_m
  00016	53		 push	 ebx
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _array$[ebp]
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL4@lssproto_m:
  00020	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00026	ff 34 b3	 push	 DWORD PTR [ebx+esi*4]
  00029	e8 00 00 00 00	 call	 ?lssproto_mkstr_int@@YAPADH@Z ; lssproto_mkstr_int
  0002e	83 c4 04	 add	 esp, 4
  00031	50		 push	 eax
  00032	ff 35 0c 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  00038	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  0003d	46		 inc	 esi
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00041	3b f7		 cmp	 esi, edi
  00043	7c db		 jl	 SHORT $LL4@lssproto_m
  00045	5b		 pop	 ebx
$LN10@lssproto_m:

; 230  : }

  00046	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?lssproto_mkstr_int_array@@YAPADHPAH@Z ENDP		; lssproto_mkstr_int_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_double@@YAPADN@Z
_TEXT	SEGMENT
_d$ = 8							; size = 8
?lssproto_mkstr_double@@YAPADN@Z PROC			; lssproto_mkstr_double, COMDAT

; 213  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 214  : 	sprintf( lssproto.val_str , "%f " , d );

  00003	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _d$[ebp]
  00008	83 ec 08	 sub	 esp, 8
  0000b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_03JAIJOMNP@?$CFf?5@
  00015	ff 35 14 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  0001b	e8 00 00 00 00	 call	 _sprintf

; 215  : 	return lssproto.val_str;

  00020	a1 14 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00025	83 c4 10	 add	 esp, 16			; 00000010H

; 216  : }

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?lssproto_mkstr_double@@YAPADN@Z ENDP			; lssproto_mkstr_double
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_float@@YAPADM@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
?lssproto_mkstr_float@@YAPADM@Z PROC			; lssproto_mkstr_float, COMDAT

; 208  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _f$[ebp]

; 209  : 	sprintf( lssproto.val_str , "%f " , f );

  00008	83 ec 08	 sub	 esp, 8
  0000b	0f 5a c0	 cvtps2pd xmm0, xmm0
  0000e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00013	68 00 00 00 00	 push	 OFFSET ??_C@_03JAIJOMNP@?$CFf?5@
  00018	ff 35 14 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  0001e	e8 00 00 00 00	 call	 _sprintf

; 210  : 	return lssproto.val_str;

  00023	a1 14 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00028	83 c4 10	 add	 esp, 16			; 00000010H

; 211  : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?lssproto_mkstr_float@@YAPADM@Z ENDP			; lssproto_mkstr_float
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_string@@YAPADPAD@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?lssproto_mkstr_string@@YAPADPAD@Z PROC			; lssproto_mkstr_string, COMDAT

; 202  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 203  : 	char *ret = lssproto_escapeString( a );

  00004	ff 75 08	 push	 DWORD PTR _a$[ebp]
  00007	e8 00 00 00 00	 call	 ?lssproto_escapeString@@YAPADPAD@Z ; lssproto_escapeString

; 204  : 	lssproto_strcatsafe( ret , " ", lssproto.workbufsize );

  0000c	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00012	8b f0		 mov	 esi, eax
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  00019	56		 push	 esi
  0001a	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  0001f	83 c4 10	 add	 esp, 16			; 00000010H

; 205  : 	return ret;

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi

; 206  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?lssproto_mkstr_string@@YAPADPAD@Z ENDP			; lssproto_mkstr_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_u_char@@YAPADD@Z
_TEXT	SEGMENT
_c$ = 8							; size = 1
?lssproto_mkstr_u_char@@YAPADD@Z PROC			; lssproto_mkstr_u_char, COMDAT

; 195  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 196  : #define MKSTR_U_CHAR8(v)   lssproto_Ltoa( (long)( ((long)(v)) & 0xff ))
; 197  : 	lssproto_strcpysafe( lssproto.val_str , MKSTR_U_CHAR8(c) , lssproto.workbufsize );

  00003	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00009	0f b6 45 08	 movzx	 eax, BYTE PTR _c$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?lssproto_Ltoa@@YAPADJ@Z ; lssproto_Ltoa
  00013	83 c4 04	 add	 esp, 4
  00016	50		 push	 eax
  00017	ff 35 14 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  0001d	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe

; 198  : 	lssproto_strcatsafe( lssproto.val_str ," "  , lssproto.workbufsize );

  00022	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  0002d	ff 35 14 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00033	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe

; 199  : 	return lssproto.val_str;

  00038	a1 14 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  0003d	83 c4 18	 add	 esp, 24			; 00000018H

; 200  : }

  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?lssproto_mkstr_u_char@@YAPADD@Z ENDP			; lssproto_mkstr_u_char
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_char@@YAPADD@Z
_TEXT	SEGMENT
_c$ = 8							; size = 1
?lssproto_mkstr_char@@YAPADD@Z PROC			; lssproto_mkstr_char, COMDAT

; 188  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 189  : #define MKSTR_CHAR8(v)   lssproto_Ltoa( ( long)((int)(v)))
; 190  : 	lssproto_strcpysafe( lssproto.val_str , MKSTR_CHAR8(c) , lssproto.workbufsize );

  00003	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00009	0f be 45 08	 movsx	 eax, BYTE PTR _c$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?lssproto_Ltoa@@YAPADJ@Z ; lssproto_Ltoa
  00013	83 c4 04	 add	 esp, 4
  00016	50		 push	 eax
  00017	ff 35 14 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  0001d	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe

; 191  : 	lssproto_strcatsafe( lssproto.val_str ," ", lssproto.workbufsize );

  00022	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  0002d	ff 35 14 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00033	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe

; 192  : 	return lssproto.val_str;	

  00038	a1 14 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  0003d	83 c4 18	 add	 esp, 24			; 00000018H

; 193  : }

  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?lssproto_mkstr_char@@YAPADD@Z ENDP			; lssproto_mkstr_char
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_u_short@@YAPADF@Z
_TEXT	SEGMENT
_s$ = 8							; size = 2
?lssproto_mkstr_u_short@@YAPADF@Z PROC			; lssproto_mkstr_u_short, COMDAT

; 181  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : #define MKSTR_U_SHORT16(v)   lssproto_Ltoa( (long)(  ((long)(v)) & 0xffff ))
; 183  : 	lssproto_strcpysafe( lssproto.val_str , MKSTR_U_SHORT16(s) , lssproto.workbufsize );

  00003	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00009	0f b7 45 08	 movzx	 eax, WORD PTR _s$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?lssproto_Ltoa@@YAPADJ@Z ; lssproto_Ltoa
  00013	83 c4 04	 add	 esp, 4
  00016	50		 push	 eax
  00017	ff 35 14 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  0001d	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe

; 184  : 	lssproto_strcatsafe( lssproto.val_str ," " , lssproto.workbufsize );

  00022	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  0002d	ff 35 14 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00033	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe

; 185  : 	return lssproto.val_str;	

  00038	a1 14 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  0003d	83 c4 18	 add	 esp, 24			; 00000018H

; 186  : }

  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?lssproto_mkstr_u_short@@YAPADF@Z ENDP			; lssproto_mkstr_u_short
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_short@@YAPADF@Z
_TEXT	SEGMENT
_s$ = 8							; size = 2
?lssproto_mkstr_short@@YAPADF@Z PROC			; lssproto_mkstr_short, COMDAT

; 174  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 175  : #define MKSTR_SHORT16(v)    lssproto_Ltoa( (long)((int)(v) ))
; 176  : 	lssproto_strcpysafe( lssproto.val_str , MKSTR_SHORT16(s) , lssproto.workbufsize );

  00003	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00009	0f bf 45 08	 movsx	 eax, WORD PTR _s$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?lssproto_Ltoa@@YAPADJ@Z ; lssproto_Ltoa
  00013	83 c4 04	 add	 esp, 4
  00016	50		 push	 eax
  00017	ff 35 14 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  0001d	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe

; 177  : 	lssproto_strcatsafe( lssproto.val_str ," " , lssproto.workbufsize );

  00022	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  0002d	ff 35 14 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00033	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe

; 178  : 	return lssproto.val_str;	

  00038	a1 14 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  0003d	83 c4 18	 add	 esp, 24			; 00000018H

; 179  : }

  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?lssproto_mkstr_short@@YAPADF@Z ENDP			; lssproto_mkstr_short
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_u_long@@YAPADK@Z
_TEXT	SEGMENT
_l$ = 8							; size = 4
?lssproto_mkstr_u_long@@YAPADK@Z PROC			; lssproto_mkstr_u_long, COMDAT

; 167  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 168  : #define MKSTR_U_LONG(v) lssproto_Ultoa(v ) 
; 169  : 	lssproto_strcpysafe( lssproto.val_str , MKSTR_U_LONG(l) , lssproto.workbufsize );

  00003	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00009	ff 75 08	 push	 DWORD PTR _l$[ebp]
  0000c	e8 00 00 00 00	 call	 ?lssproto_Ultoa@@YAPADK@Z ; lssproto_Ultoa
  00011	83 c4 04	 add	 esp, 4
  00014	50		 push	 eax
  00015	ff 35 14 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  0001b	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe

; 170  : 	lssproto_strcatsafe( lssproto.val_str ," " , lssproto.workbufsize );

  00020	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  0002b	ff 35 14 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00031	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe

; 171  : 	return lssproto.val_str;	

  00036	a1 14 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  0003b	83 c4 18	 add	 esp, 24			; 00000018H

; 172  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?lssproto_mkstr_u_long@@YAPADK@Z ENDP			; lssproto_mkstr_u_long
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_long@@YAPADJ@Z
_TEXT	SEGMENT
_l$ = 8							; size = 4
?lssproto_mkstr_long@@YAPADJ@Z PROC			; lssproto_mkstr_long, COMDAT

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 161  : #define MKSTR_LONG(v) lssproto_Ltoa( v ) 
; 162  : 	lssproto_strcpysafe( lssproto.val_str , MKSTR_LONG(l) , lssproto.workbufsize );

  00003	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00009	ff 75 08	 push	 DWORD PTR _l$[ebp]
  0000c	e8 00 00 00 00	 call	 ?lssproto_Ltoa@@YAPADJ@Z ; lssproto_Ltoa
  00011	83 c4 04	 add	 esp, 4
  00014	50		 push	 eax
  00015	ff 35 14 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  0001b	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe

; 163  : 	lssproto_strcatsafe( lssproto.val_str ," " , lssproto.workbufsize );

  00020	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  0002b	ff 35 14 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00031	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe

; 164  : 	return lssproto.val_str;

  00036	a1 14 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  0003b	83 c4 18	 add	 esp, 24			; 00000018H

; 165  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?lssproto_mkstr_long@@YAPADJ@Z ENDP			; lssproto_mkstr_long
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_u_int@@YAPADI@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?lssproto_mkstr_u_int@@YAPADI@Z PROC			; lssproto_mkstr_u_int, COMDAT

; 153  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 154  : #define MKSTR_U_INT(v) lssproto_Ultoa( (unsigned long ) (v) )
; 155  : 	lssproto_strcpysafe( lssproto.val_str , MKSTR_U_INT(i) , lssproto.workbufsize );

  00003	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00009	ff 75 08	 push	 DWORD PTR _i$[ebp]
  0000c	e8 00 00 00 00	 call	 ?lssproto_Ultoa@@YAPADK@Z ; lssproto_Ultoa
  00011	83 c4 04	 add	 esp, 4
  00014	50		 push	 eax
  00015	ff 35 14 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  0001b	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe

; 156  : 	lssproto_strcatsafe( lssproto.val_str ," " , lssproto.workbufsize );

  00020	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  0002b	ff 35 14 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00031	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe

; 157  : 	return lssproto.val_str;

  00036	a1 14 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  0003b	83 c4 18	 add	 esp, 24			; 00000018H

; 158  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?lssproto_mkstr_u_int@@YAPADI@Z ENDP			; lssproto_mkstr_u_int
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_int@@YAPADH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?lssproto_mkstr_int@@YAPADH@Z PROC			; lssproto_mkstr_int, COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 147  : #define MKSTR_INT(v) lssproto_Ltoa( (long)(v)) 
; 148  : 	lssproto_strcpysafe( lssproto.val_str ,  (char*)MKSTR_INT(i) , lssproto.workbufsize );

  00003	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00009	ff 75 08	 push	 DWORD PTR _i$[ebp]
  0000c	e8 00 00 00 00	 call	 ?lssproto_Ltoa@@YAPADJ@Z ; lssproto_Ltoa
  00011	83 c4 04	 add	 esp, 4
  00014	50		 push	 eax
  00015	ff 35 14 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  0001b	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe

; 149  : 	lssproto_strcatsafe( lssproto.val_str ," " , lssproto.workbufsize );

  00020	ff 35 04 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  0002b	ff 35 14 00 00
	00		 push	 DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00031	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe

; 150  : 	return lssproto.val_str;

  00036	a1 14 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  0003b	83 c4 18	 add	 esp, 24			; 00000018H

; 151  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?lssproto_mkstr_int@@YAPADH@Z ENDP			; lssproto_mkstr_int
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_strcatsafe@@YAXPAD0H@Z
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_maxlen$ = 16						; size = 4
?lssproto_strcatsafe@@YAXPAD0H@Z PROC			; lssproto_strcatsafe, COMDAT

; 132  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 133  : 	int i,j;
; 134  : 	for(i=0;i<maxlen-1;i++){

  00004	8b 75 10	 mov	 esi, DWORD PTR _maxlen$[ebp]
  00007	33 c0		 xor	 eax, eax
  00009	4e		 dec	 esi
  0000a	85 f6		 test	 esi, esi
  0000c	7e 2f		 jle	 SHORT $LN3@lssproto_s
  0000e	57		 push	 edi
  0000f	8b 7d 08	 mov	 edi, DWORD PTR _dest$[ebp]
$LL4@lssproto_s:

; 135  : 		if( dest[i] == 0 ){

  00012	80 3c 38 00	 cmp	 BYTE PTR [eax+edi], 0
  00016	74 09		 je	 SHORT $LN13@lssproto_s

; 133  : 	int i,j;
; 134  : 	for(i=0;i<maxlen-1;i++){

  00018	40		 inc	 eax
  00019	3b c6		 cmp	 eax, esi
  0001b	7c f5		 jl	 SHORT $LL4@lssproto_s
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi

; 141  : 			break;
; 142  : 		}
; 143  : 	}
; 144  : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
$LN13@lssproto_s:

; 136  : 			for(j=i;j<maxlen-1;j++){

  00021	3b c6		 cmp	 eax, esi
  00023	7d 13		 jge	 SHORT $LN21@lssproto_s
  00025	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
$LL7@lssproto_s:

; 137  : 				dest[j]= src[j-i];

  00028	8a 0a		 mov	 cl, BYTE PTR [edx]
  0002a	88 0c 38	 mov	 BYTE PTR [eax+edi], cl

; 138  : 				if( src[j-i] == 0 )break;

  0002d	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00030	74 06		 je	 SHORT $LN21@lssproto_s

; 136  : 			for(j=i;j<maxlen-1;j++){

  00032	40		 inc	 eax
  00033	42		 inc	 edx
  00034	3b c6		 cmp	 eax, esi
  00036	7c f0		 jl	 SHORT $LL7@lssproto_s
$LN21@lssproto_s:

; 139  : 			}
; 140  : 			dest[j]=0;

  00038	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  0003c	5f		 pop	 edi
$LN3@lssproto_s:
  0003d	5e		 pop	 esi

; 141  : 			break;
; 142  : 		}
; 143  : 	}
; 144  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?lssproto_strcatsafe@@YAXPAD0H@Z ENDP			; lssproto_strcatsafe
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_strcpysafe@@YAXPAD0H@Z
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_maxlen$ = 16						; size = 4
?lssproto_strcpysafe@@YAXPAD0H@Z PROC			; lssproto_strcpysafe, COMDAT

; 123  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 124  : 	int i;
; 125  : 	for(i=0;i<maxlen-1;i++){

  00004	8b 75 10	 mov	 esi, DWORD PTR _maxlen$[ebp]
  00007	33 d2		 xor	 edx, edx
  00009	4e		 dec	 esi
  0000a	85 f6		 test	 esi, esi
  0000c	7e 2b		 jle	 SHORT $LN13@lssproto_s
  0000e	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00011	53		 push	 ebx
  00012	8b 5d 08	 mov	 ebx, DWORD PTR _dest$[ebp]
  00015	57		 push	 edi
  00016	8b fb		 mov	 edi, ebx
  00018	2b f8		 sub	 edi, eax
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL4@lssproto_s:

; 126  : 		dest[i] = src[i];

  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	88 0c 07	 mov	 BYTE PTR [edi+eax], cl

; 127  : 		if( src[i]==0)break;

  00025	80 38 00	 cmp	 BYTE PTR [eax], 0
  00028	74 06		 je	 SHORT $LN12@lssproto_s

; 124  : 	int i;
; 125  : 	for(i=0;i<maxlen-1;i++){

  0002a	42		 inc	 edx
  0002b	40		 inc	 eax
  0002c	3b d6		 cmp	 edx, esi
  0002e	7c f0		 jl	 SHORT $LL4@lssproto_s
$LN12@lssproto_s:
  00030	5f		 pop	 edi

; 128  : 	}
; 129  : 	dest[i]=0;

  00031	c6 04 1a 00	 mov	 BYTE PTR [edx+ebx], 0
  00035	5b		 pop	 ebx
  00036	5e		 pop	 esi

; 130  : }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
$LN13@lssproto_s:

; 128  : 	}
; 129  : 	dest[i]=0;

  00039	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0003c	5e		 pop	 esi
  0003d	88 14 02	 mov	 BYTE PTR [edx+eax], dl

; 130  : }

  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?lssproto_strcpysafe@@YAXPAD0H@Z ENDP			; lssproto_strcpysafe
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_splitString@@YAXPAD@Z
_TEXT	SEGMENT
_src$ = 8						; size = 4
?lssproto_splitString@@YAXPAD@Z PROC			; lssproto_splitString, COMDAT

; 458  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 459  : 	int i,c=0;

  00005	33 ff		 xor	 edi, edi

; 460  : 	char *decoded;
; 461  : 	
; 462  : #ifdef lssproto__ENCRYPT
; 463  : 	if( !bNewServer){

  00007	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?bNewServer@@3HA, edi ; bNewServer
  0000d	75 14		 jne	 SHORT $LN7@lssproto_s

; 464  : 		decoded = lssproto.cryptwork;

  0000f	8b 35 1c 00 00
	00		 mov	 esi, DWORD PTR ?lssproto@@3Ulssproto_@@A+28

; 465  : 		lssproto_decodeString( src , decoded );

  00015	56		 push	 esi
  00016	ff 75 08	 push	 DWORD PTR _src$[ebp]
  00019	e8 00 00 00 00	 call	 ?lssproto_decodeString@@YAXPAD0@Z ; lssproto_decodeString
  0001e	83 c4 08	 add	 esp, 8

; 466  : 	}else

  00021	eb 03		 jmp	 SHORT $LN8@lssproto_s
$LN7@lssproto_s:

; 467  : 		decoded = src;

  00023	8b 75 08	 mov	 esi, DWORD PTR _src$[ebp]
$LN8@lssproto_s:

; 468  : #else
; 469  : 	decoded = src;
; 470  : #endif
; 471  : 	if( lssproto_readlogfilename[0] != '\0'){

  00026	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?lssproto_readlogfilename@@3PADA, 0
  0002d	74 2f		 je	 SHORT $LN10@lssproto_s

; 472  : 		FILE *rfp;
; 473  : 		rfp = fopen( lssproto_readlogfilename , "a+" );

  0002f	53		 push	 ebx
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_02DPNLHKJD@a?$CL@
  00035	68 00 00 00 00	 push	 OFFSET ?lssproto_readlogfilename@@3PADA ; lssproto_readlogfilename
  0003a	e8 00 00 00 00	 call	 _fopen
  0003f	8b d8		 mov	 ebx, eax
  00041	83 c4 08	 add	 esp, 8

; 474  : 		if(rfp){

  00044	85 db		 test	 ebx, ebx
  00046	74 15		 je	 SHORT $LN28@lssproto_s

; 475  : 			fprintf( rfp, "收到：\t%s\n",decoded );

  00048	56		 push	 esi
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0L@INAHAGEI@?b?$KF?S?p?$KD?$LK?7?$CFs?6@
  0004e	53		 push	 ebx
  0004f	e8 00 00 00 00	 call	 _fprintf

; 476  : 			fclose(rfp);

  00054	53		 push	 ebx
  00055	e8 00 00 00 00	 call	 _fclose
  0005a	83 c4 10	 add	 esp, 16			; 00000010H
$LN28@lssproto_s:
  0005d	5b		 pop	 ebx
$LN10@lssproto_s:

; 477  : 		}
; 478  : 	}
; 479  : 	for(i = 0 ; ; i++ ){
; 480  : 		if( decoded[i] == '\0' ) break;

  0005e	8a 06		 mov	 al, BYTE PTR [esi]
  00060	33 d2		 xor	 edx, edx
  00062	84 c0		 test	 al, al
  00064	74 45		 je	 SHORT $LN27@lssproto_s
  00066	8b ce		 mov	 ecx, esi
$LL4@lssproto_s:

; 481  : 		if( i==0){

  00068	85 d2		 test	 edx, edx
  0006a	75 09		 jne	 SHORT $LN12@lssproto_s

; 482  : 		    lssproto.token_list[c++]=&(decoded[i]);

  0006c	a1 2c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+44
  00071	89 34 b8	 mov	 DWORD PTR [eax+edi*4], esi
  00074	47		 inc	 edi
$LN12@lssproto_s:

; 483  : 		}
; 484  : 		if( decoded[i]== ' '){

  00075	80 39 20	 cmp	 BYTE PTR [ecx], 32	; 00000020H
  00078	75 0a		 jne	 SHORT $LN2@lssproto_s

; 485  : 		    lssproto.token_list[c++]=&(decoded[i+1]);

  0007a	a1 2c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+44
  0007f	41		 inc	 ecx
  00080	89 0c b8	 mov	 DWORD PTR [eax+edi*4], ecx
  00083	47		 inc	 edi
$LN2@lssproto_s:

; 477  : 		}
; 478  : 	}
; 479  : 	for(i = 0 ; ; i++ ){
; 480  : 		if( decoded[i] == '\0' ) break;

  00084	42		 inc	 edx
  00085	80 3c 32 00	 cmp	 BYTE PTR [edx+esi], 0
  00089	8d 0c 32	 lea	 ecx, DWORD PTR [edx+esi]
  0008c	75 da		 jne	 SHORT $LL4@lssproto_s

; 486  : 		}
; 487  : 	}
; 488  : 	while( *decoded ){

  0008e	8a 06		 mov	 al, BYTE PTR [esi]
  00090	84 c0		 test	 al, al
  00092	74 17		 je	 SHORT $LN27@lssproto_s
$LL5@lssproto_s:

; 489  : 		if( ( *decoded  ) == ' ' || (*decoded ) == '\n' || (*decoded ) == '\r' ) *decoded = '\0';

  00094	3c 20		 cmp	 al, 32			; 00000020H
  00096	74 08		 je	 SHORT $LN15@lssproto_s
  00098	3c 0a		 cmp	 al, 10			; 0000000aH
  0009a	74 04		 je	 SHORT $LN15@lssproto_s
  0009c	3c 0d		 cmp	 al, 13			; 0000000dH
  0009e	75 03		 jne	 SHORT $LN14@lssproto_s
$LN15@lssproto_s:
  000a0	c6 06 00	 mov	 BYTE PTR [esi], 0
$LN14@lssproto_s:

; 486  : 		}
; 487  : 	}
; 488  : 	while( *decoded ){

  000a3	8a 46 01	 mov	 al, BYTE PTR [esi+1]

; 490  : 		decoded++;

  000a6	46		 inc	 esi
  000a7	84 c0		 test	 al, al
  000a9	75 e9		 jne	 SHORT $LL5@lssproto_s
$LN27@lssproto_s:

; 491  :  	}
; 492  : 	lssproto.token_list[c] = (char*)NULL;
; 493  : }

  000ab	a1 2c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+44
  000b0	c7 04 b8 00 00
	00 00		 mov	 DWORD PTR [eax+edi*4], 0
  000b7	5f		 pop	 edi
  000b8	5e		 pop	 esi
  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
?lssproto_splitString@@YAXPAD@Z ENDP			; lssproto_splitString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_descapeString@@YAPADPAD@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
_a$ = 8							; size = 4
?lssproto_descapeString@@YAPADPAD@Z PROC		; lssproto_descapeString, COMDAT

; 412  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 413  : 	lssproto.escapework[0]='\0';

  00003	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  00008	56		 push	 esi
  00009	57		 push	 edi

; 414  : 	int c = 0;
; 415  : 	for(int i=0,c=0;a[i]!='\0';i++){

  0000a	8b 7d 08	 mov	 edi, DWORD PTR _a$[ebp]
  0000d	33 f6		 xor	 esi, esi
  0000f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00012	8a 07		 mov	 al, BYTE PTR [edi]
  00014	84 c0		 test	 al, al
  00016	0f 84 af 00 00
	00		 je	 $LN28@lssproto_d
  0001c	53		 push	 ebx
  0001d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__IsDBCSLeadByte@4
  00023	88 45 08	 mov	 BYTE PTR $T1[ebp], al
$LL4@lssproto_d:

; 416  : 		if(IsDBCSLeadByte(a[i])){

  00026	ff 75 08	 push	 DWORD PTR $T1[ebp]
  00029	ff d3		 call	 ebx
  0002b	85 c0		 test	 eax, eax
  0002d	74 1a		 je	 SHORT $LN5@lssproto_d

; 417  : 			lssproto.escapework[c++]=a[i++];

  0002f	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00032	47		 inc	 edi
  00033	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  00038	88 0c 30	 mov	 BYTE PTR [eax+esi], cl
  0003b	46		 inc	 esi

; 418  : 			if(a[i]=='\0'){

  0003c	8a 0f		 mov	 cl, BYTE PTR [edi]
  0003e	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  00043	84 c9		 test	 cl, cl
  00045	74 77		 je	 SHORT $LN29@lssproto_d

; 419  : 				c--;
; 420  : 				break;
; 421  : 			}
; 422  : 			lssproto.escapework[c++]=a[i];

  00047	eb 47		 jmp	 SHORT $LN31@lssproto_d
$LN5@lssproto_d:

; 423  : 		}else if(a[i]=='\\'){

  00049	8a 0f		 mov	 cl, BYTE PTR [edi]
  0004b	80 f9 5c	 cmp	 cl, 92			; 0000005cH
  0004e	75 3b		 jne	 SHORT $LN8@lssproto_d

; 424  : 			if(a[i+1]=='\0'){

  00050	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00053	47		 inc	 edi
  00054	84 c0		 test	 al, al
  00056	74 59		 je	 SHORT $LN22@lssproto_d

; 426  : 				break;
; 427  : 			}
; 428  : 			if(a[i+1]=='S')

  00058	3c 53		 cmp	 al, 83			; 00000053H
  0005a	75 0b		 jne	 SHORT $LN11@lssproto_d

; 429  : 				lssproto.escapework[c++]=' ';

  0005c	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  00061	c6 04 30 20	 mov	 BYTE PTR [eax+esi], 32	; 00000020H
  00065	eb 2c		 jmp	 SHORT $LN2@lssproto_d
$LN11@lssproto_d:

; 430  : 			else if(a[i+1]=='n')

  00067	3c 6e		 cmp	 al, 110			; 0000006eH
  00069	75 0b		 jne	 SHORT $LN13@lssproto_d

; 431  : 				lssproto.escapework[c++]='\n';

  0006b	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  00070	c6 04 30 0a	 mov	 BYTE PTR [eax+esi], 10	; 0000000aH
  00074	eb 1d		 jmp	 SHORT $LN2@lssproto_d
$LN13@lssproto_d:

; 432  : 			else if( a[i+1] == 'r' )

  00076	3c 72		 cmp	 al, 114			; 00000072H
  00078	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  0007d	75 06		 jne	 SHORT $LN15@lssproto_d

; 433  : 				lssproto.escapework[c++]='\r';

  0007f	c6 04 30 0d	 mov	 BYTE PTR [eax+esi], 13	; 0000000dH
  00083	eb 0e		 jmp	 SHORT $LN2@lssproto_d
$LN15@lssproto_d:

; 434  : 			else if( a[i+1] == '\\' )

  00085	c6 04 30 5c	 mov	 BYTE PTR [eax+esi], 92	; 0000005cH

; 435  : 				lssproto.escapework[c++]='\\';
; 436  : 			else
; 437  : 				lssproto.escapework[c++]=a[i];
; 438  : 			i++;           
; 439  : 		}else

  00089	eb 08		 jmp	 SHORT $LN2@lssproto_d
$LN8@lssproto_d:

; 440  : 			lssproto.escapework[c++]=a[i];

  0008b	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
$LN31@lssproto_d:

; 414  : 	int c = 0;
; 415  : 	for(int i=0,c=0;a[i]!='\0';i++){

  00090	88 0c 30	 mov	 BYTE PTR [eax+esi], cl
$LN2@lssproto_d:
  00093	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00096	47		 inc	 edi
  00097	46		 inc	 esi
  00098	88 45 08	 mov	 BYTE PTR $T1[ebp], al
  0009b	84 c0		 test	 al, al
  0009d	75 87		 jne	 SHORT $LL4@lssproto_d

; 441  : 	}
; 442  : 	lssproto.escapework[c]='\0';

  0009f	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  000a4	5b		 pop	 ebx
  000a5	5f		 pop	 edi

; 444  : }

  000a6	5e		 pop	 esi
  000a7	c6 00 00	 mov	 BYTE PTR [eax], 0
  000aa	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
$LN22@lssproto_d:

; 425  : 				lssproto.escapework[c++]=a[i];

  000b1	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  000b6	88 0c 30	 mov	 BYTE PTR [eax+esi], cl

; 441  : 	}
; 442  : 	lssproto.escapework[c]='\0';

  000b9	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
$LN29@lssproto_d:
  000be	5b		 pop	 ebx
  000bf	5f		 pop	 edi
  000c0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 443  : 	return lssproto.escapework;

  000c3	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16

; 444  : }

  000c8	5e		 pop	 esi
  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
$LN28@lssproto_d:

; 441  : 	}
; 442  : 	lssproto.escapework[c]='\0';

  000cb	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  000d0	5f		 pop	 edi

; 444  : }

  000d1	5e		 pop	 esi
  000d2	c6 00 00	 mov	 BYTE PTR [eax], 0
  000d5	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  000da	5d		 pop	 ebp
  000db	c3		 ret	 0
?lssproto_descapeString@@YAPADPAD@Z ENDP		; lssproto_descapeString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\lssproto_util.cpp
;	COMDAT ?lssproto_escapeString@@YAPADPAD@Z
_TEXT	SEGMENT
_c$1$ = 8						; size = 4
_a$ = 8							; size = 4
?lssproto_escapeString@@YAPADPAD@Z PROC			; lssproto_escapeString, COMDAT

; 378  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 379  : 	lssproto.escapework[0]='\0';

  00003	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  00008	53		 push	 ebx

; 380  : 	int i, c;
; 381  : 	for(i=0,c=0;a[i]!='\0';i++){

  00009	8b 5d 08	 mov	 ebx, DWORD PTR _a$[ebp]
  0000c	56		 push	 esi
  0000d	c6 00 00	 mov	 BYTE PTR [eax], 0
  00010	33 f6		 xor	 esi, esi
  00012	8a 03		 mov	 al, BYTE PTR [ebx]
  00014	84 c0		 test	 al, al
  00016	0f 84 e7 00 00
	00		 je	 $LN26@lssproto_e
  0001c	57		 push	 edi
  0001d	0f 1f 00	 npad	 3
$LL4@lssproto_e:

; 382  : 		if(a[i]==-1){

  00020	89 75 08	 mov	 DWORD PTR _c$1$[ebp], esi
  00023	3c ff		 cmp	 al, -1
  00025	75 0e		 jne	 SHORT $LN5@lssproto_e

; 383  : 			lssproto.escapework[c++]=' ';

  00027	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  0002c	c6 04 30 20	 mov	 BYTE PTR [eax+esi], 32	; 00000020H
  00030	e9 93 00 00 00	 jmp	 $LN28@lssproto_e
$LN5@lssproto_e:

; 384  : 		}else if(IsDBCSLeadByte(a[i])){

  00035	50		 push	 eax
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsDBCSLeadByte@4
  0003c	85 c0		 test	 eax, eax
  0003e	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  00043	74 1f		 je	 SHORT $LN7@lssproto_e

; 385  : 			lssproto.escapework[c++]=a[i++];

  00045	0f b6 0b	 movzx	 ecx, BYTE PTR [ebx]
  00048	43		 inc	 ebx
  00049	88 0c 30	 mov	 BYTE PTR [eax+esi], cl

; 386  : 			if(a[i]=='\0'){

  0004c	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  00051	8a 0b		 mov	 cl, BYTE PTR [ebx]
  00053	84 c9		 test	 cl, cl
  00055	0f 84 8d 00 00
	00		 je	 $LN20@lssproto_e

; 389  : 				break;
; 390  : 			}
; 391  : 			lssproto.escapework[c++]=a[i];

  0005b	88 4c 30 01	 mov	 BYTE PTR [eax+esi+1], cl
  0005f	83 c6 02	 add	 esi, 2
  00062	eb 65		 jmp	 SHORT $LN2@lssproto_e
$LN7@lssproto_e:

; 392  : 		}else if( a[i] == '\\' ){

  00064	8a 0b		 mov	 cl, BYTE PTR [ebx]
  00066	80 f9 5c	 cmp	 cl, 92			; 0000005cH
  00069	75 12		 jne	 SHORT $LN10@lssproto_e

; 393  : 			lssproto.escapework[c++] = '\\';

  0006b	88 0c 30	 mov	 BYTE PTR [eax+esi], cl

; 394  : 			lssproto.escapework[c++] = 'y';

  0006e	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  00073	c6 44 30 01 79	 mov	 BYTE PTR [eax+esi+1], 121 ; 00000079H
  00078	83 c6 02	 add	 esi, 2
  0007b	eb 4c		 jmp	 SHORT $LN2@lssproto_e
$LN10@lssproto_e:

; 395  : 		}else if( a[i] == ' ' ){

  0007d	80 f9 20	 cmp	 cl, 32			; 00000020H
  00080	75 13		 jne	 SHORT $LN12@lssproto_e

; 396  : 			lssproto.escapework[c++] = '\\';

  00082	c6 04 30 5c	 mov	 BYTE PTR [eax+esi], 92	; 0000005cH

; 397  : 			lssproto.escapework[c++] = 'S';

  00086	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  0008b	c6 44 30 01 53	 mov	 BYTE PTR [eax+esi+1], 83 ; 00000053H
  00090	83 c6 02	 add	 esi, 2
  00093	eb 34		 jmp	 SHORT $LN2@lssproto_e
$LN12@lssproto_e:

; 398  : 		}else if( a[i] == '\n' ){

  00095	80 f9 0a	 cmp	 cl, 10			; 0000000aH
  00098	75 13		 jne	 SHORT $LN14@lssproto_e

; 399  : 			lssproto.escapework[c++] = '\\';

  0009a	c6 04 30 5c	 mov	 BYTE PTR [eax+esi], 92	; 0000005cH

; 400  : 			lssproto.escapework[c++] = 'n';

  0009e	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  000a3	c6 44 30 01 6e	 mov	 BYTE PTR [eax+esi+1], 110 ; 0000006eH
  000a8	83 c6 02	 add	 esi, 2
  000ab	eb 1c		 jmp	 SHORT $LN2@lssproto_e
$LN14@lssproto_e:

; 401  : 		}else if( a[i] == '\r' ){

  000ad	80 f9 0d	 cmp	 cl, 13			; 0000000dH
  000b0	75 13		 jne	 SHORT $LN16@lssproto_e

; 402  : 			lssproto.escapework[c++] = '\\';

  000b2	c6 04 30 5c	 mov	 BYTE PTR [eax+esi], 92	; 0000005cH

; 403  : 			lssproto.escapework[c++] = 'r';

  000b6	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  000bb	c6 44 30 01 72	 mov	 BYTE PTR [eax+esi+1], 114 ; 00000072H
  000c0	83 c6 02	 add	 esi, 2

; 404  : 		}else

  000c3	eb 04		 jmp	 SHORT $LN2@lssproto_e
$LN16@lssproto_e:

; 405  : 			lssproto.escapework[c++] = a[i];

  000c5	88 0c 30	 mov	 BYTE PTR [eax+esi], cl
$LN28@lssproto_e:

; 380  : 	int i, c;
; 381  : 	for(i=0,c=0;a[i]!='\0';i++){

  000c8	46		 inc	 esi
$LN2@lssproto_e:
  000c9	8a 43 01	 mov	 al, BYTE PTR [ebx+1]
  000cc	43		 inc	 ebx
  000cd	84 c0		 test	 al, al
  000cf	0f 85 4b ff ff
	ff		 jne	 $LL4@lssproto_e

; 406  : 	}
; 407  : 	lssproto.escapework[c] = '\0';

  000d5	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  000da	5f		 pop	 edi
  000db	c6 04 30 00	 mov	 BYTE PTR [eax+esi], 0

; 408  : 	return lssproto.escapework;
; 409  : }

  000df	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  000e4	5e		 pop	 esi
  000e5	5b		 pop	 ebx
  000e6	5d		 pop	 ebp
  000e7	c3		 ret	 0
$LN20@lssproto_e:

; 387  : 				c--;
; 388  : 				lssproto.escapework[c++]=' ';

  000e8	8b 4d 08	 mov	 ecx, DWORD PTR _c$1$[ebp]
  000eb	5f		 pop	 edi
  000ec	5e		 pop	 esi

; 408  : 	return lssproto.escapework;
; 409  : }

  000ed	5b		 pop	 ebx
  000ee	c6 04 08 20	 mov	 BYTE PTR [eax+ecx], 32	; 00000020H
  000f2	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  000f7	c6 44 08 01 00	 mov	 BYTE PTR [eax+ecx+1], 0
  000fc	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
$LN26@lssproto_e:

; 406  : 	}
; 407  : 	lssproto.escapework[c] = '\0';

  00103	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  00108	c6 04 30 00	 mov	 BYTE PTR [eax+esi], 0

; 408  : 	return lssproto.escapework;
; 409  : }

  0010c	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  00111	5e		 pop	 esi
  00112	5b		 pop	 ebx
  00113	5d		 pop	 ebp
  00114	c3		 ret	 0
?lssproto_escapeString@@YAPADPAD@Z ENDP			; lssproto_escapeString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);
; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1777 : 
; 1778 :         __crt_va_end(_ArgList);
; 1779 :         return _Result;
; 1780 :     }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 837  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Stream$[ebp]
  0000f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00014	ff 70 04	 push	 DWORD PTR [eax+4]
  00017	ff 30		 push	 DWORD PTR [eax]
  00019	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);
; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 842  :         __crt_va_end(_ArgList);
; 843  :         return _Result;
; 844  :     }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
