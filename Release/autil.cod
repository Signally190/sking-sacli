; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29336.0 

	TITLE	C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?MesgSlice@@3PAPADA				; MesgSlice
PUBLIC	?SliceCount@@3HA				; SliceCount
PUBLIC	?PersonalKey@@3PADA				; PersonalKey
PUBLIC	?wmstr@@3PAUWM_STR@@A				; wmstr
_BSS	SEGMENT
?MesgSlice@@3PAPADA DD 01H DUP (?)			; MesgSlice
?SliceCount@@3HA DD 01H DUP (?)				; SliceCount
?PersonalKey@@3PADA DB 020H DUP (?)			; PersonalKey
?wmstr@@3PAUWM_STR@@A DB 019a8cH DUP (?)		; wmstr
_BSS	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_sprintf
PUBLIC	?util_Init@@YAXXZ				; util_Init
PUBLIC	?util_Release@@YAXXZ				; util_Release
PUBLIC	?util_SplitMessage@@YAXPAD0@Z			; util_SplitMessage
PUBLIC	?util_EncodeMessage@@YAXPAD0@Z			; util_EncodeMessage
PUBLIC	?util_DecodeMessage@@YAXPAD0@Z			; util_DecodeMessage
PUBLIC	?util_GetFunctionFromSlice@@YAHPAH0@Z		; util_GetFunctionFromSlice
PUBLIC	?util_DiscardMessage@@YAXXZ			; util_DiscardMessage
PUBLIC	?util_SendMesg@@YAXHHPAD@Z			; util_SendMesg
PUBLIC	?util_256to64@@YAHPAD0H0@Z			; util_256to64
PUBLIC	?util_64to256@@YAHPAD00@Z			; util_64to256
PUBLIC	?util_256to64_shr@@YAHPAD0H00@Z			; util_256to64_shr
PUBLIC	?util_shl_64to256@@YAHPAD000@Z			; util_shl_64to256
PUBLIC	?util_256to64_shl@@YAHPAD0H00@Z			; util_256to64_shl
PUBLIC	?util_shr_64to256@@YAHPAD000@Z			; util_shr_64to256
PUBLIC	?util_swapint@@YAXPAH0PAD@Z			; util_swapint
PUBLIC	?util_xorstring@@YAXPAD0@Z			; util_xorstring
PUBLIC	?util_shrstring@@YAXPAD0H@Z			; util_shrstring
PUBLIC	?util_shlstring@@YAXPAD0H@Z			; util_shlstring
PUBLIC	?util_deint@@YAHHPAH@Z				; util_deint
PUBLIC	?util_mkint@@YAHPADH@Z				; util_mkint
PUBLIC	?util_destring@@YAHHPAD@Z			; util_destring
PUBLIC	?util_mkstring@@YAHPAD0@Z			; util_mkstring
PUBLIC	?getStrSplitNew@@YAXQAY0BAA@D@Z			; getStrSplitNew
PUBLIC	?PutWinText@@YAXHHDHPADHH@Z			; PutWinText
PUBLIC	?strcmptail@@YAHPAD0@Z				; strcmptail
PUBLIC	?getStringFromIndexWithDelim_body@@YAHPAD0H0H@Z	; getStringFromIndexWithDelim_body
PUBLIC	?ltrim@@YAXPAD@Z				; ltrim
PUBLIC	?rtrim@@YAXPAD@Z				; rtrim
PUBLIC	?getstrstyle@@YAXPADHHHQAUWM_STR@@@Z		; getstrstyle
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_04EMLHGGGF@2413@				; `string'
PUBLIC	??_C@_0EB@CPNIKEEC@0123456789ABCDEFGHIJKLMNOPQRSTU@ ; `string'
PUBLIC	??_C@_04FJNJEMEN@3142@				; `string'
PUBLIC	??_C@_01IPJKGB@?$CD@				; `string'
PUBLIC	??_C@_09PELNNIGO@?$CG?$DL?$CFd?$CFs?$DL?$CD?$DL@ ; `string'
PUBLIC	??_C@_01ICJEACDI@?$DL@				; `string'
PUBLIC	??_C@_07IBAIKNAL@?$FLstyle?5@			; `string'
PUBLIC	??_C@_01LBDDMOBJ@?$FN@				; `string'
PUBLIC	??_C@_02CAMHBLCK@c?$DN@				; `string'
PUBLIC	??_C@_02DMOBLIFK@s?$DN@				; `string'
PUBLIC	??_C@_08EAKPCBLG@?$FL?1style?$FN@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_strstr:PROC
EXTRN	_strncat:PROC
EXTRN	_strncpy:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_rand:PROC
EXTRN	_atoi:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	?JL_combineInt_RECV@@YAXHH@Z:PROC		; JL_combineInt_RECV
EXTRN	?JL_combineString_RECV@@YAXPADH@Z:PROC		; JL_combineString_RECV
EXTRN	?JL_combineInt_SEND@@YAXH@Z:PROC		; JL_combineInt_SEND
EXTRN	?JL_combineString_SEND@@YAXPADH@Z:PROC		; JL_combineString_SEND
EXTRN	?JL_combinePacket_SEND@@YAXHH@Z:PROC		; JL_combinePacket_SEND
EXTRN	?GBK2GB@@YIXPAD@Z:PROC				; GBK2GB
EXTRN	?BIG52GBK@@YIXPAD@Z:PROC			; BIG52GBK
EXTRN	?sunday@@YAPADPAD0@Z:PROC			; sunday
EXTRN	?StockFontBufferExt@@YAHHHDHPADHH@Z:PROC	; StockFontBufferExt
EXTRN	?lssproto_Send@@YAXHPAD@Z:PROC			; lssproto_Send
EXTRN	?ScanOneByte@@YAPADPADD@Z:PROC			; ScanOneByte
EXTRN	?strcpysafe@@YAXPADIPBD@Z:PROC			; strcpysafe
EXTRN	?strncpysafe@@YAXPADIPBDH@Z:PROC		; strncpysafe
EXTRN	?getTextLength@@YAHPAD@Z:PROC			; getTextLength
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	?g_Ü×?Ðï@@3HA:DWORD				; g_Ü×?Ðï
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08EAKPCBLG@?$FL?1style?$FN@
CONST	SEGMENT
??_C@_08EAKPCBLG@?$FL?1style?$FN@ DB '[/style]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DMOBLIFK@s?$DN@
CONST	SEGMENT
??_C@_02DMOBLIFK@s?$DN@ DB 's=', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CAMHBLCK@c?$DN@
CONST	SEGMENT
??_C@_02CAMHBLCK@c?$DN@ DB 'c=', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LBDDMOBJ@?$FN@
CONST	SEGMENT
??_C@_01LBDDMOBJ@?$FN@ DB ']', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07IBAIKNAL@?$FLstyle?5@
CONST	SEGMENT
??_C@_07IBAIKNAL@?$FLstyle?5@ DB '[style ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01ICJEACDI@?$DL@
CONST	SEGMENT
??_C@_01ICJEACDI@?$DL@ DB ';', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09PELNNIGO@?$CG?$DL?$CFd?$CFs?$DL?$CD?$DL@
CONST	SEGMENT
??_C@_09PELNNIGO@?$CG?$DL?$CFd?$CFs?$DL?$CD?$DL@ DB '&;%d%s;#;', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01IPJKGB@?$CD@
CONST	SEGMENT
??_C@_01IPJKGB@?$CD@ DB '#', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FJNJEMEN@3142@
CONST	SEGMENT
??_C@_04FJNJEMEN@3142@ DB '3142', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@CPNIKEEC@0123456789ABCDEFGHIJKLMNOPQRSTU@
CONST	SEGMENT
??_C@_0EB@CPNIKEEC@0123456789ABCDEFGHIJKLMNOPQRSTU@ DB '0123456789ABCDEFG'
	DB	'HIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz{}', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04EMLHGGGF@2413@
CONST	SEGMENT
??_C@_04EMLHGGGF@2413@ DB '2413', 00H			; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?getstrstyle@@YAXPADHHHQAUWM_STR@@@Z
_TEXT	SEGMENT
_etemp$1$ = -20						; size = 4
tv1384 = -16						; size = 4
_pos$1$ = -16						; size = 4
tv1391 = -12						; size = 4
_str$1$ = -8						; size = 4
_strsize$1 = -4						; size = 3
_str$ = 8						; size = 4
_index$ = 12						; size = 4
_pos$ = 16						; size = 4
_strnum$2 = 20						; size = 3
_flg$ = 20						; size = 4
_wm$ = 24						; size = 4
?getstrstyle@@YAXPADHHHQAUWM_STR@@@Z PROC		; getstrstyle, COMDAT

; 577  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	69 4d 0c 6c 10
	00 00		 imul	 ecx, DWORD PTR _index$[ebp], 4204
  0000d	8b 45 14	 mov	 eax, DWORD PTR _flg$[ebp]
  00010	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 10	 mov	 ebx, DWORD PTR _pos$[ebp]
  00017	56		 push	 esi
  00018	8b 75 18	 mov	 esi, DWORD PTR _wm$[ebp]
  0001b	89 4d f4	 mov	 DWORD PTR tv1391[ebp], ecx
  0001e	57		 push	 edi
$LN42@getstrstyl:

; 578  : 	char *stemp, *etemp;
; 579  : 	if (flg)

  0001f	89 5d f0	 mov	 DWORD PTR _pos$1$[ebp], ebx
  00022	89 55 f8	 mov	 DWORD PTR _str$1$[ebp], edx
  00025	85 c0		 test	 eax, eax
  00027	74 04		 je	 SHORT $LN8@getstrstyl

; 580  : 		stemp = str;

  00029	8b fa		 mov	 edi, edx
  0002b	eb 16		 jmp	 SHORT $LN9@getstrstyl
$LN8@getstrstyl:

; 581  : 	else
; 582  : 		stemp = sunday(str, "[style ");

  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_07IBAIKNAL@?$FLstyle?5@
  00032	52		 push	 edx
  00033	e8 00 00 00 00	 call	 ?sunday@@YAPADPAD0@Z	; sunday
  00038	8b 55 f8	 mov	 edx, DWORD PTR _str$1$[ebp]
  0003b	83 c4 08	 add	 esp, 8
  0003e	8b 4d f4	 mov	 ecx, DWORD PTR tv1391[ebp]
  00041	8b f8		 mov	 edi, eax
$LN9@getstrstyl:

; 583  : 	if (stemp) {

  00043	85 ff		 test	 edi, edi
  00045	0f 84 c3 01 00
	00		 je	 $LN10@getstrstyl

; 584  : 		if (stemp != str) {

  0004b	c7 04 0e 01 00
	00 00		 mov	 DWORD PTR [esi+ecx], 1
  00052	3b fa		 cmp	 edi, edx
  00054	74 75		 je	 SHORT $LN12@getstrstyl

; 585  : 			wm[index].flg = TRUE;
; 586  : 			wm[index].style[pos].size = FONT_SIZE1;

  00056	69 db 8c 00 00
	00		 imul	 ebx, ebx, 140
  0005c	03 d9		 add	 ebx, ecx

; 587  : 			if (pos == 0)

  0005e	83 7d f0 00	 cmp	 DWORD PTR _pos$1$[ebp], 0
  00062	c7 44 33 08 0e
	00 00 00	 mov	 DWORD PTR [ebx+esi+8], 14 ; 0000000eH
  0006a	75 04		 jne	 SHORT $LN14@getstrstyl

; 588  : 				wm[index].style[pos].x = 0;

  0006c	33 c9		 xor	 ecx, ecx
  0006e	eb 1a		 jmp	 SHORT $LN15@getstrstyl
$LN14@getstrstyl:

; 589  : 			else
; 590  : 				wm[index].style[pos].x = getTextLength(wm[index].style[pos - 1].str) + wm[index].style[pos - 1].x;

  00070	8d 46 84	 lea	 eax, DWORD PTR [esi-124]
  00073	03 c3		 add	 eax, ebx
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ?getTextLength@@YAHPAD@Z ; getTextLength
  0007b	8b 8c 33 78 ff
	ff ff		 mov	 ecx, DWORD PTR [ebx+esi-136]
  00082	83 c4 04	 add	 esp, 4
  00085	8b 55 f8	 mov	 edx, DWORD PTR _str$1$[ebp]
  00088	03 c8		 add	 ecx, eax
$LN15@getstrstyl:

; 591  : 			wm[index].style[pos].color = 0;
; 592  : 			int len = stemp - str;
; 593  : 			memcpy(wm[index].style[pos].str, str, len);

  0008a	8b 45 18	 mov	 eax, DWORD PTR _wm$[ebp]
  0008d	89 4c 33 04	 mov	 DWORD PTR [ebx+esi+4], ecx
  00091	83 c0 10	 add	 eax, 16			; 00000010H
  00094	c7 44 33 0c 00
	00 00 00	 mov	 DWORD PTR [ebx+esi+12], 0
  0009c	03 c3		 add	 eax, ebx
  0009e	8b f7		 mov	 esi, edi
  000a0	2b f2		 sub	 esi, edx
  000a2	56		 push	 esi
  000a3	52		 push	 edx
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _memcpy

; 594  : 			wm[index].style[pos].str[len] = NULL;
; 595  : 			pos++;
; 596  : 			getstrstyle(stemp, index, pos, TRUE, wm);

  000aa	8b 4d f4	 mov	 ecx, DWORD PTR tv1391[ebp]
  000ad	8d 04 33	 lea	 eax, DWORD PTR [ebx+esi]
  000b0	8b 75 18	 mov	 esi, DWORD PTR _wm$[ebp]
  000b3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b6	8b 5d f0	 mov	 ebx, DWORD PTR _pos$1$[ebp]
  000b9	8b d7		 mov	 edx, edi
  000bb	43		 inc	 ebx
  000bc	c6 44 30 10 00	 mov	 BYTE PTR [eax+esi+16], 0
  000c1	b8 01 00 00 00	 mov	 eax, 1
  000c6	e9 54 ff ff ff	 jmp	 $LN42@getstrstyl
$LN12@getstrstyl:

; 597  : 		}
; 598  : 		else {
; 599  : 			wm[index].flg = TRUE;
; 600  : 			stemp = stemp + 7;

  000cb	83 c7 07	 add	 edi, 7

; 601  : 			etemp = sunday(stemp, "]") + 1;

  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_01LBDDMOBJ@?$FN@
  000d3	57		 push	 edi
  000d4	e8 00 00 00 00	 call	 ?sunday@@YAPADPAD0@Z	; sunday
  000d9	40		 inc	 eax

; 602  : 			char *scolor = sunday(stemp, "c=");

  000da	68 00 00 00 00	 push	 OFFSET ??_C@_02CAMHBLCK@c?$DN@
  000df	57		 push	 edi
  000e0	89 45 ec	 mov	 DWORD PTR _etemp$1$[ebp], eax
  000e3	e8 00 00 00 00	 call	 ?sunday@@YAPADPAD0@Z	; sunday
  000e8	8b d0		 mov	 edx, eax
  000ea	83 c4 10	 add	 esp, 16			; 00000010H

; 603  : 			if (scolor) {

  000ed	85 d2		 test	 edx, edx
  000ef	74 38		 je	 SHORT $LN16@getstrstyl

; 604  : 				scolor = scolor + 2;
; 605  : 				char strnum[3];
; 606  : 				int i = 0;

  000f1	33 c0		 xor	 eax, eax
$LL4@getstrstyl:

; 607  : 				for (i; i<2 && scolor[i] != ' ' && scolor[i] != ']'; i++) {

  000f3	8a 4c 02 02	 mov	 cl, BYTE PTR [edx+eax+2]
  000f7	80 f9 20	 cmp	 cl, 32			; 00000020H
  000fa	74 0f		 je	 SHORT $LN3@getstrstyl
  000fc	80 f9 5d	 cmp	 cl, 93			; 0000005dH
  000ff	74 0a		 je	 SHORT $LN3@getstrstyl

; 608  : 					strnum[i] = scolor[i];

  00101	88 4c 05 14	 mov	 BYTE PTR _strnum$2[ebp+eax], cl
  00105	40		 inc	 eax
  00106	83 f8 02	 cmp	 eax, 2
  00109	7c e8		 jl	 SHORT $LL4@getstrstyl
$LN3@getstrstyl:

; 609  : 				}
; 610  : 				strnum[i] = 0;

  0010b	83 f8 03	 cmp	 eax, 3
  0010e	0f 83 79 01 00
	00		 jae	 $LN25@getstrstyl
  00114	c6 44 05 14 00	 mov	 BYTE PTR _strnum$2[ebp+eax], 0

; 611  : 				wm[index].style[pos].color = atoi(strnum);

  00119	8d 45 14	 lea	 eax, DWORD PTR _strnum$2[ebp]
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 _atoi
  00122	83 c4 04	 add	 esp, 4
  00125	8b c8		 mov	 ecx, eax

; 612  : 			}

  00127	eb 02		 jmp	 SHORT $LN17@getstrstyl
$LN16@getstrstyl:

; 613  : 			else wm[index].style[pos].color = 0;

  00129	33 c9		 xor	 ecx, ecx
$LN17@getstrstyl:

; 614  : 
; 615  : 			char *ssize = sunday(stemp, "s=");

  0012b	8b 45 18	 mov	 eax, DWORD PTR _wm$[ebp]
  0012e	69 f3 8c 00 00
	00		 imul	 esi, ebx, 140
  00134	68 00 00 00 00	 push	 OFFSET ??_C@_02DMOBLIFK@s?$DN@
  00139	57		 push	 edi
  0013a	03 75 f4	 add	 esi, DWORD PTR tv1391[ebp]
  0013d	89 75 f0	 mov	 DWORD PTR tv1384[ebp], esi
  00140	89 4c 06 0c	 mov	 DWORD PTR [esi+eax+12], ecx
  00144	e8 00 00 00 00	 call	 ?sunday@@YAPADPAD0@Z	; sunday
  00149	8b d0		 mov	 edx, eax
  0014b	83 c4 08	 add	 esp, 8

; 616  : 			if (ssize) {

  0014e	85 d2		 test	 edx, edx
  00150	74 2f		 je	 SHORT $LN18@getstrstyl

; 617  : 				ssize = ssize + 2;

  00152	83 c2 02	 add	 edx, 2

; 618  : 				char strsize[3];
; 619  : 				int i = 0;

  00155	33 c9		 xor	 ecx, ecx
$LL7@getstrstyl:

; 620  : 				for (i; i<2 && ssize[i] != ' ' && ssize[i] != ']'; i++) {

  00157	8a 04 0a	 mov	 al, BYTE PTR [edx+ecx]
  0015a	3c 20		 cmp	 al, 32			; 00000020H
  0015c	74 0a		 je	 SHORT $LN6@getstrstyl
  0015e	3c 5d		 cmp	 al, 93			; 0000005dH
  00160	74 06		 je	 SHORT $LN6@getstrstyl
  00162	41		 inc	 ecx
  00163	83 f9 02	 cmp	 ecx, 2
  00166	7c ef		 jl	 SHORT $LL7@getstrstyl
$LN6@getstrstyl:

; 621  : 					strsize[i] = ssize[i];
; 622  : 				}
; 623  : 				strsize[i] = 0;

  00168	83 f9 03	 cmp	 ecx, 3
  0016b	0f 83 1c 01 00
	00		 jae	 $LN25@getstrstyl

; 624  : 				wm[index].style[pos].size = atoi(ssize);

  00171	52		 push	 edx
  00172	c6 44 0d fc 00	 mov	 BYTE PTR _strsize$1[ebp+ecx], 0
  00177	e8 00 00 00 00	 call	 _atoi
  0017c	83 c4 04	 add	 esp, 4

; 625  : 			}

  0017f	eb 05		 jmp	 SHORT $LN19@getstrstyl
$LN18@getstrstyl:

; 626  : 			else wm[index].style[pos].size = FONT_SIZE1;

  00181	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
$LN19@getstrstyl:

; 627  : 
; 628  : 			stemp = sunday(str, "[/style]");

  00186	8b 4d 18	 mov	 ecx, DWORD PTR _wm$[ebp]
  00189	68 00 00 00 00	 push	 OFFSET ??_C@_08EAKPCBLG@?$FL?1style?$FN@
  0018e	ff 75 f8	 push	 DWORD PTR _str$1$[ebp]
  00191	89 44 0e 08	 mov	 DWORD PTR [esi+ecx+8], eax
  00195	e8 00 00 00 00	 call	 ?sunday@@YAPADPAD0@Z	; sunday

; 629  : 
; 630  : 			int len = stemp - etemp;
; 631  : 			memcpy(wm[index].style[pos].str, etemp, len);

  0019a	8b 55 f0	 mov	 edx, DWORD PTR tv1384[ebp]
  0019d	8b f8		 mov	 edi, eax
  0019f	8b 45 ec	 mov	 eax, DWORD PTR _etemp$1$[ebp]
  001a2	8b f7		 mov	 esi, edi
  001a4	8b 4d 18	 mov	 ecx, DWORD PTR _wm$[ebp]
  001a7	2b f0		 sub	 esi, eax
  001a9	56		 push	 esi
  001aa	83 c2 10	 add	 edx, 16			; 00000010H
  001ad	50		 push	 eax
  001ae	03 ca		 add	 ecx, edx
  001b0	51		 push	 ecx
  001b1	e8 00 00 00 00	 call	 _memcpy

; 632  : 			wm[index].style[pos].str[len] = NULL;

  001b6	8b 4d f0	 mov	 ecx, DWORD PTR tv1384[ebp]
  001b9	83 c4 14	 add	 esp, 20			; 00000014H
  001bc	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
  001bf	8b 75 18	 mov	 esi, DWORD PTR _wm$[ebp]
  001c2	c6 44 30 10 00	 mov	 BYTE PTR [eax+esi+16], 0

; 633  : 			if (pos == 0)

  001c7	85 db		 test	 ebx, ebx
  001c9	75 17		 jne	 SHORT $LN20@getstrstyl

; 634  : 				wm[index].style[pos].x = 0;

  001cb	8b 55 f0	 mov	 edx, DWORD PTR tv1384[ebp]
  001ce	33 c9		 xor	 ecx, ecx

; 637  : 			pos++;

  001d0	43		 inc	 ebx

; 638  : 			stemp = stemp + 8;
; 639  : 			getstrstyle(stemp, index, pos, FALSE, wm);

  001d1	33 c0		 xor	 eax, eax
  001d3	89 4c 32 04	 mov	 DWORD PTR [edx+esi+4], ecx
  001d7	8d 57 08	 lea	 edx, DWORD PTR [edi+8]
  001da	8b 4d f4	 mov	 ecx, DWORD PTR tv1391[ebp]
  001dd	e9 3d fe ff ff	 jmp	 $LN42@getstrstyl
$LN20@getstrstyl:

; 635  : 			else
; 636  : 				wm[index].style[pos].x = getTextLength(wm[index].style[pos - 1].str) + wm[index].style[pos - 1].x;

  001e2	8d 41 84	 lea	 eax, DWORD PTR [ecx-124]
  001e5	03 c6		 add	 eax, esi
  001e7	50		 push	 eax
  001e8	e8 00 00 00 00	 call	 ?getTextLength@@YAHPAD@Z ; getTextLength
  001ed	8b 55 f0	 mov	 edx, DWORD PTR tv1384[ebp]
  001f0	83 c4 04	 add	 esp, 4

; 637  : 			pos++;

  001f3	43		 inc	 ebx
  001f4	8b 8c 32 78 ff
	ff ff		 mov	 ecx, DWORD PTR [edx+esi-136]
  001fb	03 c8		 add	 ecx, eax

; 638  : 			stemp = stemp + 8;
; 639  : 			getstrstyle(stemp, index, pos, FALSE, wm);

  001fd	33 c0		 xor	 eax, eax
  001ff	89 4c 32 04	 mov	 DWORD PTR [edx+esi+4], ecx
  00203	8d 57 08	 lea	 edx, DWORD PTR [edi+8]
  00206	8b 4d f4	 mov	 ecx, DWORD PTR tv1391[ebp]
  00209	e9 11 fe ff ff	 jmp	 $LN42@getstrstyl
$LN10@getstrstyl:

; 640  : 		}
; 641  : 	}
; 642  : 	else {
; 643  : 		sprintf(wm[index].style[pos].str, "%s", str);

  0020e	69 f3 8c 00 00
	00		 imul	 esi, ebx, 140
  00214	8b 5d 18	 mov	 ebx, DWORD PTR _wm$[ebp]
  00217	52		 push	 edx
  00218	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0021d	03 f1		 add	 esi, ecx
  0021f	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  00222	03 c6		 add	 eax, esi
  00224	50		 push	 eax
  00225	e8 00 00 00 00	 call	 _sprintf

; 644  : 		if (!wm[index].flg) {

  0022a	8b 55 f4	 mov	 edx, DWORD PTR tv1391[ebp]
  0022d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00230	83 3c 13 00	 cmp	 DWORD PTR [ebx+edx], 0
  00234	5f		 pop	 edi
  00235	75 25		 jne	 SHORT $LN22@getstrstyl

; 645  : 			wm[index].flg = TRUE;

  00237	c7 04 13 01 00
	00 00		 mov	 DWORD PTR [ebx+edx], 1

; 646  : 			wm[index].style[pos].x = 0;

  0023e	c7 44 1e 04 00
	00 00 00	 mov	 DWORD PTR [esi+ebx+4], 0

; 647  : 			wm[index].style[pos].color = 0;
; 648  : 			wm[index].style[pos].size = FONT_SIZE1;

  00246	c7 44 1e 08 0e
	00 00 00	 mov	 DWORD PTR [esi+ebx+8], 14 ; 0000000eH

; 653  : 			wm[index].style[pos].color = 0;
; 654  : 		}
; 655  : 	}
; 656  : }

  0024e	c7 44 1e 0c 00
	00 00 00	 mov	 DWORD PTR [esi+ebx+12], 0
  00256	5e		 pop	 esi
  00257	5b		 pop	 ebx
  00258	8b e5		 mov	 esp, ebp
  0025a	5d		 pop	 ebp
  0025b	c3		 ret	 0
$LN22@getstrstyl:

; 649  : 		}
; 650  : 		else {
; 651  : 			wm[index].style[pos].size = FONT_SIZE1;
; 652  : 			wm[index].style[pos].x = getTextLength(wm[index].style[pos - 1].str) + wm[index].style[pos - 1].x;

  0025c	8d 43 84	 lea	 eax, DWORD PTR [ebx-124]
  0025f	c7 44 1e 08 0e
	00 00 00	 mov	 DWORD PTR [esi+ebx+8], 14 ; 0000000eH
  00267	03 c6		 add	 eax, esi
  00269	50		 push	 eax
  0026a	e8 00 00 00 00	 call	 ?getTextLength@@YAHPAD@Z ; getTextLength
  0026f	8b 8c 1e 78 ff
	ff ff		 mov	 ecx, DWORD PTR [esi+ebx-136]
  00276	83 c4 04	 add	 esp, 4
  00279	03 c8		 add	 ecx, eax

; 653  : 			wm[index].style[pos].color = 0;
; 654  : 		}
; 655  : 	}
; 656  : }

  0027b	c7 44 1e 0c 00
	00 00 00	 mov	 DWORD PTR [esi+ebx+12], 0
  00283	89 4c 1e 04	 mov	 DWORD PTR [esi+ebx+4], ecx
  00287	5e		 pop	 esi
  00288	5b		 pop	 ebx
  00289	8b e5		 mov	 esp, ebp
  0028b	5d		 pop	 ebp
  0028c	c3		 ret	 0
$LN25@getstrstyl:
  0028d	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN41@getstrstyl:
  00292	cc		 int	 3
?getstrstyle@@YAXPADHHHQAUWM_STR@@@Z ENDP		; getstrstyle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?rtrim@@YAXPAD@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
?rtrim@@YAXPAD@Z PROC					; rtrim, COMDAT

; 567  : void rtrim(char *str) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 568  : 	int i;
; 569  : 	for (i = (int)strlen(str) - 1; str[i] == 32 && i >= 0; str[i--] = 0);

  00003	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00006	8b ca		 mov	 ecx, edx
  00008	56		 push	 esi
  00009	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  0000c	0f 1f 40 00	 npad	 4
$LL10@rtrim:
  00010	8a 01		 mov	 al, BYTE PTR [ecx]
  00012	41		 inc	 ecx
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL10@rtrim
  00017	2b ce		 sub	 ecx, esi
  00019	5e		 pop	 esi
  0001a	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  0001d	80 3c 10 20	 cmp	 BYTE PTR [eax+edx], 32	; 00000020H
  00021	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]
  00024	75 11		 jne	 SHORT $LN11@rtrim
$LL4@rtrim:
  00026	85 c0		 test	 eax, eax
  00028	78 0d		 js	 SHORT $LN11@rtrim
  0002a	48		 dec	 eax
  0002b	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0002e	80 3c 10 20	 cmp	 BYTE PTR [eax+edx], 32	; 00000020H
  00032	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]
  00035	74 ef		 je	 SHORT $LL4@rtrim
$LN11@rtrim:

; 570  : }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?rtrim@@YAXPAD@Z ENDP					; rtrim
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?ltrim@@YAXPAD@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
?ltrim@@YAXPAD@Z PROC					; ltrim, COMDAT

; 561  : void ltrim(char *str) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 562  : 	char *ptr;
; 563  : 	for (ptr = str; *ptr == 32; ptr++);
; 564  : 
; 565  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?ltrim@@YAXPAD@Z ENDP					; ltrim
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?getStringFromIndexWithDelim_body@@YAHPAD0H0H@Z
_TEXT	SEGMENT
tv160 = -8						; size = 4
_i$1$ = -4						; size = 4
_src$ = 8						; size = 4
_delim$ = 12						; size = 4
_index$ = 16						; size = 4
_buf$ = 20						; size = 4
_buflen$ = 24						; size = 4
?getStringFromIndexWithDelim_body@@YAHPAD0H0H@Z PROC	; getStringFromIndexWithDelim_body, COMDAT

; 520  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 521  : 	int i;
; 522  : 	int length = 0;

  00006	33 d2		 xor	 edx, edx

; 523  : 	int addlen = 0;

  00008	33 c9		 xor	 ecx, ecx
  0000a	53		 push	 ebx

; 524  : 	int oneByteMode = 0;
; 525  : 
; 526  : 	if (strlen(delim) == 1) {

  0000b	8b 5d 0c	 mov	 ebx, DWORD PTR _delim$[ebp]
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8b fb		 mov	 edi, ebx
  00012	8d 77 01	 lea	 esi, DWORD PTR [edi+1]
$LL21@getStringF:
  00015	8a 07		 mov	 al, BYTE PTR [edi]
  00017	47		 inc	 edi
  00018	84 c0		 test	 al, al
  0001a	75 f9		 jne	 SHORT $LL21@getStringF
  0001c	2b fe		 sub	 edi, esi

; 527  : 		oneByteMode = 1;
; 528  : 	}
; 529  : 	for (i = 0; i < index; i++) {

  0001e	89 4d fc	 mov	 DWORD PTR _i$1$[ebp], ecx
  00021	8b 75 08	 mov	 esi, DWORD PTR _src$[ebp]
  00024	39 4d 10	 cmp	 DWORD PTR _index$[ebp], ecx
  00027	7e 50		 jle	 SHORT $LN3@getStringF
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@getStringF:

; 530  : 		char* last;
; 531  : 		src += addlen;

  00030	03 f1		 add	 esi, ecx

; 532  : 
; 533  : 		if (oneByteMode) {

  00032	83 ff 01	 cmp	 edi, 1
  00035	75 0c		 jne	 SHORT $LN6@getStringF

; 534  : 
; 535  : 			char * ScanOneByte(char *src, char delim);
; 536  : 			last = ScanOneByte(src, delim[0]);

  00037	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0003a	50		 push	 eax
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 ?ScanOneByte@@YAPADPADD@Z ; ScanOneByte

; 537  : 		}

  00041	eb 07		 jmp	 SHORT $LN24@getStringF
$LN6@getStringF:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h

; 524  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  00043	53		 push	 ebx
  00044	56		 push	 esi
  00045	e8 00 00 00 00	 call	 _strstr
$LN24@getStringF:
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp

; 541  : 		if (last == NULL) {

  0004a	8b d0		 mov	 edx, eax
  0004c	83 c4 08	 add	 esp, 8
  0004f	85 d2		 test	 edx, edx
  00051	74 48		 je	 SHORT $LN16@getStringF

; 549  : 			return FALSE;
; 550  : 		}
; 551  : 		length = last - src;
; 552  : 		addlen = length + strlen(delim);

  00053	8b c3		 mov	 eax, ebx
  00055	2b d6		 sub	 edx, esi
  00057	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0005a	89 4d f8	 mov	 DWORD PTR tv160[ebp], ecx
  0005d	0f 1f 00	 npad	 3
$LL22@getStringF:
  00060	8a 08		 mov	 cl, BYTE PTR [eax]
  00062	40		 inc	 eax
  00063	84 c9		 test	 cl, cl
  00065	75 f9		 jne	 SHORT $LL22@getStringF
  00067	2b 45 f8	 sub	 eax, DWORD PTR tv160[ebp]
  0006a	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]
  0006d	8b 45 fc	 mov	 eax, DWORD PTR _i$1$[ebp]
  00070	40		 inc	 eax
  00071	89 45 fc	 mov	 DWORD PTR _i$1$[ebp], eax
  00074	3b 45 10	 cmp	 eax, DWORD PTR _index$[ebp]
  00077	7c b7		 jl	 SHORT $LL4@getStringF
$LN3@getStringF:

; 553  : 	}
; 554  : 	void strncpysafe(char* dest, const size_t n,
; 555  : 		const char* src, const int length);
; 556  : 	strncpysafe(buf, buflen, src, length);

  00079	52		 push	 edx
  0007a	56		 push	 esi
  0007b	ff 75 18	 push	 DWORD PTR _buflen$[ebp]
  0007e	8b 75 14	 mov	 esi, DWORD PTR _buf$[ebp]
  00081	56		 push	 esi
  00082	e8 00 00 00 00	 call	 ?strncpysafe@@YAXPADIPBDH@Z ; strncpysafe
  00087	83 c4 10	 add	 esp, 16			; 00000010H
$LN26@getStringF:

; 557  : 	if (buf[0] == 0) return FALSE;

  0008a	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0008d	74 28		 je	 SHORT $LN27@getStringF

; 558  : 	return TRUE;
; 559  : }

  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	b8 01 00 00 00	 mov	 eax, 1
  00096	5b		 pop	 ebx
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
$LN16@getStringF:

; 542  : 			void strcpysafe(char* dest, size_t n, const char* src);
; 543  : 			strcpysafe(buf, buflen, src);

  0009b	56		 push	 esi
  0009c	ff 75 18	 push	 DWORD PTR _buflen$[ebp]
  0009f	8b 75 14	 mov	 esi, DWORD PTR _buf$[ebp]
  000a2	56		 push	 esi
  000a3	e8 00 00 00 00	 call	 ?strcpysafe@@YAXPADIPBD@Z ; strcpysafe

; 544  : 			if (i == index - 1) {

  000a8	8b 45 10	 mov	 eax, DWORD PTR _index$[ebp]
  000ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ae	48		 dec	 eax
  000af	39 45 fc	 cmp	 DWORD PTR _i$1$[ebp], eax
  000b2	74 d6		 je	 SHORT $LN26@getStringF

; 545  : 				if (buf[0] == 0) return FALSE;
; 546  : 				return TRUE;
; 547  : 			}
; 548  : 			buf[0] = 0;

  000b4	c6 06 00	 mov	 BYTE PTR [esi], 0
$LN27@getStringF:
  000b7	5f		 pop	 edi

; 558  : 	return TRUE;
; 559  : }

  000b8	5e		 pop	 esi
  000b9	33 c0		 xor	 eax, eax
  000bb	5b		 pop	 ebx
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c3		 ret	 0
?getStringFromIndexWithDelim_body@@YAHPAD0H0H@Z ENDP	; getStringFromIndexWithDelim_body
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?strcmptail@@YAHPAD0@Z
_TEXT	SEGMENT
_s1$ = 8						; size = 4
_s2$ = 12						; size = 4
?strcmptail@@YAHPAD0@Z PROC				; strcmptail, COMDAT

; 504  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 505  : 	int i;
; 506  : 	int len1 = strlen(s1);

  00004	8b 75 08	 mov	 esi, DWORD PTR _s1$[ebp]
  00007	8b d6		 mov	 edx, esi
  00009	57		 push	 edi
  0000a	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
  0000d	0f 1f 00	 npad	 3
$LL15@strcmptail:
  00010	8a 02		 mov	 al, BYTE PTR [edx]
  00012	42		 inc	 edx
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL15@strcmptail

; 507  : 	int len2 = strlen(s2);

  00017	8b 7d 0c	 mov	 edi, DWORD PTR _s2$[ebp]
  0001a	2b d1		 sub	 edx, ecx
  0001c	8b c7		 mov	 eax, edi
  0001e	53		 push	 ebx
  0001f	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]
$LL16@strcmptail:
  00022	8a 08		 mov	 cl, BYTE PTR [eax]
  00024	40		 inc	 eax
  00025	84 c9		 test	 cl, cl
  00027	75 f9		 jne	 SHORT $LL16@strcmptail
  00029	2b c3		 sub	 eax, ebx

; 510  : 		int ind1 = len1 - 1 - i;

  0002b	8d 4a ff	 lea	 ecx, DWORD PTR [edx-1]
  0002e	5b		 pop	 ebx

; 511  : 		int ind2 = len2 - 1 - i;
; 512  : 		if (ind1 < 0 || ind2 < 0) return 0;

  0002f	85 c9		 test	 ecx, ecx
  00031	78 17		 js	 SHORT $LN6@strcmptail

; 505  : 	int i;
; 506  : 	int len1 = strlen(s1);

  00033	8b d1		 mov	 edx, ecx
$LL4@strcmptail:

; 511  : 		int ind2 = len2 - 1 - i;
; 512  : 		if (ind1 < 0 || ind2 < 0) return 0;

  00035	85 c0		 test	 eax, eax
  00037	7e 11		 jle	 SHORT $LN6@strcmptail

; 513  : 		if (s1[ind1] != s2[ind2]) return 1;

  00039	8a 0c 31	 mov	 cl, BYTE PTR [ecx+esi]
  0003c	3a 4c 07 ff	 cmp	 cl, BYTE PTR [edi+eax-1]
  00040	75 0e		 jne	 SHORT $LN11@strcmptail

; 508  : 
; 509  : 	for (i = 0;; i++) {

  00042	48		 dec	 eax
  00043	83 ea 01	 sub	 edx, 1

; 510  : 		int ind1 = len1 - 1 - i;

  00046	8b ca		 mov	 ecx, edx

; 511  : 		int ind2 = len2 - 1 - i;
; 512  : 		if (ind1 < 0 || ind2 < 0) return 0;

  00048	79 eb		 jns	 SHORT $LL4@strcmptail
$LN6@strcmptail:
  0004a	5f		 pop	 edi
  0004b	33 c0		 xor	 eax, eax

; 514  : 	}
; 515  : }

  0004d	5e		 pop	 esi
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
$LN11@strcmptail:
  00050	5f		 pop	 edi

; 513  : 		if (s1[ind1] != s2[ind2]) return 1;

  00051	b8 01 00 00 00	 mov	 eax, 1

; 514  : 	}
; 515  : }

  00056	5e		 pop	 esi
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?strcmptail@@YAHPAD0@Z ENDP				; strcmptail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?PutWinText@@YAXHHDHPADHH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_fontPrio$ = 16						; size = 1
_color$ = 20						; size = 4
_str$ = 24						; size = 4
_hitFlag$ = 28						; size = 4
_index$ = 32						; size = 4
?PutWinText@@YAXHHDHPADHH@Z PROC			; PutWinText, COMDAT

; 659  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 660  : 	int i = 0;

  00004	8b 5d 1c	 mov	 ebx, DWORD PTR _hitFlag$[ebp]
  00007	56		 push	 esi
  00008	69 75 20 6c 10
	00 00		 imul	 esi, DWORD PTR _index$[ebp], 4204
  0000f	57		 push	 edi
  00010	bf 1e 00 00 00	 mov	 edi, 30			; 0000001eH
  00015	81 c6 10 00 00
	00		 add	 esi, OFFSET ?wmstr@@3PAUWM_STR@@A+16
  0001b	0f 1f 44 00 00	 npad	 5
$LL4@PutWinText:

; 662  : 		if (*wmstr[index].style[i].str)

  00020	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00023	74 1d		 je	 SHORT $LN2@PutWinText

; 663  : 			StockFontBufferExt(x + wmstr[index].style[i].x, y, fontPrio, wmstr[index].style[i].color,

  00025	ff 76 f8	 push	 DWORD PTR [esi-8]
  00028	8b 46 f4	 mov	 eax, DWORD PTR [esi-12]
  0002b	03 45 08	 add	 eax, DWORD PTR _x$[ebp]
  0002e	53		 push	 ebx
  0002f	56		 push	 esi
  00030	ff 76 fc	 push	 DWORD PTR [esi-4]
  00033	ff 75 10	 push	 DWORD PTR _fontPrio$[ebp]
  00036	ff 75 0c	 push	 DWORD PTR _y$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?StockFontBufferExt@@YAHHHDHPADHH@Z ; StockFontBufferExt
  0003f	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN2@PutWinText:

; 661  : 	for (; i<30; i++) {

  00042	81 c6 8c 00 00
	00		 add	 esi, 140		; 0000008cH
  00048	83 ef 01	 sub	 edi, 1
  0004b	75 d3		 jne	 SHORT $LL4@PutWinText

; 664  : 				wmstr[index].style[i].str, hitFlag, wmstr[index].style[i].size);
; 665  : 	}
; 666  : }

  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?PutWinText@@YAXHHDHPADHH@Z ENDP			; PutWinText
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?getStrSplitNew@@YAXQAY0BAA@D@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
?getStrSplitNew@@YAXQAY0BAA@D@Z PROC			; getStrSplitNew, COMDAT

; 778  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 779  : 	memset(wmstr, 0, sizeof(WM_STR) * 25);

  00005	68 8c 9a 01 00	 push	 105100			; 00019a8cH
  0000a	6a 00		 push	 0
  0000c	68 00 00 00 00	 push	 OFFSET ?wmstr@@3PAUWM_STR@@A ; wmstr
  00011	e8 00 00 00 00	 call	 _memset
  00016	8b 75 08	 mov	 esi, DWORD PTR _str$[ebp]
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001c	33 ff		 xor	 edi, edi
  0001e	66 90		 npad	 2
$LL4@getStrSpli:

; 783  : 		if (str[i][0]) {

  00020	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00023	74 13		 je	 SHORT $LN2@getStrSpli

; 784  : 			getstrstyle(str[i], i, 0, FALSE, wmstr);

  00025	68 00 00 00 00	 push	 OFFSET ?wmstr@@3PAUWM_STR@@A ; wmstr
  0002a	6a 00		 push	 0
  0002c	6a 00		 push	 0
  0002e	57		 push	 edi
  0002f	56		 push	 esi
  00030	e8 00 00 00 00	 call	 ?getstrstyle@@YAXPADHHHQAUWM_STR@@@Z ; getstrstyle
  00035	83 c4 14	 add	 esp, 20			; 00000014H
$LN2@getStrSpli:

; 780  : 	int i = 0;
; 781  : 
; 782  : 	for (i; i<25; i++) {

  00038	47		 inc	 edi
  00039	81 c6 00 01 00
	00		 add	 esi, 256		; 00000100H
  0003f	83 ff 19	 cmp	 edi, 25			; 00000019H
  00042	7c dc		 jl	 SHORT $LL4@getStrSpli

; 785  : 		}
; 786  : 	}
; 787  : }

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?getStrSplitNew@@YAXQAY0BAA@D@Z ENDP			; getStrSplitNew
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?util_mkstring@@YAHPAD0@Z
_TEXT	SEGMENT
_value$GSCopy$1$ = -65508				; size = 4
_t1$ = -65504						; size = 65500
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_value$ = 12						; size = 4
?util_mkstring@@YAHPAD0@Z PROC				; util_mkstring, COMDAT

; 468  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 e4 ff 00 00	 mov	 eax, 65508		; 0000ffe4H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp]

; 469  :   char t1[SLICE_SIZE];
; 470  :   //printf("åŠ¨æ€å¯†é’¥4ï¼š%s\n",PersonalKey);
; 471  :   util_256to64_shl(t1, value, strlen(value), DEFAULTTABLE, PersonalKey);

  0001a	8b ca		 mov	 ecx, edx
  0001c	53		 push	 ebx
  0001d	8b 5d 08	 mov	 ebx, DWORD PTR _buffer$[ebp]
  00020	56		 push	 esi
  00021	57		 push	 edi
  00022	89 95 1c 00 ff
	ff		 mov	 DWORD PTR _value$GSCopy$1$[ebp], edx
  00028	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  0002b	0f 1f 44 00 00	 npad	 5
$LL3@util_mkstr:
  00030	8a 01		 mov	 al, BYTE PTR [ecx]
  00032	41		 inc	 ecx
  00033	84 c0		 test	 al, al
  00035	75 f9		 jne	 SHORT $LL3@util_mkstr
  00037	68 00 00 00 00	 push	 OFFSET ?PersonalKey@@3PADA ; PersonalKey
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@CPNIKEEC@0123456789ABCDEFGHIJKLMNOPQRSTU@
  00041	2b ce		 sub	 ecx, esi
  00043	8d 85 20 00 ff
	ff		 lea	 eax, DWORD PTR _t1$[ebp]
  00049	51		 push	 ecx
  0004a	52		 push	 edx
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ?util_256to64_shl@@YAHPAD0H00@Z ; util_256to64_shl
  00051	83 c4 14	 add	 esp, 20			; 00000014H

; 472  :   strcat(buffer, ";");	// It's important to append a SEPARATOR between fields

  00054	8d 7b ff	 lea	 edi, DWORD PTR [ebx-1]
$LL4@util_mkstr:
  00057	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  0005a	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  0005d	84 c0		 test	 al, al
  0005f	75 f6		 jne	 SHORT $LL4@util_mkstr
  00061	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01ICJEACDI@?$DL@

; 473  :   strcat(buffer, t1);

  00067	8d 95 20 00 ff
	ff		 lea	 edx, DWORD PTR _t1$[ebp]
  0006d	66 89 07	 mov	 WORD PTR [edi], ax
  00070	8b f2		 mov	 esi, edx
$LL5@util_mkstr:
  00072	8a 02		 mov	 al, BYTE PTR [edx]
  00074	42		 inc	 edx
  00075	84 c0		 test	 al, al
  00077	75 f9		 jne	 SHORT $LL5@util_mkstr
  00079	2b d6		 sub	 edx, esi
  0007b	4b		 dec	 ebx
  0007c	0f 1f 40 00	 npad	 4
$LL6@util_mkstr:
  00080	8a 43 01	 mov	 al, BYTE PTR [ebx+1]
  00083	43		 inc	 ebx
  00084	84 c0		 test	 al, al
  00086	75 f8		 jne	 SHORT $LL6@util_mkstr
  00088	8b ca		 mov	 ecx, edx
  0008a	8b fb		 mov	 edi, ebx
  0008c	c1 e9 02	 shr	 ecx, 2
  0008f	f3 a5		 rep movsd
  00091	8b ca		 mov	 ecx, edx
  00093	83 e1 03	 and	 ecx, 3
  00096	f3 a4		 rep movsb

; 474  : 
; 475  :   //JL 2016.8.25
; 476  :   //hook stringç¼–ç 
; 477  :   int len = strlen(value);

  00098	8b 8d 1c 00 ff
	ff		 mov	 ecx, DWORD PTR _value$GSCopy$1$[ebp]
  0009e	8b f1		 mov	 esi, ecx
  000a0	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
$LL7@util_mkstr:
  000a3	8a 06		 mov	 al, BYTE PTR [esi]
  000a5	46		 inc	 esi
  000a6	84 c0		 test	 al, al
  000a8	75 f9		 jne	 SHORT $LL7@util_mkstr
  000aa	2b f2		 sub	 esi, edx

; 478  :   JL_combineString_SEND(value, len);

  000ac	56		 push	 esi
  000ad	51		 push	 ecx
  000ae	e8 00 00 00 00	 call	 ?JL_combineString_SEND@@YAXPADH@Z ; JL_combineString_SEND

; 479  : 
; 480  :   return len ;
; 481  : }

  000b3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b6	83 c4 08	 add	 esp, 8
  000b9	8b c6		 mov	 eax, esi
  000bb	33 cd		 xor	 ecx, ebp
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
?util_mkstring@@YAHPAD0@Z ENDP				; util_mkstring
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?util_destring@@YAHHPAD@Z
_TEXT	SEGMENT
_sliceno$ = 8						; size = 4
_value$ = 12						; size = 4
?util_destring@@YAHHPAD@Z PROC				; util_destring, COMDAT

; 443  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 444  : 
; 445  : 	//printf("åŠ¨æ€å¯†é’¥3ï¼š%s\n",PersonalKey);
; 446  : 	util_shr_64to256(value, MesgSlice[sliceno], DEFAULTTABLE, PersonalKey);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _sliceno$[ebp]
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ?MesgSlice@@3PAPADA ; MesgSlice
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b 7d 0c	 mov	 edi, DWORD PTR _value$[ebp]
  00010	68 00 00 00 00	 push	 OFFSET ?PersonalKey@@3PADA ; PersonalKey
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@CPNIKEEC@0123456789ABCDEFGHIJKLMNOPQRSTU@
  0001a	ff 34 88	 push	 DWORD PTR [eax+ecx*4]
  0001d	57		 push	 edi
  0001e	e8 00 00 00 00	 call	 ?util_shr_64to256@@YAHPAD000@Z ; util_shr_64to256
  00023	83 c4 10	 add	 esp, 16			; 00000010H

; 447  : 	extern int g_æœåŠ¡å™¨;
; 448  : 	if (g_æœåŠ¡å™¨ == SERVER_å°æœ){

  00026	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_Ü×?Ðï@@3HA, 1 ; g_Ü×?Ðï
  0002d	75 0e		 jne	 SHORT $LN2@util_destr

; 449  : 		BIG52GBK(value);

  0002f	8b cf		 mov	 ecx, edi
  00031	e8 00 00 00 00	 call	 ?BIG52GBK@@YIXPAD@Z	; BIG52GBK

; 450  : 		GBK2GB(value);

  00036	8b cf		 mov	 ecx, edi
  00038	e8 00 00 00 00	 call	 ?GBK2GB@@YIXPAD@Z	; GBK2GB
$LN2@util_destr:

; 451  : 	}
; 452  : 
; 453  : 
; 454  : 	//JL 2016.8.23
; 455  : 	//hook stringè§£ç 
; 456  : 	int len = strlen(value);

  0003d	8b f7		 mov	 esi, edi
  0003f	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
$LL4@util_destr:
  00042	8a 06		 mov	 al, BYTE PTR [esi]
  00044	46		 inc	 esi
  00045	84 c0		 test	 al, al
  00047	75 f9		 jne	 SHORT $LL4@util_destr
  00049	2b f1		 sub	 esi, ecx

; 457  : 	JL_combineString_RECV(value, len);

  0004b	56		 push	 esi
  0004c	57		 push	 edi
  0004d	e8 00 00 00 00	 call	 ?JL_combineString_RECV@@YAXPADH@Z ; JL_combineString_RECV
  00052	83 c4 08	 add	 esp, 8

; 458  : 
; 459  : 	return len; 

  00055	8b c6		 mov	 eax, esi
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi

; 460  : }

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?util_destring@@YAHHPAD@Z ENDP				; util_destring
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?util_mkint@@YAHPADH@Z
_TEXT	SEGMENT
_t2$ = -4104						; size = 4
_t1$ = -4104						; size = 4
_t3$ = -4100						; size = 4096
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_value$ = 12						; size = 4
?util_mkint@@YAHPADH@Z PROC				; util_mkint, COMDAT

; 419  : int util_mkint(char *buffer, int value){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 08 10 00 00	 mov	 eax, 4104		; 00001008H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	8b 5d 08	 mov	 ebx, DWORD PTR _buffer$[ebp]

; 420  :   int t1, t2;
; 421  :   char t3[4096];
; 422  :   util_swapint(&t1, &value, "3142");

  0001b	8d 45 0c	 lea	 eax, DWORD PTR _value$[ebp]
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_04FJNJEMEN@3142@
  00025	50		 push	 eax
  00026	8d 85 f8 ef ff
	ff		 lea	 eax, DWORD PTR _t1$[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?util_swapint@@YAXPAH0PAD@Z ; util_swapint

; 423  :   t2 = t1 ^ 0xffffffff;

  00032	f7 95 f8 ef ff
	ff		 not	 DWORD PTR _t1$[ebp]

; 424  : 
; 425  :   //printf("åŠ¨æ€å¯†é’¥2ï¼š%s\n",PersonalKey);
; 426  :   util_256to64_shr(t3, (char *) &t2, sizeof(int), DEFAULTTABLE, PersonalKey);

  00038	8d 85 f8 ef ff
	ff		 lea	 eax, DWORD PTR _t2$[ebp]
  0003e	68 00 00 00 00	 push	 OFFSET ?PersonalKey@@3PADA ; PersonalKey
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@CPNIKEEC@0123456789ABCDEFGHIJKLMNOPQRSTU@
  00048	6a 04		 push	 4
  0004a	50		 push	 eax
  0004b	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _t3$[ebp]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ?util_256to64_shr@@YAHPAD0H00@Z ; util_256to64_shr
  00057	83 c4 20	 add	 esp, 32			; 00000020H

; 427  :   strcat(buffer, ";");	// It's important to append a SEPARATOR between fields

  0005a	8d 7b ff	 lea	 edi, DWORD PTR [ebx-1]
  0005d	0f 1f 00	 npad	 3
$LL3@util_mkint:
  00060	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00063	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  00066	84 c0		 test	 al, al
  00068	75 f6		 jne	 SHORT $LL3@util_mkint
  0006a	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01ICJEACDI@?$DL@

; 428  :   strcat(buffer, t3);

  00070	8d 95 fc ef ff
	ff		 lea	 edx, DWORD PTR _t3$[ebp]
  00076	66 89 07	 mov	 WORD PTR [edi], ax
  00079	8b f2		 mov	 esi, edx
  0007b	0f 1f 44 00 00	 npad	 5
$LL4@util_mkint:
  00080	8a 02		 mov	 al, BYTE PTR [edx]
  00082	42		 inc	 edx
  00083	84 c0		 test	 al, al
  00085	75 f9		 jne	 SHORT $LL4@util_mkint
  00087	2b d6		 sub	 edx, esi
  00089	4b		 dec	 ebx
  0008a	66 0f 1f 44 00
	00		 npad	 6
$LL5@util_mkint:
  00090	8a 43 01	 mov	 al, BYTE PTR [ebx+1]
  00093	43		 inc	 ebx
  00094	84 c0		 test	 al, al
  00096	75 f8		 jne	 SHORT $LL5@util_mkint
  00098	8b ca		 mov	 ecx, edx
  0009a	8b fb		 mov	 edi, ebx
  0009c	c1 e9 02	 shr	 ecx, 2
  0009f	f3 a5		 rep movsd
  000a1	8b ca		 mov	 ecx, edx
  000a3	83 e1 03	 and	 ecx, 3
  000a6	f3 a4		 rep movsb

; 429  : 
; 430  :   //JL 2016.8.25
; 431  :   JL_combineInt_SEND(value);

  000a8	8b 75 0c	 mov	 esi, DWORD PTR _value$[ebp]
  000ab	56		 push	 esi
  000ac	e8 00 00 00 00	 call	 ?JL_combineInt_SEND@@YAXH@Z ; JL_combineInt_SEND

; 432  : 
; 433  :   return value;
; 434  : }

  000b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b4	83 c4 04	 add	 esp, 4
  000b7	8b c6		 mov	 eax, esi
  000b9	33 cd		 xor	 ecx, ebp
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx
  000be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c3		 ret	 0
?util_mkint@@YAHPADH@Z ENDP				; util_mkint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?util_deint@@YAHHPAH@Z
_TEXT	SEGMENT
_addr$ = -4108						; size = 4
_t2$ = -4104						; size = 4
_t3$ = -4100						; size = 4096
__$ArrayPad$ = -4					; size = 4
_sliceno$ = 8						; size = 4
_value$ = 12						; size = 4
?util_deint@@YAHHPAH@Z PROC				; util_deint, COMDAT

; 394  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 0c 10 00 00	 mov	 eax, 4108		; 0000100cH
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	56		 push	 esi
  00018	8b 75 0c	 mov	 esi, DWORD PTR _value$[ebp]

; 395  :   int *t1, t2;
; 396  :   char t3[4096];
; 397  :   int addr;
; 398  :   __asm
; 399  :   {
; 400  : 	  push dword ptr[ebp + 4];

  0001b	ff 75 04	 push	 DWORD PTR [ebp+4]

; 401  : 	  pop addr;

  0001e	8f 85 f4 ef ff
	ff		 pop	 DWORD PTR _addr$[ebp]

; 402  :   }
; 403  :   //printf("åŠ¨æ€å¯†é’¥1ï¼š%s\n",PersonalKey);
; 404  :   util_shl_64to256(t3, MesgSlice[sliceno], DEFAULTTABLE, PersonalKey);

  00024	a1 00 00 00 00	 mov	 eax, DWORD PTR ?MesgSlice@@3PAPADA ; MesgSlice
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _sliceno$[ebp]
  0002c	68 00 00 00 00	 push	 OFFSET ?PersonalKey@@3PADA ; PersonalKey
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@CPNIKEEC@0123456789ABCDEFGHIJKLMNOPQRSTU@
  00036	ff 34 88	 push	 DWORD PTR [eax+ecx*4]
  00039	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _t3$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?util_shl_64to256@@YAHPAD000@Z ; util_shl_64to256

; 405  :   t1 = (int *) t3;
; 406  :   t2 = *t1 ^ 0xffffffff;

  00045	8b 85 fc ef ff
	ff		 mov	 eax, DWORD PTR _t3$[ebp]
  0004b	f7 d0		 not	 eax
  0004d	89 85 f8 ef ff
	ff		 mov	 DWORD PTR _t2$[ebp], eax

; 407  :   util_swapint(value, &t2, "2413");

  00053	8d 85 f8 ef ff
	ff		 lea	 eax, DWORD PTR _t2$[ebp]
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_04EMLHGGGF@2413@
  0005e	50		 push	 eax
  0005f	56		 push	 esi
  00060	e8 00 00 00 00	 call	 ?util_swapint@@YAXPAH0PAD@Z ; util_swapint

; 408  : 
; 409  :   //JL 2016.8.23
; 410  :   //hook æ•´æ•°è§£ç 
; 411  :   JL_combineInt_RECV(*value, addr);

  00065	ff b5 f4 ef ff
	ff		 push	 DWORD PTR _addr$[ebp]
  0006b	ff 36		 push	 DWORD PTR [esi]
  0006d	e8 00 00 00 00	 call	 ?JL_combineInt_RECV@@YAXHH@Z ; JL_combineInt_RECV

; 412  : 
; 413  : 
; 414  : 
; 415  :   return *value;
; 416  : }

  00072	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00075	83 c4 24	 add	 esp, 36			; 00000024H
  00078	8b 06		 mov	 eax, DWORD PTR [esi]
  0007a	33 cd		 xor	 ecx, ebp
  0007c	5e		 pop	 esi
  0007d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
?util_deint@@YAHHPAH@Z ENDP				; util_deint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?util_shlstring@@YAXPAD0H@Z
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_offs$ = 16						; size = 4
?util_shlstring@@YAXPAD0H@Z PROC			; util_shlstring, COMDAT

; 381  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 382  :   char *ptr;
; 383  :   if (!dst || !src || (strlen(src)<1)) return;

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _dst$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	74 72		 je	 SHORT $LN3@util_shlst
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR _src$[ebp]
  0000f	85 f6		 test	 esi, esi
  00011	74 69		 je	 SHORT $LN12@util_shlst
  00013	8b ce		 mov	 ecx, esi
  00015	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL9@util_shlst:
  00018	8a 01		 mov	 al, BYTE PTR [ecx]
  0001a	41		 inc	 ecx
  0001b	84 c0		 test	 al, al
  0001d	75 f9		 jne	 SHORT $LL9@util_shlst
  0001f	2b ca		 sub	 ecx, edx
  00021	83 f9 01	 cmp	 ecx, 1
  00024	72 56		 jb	 SHORT $LN12@util_shlst

; 384  :   
; 385  :   offs = offs % strlen(src);

  00026	8b ce		 mov	 ecx, esi
  00028	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0002b	0f 1f 44 00 00	 npad	 5
$LL10@util_shlst:
  00030	8a 01		 mov	 al, BYTE PTR [ecx]
  00032	41		 inc	 ecx
  00033	84 c0		 test	 al, al
  00035	75 f9		 jne	 SHORT $LL10@util_shlst
  00037	8b 45 10	 mov	 eax, DWORD PTR _offs$[ebp]
  0003a	2b ca		 sub	 ecx, edx
  0003c	33 d2		 xor	 edx, edx
  0003e	f7 f1		 div	 ecx
  00040	57		 push	 edi

; 386  :   ptr = src+offs;
; 387  :   strcpy(dst, ptr);

  00041	8b fb		 mov	 edi, ebx
  00043	8d 0c 16	 lea	 ecx, DWORD PTR [esi+edx]
  00046	2b f9		 sub	 edi, ecx
  00048	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@util_shlst:
  00050	8a 01		 mov	 al, BYTE PTR [ecx]
  00052	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00055	88 44 0f ff	 mov	 BYTE PTR [edi+ecx-1], al
  00059	84 c0		 test	 al, al
  0005b	75 f3		 jne	 SHORT $LL5@util_shlst

; 388  :   strncat(dst, src, offs);

  0005d	52		 push	 edx
  0005e	56		 push	 esi
  0005f	53		 push	 ebx
  00060	e8 00 00 00 00	 call	 _strncat
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH

; 389  :   dst[strlen(src)]='\0';

  00068	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  0006b	5f		 pop	 edi
  0006c	0f 1f 40 00	 npad	 4
$LL11@util_shlst:
  00070	8a 06		 mov	 al, BYTE PTR [esi]
  00072	46		 inc	 esi
  00073	84 c0		 test	 al, al
  00075	75 f9		 jne	 SHORT $LL11@util_shlst
  00077	2b f1		 sub	 esi, ecx
  00079	88 04 1e	 mov	 BYTE PTR [esi+ebx], al
$LN12@util_shlst:
  0007c	5e		 pop	 esi
$LN3@util_shlst:
  0007d	5b		 pop	 ebx

; 390  : }

  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
?util_shlstring@@YAXPAD0H@Z ENDP			; util_shlstring
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?util_shrstring@@YAXPAD0H@Z
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_offs$ = 16						; size = 4
?util_shrstring@@YAXPAD0H@Z PROC			; util_shrstring, COMDAT

; 365  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 366  :   char *ptr;
; 367  :   int len = strlen(src);
; 368  :   if (!dst || !src || (strlen(src)<1)) return;

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _dst$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	0f 84 7e 00 00
	00		 je	 $LN3@util_shrst
  0000f	56		 push	 esi
  00010	8b 75 0c	 mov	 esi, DWORD PTR _src$[ebp]
  00013	85 f6		 test	 esi, esi
  00015	74 75		 je	 SHORT $LN13@util_shrst
  00017	8b ce		 mov	 ecx, esi
  00019	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0001c	0f 1f 40 00	 npad	 4
$LL9@util_shrst:
  00020	8a 01		 mov	 al, BYTE PTR [ecx]
  00022	41		 inc	 ecx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL9@util_shrst
  00027	2b ca		 sub	 ecx, edx
  00029	83 f9 01	 cmp	 ecx, 1
  0002c	72 5e		 jb	 SHORT $LN13@util_shrst

; 369  :   
; 370  :   offs = strlen(src) - (offs % strlen(src));

  0002e	57		 push	 edi
  0002f	8b fe		 mov	 edi, esi
  00031	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
$LL10@util_shrst:
  00034	8a 07		 mov	 al, BYTE PTR [edi]
  00036	47		 inc	 edi
  00037	84 c0		 test	 al, al
  00039	75 f9		 jne	 SHORT $LL10@util_shrst
  0003b	2b f9		 sub	 edi, ecx
  0003d	8b ce		 mov	 ecx, esi
  0003f	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL11@util_shrst:
  00042	8a 01		 mov	 al, BYTE PTR [ecx]
  00044	41		 inc	 ecx
  00045	84 c0		 test	 al, al
  00047	75 f9		 jne	 SHORT $LL11@util_shrst
  00049	8b 45 10	 mov	 eax, DWORD PTR _offs$[ebp]
  0004c	2b ca		 sub	 ecx, edx
  0004e	33 d2		 xor	 edx, edx
  00050	f7 f1		 div	 ecx
  00052	2b fa		 sub	 edi, edx

; 371  :   ptr = src+offs;
; 372  :   strcpy(dst, ptr);

  00054	8b d3		 mov	 edx, ebx
  00056	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]
  00059	2b d1		 sub	 edx, ecx
  0005b	0f 1f 44 00 00	 npad	 5
$LL5@util_shrst:
  00060	8a 01		 mov	 al, BYTE PTR [ecx]
  00062	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00065	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  00069	84 c0		 test	 al, al
  0006b	75 f3		 jne	 SHORT $LL5@util_shrst

; 373  :   strncat(dst, src, offs);

  0006d	57		 push	 edi
  0006e	56		 push	 esi
  0006f	53		 push	 ebx
  00070	e8 00 00 00 00	 call	 _strncat
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 374  :   dst[strlen(src)]='\0';

  00078	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  0007b	5f		 pop	 edi
  0007c	0f 1f 40 00	 npad	 4
$LL12@util_shrst:
  00080	8a 06		 mov	 al, BYTE PTR [esi]
  00082	46		 inc	 esi
  00083	84 c0		 test	 al, al
  00085	75 f9		 jne	 SHORT $LL12@util_shrst
  00087	2b f1		 sub	 esi, ecx
  00089	88 04 1e	 mov	 BYTE PTR [esi+ebx], al
$LN13@util_shrst:
  0008c	5e		 pop	 esi
$LN3@util_shrst:
  0008d	5b		 pop	 ebx

; 375  : }

  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
?util_shrstring@@YAXPAD0H@Z ENDP			; util_shrstring
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?util_xorstring@@YAXPAD0@Z
_TEXT	SEGMENT
tv67 = -4						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
?util_xorstring@@YAXPAD0@Z PROC				; util_xorstring, COMDAT

; 356  : void util_xorstring(char *dst, char *src){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 357  :   unsigned int i;
; 358  :   
; 359  :   for (i=0; i<strlen(src); i++) dst[i]=src[i]^255;

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR _src$[ebp]
  00008	33 d2		 xor	 edx, edx
  0000a	8b cb		 mov	 ecx, ebx
  0000c	56		 push	 esi
  0000d	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL10@util_xorst:
  00010	8a 01		 mov	 al, BYTE PTR [ecx]
  00012	41		 inc	 ecx
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL10@util_xorst
  00017	2b ce		 sub	 ecx, esi
  00019	74 36		 je	 SHORT $LN12@util_xorst
  0001b	8b 75 08	 mov	 esi, DWORD PTR _dst$[ebp]
  0001e	57		 push	 edi
  0001f	8b fb		 mov	 edi, ebx
  00021	2b fe		 sub	 edi, esi
$LL4@util_xorst:
  00023	8a 04 37	 mov	 al, BYTE PTR [edi+esi]
  00026	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  00029	f6 d0		 not	 al
  0002b	42		 inc	 edx
  0002c	88 46 ff	 mov	 BYTE PTR [esi-1], al
  0002f	8b c3		 mov	 eax, ebx
  00031	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]
$LL11@util_xorst:
  00034	8a 08		 mov	 cl, BYTE PTR [eax]
  00036	40		 inc	 eax
  00037	84 c9		 test	 cl, cl
  00039	75 f9		 jne	 SHORT $LL11@util_xorst
  0003b	2b c3		 sub	 eax, ebx
  0003d	8b 5d 0c	 mov	 ebx, DWORD PTR _src$[ebp]
  00040	3b d0		 cmp	 edx, eax
  00042	72 df		 jb	 SHORT $LL4@util_xorst

; 360  :   dst[i]='\0';

  00044	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi

; 361  : }

  00049	5b		 pop	 ebx
  0004a	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
$LN12@util_xorst:

; 360  :   dst[i]='\0';

  00051	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00054	5e		 pop	 esi

; 361  : }

  00055	5b		 pop	 ebx
  00056	88 14 02	 mov	 BYTE PTR [edx+eax], dl
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
?util_xorstring@@YAXPAD0@Z ENDP				; util_xorstring
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?util_swapint@@YAXPAH0PAD@Z
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_rule$ = 16						; size = 4
?util_swapint@@YAXPAH0PAD@Z PROC			; util_swapint, COMDAT

; 346  : void util_swapint(int *dst, int *src, char *rule){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 347  :   char *ptr, *qtr;
; 348  :   int i;
; 349  : 
; 350  :   ptr = (char *) src;
; 351  :   qtr = (char *) dst;
; 352  :   for (i=0; i<4; i++) qtr[rule[i]-'1']=ptr[i];

  00003	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR _src$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 10	 mov	 edi, DWORD PTR _rule$[ebp]
  0000e	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00011	0f be 0f	 movsx	 ecx, BYTE PTR [edi]
  00014	88 44 11 cf	 mov	 BYTE PTR [ecx+edx-49], al
  00018	0f be 4f 01	 movsx	 ecx, BYTE PTR [edi+1]
  0001c	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  00020	88 44 11 cf	 mov	 BYTE PTR [ecx+edx-49], al
  00024	0f be 4f 02	 movsx	 ecx, BYTE PTR [edi+2]
  00028	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  0002c	88 44 11 cf	 mov	 BYTE PTR [ecx+edx-49], al
  00030	0f be 4f 03	 movsx	 ecx, BYTE PTR [edi+3]
  00034	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	88 44 11 cf	 mov	 BYTE PTR [ecx+edx-49], al

; 353  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?util_swapint@@YAXPAH0PAD@Z ENDP			; util_swapint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?util_shr_64to256@@YAHPAD000@Z
_TEXT	SEGMENT
tv82 = -24						; size = 4
tv75 = -24						; size = 4
_i$1$ = -20						; size = 4
_dwcounter$1$ = -16					; size = 4
_j$3$ = -12						; size = 4
_ptr$1$ = -8						; size = 4
_dw$1$ = -4						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_table$ = 16						; size = 4
_key$ = 20						; size = 4
?util_shr_64to256@@YAHPAD000@Z PROC			; util_shr_64to256, COMDAT

; 309  : int util_shr_64to256(char *dst, char *src, char *table, char *key){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 310  :   unsigned int dw,dwcounter,i,j,k;
; 311  :   char *ptr = NULL;
; 312  : 
; 313  :   if (!key || (strlen(key)<1)) return 0;	// must have key

  00006	8b 45 14	 mov	 eax, DWORD PTR _key$[ebp]
  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _ptr$1$[ebp], 0
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	8b 7d 10	 mov	 edi, DWORD PTR _table$[ebp]
  00016	85 c0		 test	 eax, eax
  00018	0f 84 43 01 00
	00		 je	 $LN9@util_shr_6
  0001e	8b c8		 mov	 ecx, eax
  00020	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL30@util_shr_6:
  00023	8a 01		 mov	 al, BYTE PTR [ecx]
  00025	41		 inc	 ecx
  00026	84 c0		 test	 al, al
  00028	75 f9		 jne	 SHORT $LL30@util_shr_6
  0002a	2b ca		 sub	 ecx, edx
  0002c	83 f9 01	 cmp	 ecx, 1
  0002f	0f 82 2c 01 00
	00		 jb	 $LN9@util_shr_6

; 314  : 
; 315  :   dw=0;

  00035	33 c0		 xor	 eax, eax

; 316  :   dwcounter=0;

  00037	33 f6		 xor	 esi, esi
  00039	89 45 fc	 mov	 DWORD PTR _dw$1$[ebp], eax
  0003c	89 75 f0	 mov	 DWORD PTR _dwcounter$1$[ebp], esi

; 317  :   j=0;

  0003f	89 45 f4	 mov	 DWORD PTR _j$3$[ebp], eax

; 318  :   if (!dst || !src || !table) return 0;

  00042	39 45 08	 cmp	 DWORD PTR _dst$[ebp], eax
  00045	0f 84 16 01 00
	00		 je	 $LN9@util_shr_6
  0004b	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0004e	85 c0		 test	 eax, eax
  00050	0f 84 0b 01 00
	00		 je	 $LN9@util_shr_6
  00056	85 ff		 test	 edi, edi
  00058	0f 84 03 01 00
	00		 je	 $LN9@util_shr_6

; 319  :   char c;
; 320  :   for (i=0; i<strlen(src); i++) {

  0005e	8b c8		 mov	 ecx, eax
  00060	33 db		 xor	 ebx, ebx
  00062	89 5d ec	 mov	 DWORD PTR _i$1$[ebp], ebx
  00065	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL31@util_shr_6:
  00068	8a 01		 mov	 al, BYTE PTR [ecx]
  0006a	41		 inc	 ecx
  0006b	84 c0		 test	 al, al
  0006d	75 f9		 jne	 SHORT $LL31@util_shr_6
  0006f	2b ca		 sub	 ecx, edx
  00071	0f 84 da 00 00
	00		 je	 $LN18@util_shr_6
$LL4@util_shr_6:

; 321  : 	  c = src[i];

  00077	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]

; 322  : 	  for( k = 0; k < strlen(table); k++){

  0007a	8b cf		 mov	 ecx, edi
  0007c	33 d2		 xor	 edx, edx
  0007e	8a 1c 03	 mov	 bl, BYTE PTR [ebx+eax]
  00081	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL32@util_shr_6:
  00084	8a 01		 mov	 al, BYTE PTR [ecx]
  00086	41		 inc	 ecx
  00087	84 c0		 test	 al, al
  00089	75 f9		 jne	 SHORT $LL32@util_shr_6
  0008b	2b ce		 sub	 ecx, esi
  0008d	74 1e		 je	 SHORT $LN35@util_shr_6
  0008f	90		 npad	 1
$LL7@util_shr_6:

; 323  : 		  if( table[k] == c){

  00090	38 1c 3a	 cmp	 BYTE PTR [edx+edi], bl
  00093	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  00096	74 71		 je	 SHORT $LN22@util_shr_6

; 322  : 	  for( k = 0; k < strlen(table); k++){

  00098	8b c7		 mov	 eax, edi
  0009a	42		 inc	 edx
  0009b	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0009e	66 90		 npad	 2
$LL33@util_shr_6:
  000a0	8a 08		 mov	 cl, BYTE PTR [eax]
  000a2	40		 inc	 eax
  000a3	84 c9		 test	 cl, cl
  000a5	75 f9		 jne	 SHORT $LL33@util_shr_6
  000a7	2b c6		 sub	 eax, esi
  000a9	3b d0		 cmp	 edx, eax
  000ab	72 e3		 jb	 SHORT $LL7@util_shr_6
$LN35@util_shr_6:

; 325  : 			  break;
; 326  : 		  }
; 327  : 	  }
; 328  :     if (!ptr) return 0;

  000ad	8b 4d f8	 mov	 ecx, DWORD PTR _ptr$1$[ebp]
$LN6@util_shr_6:
  000b0	85 c9		 test	 ecx, ecx
  000b2	0f 84 a9 00 00
	00		 je	 $LN9@util_shr_6

; 329  :     if (i%4) {

  000b8	8b 45 f4	 mov	 eax, DWORD PTR _j$3$[ebp]
  000bb	8b 5d 14	 mov	 ebx, DWORD PTR _key$[ebp]
  000be	8b 55 ec	 mov	 edx, DWORD PTR _i$1$[ebp]
  000c1	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  000c4	0f be 04 18	 movsx	 eax, BYTE PTR [eax+ebx]
  000c8	2b c7		 sub	 eax, edi
  000ca	03 c1		 add	 eax, ecx
  000cc	83 e0 3f	 and	 eax, 63			; 0000003fH
  000cf	83 e2 03	 and	 edx, 3
  000d2	74 3c		 je	 SHORT $LN14@util_shr_6

; 330  :       dw = ((((unsigned int)(ptr-table) & 0x3f) + key[j]) % 64)

  000d4	b9 04 00 00 00	 mov	 ecx, 4
  000d9	2b ca		 sub	 ecx, edx

; 331  :            << ((4-(i%4))<<1) | dw;
; 332  :       j++;  if (!key[j]) j=0;

  000db	8b d3		 mov	 edx, ebx
  000dd	03 c9		 add	 ecx, ecx
  000df	d3 e0		 shl	 eax, cl
  000e1	8b 4d fc	 mov	 ecx, DWORD PTR _dw$1$[ebp]
  000e4	0b c8		 or	 ecx, eax
  000e6	8b c6		 mov	 eax, esi
  000e8	33 f6		 xor	 esi, esi
  000ea	80 3c 10 00	 cmp	 BYTE PTR [eax+edx], 0
  000ee	0f 44 c6	 cmove	 eax, esi

; 333  :       dst[ dwcounter++ ] = dw & 0xff;

  000f1	8b 75 f0	 mov	 esi, DWORD PTR _dwcounter$1$[ebp]
  000f4	89 45 f4	 mov	 DWORD PTR _j$3$[ebp], eax
  000f7	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  000fa	88 0c 06	 mov	 BYTE PTR [esi+eax], cl
  000fd	46		 inc	 esi

; 334  :       dw = dw >> 8;

  000fe	c1 e9 08	 shr	 ecx, 8
  00101	89 75 f0	 mov	 DWORD PTR _dwcounter$1$[ebp], esi
  00104	89 4d fc	 mov	 DWORD PTR _dw$1$[ebp], ecx

; 335  :     } else {

  00107	eb 1c		 jmp	 SHORT $LN2@util_shr_6
$LN22@util_shr_6:

; 324  : 			  ptr = table+k;

  00109	8b c8		 mov	 ecx, eax
  0010b	89 4d f8	 mov	 DWORD PTR _ptr$1$[ebp], ecx
  0010e	eb a0		 jmp	 SHORT $LN6@util_shr_6
$LN14@util_shr_6:

; 336  :       dw = (((unsigned int)(ptr-table) & 0x3f) + key[j]) % 64;

  00110	89 45 fc	 mov	 DWORD PTR _dw$1$[ebp], eax

; 337  :       j++;  if (!key[j]) j=0;

  00113	8b cb		 mov	 ecx, ebx
  00115	8b c6		 mov	 eax, esi
  00117	33 d2		 xor	 edx, edx
  00119	8b 75 f0	 mov	 esi, DWORD PTR _dwcounter$1$[ebp]
  0011c	38 14 08	 cmp	 BYTE PTR [eax+ecx], dl
  0011f	0f 44 c2	 cmove	 eax, edx
  00122	89 45 f4	 mov	 DWORD PTR _j$3$[ebp], eax
$LN2@util_shr_6:

; 319  :   char c;
; 320  :   for (i=0; i<strlen(src); i++) {

  00125	8b 5d ec	 mov	 ebx, DWORD PTR _i$1$[ebp]
  00128	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  0012b	43		 inc	 ebx
  0012c	89 5d ec	 mov	 DWORD PTR _i$1$[ebp], ebx
  0012f	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL34@util_shr_6:
  00132	8a 01		 mov	 al, BYTE PTR [ecx]
  00134	41		 inc	 ecx
  00135	84 c0		 test	 al, al
  00137	75 f9		 jne	 SHORT $LL34@util_shr_6
  00139	2b ca		 sub	 ecx, edx
  0013b	3b d9		 cmp	 ebx, ecx
  0013d	0f 82 34 ff ff
	ff		 jb	 $LL4@util_shr_6

; 338  :     }
; 339  :   }
; 340  :   if (dw) dst[ dwcounter++ ] = dw & 0xff;

  00143	8b 45 fc	 mov	 eax, DWORD PTR _dw$1$[ebp]
  00146	85 c0		 test	 eax, eax
  00148	74 07		 je	 SHORT $LN18@util_shr_6
  0014a	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0014d	88 04 0e	 mov	 BYTE PTR [esi+ecx], al
  00150	46		 inc	 esi
$LN18@util_shr_6:

; 341  :   dst[ dwcounter ] = '\0';

  00151	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00154	5f		 pop	 edi
  00155	c6 04 06 00	 mov	 BYTE PTR [esi+eax], 0

; 342  :   return dwcounter;

  00159	8b c6		 mov	 eax, esi

; 343  : }

  0015b	5e		 pop	 esi
  0015c	5b		 pop	 ebx
  0015d	8b e5		 mov	 esp, ebp
  0015f	5d		 pop	 ebp
  00160	c3		 ret	 0
$LN9@util_shr_6:
  00161	5f		 pop	 edi
  00162	5e		 pop	 esi
  00163	33 c0		 xor	 eax, eax
  00165	5b		 pop	 ebx
  00166	8b e5		 mov	 esp, ebp
  00168	5d		 pop	 ebp
  00169	c3		 ret	 0
?util_shr_64to256@@YAHPAD000@Z ENDP			; util_shr_64to256
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?util_256to64_shl@@YAHPAD0H00@Z
_TEXT	SEGMENT
_i$1$ = -4						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_len$ = 16						; size = 4
_table$ = 20						; size = 4
_key$ = 24						; size = 4
?util_256to64_shl@@YAHPAD0H00@Z PROC			; util_256to64_shl, COMDAT

; 283  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 284  :   unsigned int dw,dwcounter;
; 285  :   int i, j;
; 286  : 
; 287  :   if (!dst || !src || !table || !key) return 0;

  00004	83 7d 08 00	 cmp	 DWORD PTR _dst$[ebp], 0
  00008	0f 84 f9 00 00
	00		 je	 $LN6@util_256to
  0000e	83 7d 0c 00	 cmp	 DWORD PTR _src$[ebp], 0
  00012	0f 84 ef 00 00
	00		 je	 $LN6@util_256to
  00018	83 7d 14 00	 cmp	 DWORD PTR _table$[ebp], 0
  0001c	0f 84 e5 00 00
	00		 je	 $LN6@util_256to
  00022	8b 45 18	 mov	 eax, DWORD PTR _key$[ebp]
  00025	85 c0		 test	 eax, eax
  00027	0f 84 da 00 00
	00		 je	 $LN6@util_256to

; 288  :   if (strlen(key)<1) return 0;	// key can't be empty.

  0002d	8b c8		 mov	 ecx, eax
  0002f	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL17@util_256to:
  00032	8a 01		 mov	 al, BYTE PTR [ecx]
  00034	41		 inc	 ecx
  00035	84 c0		 test	 al, al
  00037	75 f9		 jne	 SHORT $LL17@util_256to
  00039	2b ca		 sub	 ecx, edx
  0003b	83 f9 01	 cmp	 ecx, 1
  0003e	0f 82 c3 00 00
	00		 jb	 $LN6@util_256to

; 289  :   dw=0;

  00044	53		 push	 ebx
  00045	56		 push	 esi
  00046	33 c9		 xor	 ecx, ecx

; 290  :   dwcounter=0;

  00048	33 db		 xor	 ebx, ebx
  0004a	57		 push	 edi
  0004b	33 ff		 xor	 edi, edi
  0004d	89 4d fc	 mov	 DWORD PTR _i$1$[ebp], ecx

; 291  :   j=0;

  00050	33 f6		 xor	 esi, esi

; 292  :   for (i=0; i<len; i++) {

  00052	39 4d 10	 cmp	 DWORD PTR _len$[ebp], ecx
  00055	0f 8e 9c 00 00
	00		 jle	 $LN11@util_256to
  0005b	0f 1f 44 00 00	 npad	 5
$LL4@util_256to:

; 293  :     dw = ( ((unsigned int)src[i] & 0xff) << ((i%3)<<1) ) | dw;

  00060	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00065	f7 e1		 mul	 ecx
  00067	d1 ea		 shr	 edx, 1
  00069	8d 04 52	 lea	 eax, DWORD PTR [edx+edx*2]
  0006c	8b d1		 mov	 edx, ecx
  0006e	2b d0		 sub	 edx, eax
  00070	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00073	0f be 04 01	 movsx	 eax, BYTE PTR [ecx+eax]
  00077	8d 0c 12	 lea	 ecx, DWORD PTR [edx+edx]
  0007a	0f b6 c0	 movzx	 eax, al
  0007d	d3 e0		 shl	 eax, cl
  0007f	0b f8		 or	 edi, eax

; 294  :     dst[ dwcounter++ ] = table[ ((dw & 0x3f) + 64 - key[j]) % 64 ];	// check!

  00081	8b 45 18	 mov	 eax, DWORD PTR _key$[ebp]
  00084	8b cf		 mov	 ecx, edi
  00086	0f be 04 06	 movsx	 eax, BYTE PTR [esi+eax]

; 295  :     j++;  if (!key[j]) j=0;

  0008a	46		 inc	 esi
  0008b	2b c8		 sub	 ecx, eax
  0008d	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  00090	83 e1 3f	 and	 ecx, 63			; 0000003fH
  00093	8a 04 01	 mov	 al, BYTE PTR [ecx+eax]
  00096	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00099	88 04 0b	 mov	 BYTE PTR [ebx+ecx], al
  0009c	33 c0		 xor	 eax, eax
  0009e	8b 4d 18	 mov	 ecx, DWORD PTR _key$[ebp]
  000a1	43		 inc	 ebx
  000a2	38 04 0e	 cmp	 BYTE PTR [esi+ecx], al
  000a5	0f 44 f0	 cmove	 esi, eax

; 296  :     dw = ( dw >> 6 );

  000a8	c1 ef 06	 shr	 edi, 6

; 297  :     if (i%3==2) {

  000ab	83 fa 02	 cmp	 edx, 2
  000ae	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  000b1	75 1e		 jne	 SHORT $LN2@util_256to

; 298  :       dst[ dwcounter++ ] = table[ ((dw & 0x3f) + 64 - key[j]) % 64 ];	// check!

  000b3	0f be 04 0e	 movsx	 eax, BYTE PTR [esi+ecx]

; 299  :       j++;  if (!key[j]) j=0;

  000b7	46		 inc	 esi
  000b8	2b f8		 sub	 edi, eax
  000ba	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  000bd	83 e7 3f	 and	 edi, 63			; 0000003fH
  000c0	8a 04 07	 mov	 al, BYTE PTR [edi+eax]
  000c3	88 04 13	 mov	 BYTE PTR [ebx+edx], al
  000c6	33 c0		 xor	 eax, eax
  000c8	43		 inc	 ebx
  000c9	38 04 0e	 cmp	 BYTE PTR [esi+ecx], al
  000cc	0f 44 f0	 cmove	 esi, eax

; 300  :       dw = 0;

  000cf	33 ff		 xor	 edi, edi
$LN2@util_256to:

; 292  :   for (i=0; i<len; i++) {

  000d1	8b 4d fc	 mov	 ecx, DWORD PTR _i$1$[ebp]
  000d4	41		 inc	 ecx
  000d5	89 4d fc	 mov	 DWORD PTR _i$1$[ebp], ecx
  000d8	3b 4d 10	 cmp	 ecx, DWORD PTR _len$[ebp]
  000db	7c 83		 jl	 SHORT $LL4@util_256to

; 301  :     }
; 302  :   }
; 303  :   if (dw) dst[ dwcounter++ ] = table[ (dw + 64 - key[j]) % 64 ];	// check!

  000dd	85 ff		 test	 edi, edi
  000df	74 16		 je	 SHORT $LN11@util_256to
  000e1	8b 45 18	 mov	 eax, DWORD PTR _key$[ebp]
  000e4	0f be 0c 06	 movsx	 ecx, BYTE PTR [esi+eax]
  000e8	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  000eb	2b f9		 sub	 edi, ecx
  000ed	83 e7 3f	 and	 edi, 63			; 0000003fH
  000f0	8a 0c 07	 mov	 cl, BYTE PTR [edi+eax]
  000f3	88 0c 13	 mov	 BYTE PTR [ebx+edx], cl
  000f6	43		 inc	 ebx
$LN11@util_256to:

; 304  :   dst[ dwcounter ] = '\0';

  000f7	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]

; 305  :   return dwcounter;

  000fa	8b c3		 mov	 eax, ebx
  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	c6 04 0b 00	 mov	 BYTE PTR [ebx+ecx], 0
  00102	5b		 pop	 ebx

; 306  : }

  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c3		 ret	 0
$LN6@util_256to:

; 284  :   unsigned int dw,dwcounter;
; 285  :   int i, j;
; 286  : 
; 287  :   if (!dst || !src || !table || !key) return 0;

  00107	33 c0		 xor	 eax, eax

; 306  : }

  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c3		 ret	 0
?util_256to64_shl@@YAHPAD0H00@Z ENDP			; util_256to64_shl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?util_shl_64to256@@YAHPAD000@Z
_TEXT	SEGMENT
tv82 = -28						; size = 4
tv75 = -28						; size = 4
_i$1$ = -24						; size = 4
_j$3$ = -20						; size = 4
_ptr$1$ = -16						; size = 4
_dwcounter$1$ = -12					; size = 4
_dw$1$ = -8						; size = 4
_c$1$ = -1						; size = 1
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_table$ = 16						; size = 4
_key$ = 20						; size = 4
?util_shl_64to256@@YAHPAD000@Z PROC			; util_shl_64to256, COMDAT

; 243  : int util_shl_64to256(char *dst, char *src, char *table, char *key){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 244  :   unsigned int dw,dwcounter,i,j,k;
; 245  :   char *ptr = NULL;
; 246  : 
; 247  :   if (!key || (strlen(key)<1)) return 0;	// must have key

  00006	8b 45 14	 mov	 eax, DWORD PTR _key$[ebp]
  00009	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _ptr$1$[ebp], 0
  00010	53		 push	 ebx
  00011	8b 5d 10	 mov	 ebx, DWORD PTR _table$[ebp]
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	85 c0		 test	 eax, eax
  00018	0f 84 55 01 00
	00		 je	 $LN9@util_shl_6
  0001e	8b c8		 mov	 ecx, eax
  00020	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL30@util_shl_6:
  00023	8a 01		 mov	 al, BYTE PTR [ecx]
  00025	41		 inc	 ecx
  00026	84 c0		 test	 al, al
  00028	75 f9		 jne	 SHORT $LL30@util_shl_6
  0002a	2b ca		 sub	 ecx, edx
  0002c	83 f9 01	 cmp	 ecx, 1
  0002f	0f 82 3e 01 00
	00		 jb	 $LN9@util_shl_6

; 248  : 
; 249  :   dw=0;

  00035	33 c0		 xor	 eax, eax

; 250  :   dwcounter=0;
; 251  :   j=0;

  00037	33 ff		 xor	 edi, edi
  00039	89 45 f8	 mov	 DWORD PTR _dw$1$[ebp], eax
  0003c	89 45 f4	 mov	 DWORD PTR _dwcounter$1$[ebp], eax
  0003f	89 7d ec	 mov	 DWORD PTR _j$3$[ebp], edi

; 252  :   if (!dst || !src || !table) return 0;

  00042	39 45 08	 cmp	 DWORD PTR _dst$[ebp], eax
  00045	0f 84 28 01 00
	00		 je	 $LN9@util_shl_6
  0004b	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0004e	85 c0		 test	 eax, eax
  00050	0f 84 1d 01 00
	00		 je	 $LN9@util_shl_6
  00056	85 db		 test	 ebx, ebx
  00058	0f 84 15 01 00
	00		 je	 $LN9@util_shl_6

; 253  :   char c;
; 254  :   for (i=0; i<strlen(src); i++) {

  0005e	8b c8		 mov	 ecx, eax
  00060	33 f6		 xor	 esi, esi
  00062	89 75 e8	 mov	 DWORD PTR _i$1$[ebp], esi
  00065	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL31@util_shl_6:
  00068	8a 01		 mov	 al, BYTE PTR [ecx]
  0006a	41		 inc	 ecx
  0006b	84 c0		 test	 al, al
  0006d	75 f9		 jne	 SHORT $LL31@util_shl_6
  0006f	2b ca		 sub	 ecx, edx
  00071	0f 84 ea 00 00
	00		 je	 $LN35@util_shl_6
$LL4@util_shl_6:

; 255  : 	  c = src[i];

  00077	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]

; 256  : 	  for( k = 0; k < strlen(table); k++){

  0007a	8b cb		 mov	 ecx, ebx
  0007c	33 d2		 xor	 edx, edx
  0007e	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  00081	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  00084	88 45 ff	 mov	 BYTE PTR _c$1$[ebp], al
$LL32@util_shl_6:
  00087	8a 01		 mov	 al, BYTE PTR [ecx]
  00089	41		 inc	 ecx
  0008a	84 c0		 test	 al, al
  0008c	75 f9		 jne	 SHORT $LL32@util_shl_6
  0008e	2b ce		 sub	 ecx, esi
  00090	74 1e		 je	 SHORT $LN37@util_shl_6
  00092	8a 6d ff	 mov	 ch, BYTE PTR _c$1$[ebp]
$LL7@util_shl_6:

; 257  : 		  if( table[k] == c){

  00095	38 2c 1a	 cmp	 BYTE PTR [edx+ebx], ch
  00098	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  0009b	74 6a		 je	 SHORT $LN22@util_shl_6

; 256  : 	  for( k = 0; k < strlen(table); k++){

  0009d	8b c3		 mov	 eax, ebx
  0009f	42		 inc	 edx
  000a0	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$LL33@util_shl_6:
  000a3	8a 08		 mov	 cl, BYTE PTR [eax]
  000a5	40		 inc	 eax
  000a6	84 c9		 test	 cl, cl
  000a8	75 f9		 jne	 SHORT $LL33@util_shl_6
  000aa	2b c6		 sub	 eax, esi
  000ac	3b d0		 cmp	 edx, eax
  000ae	72 e5		 jb	 SHORT $LL7@util_shl_6
$LN37@util_shl_6:

; 259  : 			  break;
; 260  : 		  }
; 261  : 	  }
; 262  :     if (!ptr) return 0;

  000b0	8b 4d f0	 mov	 ecx, DWORD PTR _ptr$1$[ebp]
$LN6@util_shl_6:
  000b3	85 c9		 test	 ecx, ecx
  000b5	0f 84 b8 00 00
	00		 je	 $LN9@util_shl_6

; 263  :     if (i%4) {

  000bb	8b 55 14	 mov	 edx, DWORD PTR _key$[ebp]
  000be	47		 inc	 edi
  000bf	8b 45 ec	 mov	 eax, DWORD PTR _j$3$[ebp]
  000c2	8b 75 e8	 mov	 esi, DWORD PTR _i$1$[ebp]
  000c5	0f be 04 10	 movsx	 eax, BYTE PTR [eax+edx]
  000c9	8b d1		 mov	 edx, ecx
  000cb	2b d0		 sub	 edx, eax
  000cd	2b d3		 sub	 edx, ebx
  000cf	83 e2 3f	 and	 edx, 63			; 0000003fH
  000d2	83 e6 03	 and	 esi, 3
  000d5	74 37		 je	 SHORT $LN14@util_shl_6

; 264  :       // check!
; 265  :       dw = ((((unsigned int)(ptr-table) & 0x3f) + 64 - key[j]) % 64)

  000d7	8b 45 f8	 mov	 eax, DWORD PTR _dw$1$[ebp]
  000da	b9 04 00 00 00	 mov	 ecx, 4
  000df	2b ce		 sub	 ecx, esi
  000e1	03 c9		 add	 ecx, ecx
  000e3	d3 e2		 shl	 edx, cl

; 266  :            << ((4-(i%4))<<1) | dw;
; 267  :       j++;  if (!key[j]) j=0;

  000e5	8b 4d 14	 mov	 ecx, DWORD PTR _key$[ebp]
  000e8	0b c2		 or	 eax, edx
  000ea	33 d2		 xor	 edx, edx
  000ec	38 14 0f	 cmp	 BYTE PTR [edi+ecx], dl

; 268  :       dst[ dwcounter++ ] = dw & 0xff;

  000ef	8b 4d f4	 mov	 ecx, DWORD PTR _dwcounter$1$[ebp]
  000f2	0f 44 fa	 cmove	 edi, edx
  000f5	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  000f8	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  000fb	41		 inc	 ecx

; 269  :       dw = dw >> 8;

  000fc	c1 e8 08	 shr	 eax, 8
  000ff	89 4d f4	 mov	 DWORD PTR _dwcounter$1$[ebp], ecx
  00102	89 45 f8	 mov	 DWORD PTR _dw$1$[ebp], eax

; 270  :     } else {

  00105	eb 15		 jmp	 SHORT $LN38@util_shl_6
$LN22@util_shl_6:

; 258  : 			  ptr = table+k;

  00107	8b c8		 mov	 ecx, eax
  00109	89 4d f0	 mov	 DWORD PTR _ptr$1$[ebp], ecx
  0010c	eb a5		 jmp	 SHORT $LN6@util_shl_6
$LN14@util_shl_6:

; 271  :       // check!
; 272  :       dw = (((unsigned int)(ptr-table) & 0x3f) + 64 - key[j]) % 64;
; 273  :       j++;  if (!key[j]) j=0;

  0010e	8b 45 14	 mov	 eax, DWORD PTR _key$[ebp]
  00111	33 c9		 xor	 ecx, ecx
  00113	89 55 f8	 mov	 DWORD PTR _dw$1$[ebp], edx
  00116	38 0c 07	 cmp	 BYTE PTR [edi+eax], cl
  00119	0f 44 f9	 cmove	 edi, ecx
$LN38@util_shl_6:

; 253  :   char c;
; 254  :   for (i=0; i<strlen(src); i++) {

  0011c	8b 75 e8	 mov	 esi, DWORD PTR _i$1$[ebp]
  0011f	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00122	46		 inc	 esi
  00123	89 7d ec	 mov	 DWORD PTR _j$3$[ebp], edi
  00126	89 75 e8	 mov	 DWORD PTR _i$1$[ebp], esi
  00129	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0012c	0f 1f 40 00	 npad	 4
$LL34@util_shl_6:
  00130	8a 01		 mov	 al, BYTE PTR [ecx]
  00132	41		 inc	 ecx
  00133	84 c0		 test	 al, al
  00135	75 f9		 jne	 SHORT $LL34@util_shl_6
  00137	2b ca		 sub	 ecx, edx
  00139	3b f1		 cmp	 esi, ecx
  0013b	0f 82 36 ff ff
	ff		 jb	 $LL4@util_shl_6

; 274  :     }
; 275  :   }
; 276  :   if (dw) dst[ dwcounter++ ] = dw & 0xff;

  00141	8b 45 f8	 mov	 eax, DWORD PTR _dw$1$[ebp]
  00144	8b 4d f4	 mov	 ecx, DWORD PTR _dwcounter$1$[ebp]
  00147	85 c0		 test	 eax, eax
  00149	74 18		 je	 SHORT $LN18@util_shl_6
  0014b	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  0014e	5f		 pop	 edi

; 278  :   return dwcounter;
; 279  : }

  0014f	5e		 pop	 esi
  00150	5b		 pop	 ebx
  00151	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  00154	41		 inc	 ecx
  00155	8b c2		 mov	 eax, edx
  00157	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0
  0015b	8b c1		 mov	 eax, ecx
  0015d	8b e5		 mov	 esp, ebp
  0015f	5d		 pop	 ebp
  00160	c3		 ret	 0
$LN35@util_shl_6:

; 253  :   char c;
; 254  :   for (i=0; i<strlen(src); i++) {

  00161	33 c9		 xor	 ecx, ecx
$LN18@util_shl_6:

; 277  :   dst[ dwcounter ] = '\0';

  00163	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00166	5f		 pop	 edi

; 278  :   return dwcounter;
; 279  : }

  00167	5e		 pop	 esi
  00168	5b		 pop	 ebx
  00169	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0
  0016d	8b c1		 mov	 eax, ecx
  0016f	8b e5		 mov	 esp, ebp
  00171	5d		 pop	 ebp
  00172	c3		 ret	 0
$LN9@util_shl_6:
  00173	5f		 pop	 edi
  00174	5e		 pop	 esi
  00175	33 c0		 xor	 eax, eax
  00177	5b		 pop	 ebx
  00178	8b e5		 mov	 esp, ebp
  0017a	5d		 pop	 ebp
  0017b	c3		 ret	 0
?util_shl_64to256@@YAHPAD000@Z ENDP			; util_shl_64to256
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?util_256to64_shr@@YAHPAD0H00@Z
_TEXT	SEGMENT
tv278 = -8						; size = 4
_dw$1$ = -4						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_len$ = 16						; size = 4
_table$ = 20						; size = 4
_key$ = 24						; size = 4
?util_256to64_shr@@YAHPAD0H00@Z PROC			; util_256to64_shr, COMDAT

; 217  : int util_256to64_shr(char *dst, char *src, int len, char *table, char *key){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 218  :   unsigned int dw,dwcounter,j;
; 219  :   int i;
; 220  : 
; 221  :   if (!dst || !src || !table || !key) return 0;

  00006	83 7d 08 00	 cmp	 DWORD PTR _dst$[ebp], 0
  0000a	0f 84 ff 00 00
	00		 je	 $LN6@util_256to
  00010	83 7d 0c 00	 cmp	 DWORD PTR _src$[ebp], 0
  00014	0f 84 f5 00 00
	00		 je	 $LN6@util_256to
  0001a	83 7d 14 00	 cmp	 DWORD PTR _table$[ebp], 0
  0001e	0f 84 eb 00 00
	00		 je	 $LN6@util_256to
  00024	8b 45 18	 mov	 eax, DWORD PTR _key$[ebp]
  00027	85 c0		 test	 eax, eax
  00029	0f 84 e0 00 00
	00		 je	 $LN6@util_256to

; 222  :   if (strlen(key)<1) return 0;	// key can't be empty.

  0002f	8b c8		 mov	 ecx, eax
  00031	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL17@util_256to:
  00034	8a 01		 mov	 al, BYTE PTR [ecx]
  00036	41		 inc	 ecx
  00037	84 c0		 test	 al, al
  00039	75 f9		 jne	 SHORT $LL17@util_256to
  0003b	2b ca		 sub	 ecx, edx
  0003d	83 f9 01	 cmp	 ecx, 1
  00040	0f 82 c9 00 00
	00		 jb	 $LN6@util_256to

; 223  :   dw=0;

  00046	53		 push	 ebx
  00047	56		 push	 esi
  00048	33 c0		 xor	 eax, eax

; 224  :   dwcounter=0;
; 225  :   j=0;

  0004a	33 f6		 xor	 esi, esi
  0004c	57		 push	 edi
  0004d	33 ff		 xor	 edi, edi
  0004f	89 45 fc	 mov	 DWORD PTR _dw$1$[ebp], eax
  00052	33 db		 xor	 ebx, ebx

; 226  :   for (i=0; i<len; i++) {

  00054	39 45 10	 cmp	 DWORD PTR _len$[ebp], eax
  00057	0f 8e a2 00 00
	00		 jle	 $LN11@util_256to
  0005d	0f 1f 00	 npad	 3
$LL4@util_256to:

; 227  :     dw = ( ((unsigned int)src[i] & 0xff) << ((i%3)<<1) ) | dw;

  00060	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00065	f7 e3		 mul	 ebx
  00067	d1 ea		 shr	 edx, 1
  00069	8d 04 52	 lea	 eax, DWORD PTR [edx+edx*2]
  0006c	8b d3		 mov	 edx, ebx
  0006e	2b d0		 sub	 edx, eax
  00070	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00073	89 55 f8	 mov	 DWORD PTR tv278[ebp], edx
  00076	0f be 04 03	 movsx	 eax, BYTE PTR [ebx+eax]
  0007a	8d 0c 12	 lea	 ecx, DWORD PTR [edx+edx]

; 228  :     dst[ dwcounter++ ] = table[ ((dw & 0x3f) + key[j]) % 64 ];	// check!

  0007d	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  00080	0f b6 c0	 movzx	 eax, al
  00083	d3 e0		 shl	 eax, cl
  00085	8b 4d fc	 mov	 ecx, DWORD PTR _dw$1$[ebp]
  00088	0b c8		 or	 ecx, eax
  0008a	8b 45 18	 mov	 eax, DWORD PTR _key$[ebp]
  0008d	0f be 04 06	 movsx	 eax, BYTE PTR [esi+eax]

; 229  :     j++;  if (!key[j]) j=0;

  00091	46		 inc	 esi
  00092	03 c1		 add	 eax, ecx
  00094	83 e0 3f	 and	 eax, 63			; 0000003fH
  00097	8a 04 10	 mov	 al, BYTE PTR [eax+edx]
  0009a	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  0009d	88 04 17	 mov	 BYTE PTR [edi+edx], al
  000a0	33 d2		 xor	 edx, edx
  000a2	8b 45 18	 mov	 eax, DWORD PTR _key$[ebp]
  000a5	47		 inc	 edi
  000a6	38 14 06	 cmp	 BYTE PTR [esi+eax], dl
  000a9	0f 44 f2	 cmove	 esi, edx

; 230  :     dw = ( dw >> 6 );
; 231  :     if (i%3==2) {

  000ac	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  000af	c1 e9 06	 shr	 ecx, 6
  000b2	83 7d f8 02	 cmp	 DWORD PTR tv278[ebp], 2
  000b6	89 4d fc	 mov	 DWORD PTR _dw$1$[ebp], ecx
  000b9	75 22		 jne	 SHORT $LN2@util_256to

; 232  :       dst[ dwcounter++ ] = table[ ((dw & 0x3f) + key[j]) % 64 ];// check!

  000bb	0f be 04 06	 movsx	 eax, BYTE PTR [esi+eax]

; 233  :       j++;  if (!key[j]) j=0;

  000bf	46		 inc	 esi
  000c0	03 c1		 add	 eax, ecx
  000c2	8b 4d 14	 mov	 ecx, DWORD PTR _table$[ebp]
  000c5	83 e0 3f	 and	 eax, 63			; 0000003fH
  000c8	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  000cb	33 c9		 xor	 ecx, ecx
  000cd	88 04 17	 mov	 BYTE PTR [edi+edx], al
  000d0	47		 inc	 edi
  000d1	8b 45 18	 mov	 eax, DWORD PTR _key$[ebp]

; 234  :       dw = 0;

  000d4	89 4d fc	 mov	 DWORD PTR _dw$1$[ebp], ecx
  000d7	38 0c 06	 cmp	 BYTE PTR [esi+eax], cl
  000da	0f 44 f1	 cmove	 esi, ecx
$LN2@util_256to:

; 226  :   for (i=0; i<len; i++) {

  000dd	43		 inc	 ebx
  000de	3b 5d 10	 cmp	 ebx, DWORD PTR _len$[ebp]
  000e1	0f 8c 79 ff ff
	ff		 jl	 $LL4@util_256to

; 235  :     }
; 236  :   }
; 237  :   if (dw) dst[ dwcounter++ ] = table[ (dw + key[j]) % 64 ];	// check!

  000e7	85 c9		 test	 ecx, ecx
  000e9	74 14		 je	 SHORT $LN11@util_256to
  000eb	0f be 0c 06	 movsx	 ecx, BYTE PTR [esi+eax]
  000ef	03 4d fc	 add	 ecx, DWORD PTR _dw$1$[ebp]
  000f2	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  000f5	83 e1 3f	 and	 ecx, 63			; 0000003fH
  000f8	8a 0c 01	 mov	 cl, BYTE PTR [ecx+eax]
  000fb	88 0c 17	 mov	 BYTE PTR [edi+edx], cl
  000fe	47		 inc	 edi
$LN11@util_256to:

; 238  :   dst[ dwcounter ] = '\0';

  000ff	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00102	c6 04 07 00	 mov	 BYTE PTR [edi+eax], 0

; 239  :   return dwcounter;

  00106	8b c7		 mov	 eax, edi
  00108	5f		 pop	 edi
  00109	5e		 pop	 esi
  0010a	5b		 pop	 ebx

; 240  : }

  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c3		 ret	 0
$LN6@util_256to:

; 218  :   unsigned int dw,dwcounter,j;
; 219  :   int i;
; 220  : 
; 221  :   if (!dst || !src || !table || !key) return 0;

  0010f	33 c0		 xor	 eax, eax

; 240  : }

  00111	8b e5		 mov	 esp, ebp
  00113	5d		 pop	 ebp
  00114	c3		 ret	 0
?util_256to64_shr@@YAHPAD0H00@Z ENDP			; util_256to64_shr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?util_64to256@@YAHPAD00@Z
_TEXT	SEGMENT
tv77 = -20						; size = 4
tv70 = -20						; size = 4
_dwcounter$1$ = -16					; size = 4
_dw$1$ = -12						; size = 4
_ptr$1$ = -8						; size = 4
_i$1$ = -4						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_table$ = 16						; size = 4
?util_64to256@@YAHPAD00@Z PROC				; util_64to256, COMDAT

; 185  : int util_64to256(char *dst, char *src, char *table){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 186  :   unsigned int dw,dwcounter;
; 187  :   unsigned int i, j;
; 188  :   char *ptr = NULL;
; 189  : 
; 190  :   dw=0;
; 191  :   dwcounter=0;

  00008	33 f6		 xor	 esi, esi
  0000a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _ptr$1$[ebp], 0
  00011	57		 push	 edi
  00012	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dw$1$[ebp], 0
  00019	89 75 f0	 mov	 DWORD PTR _dwcounter$1$[ebp], esi

; 192  :   if (!dst || !src || !table) return 0;

  0001c	39 75 08	 cmp	 DWORD PTR _dst$[ebp], esi
  0001f	0f 84 ed 00 00
	00		 je	 $LN9@util_64to2
  00025	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 e2 00 00
	00		 je	 $LN9@util_64to2
  00030	8b 7d 10	 mov	 edi, DWORD PTR _table$[ebp]
  00033	85 ff		 test	 edi, edi
  00035	0f 84 d7 00 00
	00		 je	 $LN9@util_64to2

; 193  :   char c;
; 194  :   for (i=0; i<strlen(src); i++) {

  0003b	8b c8		 mov	 ecx, eax
  0003d	89 75 fc	 mov	 DWORD PTR _i$1$[ebp], esi
  00040	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL26@util_64to2:
  00043	8a 01		 mov	 al, BYTE PTR [ecx]
  00045	41		 inc	 ecx
  00046	84 c0		 test	 al, al
  00048	75 f9		 jne	 SHORT $LL26@util_64to2
  0004a	2b ca		 sub	 ecx, edx
  0004c	0f 84 b0 00 00
	00		 je	 $LN31@util_64to2
  00052	33 c0		 xor	 eax, eax
$LL4@util_64to2:

; 195  : 	  c = src[i];

  00054	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]

; 196  : 	  for( j = 0; j < strlen(table); j++){

  00057	33 d2		 xor	 edx, edx
  00059	8a 1c 08	 mov	 bl, BYTE PTR [eax+ecx]
  0005c	8b cf		 mov	 ecx, edi
  0005e	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL27@util_64to2:
  00061	8a 01		 mov	 al, BYTE PTR [ecx]
  00063	41		 inc	 ecx
  00064	84 c0		 test	 al, al
  00066	75 f9		 jne	 SHORT $LL27@util_64to2
  00068	2b ce		 sub	 ecx, esi
  0006a	74 21		 je	 SHORT $LN30@util_64to2
  0006c	0f 1f 40 00	 npad	 4
$LL7@util_64to2:

; 197  : 		  if( table[j] == c){

  00070	38 1c 3a	 cmp	 BYTE PTR [edx+edi], bl
  00073	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  00076	74 4b		 je	 SHORT $LN18@util_64to2

; 196  : 	  for( j = 0; j < strlen(table); j++){

  00078	8b c7		 mov	 eax, edi
  0007a	42		 inc	 edx
  0007b	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0007e	66 90		 npad	 2
$LL28@util_64to2:
  00080	8a 08		 mov	 cl, BYTE PTR [eax]
  00082	40		 inc	 eax
  00083	84 c9		 test	 cl, cl
  00085	75 f9		 jne	 SHORT $LL28@util_64to2
  00087	2b c6		 sub	 eax, esi
  00089	3b d0		 cmp	 edx, eax
  0008b	72 e3		 jb	 SHORT $LL7@util_64to2
$LN30@util_64to2:

; 199  : 			  break;
; 200  : 		  }
; 201  : 	  }
; 202  :     if (!ptr) return 0;

  0008d	8b 45 f8	 mov	 eax, DWORD PTR _ptr$1$[ebp]
$LN6@util_64to2:
  00090	85 c0		 test	 eax, eax
  00092	74 7e		 je	 SHORT $LN9@util_64to2

; 203  :     if (i%4) {

  00094	8b 55 fc	 mov	 edx, DWORD PTR _i$1$[ebp]
  00097	2b c7		 sub	 eax, edi
  00099	8b 75 f0	 mov	 esi, DWORD PTR _dwcounter$1$[ebp]
  0009c	83 e0 3f	 and	 eax, 63			; 0000003fH
  0009f	83 e2 03	 and	 edx, 3
  000a2	74 24		 je	 SHORT $LN12@util_64to2

; 204  :       dw = ((unsigned int)(ptr-table) & 0x3f) << ((4-(i%4))<<1) | dw;

  000a4	8b 5d f4	 mov	 ebx, DWORD PTR _dw$1$[ebp]
  000a7	b9 04 00 00 00	 mov	 ecx, 4
  000ac	2b ca		 sub	 ecx, edx
  000ae	03 c9		 add	 ecx, ecx
  000b0	d3 e0		 shl	 eax, cl
  000b2	0b d8		 or	 ebx, eax

; 205  :       dst[ dwcounter++ ] = dw & 0xff;

  000b4	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  000b7	88 1c 06	 mov	 BYTE PTR [esi+eax], bl
  000ba	46		 inc	 esi
  000bb	89 75 f0	 mov	 DWORD PTR _dwcounter$1$[ebp], esi

; 206  :       dw = dw >> 8;

  000be	c1 eb 08	 shr	 ebx, 8

; 207  :     } else {

  000c1	eb 07		 jmp	 SHORT $LN33@util_64to2
$LN18@util_64to2:

; 198  : 			  ptr = table+j;

  000c3	89 45 f8	 mov	 DWORD PTR _ptr$1$[ebp], eax
  000c6	eb c8		 jmp	 SHORT $LN6@util_64to2
$LN12@util_64to2:

; 208  :       dw = (unsigned int)(ptr-table) & 0x3f;

  000c8	8b d8		 mov	 ebx, eax
$LN33@util_64to2:

; 193  :   char c;
; 194  :   for (i=0; i<strlen(src); i++) {

  000ca	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  000cd	ff 45 fc	 inc	 DWORD PTR _i$1$[ebp]
  000d0	89 5d f4	 mov	 DWORD PTR _dw$1$[ebp], ebx
  000d3	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL29@util_64to2:
  000d6	8a 01		 mov	 al, BYTE PTR [ecx]
  000d8	41		 inc	 ecx
  000d9	84 c0		 test	 al, al
  000db	75 f9		 jne	 SHORT $LL29@util_64to2
  000dd	8b 45 fc	 mov	 eax, DWORD PTR _i$1$[ebp]
  000e0	2b ca		 sub	 ecx, edx
  000e2	3b c1		 cmp	 eax, ecx
  000e4	0f 82 6a ff ff
	ff		 jb	 $LL4@util_64to2

; 209  :     }
; 210  :   }
; 211  :   if (dw) dst[ dwcounter++ ] = dw & 0xff;

  000ea	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  000ed	85 db		 test	 ebx, ebx
  000ef	74 14		 je	 SHORT $LN14@util_64to2
  000f1	88 1c 06	 mov	 BYTE PTR [esi+eax], bl
  000f4	46		 inc	 esi
  000f5	5f		 pop	 edi

; 212  :   dst[ dwcounter ] = '\0';

  000f6	c6 04 06 00	 mov	 BYTE PTR [esi+eax], 0

; 213  :   return dwcounter;

  000fa	8b c6		 mov	 eax, esi

; 214  : }

  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx
  000fe	8b e5		 mov	 esp, ebp
  00100	5d		 pop	 ebp
  00101	c3		 ret	 0
$LN31@util_64to2:

; 193  :   char c;
; 194  :   for (i=0; i<strlen(src); i++) {

  00102	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
$LN14@util_64to2:

; 212  :   dst[ dwcounter ] = '\0';

  00105	c6 04 06 00	 mov	 BYTE PTR [esi+eax], 0

; 213  :   return dwcounter;

  00109	8b c6		 mov	 eax, esi
  0010b	5f		 pop	 edi

; 214  : }

  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx
  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c3		 ret	 0
$LN9@util_64to2:
  00112	5f		 pop	 edi
  00113	5e		 pop	 esi
  00114	33 c0		 xor	 eax, eax
  00116	5b		 pop	 ebx
  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c3		 ret	 0
?util_64to256@@YAHPAD00@Z ENDP				; util_64to256
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?util_256to64@@YAHPAD0H0@Z
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_len$ = 16						; size = 4
_table$ = 20						; size = 4
?util_256to64@@YAHPAD0H0@Z PROC				; util_256to64, COMDAT

; 163  : int util_256to64(char *dst, char *src, int len, char *table){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 164  :   unsigned int dw,dwcounter;
; 165  :   int i;
; 166  : 
; 167  :   if (!dst || !src || !table) return 0;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	0f 84 8d 00 00
	00		 je	 $LN6@util_256to
  0000e	83 7d 0c 00	 cmp	 DWORD PTR _src$[ebp], 0
  00012	0f 84 83 00 00
	00		 je	 $LN6@util_256to
  00018	83 7d 14 00	 cmp	 DWORD PTR _table$[ebp], 0
  0001c	0f 84 79 00 00
	00		 je	 $LN6@util_256to

; 168  :   dw=0;

  00022	53		 push	 ebx
  00023	56		 push	 esi
  00024	57		 push	 edi
  00025	33 db		 xor	 ebx, ebx
  00027	33 f6		 xor	 esi, esi

; 169  :   dwcounter=0;

  00029	33 ff		 xor	 edi, edi

; 170  :   for (i=0; i<len; i++) {

  0002b	39 5d 10	 cmp	 DWORD PTR _len$[ebp], ebx
  0002e	7e 60		 jle	 SHORT $LN8@util_256to
$LL4@util_256to:

; 171  :     dw = ( ((unsigned int)src[i] & 0xff) << ((i%3)<<1) ) | dw;

  00030	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00035	f7 e3		 mul	 ebx
  00037	d1 ea		 shr	 edx, 1
  00039	8d 04 52	 lea	 eax, DWORD PTR [edx+edx*2]
  0003c	8b d3		 mov	 edx, ebx
  0003e	2b d0		 sub	 edx, eax
  00040	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00043	0f be 04 03	 movsx	 eax, BYTE PTR [ebx+eax]
  00047	8d 0c 12	 lea	 ecx, DWORD PTR [edx+edx]
  0004a	0f b6 c0	 movzx	 eax, al
  0004d	d3 e0		 shl	 eax, cl

; 172  :     dst[ dwcounter++ ] = table[ dw & 0x3f ];

  0004f	8b 4d 14	 mov	 ecx, DWORD PTR _table$[ebp]
  00052	0b f0		 or	 esi, eax
  00054	8b c6		 mov	 eax, esi

; 173  :     dw = ( dw >> 6 );

  00056	c1 ee 06	 shr	 esi, 6
  00059	83 e0 3f	 and	 eax, 63			; 0000003fH
  0005c	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00062	88 04 0f	 mov	 BYTE PTR [edi+ecx], al
  00065	47		 inc	 edi

; 174  :     if (i%3==2) {

  00066	83 fa 02	 cmp	 edx, 2
  00069	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  0006c	75 0c		 jne	 SHORT $LN2@util_256to

; 175  :       dst[ dwcounter++ ] = table[ dw & 0x3f ];

  0006e	83 e6 3f	 and	 esi, 63			; 0000003fH
  00071	8a 04 16	 mov	 al, BYTE PTR [esi+edx]
  00074	88 04 0f	 mov	 BYTE PTR [edi+ecx], al
  00077	47		 inc	 edi

; 176  :       dw = 0;

  00078	33 f6		 xor	 esi, esi
$LN2@util_256to:

; 170  :   for (i=0; i<len; i++) {

  0007a	43		 inc	 ebx
  0007b	3b 5d 10	 cmp	 ebx, DWORD PTR _len$[ebp]
  0007e	7c b0		 jl	 SHORT $LL4@util_256to

; 177  :     }
; 178  :   }
; 179  :   if (dw) dst[ dwcounter++ ] = table[ dw ];

  00080	85 f6		 test	 esi, esi
  00082	74 0c		 je	 SHORT $LN8@util_256to
  00084	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00087	8a 0c 16	 mov	 cl, BYTE PTR [esi+edx]
  0008a	88 0c 07	 mov	 BYTE PTR [edi+eax], cl
  0008d	47		 inc	 edi
  0008e	8b c8		 mov	 ecx, eax
$LN8@util_256to:

; 180  :   dst[ dwcounter ] = '\0';

  00090	c6 04 0f 00	 mov	 BYTE PTR [edi+ecx], 0

; 181  :   return dwcounter;

  00094	8b c7		 mov	 eax, edi
  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx

; 182  : }

  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
$LN6@util_256to:

; 164  :   unsigned int dw,dwcounter;
; 165  :   int i;
; 166  : 
; 167  :   if (!dst || !src || !table) return 0;

  0009b	33 c0		 xor	 eax, eax

; 182  : }

  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
?util_256to64@@YAHPAD0H0@Z ENDP				; util_256to64
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?util_SendMesg@@YAXHHPAD@Z
_TEXT	SEGMENT
_addr$ = -120008					; size = 4
_t2$ = -120004						; size = 60000
_t1$ = -60004						; size = 60000
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_func$ = 12						; size = 4
_buffer$ = 16						; size = 4
?util_SendMesg@@YAXHHPAD@Z PROC				; util_SendMesg, COMDAT

; 136  : void util_SendMesg(int fd, int func, char *buffer){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 c8 d4 01 00	 mov	 eax, 120008		; 0001d4c8H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	8b 7d 10	 mov	 edi, DWORD PTR _buffer$[ebp]

; 137  : 	char t1[60000], t2[60000];
; 138  :   int addr = 0;

  0001c	c7 85 38 2b fe
	ff 00 00 00 00	 mov	 DWORD PTR _addr$[ebp], 0

; 139  :   __asm
; 140  :   {
; 141  : 	  push dword ptr [ebp + 4];

  00026	ff 75 04	 push	 DWORD PTR [ebp+4]

; 142  : 	  pop addr;

  00029	8f 85 38 2b fe
	ff		 pop	 DWORD PTR _addr$[ebp]

; 143  : 
; 144  :   }
; 145  :   JL_combinePacket_SEND(func, addr);

  0002f	8b 75 0c	 mov	 esi, DWORD PTR _func$[ebp]
  00032	ff b5 38 2b fe
	ff		 push	 DWORD PTR _addr$[ebp]
  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 ?JL_combinePacket_SEND@@YAXHH@Z ; JL_combinePacket_SEND

; 146  :   sprintf(t1, "&;%d%s;#;", func + 13, buffer);

  0003e	57		 push	 edi
  0003f	8d 46 0d	 lea	 eax, DWORD PTR [esi+13]
  00042	50		 push	 eax
  00043	8d 85 9c 15 ff
	ff		 lea	 eax, DWORD PTR _t1$[ebp]
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_09PELNNIGO@?$CG?$DL?$CFd?$CFs?$DL?$CD?$DL@
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _sprintf

; 147  : #if 0
; 148  : 	if( lssproto_writelogfilename[0] != '\0' ){
; 149  : 		FILE *wfp = fopen( lssproto_writelogfilename , "a+" );
; 150  : 		if(wfp){
; 151  : 			fprintf( wfp , "é€å‡ºï¼š\t%s\n", t1 );
; 152  : 			fclose(wfp);
; 153  : 		}
; 154  : 	}
; 155  : #endif
; 156  :   util_EncodeMessage(t2, t1);

  00054	8d 85 9c 15 ff
	ff		 lea	 eax, DWORD PTR _t1$[ebp]
  0005a	50		 push	 eax
  0005b	8d 85 3c 2b fe
	ff		 lea	 eax, DWORD PTR _t2$[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ?util_EncodeMessage@@YAXPAD0@Z ; util_EncodeMessage

; 157  : #ifdef __STONEAGE
; 158  :   lssproto_Send(fd, t2);

  00067	8d 85 3c 2b fe
	ff		 lea	 eax, DWORD PTR _t2$[ebp]
  0006d	50		 push	 eax
  0006e	ff 75 08	 push	 DWORD PTR _fd$[ebp]
  00071	e8 00 00 00 00	 call	 ?lssproto_Send@@YAXHPAD@Z ; lssproto_Send

; 159  : #endif
; 160  : }

  00076	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00079	83 c4 28	 add	 esp, 40			; 00000028H
  0007c	33 cd		 xor	 ecx, ebp
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?util_SendMesg@@YAXHHPAD@Z ENDP				; util_SendMesg
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?util_DiscardMessage@@YAXXZ
_TEXT	SEGMENT
?util_DiscardMessage@@YAXXZ PROC			; util_DiscardMessage, COMDAT

; 132  : 	SliceCount=0;

  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?SliceCount@@3HA, 0 ; SliceCount

; 133  : }

  0000a	c3		 ret	 0
?util_DiscardMessage@@YAXXZ ENDP			; util_DiscardMessage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?util_GetFunctionFromSlice@@YAHPAH0@Z
_TEXT	SEGMENT
_t1$ = -16388						; size = 16384
__$ArrayPad$ = -4					; size = 4
_func$ = 8						; size = 4
_fieldcount$ = 12					; size = 4
?util_GetFunctionFromSlice@@YAHPAH0@Z PROC		; util_GetFunctionFromSlice, COMDAT

; 117  : int util_GetFunctionFromSlice(int *func, int *fieldcount){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 04 40 00 00	 mov	 eax, 16388		; 00004004H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 118  :   char t1[16384];
; 119  :   int i;
; 120  :   strcpy(t1, MesgSlice[1]);

  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ?MesgSlice@@3PAPADA ; MesgSlice
  0001c	8d 95 fc bf ff
	ff		 lea	 edx, DWORD PTR _t1$[ebp]
  00022	53		 push	 ebx
  00023	8b 5d 0c	 mov	 ebx, DWORD PTR _fieldcount$[ebp]
  00026	56		 push	 esi
  00027	8b 75 08	 mov	 esi, DWORD PTR _func$[ebp]
  0002a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002d	57		 push	 edi
  0002e	66 90		 npad	 2
$LL7@util_GetFu:
  00030	8a 01		 mov	 al, BYTE PTR [ecx]
  00032	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00035	88 02		 mov	 BYTE PTR [edx], al
  00037	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  0003a	84 c0		 test	 al, al
  0003c	75 f2		 jne	 SHORT $LL7@util_GetFu

; 121  :   *func = atoi(t1) - 23;

  0003e	8d 85 fc bf ff
	ff		 lea	 eax, DWORD PTR _t1$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _atoi
  0004a	83 e8 17	 sub	 eax, 23			; 00000017H
  0004d	83 c4 04	 add	 esp, 4
  00050	89 06		 mov	 DWORD PTR [esi], eax

; 122  :   for (i=0; i<SLICE_MAX; i++)

  00052	33 f6		 xor	 esi, esi
  00054	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?MesgSlice@@3PAPADA ; MesgSlice
  0005a	66 0f 1f 44 00
	00		 npad	 6
$LL4@util_GetFu:

; 123  :     if (strcmp(MesgSlice[i], DEFAULTFUNCEND)==0) {

  00060	8b 0c b7	 mov	 ecx, DWORD PTR [edi+esi*4]
  00063	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_01IPJKGB@?$CD@
$LL16@util_GetFu:
  00068	8a 11		 mov	 dl, BYTE PTR [ecx]
  0006a	3a 10		 cmp	 dl, BYTE PTR [eax]
  0006c	75 1a		 jne	 SHORT $LN17@util_GetFu
  0006e	84 d2		 test	 dl, dl
  00070	74 12		 je	 SHORT $LN18@util_GetFu
  00072	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  00075	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  00078	75 0e		 jne	 SHORT $LN17@util_GetFu
  0007a	83 c1 02	 add	 ecx, 2
  0007d	83 c0 02	 add	 eax, 2
  00080	84 d2		 test	 dl, dl
  00082	75 e4		 jne	 SHORT $LL16@util_GetFu
$LN18@util_GetFu:
  00084	33 c0		 xor	 eax, eax
  00086	eb 05		 jmp	 SHORT $LN19@util_GetFu
$LN17@util_GetFu:
  00088	1b c0		 sbb	 eax, eax
  0008a	83 c8 01	 or	 eax, 1
$LN19@util_GetFu:
  0008d	85 c0		 test	 eax, eax
  0008f	74 19		 je	 SHORT $LN10@util_GetFu

; 122  :   for (i=0; i<SLICE_MAX; i++)

  00091	46		 inc	 esi
  00092	83 fe 14	 cmp	 esi, 20			; 00000014H
  00095	7c c9		 jl	 SHORT $LL4@util_GetFu

; 124  :       *fieldcount=i-2;
; 125  :       return 1;
; 126  :     }
; 127  : 
; 128  :   return 0;
; 129  : }

  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	33 c0		 xor	 eax, eax
  0009b	5b		 pop	 ebx
  0009c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009f	33 cd		 xor	 ecx, ebp
  000a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
$LN10@util_GetFu:
  000aa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ad	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]
  000b0	5f		 pop	 edi
  000b1	89 03		 mov	 DWORD PTR [ebx], eax
  000b3	33 cd		 xor	 ecx, ebp
  000b5	5e		 pop	 esi
  000b6	b8 01 00 00 00	 mov	 eax, 1
  000bb	5b		 pop	 ebx
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
?util_GetFunctionFromSlice@@YAHPAH0@Z ENDP		; util_GetFunctionFromSlice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?util_DecodeMessage@@YAXPAD0@Z
_TEXT	SEGMENT
_t2$ = -73704						; size = 4
_rn$ = -73700						; size = 4
_tz$ = -73696						; size = 65500
_t3$ = -8196						; size = 4096
_t4$ = -4100						; size = 4096
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
?util_DecodeMessage@@YAXPAD0@Z PROC			; util_DecodeMessage, COMDAT

; 95   : void util_DecodeMessage(char *dst, char *src){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 e8 1f 01 00	 mov	 eax, 73704		; 00011fe8H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]

; 96   : #define INTCODESIZE	(sizeof(int)*8+5)/6
; 97   :   int rn;
; 98   :   int *t1, t2;
; 99   :   char t3[4096], t4[4096];
; 100  :   char tz[65500];
; 101  : 
; 102  :   if( src[strlen(src)-1] == '\n')

  0001a	8b ca		 mov	 ecx, edx
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8b 7d 08	 mov	 edi, DWORD PTR _dst$[ebp]
  00021	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL6@util_Decod:
  00024	8a 01		 mov	 al, BYTE PTR [ecx]
  00026	41		 inc	 ecx
  00027	84 c0		 test	 al, al
  00029	75 f9		 jne	 SHORT $LL6@util_Decod
  0002b	2b ce		 sub	 ecx, esi
  0002d	80 7c 11 ff 0a	 cmp	 BYTE PTR [ecx+edx-1], 10 ; 0000000aH
  00032	75 19		 jne	 SHORT $LN2@util_Decod

; 103  : 	src[strlen(src)-1] = 0;

  00034	8b ca		 mov	 ecx, edx
  00036	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@util_Decod:
  00040	8a 01		 mov	 al, BYTE PTR [ecx]
  00042	41		 inc	 ecx
  00043	84 c0		 test	 al, al
  00045	75 f9		 jne	 SHORT $LL7@util_Decod
  00047	2b ce		 sub	 ecx, esi
  00049	88 44 11 ff	 mov	 BYTE PTR [ecx+edx-1], al
$LN2@util_Decod:

; 104  :   util_xorstring(tz, src);

  0004d	52		 push	 edx
  0004e	8d 85 20 e0 fe
	ff		 lea	 eax, DWORD PTR _tz$[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?util_xorstring@@YAXPAD0@Z ; util_xorstring

; 105  : 
; 106  :   rn=INTCODESIZE;
; 107  :   strncpy(t4, tz, INTCODESIZE);

  0005a	6a 06		 push	 6
  0005c	8d 85 20 e0 fe
	ff		 lea	 eax, DWORD PTR _tz$[ebp]
  00062	c7 85 1c e0 fe
	ff 06 00 00 00	 mov	 DWORD PTR _rn$[ebp], 6
  0006c	50		 push	 eax
  0006d	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _t4$[ebp]
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 _strncpy

; 108  :   t4[INTCODESIZE] = '\0';
; 109  :   util_64to256(t3, t4, DEFAULTTABLE);

  00079	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@CPNIKEEC@0123456789ABCDEFGHIJKLMNOPQRSTU@
  0007e	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _t4$[ebp]
  00084	c6 85 02 f0 ff
	ff 00		 mov	 BYTE PTR _t4$[ebp+6], 0
  0008b	50		 push	 eax
  0008c	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _t3$[ebp]
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ?util_64to256@@YAHPAD00@Z ; util_64to256

; 110  :   t1 = (int *) t3;
; 111  :   t2 = *t1 ^ 0xffffffff;

  00098	8b 85 fc df ff
	ff		 mov	 eax, DWORD PTR _t3$[ebp]
  0009e	f7 d0		 not	 eax
  000a0	89 85 18 e0 fe
	ff		 mov	 DWORD PTR _t2$[ebp], eax

; 112  :   util_swapint(&rn, &t2, "3142");

  000a6	8d 85 18 e0 fe
	ff		 lea	 eax, DWORD PTR _t2$[ebp]
  000ac	68 00 00 00 00	 push	 OFFSET ??_C@_04FJNJEMEN@3142@
  000b1	50		 push	 eax
  000b2	8d 85 1c e0 fe
	ff		 lea	 eax, DWORD PTR _rn$[ebp]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 ?util_swapint@@YAXPAH0PAD@Z ; util_swapint

; 113  :   util_shrstring(dst, tz + INTCODESIZE, rn);

  000be	ff b5 1c e0 fe
	ff		 push	 DWORD PTR _rn$[ebp]
  000c4	8d 85 26 e0 fe
	ff		 lea	 eax, DWORD PTR _tz$[ebp+6]
  000ca	50		 push	 eax
  000cb	57		 push	 edi
  000cc	e8 00 00 00 00	 call	 ?util_shrstring@@YAXPAD0H@Z ; util_shrstring

; 114  : }

  000d1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d4	83 c4 38	 add	 esp, 56			; 00000038H
  000d7	33 cd		 xor	 ecx, ebp
  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi
  000db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
?util_DecodeMessage@@YAXPAD0@Z ENDP			; util_DecodeMessage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?util_EncodeMessage@@YAXPAD0@Z
_TEXT	SEGMENT
_rn$ = -131012						; size = 4
_t2$ = -131008						; size = 4
_t1$ = -131008						; size = 4
_t3$ = -131004						; size = 65500
_tz$ = -65504						; size = 65500
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
?util_EncodeMessage@@YAXPAD0@Z PROC			; util_EncodeMessage, COMDAT

; 81   : void util_EncodeMessage(char *dst, char *src){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 c4 ff 01 00	 mov	 eax, 131012		; 0001ffc4H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	8b 5d 08	 mov	 ebx, DWORD PTR _dst$[ebp]
  0001b	56		 push	 esi
  0001c	8b 75 0c	 mov	 esi, DWORD PTR _src$[ebp]
  0001f	57		 push	 edi

; 82   :   int rn = rand()%99;

  00020	e8 00 00 00 00	 call	 _rand
  00025	99		 cdq
  00026	b9 63 00 00 00	 mov	 ecx, 99			; 00000063H
  0002b	f7 f9		 idiv	 ecx

; 83   :   int t1, t2;
; 84   :   char t3[65500], tz[65500];
; 85   :   util_swapint(&t1, &rn, "2413");

  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_04EMLHGGGF@2413@
  00032	8d 85 3c 00 fe
	ff		 lea	 eax, DWORD PTR _rn$[ebp]
  00038	89 95 3c 00 fe
	ff		 mov	 DWORD PTR _rn$[ebp], edx
  0003e	50		 push	 eax
  0003f	8d 85 40 00 fe
	ff		 lea	 eax, DWORD PTR _t1$[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?util_swapint@@YAXPAH0PAD@Z ; util_swapint

; 86   :   t2 = t1 ^ 0xffffffff;

  0004b	f7 95 40 00 fe
	ff		 not	 DWORD PTR _t1$[ebp]

; 87   :   util_256to64(tz, (char *) &t2, sizeof(int), DEFAULTTABLE);

  00051	8d 85 40 00 fe
	ff		 lea	 eax, DWORD PTR _t2$[ebp]
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@CPNIKEEC@0123456789ABCDEFGHIJKLMNOPQRSTU@
  0005c	6a 04		 push	 4
  0005e	50		 push	 eax
  0005f	8d 85 20 00 ff
	ff		 lea	 eax, DWORD PTR _tz$[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ?util_256to64@@YAHPAD0H0@Z ; util_256to64

; 88   :   
; 89   :   util_shlstring(t3, src, rn);

  0006b	ff b5 3c 00 fe
	ff		 push	 DWORD PTR _rn$[ebp]
  00071	8d 85 44 00 fe
	ff		 lea	 eax, DWORD PTR _t3$[ebp]
  00077	56		 push	 esi
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?util_shlstring@@YAXPAD0H@Z ; util_shlstring

; 90   :   strcat(tz, t3);

  0007e	8d 85 44 00 fe
	ff		 lea	 eax, DWORD PTR _t3$[ebp]
  00084	83 c4 28	 add	 esp, 40			; 00000028H
  00087	8b f0		 mov	 esi, eax
  00089	0f 1f 80 00 00
	00 00		 npad	 7
$LL3@util_Encod:
  00090	8a 08		 mov	 cl, BYTE PTR [eax]
  00092	40		 inc	 eax
  00093	84 c9		 test	 cl, cl
  00095	75 f9		 jne	 SHORT $LL3@util_Encod
  00097	8d bd 20 00 ff
	ff		 lea	 edi, DWORD PTR _tz$[ebp]
  0009d	2b c6		 sub	 eax, esi
  0009f	4f		 dec	 edi
$LL4@util_Encod:
  000a0	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  000a3	47		 inc	 edi
  000a4	84 c9		 test	 cl, cl
  000a6	75 f8		 jne	 SHORT $LL4@util_Encod
  000a8	8b c8		 mov	 ecx, eax
  000aa	c1 e9 02	 shr	 ecx, 2
  000ad	f3 a5		 rep movsd
  000af	8b c8		 mov	 ecx, eax

; 91   :   util_xorstring(dst, tz);

  000b1	8d 85 20 00 ff
	ff		 lea	 eax, DWORD PTR _tz$[ebp]
  000b7	83 e1 03	 and	 ecx, 3
  000ba	50		 push	 eax
  000bb	f3 a4		 rep movsb
  000bd	53		 push	 ebx
  000be	e8 00 00 00 00	 call	 ?util_xorstring@@YAXPAD0@Z ; util_xorstring

; 92   : }

  000c3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c6	83 c4 08	 add	 esp, 8
  000c9	33 cd		 xor	 ecx, ebp
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c3		 ret	 0
?util_EncodeMessage@@YAXPAD0@Z ENDP			; util_EncodeMessage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?util_SplitMessage@@YAXPAD0@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
_separator$ = 12					; size = 4
?util_SplitMessage@@YAXPAD0@Z PROC			; util_SplitMessage, COMDAT

; 59   : void util_SplitMessage(char *source, char *separator){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 60   :   if (source && separator) {	// NULL input is invalid.

  00004	8b 7d 08	 mov	 edi, DWORD PTR _source$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	0f 84 8f 00 00
	00		 je	 $LN4@util_Split
  0000f	8b 45 0c	 mov	 eax, DWORD PTR _separator$[ebp]
  00012	85 c0		 test	 eax, eax
  00014	0f 84 84 00 00
	00		 je	 $LN4@util_Split

; 62   :     char *head = source;

  0001a	56		 push	 esi
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h

; 524  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  0001b	50		 push	 eax
  0001c	57		 push	 edi
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp

; 62   :     char *head = source;

  0001d	8b f7		 mov	 esi, edi
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h

; 524  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  0001f	e8 00 00 00 00	 call	 _strstr
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp

; 64   :     while ((ptr = (char *) strstr(head, separator)) && (SliceCount<=SLICE_MAX)) {

  00024	8b d0		 mov	 edx, eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h

; 524  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  00026	83 c4 08	 add	 esp, 8
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp

; 64   :     while ((ptr = (char *) strstr(head, separator)) && (SliceCount<=SLICE_MAX)) {

  00029	85 d2		 test	 edx, edx
  0002b	74 5d		 je	 SHORT $LN22@util_Split
  0002d	53		 push	 ebx
  0002e	66 90		 npad	 2
$LL2@util_Split:
  00030	83 3d 00 00 00
	00 14		 cmp	 DWORD PTR ?SliceCount@@3HA, 20 ; SliceCount, 00000014H
  00037	7f 50		 jg	 SHORT $LN23@util_Split

; 65   :       ptr[0] = '\0';
; 66   :       if (strlen(head)<SLICE_SIZE) {	// discard slices too large

  00039	8b ce		 mov	 ecx, esi
  0003b	c6 02 00	 mov	 BYTE PTR [edx], 0
  0003e	8d 59 01	 lea	 ebx, DWORD PTR [ecx+1]
$LL21@util_Split:
  00041	8a 01		 mov	 al, BYTE PTR [ecx]
  00043	41		 inc	 ecx
  00044	84 c0		 test	 al, al
  00046	75 f9		 jne	 SHORT $LL21@util_Split
  00048	2b cb		 sub	 ecx, ebx
  0004a	81 f9 dc ff 00
	00		 cmp	 ecx, 65500		; 0000ffdcH
  00050	73 22		 jae	 SHORT $LN5@util_Split

; 67   :         strcpy(MesgSlice[SliceCount], head);

  00052	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?SliceCount@@3HA ; SliceCount
  00058	a1 00 00 00 00	 mov	 eax, DWORD PTR ?MesgSlice@@3PAPADA ; MesgSlice
  0005d	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
$LL7@util_Split:
  00060	8a 06		 mov	 al, BYTE PTR [esi]
  00062	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  00065	88 01		 mov	 BYTE PTR [ecx], al
  00067	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  0006a	84 c0		 test	 al, al
  0006c	75 f2		 jne	 SHORT $LL7@util_Split

; 68   :         SliceCount++;

  0006e	ff 05 00 00 00
	00		 inc	 DWORD PTR ?SliceCount@@3HA ; SliceCount
$LN5@util_Split:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h

; 524  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  00074	ff 75 0c	 push	 DWORD PTR _separator$[ebp]
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp

; 70   :       head = ptr+1;

  00077	8d 72 01	 lea	 esi, DWORD PTR [edx+1]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h

; 524  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  0007a	56		 push	 esi
  0007b	e8 00 00 00 00	 call	 _strstr
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp

; 64   :     while ((ptr = (char *) strstr(head, separator)) && (SliceCount<=SLICE_MAX)) {

  00080	8b d0		 mov	 edx, eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h

; 524  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  00082	83 c4 08	 add	 esp, 8
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp

; 64   :     while ((ptr = (char *) strstr(head, separator)) && (SliceCount<=SLICE_MAX)) {

  00085	85 d2		 test	 edx, edx
  00087	75 a7		 jne	 SHORT $LL2@util_Split
$LN23@util_Split:
  00089	5b		 pop	 ebx
$LN22@util_Split:

; 71   :     }
; 72   :     strcpy(source, head);	// remove splited slices

  0008a	2b fe		 sub	 edi, esi
  0008c	0f 1f 40 00	 npad	 4
$LL8@util_Split:
  00090	8a 06		 mov	 al, BYTE PTR [esi]
  00092	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  00095	88 44 37 ff	 mov	 BYTE PTR [edi+esi-1], al
  00099	84 c0		 test	 al, al
  0009b	75 f3		 jne	 SHORT $LL8@util_Split
  0009d	5e		 pop	 esi
$LN4@util_Split:
  0009e	5f		 pop	 edi

; 73   :   }
; 74   : }

  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
?util_SplitMessage@@YAXPAD0@Z ENDP			; util_SplitMessage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?util_Release@@YAXXZ
_TEXT	SEGMENT
?util_Release@@YAXXZ PROC				; util_Release, COMDAT

; 485  :   int i;
; 486  :   
; 487  : 	if(MesgSlice){

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?MesgSlice@@3PAPADA ; MesgSlice
  00005	85 c0		 test	 eax, eax
  00007	74 2e		 je	 SHORT $LN5@util_Relea

; 488  : 		for(i=0;i<SLICE_MAX;i++){

  00009	56		 push	 esi
  0000a	33 f6		 xor	 esi, esi
  0000c	0f 1f 40 00	 npad	 4
$LL4@util_Relea:

; 489  : 			if(MesgSlice[i]){

  00010	8b 0c 06	 mov	 ecx, DWORD PTR [esi+eax]
  00013	85 c9		 test	 ecx, ecx
  00015	74 0e		 je	 SHORT $LN2@util_Relea

; 490  : 				FREE(MesgSlice[i]);

  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _free
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?MesgSlice@@3PAPADA ; MesgSlice
  00022	83 c4 04	 add	 esp, 4
$LN2@util_Relea:

; 488  : 		for(i=0;i<SLICE_MAX;i++){

  00025	83 c6 04	 add	 esi, 4
  00028	83 fe 50	 cmp	 esi, 80			; 00000050H
  0002b	7c e3		 jl	 SHORT $LL4@util_Relea

; 491  : #ifdef  _STONDEBUG_
; 492  : 				g_iMallocCount--;
; 493  : #endif
; 494  : 			}
; 495  : 		}
; 496  : 		FREE(MesgSlice);

  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _free
  00033	83 c4 04	 add	 esp, 4
  00036	5e		 pop	 esi
$LN5@util_Relea:

; 497  : #ifdef  _STONDEBUG_
; 498  : 		g_iMallocCount--;
; 499  : #endif
; 500  : 	}
; 501  : }

  00037	c3		 ret	 0
?util_Release@@YAXXZ ENDP				; util_Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\NewProto\autil.cpp
;	COMDAT ?util_Init@@YAXXZ
_TEXT	SEGMENT
?util_Init@@YAXXZ PROC					; util_Init, COMDAT

; 38   : void util_Init(void){

  00000	56		 push	 esi

; 39   :   int i;
; 40   :   MesgSlice = (char **) MALLOC(sizeof(char *) * SLICE_MAX);

  00001	6a 50		 push	 80			; 00000050H
  00003	e8 00 00 00 00	 call	 _malloc
  00008	83 c4 04	 add	 esp, 4
  0000b	a3 00 00 00 00	 mov	 DWORD PTR ?MesgSlice@@3PAPADA, eax ; MesgSlice
  00010	33 f6		 xor	 esi, esi
$LL4@util_Init:

; 41   : #ifdef  _STONDEBUG_
; 42   : 	g_iMallocCount++;
; 43   : #endif
; 44   :   for (i=0; i<SLICE_MAX; i++){
; 45   :     MesgSlice[i] = (char *) MALLOC(SLICE_SIZE);

  00012	68 dc ff 00 00	 push	 65500			; 0000ffdcH
  00017	e8 00 00 00 00	 call	 _malloc
  0001c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?MesgSlice@@3PAPADA ; MesgSlice
  00022	83 c4 04	 add	 esp, 4
  00025	89 04 0e	 mov	 DWORD PTR [esi+ecx], eax
  00028	83 c6 04	 add	 esi, 4
  0002b	83 fe 50	 cmp	 esi, 80			; 00000050H
  0002e	7c e2		 jl	 SHORT $LL4@util_Init

; 46   : #ifdef  _STONDEBUG_
; 47   : 		g_iMallocCount++;
; 48   : #endif
; 49   : 	}
; 50   :   SliceCount = 0;

  00030	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?SliceCount@@3HA, 0 ; SliceCount
  0003a	5e		 pop	 esi

; 51   : }

  0003b	c3		 ret	 0
?util_Init@@YAXXZ ENDP					; util_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1781 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1782 :         int _Result;
; 1783 :         va_list _ArgList;
; 1784 :         __crt_va_start(_ArgList, _Format);
; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1789 :         #pragma warning(pop)
; 1790 : 
; 1791 :         __crt_va_end(_ArgList);
; 1792 :         return _Result;
; 1793 :     }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
