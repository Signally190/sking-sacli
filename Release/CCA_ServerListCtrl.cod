; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30133.0 

	TITLE	\\VBOXSVR\_stoneage\repos\ssm-sacli\Release\CCA_ServerListCtrl.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?serverListDecodeComplete@@3HA			; serverListDecodeComplete
PUBLIC	?serverListEncodeArray@@3PADA			; serverListEncodeArray
PUBLIC	?serverListDecodeArray@@3PADA			; serverListDecodeArray
PUBLIC	?serverListEncodeRealLenght@@3HA		; serverListEncodeRealLenght
_BSS	SEGMENT
?serverListDecodeComplete@@3HA DD 01H DUP (?)		; serverListDecodeComplete
?serverListEncodeArray@@3PADA DB 0800H DUP (?)		; serverListEncodeArray
?serverListDecodeArray@@3PADA DB 0800H DUP (?)		; serverListDecodeArray
_BSS	ENDS
_DATA	SEGMENT
?serverListEncodeRealLenght@@3HA DD 0ffffffffH		; serverListEncodeRealLenght
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_sprintf
PUBLIC	?split_damage@@YAHPADDPAHI@Z			; split_damage
PUBLIC	?strncpy2@@YAPADPADPBDI@Z			; strncpy2
PUBLIC	?strncpysafe@@YAXPADIPBDH@Z			; strncpysafe
PUBLIC	?strcpysafe@@YAXPADIPBD@Z			; strcpysafe
PUBLIC	?ScanOneByte@@YAPADPADD@Z			; ScanOneByte
PUBLIC	?getStringFromIndexWithDelim_body@@YAHPAD0H0H0H@Z ; getStringFromIndexWithDelim_body
PUBLIC	?ú°à°Ôô?ÖªøúÙ¥Ùş@@YAXPAD0@Z			; ú°à°Ôô?ÖªøúÙ¥Ùş
PUBLIC	?ú°ÚËMAX??ÓÛ?@@YAXPADH@Z			; ú°ÚËMAX??ÓÛ?
PUBLIC	??ìıserverMax@@YAXPADH@Z			; ?ìıserverMax
PUBLIC	???ú°?serverMax@@YAXXZ				; ??ú°?serverMax
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_09KCBLGBPG@?$HM?$CFs?$HM?$CFs?4?$CFs@	; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0FN@LLDCKPMI@?$DP?z?$LM?$HM?X?$KB?u?U?$HM222?4186?451?4178?39065?6?$DP?z@ ; `string'
PUBLIC	??_C@_03BPOAKJOG@?$CFs?$AA@			; `string'
PUBLIC	??_C@_01KDCPPGHE@r@				; `string'
PUBLIC	??_C@_0L@PGDGOFEL@server?4max@			; `string'
EXTRN	_strstr:PROC
EXTRN	__imp__lstrcpyA@8:PROC
EXTRN	__imp__lstrcatA@8:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_atoi:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_fread:PROC
EXTRN	_fseek:PROC
EXTRN	_ftell:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
EXTRN	?gmsv@@3PAUgameserver@@A:BYTE			; gmsv
EXTRN	?gmgroup@@3PAUgamegroup@@A:BYTE			; gmgroup
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_C@_0L@PGDGOFEL@server?4max@
CONST	SEGMENT
??_C@_0L@PGDGOFEL@server?4max@ DB 'server.max', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r@
CONST	SEGMENT
??_C@_01KDCPPGHE@r@ DB 'r', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03BPOAKJOG@?$CFs?$AA@
CONST	SEGMENT
??_C@_03BPOAKJOG@?$CFs?$AA@ DB '%s', 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@LLDCKPMI@?$DP?z?$LM?$HM?X?$KB?u?U?$HM222?4186?451?4178?39065?6?$DP?z@
CONST	SEGMENT
??_C@_0FN@LLDCKPMI@?$DP?z?$LM?$HM?X?$KB?u?U?$HM222?4186?451?4178?39065?6?$DP?z@ DB '?'
	DB	0faH, 0bcH, '|', 0d8H, 0a1H, 0f5H, 0d5H, '|222.186.51.178:9065'
	DB	0aH, '?', 0faH, 0bcH, '|??', 0ecH, 0e9H, '?|amoijing.gicp.net:'
	DB	'9065', 0aH, '?', 0faH, 0bcH, '|', 0dcH, 0e2H, 0f2H, 0a2H, 0ecH
	DB	0e9H, '?|192.168.1.25:9065', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09KCBLGBPG@?$HM?$CFs?$HM?$CFs?4?$CFs@
CONST	SEGMENT
??_C@_09KCBLGBPG@?$HM?$CFs?$HM?$CFs?4?$CFs@ DB '|%s|%s.%s', 00H ; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\CCA_ServerListCtrl.cpp
;	COMDAT ???ú°?serverMax@@YAXXZ
_TEXT	SEGMENT
_pf$1$ = -4						; size = 4
???ú°?serverMax@@YAXXZ PROC				; ??ú°?serverMax, COMDAT

; 609  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 610  : 	FILE *pf;
; 611  : 	if ((pf = fopen("server.max", "r")) == NULL)

  00005	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r@
  0000a	68 00 00 00 00	 push	 OFFSET ??_C@_0L@PGDGOFEL@server?4max@
  0000f	e8 00 00 00 00	 call	 _fopen
  00014	8b d8		 mov	 ebx, eax
  00016	83 c4 08	 add	 esp, 8
  00019	89 5d fc	 mov	 DWORD PTR _pf$1$[ebp], ebx
  0001c	85 db		 test	 ebx, ebx
  0001e	0f 84 81 00 00
	00		 je	 $LN3@

; 612  : 	{
; 613  : 	}
; 614  : 	else
; 615  : 	{
; 616  : 		fseek(pf, 0, SEEK_END); //å®šä½åˆ°æ–‡ä»¶æœ« 

  00024	56		 push	 esi
  00025	57		 push	 edi
  00026	6a 02		 push	 2
  00028	6a 00		 push	 0
  0002a	53		 push	 ebx
  0002b	e8 00 00 00 00	 call	 _fseek

; 617  : 		int nFileLen = ftell(pf); //æ–‡ä»¶é•¿åº¦ 

  00030	53		 push	 ebx
  00031	e8 00 00 00 00	 call	 _ftell

; 618  : 		fseek(pf, 0, SEEK_SET); //å®šä½åˆ°æ–‡ä»¶æœ« 

  00036	6a 00		 push	 0
  00038	6a 00		 push	 0
  0003a	53		 push	 ebx
  0003b	8b f0		 mov	 esi, eax
  0003d	e8 00 00 00 00	 call	 _fseek

; 619  : 
; 620  : 		char * pMax = (char *)malloc(nFileLen);

  00042	56		 push	 esi
  00043	e8 00 00 00 00	 call	 _malloc

; 621  : 		char * pMax1 = (char *)malloc(2048);

  00048	68 00 08 00 00	 push	 2048			; 00000800H
  0004d	8b d8		 mov	 ebx, eax
  0004f	e8 00 00 00 00	 call	 _malloc

; 622  : 		memset(pMax, 0, nFileLen);

  00054	56		 push	 esi
  00055	6a 00		 push	 0
  00057	53		 push	 ebx
  00058	8b f8		 mov	 edi, eax
  0005a	e8 00 00 00 00	 call	 _memset

; 623  : 		memset(pMax1, 0, 2048);

  0005f	68 00 08 00 00	 push	 2048			; 00000800H
  00064	6a 00		 push	 0
  00066	57		 push	 edi
  00067	e8 00 00 00 00	 call	 _memset

; 624  : 		fread(pMax, sizeof(char), nFileLen, pf);

  0006c	ff 75 fc	 push	 DWORD PTR _pf$1$[ebp]
  0006f	56		 push	 esi
  00070	6a 01		 push	 1
  00072	53		 push	 ebx
  00073	e8 00 00 00 00	 call	 _fread
  00078	83 c4 4c	 add	 esp, 76			; 0000004cH

; 625  : 		è§£å¯†MAXå†…è”ä»£ç (pMax, nFileLen);

  0007b	56		 push	 esi
  0007c	53		 push	 ebx
  0007d	e8 00 00 00 00	 call	 ?ú°ÚËMAX??ÓÛ?@@YAXPADH@Z ; ú°ÚËMAX??ÓÛ?

; 626  : 		è§£æç™»é™†åˆ—è¡¨æ˜æ–‡((char*)(pMax + 16), pMax1);

  00082	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  00085	57		 push	 edi
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ?ú°à°Ôô?ÖªøúÙ¥Ùş@@YAXPAD0@Z ; ú°à°Ôô?ÖªøúÙ¥Ùş

; 627  : 		//æƒ…ç¼˜|ç”µä¿¡1|218.92.147.50:9065\nCC|CC|amoijing.gicp.net:9065\næœ¬åœ°|æœ¬åœ°|192.168.0.110:9065\n
; 628  : 		fclose(pf);

  0008c	ff 75 fc	 push	 DWORD PTR _pf$1$[ebp]
  0008f	e8 00 00 00 00	 call	 _fclose

; 629  : 		free(pMax);

  00094	53		 push	 ebx
  00095	e8 00 00 00 00	 call	 _free

; 630  : 		free(pMax1);

  0009a	57		 push	 edi
  0009b	e8 00 00 00 00	 call	 _free
  000a0	83 c4 1c	 add	 esp, 28			; 0000001cH
  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
$LN3@:
  000a5	5b		 pop	 ebx

; 631  : 	}
; 632  : }

  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
???ú°?serverMax@@YAXXZ ENDP				; ??ú°?serverMax
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\CCA_ServerListCtrl.cpp
;	COMDAT ??ìıserverMax@@YAXPADH@Z
_TEXT	SEGMENT
_n1$1$ = -660						; size = 4
_n3$1$ = -656						; size = 4
_i$1$ = -652						; size = 4
_tmcount$1$ = -648					; size = 4
_array1$1 = -644					; size = 400
_array3$2 = -244					; size = 200
_array2$3 = -44						; size = 20
_array4$4 = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_pEncode$ = 8						; size = 4
_LenEncode$ = 12					; size = 4
??ìıserverMax@@YAXPADH@Z PROC				; ?ìıserverMax, COMDAT

; 505  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 02 00
	00		 sub	 esp, 660		; 00000294H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _pEncode$[ebp]

; 506  : 	//æµ‹è¯•
; 507  : 	//sprintf(serverListDecodeArray, "%s\0", "æƒ…ç¼˜|ç”µä¿¡1|218.92.147.50:9065\nCC|CC|amoijing.gicp.net:9065\næœ¬åœ°|æœ¬åœ°|192.168.0.110:9065\næœ¬åœ°|æœ¬åœ°2|192.168.0.110:9065\næœ¬åœ°|æœ¬åœ°3|192.168.0.110:9065\n");
; 508  : 	memset(serverListDecodeArray, 0, serverListEncodeLenght);

  00017	68 00 08 00 00	 push	 2048			; 00000800H
  0001c	6a 00		 push	 0
  0001e	68 00 00 00 00	 push	 OFFSET ?serverListDecodeArray@@3PADA ; serverListDecodeArray
  00023	e8 00 00 00 00	 call	 _memset
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 509  : 
; 510  : 	if (*pEncode == '\0')

  0002b	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0002e	75 17		 jne	 SHORT $LN8@

; 511  : 	{
; 512  : 		sprintf(serverListDecodeArray, "%s\0", "è¿è¡Œ|ç«‹ç§‹|222.186.51.178:9065\nè¿è¡Œ|æµ‹è¯•ä¸€çº¿|amoijing.gicp.net:9065\nè¿è¡Œ|æœ¬åœ°ä¸€çº¿|192.168.1.25:9065\n");

  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0FN@LLDCKPMI@?$DP?z?$LM?$HM?X?$KB?u?U?$HM222?4186?451?4178?39065?6?$DP?z@
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_03BPOAKJOG@?$CFs?$AA@
  0003a	68 00 00 00 00	 push	 OFFSET ?serverListDecodeArray@@3PADA ; serverListDecodeArray
  0003f	e8 00 00 00 00	 call	 _sprintf
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@:

; 513  : 	}
; 514  : 
; 515  : 	if (serverListDecodeComplete)

  00047	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?serverListDecodeComplete@@3HA, 0 ; serverListDecodeComplete
  0004e	0f 85 3d 01 00
	00		 jne	 $LN10@

; 516  : 	{
; 517  : 		//å¦‚æœè§£ç å®Œæˆä»€ä¹ˆéƒ½ä¸åš
; 518  : 		return;
; 519  : 	}
; 520  : 	else
; 521  : 	{
; 522  : 		//è®¡ç®—åŠ å¯†çš„encodeArrayé•¿åº¦
; 523  : 		serverListEncodeRealLenght = LenEncode;

  00054	8b 45 0c	 mov	 eax, DWORD PTR _LenEncode$[ebp]
  00057	a3 00 00 00 00	 mov	 DWORD PTR ?serverListEncodeRealLenght@@3HA, eax ; serverListEncodeRealLenght

; 524  : 		//è§£ç 
; 525  : 
; 526  : 		if (*pEncode != '\0')

  0005c	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0005f	74 18		 je	 SHORT $LN11@

; 527  : 		{
; 528  : 			è§£å¯†MAXå†…è”ä»£ç (pEncode, serverListEncodeRealLenght);

  00061	50		 push	 eax
  00062	56		 push	 esi
  00063	e8 00 00 00 00	 call	 ?ú°ÚËMAX??ÓÛ?@@YAXPADH@Z ; ú°ÚËMAX??ÓÛ?

; 529  : 			è§£æç™»é™†åˆ—è¡¨æ˜æ–‡((char*)(pEncode + 16), serverListDecodeArray);

  00068	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  0006b	68 00 00 00 00	 push	 OFFSET ?serverListDecodeArray@@3PADA ; serverListDecodeArray
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ?ú°à°Ôô?ÖªøúÙ¥Ùş@@YAXPAD0@Z ; ú°à°Ôô?ÖªøúÙ¥Ùş
  00076	83 c4 10	 add	 esp, 16			; 00000010H
$LN11@:

; 530  : 		}
; 531  : 		else
; 532  : 		{
; 533  : 			//å¦‚æœæ²¡æœ‰å†™å…¥serverListEncodeArray
; 534  : 			//é‚£ä¹ˆå°±ç”¨é»˜è®¤çš„æ•°æ®
; 535  : 		}
; 536  : 		//è§£ç å®Œæˆï¼Œå†™å…¥åˆ—è¡¨æ•°æ®åˆ°åŸæœ‰çš„é€»è¾‘
; 537  : 		//æƒ…ç¼˜ç”µä¿¡|ç«‹ç§‹-ç”µä¿¡ä¸€çº¿|222.186.51.178:9065|ç«‹æ˜¥-ç”µä¿¡äºŒçº¿|222.186.51.178:9066|é›¨æ°´-ç”µä¿¡ä¸‰çº¿|222.186.51.178:9067|è°·é›¨-ç”µä¿¡å››çº¿|222.186.51.178:9068\n
; 538  : 		//æƒ…ç¼˜ç½‘é€š | ç§‹åˆ† - ç½‘é€šä¸€çº¿ | 153.37.74.177:9065 | ç™½éœ² - ç½‘é€šäºŒçº¿ | 153.37.74.177 : 9066 | æƒŠè›° - ç½‘é€šä¸‰çº¿ | 153.37.74.177 : 9067 | å¤è‡³ - ç½‘é€šå››çº¿ | 153.37.74.177 : 9068\n
; 539  : 		//	CC | CC | amoijing.gicp.net : 9065\n
; 540  : 		//	æœ¬åœ° | æœ¬åœ° | 192.168.0.110 : 9065\n
; 541  : 
; 542  : 		int tmcount = 0; 
; 543  : 		char *strpos = NULL;
; 544  : 		char *tmstrposSearch = &serverListDecodeArray[0];
; 545  : 		//ç»Ÿè®¡ \nçš„åˆ—è¡¨æ•°é‡ 
; 546  : 
; 547  : 		char* array1[100]; //  \nåˆ†å‰²
; 548  : 		char* array2[5];   //  |åˆ†å‰²ä¸€æ¬¡
; 549  : 		char* array3[50];  //  |åˆ†å‰²
; 550  : 		char* array4[5];   //  :åˆ†å‰²
; 551  : 		int n1 = split_damage(serverListDecodeArray, '\n', (int*)array1, 100);

  00079	6a 64		 push	 100			; 00000064H
  0007b	8d 85 7c fd ff
	ff		 lea	 eax, DWORD PTR _array1$1[ebp]
  00081	c7 85 78 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _tmcount$1$[ebp], 0
  0008b	50		 push	 eax
  0008c	6a 0a		 push	 10			; 0000000aH
  0008e	68 00 00 00 00	 push	 OFFSET ?serverListDecodeArray@@3PADA ; serverListDecodeArray
  00093	e8 00 00 00 00	 call	 ?split_damage@@YAHPADDPAHI@Z ; split_damage
  00098	8b c8		 mov	 ecx, eax
  0009a	83 c4 10	 add	 esp, 16			; 00000010H

; 552  : 		for (int i = 0; i < n1; i++)

  0009d	33 c0		 xor	 eax, eax
  0009f	89 8d 6c fd ff
	ff		 mov	 DWORD PTR _n1$1$[ebp], ecx
  000a5	89 85 74 fd ff
	ff		 mov	 DWORD PTR _i$1$[ebp], eax
  000ab	85 c9		 test	 ecx, ecx
  000ad	0f 8e d2 00 00
	00		 jle	 $_ret$32
  000b3	53		 push	 ebx
  000b4	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__lstrcpyA@8
  000ba	57		 push	 edi
  000bb	0f 1f 44 00 00	 npad	 5
$LL4@:

; 553  : 		{
; 554  : 			int n2 = split_damage(array1[i], '|', (int*)array2, 2);

  000c0	6a 02		 push	 2
  000c2	8d 4d d4	 lea	 ecx, DWORD PTR _array2$3[ebp]
  000c5	51		 push	 ecx
  000c6	6a 7c		 push	 124			; 0000007cH
  000c8	ff b4 85 7c fd
	ff ff		 push	 DWORD PTR _array1$1[ebp+eax*4]
  000cf	e8 00 00 00 00	 call	 ?split_damage@@YAHPADDPAHI@Z ; split_damage
  000d4	83 c4 10	 add	 esp, 16			; 00000010H

; 555  : 			if (n2 != 2) goto _ret;

  000d7	83 f8 02	 cmp	 eax, 2
  000da	0f 85 a3 00 00
	00		 jne	 $LN30@

; 556  : 
; 557  : 			int n3 = split_damage(array2[1], '|', (int*)array3, 50);

  000e0	6a 32		 push	 50			; 00000032H
  000e2	8d 85 0c ff ff
	ff		 lea	 eax, DWORD PTR _array3$2[ebp]
  000e8	50		 push	 eax
  000e9	6a 7c		 push	 124			; 0000007cH
  000eb	ff 75 d8	 push	 DWORD PTR _array2$3[ebp+4]
  000ee	e8 00 00 00 00	 call	 ?split_damage@@YAHPADDPAHI@Z ; split_damage
  000f3	83 c4 10	 add	 esp, 16			; 00000010H
  000f6	89 85 70 fd ff
	ff		 mov	 DWORD PTR _n3$1$[ebp], eax

; 558  : 			for (int j = 0; j < n3; )

  000fc	33 ff		 xor	 edi, edi
  000fe	85 c0		 test	 eax, eax
  00100	7e 68		 jle	 SHORT $LN2@

; 556  : 
; 557  : 			int n3 = split_damage(array2[1], '|', (int*)array3, 50);

  00102	8b b5 78 fd ff
	ff		 mov	 esi, DWORD PTR _tmcount$1$[ebp]
  00108	c1 e6 08	 shl	 esi, 8
  0010b	81 c6 c0 00 00
	00		 add	 esi, OFFSET ?gmsv@@3PAUgameserver@@A+192
$LL5@:

; 559  : 			{
; 560  : 				gmsv[tmcount].used = '1';
; 561  : 				lstrcpy(gmsv[tmcount].name, array3[j]);

  00111	ff b4 bd 0c ff
	ff ff		 push	 DWORD PTR _array3$2[ebp+edi*4]
  00118	c6 86 40 ff ff
	ff 31		 mov	 BYTE PTR [esi-192], 49	; 00000031H
  0011f	56		 push	 esi
  00120	ff d3		 call	 ebx

; 562  : 				int n4 = split_damage(array3[j + 1], ':', (int*)array4, 3);

  00122	6a 03		 push	 3
  00124	8d 45 e8	 lea	 eax, DWORD PTR _array4$4[ebp]
  00127	50		 push	 eax
  00128	6a 3a		 push	 58			; 0000003aH
  0012a	ff b4 bd 10 ff
	ff ff		 push	 DWORD PTR _array3$2[ebp+edi*4+4]
  00131	e8 00 00 00 00	 call	 ?split_damage@@YAHPADDPAHI@Z ; split_damage
  00136	83 c4 10	 add	 esp, 16			; 00000010H

; 563  : 				if (n4 != 2)  goto _ret;

  00139	83 f8 02	 cmp	 eax, 2
  0013c	75 45		 jne	 SHORT $LN30@

; 564  : 				lstrcpy(gmsv[tmcount].ipaddr, array4[0]);

  0013e	ff 75 e8	 push	 DWORD PTR _array4$4[ebp]
  00141	8d 86 41 ff ff
	ff		 lea	 eax, DWORD PTR [esi-191]
  00147	50		 push	 eax
  00148	ff d3		 call	 ebx

; 565  : 				lstrcpy(gmsv[tmcount].port, array4[1]);

  0014a	ff 75 ec	 push	 DWORD PTR _array4$4[ebp+4]
  0014d	8d 46 c0	 lea	 eax, DWORD PTR [esi-64]
  00150	50		 push	 eax
  00151	ff d3		 call	 ebx

; 566  : 				j = j + 2;
; 567  : 				tmcount++;

  00153	ff 85 78 fd ff
	ff		 inc	 DWORD PTR _tmcount$1$[ebp]
  00159	83 c7 02	 add	 edi, 2
  0015c	81 c6 00 01 00
	00		 add	 esi, 256		; 00000100H
  00162	3b bd 70 fd ff
	ff		 cmp	 edi, DWORD PTR _n3$1$[ebp]
  00168	7c a7		 jl	 SHORT $LL5@
$LN2@:

; 552  : 		for (int i = 0; i < n1; i++)

  0016a	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR _i$1$[ebp]
  00170	40		 inc	 eax
  00171	89 85 74 fd ff
	ff		 mov	 DWORD PTR _i$1$[ebp], eax
  00177	3b 85 6c fd ff
	ff		 cmp	 eax, DWORD PTR _n1$1$[ebp]
  0017d	0f 8c 3d ff ff
	ff		 jl	 $LL4@
$LN30@:
  00183	5f		 pop	 edi
  00184	5b		 pop	 ebx
$_ret$32:

; 568  : 			}
; 569  : 		}
; 570  : 		_ret:
; 571  : 		gmgroup->num = (char)tmcount;

  00185	8b 8d 78 fd ff
	ff		 mov	 ecx, DWORD PTR _tmcount$1$[ebp]
  0018b	88 0d 01 00 00
	00		 mov	 BYTE PTR ?gmgroup@@3PAUgamegroup@@A+1, cl
$LN10@:

; 572  : 	//	for (; ;)
; 573  : 	//	{
; 574  : 	//		strpos = strstr(tmstrposSearch, "\n");
; 575  : 	//		if (strpos != NULL)
; 576  : 	//		{
; 577  : 
; 578  : 	//			//ä¿®æ”¹ gmsvä¿¡æ¯
; 579  : 	//			char    splitBuf[512];
; 580  : 	//			getStringFromIndexWithDelim(serverListDecodeArray, "\n", tmcount +1, splitBuf, sizeof(splitBuf));
; 581  : 	//			gmsv[tmcount].used = '1';
; 582  : 	//			getStringFromIndexWithDelim(splitBuf, "|", 2, gmsv[tmcount].name, sizeof(gmsv[tmcount].name));
; 583  : 	//			char    serverBuf[512];
; 584  : 	//			getStringFromIndexWithDelim(splitBuf, "|", 3, serverBuf, sizeof(serverBuf));
; 585  : 	//			getStringFromIndexWithDelim(serverBuf, ":", 1, gmsv[tmcount].ipaddr, sizeof(gmsv[tmcount].ipaddr));
; 586  : 	//			getStringFromIndexWithDelim(serverBuf, ":", 2, gmsv[tmcount].port, sizeof(gmsv[tmcount].port));
; 587  : 
; 588  : 	//			tmcount++; 
; 589  : 	//			tmstrposSearch = strpos + 1;
; 590  : 
; 591  : 
; 592  : 	//		}
; 593  : 	//		else
; 594  : 	//		{
; 595  : 	//			break;
; 596  : 	//		}
; 597  : 	//	}
; 598  : 	//	//å·²ç»Ÿè®¡å‡ºå…·ä½“çš„åˆ—è¡¨æ•°é‡
; 599  : 
; 600  : 	//	//ä¿®æ”¹group ä¿¡æ¯
; 601  : 	//	gmgroup->num = (char)tmcount;
; 602  : 	//	//å†™å…¥å®Œæˆ
; 603  : 	//	serverListDecodeComplete = true;
; 604  : 	}
; 605  : 	return;
; 606  : }

  00191	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00194	33 cd		 xor	 ecx, ebp
  00196	5e		 pop	 esi
  00197	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0019c	8b e5		 mov	 esp, ebp
  0019e	5d		 pop	 ebp
  0019f	c3		 ret	 0
??ìıserverMax@@YAXPADH@Z ENDP				; ?ìıserverMax
_TEXT	ENDS
; Function compile flags: /Odtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\CCA_ServerListCtrl.cpp
;	COMDAT ?ú°ÚËMAX??ÓÛ?@@YAXPADH@Z
_TEXT	SEGMENT
_pMax$ = 8						; size = 4
_file_size$ = 12					; size = 4
?ú°ÚËMAX??ÓÛ?@@YAXPADH@Z PROC				; ú°ÚËMAX??ÓÛ?, COMDAT

; 306  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 307  : 	*(int *)pMax = 0x1234;

  00006	8b 45 08	 mov	 eax, DWORD PTR _pMax$[ebp]
  00009	c7 00 34 12 00
	00		 mov	 DWORD PTR [eax], 4660	; 00001234H

; 308  : 	*(int *)(pMax + 4) = 0x5678;

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _pMax$[ebp]
  00012	c7 41 04 78 56
	00 00		 mov	 DWORD PTR [ecx+4], 22136 ; 00005678H

; 309  : 	*(int *)(pMax + 8) = 0x9ABC;

  00019	8b 55 08	 mov	 edx, DWORD PTR _pMax$[ebp]
  0001c	c7 42 08 bc 9a
	00 00		 mov	 DWORD PTR [edx+8], 39612 ; 00009abcH

; 310  : 	*(int *)(pMax + 12) = 0xDEF0;

  00023	8b 45 08	 mov	 eax, DWORD PTR _pMax$[ebp]
  00026	c7 40 0c f0 de
	00 00		 mov	 DWORD PTR [eax+12], 57072 ; 0000def0H

; 311  : 	__asm{
; 312  : 		pushad

  0002d	60		 pushad

; 313  : 
; 314  : 			mov ecx, [file_size]; æ–‡ä»¶å¤§å°->ecx

  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _file_size$[ebp]

; 315  : 			mov edi, ecx

  00031	8b f9		 mov	 edi, ecx

; 316  : 			and ecx, 0x80000007

  00033	81 e1 07 00 00
	80		 and	 ecx, -2147483641	; 80000007H

; 317  : 			jns sa_8018_0048C866

  00039	79 05		 jns	 SHORT $sa_8018_0048C866$3

; 318  : 			dec ecx

  0003b	49		 dec	 ecx

; 319  : 			or ecx, 0xFFFFFFF8

  0003c	83 c9 f8	 or	 ecx, -8			; fffffff8H

; 320  : 			inc ecx

  0003f	41		 inc	 ecx
$sa_8018_0048C866$3:

; 321  : 
; 322  : 		sa_8018_0048C866 :
; 323  : 
; 324  : 		mov eax, edi

  00040	8b c7		 mov	 eax, edi

; 325  : 			je sa_8018_0048C878

  00042	74 0e		 je	 SHORT $sa_8018_0048C878$4

; 326  : 			sub eax, ecx

  00044	2b c1		 sub	 eax, ecx

; 327  : 			cdq

  00046	99		 cdq

; 328  : 			and edx, 0x7

  00047	83 e2 07	 and	 edx, 7

; 329  : 			add eax, edx

  0004a	03 c2		 add	 eax, edx

; 330  : 			sar eax, 0x3

  0004c	c1 f8 03	 sar	 eax, 3

; 331  : 			inc eax

  0004f	40		 inc	 eax

; 332  : 			jmp sa_8018_0048C881

  00050	eb 09		 jmp	 SHORT $sa_8018_0048C881$5
$sa_8018_0048C878$4:

; 333  : 
; 334  : 		sa_8018_0048C878 :
; 335  : 
; 336  : 		cdq

  00052	99		 cdq

; 337  : 			and edx, 0x7

  00053	83 e2 07	 and	 edx, 7

; 338  : 			add eax, edx

  00056	03 c2		 add	 eax, edx

; 339  : 			sar eax, 0x3

  00058	c1 f8 03	 sar	 eax, 3
$sa_8018_0048C881$5:

; 340  : 
; 341  : 		sa_8018_0048C881 :
; 342  : 
; 343  : 						 test eax, eax; æ ¹æ®æ–‡ä»¶å¤§å°è®¡ç®—å‡ºæ¥çš„eax

  0005b	85 c0		 test	 eax, eax

; 344  : 						 jle sa_8018_0048C89F

  0005d	7e 1b		 jle	 SHORT $sa_8018_0048C89F$6

; 345  : 						 mov esi, pMax

  0005f	8b 75 08	 mov	 esi, DWORD PTR _pMax$[ebp]

; 346  : 						 add esi, 16

  00062	83 c6 10	 add	 esi, 16			; 00000010H

; 347  : 						 mov edi, eax

  00065	8b f8		 mov	 edi, eax
$sa_8018_0048C88B$7:

; 348  : 
; 349  : 					 sa_8018_0048C88B :
; 350  : 
; 351  : 		mov ecx, pMax

  00067	8b 4d 08	 mov	 ecx, DWORD PTR _pMax$[ebp]

; 352  : 			push esi

  0006a	56		 push	 esi

; 353  : 			push ecx

  0006b	51		 push	 ecx

; 354  : 			call è§£å¯†max; <= Jump / Call Address Not Resolved; è§£å¯†maxæ–‡ä»¶

  0006c	e8 0e 00 00 00	 call	 $ú°ÚËmax$8

; 355  : 			add esp, 0x8

  00071	83 c4 08	 add	 esp, 8

; 356  : 			add esi, 0x8

  00074	83 c6 08	 add	 esi, 8

; 357  : 			dec edi

  00077	4f		 dec	 edi

; 358  : 			jnz sa_8018_0048C88B

  00078	75 ed		 jne	 SHORT $sa_8018_0048C88B$7
$sa_8018_0048C89F$6:

; 359  : 
; 360  : 		sa_8018_0048C89F :
; 361  : 		jmp ooookkkk

  0007a	e9 08 01 00 00	 jmp	 $ooookkkk$9
$ú°ÚËmax$8:

; 362  : 
; 363  : 		è§£å¯†max : ; <= Procedure Start
; 364  : 
; 365  : 				mov eax, dword ptr ss : [esp + 0x8]

  0007f	36 8b 44 24 08	 mov	 eax, DWORD PTR ss:[esp+8]

; 366  : 				mov ecx, dword ptr ss : [esp + 0x4]

  00084	36 8b 4c 24 04	 mov	 ecx, DWORD PTR ss:[esp+4]

; 367  : 				push - 0x20

  00089	6a e0		 push	 -32			; ffffffe0H

; 368  : 				push eax

  0008b	50		 push	 eax

; 369  : 				push ecx

  0008c	51		 push	 ecx

; 370  : 				call maxåŠ å¯†è§£å¯†; <= Jump / Call Address Not Resolved

  0008d	e8 04 00 00 00	 call	 $maxÊ¥ÚËú°ÚË$10

; 371  : 				add esp, 0xC

  00092	83 c4 0c	 add	 esp, 12			; 0000000cH

; 372  : 				retn; <= Procedure End

  00095	c3		 ret	 0
$maxÊ¥ÚËú°ÚË$10:

; 373  : 
; 374  : 
; 375  : 
; 376  : 			maxåŠ å¯†è§£å¯† : ; <= Procedure Start
; 377  : 
; 378  : 					  mov edx, dword ptr ss : [esp + 0xC]

  00096	36 8b 54 24 0c	 mov	 edx, DWORD PTR ss:[esp+12]

; 379  : 					  push ebx

  0009b	53		 push	 ebx

; 380  : 					  push ebp

  0009c	55		 push	 ebp

; 381  : 					  push esi

  0009d	56		 push	 esi

; 382  : 					  push edi

  0009e	57		 push	 edi

; 383  : 					  mov edi, dword ptr ss : [esp + 0x18]

  0009f	36 8b 7c 24 18	 mov	 edi, DWORD PTR ss:[esp+24]

; 384  : 					  xor esi, esi

  000a4	33 f6		 xor	 esi, esi

; 385  : 					  mov ecx, dword ptr ds : [edi]

  000a6	3e 8b 0f	 mov	 ecx, DWORD PTR ds:[edi]

; 386  : 					  mov eax, dword ptr ds : [edi + 0x4]

  000a9	3e 8b 47 04	 mov	 eax, DWORD PTR ds:[edi+4]

; 387  : 					  test edx, edx

  000ad	85 d2		 test	 edx, edx

; 388  : 					  jle sa_8018_0048C622

  000af	7e 74		 jle	 SHORT $sa_8018_0048C622$11

; 389  : 					  imul edx, edx, 0x9E3779B9

  000b1	69 d2 b9 79 37
	9e		 imul	 edx, edx, -1640531527

; 390  : 					  test edx, edx

  000b7	85 d2		 test	 edx, edx

; 391  : 					  mov dword ptr ss : [esp + 0x18], edx

  000b9	36 89 54 24 18	 mov	 DWORD PTR ss:[esp+24], edx

; 392  : 					  je sa_8018_0048C675

  000be	0f 84 b7 00 00
	00		 je	 $sa_8018_0048C675$12

; 393  : 					  mov edx, dword ptr ss : [esp + 0x14]

  000c4	36 8b 54 24 14	 mov	 edx, DWORD PTR ss:[esp+20]
$sa_8018_0048C5CD$13:

; 394  : 
; 395  : 				  sa_8018_0048C5CD :
; 396  : 
; 397  : 								   mov ebx, eax

  000c9	8b d8		 mov	 ebx, eax

; 398  : 								   mov ebp, eax

  000cb	8b e8		 mov	 ebp, eax

; 399  : 								   sar ebx, 0x5

  000cd	c1 fb 05	 sar	 ebx, 5

; 400  : 								   shl ebp, 0x4

  000d0	c1 e5 04	 shl	 ebp, 4

; 401  : 								   xor ebx, ebp

  000d3	33 dd		 xor	 ebx, ebp

; 402  : 								   mov ebp, esi

  000d5	8b ee		 mov	 ebp, esi

; 403  : 								   and ebp, 0x3

  000d7	83 e5 03	 and	 ebp, 3

; 404  : 								   add ebx, dword ptr ds : [edx + ebp * 4]

  000da	3e 03 1c aa	 add	 ebx, DWORD PTR ds:[edx+ebp*4]

; 405  : 								   mov ebp, esi

  000de	8b ee		 mov	 ebp, esi

; 406  : 								   xor ebp, eax

  000e0	33 e8		 xor	 ebp, eax

; 407  : 								   sub esi, 0x61C88647

  000e2	81 ee 47 86 c8
	61		 sub	 esi, 1640531527		; 61c88647H

; 408  : 								   add ebp, ecx

  000e8	03 e9		 add	 ebp, ecx

; 409  : 								   lea ecx, dword ptr ds : [ebx + ebp]

  000ea	3e 8d 0c 2b	 lea	 ecx, DWORD PTR ds:[ebx+ebp]

; 410  : 								   mov ebx, ecx

  000ee	8b d9		 mov	 ebx, ecx

; 411  : 								   mov ebp, ecx

  000f0	8b e9		 mov	 ebp, ecx

; 412  : 								   sar ebx, 0x5

  000f2	c1 fb 05	 sar	 ebx, 5

; 413  : 								   shl ebp, 0x4

  000f5	c1 e5 04	 shl	 ebp, 4

; 414  : 								   xor ebx, ebp

  000f8	33 dd		 xor	 ebx, ebp

; 415  : 								   mov ebp, esi

  000fa	8b ee		 mov	 ebp, esi

; 416  : 								   sar ebp, 0xB

  000fc	c1 fd 0b	 sar	 ebp, 11			; 0000000bH

; 417  : 								   and ebp, 0x3

  000ff	83 e5 03	 and	 ebp, 3

; 418  : 								   add ebx, dword ptr ds : [edx + ebp * 4]

  00102	3e 03 1c aa	 add	 ebx, DWORD PTR ds:[edx+ebp*4]

; 419  : 								   mov ebp, esi

  00106	8b ee		 mov	 ebp, esi

; 420  : 								   xor ebp, ecx

  00108	33 e9		 xor	 ebp, ecx

; 421  : 								   add ebp, eax

  0010a	03 e8		 add	 ebp, eax

; 422  : 								   lea eax, dword ptr ds : [ebx + ebp]

  0010c	3e 8d 04 2b	 lea	 eax, DWORD PTR ds:[ebx+ebp]

; 423  : 								   mov ebx, dword ptr ss : [esp + 0x18]

  00110	36 8b 5c 24 18	 mov	 ebx, DWORD PTR ss:[esp+24]

; 424  : 								   cmp esi, ebx

  00115	3b f3		 cmp	 esi, ebx

; 425  : 								   jnz sa_8018_0048C5CD

  00117	75 b0		 jne	 SHORT $sa_8018_0048C5CD$13

; 426  : 								   mov dword ptr ds : [edi], ecx

  00119	3e 89 0f	 mov	 DWORD PTR ds:[edi], ecx

; 427  : 								   mov dword ptr ds : [edi + 0x4], eax

  0011c	3e 89 47 04	 mov	 DWORD PTR ds:[edi+4], eax

; 428  : 								   pop edi

  00120	5f		 pop	 edi

; 429  : 								   pop esi

  00121	5e		 pop	 esi

; 430  : 								   pop ebp

  00122	5d		 pop	 ebp

; 431  : 								   pop ebx

  00123	5b		 pop	 ebx

; 432  : 								   retn

  00124	c3		 ret	 0
$sa_8018_0048C622$11:

; 433  : 
; 434  : 							   sa_8018_0048C622 :
; 435  : 
; 436  : 		imul edx, edx, 0x61C88647

  00125	69 d2 47 86 c8
	61		 imul	 edx, edx, 1640531527

; 437  : 			test edx, edx

  0012b	85 d2		 test	 edx, edx

; 438  : 			je sa_8018_0048C675

  0012d	74 4c		 je	 SHORT $sa_8018_0048C675$12

; 439  : 			mov esi, dword ptr ss : [esp + 0x14]

  0012f	36 8b 74 24 14	 mov	 esi, DWORD PTR ss:[esp+20]
$sa_8018_0048C630$14:

; 440  : 
; 441  : 		sa_8018_0048C630 :
; 442  : 
; 443  : 						 mov ebx, ecx

  00134	8b d9		 mov	 ebx, ecx

; 444  : 						 mov ebp, ecx

  00136	8b e9		 mov	 ebp, ecx

; 445  : 						 sar ebx, 0x5

  00138	c1 fb 05	 sar	 ebx, 5

; 446  : 						 shl ebp, 0x4

  0013b	c1 e5 04	 shl	 ebp, 4

; 447  : 						 xor ebx, ebp

  0013e	33 dd		 xor	 ebx, ebp

; 448  : 						 mov ebp, edx

  00140	8b ea		 mov	 ebp, edx

; 449  : 						 sar ebp, 0xB

  00142	c1 fd 0b	 sar	 ebp, 11			; 0000000bH

; 450  : 						 and ebp, 0x3

  00145	83 e5 03	 and	 ebp, 3

; 451  : 						 add ebx, dword ptr ds : [esi + ebp * 4]

  00148	3e 03 1c ae	 add	 ebx, DWORD PTR ds:[esi+ebp*4]

; 452  : 						 mov ebp, edx

  0014c	8b ea		 mov	 ebp, edx

; 453  : 						 xor ebp, ecx

  0014e	33 e9		 xor	 ebp, ecx

; 454  : 						 add edx, 0x61C88647

  00150	81 c2 47 86 c8
	61		 add	 edx, 1640531527		; 61c88647H

; 455  : 						 add ebx, ebp

  00156	03 dd		 add	 ebx, ebp

; 456  : 						 sub eax, ebx

  00158	2b c3		 sub	 eax, ebx

; 457  : 						 mov ebx, eax

  0015a	8b d8		 mov	 ebx, eax

; 458  : 						 mov ebp, eax

  0015c	8b e8		 mov	 ebp, eax

; 459  : 						 sar ebx, 0x5

  0015e	c1 fb 05	 sar	 ebx, 5

; 460  : 						 shl ebp, 0x4

  00161	c1 e5 04	 shl	 ebp, 4

; 461  : 						 xor ebx, ebp

  00164	33 dd		 xor	 ebx, ebp

; 462  : 						 mov ebp, edx

  00166	8b ea		 mov	 ebp, edx

; 463  : 						 and ebp, 0x3

  00168	83 e5 03	 and	 ebp, 3

; 464  : 						 add ebx, dword ptr ds : [esi + ebp * 4]

  0016b	3e 03 1c ae	 add	 ebx, DWORD PTR ds:[esi+ebp*4]

; 465  : 						 mov ebp, edx

  0016f	8b ea		 mov	 ebp, edx

; 466  : 						 xor ebp, eax

  00171	33 e8		 xor	 ebp, eax

; 467  : 						 add ebx, ebp

  00173	03 dd		 add	 ebx, ebp

; 468  : 						 sub ecx, ebx

  00175	2b cb		 sub	 ecx, ebx

; 469  : 						 test edx, edx

  00177	85 d2		 test	 edx, edx

; 470  : 						 jnz sa_8018_0048C630

  00179	75 b9		 jne	 SHORT $sa_8018_0048C630$14
$sa_8018_0048C675$12:

; 471  : 
; 472  : 					 sa_8018_0048C675 :
; 473  : 
; 474  : 		mov dword ptr ds : [edi], ecx

  0017b	3e 89 0f	 mov	 DWORD PTR ds:[edi], ecx

; 475  : 			mov dword ptr ds : [edi + 0x4], eax

  0017e	3e 89 47 04	 mov	 DWORD PTR ds:[edi+4], eax

; 476  : 			pop edi

  00182	5f		 pop	 edi

; 477  : 			pop esi

  00183	5e		 pop	 esi

; 478  : 			pop ebp

  00184	5d		 pop	 ebp

; 479  : 			pop ebx

  00185	5b		 pop	 ebx

; 480  : 			retn; <= Procedure End

  00186	c3		 ret	 0
$ooookkkk$9:

; 481  : 
; 482  : 
; 483  : 
; 484  : 		ooookkkk :
; 485  : 		popad

  00187	61		 popad

; 486  : 	}
; 487  : 
; 488  : }

  00188	5f		 pop	 edi
  00189	5e		 pop	 esi
  0018a	5b		 pop	 ebx
  0018b	5d		 pop	 ebp
  0018c	c3		 ret	 0
?ú°ÚËMAX??ÓÛ?@@YAXPADH@Z ENDP				; ú°ÚËMAX??ÓÛ?
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\CCA_ServerListCtrl.cpp
;	COMDAT ?ú°à°Ôô?ÖªøúÙ¥Ùş@@YAXPAD0@Z
_TEXT	SEGMENT
_count_ÓŞÜ×?Õá$1$ = -20128				; size = 4
_IP?$1$ = -20124					; size = 4
_count$1$ = -20120					; size = 4
_i$1$ = -20116						; size = 4
_dest$GSCopy$1$ = -20112				; size = 4
_count_á³Ü×?Õá$1$ = -20108				; size = 4
_array_split$ = -20104					; size = 20000
_buf2$1 = -104						; size = 100
__$ArrayPad$ = -4					; size = 4
_src$ = 8						; size = 4
_dest$ = 12						; size = 4
?ú°à°Ôô?ÖªøúÙ¥Ùş@@YAXPAD0@Z PROC			; ú°à°Ôô?ÖªøúÙ¥Ùş, COMDAT

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 a0 4e 00 00	 mov	 eax, 20128		; 00004ea0H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]

; 255  : 	int array_split[5000];
; 256  : 	int count = split_damage(src, ';', array_split, 5000);

  0001a	8d 8d 78 b1 ff
	ff		 lea	 ecx, DWORD PTR _array_split$[ebp]
  00020	53		 push	 ebx
  00021	8b 5d 0c	 mov	 ebx, DWORD PTR _dest$[ebp]
  00024	56		 push	 esi
  00025	68 88 13 00 00	 push	 5000			; 00001388H
  0002a	51		 push	 ecx
  0002b	6a 3b		 push	 59			; 0000003bH
  0002d	50		 push	 eax
  0002e	89 9d 70 b1 ff
	ff		 mov	 DWORD PTR _dest$GSCopy$1$[ebp], ebx
  00034	e8 00 00 00 00	 call	 ?split_damage@@YAHPADDPAHI@Z ; split_damage

; 257  : 
; 258  : 	int index = 1;
; 259  : 	int count_å¤§æœæ•°é‡ = atoi((char*)array_split[index]);

  00039	ff b5 7c b1 ff
	ff		 push	 DWORD PTR _array_split$[ebp+4]
  0003f	89 85 68 b1 ff
	ff		 mov	 DWORD PTR _count$1$[ebp], eax
  00045	e8 00 00 00 00	 call	 _atoi
  0004a	83 c4 14	 add	 esp, 20			; 00000014H
  0004d	89 85 60 b1 ff
	ff		 mov	 DWORD PTR _count_ÓŞÜ×?Õá$1$[ebp], eax

; 260  : 	index++;
; 261  : 
; 262  : 	*dest = 0;

  00053	c6 03 00	 mov	 BYTE PTR [ebx], 0
  00056	be 02 00 00 00	 mov	 esi, 2

; 263  : 
; 264  : 	for (int i = 0; i < count_å¤§æœæ•°é‡; i++)

  0005b	c7 85 6c b1 ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$1$[ebp], 0
  00065	85 c0		 test	 eax, eax
  00067	0f 8e bf 00 00
	00		 jle	 $LN19@
  0006d	57		 push	 edi
  0006e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__lstrcatA@8
$LL4@:

; 265  : 	{
; 266  : 		index++; //è·³è¿‡0   0;æœ¬åœ°;3;192.168.0;æœ¬åœ°;110:9065;é›¨æ°´;146:9070;ç«‹æ˜¥;134:9075;;
; 267  : 		char* ä¸»æœºå = (char*)array_split[index];
; 268  : 		index++;
; 269  : 		int count_å°æœæ•°é‡ = atoi((char*)array_split[index]);

  00074	ff b4 b5 80 b1
	ff ff		 push	 DWORD PTR _array_split$[ebp+esi*4+8]
  0007b	e8 00 00 00 00	 call	 _atoi
  00080	83 c4 04	 add	 esp, 4
  00083	89 85 74 b1 ff
	ff		 mov	 DWORD PTR _count_á³Ü×?Õá$1$[ebp], eax

; 270  : 		index++;
; 271  : 
; 272  : 		// ä¸»æœºå|å‰¯æœº|IP|å‰¯æœº|IP\nä¸»æœºå|å‰¯æœº|IP
; 273  : 		lstrcatA(dest, ä¸»æœºå);

  00089	ff b4 b5 7c b1
	ff ff		 push	 DWORD PTR _array_split$[ebp+esi*4+4]
  00090	53		 push	 ebx
  00091	ff d7		 call	 edi

; 274  : 
; 275  : 
; 276  : 
; 277  : 		char* IPå¤´ = (char*)array_split[index];

  00093	8b 84 b5 84 b1
	ff ff		 mov	 eax, DWORD PTR _array_split$[ebp+esi*4+12]

; 278  : 		index++;
; 279  : 
; 280  : 		for (int j = 0; j < count_å°æœæ•°é‡; j++)

  0009a	33 db		 xor	 ebx, ebx
  0009c	83 c6 04	 add	 esi, 4
  0009f	89 85 64 b1 ff
	ff		 mov	 DWORD PTR _IP?$1$[ebp], eax
  000a5	39 9d 74 b1 ff
	ff		 cmp	 DWORD PTR _count_á³Ü×?Õá$1$[ebp], ebx
  000ab	7e 56		 jle	 SHORT $LN6@
  000ad	0f 1f 00	 npad	 3
$LL7@:

; 281  : 		{
; 282  : 			char* å‰¯æœºå = (char*)array_split[index];
; 283  : 			index++;
; 284  : 			char* IPå°¾ = (char*)array_split[index];
; 285  : 			index++;

  000b0	8d 7e 02	 lea	 edi, DWORD PTR [esi+2]

; 286  : 
; 287  : 			if (index > count)

  000b3	3b bd 68 b1 ff
	ff		 cmp	 edi, DWORD PTR _count$1$[ebp]
  000b9	7f 70		 jg	 SHORT $LN20@

; 288  : 			{
; 289  : 				return;
; 290  : 			}
; 291  : 
; 292  : 			char buf2[100];
; 293  : 			wsprintfA(buf2, "|%s|%s.%s", å‰¯æœºå, IPå¤´, IPå°¾);

  000bb	ff b4 b5 7c b1
	ff ff		 push	 DWORD PTR _array_split$[ebp+esi*4+4]
  000c2	50		 push	 eax
  000c3	ff b4 b5 78 b1
	ff ff		 push	 DWORD PTR _array_split$[ebp+esi*4]
  000ca	8d 45 98	 lea	 eax, DWORD PTR _buf2$1[ebp]
  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_09KCBLGBPG@?$HM?$CFs?$HM?$CFs?4?$CFs@
  000d2	50		 push	 eax
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  000d9	83 c4 14	 add	 esp, 20			; 00000014H

; 294  : 			lstrcatA(dest, buf2);

  000dc	8d 45 98	 lea	 eax, DWORD PTR _buf2$1[ebp]
  000df	50		 push	 eax
  000e0	ff b5 70 b1 ff
	ff		 push	 DWORD PTR _dest$GSCopy$1$[ebp]
  000e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcatA@8
  000ec	8b 85 64 b1 ff
	ff		 mov	 eax, DWORD PTR _IP?$1$[ebp]
  000f2	43		 inc	 ebx
  000f3	8b f7		 mov	 esi, edi
  000f5	3b 9d 74 b1 ff
	ff		 cmp	 ebx, DWORD PTR _count_á³Ü×?Õá$1$[ebp]
  000fb	7c b3		 jl	 SHORT $LL7@
  000fd	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__lstrcatA@8
$LN6@:

; 295  : 
; 296  : 		}
; 297  : 		index++;
; 298  : 
; 299  : 		lstrcatA(dest, "\n");

  00103	8b 9d 70 b1 ff
	ff		 mov	 ebx, DWORD PTR _dest$GSCopy$1$[ebp]
  00109	46		 inc	 esi
  0010a	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  0010f	53		 push	 ebx
  00110	ff d7		 call	 edi
  00112	8b 85 6c b1 ff
	ff		 mov	 eax, DWORD PTR _i$1$[ebp]
  00118	40		 inc	 eax
  00119	89 85 6c b1 ff
	ff		 mov	 DWORD PTR _i$1$[ebp], eax
  0011f	3b 85 60 b1 ff
	ff		 cmp	 eax, DWORD PTR _count_ÓŞÜ×?Õá$1$[ebp]
  00125	0f 8c 49 ff ff
	ff		 jl	 $LL4@
$LN20@:
  0012b	5f		 pop	 edi
$LN19@:

; 300  : 
; 301  : 	}
; 302  : 
; 303  : }

  0012c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012f	5e		 pop	 esi
  00130	33 cd		 xor	 ecx, ebp
  00132	5b		 pop	 ebx
  00133	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00138	8b e5		 mov	 esp, ebp
  0013a	5d		 pop	 ebp
  0013b	c3		 ret	 0
?ú°à°Ôô?ÖªøúÙ¥Ùş@@YAXPAD0@Z ENDP			; ú°à°Ôô?ÖªøúÙ¥Ùş
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\CCA_ServerListCtrl.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\CCA_ServerListCtrl.cpp
;	COMDAT ?getStringFromIndexWithDelim_body@@YAHPAD0H0H0H@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_i$1$ = -4						; size = 4
_src$ = 8						; size = 4
_delim$ = 12						; size = 4
_index$ = 16						; size = 4
_buf$ = 20						; size = 4
_buflen$ = 24						; size = 4
_file$ = 28						; size = 4
_line$ = 32						; size = 4
?getStringFromIndexWithDelim_body@@YAHPAD0H0H0H@Z PROC	; getStringFromIndexWithDelim_body, COMDAT

; 179  : {//ttom this function all change,copy from the second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 180  : 	int i;          /* ä¼™â–¡çš¿  é†’ */
; 181  : 	int length = 0;  /* æ½¸æ›°è¯·ä»„å‡¶  ä¾¬  åŠèµ¢ä»Š */

  00006	33 d2		 xor	 edx, edx

; 182  : 	int addlen = 0;   /* ç®«ä»Šæœ¨æœˆèµ¢ä»Š */

  00008	33 c9		 xor	 ecx, ecx
  0000a	53		 push	 ebx

; 183  : 	int oneByteMode = 0; /* ã„ ç”°å¥¶ç„ä¹’â–¡ç‰äº•ï¼‚ */
; 184  : 
; 185  : 	if (strlen(delim) == 1){ // è…¹ç»¸äº’ã„ ç”°å¥¶ç„å…æ—¥ã„ ç”°å¥¶ç„ä¹’â–¡ç‰åå…æœˆ

  0000b	8b 5d 0c	 mov	 ebx, DWORD PTR _delim$[ebp]
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8b fb		 mov	 edi, ebx
  00012	8d 77 01	 lea	 esi, DWORD PTR [edi+1]
$LL18@getStringF:
  00015	8a 07		 mov	 al, BYTE PTR [edi]
  00017	47		 inc	 edi
  00018	84 c0		 test	 al, al
  0001a	75 f9		 jne	 SHORT $LL18@getStringF
  0001c	2b fe		 sub	 edi, esi

; 186  : 		oneByteMode = 1;// å…¬åŠç«¯ã„¡ç”°å¥¶ç„  ä¾¬åæ°‘å°¼æ°¸å¼ä»„å…ä¸­
; 187  : 	}
; 188  : 	for (i = 0; i < index; i++){

  0001e	33 f6		 xor	 esi, esi
  00020	89 75 fc	 mov	 DWORD PTR _i$1$[ebp], esi
  00023	8b 75 08	 mov	 esi, DWORD PTR _src$[ebp]
  00026	39 4d 10	 cmp	 DWORD PTR _index$[ebp], ecx
  00029	7e 4e		 jle	 SHORT $LN3@getStringF
  0002b	0f 1f 44 00 00	 npad	 5
$LL4@getStringF:

; 189  : 		char* last;
; 190  : 		src += addlen;/* å¿ƒå‹¾äº•åŒ€å‡¶èµ¢ä»Šæ¯›ç®«å… */

  00030	03 f1		 add	 esi, ecx

; 191  : 
; 192  : 		if (oneByteMode){

  00032	83 ff 01	 cmp	 edi, 1
  00035	75 0c		 jne	 SHORT $LN6@getStringF

; 193  : 			// ã„ ç”°å¥¶ç„ä¹’â–¡ç‰åˆ†åŒ€å‡¶æ—¥ä»‡åˆ‡æ—¥åŒ¹è…¹ç»¸
; 194  : 			last = ScanOneByte(src, delim[0]);

  00037	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0003a	50		 push	 eax
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 ?ScanOneByte@@YAPADPADD@Z ; ScanOneByte

; 195  : 		}

  00041	eb 07		 jmp	 SHORT $LN21@getStringF
$LN6@getStringF:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h

; 520  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  00043	53		 push	 ebx
  00044	56		 push	 esi
  00045	e8 00 00 00 00	 call	 _strstr
$LN21@getStringF:
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\CCA_ServerListCtrl.cpp

; 199  : 		if (last == NULL){

  0004a	8b d0		 mov	 edx, eax
  0004c	83 c4 08	 add	 esp, 8
  0004f	85 d2		 test	 edx, edx
  00051	74 42		 je	 SHORT $LN14@getStringF

; 206  : 				/*åˆ‡æ–¤ä¸¹å‡å¿ƒå‹¾äº•åŒ€å‡¶*/
; 207  : 				return TRUE;
; 208  : 
; 209  : 			/*å¿ƒå‹¾äº•æ—¥å…äº•åŒ€å‡¶*/
; 210  : 			return FALSE;
; 211  : 		}
; 212  : 
; 213  : 		/*
; 214  : 		* å¿ƒå‹¾äº•åŒ€å‡¶èµ­åˆ  èµ“åŠåŒ  åŠçŠ’æ¯›è²æˆ·æœˆ
; 215  : 		* å‹¾å¼•æ›°å—‰æ¿ æ—¥æœ¨åŒ–ä¸­æœˆ  ä¾¬  åŠèµ¢ä»Š
; 216  : 		*/
; 217  : 		length = last - src;
; 218  : 
; 219  : 		/*
; 220  : 		* æˆšåŠä¼™â–¡çš¿åŠå•ƒåå¿ƒå‹¾äº•åŒ€å‡¶èµ¢ä»Šåˆ delim åŠèµ¢ä»Šæ¯›ç®«ä»„åŒ–äº‘ä»
; 221  : 		*/
; 222  : 		addlen = length + strlen(delim);

  00053	8b c3		 mov	 eax, ebx
  00055	2b d6		 sub	 edx, esi
  00057	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0005a	89 4d f8	 mov	 DWORD PTR tv73[ebp], ecx
  0005d	0f 1f 00	 npad	 3
$LL19@getStringF:
  00060	8a 08		 mov	 cl, BYTE PTR [eax]
  00062	40		 inc	 eax
  00063	84 c9		 test	 cl, cl
  00065	75 f9		 jne	 SHORT $LL19@getStringF
  00067	2b 45 f8	 sub	 eax, DWORD PTR tv73[ebp]
  0006a	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]
  0006d	8b 45 fc	 mov	 eax, DWORD PTR _i$1$[ebp]
  00070	40		 inc	 eax
  00071	89 45 fc	 mov	 DWORD PTR _i$1$[ebp], eax
  00074	3b 45 10	 cmp	 eax, DWORD PTR _index$[ebp]
  00077	7c b7		 jl	 SHORT $LL4@getStringF
$LN3@getStringF:

; 223  : 	}
; 224  : 	strncpysafe(buf, buflen, src, length);

  00079	52		 push	 edx
  0007a	56		 push	 esi
  0007b	ff 75 18	 push	 DWORD PTR _buflen$[ebp]
  0007e	ff 75 14	 push	 DWORD PTR _buf$[ebp]
  00081	e8 00 00 00 00	 call	 ?strncpysafe@@YAXPADIPBDH@Z ; strncpysafe
  00086	83 c4 10	 add	 esp, 16			; 00000010H

; 225  : 
; 226  : 	return TRUE;

  00089	b8 01 00 00 00	 mov	 eax, 1
  0008e	5f		 pop	 edi

; 227  : }

  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
$LN14@getStringF:

; 200  : 			/*
; 201  : 			* å¿ƒå‹¾äº•æ—¥å…äº•åŒ€å‡¶åŠåŒ¹å…å±¯åŒ–æˆŠç–‹â–¡ä»„åŒ– returnï¼»
; 202  : 			*/
; 203  : 			strcpysafe(buf, buflen, src);

  00095	56		 push	 esi
  00096	ff 75 18	 push	 DWORD PTR _buflen$[ebp]
  00099	ff 75 14	 push	 DWORD PTR _buf$[ebp]
  0009c	e8 00 00 00 00	 call	 ?strcpysafe@@YAXPADIPBD@Z ; strcpysafe

; 204  : 
; 205  : 			if (i == index - 1)

  000a1	8b 4d 10	 mov	 ecx, DWORD PTR _index$[ebp]
  000a4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a7	49		 dec	 ecx
  000a8	33 c0		 xor	 eax, eax
  000aa	39 4d fc	 cmp	 DWORD PTR _i$1$[ebp], ecx
  000ad	5f		 pop	 edi

; 227  : }

  000ae	5e		 pop	 esi
  000af	0f 94 c0	 sete	 al
  000b2	5b		 pop	 ebx
  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c3		 ret	 0
?getStringFromIndexWithDelim_body@@YAHPAD0H0H0H@Z ENDP	; getStringFromIndexWithDelim_body
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\CCA_ServerListCtrl.cpp
;	COMDAT ?ScanOneByte@@YAPADPADD@Z
_TEXT	SEGMENT
_src$ = 8						; size = 4
_delim$ = 12						; size = 1
?ScanOneByte@@YAPADPADD@Z PROC				; ScanOneByte, COMDAT

; 153  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 154  : 	// Nuke
; 155  : 	if (!src) return NULL;

  00003	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 23		 je	 SHORT $LN3@ScanOneByt

; 156  : 
; 157  : 	//   ä¾¬  äº’å…ä»å…æœˆå¼•åŒ¹è…¹ç»¸
; 158  : 	for (; src[0] != '\0'; src++){

  0000a	8a 08		 mov	 cl, BYTE PTR [eax]
  0000c	84 c9		 test	 cl, cl
  0000e	74 1d		 je	 SHORT $LN3@ScanOneByt
  00010	8a 55 0c	 mov	 dl, BYTE PTR _delim$[ebp]
$LL4@ScanOneByt:

; 159  : 		if (IS_2BYTEWORD(src[0])){

  00013	80 f9 ff	 cmp	 cl, -1
  00016	7f 09		 jg	 SHORT $LN6@ScanOneByt

; 160  : 			// èˆå‰©åˆ†ï¼»å…¬åŠæ¡¦å®åã„ ç”°å¥¶ç„èŠ´åŒåè¤¡å¼•å…­æœˆï¼»
; 161  : 			// å‡¶åˆ†ä»„ã„ ç”°å¥¶ç„ä»„äº•å…ä¸­æ¡¦å®åå…¬ä¸¹ä»„å…ä¸­
; 162  : 			if (src[1] != 0){

  00018	80 78 01 00	 cmp	 BYTE PTR [eax+1], 0
  0001c	74 07		 je	 SHORT $LN2@ScanOneByt

; 163  : 				src++;

  0001e	40		 inc	 eax

; 164  : 			}
; 165  : 			continue;

  0001f	eb 04		 jmp	 SHORT $LN2@ScanOneByt
$LN6@ScanOneByt:

; 166  : 		}
; 167  : 		//   å‰©åˆ†åŒ€å‡¶ï¼»ä»‡ä»‡åŒ¹è¦†æ“‚åŠ  ä¾¬åˆ  èƒœ
; 168  : 		if (src[0] == delim){

  00021	3a ca		 cmp	 cl, dl
  00023	74 0a		 je	 SHORT $LN1@ScanOneByt
$LN2@ScanOneByt:

; 156  : 
; 157  : 	//   ä¾¬  äº’å…ä»å…æœˆå¼•åŒ¹è…¹ç»¸
; 158  : 	for (; src[0] != '\0'; src++){

  00025	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00028	40		 inc	 eax
  00029	84 c9		 test	 cl, cl
  0002b	75 e6		 jne	 SHORT $LL4@ScanOneByt
$LN3@ScanOneByt:

; 169  : 			return src;
; 170  : 		}
; 171  : 	}
; 172  : 	// ä¼™â–¡çš¿  ä»ƒå‡¶æ—¥è‹‡å‹¾äº•æ—¥å…äº•åŒ€å‡¶ï¼»
; 173  : 	return NULL;

  0002d	33 c0		 xor	 eax, eax
$LN1@ScanOneByt:

; 174  : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?ScanOneByte@@YAPADPADD@Z ENDP				; ScanOneByte
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\CCA_ServerListCtrl.cpp
;	COMDAT ?strcpysafe@@YAXPADIPBD@Z
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_n$ = 12						; size = 4
_src$ = 16						; size = 4
?strcpysafe@@YAXPADIPBD@Z PROC				; strcpysafe, COMDAT

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 116  : 	/*
; 117  : 	* src äº•æ—¥ dest å°ºæˆŠç–‹â–¡å…æœˆ.
; 118  : 	* strcpy, strncpy åŒ¹å dest æ–¹æ›° æˆŠç–‹â–¡å…æœˆæ±¹äº’
; 119  : 	*   äº”ä¸­å‡›åè£Ÿå°‘åˆ,ä¸¢ä¹’ä¼‰é™†å¤±å¼æœ¬æ—¦äº’ç²Ÿæœˆ.
; 120  : 	* ä»‡æœ¨æ¯›  ä»€å•ƒå, strncpy äº’ä¸æœˆäº’ strlen( src ) äº’ n æ–¹æ›°
; 121  : 	*   äº”ä¸­å‡›åå, dest åŠ    äº’ NULL   ä¾¬åˆåå…æ—¥å…ä¸­.
; 122  : 	*
; 123  : 	* ä»„å‡¶äº’åŒ€åŒ– dest åŠ  äº”ä»Šæ–¹æ›° src åŠå¹»ä¸¹äº’èµ¢ä¸­å‡›åå
; 124  : 	* n-1 åŒ¹ strncpy æ¯›å…æœˆ. å‡ä»Šä¸­å‡›åå…¬åŠå¼•å¼•æˆŠç–‹â–¡å…æœˆ
; 125  : 	*
; 126  : 	* n äº’  åŠå‡›åäº‘äº•ä»„ä»å…æœˆåŠåŒ¹  åŠå‡›å çª’æ‰‹ä»„å…ä¸­ï¼»
; 127  : 	*
; 128  : 	*/
; 129  : 	// Nuke +1 (08/25): Danger if src=0
; 130  : 	if (!src) {

  00003	8b 45 10	 mov	 eax, DWORD PTR _src$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 08		 jne	 SHORT $LN2@strcpysafe

; 131  : 		*dest = '\0';

  0000a	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0000d	c6 00 00	 mov	 BYTE PTR [eax], 0

; 149  : 
; 150  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
$LN2@strcpysafe:
  00012	57		 push	 edi

; 132  : 		return;
; 133  : 	}
; 134  : 	if (n <= 0)        /* çª’æ‰‹ä»„å…ä¸­   */

  00013	8b 7d 0c	 mov	 edi, DWORD PTR _n$[ebp]
  00016	85 ff		 test	 edi, edi
  00018	74 44		 je	 SHORT $LN13@strcpysafe

; 135  : 		return;
; 136  : 
; 137  : 	/*  ä»‡åŠå‡›é³”åŒ¹ï½ n >= 1 åŠ¨æ™“äº’ç‘çƒ‚  */
; 138  : 	/*  NULL  ä¾¬æ¯›å“”  ä»„åŒ–  èƒœå…æœˆ  */
; 139  : 	else if (n < strlen(src) + 1){

  0001a	8b d0		 mov	 edx, eax
  0001c	56		 push	 esi
  0001d	8d 72 01	 lea	 esi, DWORD PTR [edx+1]
$LL12@strcpysafe:
  00020	8a 0a		 mov	 cl, BYTE PTR [edx]
  00022	42		 inc	 edx
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL12@strcpysafe
  00027	2b d6		 sub	 edx, esi
  00029	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
  0002c	3b f9		 cmp	 edi, ecx
  0002e	73 1a		 jae	 SHORT $LN5@strcpysafe

; 140  : 		/*
; 141  : 		* ç”°æ°¸ç™½å¤®äº’ç®«æ›°å…ä¸­åŠåŒ¹ n - 1(NULL  ä¾¬)
; 142  : 		* åŒ¹ strncpy æ¯›è£Ÿå°‘
; 143  : 		*/
; 144  : 		strncpy2(dest, src, n - 1);

  00030	8b 75 08	 mov	 esi, DWORD PTR _dest$[ebp]
  00033	8d 4f ff	 lea	 ecx, DWORD PTR [edi-1]
  00036	51		 push	 ecx
  00037	50		 push	 eax
  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 ?strncpy2@@YAPADPADPBDI@Z ; strncpy2
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 145  : 		dest[n - 1] = '\0';

  00041	c6 44 3e ff 00	 mov	 BYTE PTR [esi+edi-1], 0
  00046	5e		 pop	 esi
  00047	5f		 pop	 edi

; 149  : 
; 150  : }

  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
$LN5@strcpysafe:

; 146  : 	}
; 147  : 	else
; 148  : 		strcpy(dest, src);

  0004a	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  0004d	2b d0		 sub	 edx, eax
  0004f	90		 npad	 1
$LL8@strcpysafe:
  00050	8a 08		 mov	 cl, BYTE PTR [eax]
  00052	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00055	88 4c 02 ff	 mov	 BYTE PTR [edx+eax-1], cl
  00059	84 c9		 test	 cl, cl
  0005b	75 f3		 jne	 SHORT $LL8@strcpysafe
  0005d	5e		 pop	 esi
$LN13@strcpysafe:
  0005e	5f		 pop	 edi

; 149  : 
; 150  : }

  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
?strcpysafe@@YAXPADIPBD@Z ENDP				; strcpysafe
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\CCA_ServerListCtrl.cpp
;	COMDAT ?strncpysafe@@YAXPADIPBDH@Z
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_n$ = 12						; size = 4
_src$ = 16						; size = 4
_length$ = 20						; size = 4
?strncpysafe@@YAXPADIPBDH@Z PROC			; strncpysafe, COMDAT

; 75   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 76   : 	/*
; 77   : 	* src äº•æ—¥ dest å length æˆŠç–‹â–¡å…æœˆ
; 78   : 	* strcpy, strncpy åŒ¹å dest æ–¹æ›° æˆŠç–‹â–¡å…æœˆæ±¹äº’
; 79   : 	*   äº”ä¸­å‡›åè£Ÿå°‘åˆ,ä¸¢ä¹’ä¼‰é™†å¤±å¼æœ¬æ—¦äº’ç²Ÿæœˆ.
; 80   : 	* ä»‡åŠæ¥®é†’åŒ¹åï½strlen( src ) åˆ length åŠå‡ä»Šä¸­å¹»ä¸¹
; 81   : 	* (  ç«¯åæˆŠç–‹â–¡å…æœˆæ±¹) åˆ dest åŠæ‰”å¥¶æœ¯æ¯›  å±¯åŒ–ï½
; 82   : 	* strcpysafe åˆ  å…ƒä»ªæ¯›å…æœˆï¼»
; 83   : 	*/
; 84   : 
; 85   : 	int Short;
; 86   : 	Short = min(strlen(src), length);

  00003	8b 55 10	 mov	 edx, DWORD PTR _src$[ebp]
  00006	8b ca		 mov	 ecx, edx
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  0000e	66 90		 npad	 2
$LL9@strncpysaf:
  00010	8a 01		 mov	 al, BYTE PTR [ecx]
  00012	41		 inc	 ecx
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL9@strncpysaf
  00017	8b 7d 14	 mov	 edi, DWORD PTR _length$[ebp]
  0001a	2b ce		 sub	 ecx, esi
  0001c	3b cf		 cmp	 ecx, edi
  0001e	73 0e		 jae	 SHORT $LN7@strncpysaf
  00020	8b fa		 mov	 edi, edx
  00022	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
$LL10@strncpysaf:
  00025	8a 07		 mov	 al, BYTE PTR [edi]
  00027	47		 inc	 edi
  00028	84 c0		 test	 al, al
  0002a	75 f9		 jne	 SHORT $LL10@strncpysaf
  0002c	2b f9		 sub	 edi, ecx
$LN7@strncpysaf:

; 87   : 
; 88   : 	/* NULL  ä¾¬ æ¯›å“”  ä»„å‡¶  èƒœ */
; 89   : 	if (n < Short + 1){

  0002e	8b 5d 0c	 mov	 ebx, DWORD PTR _n$[ebp]
  00031	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00034	3b d8		 cmp	 ebx, eax
  00036	73 1b		 jae	 SHORT $LN2@strncpysaf

; 90   : 		/*
; 91   : 		* ç”°æ°¸ç™½å¤®äº’ç®«æ›°å…ä¸­åŠåŒ¹ n - 1(NULL  ä¾¬)
; 92   : 		* åŒ¹ strncpy æ¯›è£Ÿå°‘
; 93   : 		*/
; 94   : 		strncpy2(dest, src, n - 1);

  00038	8b 75 08	 mov	 esi, DWORD PTR _dest$[ebp]
  0003b	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  0003e	50		 push	 eax
  0003f	52		 push	 edx
  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ?strncpy2@@YAPADPADPBDI@Z ; strncpy2

; 110  : 
; 111  : 	}
; 112  : }

  00046	83 c4 0c	 add	 esp, 12			; 0000000cH
  00049	c6 44 1e ff 00	 mov	 BYTE PTR [esi+ebx-1], 0
  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN2@strncpysaf:

; 95   : 		dest[n - 1] = '\0';
; 96   : 
; 97   : 	}
; 98   : 	else if (n <= 0){

  00053	85 db		 test	 ebx, ebx
  00055	74 12		 je	 SHORT $LN5@strncpysaf

; 99   : 		return;
; 100  : 	}
; 101  : 	else{
; 102  : 		/*
; 103  : 		* ç”°æ°¸ç™½å¤®åèœ—åŒåä¸æœˆåŠåŒ¹ Short åŒ¹strncpyæ¯›è£Ÿå°‘
; 104  : 		* å…äº‘ src åå Short åŠèµ¢ä»Š  å NULL äº’å…ä¸­åŠåŒ¹ï½
; 105  : 		* dest åå é¦¨ç¬›ä»„åŒ–äº‘ä»ï¼»
; 106  : 		*/
; 107  : 
; 108  : 		strncpy2(dest, src, Short);

  00057	8b 75 08	 mov	 esi, DWORD PTR _dest$[ebp]
  0005a	57		 push	 edi
  0005b	52		 push	 edx
  0005c	56		 push	 esi
  0005d	e8 00 00 00 00	 call	 ?strncpy2@@YAPADPADPBDI@Z ; strncpy2

; 109  : 		dest[Short] = '\0';

  00062	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0

; 110  : 
; 111  : 	}
; 112  : }

  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@strncpysaf:
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?strncpysafe@@YAXPADIPBDH@Z ENDP			; strncpysafe
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\CCA_ServerListCtrl.cpp
;	COMDAT ?strncpy2@@YAPADPADPBDI@Z
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_n$ = 16						; size = 4
?strncpy2@@YAPADPADPBDI@Z PROC				; strncpy2, COMDAT

; 46   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 	if (n > 0){

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _n$[ebp]
  0000b	57		 push	 edi
  0000c	85 f6		 test	 esi, esi
  0000e	74 2b		 je	 SHORT $LN3@strncpy2

; 48   : 		char*   d = dest;
; 49   : 		const char*   s = src;
; 50   : 		int i;
; 51   : 		for (i = 0; i<n; i++){

  00010	8b 7d 0c	 mov	 edi, DWORD PTR _src$[ebp]
  00013	33 c0		 xor	 eax, eax
  00015	8b d1		 mov	 edx, ecx
$LL4@strncpy2:

; 52   : 			if (*(s + i) == 0){

  00017	8a 1c 38	 mov	 bl, BYTE PTR [eax+edi]
  0001a	84 db		 test	 bl, bl
  0001c	74 32		 je	 SHORT $LN12@strncpy2

; 56   : 			}
; 57   : 			if (*(s + i) & 0x80){

  0001e	8a cb		 mov	 cl, bl
  00020	88 1a		 mov	 BYTE PTR [edx], bl
  00022	80 e1 80	 and	 cl, 128			; 00000080H
  00025	74 0b		 je	 SHORT $LN2@strncpy2

; 58   : 				*(d + i) = *(s + i);
; 59   : 				i++;

  00027	40		 inc	 eax
  00028	42		 inc	 edx

; 60   : 				if (i >= n){

  00029	3b c6		 cmp	 eax, esi
  0002b	73 15		 jae	 SHORT $LN13@strncpy2

; 61   : 					*(d + i - 1) = '\0';
; 62   : 					break;
; 63   : 				}
; 64   : 				*(d + i) = *(s + i);

  0002d	8a 0c 38	 mov	 cl, BYTE PTR [eax+edi]
  00030	88 0a		 mov	 BYTE PTR [edx], cl
$LN2@strncpy2:

; 48   : 		char*   d = dest;
; 49   : 		const char*   s = src;
; 50   : 		int i;
; 51   : 		for (i = 0; i<n; i++){

  00032	40		 inc	 eax
  00033	42		 inc	 edx
  00034	3b c6		 cmp	 eax, esi
  00036	72 df		 jb	 SHORT $LL4@strncpy2

; 65   : 			}
; 66   : 			else
; 67   : 				*(d + i) = *(s + i);
; 68   : 		}
; 69   : 	}
; 70   : 	return dest;

  00038	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
$LN3@strncpy2:
  0003b	5f		 pop	 edi

; 71   : }

  0003c	5e		 pop	 esi
  0003d	8b c1		 mov	 eax, ecx
  0003f	5b		 pop	 ebx
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
$LN13@strncpy2:

; 65   : 			}
; 66   : 			else
; 67   : 				*(d + i) = *(s + i);
; 68   : 		}
; 69   : 	}
; 70   : 	return dest;

  00042	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00045	8b c1		 mov	 eax, ecx
  00047	5f		 pop	 edi

; 71   : }

  00048	5e		 pop	 esi
  00049	c6 42 ff 00	 mov	 BYTE PTR [edx-1], 0
  0004d	5b		 pop	 ebx
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
$LN12@strncpy2:

; 53   : 				/*  æˆŠç–‹â–¡ä»„äº‘æ­¹åŒ€å‡¶æ—¥ NULL   ä¾¬æ¯›  æœ¨æœˆ   */
; 54   : 				*(d + i) = '\0';
; 55   : 				return dest;

  00050	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00053	5f		 pop	 edi

; 71   : }

  00054	5e		 pop	 esi
  00055	c6 02 00	 mov	 BYTE PTR [edx], 0
  00058	5b		 pop	 ebx
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?strncpy2@@YAPADPADPBDI@Z ENDP				; strncpy2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\CCA_ServerListCtrl.cpp
;	COMDAT ?split_damage@@YAHPADDPAHI@Z
_TEXT	SEGMENT
_src$ = 8						; size = 4
_delim$ = 12						; size = 1
_pArraySplitAddr$ = 16					; size = 4
_maxCount$ = 20						; size = 4
?split_damage@@YAHPADDPAHI@Z PROC			; split_damage, COMDAT

; 231  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 232  : 
; 233  : 	unsigned int count = 1;	//æœ€å°‘èƒ½åˆ†å‰²1ä¸ªæˆå‘˜(å½“åˆ†éš”ç¬¦ä¸å­˜åœ¨çš„æ—¶å€™ï¼Œè¿”å›è‡ªèº«)
; 234  : 	*pArraySplitAddr = (int)src;

  00003	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00006	ba 01 00 00 00	 mov	 edx, 1
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	8b 75 10	 mov	 esi, DWORD PTR _pArraySplitAddr$[ebp]
  00010	57		 push	 edi
  00011	89 06		 mov	 DWORD PTR [esi], eax

; 235  : 	pArraySplitAddr++;

  00013	83 c6 04	 add	 esi, 4

; 236  : 	int i = 0;
; 237  : 	while (*(src + i)){	//å½“é0çš„æ—¶å€™ç»§ç»­å¾ªç¯

  00016	8a 08		 mov	 cl, BYTE PTR [eax]
  00018	84 c9		 test	 cl, cl
  0001a	74 22		 je	 SHORT $LN12@split_dama

; 232  : 
; 233  : 	unsigned int count = 1;	//æœ€å°‘èƒ½åˆ†å‰²1ä¸ªæˆå‘˜(å½“åˆ†éš”ç¬¦ä¸å­˜åœ¨çš„æ—¶å€™ï¼Œè¿”å›è‡ªèº«)
; 234  : 	*pArraySplitAddr = (int)src;

  0001c	8b 7d 14	 mov	 edi, DWORD PTR _maxCount$[ebp]
  0001f	8a 5d 0c	 mov	 bl, BYTE PTR _delim$[ebp]
$LL2@split_dama:

; 238  : 		if (*(src + i) == delim){	//å¦‚æœæ‰¾åˆ°äº†åˆ†éš”ç¬¦

  00022	3a cb		 cmp	 cl, bl
  00024	75 10		 jne	 SHORT $LN4@split_dama

; 239  : 			if (count >= maxCount){

  00026	3b d7		 cmp	 edx, edi
  00028	73 14		 jae	 SHORT $LN12@split_dama

; 240  : 				return count;
; 241  : 			}
; 242  : 			*(src + i) = 0;	//å°†åˆ†éš”ç¬¦ç½®0
; 243  : 			*pArraySplitAddr = (int)(src + i + 1);	//å°†åˆ†éš”ç¬¦çš„ä¸‹ä¸€ä¸ªå­—èŠ‚åœ°å€å‚¨å­˜

  0002a	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0002d	c6 00 00	 mov	 BYTE PTR [eax], 0
  00030	89 0e		 mov	 DWORD PTR [esi], ecx

; 244  : 			pArraySplitAddr++;

  00032	83 c6 04	 add	 esi, 4

; 245  : 			count++;

  00035	42		 inc	 edx
$LN4@split_dama:

; 246  : 		}
; 247  : 		i++;

  00036	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00039	40		 inc	 eax
  0003a	84 c9		 test	 cl, cl
  0003c	75 e4		 jne	 SHORT $LL2@split_dama
$LN12@split_dama:
  0003e	5f		 pop	 edi

; 248  : 	}
; 249  : 
; 250  : 	return count;
; 251  : }

  0003f	5e		 pop	 esi
  00040	8b c2		 mov	 eax, edx
  00042	5b		 pop	 ebx
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?split_damage@@YAHPADDPAHI@Z ENDP			; split_damage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);
; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1777 : 
; 1778 :         __crt_va_end(_ArgList);
; 1779 :         return _Result;
; 1780 :     }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
