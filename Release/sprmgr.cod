; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29336.0 

	TITLE	C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\sprmgr.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?lpBattleSurface@@3PAUIDirectDrawSurface@@A	; lpBattleSurface
PUBLIC	?SurfaceSizeX@@3HA				; SurfaceSizeX
PUBLIC	?SurfaceSizeY@@3HA				; SurfaceSizeY
PUBLIC	?SurfaceDate@@3IA				; SurfaceDate
PUBLIC	?SpriteInfo@@3PAUSPRITE_INFO@@A			; SpriteInfo
PUBLIC	?SurfaceInfo@@3PAUsurfaceInfo@@A		; SurfaceInfo
PUBLIC	?SurfaceCnt@@3HA				; SurfaceCnt
PUBLIC	?VramSurfaceCnt@@3HA				; VramSurfaceCnt
PUBLIC	?SysramSurfaceCnt@@3HA				; SysramSurfaceCnt
PUBLIC	?SurfaceSearchPoint@@3HA			; SurfaceSearchPoint
_BSS	SEGMENT
?lpBattleSurface@@3PAUIDirectDrawSurface@@A DD 01H DUP (?) ; lpBattleSurface
?SurfaceSizeX@@3HA DD 01H DUP (?)			; SurfaceSizeX
?SurfaceSizeY@@3HA DD 01H DUP (?)			; SurfaceSizeY
?SpriteInfo@@3PAUSPRITE_INFO@@A DB 016e3600H DUP (?)	; SpriteInfo
?SurfaceInfo@@3PAUsurfaceInfo@@A DB 015000H DUP (?)	; SurfaceInfo
?SurfaceCnt@@3HA DD 01H DUP (?)				; SurfaceCnt
?VramSurfaceCnt@@3HA DD 01H DUP (?)			; VramSurfaceCnt
?SysramSurfaceCnt@@3HA DD 01H DUP (?)			; SysramSurfaceCnt
?SurfaceSearchPoint@@3HA DD 01H DUP (?)			; SurfaceSearchPoint
_BSS	ENDS
_DATA	SEGMENT
?SurfaceDate@@3IA DD 03H				; SurfaceDate
_DATA	ENDS
PUBLIC	?InitOffScreenSurface@@YAHXZ			; InitOffScreenSurface
PUBLIC	?InitSurfaceInfo@@YAXXZ				; InitSurfaceInfo
PUBLIC	?InitSpriteInfo@@YAXXZ				; InitSpriteInfo
PUBLIC	?LoadBmp@@YAHH@Z				; LoadBmp
PUBLIC	?AllocateBmpToSurface@@YAXH@Z			; AllocateBmpToSurface
EXTRN	?ClearSurface@@YAXPAUIDirectDrawSurface@@@Z:PROC ; ClearSurface
EXTRN	?CreateSurface@@YAPAUIDirectDrawSurface@@FFKI@Z:PROC ; CreateSurface
EXTRN	?DrawBitmapToSurface2@@YAXPAUsurfaceInfo@@HHHHPAUtagBITMAPINFO@@@Z:PROC ; DrawBitmapToSurface2
EXTRN	?realGetImage@@YAHHPAPAEPAH1@Z:PROC		; realGetImage
EXTRN	?ResoMode@@3HA:DWORD				; ResoMode
EXTRN	?pRealBinBits@@3PADA:DWORD			; pRealBinBits
EXTRN	?RealBinWidth@@3HA:DWORD			; RealBinWidth
EXTRN	?RealBinHeight@@3HA:DWORD			; RealBinHeight
EXTRN	?NewColor16Flg@@3HA:DWORD			; NewColor16Flg
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\sprmgr.cpp
;	COMDAT ?AllocateBmpToSurface@@YAXH@Z
_TEXT	SEGMENT
tv511 = -36						; size = 4
_prevSurfaceInfo$ = -36					; size = 4
_totalSurface$1$ = -32					; size = 4
tv492 = -28						; size = 4
_totalSurfaceCnt$1$ = -24				; size = 4
_amariSizeY$1$ = -20					; size = 4
tv487 = -16						; size = 4
_bmpWidth$1$ = -12					; size = 4
_bmpHeight$1$ = -8					; size = 4
_amariSizeX$1$ = -4					; size = 4
_bmpNo$ = 8						; size = 4
?AllocateBmpToSurface@@YAXH@Z PROC			; AllocateBmpToSurface, COMDAT

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 45   : 	int bmpWidth = RealBinWidth;	// ????????

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ?RealBinWidth@@3HA ; RealBinWidth
  0000b	89 45 f4	 mov	 DWORD PTR _bmpWidth$1$[ebp], eax
  0000e	53		 push	 ebx
  0000f	56		 push	 esi

; 46   : 	int bmpHeight = RealBinHeight; 	// ????Óèë???
; 47   : 
; 48   : 	int offsetX, offsetY; 			// ???????????????
; 49   : 	int sizeX, sizeY;				// Óòø??????
; 50   : 	int surfaceCntX;				// Óùß???????????
; 51   : 	int surfaceCntY;				// Óùß???????????
; 52   : 	int totalSurface;				// Óùß??????????
; 53   : 	int totalSurfaceCnt = 0;		// ????Óüï??????????? ??????? ?
; 54   : 	int	SurfaceSearchPointBak = SurfaceSearchPoint; // ?Óé´?????Óé∑?????????Óñ∫???
; 55   : 	int amariSizeX = FALSE;		// ???????????
; 56   : 	int amariSizeY = FALSE;		// Óèë??????????
; 57   : 	BOOL vramFullFlag = FALSE; 		// VRAM?????????
; 58   : 	SURFACE_INFO *prevSurfaceInfo; 	// Óì∑???????????Óî®Óïí?????
; 59   : 	offsetX = 0;
; 60   : #ifdef _READ16BITBMP
; 61   : 	SURFACE_INFO *prevSurfaceInfoSys;
; 62   : 	RECT rect = { 0,0,SurfaceSizeX,SurfaceSizeY };
; 63   : 	if (bmpNo >= OLD_GRAPHICS_START) offsetY = 0;
; 64   : 	else
; 65   : #endif
; 66   : 		offsetY = bmpHeight;

  00010	99		 cdq
  00011	33 db		 xor	 ebx, ebx
  00013	57		 push	 edi
  00014	bf 40 00 00 00	 mov	 edi, 64			; 00000040H
  00019	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?RealBinHeight@@3HA ; RealBinHeight
  0001f	f7 ff		 idiv	 edi
  00021	89 75 f8	 mov	 DWORD PTR _bmpHeight$1$[ebp], esi
  00024	89 55 fc	 mov	 DWORD PTR _amariSizeX$1$[ebp], edx
  00027	8b f8		 mov	 edi, eax

; 67   : 	surfaceCntX = bmpWidth / SURFACE_WIDTH;
; 68   : 	if ((amariSizeX = bmpWidth % SURFACE_WIDTH)) {
; 69   : 		surfaceCntX++;
; 70   : 	}
; 71   : 
; 72   : 	surfaceCntY = bmpHeight / SURFACE_HEIGHT;

  00029	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?SurfaceSearchPoint@@3HA ; SurfaceSearchPoint
  00034	f7 ee		 imul	 esi
  00036	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _totalSurfaceCnt$1$[ebp], 0
  0003d	c1 fa 03	 sar	 edx, 3
  00040	8b f2		 mov	 esi, edx
  00042	89 4d dc	 mov	 DWORD PTR tv511[ebp], ecx
  00045	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00048	03 f2		 add	 esi, edx

; 73   : 	if ((amariSizeY = bmpHeight % SURFACE_HEIGHT)) {

  0004a	8b 55 f8	 mov	 edx, DWORD PTR _bmpHeight$1$[ebp]
  0004d	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  00050	c1 e0 04	 shl	 eax, 4
  00053	2b d0		 sub	 edx, eax
  00055	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00058	89 55 ec	 mov	 DWORD PTR _amariSizeY$1$[ebp], edx

; 74   : 		surfaceCntY++;		// ?????Óùß?
; 75   : 	}
; 76   : 	totalSurface = surfaceCntX * surfaceCntY;

  0005b	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
  0005e	0f 44 d6	 cmove	 edx, esi
  00061	39 5d fc	 cmp	 DWORD PTR _amariSizeX$1$[ebp], ebx
  00064	0f 44 c7	 cmove	 eax, edi
  00067	0f af d0	 imul	 edx, eax
  0006a	89 55 e0	 mov	 DWORD PTR _totalSurface$1$[ebp], edx
  0006d	8b 55 f4	 mov	 edx, DWORD PTR _bmpWidth$1$[ebp]
  00070	f6 c2 03	 test	 dl, 3

; 77   : #ifdef _READ16BITBMP
; 78   : 	if (bmpNo < OLD_GRAPHICS_START)
; 79   : #endif
; 80   : 	{
; 81   : 		if ((RealBinWidth & 3)) RealBinWidth += 4 - RealBinWidth & 3;

  00073	74 0e		 je	 SHORT $LN37@AllocateBm
  00075	8b c2		 mov	 eax, edx
  00077	f7 d8		 neg	 eax
  00079	83 e0 03	 and	 eax, 3
  0007c	03 c2		 add	 eax, edx
  0007e	a3 00 00 00 00	 mov	 DWORD PTR ?RealBinWidth@@3HA, eax ; RealBinWidth
$LN37@AllocateBm:
  00083	8b 7d f8	 mov	 edi, DWORD PTR _bmpHeight$1$[ebp]
  00086	8b 75 dc	 mov	 esi, DWORD PTR _prevSurfaceInfo$[ebp]
  00089	4f		 dec	 edi
  0008a	89 7d e4	 mov	 DWORD PTR tv492[ebp], edi
  0008d	89 5d f0	 mov	 DWORD PTR tv487[ebp], ebx
$LL2@AllocateBm:

; 82   : 	}
; 83   : 	while (1) {
; 84   : 		if (SurfaceInfo[SurfaceSearchPoint].date < SurfaceDate - SURACE_BMP_DEATH_DATE) {

  00090	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SurfaceDate@@3IA ; SurfaceDate
  00095	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  0009c	2b d1		 sub	 edx, ecx
  0009e	83 c0 fe	 add	 eax, -2			; fffffffeH
  000a1	39 04 95 10 00
	00 00		 cmp	 DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[edx*4+16], eax
  000a8	0f 83 81 01 00
	00		 jae	 $LN25@AllocateBm

; 85   : #ifdef _STONDEBUG_		
; 86   : 			SurfaceUseCnt++;
; 87   : #endif
; 88   : 			// Â∑≤Âú®‰ΩøÁî®‰∏≠
; 89   : 			if (SurfaceInfo[SurfaceSearchPoint].bmpNo != -1) {

  000ae	8b 04 95 0c 00
	00 00		 mov	 eax, DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[edx*4+12]
  000b5	83 f8 ff	 cmp	 eax, -1
  000b8	74 2d		 je	 SHORT $LN5@AllocateBm

; 90   : 				SURFACE_INFO *lpSurfaceInfo;
; 91   : #ifdef _READ16BITBMP
; 92   : 				SURFACE_INFO *lpSurfaceInfoSys;
; 93   : #endif
; 94   : 				lpSurfaceInfo = SpriteInfo[SurfaceInfo[SurfaceSearchPoint].bmpNo].lpSurfaceInfo;

  000ba	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  000bd	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR ?SpriteInfo@@3PAUSPRITE_INFO@@A[eax*4]

; 95   : 				SpriteInfo[SurfaceInfo[SurfaceSearchPoint].bmpNo].lpSurfaceInfo = NULL;

  000c4	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ?SpriteInfo@@3PAUSPRITE_INFO@@A[eax*4], 0

; 96   : #ifdef _READ16BITBMP
; 97   : 				if (g_bUseAlpha) {
; 98   : 					lpSurfaceInfoSys = SpriteInfo[SurfaceInfo[SurfaceSearchPoint].bmpNo].lpSurfaceInfoSys;
; 99   : 					SpriteInfo[SurfaceInfo[SurfaceSearchPoint].bmpNo].lpSurfaceInfoSys = NULL;
; 100  : 				}
; 101  : #endif
; 102  : 				for (; lpSurfaceInfo != NULL;

  000cf	85 d2		 test	 edx, edx
  000d1	74 14		 je	 SHORT $LN5@AllocateBm
$LL6@AllocateBm:

; 103  : 					lpSurfaceInfo = lpSurfaceInfo->pNext) {
; 104  : 					lpSurfaceInfo->bmpNo = -1;

  000d3	c7 42 0c ff ff
	ff ff		 mov	 DWORD PTR [edx+12], -1
  000da	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  000dd	85 d2		 test	 edx, edx
  000df	75 f2		 jne	 SHORT $LL6@AllocateBm
  000e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?SurfaceSearchPoint@@3HA ; SurfaceSearchPoint
$LN5@AllocateBm:

; 105  : #ifdef _READ16BITBMP
; 106  : 					if (g_bUseAlpha)	lpSurfaceInfoSys->bmpNo = -1;
; 107  : #endif
; 108  : #ifdef _STONDEBUG_		
; 109  : 					SurfaceUseCnt--;
; 110  : #endif
; 111  : 				}
; 112  : 			}
; 113  : 			if (SpriteInfo[bmpNo].lpSurfaceInfo == NULL) {

  000e7	8b 45 08	 mov	 eax, DWORD PTR _bmpNo$[ebp]
  000ea	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  000ed	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  000f4	2b c1		 sub	 eax, ecx
  000f6	83 3c 95 00 00
	00 00 00	 cmp	 DWORD PTR ?SpriteInfo@@3PAUSPRITE_INFO@@A[edx*4], 0
  000fe	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[eax*4]
  00105	75 09		 jne	 SHORT $LN12@AllocateBm

; 114  : 				// Á¨¨‰∏ÄÂº†ÂõæÁöÑsurfaceinfo
; 115  : 				SpriteInfo[bmpNo].lpSurfaceInfo = &SurfaceInfo[SurfaceSearchPoint];

  00107	89 04 95 00 00
	00 00		 mov	 DWORD PTR ?SpriteInfo@@3PAUSPRITE_INFO@@A[edx*4], eax

; 116  : #ifdef _READ16BITBMP
; 117  : 				if (g_bUseAlpha)	SpriteInfo[bmpNo].lpSurfaceInfoSys = &SurfaceInfoSys[SurfaceSearchPoint];
; 118  : #endif
; 119  : 			}

  0010e	eb 09		 jmp	 SHORT $LN13@AllocateBm
$LN12@AllocateBm:

; 120  : 			else {
; 121  : 				// ÊåáÂêë‰∏ã‰∏ÄÂº†surfaceinfo
; 122  : 				prevSurfaceInfo->pNext = &SurfaceInfo[SurfaceSearchPoint];

  00110	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00113	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?SurfaceSearchPoint@@3HA ; SurfaceSearchPoint
$LN13@AllocateBm:

; 123  : #ifdef _READ16BITBMP
; 124  : 				if (g_bUseAlpha)	prevSurfaceInfoSys->pNext = &SurfaceInfoSys[SurfaceSearchPoint];
; 125  : #endif
; 126  : 			}
; 127  : 			SurfaceInfo[SurfaceSearchPoint].bmpNo = bmpNo;

  00119	8b 45 08	 mov	 eax, DWORD PTR _bmpNo$[ebp]
  0011c	8d 34 cd 00 00
	00 00		 lea	 esi, DWORD PTR [ecx*8]
  00123	2b f1		 sub	 esi, ecx

; 128  : #ifdef _READ16BITBMP
; 129  : 			if (g_bUseAlpha) SurfaceInfoSys[SurfaceSearchPoint].bmpNo = bmpNo;
; 130  : #endif
; 131  : 			if (ResoMode == 1) {

  00125	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?ResoMode@@3HA, 1 ; ResoMode
  0012c	89 04 b5 0c 00
	00 00		 mov	 DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[esi*4+12], eax
  00133	75 14		 jne	 SHORT $LN14@AllocateBm

; 132  : 				SurfaceInfo[SurfaceSearchPoint].offsetX = offsetX / 2;
; 133  : #ifdef _READ16BITBMP
; 134  : 				if (g_bUseAlpha) SurfaceInfoSys[SurfaceSearchPoint].offsetX = offsetX / 2;
; 135  : 				if (bmpNo >= OLD_GRAPHICS_START) {
; 136  : 					SurfaceInfo[SurfaceSearchPoint].offsetY = offsetY / 2;
; 137  : 					if (g_bUseAlpha) SurfaceInfoSys[SurfaceSearchPoint].offsetY = offsetY / 2;
; 138  : 				}
; 139  : 				else
; 140  : #endif
; 141  : 				{
; 142  : 					SurfaceInfo[SurfaceSearchPoint].offsetY = (bmpHeight - offsetY) / 2;

  00135	8b 45 f0	 mov	 eax, DWORD PTR tv487[ebp]
  00138	99		 cdq
  00139	2b c2		 sub	 eax, edx
  0013b	d1 f8		 sar	 eax, 1
  0013d	0f b7 f8	 movzx	 edi, ax
  00140	8b c3		 mov	 eax, ebx
  00142	99		 cdq
  00143	2b c2		 sub	 eax, edx
  00145	d1 f8		 sar	 eax, 1

; 143  : #ifdef _READ16BITBMP
; 144  : 					if (g_bUseAlpha) SurfaceInfoSys[SurfaceSearchPoint].offsetY = (bmpHeight - offsetY) / 2;
; 145  : #endif
; 146  : 				}
; 147  : 			}

  00147	eb 0b		 jmp	 SHORT $LN15@AllocateBm
$LN14@AllocateBm:

; 148  : 			else {
; 149  : 				SurfaceInfo[SurfaceSearchPoint].offsetX = offsetX;
; 150  : #ifdef _READ16BITBMP
; 151  : 				if (g_bUseAlpha) SurfaceInfoSys[SurfaceSearchPoint].offsetX = offsetX;
; 152  : 				if (bmpNo >= OLD_GRAPHICS_START) {
; 153  : 					SurfaceInfo[SurfaceSearchPoint].offsetY = offsetY;
; 154  : 					if (g_bUseAlpha) SurfaceInfoSys[SurfaceSearchPoint].offsetY = offsetY;
; 155  : 				}
; 156  : 				else
; 157  : #endif
; 158  : 				{
; 159  : 					SurfaceInfo[SurfaceSearchPoint].offsetY = bmpHeight - offsetY;

  00149	8b 45 f8	 mov	 eax, DWORD PTR _bmpHeight$1$[ebp]
  0014c	2b c7		 sub	 eax, edi
  0014e	48		 dec	 eax
  0014f	0f b7 f8	 movzx	 edi, ax
  00152	8b c3		 mov	 eax, ebx
$LN15@AllocateBm:

; 160  : #ifdef _READ16BITBMP
; 161  : 					if (g_bUseAlpha)	SurfaceInfoSys[SurfaceSearchPoint].offsetY = bmpHeight - offsetY;
; 162  : #endif
; 163  : 				}
; 164  : 			}
; 165  : 
; 166  : 			if (offsetX >= bmpWidth - SURFACE_WIDTH && amariSizeX) {

  00154	8b 55 fc	 mov	 edx, DWORD PTR _amariSizeX$1$[ebp]
  00157	66 89 04 b5 14
	00 00 00	 mov	 WORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[esi*4+20], ax
  0015f	8b 45 f4	 mov	 eax, DWORD PTR _bmpWidth$1$[ebp]
  00162	83 c0 c0	 add	 eax, -64		; ffffffc0H
  00165	66 89 3c b5 16
	00 00 00	 mov	 WORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[esi*4+22], di
  0016d	3b d8		 cmp	 ebx, eax
  0016f	7c 20		 jl	 SHORT $LN16@AllocateBm
  00171	85 d2		 test	 edx, edx
  00173	74 1c		 je	 SHORT $LN16@AllocateBm

; 167  : 				ClearSurface(SurfaceInfo[SurfaceSearchPoint].lpSurface);

  00175	ff 34 b5 00 00
	00 00		 push	 DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[esi*4]
  0017c	e8 00 00 00 00	 call	 ?ClearSurface@@YAXPAUIDirectDrawSurface@@@Z ; ClearSurface

; 168  : #ifdef _READ16BITBMP
; 169  : 				if (g_bUseAlpha) {
; 170  : 					ClearSurface(SurfaceInfoSys[SurfaceSearchPoint].lpSurface);
; 171  : 					if (SurfaceInfo[SurfaceSearchPoint].lpAlphaData)
; 172  : 						memset(SurfaceInfo[SurfaceSearchPoint].lpAlphaData, 0, SurfaceSizeX*SurfaceSizeY);
; 173  : 				}
; 174  : #endif
; 175  : 				sizeX = amariSizeX;

  00181	8b 55 fc	 mov	 edx, DWORD PTR _amariSizeX$1$[ebp]
  00184	83 c4 04	 add	 esp, 4

; 176  : 			}

  00187	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?SurfaceSearchPoint@@3HA ; SurfaceSearchPoint
  0018d	8b f2		 mov	 esi, edx
  0018f	eb 05		 jmp	 SHORT $LN17@AllocateBm
$LN16@AllocateBm:

; 177  : 			else sizeX = SURFACE_WIDTH;

  00191	be 40 00 00 00	 mov	 esi, 64			; 00000040H
$LN17@AllocateBm:

; 178  : 
; 179  : #ifdef _READ16BITBMP
; 180  : 			if (bmpNo >= OLD_GRAPHICS_START) {
; 181  : 				if (offsetY >= bmpHeight - SURFACE_HEIGHT && amariSizeY) {
; 182  : 					ClearSurface(SurfaceInfo[SurfaceSearchPoint].lpSurface);
; 183  : 					if (g_bUseAlpha) {
; 184  : 						ClearSurface(SurfaceInfoSys[SurfaceSearchPoint].lpSurface);
; 185  : 						if (SurfaceInfo[SurfaceSearchPoint].lpAlphaData)
; 186  : 							memset(SurfaceInfo[SurfaceSearchPoint].lpAlphaData, 0, SurfaceSizeX*SurfaceSizeY);
; 187  : 					}
; 188  : 					sizeY = amariSizeY;
; 189  : 				}
; 190  : 				else sizeY = SURFACE_HEIGHT;
; 191  : 			}
; 192  : 			else
; 193  : #endif
; 194  : 			{
; 195  : 				if (offsetY - SURFACE_HEIGHT <= 0 && amariSizeY) {

  00196	8b 7d e4	 mov	 edi, DWORD PTR tv492[ebp]
  00199	8d 47 d1	 lea	 eax, DWORD PTR [edi-47]
  0019c	85 c0		 test	 eax, eax
  0019e	7f 2e		 jg	 SHORT $LN18@AllocateBm
  001a0	8b 45 ec	 mov	 eax, DWORD PTR _amariSizeY$1$[ebp]
  001a3	85 c0		 test	 eax, eax
  001a5	74 27		 je	 SHORT $LN18@AllocateBm

; 196  : 					if (sizeX != amariSizeX) {

  001a7	3b f2		 cmp	 esi, edx
  001a9	74 28		 je	 SHORT $LN19@AllocateBm

; 197  : 						ClearSurface(SurfaceInfo[SurfaceSearchPoint].lpSurface);

  001ab	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  001b2	2b c1		 sub	 eax, ecx
  001b4	ff 34 85 00 00
	00 00		 push	 DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[eax*4]
  001bb	e8 00 00 00 00	 call	 ?ClearSurface@@YAXPAUIDirectDrawSurface@@@Z ; ClearSurface
  001c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?SurfaceSearchPoint@@3HA ; SurfaceSearchPoint
  001c6	83 c4 04	 add	 esp, 4
  001c9	8b 45 ec	 mov	 eax, DWORD PTR _amariSizeY$1$[ebp]

; 198  : #ifdef _READ16BITBMP
; 199  : 						if (g_bUseAlpha) ClearSurface(SurfaceInfoSys[SurfaceSearchPoint].lpSurface);
; 200  : #endif
; 201  : 					}
; 202  : 					sizeY = amariSizeY;
; 203  : 				}

  001cc	eb 05		 jmp	 SHORT $LN19@AllocateBm
$LN18@AllocateBm:

; 204  : 				else sizeY = SURFACE_HEIGHT;

  001ce	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
$LN19@AllocateBm:

; 205  : 			}
; 206  : 
; 207  : #ifdef _READ16BITBMP
; 208  : 			SurfaceInfo[SurfaceSearchPoint].useAlpha = useAlpha;
; 209  : 			SurfaceInfoSys[SurfaceSearchPoint].useAlpha = useAlpha;
; 210  : 			if (bmpNo >= OLD_GRAPHICS_START) {
; 211  : 				Draw16BitmapToSurface2(&SurfaceInfo[SurfaceSearchPoint],
; 212  : 					SurfaceInfoSys[SurfaceSearchPoint].lpSurface,
; 213  : 					offsetX,
; 214  : 					offsetY,
; 215  : 					sizeX,
; 216  : 					sizeY,
; 217  : 					NULL);
; 218  : 			}
; 219  : 			else {
; 220  : 				if (g_bUseAlpha) {
; 221  : 					DrawBitmapToSurface2(&SurfaceInfo[SurfaceSearchPoint],
; 222  : 						SurfaceInfoSys[SurfaceSearchPoint].lpSurface,
; 223  : 						offsetX,
; 224  : 						offsetY - 1,
; 225  : 						sizeX,
; 226  : 						sizeY,
; 227  : 						NULL);
; 228  : 				}
; 229  : 				else {
; 230  : 					DrawBitmapToSurface2(SurfaceInfo[SurfaceSearchPoint].lpSurface,
; 231  : 						offsetX,
; 232  : 						offsetY - 1,
; 233  : 						sizeX,
; 234  : 						sizeY,
; 235  : 						NULL);
; 236  : 				}
; 237  : 			}
; 238  : #else
; 239  : 			DrawBitmapToSurface2(&SurfaceInfo[SurfaceSearchPoint],

  001d3	6a 00		 push	 0
  001d5	50		 push	 eax
  001d6	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  001dd	56		 push	 esi
  001de	2b c1		 sub	 eax, ecx
  001e0	57		 push	 edi
  001e1	53		 push	 ebx
  001e2	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[eax*4]
  001e9	50		 push	 eax
  001ea	e8 00 00 00 00	 call	 ?DrawBitmapToSurface2@@YAXPAUsurfaceInfo@@HHHHPAUtagBITMAPINFO@@@Z ; DrawBitmapToSurface2

; 240  : 				offsetX,
; 241  : 				offsetY - 1,
; 242  : 				sizeX,
; 243  : 				sizeY,
; 244  : 				NULL);
; 245  : #endif
; 246  : 			totalSurfaceCnt++;

  001ef	8b 45 e8	 mov	 eax, DWORD PTR _totalSurfaceCnt$1$[ebp]
  001f2	83 c4 18	 add	 esp, 24			; 00000018H

; 247  : 			// ÊâÄÊúâÁöÑÂõæÈÉΩÂ∑≤Â≠òÂÖ•offscreen
; 248  : 			if (totalSurfaceCnt >= totalSurface) {

  001f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?SurfaceSearchPoint@@3HA ; SurfaceSearchPoint
  001fb	40		 inc	 eax
  001fc	3b 45 e0	 cmp	 eax, DWORD PTR _totalSurface$1$[ebp]
  001ff	89 45 e8	 mov	 DWORD PTR _totalSurfaceCnt$1$[ebp], eax
  00202	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  00209	7d 4f		 jge	 SHORT $LN32@AllocateBm

; 254  : 
; 255  : 				if (SurfaceSearchPoint >= SurfaceCnt) SurfaceSearchPoint = 0;
; 256  : 				break;
; 257  : 			}
; 258  : 			else {
; 259  : 				prevSurfaceInfo = &SurfaceInfo[SurfaceSearchPoint];

  0020b	2b c1		 sub	 eax, ecx
  0020d	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[eax*4]

; 260  : #ifdef _READ16BITBMP
; 261  : 				if (g_bUseAlpha)	prevSurfaceInfoSys = &SurfaceInfoSys[SurfaceSearchPoint];
; 262  : #endif
; 263  : 				if (offsetX >= bmpWidth - SURFACE_WIDTH) {

  00214	8b 45 f4	 mov	 eax, DWORD PTR _bmpWidth$1$[ebp]
  00217	83 c0 c0	 add	 eax, -64		; ffffffc0H
  0021a	3b d8		 cmp	 ebx, eax
  0021c	7c 0e		 jl	 SHORT $LN24@AllocateBm

; 264  : 					offsetX = 0;
; 265  : #ifdef _READ16BITBMP
; 266  : 					if (bmpNo >= OLD_GRAPHICS_START) offsetY += SURFACE_HEIGHT;
; 267  : 					else
; 268  : #endif
; 269  : 						offsetY -= SURFACE_HEIGHT;

  0021e	83 45 f0 30	 add	 DWORD PTR tv487[ebp], 48 ; 00000030H
  00222	33 db		 xor	 ebx, ebx
  00224	83 ef 30	 sub	 edi, 48			; 00000030H
  00227	89 7d e4	 mov	 DWORD PTR tv492[ebp], edi

; 270  : 				}

  0022a	eb 03		 jmp	 SHORT $LN25@AllocateBm
$LN24@AllocateBm:

; 271  : 				else {
; 272  : 					offsetX += SURFACE_WIDTH;

  0022c	83 c3 40	 add	 ebx, 64			; 00000040H
$LN25@AllocateBm:

; 273  : 				}
; 274  : 			}
; 275  : 		}
; 276  : 		SurfaceSearchPoint++;

  0022f	41		 inc	 ecx
  00230	8b c1		 mov	 eax, ecx
  00232	89 0d 00 00 00
	00		 mov	 DWORD PTR ?SurfaceSearchPoint@@3HA, ecx ; SurfaceSearchPoint
  00238	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?SurfaceCnt@@3HA ; SurfaceCnt

; 277  : 		if (SurfaceSearchPoint >= SurfaceCnt) SurfaceSearchPoint = 0;

  0023e	7c 0a		 jl	 SHORT $LN26@AllocateBm
  00240	33 c9		 xor	 ecx, ecx
  00242	33 c0		 xor	 eax, eax
  00244	89 0d 00 00 00
	00		 mov	 DWORD PTR ?SurfaceSearchPoint@@3HA, ecx ; SurfaceSearchPoint
$LN26@AllocateBm:

; 278  : 		if (SurfaceSearchPoint == SurfaceSearchPointBak) break;

  0024a	3b 45 dc	 cmp	 eax, DWORD PTR tv511[ebp]
  0024d	0f 85 3d fe ff
	ff		 jne	 $LL2@AllocateBm

; 279  : 	}
; 280  : }

  00253	5f		 pop	 edi
  00254	5e		 pop	 esi
  00255	5b		 pop	 ebx
  00256	8b e5		 mov	 esp, ebp
  00258	5d		 pop	 ebp
  00259	c3		 ret	 0
$LN32@AllocateBm:

; 249  : 				SurfaceInfo[SurfaceSearchPoint].pNext = NULL;

  0025a	2b c1		 sub	 eax, ecx

; 250  : #ifdef _READ16BITBMP
; 251  : 				if (g_bUseAlpha)	SurfaceInfoSys[SurfaceSearchPoint].pNext = NULL;
; 252  : #endif
; 253  : 				SurfaceSearchPoint++;

  0025c	41		 inc	 ecx
  0025d	5f		 pop	 edi

; 279  : 	}
; 280  : }

  0025e	5e		 pop	 esi
  0025f	5b		 pop	 ebx
  00260	c7 04 85 18 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[eax*4+24], 0
  0026b	33 c0		 xor	 eax, eax
  0026d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?SurfaceCnt@@3HA ; SurfaceCnt
  00273	0f 4d c8	 cmovge	 ecx, eax
  00276	89 0d 00 00 00
	00		 mov	 DWORD PTR ?SurfaceSearchPoint@@3HA, ecx ; SurfaceSearchPoint
  0027c	8b e5		 mov	 esp, ebp
  0027e	5d		 pop	 ebp
  0027f	c3		 ret	 0
?AllocateBmpToSurface@@YAXH@Z ENDP			; AllocateBmpToSurface
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\sprmgr.cpp
;	COMDAT ?LoadBmp@@YAHH@Z
_TEXT	SEGMENT
_bmpNo$ = 8						; size = 4
?LoadBmp@@YAHH@Z PROC					; LoadBmp, COMDAT

; 380  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 381  : #ifndef _READ16BITBMP
; 382  : 	if ((unsigned)bmpNo > MAX_GRAPHICS) return FALSE;

  00004	8b 75 08	 mov	 esi, DWORD PTR _bmpNo$[ebp]
  00007	57		 push	 edi
  00008	81 fe 80 84 1e
	00		 cmp	 esi, 2000000		; 001e8480H
  0000e	77 6c		 ja	 SHORT $LN8@LoadBmp

; 383  : 	if (SpriteInfo[bmpNo].lpSurfaceInfo == NULL) {

  00010	8d 3c 76	 lea	 edi, DWORD PTR [esi+esi*2]
  00013	83 3c bd 00 00
	00 00 00	 cmp	 DWORD PTR ?SpriteInfo@@3PAUSPRITE_INFO@@A[edi*4], 0
  0001b	75 56		 jne	 SHORT $LN3@LoadBmp

; 384  : 		if (realGetImage(bmpNo, (unsigned char **)&pRealBinBits,
; 385  : 			&RealBinWidth, &RealBinHeight) == FALSE) {

  0001d	68 00 00 00 00	 push	 OFFSET ?RealBinHeight@@3HA ; RealBinHeight
  00022	68 00 00 00 00	 push	 OFFSET ?RealBinWidth@@3HA ; RealBinWidth
  00027	68 00 00 00 00	 push	 OFFSET ?pRealBinBits@@3PADA ; pRealBinBits
  0002c	56		 push	 esi
  0002d	e8 00 00 00 00	 call	 ?realGetImage@@YAHHPAPAEPAH1@Z ; realGetImage
  00032	83 c4 10	 add	 esp, 16			; 00000010H
  00035	85 c0		 test	 eax, eax
  00037	74 43		 je	 SHORT $LN8@LoadBmp

; 387  : 		}
; 388  : 		SpriteInfo[bmpNo].width = RealBinWidth;

  00039	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?RealBinWidth@@3HA
  00040	66 89 04 bd 04
	00 00 00	 mov	 WORD PTR ?SpriteInfo@@3PAUSPRITE_INFO@@A[edi*4+4], ax

; 389  : 		SpriteInfo[bmpNo].height = RealBinHeight;

  00048	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?RealBinHeight@@3HA
  0004f	66 89 04 bd 06
	00 00 00	 mov	 WORD PTR ?SpriteInfo@@3PAUSPRITE_INFO@@A[edi*4+6], ax

; 390  : #ifdef _NEW_COLOR_
; 391  : 		if (NewColor16Flg == 2)SpriteInfo[bmpNo].AlphaFlg = TRUE;

  00057	33 c0		 xor	 eax, eax
  00059	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?NewColor16Flg@@3HA, 2 ; NewColor16Flg

; 392  : 		else SpriteInfo[bmpNo].AlphaFlg = FALSE;
; 393  : #endif
; 394  : 		AllocateBmpToSurface(bmpNo);

  00060	56		 push	 esi
  00061	0f 94 c0	 sete	 al
  00064	89 04 bd 08 00
	00 00		 mov	 DWORD PTR ?SpriteInfo@@3PAUSPRITE_INFO@@A[edi*4+8], eax
  0006b	e8 00 00 00 00	 call	 ?AllocateBmpToSurface@@YAXH@Z ; AllocateBmpToSurface
  00070	83 c4 04	 add	 esp, 4
$LN3@LoadBmp:

; 395  : 	}
; 396  : #ifdef _CACHE_SURFACE_
; 397  : 	else {
; 398  : 		//Â¶ÇÊûúÂ∑≤ÁªèÁºìÂ≠òÔºåÂà∑Êñ∞dateÔºå‰ª•ÂÖçË¢´ÈáäÊîæ
; 399  : 		for (SURFACE_INFO* info = SpriteInfo[bmpNo].lpSurfaceInfo; info->pNext != NULL; info = info->pNext)
; 400  : 		{
; 401  : 			info->date = SurfaceDate;
; 402  : 		}
; 403  : 	}
; 404  : #endif
; 405  : 	return TRUE;

  00073	5f		 pop	 edi
  00074	b8 01 00 00 00	 mov	 eax, 1

; 406  : #else
; 407  : 	BOOL useAlpha;
; 408  : 
; 409  : 	if ((unsigned)bmpNo >= OLD_GRAPHICS_START) {
; 410  : 		if ((unsigned)bmpNo >= MAX_GRAPHICS) return FALSE;
; 411  : 		if (SpriteInfo[bmpNo].lpSurfaceInfo == NULL) {
; 412  : 			pRealBinAlpha = NULL;
; 413  : 			if (Read16BMP(bmpNo - OLD_GRAPHICS_START, (unsigned char **)&pRealBinBits,
; 414  : 				&RealBinWidth, &RealBinHeight, (unsigned char **)&pRealBinAlpha, &useAlpha) == FALSE) return FALSE;
; 415  : 			SpriteInfo[bmpNo].width = RealBinWidth;
; 416  : 			SpriteInfo[bmpNo].height = RealBinHeight;
; 417  : 			AllocateBmpToSurface(bmpNo, useAlpha);
; 418  : 		}
; 419  : 		return TRUE;
; 420  : 	}
; 421  : 	else {
; 422  : 		if (SpriteInfo[bmpNo].lpSurfaceInfo == NULL) {
; 423  : 			pRealBinAlpha = NULL;
; 424  : 			if (realGetImage(bmpNo, (unsigned char **)&pRealBinBits,
; 425  : 				&RealBinWidth, &RealBinHeight) == FALSE) return FALSE;
; 426  : 
; 427  : 			if (NewColor16Flg == 2) {
; 428  : #define REALGETIMAGEMAXSIZE 1600*1600
; 429  : 				extern BYTE g_realgetimagebuf[REALGETIMAGEMAXSIZE];
; 430  : 				int i = 0;
; 431  : 				int b = RealBinWidth * RealBinHeight;
; 432  : 				memset(g_realgetimagebuf, 0, b);
; 433  : 				pRealBinAlpha = g_realgetimagebuf;
; 434  : 				for (i; i<b; i++) {
; 435  : 					*(pRealBinAlpha + i) = *(BYTE*)(pRealBinBits + 3 + i * 4);
; 436  : 				}
; 437  : 			}
; 438  : 			SpriteInfo[bmpNo].width = RealBinWidth;
; 439  : 			SpriteInfo[bmpNo].height = RealBinHeight;
; 440  : 			AllocateBmpToSurface(bmpNo, FALSE);
; 441  : 		}
; 442  : 		return TRUE;
; 443  : 	}
; 444  : #endif
; 445  : }

  00079	5e		 pop	 esi
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
$LN8@LoadBmp:
  0007c	5f		 pop	 edi

; 386  : 			return FALSE;

  0007d	33 c0		 xor	 eax, eax

; 406  : #else
; 407  : 	BOOL useAlpha;
; 408  : 
; 409  : 	if ((unsigned)bmpNo >= OLD_GRAPHICS_START) {
; 410  : 		if ((unsigned)bmpNo >= MAX_GRAPHICS) return FALSE;
; 411  : 		if (SpriteInfo[bmpNo].lpSurfaceInfo == NULL) {
; 412  : 			pRealBinAlpha = NULL;
; 413  : 			if (Read16BMP(bmpNo - OLD_GRAPHICS_START, (unsigned char **)&pRealBinBits,
; 414  : 				&RealBinWidth, &RealBinHeight, (unsigned char **)&pRealBinAlpha, &useAlpha) == FALSE) return FALSE;
; 415  : 			SpriteInfo[bmpNo].width = RealBinWidth;
; 416  : 			SpriteInfo[bmpNo].height = RealBinHeight;
; 417  : 			AllocateBmpToSurface(bmpNo, useAlpha);
; 418  : 		}
; 419  : 		return TRUE;
; 420  : 	}
; 421  : 	else {
; 422  : 		if (SpriteInfo[bmpNo].lpSurfaceInfo == NULL) {
; 423  : 			pRealBinAlpha = NULL;
; 424  : 			if (realGetImage(bmpNo, (unsigned char **)&pRealBinBits,
; 425  : 				&RealBinWidth, &RealBinHeight) == FALSE) return FALSE;
; 426  : 
; 427  : 			if (NewColor16Flg == 2) {
; 428  : #define REALGETIMAGEMAXSIZE 1600*1600
; 429  : 				extern BYTE g_realgetimagebuf[REALGETIMAGEMAXSIZE];
; 430  : 				int i = 0;
; 431  : 				int b = RealBinWidth * RealBinHeight;
; 432  : 				memset(g_realgetimagebuf, 0, b);
; 433  : 				pRealBinAlpha = g_realgetimagebuf;
; 434  : 				for (i; i<b; i++) {
; 435  : 					*(pRealBinAlpha + i) = *(BYTE*)(pRealBinBits + 3 + i * 4);
; 436  : 				}
; 437  : 			}
; 438  : 			SpriteInfo[bmpNo].width = RealBinWidth;
; 439  : 			SpriteInfo[bmpNo].height = RealBinHeight;
; 440  : 			AllocateBmpToSurface(bmpNo, FALSE);
; 441  : 		}
; 442  : 		return TRUE;
; 443  : 	}
; 444  : #endif
; 445  : }

  0007f	5e		 pop	 esi
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
?LoadBmp@@YAHH@Z ENDP					; LoadBmp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\sprmgr.cpp
;	COMDAT ?InitSpriteInfo@@YAXXZ
_TEXT	SEGMENT
?InitSpriteInfo@@YAXXZ PROC				; InitSpriteInfo, COMDAT

; 367  : 	int i;
; 368  : 	for (i = 0; i < MAX_GRAPHICS; i++) {

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?SpriteInfo@@3PAUSPRITE_INFO@@A ; SpriteInfo
  00005	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@InitSprite:

; 369  : 		SpriteInfo[i].lpSurfaceInfo = NULL;

  00010	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00016	83 c0 0c	 add	 eax, 12			; 0000000cH
  00019	3d 00 36 6e 01	 cmp	 eax, OFFSET ?SpriteInfo@@3PAUSPRITE_INFO@@A+24000000
  0001e	7c f0		 jl	 SHORT $LL4@InitSprite

; 370  : #ifdef _READ16BITBMP
; 371  : 		SpriteInfo[i].lpSurfaceInfoSys = NULL;
; 372  : #endif
; 373  : 	}
; 374  : }

  00020	c3		 ret	 0
?InitSpriteInfo@@YAXXZ ENDP				; InitSpriteInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\sprmgr.cpp
;	COMDAT ?InitSurfaceInfo@@YAXXZ
_TEXT	SEGMENT
?InitSurfaceInfo@@YAXXZ PROC				; InitSurfaceInfo, COMDAT

; 351  : 	for (i = 0; i < SurfaceCnt; i++) {

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?SurfaceCnt@@3HA ; SurfaceCnt
  00006	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?SurfaceSearchPoint@@3HA, 0 ; SurfaceSearchPoint
  00010	85 c9		 test	 ecx, ecx
  00012	7e 29		 jle	 SHORT $LN3@InitSurfac

; 346  : 	int i;
; 347  : #ifdef _STONDEBUG_		
; 348  : 	SurfaceUseCnt = 0;
; 349  : #endif
; 350  : 	SurfaceSearchPoint = 0;

  00014	b8 10 00 00 00	 mov	 eax, OFFSET ?SurfaceInfo@@3PAUsurfaceInfo@@A+16
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@InitSurfac:

; 352  : 		SurfaceInfo[i].bmpNo = -1;

  00020	c7 40 fc ff ff
	ff ff		 mov	 DWORD PTR [eax-4], -1
  00027	8d 40 1c	 lea	 eax, DWORD PTR [eax+28]

; 353  : 		SurfaceInfo[i].date = 0;

  0002a	c7 40 e4 00 00
	00 00		 mov	 DWORD PTR [eax-28], 0

; 354  : 		SurfaceInfo[i].pNext = NULL;

  00031	c7 40 ec 00 00
	00 00		 mov	 DWORD PTR [eax-20], 0
  00038	83 e9 01	 sub	 ecx, 1
  0003b	75 e3		 jne	 SHORT $LL4@InitSurfac
$LN3@InitSurfac:

; 355  : #ifdef _READ16BITBMP
; 356  : 		SurfaceInfo[i].useAlpha = FALSE;
; 357  : 		SurfaceInfoSys[i].bmpNo = -1;
; 358  : 		SurfaceInfoSys[i].date = 0;
; 359  : 		SurfaceInfoSys[i].pNext = NULL;
; 360  : 		SurfaceInfoSys[i].useAlpha = FALSE;
; 361  : #endif
; 362  : 	}
; 363  : }

  0003d	c3		 ret	 0
?InitSurfaceInfo@@YAXXZ ENDP				; InitSurfaceInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\πŸ≈¡ »≠∏È\∏æƒÌøœ∑·\Client Source Code1.31¿œ∫ª\system\sprmgr.cpp
;	COMDAT ?InitOffScreenSurface@@YAHXZ
_TEXT	SEGMENT
?InitOffScreenSurface@@YAHXZ PROC			; InitOffScreenSurface, COMDAT

; 283  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 284  : 	int i;
; 285  : 	BOOL vramFullFlag = TRUE;
; 286  : 	SurfaceCnt = 0;

  00002	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?SurfaceCnt@@3HA, 0 ; SurfaceCnt

; 287  : 	VramSurfaceCnt = 0;
; 288  : 	SysramSurfaceCnt = 0;
; 289  : 	for (i = 0; i < SURACE_INFO_MAX; i++) {

  0000c	33 ff		 xor	 edi, edi
  0000e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?VramSurfaceCnt@@3HA, 0 ; VramSurfaceCnt
  00018	be 00 00 00 00	 mov	 esi, OFFSET ?SurfaceInfo@@3PAUsurfaceInfo@@A ; SurfaceInfo
  0001d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?SysramSurfaceCnt@@3HA, 0 ; SysramSurfaceCnt
  00027	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL4@InitOffScr:

; 290  : 		if (vramFullFlag == FALSE) {
; 291  : 			if ((SurfaceInfo[i].lpSurface = CreateSurface(SurfaceSizeX, SurfaceSizeY, DEF_COLORKEY, /*DDSCAPS_SYSTEMMEMORY*/ DDSCAPS_VIDEOMEMORY)) == NULL) {
; 292  : #ifdef _STONDEBUG_
; 293  : 				MessageBoxNew(hWnd, "SurfaceInfo:Âª∫Á´ãVideoRAM SurfaceÂ§±Ë¥•ÔºÅ", "??", MB_OK | MB_ICONSTOP);
; 294  : #endif
; 295  : 				vramFullFlag = TRUE;
; 296  : 			}
; 297  : 			else {
; 298  : 				VramSurfaceCnt++;
; 299  : 			}
; 300  : 		}
; 301  : 		if (vramFullFlag == TRUE) {
; 302  : 			if ((SurfaceInfo[i].lpSurface = CreateSurface(SurfaceSizeX, SurfaceSizeY, DEF_COLORKEY, DDSCAPS_SYSTEMMEMORY)) == NULL) {

  00030	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?SurfaceSizeY@@3HA
  00037	68 00 08 00 00	 push	 2048			; 00000800H
  0003c	6a 00		 push	 0
  0003e	50		 push	 eax
  0003f	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?SurfaceSizeX@@3HA
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ?CreateSurface@@YAPAUIDirectDrawSurface@@FFKI@Z ; CreateSurface
  0004c	83 c4 10	 add	 esp, 16			; 00000010H
  0004f	89 06		 mov	 DWORD PTR [esi], eax
  00051	85 c0		 test	 eax, eax
  00053	74 2a		 je	 SHORT $LN13@InitOffScr

; 307  : 			}
; 308  : 			else SysramSurfaceCnt++;

  00055	ff 05 00 00 00
	00		 inc	 DWORD PTR ?SysramSurfaceCnt@@3HA ; SysramSurfaceCnt
  0005b	83 c6 1c	 add	 esi, 28			; 0000001cH
  0005e	47		 inc	 edi
  0005f	81 fe 00 50 01
	00		 cmp	 esi, OFFSET ?SurfaceInfo@@3PAUsurfaceInfo@@A+86016
  00065	7c c9		 jl	 SHORT $LL4@InitOffScr

; 309  : 		}
; 310  : #ifdef _READ16BITBMP
; 311  : 		if (g_bUseAlpha) {
; 312  : 			if ((SurfaceInfo[i].lpAlphaData = (BYTE*)MALLOC(SurfaceSizeX*SurfaceSizeY)) == NULL) {
; 313  : #ifdef _STONDEBUG_
; 314  : 				MessageBoxNew(hWnd, "alphaËÆ∞ÂøÜ‰ΩìÈÖçÁΩÆÂ§±Ë¥•ÔºÅ", "??", MB_OK | MB_ICONSTOP);
; 315  : #endif
; 316  : 				return FALSE;
; 317  : 			}
; 318  : 			else {
; 319  : #ifdef _STONDEBUG_
; 320  : 				g_iMallocCount++;
; 321  : #endif
; 322  : 				SysramSurfaceCnt++;
; 323  : 			}
; 324  : 		}
; 325  : #endif
; 326  : #ifdef _READ16BITBMP
; 327  : 		if (g_bUseAlpha) {
; 328  : 			if ((SurfaceInfoSys[i].lpSurface = CreateSurface(SurfaceSizeX, SurfaceSizeY, DEF_COLORKEY, DDSCAPS_SYSTEMMEMORY)) == NULL) {
; 329  : #ifdef _STONDEBUG_
; 330  : 				MessageBoxNew(hWnd, "Âª∫Á´ãSysRAM Surface(2)Â§±Ë¥•ÔºÅ", "??", MB_OK | MB_ICONSTOP);
; 331  : #endif
; 332  : 				return FALSE;
; 333  : 			}
; 334  : 			else SysramSurfaceCnt++;
; 335  : 		}
; 336  : #endif
; 337  : 	}
; 338  : 	SurfaceCnt = i;

  00067	89 3d 00 00 00
	00		 mov	 DWORD PTR ?SurfaceCnt@@3HA, edi ; SurfaceCnt

; 339  : 	InitSurfaceInfo();

  0006d	e8 00 00 00 00	 call	 ?InitSurfaceInfo@@YAXXZ	; InitSurfaceInfo

; 340  : 	InitSpriteInfo();

  00072	e8 00 00 00 00	 call	 ?InitSpriteInfo@@YAXXZ	; InitSpriteInfo
  00077	5f		 pop	 edi

; 341  : 	return TRUE;

  00078	b8 01 00 00 00	 mov	 eax, 1

; 342  : }

  0007d	5e		 pop	 esi
  0007e	c3		 ret	 0
$LN13@InitOffScr:
  0007f	5f		 pop	 edi

; 303  : #ifdef _STONDEBUG_
; 304  : 				MessageBoxNew(hWnd, "Âª∫Á´ãSysRAM SurfaceÂ§±Ë¥•ÔºÅ", "??", MB_OK | MB_ICONSTOP);
; 305  : #endif
; 306  : 				return FALSE;

  00080	33 c0		 xor	 eax, eax

; 342  : }

  00082	5e		 pop	 esi
  00083	c3		 ret	 0
?InitOffScreenSurface@@YAHXZ ENDP			; InitOffScreenSurface
_TEXT	ENDS
END
