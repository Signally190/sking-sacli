; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30133.0 

	TITLE	\\VBOXSVR\_stoneage\repos\ssm-sacli\Release\directDraw.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?CG_PKSERVER_PANEL@@3HA				; CG_PKSERVER_PANEL
PUBLIC	?CG_BATTTLE_SKILLCHOICE@@3HA			; CG_BATTTLE_SKILLCHOICE
PUBLIC	?CG_FIELD_SKILL_PANEL@@3HA			; CG_FIELD_SKILL_PANEL
PUBLIC	?CG_FIELD_CHATROOM_PANEL@@3HA			; CG_FIELD_CHATROOM_PANEL
PUBLIC	?CG_FIELD_SV_SELL_PANEL@@3HA			; CG_FIELD_SV_SELL_PANEL
PUBLIC	?CG_FIELD_SV_SELL_PRICE_PANEL@@3HA		; CG_FIELD_SV_SELL_PRICE_PANEL
PUBLIC	?CG_NEW_STATUS_WND@@3HA				; CG_NEW_STATUS_WND
PUBLIC	?CG_NEWITEM_WND@@3HA				; CG_NEWITEM_WND
PUBLIC	?CG_TRADE_WND@@3HA				; CG_TRADE_WND
PUBLIC	?CG_TRADE_VIEWWND@@3HA				; CG_TRADE_VIEWWND
PUBLIC	?CG_WND_G_0@@3HA				; CG_WND_G_0
PUBLIC	?CG_WND_G_1@@3HA				; CG_WND_G_1
PUBLIC	?CG_WND_G_2@@3HA				; CG_WND_G_2
PUBLIC	?CG_WND_G_3@@3HA				; CG_WND_G_3
PUBLIC	?CG_WND_G_4@@3HA				; CG_WND_G_4
PUBLIC	?CG_WND_G_5@@3HA				; CG_WND_G_5
PUBLIC	?CG_WND_G_6@@3HA				; CG_WND_G_6
PUBLIC	?CG_WND_G_7@@3HA				; CG_WND_G_7
PUBLIC	?CG_WND_G_8@@3HA				; CG_WND_G_8
PUBLIC	?CG_WND2_G_0@@3HA				; CG_WND2_G_0
PUBLIC	?CG_WND2_G_1@@3HA				; CG_WND2_G_1
PUBLIC	?CG_WND2_G_2@@3HA				; CG_WND2_G_2
PUBLIC	?CG_WND2_G_3@@3HA				; CG_WND2_G_3
PUBLIC	?CG_WND2_G_4@@3HA				; CG_WND2_G_4
PUBLIC	?CG_WND2_G_5@@3HA				; CG_WND2_G_5
PUBLIC	?CG_WND2_G_6@@3HA				; CG_WND2_G_6
PUBLIC	?CG_WND2_G_7@@3HA				; CG_WND2_G_7
PUBLIC	?CG_WND2_G_8@@3HA				; CG_WND2_G_8
PUBLIC	?CG_WND3_G_7@@3HA				; CG_WND3_G_7
PUBLIC	?CG_WND3_G_8@@3HA				; CG_WND3_G_8
PUBLIC	?CG_WND3_G_9@@3HA				; CG_WND3_G_9
PUBLIC	?CG_BTL_PET_CHANGE_WND@@3HA			; CG_BTL_PET_CHANGE_WND
PUBLIC	?CG_PET_WND_VIEW@@3HA				; CG_PET_WND_VIEW
PUBLIC	?CG_PET_WND_DETAIL@@3HA				; CG_PET_WND_DETAIL
PUBLIC	?CG_NAME_CHANGE_WND@@3HA			; CG_NAME_CHANGE_WND
PUBLIC	?CG_ITEM_WND_1@@3HA				; CG_ITEM_WND_1
PUBLIC	?CG_JUJUTU_WND@@3HA				; CG_JUJUTU_WND
PUBLIC	?CG_ITEM_WND_SELECT_WND@@3HA			; CG_ITEM_WND_SELECT_WND
PUBLIC	?CG_STATUS_WND_GROUP_WND@@3HA			; CG_STATUS_WND_GROUP_WND
PUBLIC	?CG_MAP_WND@@3HA				; CG_MAP_WND
PUBLIC	?CG_STATUS_WND@@3HA				; CG_STATUS_WND
PUBLIC	?CG_MAIL_WND@@3HA				; CG_MAIL_WND
PUBLIC	?CG_MAIL_WND_SEND_WND@@3HA			; CG_MAIL_WND_SEND_WND
PUBLIC	?CG_MAIL_WND_PET_SEND_WND@@3HA			; CG_MAIL_WND_PET_SEND_WND
PUBLIC	?CG_MAIL_WND_HISTORY_WND@@3HA			; CG_MAIL_WND_HISTORY_WND
PUBLIC	?CG_ALBUM_WND@@3HA				; CG_ALBUM_WND
PUBLIC	?CG_CHAT_REGISTY_WND@@3HA			; CG_CHAT_REGISTY_WND
PUBLIC	?CG_COMMON_WIN_YORO@@3HA			; CG_COMMON_WIN_YORO
PUBLIC	?CG_FIELD_HELP_WND@@3HA				; CG_FIELD_HELP_WND
PUBLIC	?CG_MSG_WND@@3HA				; CG_MSG_WND
PUBLIC	?CG_PET_WAZA_WND@@3HA				; CG_PET_WAZA_WND
PUBLIC	?CG_ITEMSHOP_WIN@@3HA				; CG_ITEMSHOP_WIN
PUBLIC	?CG_SKILLSHOP_WIN@@3HA				; CG_SKILLSHOP_WIN
PUBLIC	?CG_ITEMSHOP_KOSU_WIN@@3HA			; CG_ITEMSHOP_KOSU_WIN
PUBLIC	?CG_FAMILY_DETAIL_WIN@@3HA			; CG_FAMILY_DETAIL_WIN
PUBLIC	?CG_FAMILY_BANK_WIN@@3HA			; CG_FAMILY_BANK_WIN
PUBLIC	?CG_BM_WND@@3HA					; CG_BM_WND
PUBLIC	?displayBpp@@3HA				; displayBpp
PUBLIC	?rBitLShift@@3HA				; rBitLShift
PUBLIC	?gBitLShift@@3HA				; gBitLShift
PUBLIC	?bBitLShift@@3HA				; bBitLShift
PUBLIC	?rBitRShift@@3HA				; rBitRShift
PUBLIC	?gBitRShift@@3HA				; gBitRShift
PUBLIC	?bBitRShift@@3HA				; bBitRShift
PUBLIC	?highColor32Palette@@3PAIA			; highColor32Palette
PUBLIC	?highColorPalette@@3PAGA			; highColorPalette
PUBLIC	?g_bUseAlpha@@3HA				; g_bUseAlpha
PUBLIC	?palFileName@@3PAPADA				; palFileName
PUBLIC	??_C@_0BF@PBDNMBLH@data?2pal?2Palet_1?4sap@	; `string'
PUBLIC	??_C@_0BF@HHKJLDBJ@data?2pal?2Palet_2?4sap@	; `string'
PUBLIC	??_C@_0BF@LMPFGALM@data?2pal?2Palet_3?4sap@	; `string'
PUBLIC	??_C@_0BF@KBPAFAAE@data?2pal?2Palet_4?4sap@	; `string'
PUBLIC	??_C@_0BF@GKKMIDKB@data?2pal?2Palet_5?4sap@	; `string'
PUBLIC	??_C@_0BF@OMDIPBAP@data?2pal?2Palet_6?4sap@	; `string'
PUBLIC	??_C@_0BF@CHGECCKK@data?2pal?2Palet_7?4sap@	; `string'
PUBLIC	??_C@_0BF@NGDCJAHP@data?2pal?2Palet_8?4sap@	; `string'
PUBLIC	??_C@_0BF@BNGOEDNK@data?2pal?2Palet_9?4sap@	; `string'
PUBLIC	??_C@_0BG@GEGAFMNK@data?2pal?2Palet_10?4sap@	; `string'
PUBLIC	??_C@_0BG@KPDMIPHP@data?2pal?2Palet_11?4sap@	; `string'
PUBLIC	??_C@_0BG@CJKIPNNB@data?2pal?2Palet_12?4sap@	; `string'
PUBLIC	??_C@_0BG@OCPECOHE@data?2pal?2Palet_13?4sap@	; `string'
PUBLIC	??_C@_0BG@PPPBBOMM@data?2pal?2Palet_14?4sap@	; `string'
PUBLIC	??_C@_0BG@DEKNMNGJ@data?2pal?2Palet_15?4sap@	; `string'
PUBLIC	??_C@_0BF@DKGBBCBC@data?2pal?2Palet_0?4sap@	; `string'
PUBLIC	??_C@_09BLALNGD@white?4sap@			; `string'
PUBLIC	??_C@_09NGENHOEG@black?4sap@			; `string'
PUBLIC	?framesToShow@@3HA				; framesToShow
PUBLIC	?skipFramesToShow@@3HA				; skipFramesToShow
PUBLIC	?BmpOffBits@@3HA				; BmpOffBits
PUBLIC	?MAX_PAL@@3HB					; MAX_PAL
PUBLIC	?g_szChannelTitle@@3PAY0N@DA			; g_szChannelTitle
PUBLIC	?Palette@@3PAUtagPALETTEENTRY@@A		; Palette
PUBLIC	?lpDraw@@3PAUDIRECT_DRAW@@A			; lpDraw
PUBLIC	?DDinitFlag@@3HA				; DDinitFlag
PUBLIC	?hFont@@3PAUHFONT__@@A				; hFont
PUBLIC	?PalState@@3UPALETTE_STATE@@A			; PalState
PUBLIC	?PalChangeFlag@@3HA				; PalChangeFlag
_BSS	SEGMENT
?CG_PKSERVER_PANEL@@3HA DD 01H DUP (?)			; CG_PKSERVER_PANEL
?CG_BATTTLE_SKILLCHOICE@@3HA DD 01H DUP (?)		; CG_BATTTLE_SKILLCHOICE
?CG_FIELD_SKILL_PANEL@@3HA DD 01H DUP (?)		; CG_FIELD_SKILL_PANEL
?CG_FIELD_CHATROOM_PANEL@@3HA DD 01H DUP (?)		; CG_FIELD_CHATROOM_PANEL
?CG_FIELD_SV_SELL_PANEL@@3HA DD 01H DUP (?)		; CG_FIELD_SV_SELL_PANEL
?CG_FIELD_SV_SELL_PRICE_PANEL@@3HA DD 01H DUP (?)	; CG_FIELD_SV_SELL_PRICE_PANEL
?CG_NEW_STATUS_WND@@3HA DD 01H DUP (?)			; CG_NEW_STATUS_WND
?CG_NEWITEM_WND@@3HA DD 01H DUP (?)			; CG_NEWITEM_WND
?CG_TRADE_WND@@3HA DD 01H DUP (?)			; CG_TRADE_WND
?CG_TRADE_VIEWWND@@3HA DD 01H DUP (?)			; CG_TRADE_VIEWWND
?CG_WND_G_0@@3HA DD 01H DUP (?)				; CG_WND_G_0
?CG_WND_G_1@@3HA DD 01H DUP (?)				; CG_WND_G_1
?CG_WND_G_2@@3HA DD 01H DUP (?)				; CG_WND_G_2
?CG_WND_G_3@@3HA DD 01H DUP (?)				; CG_WND_G_3
?CG_WND_G_4@@3HA DD 01H DUP (?)				; CG_WND_G_4
?CG_WND_G_5@@3HA DD 01H DUP (?)				; CG_WND_G_5
?CG_WND_G_6@@3HA DD 01H DUP (?)				; CG_WND_G_6
?CG_WND_G_7@@3HA DD 01H DUP (?)				; CG_WND_G_7
?CG_WND_G_8@@3HA DD 01H DUP (?)				; CG_WND_G_8
?CG_WND2_G_0@@3HA DD 01H DUP (?)			; CG_WND2_G_0
?CG_WND2_G_1@@3HA DD 01H DUP (?)			; CG_WND2_G_1
?CG_WND2_G_2@@3HA DD 01H DUP (?)			; CG_WND2_G_2
?CG_WND2_G_3@@3HA DD 01H DUP (?)			; CG_WND2_G_3
?CG_WND2_G_4@@3HA DD 01H DUP (?)			; CG_WND2_G_4
?CG_WND2_G_5@@3HA DD 01H DUP (?)			; CG_WND2_G_5
?CG_WND2_G_6@@3HA DD 01H DUP (?)			; CG_WND2_G_6
?CG_WND2_G_7@@3HA DD 01H DUP (?)			; CG_WND2_G_7
?CG_WND2_G_8@@3HA DD 01H DUP (?)			; CG_WND2_G_8
?CG_WND3_G_7@@3HA DD 01H DUP (?)			; CG_WND3_G_7
?CG_WND3_G_8@@3HA DD 01H DUP (?)			; CG_WND3_G_8
?CG_WND3_G_9@@3HA DD 01H DUP (?)			; CG_WND3_G_9
?CG_BTL_PET_CHANGE_WND@@3HA DD 01H DUP (?)		; CG_BTL_PET_CHANGE_WND
?CG_PET_WND_VIEW@@3HA DD 01H DUP (?)			; CG_PET_WND_VIEW
?CG_PET_WND_DETAIL@@3HA DD 01H DUP (?)			; CG_PET_WND_DETAIL
?CG_NAME_CHANGE_WND@@3HA DD 01H DUP (?)			; CG_NAME_CHANGE_WND
?CG_ITEM_WND_1@@3HA DD 01H DUP (?)			; CG_ITEM_WND_1
?CG_JUJUTU_WND@@3HA DD 01H DUP (?)			; CG_JUJUTU_WND
?CG_ITEM_WND_SELECT_WND@@3HA DD 01H DUP (?)		; CG_ITEM_WND_SELECT_WND
?CG_STATUS_WND_GROUP_WND@@3HA DD 01H DUP (?)		; CG_STATUS_WND_GROUP_WND
?CG_MAP_WND@@3HA DD 01H DUP (?)				; CG_MAP_WND
?CG_STATUS_WND@@3HA DD 01H DUP (?)			; CG_STATUS_WND
?CG_MAIL_WND@@3HA DD 01H DUP (?)			; CG_MAIL_WND
?CG_MAIL_WND_SEND_WND@@3HA DD 01H DUP (?)		; CG_MAIL_WND_SEND_WND
?CG_MAIL_WND_PET_SEND_WND@@3HA DD 01H DUP (?)		; CG_MAIL_WND_PET_SEND_WND
?CG_MAIL_WND_HISTORY_WND@@3HA DD 01H DUP (?)		; CG_MAIL_WND_HISTORY_WND
?CG_ALBUM_WND@@3HA DD 01H DUP (?)			; CG_ALBUM_WND
?CG_CHAT_REGISTY_WND@@3HA DD 01H DUP (?)		; CG_CHAT_REGISTY_WND
?CG_COMMON_WIN_YORO@@3HA DD 01H DUP (?)			; CG_COMMON_WIN_YORO
?CG_FIELD_HELP_WND@@3HA DD 01H DUP (?)			; CG_FIELD_HELP_WND
?CG_MSG_WND@@3HA DD 01H DUP (?)				; CG_MSG_WND
?CG_PET_WAZA_WND@@3HA DD 01H DUP (?)			; CG_PET_WAZA_WND
?CG_ITEMSHOP_WIN@@3HA DD 01H DUP (?)			; CG_ITEMSHOP_WIN
?CG_SKILLSHOP_WIN@@3HA DD 01H DUP (?)			; CG_SKILLSHOP_WIN
?CG_ITEMSHOP_KOSU_WIN@@3HA DD 01H DUP (?)		; CG_ITEMSHOP_KOSU_WIN
?CG_FAMILY_DETAIL_WIN@@3HA DD 01H DUP (?)		; CG_FAMILY_DETAIL_WIN
?CG_FAMILY_BANK_WIN@@3HA DD 01H DUP (?)			; CG_FAMILY_BANK_WIN
?CG_BM_WND@@3HA DD 01H DUP (?)				; CG_BM_WND
?displayBpp@@3HA DD 01H DUP (?)				; displayBpp
?rBitLShift@@3HA DD 01H DUP (?)				; rBitLShift
?gBitLShift@@3HA DD 01H DUP (?)				; gBitLShift
?bBitLShift@@3HA DD 01H DUP (?)				; bBitLShift
?rBitRShift@@3HA DD 01H DUP (?)				; rBitRShift
?gBitRShift@@3HA DD 01H DUP (?)				; gBitRShift
?bBitRShift@@3HA DD 01H DUP (?)				; bBitRShift
?highColor32Palette@@3PAIA DD 0100H DUP (?)		; highColor32Palette
?highColorPalette@@3PAGA DW 0100H DUP (?)		; highColorPalette
?g_bUseAlpha@@3HA DD 01H DUP (?)			; g_bUseAlpha
?framesToShow@@3HA DD 01H DUP (?)			; framesToShow
?skipFramesToShow@@3HA DD 01H DUP (?)			; skipFramesToShow
?BmpOffBits@@3HA DD 01H DUP (?)				; BmpOffBits
?Palette@@3PAUtagPALETTEENTRY@@A DD 0100H DUP (?)	; Palette
?lpDraw@@3PAUDIRECT_DRAW@@A DD 01H DUP (?)		; lpDraw
?DDinitFlag@@3HA DD 01H DUP (?)				; DDinitFlag
?hFont@@3PAUHFONT__@@A DD 01H DUP (?)			; hFont
?PalState@@3UPALETTE_STATE@@A DB 0cH DUP (?)		; PalState
?PalChangeFlag@@3HA DD 01H DUP (?)			; PalChangeFlag
_BSS	ENDS
CONST	SEGMENT
?MAX_PAL@@3HB DD 012H					; MAX_PAL
CONST	ENDS
;	COMDAT ??_C@_09NGENHOEG@black?4sap@
CONST	SEGMENT
??_C@_09NGENHOEG@black?4sap@ DB 'black.sap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BLALNGD@white?4sap@
CONST	SEGMENT
??_C@_09BLALNGD@white?4sap@ DB 'white.sap', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DKGBBCBC@data?2pal?2Palet_0?4sap@
CONST	SEGMENT
??_C@_0BF@DKGBBCBC@data?2pal?2Palet_0?4sap@ DB 'data\pal\Palet_0.sap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DEKNMNGJ@data?2pal?2Palet_15?4sap@
CONST	SEGMENT
??_C@_0BG@DEKNMNGJ@data?2pal?2Palet_15?4sap@ DB 'data\pal\Palet_15.sap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PPPBBOMM@data?2pal?2Palet_14?4sap@
CONST	SEGMENT
??_C@_0BG@PPPBBOMM@data?2pal?2Palet_14?4sap@ DB 'data\pal\Palet_14.sap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OCPECOHE@data?2pal?2Palet_13?4sap@
CONST	SEGMENT
??_C@_0BG@OCPECOHE@data?2pal?2Palet_13?4sap@ DB 'data\pal\Palet_13.sap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CJKIPNNB@data?2pal?2Palet_12?4sap@
CONST	SEGMENT
??_C@_0BG@CJKIPNNB@data?2pal?2Palet_12?4sap@ DB 'data\pal\Palet_12.sap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KPDMIPHP@data?2pal?2Palet_11?4sap@
CONST	SEGMENT
??_C@_0BG@KPDMIPHP@data?2pal?2Palet_11?4sap@ DB 'data\pal\Palet_11.sap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GEGAFMNK@data?2pal?2Palet_10?4sap@
CONST	SEGMENT
??_C@_0BG@GEGAFMNK@data?2pal?2Palet_10?4sap@ DB 'data\pal\Palet_10.sap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BNGOEDNK@data?2pal?2Palet_9?4sap@
CONST	SEGMENT
??_C@_0BF@BNGOEDNK@data?2pal?2Palet_9?4sap@ DB 'data\pal\Palet_9.sap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NGDCJAHP@data?2pal?2Palet_8?4sap@
CONST	SEGMENT
??_C@_0BF@NGDCJAHP@data?2pal?2Palet_8?4sap@ DB 'data\pal\Palet_8.sap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CHGECCKK@data?2pal?2Palet_7?4sap@
CONST	SEGMENT
??_C@_0BF@CHGECCKK@data?2pal?2Palet_7?4sap@ DB 'data\pal\Palet_7.sap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OMDIPBAP@data?2pal?2Palet_6?4sap@
CONST	SEGMENT
??_C@_0BF@OMDIPBAP@data?2pal?2Palet_6?4sap@ DB 'data\pal\Palet_6.sap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GKKMIDKB@data?2pal?2Palet_5?4sap@
CONST	SEGMENT
??_C@_0BF@GKKMIDKB@data?2pal?2Palet_5?4sap@ DB 'data\pal\Palet_5.sap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KBPAFAAE@data?2pal?2Palet_4?4sap@
CONST	SEGMENT
??_C@_0BF@KBPAFAAE@data?2pal?2Palet_4?4sap@ DB 'data\pal\Palet_4.sap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LMPFGALM@data?2pal?2Palet_3?4sap@
CONST	SEGMENT
??_C@_0BF@LMPFGALM@data?2pal?2Palet_3?4sap@ DB 'data\pal\Palet_3.sap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HHKJLDBJ@data?2pal?2Palet_2?4sap@
CONST	SEGMENT
??_C@_0BF@HHKJLDBJ@data?2pal?2Palet_2?4sap@ DB 'data\pal\Palet_2.sap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PBDNMBLH@data?2pal?2Palet_1?4sap@
CONST	SEGMENT
??_C@_0BF@PBDNMBLH@data?2pal?2Palet_1?4sap@ DB 'data\pal\Palet_1.sap', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
?palFileName@@3PAPADA DD FLAT:??_C@_0BF@PBDNMBLH@data?2pal?2Palet_1?4sap@ ; palFileName
	DD	FLAT:??_C@_0BF@HHKJLDBJ@data?2pal?2Palet_2?4sap@
	DD	FLAT:??_C@_0BF@LMPFGALM@data?2pal?2Palet_3?4sap@
	DD	FLAT:??_C@_0BF@KBPAFAAE@data?2pal?2Palet_4?4sap@
	DD	FLAT:??_C@_0BF@GKKMIDKB@data?2pal?2Palet_5?4sap@
	DD	FLAT:??_C@_0BF@OMDIPBAP@data?2pal?2Palet_6?4sap@
	DD	FLAT:??_C@_0BF@CHGECCKK@data?2pal?2Palet_7?4sap@
	DD	FLAT:??_C@_0BF@NGDCJAHP@data?2pal?2Palet_8?4sap@
	DD	FLAT:??_C@_0BF@BNGOEDNK@data?2pal?2Palet_9?4sap@
	DD	FLAT:??_C@_0BG@GEGAFMNK@data?2pal?2Palet_10?4sap@
	DD	FLAT:??_C@_0BG@KPDMIPHP@data?2pal?2Palet_11?4sap@
	DD	FLAT:??_C@_0BG@CJKIPNNB@data?2pal?2Palet_12?4sap@
	DD	FLAT:??_C@_0BG@OCPECOHE@data?2pal?2Palet_13?4sap@
	DD	FLAT:??_C@_0BG@PPPBBOMM@data?2pal?2Palet_14?4sap@
	DD	FLAT:??_C@_0BG@DEKNMNGJ@data?2pal?2Palet_15?4sap@
	DD	FLAT:??_C@_0BF@DKGBBCBC@data?2pal?2Palet_0?4sap@
	DD	FLAT:??_C@_09BLALNGD@white?4sap@
	DD	FLAT:??_C@_09NGENHOEG@black?4sap@
?g_szChannelTitle@@3PAY0N@DA DB '[', 0dcH, 0c5H, ']', 00H ; g_szChannelTitle
	ORG $+8
	DB	'[', 0daH, 0cbH, ']', 00H
	ORG $+8
	DB	'[?]', 00H
	ORG $+9
	DB	'[', 0f0H, 0e9H, ']', 00H
	ORG $+8
	DB	'[?]', 00H
	ORG $+9
	DB	'[', 0d6H, 0fdH, ']', 00H
	ORG $+8
	DB	'[', 0e1H, 0a6H, ']', 00H
	ORG $+8
	DB	'[', 0e0H, 0f8H, ']', 00H
	ORG $+8
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_sprintf
PUBLIC	?InitDirectDraw@@YAHXZ				; InitDirectDraw
PUBLIC	?InitPalette@@YAHXZ				; InitPalette
PUBLIC	?ClearBackSurface@@YAXXZ			; ClearBackSurface
PUBLIC	?ClearSurface@@YAXPAUIDirectDrawSurface@@@Z	; ClearSurface
PUBLIC	?LoadDirectDrawBitmap@@YAPAUtagBITMAPINFO@@PAD@Z ; LoadDirectDrawBitmap
PUBLIC	?CreateSurface@@YAPAUIDirectDrawSurface@@FFKI@Z	; CreateSurface
PUBLIC	?DrawSurfaceFast@@YAJFFPAUIDirectDrawSurface@@@Z ; DrawSurfaceFast
PUBLIC	?DrawBitmapToSurface2@@YAXPAUsurfaceInfo@@HHHHPAUtagBITMAPINFO@@@Z ; DrawBitmapToSurface2
PUBLIC	?DrawSurfaceFast2@@YAJFFPAUtagRECT@@PAUIDirectDrawSurface@@@Z ; DrawSurfaceFast2
PUBLIC	?DrawBitmapToSurface@@YAXPAUIDirectDrawSurface@@HHPAUtagBITMAPINFO@@@Z ; DrawBitmapToSurface
PUBLIC	?Flip@@YAXXZ					; Flip
PUBLIC	?CheckSurfaceLost@@YAHXZ			; CheckSurfaceLost
PUBLIC	?ReleaseDirectDraw@@YAXXZ			; ReleaseDirectDraw
PUBLIC	?DrawDebugLine@@YAXE@Z				; DrawDebugLine
PUBLIC	?DrawBox@@YAXPAUtagRECT@@EH@Z			; DrawBox
PUBLIC	?InitFont@@YAXH@Z				; InitFont
PUBLIC	?PutText@@YAXD@Z				; PutText
PUBLIC	?PaletteProc@@YAXXZ				; PaletteProc
PUBLIC	?PaletteChange@@YAXHH@Z				; PaletteChange
PUBLIC	?DrawAutoMapping@@YAXHHPAEHH@Z			; DrawAutoMapping
PUBLIC	?getAutoMapColor@@YAHI@Z			; getAutoMapColor
PUBLIC	?getNearestColorIndex@@YAHKPAUtagPALETTEENTRY@@H@Z ; getNearestColorIndex
PUBLIC	?snapShot@@YAXXZ				; snapShot
PUBLIC	?saveBmpFile@@YAHPBDPAEHHHHHPAUtagRGBQUAD@@H@Z	; saveBmpFile
PUBLIC	?saveBmpFile16@@YAHPBDPAEHH@Z			; saveBmpFile16
PUBLIC	?DrawMapEffect@@YAXXZ				; DrawMapEffect
PUBLIC	?CreateNewFont@@YAPAUHFONT__@@H@Z		; CreateNewFont
PUBLIC	?SetAnimTbl@@YAXXZ				; SetAnimTbl
PUBLIC	?getBitCount@@YAHH@Z				; getBitCount
PUBLIC	??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ		; sprintf_s<256>
PUBLIC	?CalculateFrameRate@@YAXXZ			; CalculateFrameRate
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0N@FNIPCMMK@ErrorLog?4txt@		; `string'
PUBLIC	??_C@_0CM@HMMIJENE@DirectDrawCreate?5error?$CI1?$CJ?3error@ ; `string'
PUBLIC	??_C@_04IJNKKJEO@?H?$KO?$MA?N@			; `string'
PUBLIC	??_C@_0BH@MKFLKCNM@DirectDrawCreate?5Error@	; `string'
PUBLIC	??_C@_0CM@HNGBGDH@DirectDrawCreate?5error?$CI2?$CJ?3error@ ; `string'
PUBLIC	??_C@_0BF@GFNNOOOA@QueryInterface?5Error@	; `string'
PUBLIC	??_C@_0CH@HAIHOBCK@QueryInterface?5error?3error?5resu@ ; `string'
PUBLIC	??_C@_0BK@PLBEKNJA@SetCooperativeLevel?5Error@	; `string'
PUBLIC	??_C@_0BD@MODJDGBN@?$LI?$NO?$MA?N?H?$KN?$LI?i?C?$LD?$LI?$KO?$LN?G?F?P?$KB?$KD@ ; `string'
PUBLIC	??_C@_0CO@JBEGDDIO@Create?5frontbuffer?5error?$CI1?$CJ?3err@ ; `string'
PUBLIC	??_C@_0BC@OBNPBHMK@clipper?C?$LD?$LI?$KO?$LN?G?F?P?$KB?$KD@ ; `string'
PUBLIC	??_C@_0BF@NIDKJJHH@?$LH?$LJ?A?v?$LN?$LK?F?$KO?$LI?$KO?5?C?$LD?$LI?$KO?5?$LN?G?F?P@ ; `string'
PUBLIC	??_C@_0CK@MMFDMNJJ@Create?5backbuffer?5error?3error?5r@ ; `string'
PUBLIC	??_C@_0BI@CJPGPEBL@?$LI?$NO?$MA?N?5?H?$KN?$LI?i?5?C?$LD?$LI?$KO?5?$LN?G?F?P?52?$KB?$KD@ ; `string'
PUBLIC	??_C@_0CO@OKFILBGN@Create?5frontbuffer?5error?$CI2?$CJ?3err@ ; `string'
PUBLIC	??_C@_0BK@COBJPLEN@BattleSurface?5?$LB?$LI?$LM?$LK?5?$LN?G?F?P?$KD?$KB@ ; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_05NAOIJFC@Error@				; `string'
PUBLIC	??_C@_0BB@MMJDDNEI@?$MA?N?$LF?$KG?$LN?$LK?5?F?D?$MA?O?5?$MA?P?$LB?b@ ; `string'
PUBLIC	??_C@_0BB@KCGIAGNL@?F?H?$LH?$LJ?F?$KO?5?C?$LD?$LI?$KO?5?$LN?G?F?P@ ; `string'
PUBLIC	??_C@_0DN@ECLMIGIM@16?$LK?q?F?$KO?5?G?O?$MA?L?5?D?C?$LH?$KP?5?$LG?G?$LE?B?532?$LK?q?F?$KO?5?G?O@ ; `string'
PUBLIC	??_C@_0BD@KMOPGAB@Heap?n?$NM?$NL?U?v?G?$DP?$DP?$DP?c?w?$DP?$KD?$KB@ ; `string'
PUBLIC	??_C@_0BF@IOHJJJNA@Surface?n?$NMUnlock?c?w?$DP?$KD?$KB@ ; `string'
PUBLIC	??_C@_06MFMMLLPC@?$LB?$LM?$LI?$LC?C?$LM@	; `string'
PUBLIC	??_C@_0L@CMHOPIGK@screenshot@			; `string'
PUBLIC	??_C@_0CD@EDDPAJGO@screenshot?2sa?$CF02d?$CF02d?$CF02d_?$CF03d?4@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r@				; `string'
PUBLIC	??_C@_0DJ@LPEMAEJF@?2VBOXSVR?2_stoneage?2repos?2ssm?9sa@ ; `string'
PUBLIC	__real@3a83126f
PUBLIC	__real@3f800000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	__errno:PROC
EXTRN	_fclose:PROC
EXTRN	_fgetc:PROC
EXTRN	_fopen:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___stdio_common_vsprintf_s:PROC
EXTRN	__localtime64:PROC
EXTRN	__time64:PROC
EXTRN	__mkdir:PROC
EXTRN	??_U@YAPAXIHPBDH@Z:PROC				; operator new[]
EXTRN	?TimeGetTime@@YAIXZ:PROC			; TimeGetTime
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__WriteFile@20:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__HeapAlloc@12:PROC
EXTRN	__imp__HeapFree@12:PROC
EXTRN	__imp__GetProcessHeap@0:PROC
EXTRN	__imp__OpenFile@12:PROC
EXTRN	__imp___hread@12:PROC
EXTRN	__imp___lclose@4:PROC
EXTRN	__imp__CreateFontA@56:PROC
EXTRN	__imp__DeleteObject@4:PROC
EXTRN	__imp__GetDeviceCaps@8:PROC
EXTRN	__imp__SelectObject@8:PROC
EXTRN	__imp__SetBkMode@8:PROC
EXTRN	__imp__StretchDIBits@52:PROC
EXTRN	__imp__SetTextColor@8:PROC
EXTRN	__imp__TextOutA@20:PROC
EXTRN	__imp__GetDC@4:PROC
EXTRN	__imp__ReleaseDC@8:PROC
EXTRN	__imp__ClientToScreen@8:PROC
EXTRN	_DirectDrawCreate@12:PROC
EXTRN	?realGetImage@@YAHHPAPAEPAH1@Z:PROC		; realGetImage
EXTRN	?MessageBoxNew@@YAHPAUHWND__@@PBD1I@Z:PROC	; MessageBoxNew
EXTRN	?SkyIslandLoadBmp@@YAXXZ:PROC			; SkyIslandLoadBmp
EXTRN	?SkyIslandRelease@@YAXXZ:PROC			; SkyIslandRelease
EXTRN	?SkyIslandCheckSurface@@YAHXZ:PROC		; SkyIslandCheckSurface
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_IID_IDirectDraw2:BYTE
EXTRN	?lpBattleSurface@@3PAUIDirectDrawSurface@@A:DWORD ; lpBattleSurface
EXTRN	?SurfaceSizeX@@3HA:DWORD			; SurfaceSizeX
EXTRN	?SurfaceSizeY@@3HA:DWORD			; SurfaceSizeY
EXTRN	?SurfaceInfo@@3PAUsurfaceInfo@@A:BYTE		; SurfaceInfo
EXTRN	?SurfaceCnt@@3HA:DWORD				; SurfaceCnt
EXTRN	?DEF_APPSIZEX@@3HA:DWORD			; DEF_APPSIZEX
EXTRN	?DEF_APPSIZEY@@3HA:DWORD			; DEF_APPSIZEY
EXTRN	?hWnd@@3PAUHWND__@@A:DWORD			; hWnd
EXTRN	?WindowMode@@3HA:DWORD				; WindowMode
EXTRN	?ResoMode@@3HA:DWORD				; ResoMode
EXTRN	?pRealBinBits@@3PADA:DWORD			; pRealBinBits
EXTRN	?RealBinWidth@@3HA:DWORD			; RealBinWidth
EXTRN	?FontBuffer@@3PAUFONT_BUFFER@@A:BYTE		; FontBuffer
EXTRN	?FontCnt@@3HA:DWORD				; FontCnt
EXTRN	?transmigrationEffectFlag@@3HA:DWORD		; transmigrationEffectFlag
EXTRN	?transEffectPaletteStatus@@3HA:DWORD		; transEffectPaletteStatus
EXTRN	?useBufMapEffect@@3PAU_MAP_EFFECT@@A:DWORD	; useBufMapEffect
EXTRN	?NewColor16Flg@@3HA:DWORD			; NewColor16Flg
EXTRN	?g_clientRect@@3UtagRECT@@A:BYTE		; g_clientRect
EXTRN	?g_clientPoint@@3UtagPOINT@@A:QWORD		; g_clientPoint
EXTRN	?g_moveRect@@3UtagRECT@@A:BYTE			; g_moveRect
EXTRN	?g_hideSA@@3HA:DWORD				; g_hideSA
EXTRN	?NoDrawCnt@@3HA:DWORD				; NoDrawCnt
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?bChanged@?1??PaletteChange@@YAXHH@Z@4_NA
_BSS	SEGMENT
?bChanged@?1??PaletteChange@@YAXHH@Z@4_NA DB 01H DUP (?) ; `PaletteChange'::`2'::bChanged
_BSS	ENDS
;	COMDAT ?pal@?1??PaletteProc@@YAXXZ@4PAUtagPALETTEENTRY@@A
_BSS	SEGMENT
?pal@?1??PaletteProc@@YAXXZ@4PAUtagPALETTEENTRY@@A DD 0100H DUP (?) ; `PaletteProc'::`2'::pal
_BSS	ENDS
;	COMDAT ?dRed@?1??PaletteProc@@YAXXZ@4PAMA
_BSS	SEGMENT
?dRed@?1??PaletteProc@@YAXXZ@4PAMA DD 0100H DUP (?)	; `PaletteProc'::`2'::dRed
_BSS	ENDS
;	COMDAT ?dGreen@?1??PaletteProc@@YAXXZ@4PAMA
_BSS	SEGMENT
?dGreen@?1??PaletteProc@@YAXXZ@4PAMA DD 0100H DUP (?)	; `PaletteProc'::`2'::dGreen
_BSS	ENDS
;	COMDAT ?dBlue@?1??PaletteProc@@YAXXZ@4PAMA
_BSS	SEGMENT
?dBlue@?1??PaletteProc@@YAXXZ@4PAMA DD 0100H DUP (?)	; `PaletteProc'::`2'::dBlue
_BSS	ENDS
;	COMDAT ?dRedBak@?1??PaletteProc@@YAXXZ@4PAMA
_BSS	SEGMENT
?dRedBak@?1??PaletteProc@@YAXXZ@4PAMA DD 0100H DUP (?)	; `PaletteProc'::`2'::dRedBak
_BSS	ENDS
;	COMDAT ?dGreenBak@?1??PaletteProc@@YAXXZ@4PAMA
_BSS	SEGMENT
?dGreenBak@?1??PaletteProc@@YAXXZ@4PAMA DD 0100H DUP (?) ; `PaletteProc'::`2'::dGreenBak
_BSS	ENDS
;	COMDAT ?dBlueBak@?1??PaletteProc@@YAXXZ@4PAMA
_BSS	SEGMENT
?dBlueBak@?1??PaletteProc@@YAXXZ@4PAMA DD 0100H DUP (?)	; `PaletteProc'::`2'::dBlueBak
_BSS	ENDS
;	COMDAT ?timeCnt@?1??PaletteProc@@YAXXZ@4HA
_BSS	SEGMENT
?timeCnt@?1??PaletteProc@@YAXXZ@4HA DD 01H DUP (?)	; `PaletteProc'::`2'::timeCnt
_BSS	ENDS
;	COMDAT ?changeCnt@?1??PaletteProc@@YAXXZ@4HA
_BSS	SEGMENT
?changeCnt@?1??PaletteProc@@YAXXZ@4HA DD 01H DUP (?)	; `PaletteProc'::`2'::changeCnt
_BSS	ENDS
;	COMDAT ?palNoBak@?1??PaletteProc@@YAXXZ@4HA
_BSS	SEGMENT
?palNoBak@?1??PaletteProc@@YAXXZ@4HA DD 01H DUP (?)	; `PaletteProc'::`2'::palNoBak
_BSS	ENDS
;	COMDAT ?openFlag@?1??PaletteProc@@YAXXZ@4HA
_BSS	SEGMENT
?openFlag@?1??PaletteProc@@YAXXZ@4HA DD 01H DUP (?)	; `PaletteProc'::`2'::openFlag
_BSS	ENDS
;	COMDAT ?framesSkipPerSecond@?1??CalculateFrameRate@@YAXXZ@4HA
_BSS	SEGMENT
?framesSkipPerSecond@?1??CalculateFrameRate@@YAXXZ@4HA DD 01H DUP (?) ; `CalculateFrameRate'::`2'::framesSkipPerSecond
_BSS	ENDS
;	COMDAT ?framesPerSecond@?1??CalculateFrameRate@@YAXXZ@4MA
_BSS	SEGMENT
?framesPerSecond@?1??CalculateFrameRate@@YAXXZ@4MA DD 01H DUP (?) ; `CalculateFrameRate'::`2'::framesPerSecond
_BSS	ENDS
;	COMDAT ?lastTime@?1??CalculateFrameRate@@YAXXZ@4MA
_BSS	SEGMENT
?lastTime@?1??CalculateFrameRate@@YAXXZ@4MA DD 01H DUP (?) ; `CalculateFrameRate'::`2'::lastTime
_BSS	ENDS
;	COMDAT ?pcFlush@?1??DrawAutoMapping@@YAXHHPAEHH@Z@4FA
_BSS	SEGMENT
?pcFlush@?1??DrawAutoMapping@@YAXHHPAEHH@Z@4FA DW 01H DUP (?) ; `DrawAutoMapping'::`2'::pcFlush
_BSS	ENDS
;	COMDAT ?pcFlushTime@?1??DrawAutoMapping@@YAXHHPAEHH@Z@4IA
_BSS	SEGMENT
?pcFlushTime@?1??DrawAutoMapping@@YAXHHPAEHH@Z@4IA DD 01H DUP (?) ; `DrawAutoMapping'::`2'::pcFlushTime
_BSS	ENDS
;	COMDAT ?width@?1??getAutoMapColor@@YAHI@Z@4HA
_BSS	SEGMENT
?width@?1??getAutoMapColor@@YAHI@Z@4HA DD 01H DUP (?)	; `getAutoMapColor'::`2'::width
_BSS	ENDS
;	COMDAT ?height@?1??getAutoMapColor@@YAHI@Z@4HA
_BSS	SEGMENT
?height@?1??getAutoMapColor@@YAHI@Z@4HA DD 01H DUP (?)	; `getAutoMapColor'::`2'::height
_BSS	ENDS
;	COMDAT ?graBuf@?1??getAutoMapColor@@YAHI@Z@4PAEA
_BSS	SEGMENT
?graBuf@?1??getAutoMapColor@@YAHI@Z@4PAEA DD 01H DUP (?) ; `getAutoMapColor'::`2'::graBuf
_BSS	ENDS
;	COMDAT ?newFont@?BD@??PutText@@YAXD@Z@4PAUHFONT__@@A
_BSS	SEGMENT
?newFont@?BD@??PutText@@YAXD@Z@4PAUHFONT__@@A DD 01H DUP (?) ; `PutText'::`19'::newFont
_BSS	ENDS
;	COMDAT ?oldFont@?BD@??PutText@@YAXD@Z@4PAUHFONT__@@A
_BSS	SEGMENT
?oldFont@?BD@??PutText@@YAXD@Z@4PAUHFONT__@@A DD 01H DUP (?) ; `PutText'::`19'::oldFont
_BSS	ENDS
;	COMDAT ?newFont@?DL@??PutText@@YAXD@Z@4PAUHFONT__@@A
_BSS	SEGMENT
?newFont@?DL@??PutText@@YAXD@Z@4PAUHFONT__@@A DD 01H DUP (?) ; `PutText'::`59'::newFont
_BSS	ENDS
;	COMDAT ?oldFont@?DL@??PutText@@YAXD@Z@4PAUHFONT__@@A
_BSS	SEGMENT
?oldFont@?DL@??PutText@@YAXD@Z@4PAUHFONT__@@A DD 01H DUP (?) ; `PutText'::`59'::oldFont
_BSS	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT ??_C@_0DJ@LPEMAEJF@?2VBOXSVR?2_stoneage?2repos?2ssm?9sa@
CONST	SEGMENT
??_C@_0DJ@LPEMAEJF@?2VBOXSVR?2_stoneage?2repos?2ssm?9sa@ DB '\VBOXSVR\_st'
	DB	'oneage\repos\ssm-sacli\system\directDraw.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r@
CONST	SEGMENT
??_C@_01KDCPPGHE@r@ DB 'r', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@EDDPAJGO@screenshot?2sa?$CF02d?$CF02d?$CF02d_?$CF03d?4@
CONST	SEGMENT
??_C@_0CD@EDDPAJGO@screenshot?2sa?$CF02d?$CF02d?$CF02d_?$CF03d?4@ DB 'scr'
	DB	'eenshot\sa%02d%02d%02d_%03d.bmp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CMHOPIGK@screenshot@
CONST	SEGMENT
??_C@_0L@CMHOPIGK@screenshot@ DB 'screenshot', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MFMMLLPC@?$LB?$LM?$LI?$LC?C?$LM@
CONST	SEGMENT
??_C@_06MFMMLLPC@?$LB?$LM?$LI?$LC?C?$LM@ DB 0b1H, 0bcH, 0b8H, 0b2H, 0c3H, 0bcH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IOHJJJNA@Surface?n?$NMUnlock?c?w?$DP?$KD?$KB@
CONST	SEGMENT
??_C@_0BF@IOHJJJNA@Surface?n?$NMUnlock?c?w?$DP?$KD?$KB@ DB 'Surface', 0eeH
	DB	0dcH, 'Unlock', 0e3H, 0f7H, '?', 0a3H, 0a1H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KMOPGAB@Heap?n?$NM?$NL?U?v?G?$DP?$DP?$DP?c?w?$DP?$KD?$KB@
CONST	SEGMENT
??_C@_0BD@KMOPGAB@Heap?n?$NM?$NL?U?v?G?$DP?$DP?$DP?c?w?$DP?$KD?$KB@ DB 'H'
	DB	'eap', 0eeH, 0dcH, 0dbH, 0d5H, 0f6H, 0c7H, '???', 0e3H, 0f7H, '?'
	DB	0a3H, 0a1H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@ECLMIGIM@16?$LK?q?F?$KO?5?G?O?$MA?L?5?D?C?$LH?$KP?5?$LG?G?$LE?B?532?$LK?q?F?$KO?5?G?O@
CONST	SEGMENT
??_C@_0DN@ECLMIGIM@16?$LK?q?F?$KO?5?G?O?$MA?L?5?D?C?$LH?$KP?5?$LG?G?$LE?B?532?$LK?q?F?$KO?5?G?O@ DB '1'
	DB	'6', 0baH, 0f1H, 0c6H, 0aeH, ' ', 0c7H, 0cfH, 0c0H, 0ccH, ' ', 0c4H
	DB	0c3H, 0b7H, 0afH, ' ', 0b6H, 0c7H, 0b4H, 0c2H, ' 32', 0baH, 0f1H
	DB	0c6H, 0aeH, ' ', 0c7H, 0cfH, 0c0H, 0ccH, ' ', 0c4H, 0c3H, 0b7H
	DB	0afH, ' ', 0c7H, 0c1H, 0b7H, 0b9H, 0c0H, 0d3H, 0c0H, 0bbH, ' ', 0bbH
	DB	0e7H, 0bfH, 0ebH, 0c7H, 0d8H, 0c1H, 0d6H, 0bcH, 0bcH, 0bfH, 0e4H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KCGIAGNL@?F?H?$LH?$LJ?F?$KO?5?C?$LD?$LI?$KO?5?$LN?G?F?P@
CONST	SEGMENT
??_C@_0BB@KCGIAGNL@?F?H?$LH?$LJ?F?$KO?5?C?$LD?$LI?$KO?5?$LN?G?F?P@ DB 0c6H
	DB	0c8H, 0b7H, 0b9H, 0c6H, 0aeH, ' ', 0c3H, 0b3H, 0b8H, 0aeH, ' ', 0bdH
	DB	0c7H, 0c6H, 0d0H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MMJDDNEI@?$MA?N?$LF?$KG?$LN?$LK?5?F?D?$MA?O?5?$MA?P?$LB?b@
CONST	SEGMENT
??_C@_0BB@MMJDDNEI@?$MA?N?$LF?$KG?$LN?$LK?5?F?D?$MA?O?5?$MA?P?$LB?b@ DB 0c0H
	DB	0ceH, 0b5H, 0a6H, 0bdH, 0baH, ' ', 0c6H, 0c4H, 0c0H, 0cfH, ' ', 0c0H
	DB	0d0H, 0b1H, 0e2H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05NAOIJFC@Error@
CONST	SEGMENT
??_C@_05NAOIJFC@Error@ DB 'Error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@COBJPLEN@BattleSurface?5?$LB?$LI?$LM?$LK?5?$LN?G?F?P?$KD?$KB@
CONST	SEGMENT
??_C@_0BK@COBJPLEN@BattleSurface?5?$LB?$LI?$LM?$LK?5?$LN?G?F?P?$KD?$KB@ DB 'B'
	DB	'attleSurface ', 0b1H, 0b8H, 0bcH, 0baH, ' ', 0bdH, 0c7H, 0c6H
	DB	0d0H, 0a3H, 0a1H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@OKFILBGN@Create?5frontbuffer?5error?$CI2?$CJ?3err@
CONST	SEGMENT
??_C@_0CO@OKFILBGN@Create?5frontbuffer?5error?$CI2?$CJ?3err@ DB 'Create f'
	DB	'rontbuffer error(2):error result (%x)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CJPGPEBL@?$LI?$NO?$MA?N?5?H?$KN?$LI?i?5?C?$LD?$LI?$KO?5?$LN?G?F?P?52?$KB?$KD@
CONST	SEGMENT
??_C@_0BI@CJPGPEBL@?$LI?$NO?$MA?N?5?H?$KN?$LI?i?5?C?$LD?$LI?$KO?5?$LN?G?F?P?52?$KB?$KD@ DB 0b8H
	DB	0deH, 0c0H, 0ceH, ' ', 0c8H, 0adH, 0b8H, 0e9H, ' ', 0c3H, 0b3H
	DB	0b8H, 0aeH, ' ', 0bdH, 0c7H, 0c6H, 0d0H, ' 2', 0a1H, 0a3H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@MMFDMNJJ@Create?5backbuffer?5error?3error?5r@
CONST	SEGMENT
??_C@_0CK@MMFDMNJJ@Create?5backbuffer?5error?3error?5r@ DB 'Create backbu'
	DB	'ffer error:error result (%x)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NIDKJJHH@?$LH?$LJ?A?v?$LN?$LK?F?$KO?$LI?$KO?5?C?$LD?$LI?$KO?5?$LN?G?F?P@
CONST	SEGMENT
??_C@_0BF@NIDKJJHH@?$LH?$LJ?A?v?$LN?$LK?F?$KO?$LI?$KO?5?C?$LD?$LI?$KO?5?$LN?G?F?P@ DB 0b7H
	DB	0b9H, 0c1H, 0f6H, 0bdH, 0baH, 0c6H, 0aeH, 0b8H, 0aeH, ' ', 0c3H
	DB	0b3H, 0b8H, 0aeH, ' ', 0bdH, 0c7H, 0c6H, 0d0H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OBNPBHMK@clipper?C?$LD?$LI?$KO?$LN?G?F?P?$KB?$KD@
CONST	SEGMENT
??_C@_0BC@OBNPBHMK@clipper?C?$LD?$LI?$KO?$LN?G?F?P?$KB?$KD@ DB 'clipper', 0c3H
	DB	0b3H, 0b8H, 0aeH, 0bdH, 0c7H, 0c6H, 0d0H, 0a1H, 0a3H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@JBEGDDIO@Create?5frontbuffer?5error?$CI1?$CJ?3err@
CONST	SEGMENT
??_C@_0CO@JBEGDDIO@Create?5frontbuffer?5error?$CI1?$CJ?3err@ DB 'Create f'
	DB	'rontbuffer error(1):error result (%x)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MODJDGBN@?$LI?$NO?$MA?N?H?$KN?$LI?i?C?$LD?$LI?$KO?$LN?G?F?P?$KB?$KD@
CONST	SEGMENT
??_C@_0BD@MODJDGBN@?$LI?$NO?$MA?N?H?$KN?$LI?i?C?$LD?$LI?$KO?$LN?G?F?P?$KB?$KD@ DB 0b8H
	DB	0deH, 0c0H, 0ceH, 0c8H, 0adH, 0b8H, 0e9H, 0c3H, 0b3H, 0b8H, 0aeH
	DB	0bdH, 0c7H, 0c6H, 0d0H, 0a1H, 0a3H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PLBEKNJA@SetCooperativeLevel?5Error@
CONST	SEGMENT
??_C@_0BK@PLBEKNJA@SetCooperativeLevel?5Error@ DB 'SetCooperativeLevel Er'
	DB	'ror', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HAIHOBCK@QueryInterface?5error?3error?5resu@
CONST	SEGMENT
??_C@_0CH@HAIHOBCK@QueryInterface?5error?3error?5resu@ DB 'QueryInterface'
	DB	' error:error result (%x)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GFNNOOOA@QueryInterface?5Error@
CONST	SEGMENT
??_C@_0BF@GFNNOOOA@QueryInterface?5Error@ DB 'QueryInterface Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@HNGBGDH@DirectDrawCreate?5error?$CI2?$CJ?3error@
CONST	SEGMENT
??_C@_0CM@HNGBGDH@DirectDrawCreate?5error?$CI2?$CJ?3error@ DB 'DirectDraw'
	DB	'Create error(2):error result (%x)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MKFLKCNM@DirectDrawCreate?5Error@
CONST	SEGMENT
??_C@_0BH@MKFLKCNM@DirectDrawCreate?5Error@ DB 'DirectDrawCreate Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IJNKKJEO@?H?$KO?$MA?N@
CONST	SEGMENT
??_C@_04IJNKKJEO@?H?$KO?$MA?N@ DB 0c8H, 0aeH, 0c0H, 0ceH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@HMMIJENE@DirectDrawCreate?5error?$CI1?$CJ?3error@
CONST	SEGMENT
??_C@_0CM@HMMIJENE@DirectDrawCreate?5error?$CI1?$CJ?3error@ DB 'DirectDra'
	DB	'wCreate error(1):error result (%x)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FNIPCMMK@ErrorLog?4txt@
CONST	SEGMENT
??_C@_0N@FNIPCMMK@ErrorLog?4txt@ DB 'ErrorLog.txt', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
?FontPal@@3PAKA DD 0ffffffH				; FontPal
	DD	0ffff00H
	DD	0ff00ffH
	DD	0ff0000H
	DD	0ffffH
	DD	0ff00H
	DD	0ffH
	DD	0a4a0a0H
	DD	0f0caa6H
	DD	0c0dcc0H
	DD	08cffH
	DD	0247fffH
	DD	00H
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?DrawMapEffect@@YAXXZ$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?DrawMapEffect@@YAXXZ$0
__unwindtable$?DrawMapEffect@@YAXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?DrawMapEffect@@YAXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?DrawMapEffect@@YAXXZ$2
__ehfuncinfo$?DrawMapEffect@@YAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DrawMapEffect@@YAXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?DrawMapEffect@@YAXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?DrawAutoMapping@@YAXHHPAEHH@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?DrawAutoMapping@@YAXHHPAEHH@Z$0
__unwindtable$?DrawAutoMapping@@YAXHHPAEHH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?DrawAutoMapping@@YAXHHPAEHH@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?DrawAutoMapping@@YAXHHPAEHH@Z$2
__ehfuncinfo$?DrawAutoMapping@@YAXHHPAEHH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DrawAutoMapping@@YAXHHPAEHH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?DrawAutoMapping@@YAXHHPAEHH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?PutText@@YAXD@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?PutText@@YAXD@Z$0
__unwindtable$?PutText@@YAXD@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?PutText@@YAXD@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?PutText@@YAXD@Z$2
__ehfuncinfo$?PutText@@YAXD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?PutText@@YAXD@Z
	DD	01H
	DD	FLAT:__tryblocktable$?PutText@@YAXD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?DrawBox@@YAXPAUtagRECT@@EH@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?DrawBox@@YAXPAUtagRECT@@EH@Z$0
__unwindtable$?DrawBox@@YAXPAUtagRECT@@EH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?DrawBox@@YAXPAUtagRECT@@EH@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?DrawBox@@YAXPAUtagRECT@@EH@Z$2
__ehfuncinfo$?DrawBox@@YAXPAUtagRECT@@EH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DrawBox@@YAXPAUtagRECT@@EH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?DrawBox@@YAXPAUtagRECT@@EH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?DrawDebugLine@@YAXE@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?DrawDebugLine@@YAXE@Z$0
__unwindtable$?DrawDebugLine@@YAXE@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?DrawDebugLine@@YAXE@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?DrawDebugLine@@YAXE@Z$2
__ehfuncinfo$?DrawDebugLine@@YAXE@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DrawDebugLine@@YAXE@Z
	DD	01H
	DD	FLAT:__tryblocktable$?DrawDebugLine@@YAXE@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?ReleaseDirectDraw@@YAXXZ$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?ReleaseDirectDraw@@YAXXZ$0
__unwindtable$?ReleaseDirectDraw@@YAXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?ReleaseDirectDraw@@YAXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?ReleaseDirectDraw@@YAXXZ$2
__ehfuncinfo$?ReleaseDirectDraw@@YAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ReleaseDirectDraw@@YAXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?ReleaseDirectDraw@@YAXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?CheckSurfaceLost@@YAHXZ$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?CheckSurfaceLost@@YAHXZ$0
__unwindtable$?CheckSurfaceLost@@YAHXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?CheckSurfaceLost@@YAHXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?CheckSurfaceLost@@YAHXZ$2
__ehfuncinfo$?CheckSurfaceLost@@YAHXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CheckSurfaceLost@@YAHXZ
	DD	01H
	DD	FLAT:__tryblocktable$?CheckSurfaceLost@@YAHXZ
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?Flip@@YAXXZ$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?Flip@@YAXXZ$0
__unwindtable$?Flip@@YAXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?Flip@@YAXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?Flip@@YAXXZ$2
__ehfuncinfo$?Flip@@YAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Flip@@YAXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?Flip@@YAXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?DrawBitmapToSurface@@YAXPAUIDirectDrawSurface@@HHPAUtagBITMAPINFO@@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?DrawBitmapToSurface@@YAXPAUIDirectDrawSurface@@HHPAUtagBITMAPINFO@@@Z$0
__unwindtable$?DrawBitmapToSurface@@YAXPAUIDirectDrawSurface@@HHPAUtagBITMAPINFO@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?DrawBitmapToSurface@@YAXPAUIDirectDrawSurface@@HHPAUtagBITMAPINFO@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?DrawBitmapToSurface@@YAXPAUIDirectDrawSurface@@HHPAUtagBITMAPINFO@@@Z$2
__ehfuncinfo$?DrawBitmapToSurface@@YAXPAUIDirectDrawSurface@@HHPAUtagBITMAPINFO@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DrawBitmapToSurface@@YAXPAUIDirectDrawSurface@@HHPAUtagBITMAPINFO@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?DrawBitmapToSurface@@YAXPAUIDirectDrawSurface@@HHPAUtagBITMAPINFO@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?DrawSurfaceFast2@@YAJFFPAUtagRECT@@PAUIDirectDrawSurface@@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?DrawSurfaceFast2@@YAJFFPAUtagRECT@@PAUIDirectDrawSurface@@@Z$0
__unwindtable$?DrawSurfaceFast2@@YAJFFPAUtagRECT@@PAUIDirectDrawSurface@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?DrawSurfaceFast2@@YAJFFPAUtagRECT@@PAUIDirectDrawSurface@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?DrawSurfaceFast2@@YAJFFPAUtagRECT@@PAUIDirectDrawSurface@@@Z$2
__ehfuncinfo$?DrawSurfaceFast2@@YAJFFPAUtagRECT@@PAUIDirectDrawSurface@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DrawSurfaceFast2@@YAJFFPAUtagRECT@@PAUIDirectDrawSurface@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?DrawSurfaceFast2@@YAJFFPAUtagRECT@@PAUIDirectDrawSurface@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?DrawBitmapToSurface2@@YAXPAUsurfaceInfo@@HHHHPAUtagBITMAPINFO@@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?DrawBitmapToSurface2@@YAXPAUsurfaceInfo@@HHHHPAUtagBITMAPINFO@@@Z$0
__unwindtable$?DrawBitmapToSurface2@@YAXPAUsurfaceInfo@@HHHHPAUtagBITMAPINFO@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?DrawBitmapToSurface2@@YAXPAUsurfaceInfo@@HHHHPAUtagBITMAPINFO@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?DrawBitmapToSurface2@@YAXPAUsurfaceInfo@@HHHHPAUtagBITMAPINFO@@@Z$2
__ehfuncinfo$?DrawBitmapToSurface2@@YAXPAUsurfaceInfo@@HHHHPAUtagBITMAPINFO@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DrawBitmapToSurface2@@YAXPAUsurfaceInfo@@HHHHPAUtagBITMAPINFO@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?DrawBitmapToSurface2@@YAXPAUsurfaceInfo@@HHHHPAUtagBITMAPINFO@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?DrawSurfaceFast@@YAJFFPAUIDirectDrawSurface@@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?DrawSurfaceFast@@YAJFFPAUIDirectDrawSurface@@@Z$0
__unwindtable$?DrawSurfaceFast@@YAJFFPAUIDirectDrawSurface@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?DrawSurfaceFast@@YAJFFPAUIDirectDrawSurface@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?DrawSurfaceFast@@YAJFFPAUIDirectDrawSurface@@@Z$2
__ehfuncinfo$?DrawSurfaceFast@@YAJFFPAUIDirectDrawSurface@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DrawSurfaceFast@@YAJFFPAUIDirectDrawSurface@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?DrawSurfaceFast@@YAJFFPAUIDirectDrawSurface@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?CreateSurface@@YAPAUIDirectDrawSurface@@FFKI@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?CreateSurface@@YAPAUIDirectDrawSurface@@FFKI@Z$0
__unwindtable$?CreateSurface@@YAPAUIDirectDrawSurface@@FFKI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?CreateSurface@@YAPAUIDirectDrawSurface@@FFKI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?CreateSurface@@YAPAUIDirectDrawSurface@@FFKI@Z$2
__ehfuncinfo$?CreateSurface@@YAPAUIDirectDrawSurface@@FFKI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CreateSurface@@YAPAUIDirectDrawSurface@@FFKI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?CreateSurface@@YAPAUIDirectDrawSurface@@FFKI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?LoadDirectDrawBitmap@@YAPAUtagBITMAPINFO@@PAD@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?LoadDirectDrawBitmap@@YAPAUtagBITMAPINFO@@PAD@Z$0
__unwindtable$?LoadDirectDrawBitmap@@YAPAUtagBITMAPINFO@@PAD@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?LoadDirectDrawBitmap@@YAPAUtagBITMAPINFO@@PAD@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?LoadDirectDrawBitmap@@YAPAUtagBITMAPINFO@@PAD@Z$2
__ehfuncinfo$?LoadDirectDrawBitmap@@YAPAUtagBITMAPINFO@@PAD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?LoadDirectDrawBitmap@@YAPAUtagBITMAPINFO@@PAD@Z
	DD	01H
	DD	FLAT:__tryblocktable$?LoadDirectDrawBitmap@@YAPAUtagBITMAPINFO@@PAD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?ClearSurface@@YAXPAUIDirectDrawSurface@@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?ClearSurface@@YAXPAUIDirectDrawSurface@@@Z$0
__unwindtable$?ClearSurface@@YAXPAUIDirectDrawSurface@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?ClearSurface@@YAXPAUIDirectDrawSurface@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?ClearSurface@@YAXPAUIDirectDrawSurface@@@Z$2
__ehfuncinfo$?ClearSurface@@YAXPAUIDirectDrawSurface@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ClearSurface@@YAXPAUIDirectDrawSurface@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?ClearSurface@@YAXPAUIDirectDrawSurface@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?ClearBackSurface@@YAXXZ$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?ClearBackSurface@@YAXXZ$0
__unwindtable$?ClearBackSurface@@YAXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?ClearBackSurface@@YAXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?ClearBackSurface@@YAXXZ$2
__ehfuncinfo$?ClearBackSurface@@YAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ClearBackSurface@@YAXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?ClearBackSurface@@YAXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?CalculateFrameRate@@YAXXZ
_TEXT	SEGMENT
?CalculateFrameRate@@YAXXZ PROC				; CalculateFrameRate, COMDAT

; 665  : 	static int framesSkipPerSecond = 0;
; 666  : 	static float framesPerSecond = 0.0f;       // This will store our fps
; 667  : 	static float lastTime = 0.0f;       // This will hold the time from the last frame
; 668  : 	float currentTime = TimeGetTime() * 0.001f;

  00000	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime

; 669  : 	++framesPerSecond;

  00005	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR ?framesPerSecond@?1??CalculateFrameRate@@YAXXZ@4MA

; 670  : 	framesSkipPerSecond += NoDrawCnt - 1;

  0000d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?framesSkipPerSecond@?1??CalculateFrameRate@@YAXXZ@4HA
  00013	f3 0f 58 1d 00
	00 00 00	 addss	 xmm3, DWORD PTR __real@3f800000
  0001b	66 0f 6e c0	 movd	 xmm0, eax
  0001f	49		 dec	 ecx
  00020	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00024	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?NoDrawCnt@@3HA ; NoDrawCnt
  0002a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002d	89 0d 00 00 00
	00		 mov	 DWORD PTR ?framesSkipPerSecond@?1??CalculateFrameRate@@YAXXZ@4HA, ecx
  00033	f3 0f 11 1d 00
	00 00 00	 movss	 DWORD PTR ?framesPerSecond@?1??CalculateFrameRate@@YAXXZ@4MA, xmm3
  0003b	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00044	66 0f 5a d0	 cvtpd2ps xmm2, xmm0
  00048	f3 0f 59 15 00
	00 00 00	 mulss	 xmm2, DWORD PTR __real@3a83126f

; 671  : 
; 672  : 	if (currentTime - lastTime > 1.0f)

  00050	0f 28 c2	 movaps	 xmm0, xmm2
  00053	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR ?lastTime@?1??CalculateFrameRate@@YAXXZ@4MA
  0005b	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00062	76 2b		 jbe	 SHORT $LN2@CalculateF

; 673  : 	{
; 674  : 		lastTime = currentTime;

  00064	f3 0f 2c c3	 cvttss2si eax, xmm3

; 675  : 		framesToShow= int(framesPerSecond);
; 676  : 		framesPerSecond = 0;

  00068	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?framesPerSecond@?1??CalculateFrameRate@@YAXXZ@4MA, 0

; 677  : 		skipFramesToShow = framesSkipPerSecond;

  00072	89 0d 00 00 00
	00		 mov	 DWORD PTR ?skipFramesToShow@@3HA, ecx ; skipFramesToShow

; 678  : 		framesSkipPerSecond = 0;

  00078	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?framesSkipPerSecond@?1??CalculateFrameRate@@YAXXZ@4HA, 0
  00082	f3 0f 11 15 00
	00 00 00	 movss	 DWORD PTR ?lastTime@?1??CalculateFrameRate@@YAXXZ@4MA, xmm2
  0008a	a3 00 00 00 00	 mov	 DWORD PTR ?framesToShow@@3HA, eax ; framesToShow
$LN2@CalculateF:

; 679  : 	}
; 680  : }

  0008f	c3		 ret	 0
?CalculateFrameRate@@YAXXZ ENDP				; CalculateFrameRate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ PROC		; sprintf_s<256>, COMDAT

; 1840 :         )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1491 :         int const _Result = __stdio_common_vsprintf_s(

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	68 00 01 00 00	 push	 256			; 00000100H
  00011	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00014	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	ff 30		 push	 DWORD PTR [eax]
  0001e	e8 00 00 00 00	 call	 ___stdio_common_vsprintf_s

; 1492 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1493 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1494 : 
; 1495 :         return _Result < 0 ? -1 : _Result;

  00023	83 c9 ff	 or	 ecx, -1
  00026	83 c4 1c	 add	 esp, 28			; 0000001cH
  00029	85 c0		 test	 eax, eax
  0002b	0f 48 c1	 cmovs	 eax, ecx

; 1496 :     }
; 1497 :     #endif
; 1498 : 
; 1499 :     #if __STDC_WANT_SECURE_LIB__
; 1500 : 
; 1501 :         _Success_(return >= 0)
; 1502 :         _Check_return_opt_
; 1503 :         _CRT_STDIO_INLINE int __CRTDECL vsprintf_s(
; 1504 :             _Out_writes_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
; 1505 :             _In_                                          size_t      const _BufferCount,
; 1506 :             _In_z_ _Printf_format_string_                 char const* const _Format,
; 1507 :                                                           va_list           _ArgList
; 1508 :             )
; 1509 :     #if defined _NO_CRT_STDIO_INLINE
; 1510 :     ;
; 1511 :     #else
; 1512 :         {
; 1513 :             return _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1514 :         }
; 1515 :     #endif
; 1516 : 
; 1517 :         __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
; 1518 :             _Success_(return >= 0)
; 1519 :             int, vsprintf_s,
; 1520 :             _Always_(_Post_z_)            char,        _Buffer,
; 1521 :             _In_z_ _Printf_format_string_ char const*, _Format,
; 1522 :                                           va_list,     _ArgList
; 1523 :             )
; 1524 : 
; 1525 :     #endif
; 1526 : 
; 1527 :     _Success_(return >= 0)
; 1528 :     _Check_return_opt_
; 1529 :     _CRT_STDIO_INLINE int __CRTDECL _vsprintf_p_l(
; 1530 :         _Out_writes_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
; 1531 :         _In_                                          size_t      const _BufferCount,
; 1532 :         _In_z_ _Printf_format_string_params_(2)       char const* const _Format,
; 1533 :         _In_opt_                                      _locale_t   const _Locale,
; 1534 :                                                       va_list           _ArgList
; 1535 :         )
; 1536 :     #if defined _NO_CRT_STDIO_INLINE
; 1537 :     ;
; 1538 :     #else
; 1539 :     {
; 1540 :         int const _Result = __stdio_common_vsprintf_p(
; 1541 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1542 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1543 : 
; 1544 :         return _Result < 0 ? -1 : _Result;
; 1545 :     }
; 1546 :     #endif
; 1547 : 
; 1548 :     _Success_(return >= 0)
; 1549 :     _Check_return_opt_
; 1550 :     _CRT_STDIO_INLINE int __CRTDECL _vsprintf_p(
; 1551 :         _Out_writes_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
; 1552 :         _In_                                          size_t      const _BufferCount,
; 1553 :         _In_z_ _Printf_format_string_                 char const* const _Format,
; 1554 :                                                       va_list           _ArgList
; 1555 :         )
; 1556 :     #if defined _NO_CRT_STDIO_INLINE
; 1557 :     ;
; 1558 :     #else
; 1559 :     {
; 1560 :         return _vsprintf_p_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1561 :     }
; 1562 :     #endif
; 1563 : 
; 1564 :     _Success_(return >= 0)
; 1565 :     _Check_return_opt_
; 1566 :     _CRT_STDIO_INLINE int __CRTDECL _vsnprintf_s_l(
; 1567 :         _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
; 1568 :         _In_                                              size_t      const _BufferCount,
; 1569 :         _In_                                              size_t      const _MaxCount,
; 1570 :         _In_z_ _Printf_format_string_params_(2)           char const* const _Format,
; 1571 :         _In_opt_                                          _locale_t   const _Locale,
; 1572 :                                                           va_list          _ArgList
; 1573 :         )
; 1574 :     #if defined _NO_CRT_STDIO_INLINE
; 1575 :     ;
; 1576 :     #else
; 1577 :     {
; 1578 :         int const _Result = __stdio_common_vsnprintf_s(
; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;
; 1583 :     }
; 1584 :     #endif
; 1585 : 
; 1586 :     _Success_(return >= 0)
; 1587 :     _Check_return_opt_
; 1588 :     _CRT_STDIO_INLINE int __CRTDECL _vsnprintf_s(
; 1589 :         _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
; 1590 :         _In_                                              size_t      const _BufferCount,
; 1591 :         _In_                                              size_t      const _MaxCount,
; 1592 :         _In_z_ _Printf_format_string_                     char const* const _Format,
; 1593 :                                                           va_list           _ArgList
; 1594 :         )
; 1595 :     #if defined _NO_CRT_STDIO_INLINE
; 1596 :     ;
; 1597 :     #else
; 1598 :     {
; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);
; 1600 :     }
; 1601 :     #endif
; 1602 : 
; 1603 :     __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(
; 1604 :         _Success_(return >= 0)
; 1605 :         int, _vsnprintf_s,
; 1606 :         _Always_(_Post_z_)            char,        _Buffer,
; 1607 :         _In_                          size_t,      _BufferCount,
; 1608 :         _In_z_ _Printf_format_string_ char const*, _Format,
; 1609 :                                       va_list,     _ArgList
; 1610 :         )
; 1611 : 
; 1612 :     #if __STDC_WANT_SECURE_LIB__
; 1613 : 
; 1614 :         _Success_(return >= 0)
; 1615 :         _Check_return_opt_
; 1616 :         _CRT_STDIO_INLINE int __CRTDECL vsnprintf_s(
; 1617 :             _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
; 1618 :             _In_                                              size_t      const _BufferCount,
; 1619 :             _In_                                              size_t      const _MaxCount,
; 1620 :             _In_z_ _Printf_format_string_                     char const* const _Format,
; 1621 :                                                               va_list           _ArgList
; 1622 :             )
; 1623 :     #if defined _NO_CRT_STDIO_INLINE
; 1624 :     ;
; 1625 :     #else
; 1626 :         {
; 1627 :             return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);
; 1628 :         }
; 1629 :     #endif
; 1630 : 
; 1631 :         __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(
; 1632 :             _Success_(return >= 0)
; 1633 :             int, vsnprintf_s,
; 1634 :             _Always_(_Post_z_)            char,        _Buffer,
; 1635 :             _In_                          size_t,      _BufferCount,
; 1636 :             _In_z_ _Printf_format_string_ char const*, _Format,
; 1637 :                                           va_list,     _ArgList
; 1638 :             )
; 1639 : 
; 1640 :     #endif
; 1641 : 
; 1642 :     _Check_return_opt_
; 1643 :     _CRT_STDIO_INLINE int __CRTDECL _vscprintf_l(
; 1644 :         _In_z_ _Printf_format_string_params_(2) char const* const _Format,
; 1645 :         _In_opt_                                _locale_t   const _Locale,
; 1646 :                                                 va_list           _ArgList
; 1647 :         )
; 1648 :     #if defined _NO_CRT_STDIO_INLINE
; 1649 :     ;
; 1650 :     #else
; 1651 :     {
; 1652 :         int const _Result = __stdio_common_vsprintf(
; 1653 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1654 :             NULL, 0, _Format, _Locale, _ArgList);
; 1655 : 
; 1656 :         return _Result < 0 ? -1 : _Result;
; 1657 :     }
; 1658 :     #endif
; 1659 : 
; 1660 :     _Check_return_
; 1661 :     _CRT_STDIO_INLINE int __CRTDECL _vscprintf(
; 1662 :         _In_z_ _Printf_format_string_ char const* const _Format,
; 1663 :                                       va_list           _ArgList
; 1664 :         )
; 1665 :     #if defined _NO_CRT_STDIO_INLINE
; 1666 :     ;
; 1667 :     #else
; 1668 :     {
; 1669 :         return _vscprintf_l(_Format, NULL, _ArgList);
; 1670 :     }
; 1671 :     #endif
; 1672 : 
; 1673 :     _Check_return_opt_
; 1674 :     _CRT_STDIO_INLINE int __CRTDECL _vscprintf_p_l(
; 1675 :         _In_z_ _Printf_format_string_params_(2) char const* const _Format,
; 1676 :         _In_opt_                                _locale_t   const _Locale,
; 1677 :                                                 va_list           _ArgList
; 1678 :         )
; 1679 :     #if defined _NO_CRT_STDIO_INLINE
; 1680 :     ;
; 1681 :     #else
; 1682 :     {
; 1683 :         int const _Result = __stdio_common_vsprintf_p(
; 1684 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1685 :             NULL, 0, _Format, _Locale, _ArgList);
; 1686 : 
; 1687 :         return _Result < 0 ? -1 : _Result;
; 1688 :     }
; 1689 :     #endif
; 1690 : 
; 1691 :     _Check_return_
; 1692 :     _CRT_STDIO_INLINE int __CRTDECL _vscprintf_p(
; 1693 :         _In_z_ _Printf_format_string_ char const* const _Format,
; 1694 :                                       va_list           _ArgList
; 1695 :         )
; 1696 :     #if defined _NO_CRT_STDIO_INLINE
; 1697 :     ;
; 1698 :     #else
; 1699 :     {
; 1700 :         return _vscprintf_p_l(_Format, NULL, _ArgList);
; 1701 :     }
; 1702 :     #endif
; 1703 : 
; 1704 :     _Check_return_opt_
; 1705 :     _CRT_STDIO_INLINE int __CRTDECL _vsnprintf_c_l(
; 1706 :         _Out_writes_opt_(_BufferCount)          char*       const _Buffer,
; 1707 :         _In_                                    size_t      const _BufferCount,
; 1708 :         _In_z_ _Printf_format_string_params_(2) char const* const _Format,
; 1709 :         _In_opt_                                _locale_t   const _Locale,
; 1710 :                                                 va_list           _ArgList
; 1711 :         )
; 1712 :     #if defined _NO_CRT_STDIO_INLINE
; 1713 :     ;
; 1714 :     #else
; 1715 :     {
; 1716 :         int const _Result = __stdio_common_vsprintf(
; 1717 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1718 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1719 : 
; 1720 :         return _Result < 0 ? -1 : _Result;
; 1721 :     }
; 1722 :     #endif
; 1723 : 
; 1724 :     _Success_(return >= 0)
; 1725 :     _Check_return_opt_
; 1726 :     _CRT_STDIO_INLINE int __CRTDECL _vsnprintf_c(
; 1727 :         _Out_writes_opt_(_BufferCount) char*       const _Buffer,
; 1728 :         _In_                           size_t      const _BufferCount,
; 1729 :         _In_z_ _Printf_format_string_  char const* const _Format,
; 1730 :                                        va_list           _ArgList
; 1731 :         )
; 1732 :     #if defined _NO_CRT_STDIO_INLINE
; 1733 :     ;
; 1734 :     #else
; 1735 :     {
; 1736 :         return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1737 :     }
; 1738 :     #endif
; 1739 : 
; 1740 :     _Success_(return >= 0)
; 1741 :     _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_sprintf_s_l)
; 1742 :     _CRT_STDIO_INLINE int __CRTDECL _sprintf_l(
; 1743 :         _Pre_notnull_ _Always_(_Post_z_)        char*       const _Buffer,
; 1744 :         _In_z_ _Printf_format_string_params_(0) char const* const _Format,
; 1745 :         _In_opt_                                _locale_t   const _Locale,
; 1746 :         ...)
; 1747 :     #if defined _NO_CRT_STDIO_INLINE
; 1748 :     ;
; 1749 :     #else
; 1750 :     {
; 1751 :         int _Result;
; 1752 :         va_list _ArgList;
; 1753 :         __crt_va_start(_ArgList, _Locale);
; 1754 : 
; 1755 :         _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);
; 1756 : 
; 1757 :         __crt_va_end(_ArgList);
; 1758 :         return _Result;
; 1759 :     }
; 1760 :     #endif
; 1761 : 
; 1762 :     _Success_(return >= 0)
; 1763 :     _Check_return_opt_
; 1764 :     _CRT_STDIO_INLINE int __CRTDECL sprintf(
; 1765 :         _Pre_notnull_ _Always_(_Post_z_) char*       const _Buffer,
; 1766 :         _In_z_ _Printf_format_string_    char const* const _Format,
; 1767 :         ...)
; 1768 :     #if defined _NO_CRT_STDIO_INLINE
; 1769 :     ;
; 1770 :     #else
; 1771 :     {
; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);
; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1777 : 
; 1778 :         __crt_va_end(_ArgList);
; 1779 :         return _Result;
; 1780 :     }
; 1781 :     #endif
; 1782 : 
; 1783 :     __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST(
; 1784 :         _Success_(return >= 0)
; 1785 :         int, __RETURN_POLICY_SAME, __EMPTY_DECLSPEC, __CRTDECL, sprintf, vsprintf,
; 1786 :         _Pre_notnull_ _Always_(_Post_z_), char,        _Buffer,
; 1787 :         _In_z_ _Printf_format_string_     char const*, _Format
; 1788 :         )
; 1789 : 
; 1790 :     _Success_(return >= 0)
; 1791 :     _Check_return_opt_
; 1792 :     _CRT_STDIO_INLINE int __CRTDECL _sprintf_s_l(
; 1793 :         _Out_writes_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
; 1794 :         _In_                                          size_t      const _BufferCount,
; 1795 :         _In_z_ _Printf_format_string_params_(0)       char const* const _Format,
; 1796 :         _In_opt_                                      _locale_t   const _Locale,
; 1797 :         ...)
; 1798 :     #if defined _NO_CRT_STDIO_INLINE
; 1799 :     ;
; 1800 :     #else
; 1801 :     {
; 1802 :         int _Result;
; 1803 :         va_list _ArgList;
; 1804 :         __crt_va_start(_ArgList, _Locale);
; 1805 :         _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1806 :         __crt_va_end(_ArgList);
; 1807 :         return _Result;
; 1808 :     }
; 1809 :     #endif
; 1810 : 
; 1811 :     #if __STDC_WANT_SECURE_LIB__
; 1812 : 
; 1813 :         _Success_(return >= 0)
; 1814 :         _Check_return_opt_
; 1815 :         _CRT_STDIO_INLINE int __CRTDECL sprintf_s(
; 1816 :             _Out_writes_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
; 1817 :             _In_                                          size_t      const _BufferCount,
; 1818 :             _In_z_ _Printf_format_string_                 char const* const _Format,
; 1819 :             ...)
; 1820 :     #if defined _NO_CRT_STDIO_INLINE
; 1821 :     ;
; 1822 :     #else
; 1823 :         {
; 1824 :             int _Result;
; 1825 :             va_list _ArgList;
; 1826 :             __crt_va_start(_ArgList, _Format);
; 1827 :             _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1828 :             __crt_va_end(_ArgList);
; 1829 :             return _Result;
; 1830 :         }
; 1831 :     #endif
; 1832 : 
; 1833 :     #endif
; 1834 : 
; 1835 :     __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ENDP		; sprintf_s<256>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?getBitCount@@YAHH@Z
_TEXT	SEGMENT
_bit$ = 8						; size = 4
?getBitCount@@YAHH@Z PROC				; getBitCount, COMDAT

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 78   : 	int i, j, k;
; 79   : 	j = 1;

  00003	ba 01 00 00 00	 mov	 edx, 1

; 80   : 	k = 0;

  00008	33 c0		 xor	 eax, eax
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b 7d 08	 mov	 edi, DWORD PTR _bit$[ebp]
  0000f	8d 72 1f	 lea	 esi, DWORD PTR [edx+31]
$LL4@getBitCoun:

; 81   : 	for (i = 0; i < sizeof(int) * 8; i++) {
; 82   : 		if ((bit & j))

  00012	85 d7		 test	 edx, edi

; 83   : 			k++;
; 84   : 		j <<= 1;

  00014	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00017	0f 44 c8	 cmove	 ecx, eax
  0001a	03 d2		 add	 edx, edx
  0001c	8b c1		 mov	 eax, ecx
  0001e	83 ee 01	 sub	 esi, 1
  00021	75 ef		 jne	 SHORT $LL4@getBitCoun

; 85   : 	}
; 86   : 	return k;

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi

; 87   : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?getBitCount@@YAHH@Z ENDP				; getBitCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?SetAnimTbl@@YAXXZ
_TEXT	SEGMENT
?SetAnimTbl@@YAXXZ PROC					; SetAnimTbl, COMDAT

; 3943 : #ifdef _READ16BITBMP
; 3944 : 	if(g_bUseAlpha){
; 3945 : 		CG_PKSERVER_PANEL = OLD_GRAPHICS_START+37;
; 3946 : 		CG_BATTTLE_SKILLCHOICE = OLD_GRAPHICS_START+53;
; 3947 : 		CG_FIELD_SKILL_PANEL = OLD_GRAPHICS_START+50;
; 3948 : 		CG_FIELD_CHATROOM_PANEL = OLD_GRAPHICS_START+54;
; 3949 : 		CG_FIELD_SV_SELL_PANEL = OLD_GRAPHICS_START+55;
; 3950 : 		CG_FIELD_SV_SELL_PRICE_PANEL = OLD_GRAPHICS_START+56;
; 3951 : 		CG_NEW_STATUS_WND = OLD_GRAPHICS_START+51;
; 3952 : 		CG_NEWITEM_WND = OLD_GRAPHICS_START+52;
; 3953 : 		CG_TRADE_WND = OLD_GRAPHICS_START+48;
; 3954 : 		CG_TRADE_VIEWWND = OLD_GRAPHICS_START+49;
; 3955 : 		CG_WND_G_0 = OLD_GRAPHICS_START;
; 3956 : 		CG_WND_G_1 = OLD_GRAPHICS_START+1;
; 3957 : 		CG_WND_G_2 = OLD_GRAPHICS_START+2;
; 3958 : 		CG_WND_G_3 = OLD_GRAPHICS_START+3;
; 3959 : 		CG_WND_G_4 = OLD_GRAPHICS_START+4;
; 3960 : 		CG_WND_G_5 = OLD_GRAPHICS_START+5;
; 3961 : 		CG_WND_G_6 = OLD_GRAPHICS_START+6;
; 3962 : 		CG_WND_G_7 = OLD_GRAPHICS_START+7;
; 3963 : 		CG_WND_G_8 = OLD_GRAPHICS_START+8;
; 3964 : 		CG_WND2_G_0 = OLD_GRAPHICS_START+9;
; 3965 : 		CG_WND2_G_1 = OLD_GRAPHICS_START+10;
; 3966 : 		CG_WND2_G_2 = OLD_GRAPHICS_START+11;
; 3967 : 		CG_WND2_G_3 = OLD_GRAPHICS_START+12;
; 3968 : 		CG_WND2_G_4 = OLD_GRAPHICS_START+13;
; 3969 : 		CG_WND2_G_5 = OLD_GRAPHICS_START+14;
; 3970 : 		CG_WND2_G_6 = OLD_GRAPHICS_START+15;
; 3971 : 		CG_WND2_G_7 = OLD_GRAPHICS_START+16;
; 3972 : 		CG_WND2_G_8 = OLD_GRAPHICS_START+17;
; 3973 : 		CG_WND3_G_7 = OLD_GRAPHICS_START+18;
; 3974 : 		CG_WND3_G_8 = OLD_GRAPHICS_START+19;
; 3975 : 		CG_WND3_G_9 = OLD_GRAPHICS_START+20;
; 3976 : 		CG_BTL_PET_CHANGE_WND = OLD_GRAPHICS_START+21;
; 3977 : 		CG_PET_WND_VIEW = OLD_GRAPHICS_START+22;
; 3978 : 		CG_PET_WND_DETAIL	= OLD_GRAPHICS_START+23;
; 3979 : 		CG_NAME_CHANGE_WND = OLD_GRAPHICS_START+24;
; 3980 : 		CG_ITEM_WND_1 = OLD_GRAPHICS_START+25;
; 3981 : 		CG_JUJUTU_WND = OLD_GRAPHICS_START+26;
; 3982 : 		CG_ITEM_WND_SELECT_WND = OLD_GRAPHICS_START+27;
; 3983 : 		CG_STATUS_WND_GROUP_WND = OLD_GRAPHICS_START+28;
; 3984 : 		CG_MAP_WND = OLD_GRAPHICS_START+29;
; 3985 : 		CG_STATUS_WND = OLD_GRAPHICS_START+452;
; 3986 : 		CG_MAIL_WND = OLD_GRAPHICS_START+30;
; 3987 : 		CG_MAIL_WND_SEND_WND = OLD_GRAPHICS_START+38;
; 3988 : 		CG_MAIL_WND_PET_SEND_WND = OLD_GRAPHICS_START+39;
; 3989 : 		CG_MAIL_WND_HISTORY_WND = OLD_GRAPHICS_START+40;
; 3990 : 		CG_ALBUM_WND = OLD_GRAPHICS_START+41;
; 3991 : 		CG_CHAT_REGISTY_WND = OLD_GRAPHICS_START+42;
; 3992 : 		CG_COMMON_WIN_YORO = OLD_GRAPHICS_START+31;
; 3993 : 		CG_FIELD_HELP_WND = OLD_GRAPHICS_START+45;
; 3994 : 		CG_MSG_WND = OLD_GRAPHICS_START+47;
; 3995 : 		CG_PET_WAZA_WND = OLD_GRAPHICS_START+32;
; 3996 : 		CG_ITEMSHOP_WIN = OLD_GRAPHICS_START+33;
; 3997 : 		CG_SKILLSHOP_WIN = OLD_GRAPHICS_START+34;
; 3998 : 		CG_ITEMSHOP_KOSU_WIN = OLD_GRAPHICS_START+35;
; 3999 : 		CG_FAMILY_DETAIL_WIN = OLD_GRAPHICS_START+43;
; 4000 : 		CG_FAMILY_BANK_WIN = OLD_GRAPHICS_START+44;
; 4001 : 		CG_BM_WND = OLD_GRAPHICS_START+36;
; 4002 : 	}
; 4003 : 	else
; 4004 : #endif
; 4005 : 	{
; 4006 : 		CG_PKSERVER_PANEL = 26192;							// 选取星系人物框

  00000	c7 05 00 00 00
	00 50 66 00 00	 mov	 DWORD PTR ?CG_PKSERVER_PANEL@@3HA, 26192 ; CG_PKSERVER_PANEL, 00006650H

; 4007 : 		CG_BATTTLE_SKILLCHOICE = 26389;					// 战斗中选择技能

  0000a	c7 05 00 00 00
	00 15 67 00 00	 mov	 DWORD PTR ?CG_BATTTLE_SKILLCHOICE@@3HA, 26389 ; CG_BATTTLE_SKILLCHOICE, 00006715H

; 4008 : 		CG_FIELD_SKILL_PANEL = 26352;						// 职业技能介面

  00014	c7 05 00 00 00
	00 f0 66 00 00	 mov	 DWORD PTR ?CG_FIELD_SKILL_PANEL@@3HA, 26352 ; CG_FIELD_SKILL_PANEL, 000066f0H

; 4009 : 		CG_FIELD_CHATROOM_PANEL = 26427;				// 聊天室介面

  0001e	c7 05 00 00 00
	00 3b 67 00 00	 mov	 DWORD PTR ?CG_FIELD_CHATROOM_PANEL@@3HA, 26427 ; CG_FIELD_CHATROOM_PANEL, 0000673bH

; 4010 : 		CG_FIELD_SV_SELL_PANEL = 35221;					// 摆摊介面(卖方)

  00028	c7 05 00 00 00
	00 95 89 00 00	 mov	 DWORD PTR ?CG_FIELD_SV_SELL_PANEL@@3HA, 35221 ; CG_FIELD_SV_SELL_PANEL, 00008995H

; 4011 : 		CG_FIELD_SV_SELL_PRICE_PANEL = 35223;		// 输入售价视窗

  00032	c7 05 00 00 00
	00 97 89 00 00	 mov	 DWORD PTR ?CG_FIELD_SV_SELL_PRICE_PANEL@@3HA, 35223 ; CG_FIELD_SV_SELL_PRICE_PANEL, 00008997H

; 4012 : 		CG_NEW_STATUS_WND = 26386;

  0003c	c7 05 00 00 00
	00 12 67 00 00	 mov	 DWORD PTR ?CG_NEW_STATUS_WND@@3HA, 26386 ; CG_NEW_STATUS_WND, 00006712H

; 4013 : #ifdef _PET_ITEM
; 4014 : 		CG_NEWITEM_WND = 26455;									// 人物装备栏位视窗(有标签)

  00046	c7 05 00 00 00
	00 57 67 00 00	 mov	 DWORD PTR ?CG_NEWITEM_WND@@3HA, 26455 ; CG_NEWITEM_WND, 00006757H

; 4015 : #else
; 4016 : 		CG_NEWITEM_WND = 26388;									// 人物装备栏位视窗(左手、脚、手套)
; 4017 : #endif
; 4018 : 
; 4019 : 		CG_TRADE_WND = 26328;										// 交易主视窗

  00050	c7 05 00 00 00
	00 d8 66 00 00	 mov	 DWORD PTR ?CG_TRADE_WND@@3HA, 26328 ; CG_TRADE_WND, 000066d8H

; 4020 : 
; 4021 : 		CG_TRADE_VIEWWND = 26329;								// 交易检视视窗

  0005a	c7 05 00 00 00
	00 d9 66 00 00	 mov	 DWORD PTR ?CG_TRADE_VIEWWND@@3HA, 26329 ; CG_TRADE_VIEWWND, 000066d9H

; 4022 : 		CG_WND_G_0 = 26001;

  00064	c7 05 00 00 00
	00 91 65 00 00	 mov	 DWORD PTR ?CG_WND_G_0@@3HA, 26001 ; CG_WND_G_0, 00006591H

; 4023 : 		CG_WND_G_1 = 26002;

  0006e	c7 05 00 00 00
	00 92 65 00 00	 mov	 DWORD PTR ?CG_WND_G_1@@3HA, 26002 ; CG_WND_G_1, 00006592H

; 4024 : 		CG_WND_G_2 = 26003;

  00078	c7 05 00 00 00
	00 93 65 00 00	 mov	 DWORD PTR ?CG_WND_G_2@@3HA, 26003 ; CG_WND_G_2, 00006593H

; 4025 : 		CG_WND_G_3 = 26004;

  00082	c7 05 00 00 00
	00 94 65 00 00	 mov	 DWORD PTR ?CG_WND_G_3@@3HA, 26004 ; CG_WND_G_3, 00006594H

; 4026 : 		CG_WND_G_4 = 26005;

  0008c	c7 05 00 00 00
	00 95 65 00 00	 mov	 DWORD PTR ?CG_WND_G_4@@3HA, 26005 ; CG_WND_G_4, 00006595H

; 4027 : 		CG_WND_G_5 = 26006;

  00096	c7 05 00 00 00
	00 96 65 00 00	 mov	 DWORD PTR ?CG_WND_G_5@@3HA, 26006 ; CG_WND_G_5, 00006596H

; 4028 : 		CG_WND_G_6 = 26007;

  000a0	c7 05 00 00 00
	00 97 65 00 00	 mov	 DWORD PTR ?CG_WND_G_6@@3HA, 26007 ; CG_WND_G_6, 00006597H

; 4029 : 		CG_WND_G_7 = 26008;

  000aa	c7 05 00 00 00
	00 98 65 00 00	 mov	 DWORD PTR ?CG_WND_G_7@@3HA, 26008 ; CG_WND_G_7, 00006598H

; 4030 : 		CG_WND_G_8 = 26009;

  000b4	c7 05 00 00 00
	00 99 65 00 00	 mov	 DWORD PTR ?CG_WND_G_8@@3HA, 26009 ; CG_WND_G_8, 00006599H

; 4031 : 		CG_WND2_G_0 = 26021;

  000be	c7 05 00 00 00
	00 a5 65 00 00	 mov	 DWORD PTR ?CG_WND2_G_0@@3HA, 26021 ; CG_WND2_G_0, 000065a5H

; 4032 : 		CG_WND2_G_1 = 26022;

  000c8	c7 05 00 00 00
	00 a6 65 00 00	 mov	 DWORD PTR ?CG_WND2_G_1@@3HA, 26022 ; CG_WND2_G_1, 000065a6H

; 4033 : 		CG_WND2_G_2 = 26023;

  000d2	c7 05 00 00 00
	00 a7 65 00 00	 mov	 DWORD PTR ?CG_WND2_G_2@@3HA, 26023 ; CG_WND2_G_2, 000065a7H

; 4034 : 		CG_WND2_G_3 = 26024;

  000dc	c7 05 00 00 00
	00 a8 65 00 00	 mov	 DWORD PTR ?CG_WND2_G_3@@3HA, 26024 ; CG_WND2_G_3, 000065a8H

; 4035 : 		CG_WND2_G_4 = 26025;

  000e6	c7 05 00 00 00
	00 a9 65 00 00	 mov	 DWORD PTR ?CG_WND2_G_4@@3HA, 26025 ; CG_WND2_G_4, 000065a9H

; 4036 : 		CG_WND2_G_5 = 26026;

  000f0	c7 05 00 00 00
	00 aa 65 00 00	 mov	 DWORD PTR ?CG_WND2_G_5@@3HA, 26026 ; CG_WND2_G_5, 000065aaH

; 4037 : 		CG_WND2_G_6 = 26027;

  000fa	c7 05 00 00 00
	00 ab 65 00 00	 mov	 DWORD PTR ?CG_WND2_G_6@@3HA, 26027 ; CG_WND2_G_6, 000065abH

; 4038 : 		CG_WND2_G_7 = 26028;

  00104	c7 05 00 00 00
	00 ac 65 00 00	 mov	 DWORD PTR ?CG_WND2_G_7@@3HA, 26028 ; CG_WND2_G_7, 000065acH

; 4039 : 		CG_WND2_G_8 = 26029;

  0010e	c7 05 00 00 00
	00 ad 65 00 00	 mov	 DWORD PTR ?CG_WND2_G_8@@3HA, 26029 ; CG_WND2_G_8, 000065adH

; 4040 : 		CG_WND3_G_7 = 26037;

  00118	c7 05 00 00 00
	00 b5 65 00 00	 mov	 DWORD PTR ?CG_WND3_G_7@@3HA, 26037 ; CG_WND3_G_7, 000065b5H

; 4041 : 		CG_WND3_G_8 = 26038;

  00122	c7 05 00 00 00
	00 b6 65 00 00	 mov	 DWORD PTR ?CG_WND3_G_8@@3HA, 26038 ; CG_WND3_G_8, 000065b6H

; 4042 : 		CG_WND3_G_9 = 26039;

  0012c	c7 05 00 00 00
	00 b7 65 00 00	 mov	 DWORD PTR ?CG_WND3_G_9@@3HA, 26039 ; CG_WND3_G_9, 000065b7H

; 4043 : 		CG_BTL_PET_CHANGE_WND = 26040;					// ????????????

  00136	c7 05 00 00 00
	00 b8 65 00 00	 mov	 DWORD PTR ?CG_BTL_PET_CHANGE_WND@@3HA, 26040 ; CG_BTL_PET_CHANGE_WND, 000065b8H

; 4044 : 		CG_PET_WND_VIEW = 26044;								// ???????????????

  00140	c7 05 00 00 00
	00 bc 65 00 00	 mov	 DWORD PTR ?CG_PET_WND_VIEW@@3HA, 26044 ; CG_PET_WND_VIEW, 000065bcH

; 4045 : 		CG_PET_WND_DETAIL = 26045;							// ??????????

  0014a	c7 05 00 00 00
	00 bd 65 00 00	 mov	 DWORD PTR ?CG_PET_WND_DETAIL@@3HA, 26045 ; CG_PET_WND_DETAIL, 000065bdH

; 4046 : 		CG_NAME_CHANGE_WND = 26049;							// ???????

  00154	c7 05 00 00 00
	00 c1 65 00 00	 mov	 DWORD PTR ?CG_NAME_CHANGE_WND@@3HA, 26049 ; CG_NAME_CHANGE_WND, 000065c1H

; 4047 : 		CG_ITEM_WND_1 = 26061;									// ??????????

  0015e	c7 05 00 00 00
	00 cd 65 00 00	 mov	 DWORD PTR ?CG_ITEM_WND_1@@3HA, 26061 ; CG_ITEM_WND_1, 000065cdH

; 4048 : 		CG_JUJUTU_WND = 26068;									// ?????

  00168	c7 05 00 00 00
	00 d4 65 00 00	 mov	 DWORD PTR ?CG_JUJUTU_WND@@3HA, 26068 ; CG_JUJUTU_WND, 000065d4H

; 4049 : 		CG_ITEM_WND_SELECT_WND = 26070;					// ?????

  00172	c7 05 00 00 00
	00 d6 65 00 00	 mov	 DWORD PTR ?CG_ITEM_WND_SELECT_WND@@3HA, 26070 ; CG_ITEM_WND_SELECT_WND, 000065d6H

; 4050 : 		CG_STATUS_WND_GROUP_WND = 26071;				// ????????????

  0017c	c7 05 00 00 00
	00 d7 65 00 00	 mov	 DWORD PTR ?CG_STATUS_WND_GROUP_WND@@3HA, 26071 ; CG_STATUS_WND_GROUP_WND, 000065d7H

; 4051 : 		CG_MAP_WND = 26081;											// ????????

  00186	c7 05 00 00 00
	00 e1 65 00 00	 mov	 DWORD PTR ?CG_MAP_WND@@3HA, 26081 ; CG_MAP_WND, 000065e1H

; 4052 : 		CG_STATUS_WND = 26073;									// ???????????????

  00190	c7 05 00 00 00
	00 d9 65 00 00	 mov	 DWORD PTR ?CG_STATUS_WND@@3HA, 26073 ; CG_STATUS_WND, 000065d9H

; 4053 : 		CG_MAIL_WND = 26082;										// ????????

  0019a	c7 05 00 00 00
	00 e2 65 00 00	 mov	 DWORD PTR ?CG_MAIL_WND@@3HA, 26082 ; CG_MAIL_WND, 000065e2H

; 4054 : 		CG_MAIL_WND_SEND_WND = 26200;						// ?????????

  001a4	c7 05 00 00 00
	00 58 66 00 00	 mov	 DWORD PTR ?CG_MAIL_WND_SEND_WND@@3HA, 26200 ; CG_MAIL_WND_SEND_WND, 00006658H

; 4055 : 		CG_MAIL_WND_PET_SEND_WND = 26201;				// ?????????????

  001ae	c7 05 00 00 00
	00 59 66 00 00	 mov	 DWORD PTR ?CG_MAIL_WND_PET_SEND_WND@@3HA, 26201 ; CG_MAIL_WND_PET_SEND_WND, 00006659H

; 4056 : 		CG_MAIL_WND_HISTORY_WND = 26203;				// ??????????

  001b8	c7 05 00 00 00
	00 5b 66 00 00	 mov	 DWORD PTR ?CG_MAIL_WND_HISTORY_WND@@3HA, 26203 ; CG_MAIL_WND_HISTORY_WND, 0000665bH

; 4057 : 		CG_ALBUM_WND = 26230;										// ?????????

  001c2	c7 05 00 00 00
	00 76 66 00 00	 mov	 DWORD PTR ?CG_ALBUM_WND@@3HA, 26230 ; CG_ALBUM_WND, 00006676H

; 4058 : 		CG_CHAT_REGISTY_WND = 26232;

  001cc	c7 05 00 00 00
	00 78 66 00 00	 mov	 DWORD PTR ?CG_CHAT_REGISTY_WND@@3HA, 26232 ; CG_CHAT_REGISTY_WND, 00006678H

; 4059 : 		CG_COMMON_WIN_YORO = 26090;							// "???????"??????????

  001d6	c7 05 00 00 00
	00 ea 65 00 00	 mov	 DWORD PTR ?CG_COMMON_WIN_YORO@@3HA, 26090 ; CG_COMMON_WIN_YORO, 000065eaH

; 4060 : 		CG_FIELD_HELP_WND = 26258;

  001e0	c7 05 00 00 00
	00 92 66 00 00	 mov	 DWORD PTR ?CG_FIELD_HELP_WND@@3HA, 26258 ; CG_FIELD_HELP_WND, 00006692H

; 4061 : 		CG_MSG_WND = 26296;											// Message's Main Window ,added by LeiBoy

  001ea	c7 05 00 00 00
	00 b8 66 00 00	 mov	 DWORD PTR ?CG_MSG_WND@@3HA, 26296 ; CG_MSG_WND, 000066b8H

; 4062 : 		CG_PET_WAZA_WND = 26130;

  001f4	c7 05 00 00 00
	00 12 66 00 00	 mov	 DWORD PTR ?CG_PET_WAZA_WND@@3HA, 26130 ; CG_PET_WAZA_WND, 00006612H

; 4063 : 		CG_ITEMSHOP_WIN = 26138;

  001fe	c7 05 00 00 00
	00 1a 66 00 00	 mov	 DWORD PTR ?CG_ITEMSHOP_WIN@@3HA, 26138 ; CG_ITEMSHOP_WIN, 0000661aH

; 4064 : 		CG_SKILLSHOP_WIN = 26139;

  00208	c7 05 00 00 00
	00 1b 66 00 00	 mov	 DWORD PTR ?CG_SKILLSHOP_WIN@@3HA, 26139 ; CG_SKILLSHOP_WIN, 0000661bH

; 4065 : 		CG_ITEMSHOP_KOSU_WIN = 26140;

  00212	c7 05 00 00 00
	00 1c 66 00 00	 mov	 DWORD PTR ?CG_ITEMSHOP_KOSU_WIN@@3HA, 26140 ; CG_ITEMSHOP_KOSU_WIN, 0000661cH

; 4066 : 		CG_FAMILY_DETAIL_WIN = 26239;

  0021c	c7 05 00 00 00
	00 7f 66 00 00	 mov	 DWORD PTR ?CG_FAMILY_DETAIL_WIN@@3HA, 26239 ; CG_FAMILY_DETAIL_WIN, 0000667fH

; 4067 : 		CG_FAMILY_BANK_WIN = 26240;

  00226	c7 05 00 00 00
	00 80 66 00 00	 mov	 DWORD PTR ?CG_FAMILY_BANK_WIN@@3HA, 26240 ; CG_FAMILY_BANK_WIN, 00006680H

; 4068 : 		CG_BM_WND = 26141;

  00230	c7 05 00 00 00
	00 1d 66 00 00	 mov	 DWORD PTR ?CG_BM_WND@@3HA, 26141 ; CG_BM_WND, 0000661dH

; 4069 : 	}
; 4070 : }

  0023a	c3		 ret	 0
?SetAnimTbl@@YAXXZ ENDP					; SetAnimTbl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?CreateNewFont@@YAPAUHFONT__@@H@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
?CreateNewFont@@YAPAUHFONT__@@H@Z PROC			; CreateNewFont, COMDAT

; 4073 : HFONT CreateNewFont( int size) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4074 : 
; 4075 : #ifdef 加载新字体
; 4076 : //	HFONT JL_FONT();
; 4077 : 	//return JL_FONT();
; 4078 : #endif // 
; 4079 : 
; 4080 : 	
; 4081 : 
; 4082 : 	return CreateFont(  // 윈도우창 폰트

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_06MFMMLLPC@?$LB?$LM?$LI?$LC?C?$LM@
  00008	6a 11		 push	 17			; 00000011H
  0000a	6a 00		 push	 0
  0000c	6a 00		 push	 0
  0000e	6a 00		 push	 0
  00010	68 81 00 00 00	 push	 129			; 00000081H
  00015	6a 00		 push	 0
  00017	6a 00		 push	 0
  00019	6a 00		 push	 0
  0001b	68 90 01 00 00	 push	 400			; 00000190H
  00020	6a 00		 push	 0
  00022	6a 00		 push	 0
  00024	6a 00		 push	 0
  00026	ff 75 08	 push	 DWORD PTR _size$[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFontA@56

; 4083 : 		size, 	/* ????????	*/ 
; 4084 : 		0, 		/* ????????	*/ 
; 4085 : 		0, 		/* ???????	*/ 
; 4086 : 		0,		/* ??? ????x??	*/ 
; 4087 : 		
; 4088 : 		/* ???????	*/ 
; 4089 : 		FW_NORMAL,			// 400 
; 4090 : 		
; 4091 : 		/* ?????????	*/ 
; 4092 : 		FALSE, 					
; 4093 : 		
; 4094 : 		/* ???????	*/ 
; 4095 : 		FALSE,					
; 4096 : 		
; 4097 : 		/* ????????	*/ 
; 4098 : 		FALSE,					
; 4099 : 		
; 4100 : 		/* ?????	*/ 
; 4101 : 		HANGUL_CHARSET/*CHINESEBIG5_CHARSET*/,// ????
; 4102 : 		
; 4103 : 		/* ?	*/ 
; 4104 : 		OUT_DEFAULT_PRECIS, 
; 4105 : 		
; 4106 : 		/* ??????	*/ 
; 4107 : 		CLIP_DEFAULT_PRECIS,
; 4108 : 		
; 4109 : 		/* ?	*/ 
; 4110 : 		DEFAULT_QUALITY,	// ????????????????
; 4111 : 		
; 4112 : 		/* ??? */ 
; 4113 : 		FIXED_PITCH |
; 4114 : 		
; 4115 : 		/* ????	*/ 
; 4116 : 		FF_ROMAN,			// ???????????????????????MS(R) Serif????????
; 4117 : 		
; 4118 : 		/* ????????????????	*/ 				
; 4119 : 		TEXT("굴림체") /*"楷体_GB2312"*/ );
; 4120 : 
; 4121 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?CreateNewFont@@YAPAUHFONT__@@H@Z ENDP			; CreateNewFont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?DrawMapEffect@@YAXXZ
_TEXT	SEGMENT
_j$2 = -172						; size = 4
_hh$3 = -168						; size = 4
_ww$4 = -164						; size = 4
_i$5 = -160						; size = 4
_ptDest32$6 = -156					; size = 4
_hh$1$ = -152						; size = 4
_surfacePitch$7 = -152					; size = 4
_surfacePitch$1$ = -148					; size = 4
_buf$1$ = -144						; size = 4
_ptDest$8 = -140					; size = 4
_ptDest2$9 = -136					; size = 4
_ww$1$ = -132						; size = 4
_ddsd$10 = -128						; size = 108
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?DrawMapEffect@@YAXXZ PROC				; DrawMapEffect, COMDAT

; 2261 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?DrawMapEffect@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 2262 : 	try

  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 2263 : 	{
; 2264 : 		DDSURFACEDESC ddsd;
; 2265 : 		char *ptDest;
; 2266 : 		short *ptDest2;
; 2267 : #ifdef _HI_COLOR_32
; 2268 : 		int *ptDest32;
; 2269 : #endif
; 2270 : 		int surfacePitch;
; 2271 : 		int ww, hh;
; 2272 : 		MAP_EFFECT *buf;
; 2273 : 		char color;
; 2274 : 		int i, j;
; 2275 : 
; 2276 : 		ww = DEF_APPSIZEX;

  00038	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?DEF_APPSIZEX@@3HA ; DEF_APPSIZEX
  0003e	89 bd 7c ff ff
	ff		 mov	 DWORD PTR _ww$1$[ebp], edi
  00044	89 bd 5c ff ff
	ff		 mov	 DWORD PTR _ww$4[ebp], edi

; 2277 : 		hh = DEF_APPSIZEY;

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?DEF_APPSIZEY@@3HA ; DEF_APPSIZEY
  0004f	89 85 68 ff ff
	ff		 mov	 DWORD PTR _hh$1$[ebp], eax
  00055	89 85 58 ff ff
	ff		 mov	 DWORD PTR _hh$3[ebp], eax

; 2278 : 		//???????????????
; 2279 : 		if (ResoMode == 1) {

  0005b	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?ResoMode@@3HA, 1 ; ResoMode
  00062	75 1c		 jne	 SHORT $LN11@DrawMapEff

; 2280 : 			ww >>= 1;

  00064	d1 ff		 sar	 edi, 1
  00066	89 bd 7c ff ff
	ff		 mov	 DWORD PTR _ww$1$[ebp], edi
  0006c	89 bd 5c ff ff
	ff		 mov	 DWORD PTR _ww$4[ebp], edi

; 2281 : 			hh >>= 1;

  00072	d1 f8		 sar	 eax, 1
  00074	89 85 68 ff ff
	ff		 mov	 DWORD PTR _hh$1$[ebp], eax
  0007a	89 85 58 ff ff
	ff		 mov	 DWORD PTR _hh$3[ebp], eax
$LN11@DrawMapEff:

; 2282 : 		}
; 2283 : 		ZeroMemory(&ddsd, sizeof(DDSURFACEDESC));

  00080	6a 6c		 push	 108			; 0000006cH
  00082	6a 00		 push	 0
  00084	8d 45 80	 lea	 eax, DWORD PTR _ddsd$10[ebp]
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 _memset
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2284 : 		ddsd.dwSize = sizeof(DDSURFACEDESC);

  00090	c7 45 80 6c 00
	00 00		 mov	 DWORD PTR _ddsd$10[ebp], 108 ; 0000006cH

; 2285 : 		if (lpDraw->lpBACKBUFFER->Lock(NULL, &ddsd, DDLOCK_WAIT, NULL) != DD_OK)

  00097	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0009c	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0009f	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a1	6a 00		 push	 0
  000a3	6a 01		 push	 1
  000a5	8d 55 80	 lea	 edx, DWORD PTR _ddsd$10[ebp]
  000a8	52		 push	 edx
  000a9	6a 00		 push	 0
  000ab	50		 push	 eax
  000ac	ff 51 64	 call	 DWORD PTR [ecx+100]
  000af	85 c0		 test	 eax, eax
  000b1	0f 85 13 0c 00
	00		 jne	 $LN128@DrawMapEff

; 2286 : 			return;
; 2287 : #ifdef _HI_COLOR_32
; 2288 : 		if (displayBpp == 32)

  000b7	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR ?displayBpp@@3HA, 32 ; displayBpp, 00000020H
  000be	75 08		 jne	 SHORT $LN13@DrawMapEff

; 2289 : 			surfacePitch = ddsd.lPitch >> 2;

  000c0	8b 5d 90	 mov	 ebx, DWORD PTR _ddsd$10[ebp+16]
  000c3	c1 fb 02	 sar	 ebx, 2

; 2290 : #endif
; 2291 : 		if (displayBpp == 16)

  000c6	eb 16		 jmp	 SHORT $LN145@DrawMapEff
$LN13@DrawMapEff:
  000c8	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR ?displayBpp@@3HA, 16 ; displayBpp, 00000010H
  000cf	75 07		 jne	 SHORT $LN139@DrawMapEff

; 2292 : 			surfacePitch = ddsd.lPitch >> 1;

  000d1	8b 5d 90	 mov	 ebx, DWORD PTR _ddsd$10[ebp+16]
  000d4	d1 fb		 sar	 ebx, 1

; 2290 : #endif
; 2291 : 		if (displayBpp == 16)

  000d6	eb 06		 jmp	 SHORT $LN145@DrawMapEff
$LN139@DrawMapEff:
  000d8	8b 9d 68 ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$7[ebp]
$LN145@DrawMapEff:

; 2293 : 		buf = useBufMapEffect;

  000de	89 9d 6c ff ff
	ff		 mov	 DWORD PTR _surfacePitch$1$[ebp], ebx
  000e4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?useBufMapEffect@@3PAU_MAP_EFFECT@@A ; useBufMapEffect
$LN152@DrawMapEff:

; 2294 : 		while (buf != (MAP_EFFECT *)NULL) {

  000ea	89 b5 70 ff ff
	ff		 mov	 DWORD PTR _buf$1$[ebp], esi
  000f0	85 f6		 test	 esi, esi
  000f2	0f 84 b0 0b 00
	00		 je	 $LN3@DrawMapEff

; 2295 : 			if (0 < buf->x && buf->x < ww - 4 && 0 < buf->y && buf->y < hh - 12) {

  000f8	8b 16		 mov	 edx, DWORD PTR [esi]
  000fa	85 d2		 test	 edx, edx
  000fc	0f 8e d0 06 00
	00		 jle	 $LN5@DrawMapEff
  00102	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  00105	3b d0		 cmp	 edx, eax
  00107	0f 8d c5 06 00
	00		 jge	 $LN5@DrawMapEff
  0010d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00110	85 c9		 test	 ecx, ecx
  00112	0f 8e ba 06 00
	00		 jle	 $LN5@DrawMapEff
  00118	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _hh$1$[ebp]
  0011e	83 c0 f4	 add	 eax, -12		; fffffff4H
  00121	3b c8		 cmp	 ecx, eax
  00123	0f 8d a9 06 00
	00		 jge	 $LN5@DrawMapEff

; 2296 : #ifdef _HI_COLOR_32
; 2297 : 				if (displayBpp == 32) {

  00129	0f af cb	 imul	 ecx, ebx
  0012c	03 ca		 add	 ecx, edx
  0012e	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR ?displayBpp@@3HA, 32 ; displayBpp, 00000020H
  00135	75 14		 jne	 SHORT $LN16@DrawMapEff

; 2298 : 					ptDest32 = (int *)(ddsd.lpSurface) + buf->y * surfacePitch + buf->x;

  00137	8b 45 a4	 mov	 eax, DWORD PTR _ddsd$10[ebp+36]
  0013a	8d 3c 88	 lea	 edi, DWORD PTR [eax+ecx*4]
  0013d	89 bd 64 ff ff
	ff		 mov	 DWORD PTR _ptDest32$6[ebp], edi

; 2299 : 				}

  00143	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _ptDest$8[ebp]
  00149	eb 32		 jmp	 SHORT $LN146@DrawMapEff
$LN16@DrawMapEff:

; 2300 : 				else
; 2301 : #endif
; 2302 : 					if (displayBpp == 16)

  0014b	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR ?displayBpp@@3HA, 16 ; displayBpp, 00000010H
  00152	75 1a		 jne	 SHORT $LN18@DrawMapEff

; 2303 : 						ptDest2 = (short *)(ddsd.lpSurface) + buf->y * surfacePitch + buf->x;

  00154	8b 45 a4	 mov	 eax, DWORD PTR _ddsd$10[ebp+36]
  00157	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  0015a	89 95 78 ff ff
	ff		 mov	 DWORD PTR _ptDest2$9[ebp], edx
  00160	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _ptDest$8[ebp]
  00166	8b bd 64 ff ff
	ff		 mov	 edi, DWORD PTR _ptDest32$6[ebp]
  0016c	eb 15		 jmp	 SHORT $LN19@DrawMapEff
$LN18@DrawMapEff:

; 2304 : 					else
; 2305 : 						ptDest = (char *)(ddsd.lpSurface) + buf->y * surfacePitch + buf->x;

  0016e	03 4d a4	 add	 ecx, DWORD PTR _ddsd$10[ebp+36]
  00171	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _ptDest$8[ebp], ecx
  00177	8b bd 64 ff ff
	ff		 mov	 edi, DWORD PTR _ptDest32$6[ebp]
$LN146@DrawMapEff:

; 2306 : 				if (buf->type == MAP_EFFECT_TYPE_RAIN) {

  0017d	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _ptDest2$9[ebp]
$LN19@DrawMapEff:
  00183	0f b7 46 3c	 movzx	 eax, WORD PTR [esi+60]
  00187	66 83 f8 01	 cmp	 ax, 1
  0018b	0f 85 b7 00 00
	00		 jne	 $LN20@DrawMapEff

; 2307 : #ifdef _HI_COLOR_32
; 2308 : 					if (displayBpp == 32) {

  00191	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR ?displayBpp@@3HA, 32 ; displayBpp, 00000020H
  00198	75 39		 jne	 SHORT $LN22@DrawMapEff

; 2309 : 						*(ptDest32) = highColor32Palette[143];

  0019a	a1 3c 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+572
  0019f	89 07		 mov	 DWORD PTR [edi], eax

; 2310 : 						*(ptDest32 + surfacePitch) = highColor32Palette[143];

  001a1	a1 3c 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+572
  001a6	89 04 9f	 mov	 DWORD PTR [edi+ebx*4], eax

; 2311 : 						*(ptDest32 + surfacePitch * 2 + 1) = highColor32Palette[143];

  001a9	a1 3c 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+572
  001ae	89 44 df 04	 mov	 DWORD PTR [edi+ebx*8+4], eax

; 2312 : 						*(ptDest32 + surfacePitch * 3 + 1) = highColor32Palette[143];

  001b2	8b 0d 3c 02 00
	00		 mov	 ecx, DWORD PTR ?highColor32Palette@@3PAIA+572
  001b8	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  001bb	89 4c 87 04	 mov	 DWORD PTR [edi+eax*4+4], ecx

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  001bf	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  001c5	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  001c8	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  001ce	e9 17 ff ff ff	 jmp	 $LN152@DrawMapEff
$LN22@DrawMapEff:

; 2313 : 					}
; 2314 : 					else
; 2315 : #endif
; 2316 : 						if (displayBpp == 16) {

  001d3	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR ?displayBpp@@3HA, 16 ; displayBpp, 00000010H
  001da	75 44		 jne	 SHORT $LN24@DrawMapEff

; 2317 : 							*(ptDest2) = highColorPalette[143];

  001dc	0f b7 05 1e 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+286
  001e3	66 89 02	 mov	 WORD PTR [edx], ax

; 2318 : 							*(ptDest2 + surfacePitch) = highColorPalette[143];

  001e6	0f b7 05 1e 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+286
  001ed	66 89 04 5a	 mov	 WORD PTR [edx+ebx*2], ax

; 2319 : 							*(ptDest2 + surfacePitch * 2 + 1) = highColorPalette[143];

  001f1	0f b7 05 1e 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+286
  001f8	66 89 44 9a 02	 mov	 WORD PTR [edx+ebx*4+2], ax

; 2320 : 							*(ptDest2 + surfacePitch * 3 + 1) = highColorPalette[143];

  001fd	66 8b 0d 1e 01
	00 00		 mov	 cx, WORD PTR ?highColorPalette@@3PAGA+286
  00204	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  00207	66 89 4c 42 02	 mov	 WORD PTR [edx+eax*2+2], cx

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  0020c	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  00212	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  00215	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  0021b	e9 ca fe ff ff	 jmp	 $LN152@DrawMapEff
$LN24@DrawMapEff:

; 2321 : 						}
; 2322 : 						else {
; 2323 : 							*(ptDest) = (char)143;

  00220	c6 01 8f	 mov	 BYTE PTR [ecx], -113	; ffffff8fH

; 2324 : 							*(ptDest + surfacePitch) = (char)143;

  00223	c6 04 19 8f	 mov	 BYTE PTR [ecx+ebx], -113 ; ffffff8fH

; 2325 : 							*(ptDest + surfacePitch * 2 + 1) = (char)143;

  00227	c6 44 59 01 8f	 mov	 BYTE PTR [ecx+ebx*2+1], -113 ; ffffff8fH

; 2326 : 							*(ptDest + surfacePitch * 3 + 1) = (char)143;

  0022c	8d 04 59	 lea	 eax, DWORD PTR [ecx+ebx*2]
  0022f	c6 44 03 01 8f	 mov	 BYTE PTR [ebx+eax+1], -113 ; ffffff8fH

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  00234	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  0023a	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  0023d	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  00243	e9 a2 fe ff ff	 jmp	 $LN152@DrawMapEff
$LN20@DrawMapEff:

; 2327 : 						}
; 2328 : 				}
; 2329 : 				else if (buf->type == MAP_EFFECT_TYPE_SNOW) {

  00248	66 83 f8 02	 cmp	 ax, 2
  0024c	0f 85 1c 03 00
	00		 jne	 $LN26@DrawMapEff

; 2330 : 					if (buf->mode == 0) {

  00252	0f b7 46 40	 movzx	 eax, WORD PTR [esi+64]
  00256	66 85 c0	 test	 ax, ax
  00259	0f 85 26 01 00
	00		 jne	 $LN28@DrawMapEff

; 2331 : #ifdef _HI_COLOR_32
; 2332 : 						if (displayBpp == 32) {

  0025f	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR ?displayBpp@@3HA, 32 ; displayBpp, 00000020H
  00266	75 5f		 jne	 SHORT $LN30@DrawMapEff

; 2333 : 							*(ptDest32) = highColor32Palette[161];

  00268	a1 84 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+644
  0026d	89 07		 mov	 DWORD PTR [edi], eax

; 2334 : 							*(ptDest32 + 1) = highColor32Palette[159];

  0026f	a1 7c 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+636
  00274	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 2335 : 							*(ptDest32 + 2) = highColor32Palette[161];

  00277	a1 84 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+644
  0027c	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 2336 : 							*(ptDest32 + surfacePitch) = highColor32Palette[159];

  0027f	a1 7c 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+636
  00284	89 04 9f	 mov	 DWORD PTR [edi+ebx*4], eax

; 2337 : 							*(ptDest32 + surfacePitch + 1) = highColor32Palette[159];

  00287	a1 7c 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+636
  0028c	89 44 9f 04	 mov	 DWORD PTR [edi+ebx*4+4], eax

; 2338 : 							*(ptDest32 + surfacePitch + 2) = highColor32Palette[159];

  00290	a1 7c 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+636
  00295	89 44 9f 08	 mov	 DWORD PTR [edi+ebx*4+8], eax

; 2339 : 							*(ptDest32 + surfacePitch * 2) = highColor32Palette[161];

  00299	a1 84 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+644
  0029e	89 04 df	 mov	 DWORD PTR [edi+ebx*8], eax

; 2340 : 							*(ptDest32 + surfacePitch * 2 + 1) = highColor32Palette[159];

  002a1	a1 7c 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+636
  002a6	89 44 df 04	 mov	 DWORD PTR [edi+ebx*8+4], eax

; 2341 : 							*(ptDest32 + surfacePitch * 2 + 2) = highColor32Palette[161];

  002aa	a1 84 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+644
  002af	89 44 df 08	 mov	 DWORD PTR [edi+ebx*8+8], eax

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  002b3	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  002b9	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  002bc	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  002c2	e9 23 fe ff ff	 jmp	 $LN152@DrawMapEff
$LN30@DrawMapEff:

; 2342 : 						}
; 2343 : 						else
; 2344 : #endif
; 2345 : 							if (displayBpp == 16) {

  002c7	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR ?displayBpp@@3HA, 16 ; displayBpp, 00000010H
  002ce	75 7a		 jne	 SHORT $LN32@DrawMapEff

; 2346 : 								*(ptDest2) = highColorPalette[161];

  002d0	0f b7 05 42 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+322
  002d7	66 89 02	 mov	 WORD PTR [edx], ax

; 2347 : 								*(ptDest2 + 1) = highColorPalette[159];

  002da	0f b7 05 3e 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+318
  002e1	66 89 42 02	 mov	 WORD PTR [edx+2], ax

; 2348 : 								*(ptDest2 + 2) = highColorPalette[161];

  002e5	0f b7 05 42 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+322
  002ec	66 89 42 04	 mov	 WORD PTR [edx+4], ax

; 2349 : 								*(ptDest2 + surfacePitch) = highColorPalette[159];

  002f0	0f b7 05 3e 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+318
  002f7	66 89 04 5a	 mov	 WORD PTR [edx+ebx*2], ax

; 2350 : 								*(ptDest2 + surfacePitch + 1) = highColorPalette[159];

  002fb	0f b7 05 3e 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+318
  00302	66 89 44 5a 02	 mov	 WORD PTR [edx+ebx*2+2], ax

; 2351 : 								*(ptDest2 + surfacePitch + 2) = highColorPalette[159];

  00307	0f b7 05 3e 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+318
  0030e	66 89 44 5a 04	 mov	 WORD PTR [edx+ebx*2+4], ax

; 2352 : 								*(ptDest2 + surfacePitch * 2) = highColorPalette[161];

  00313	0f b7 05 42 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+322
  0031a	66 89 04 9a	 mov	 WORD PTR [edx+ebx*4], ax

; 2353 : 								*(ptDest2 + surfacePitch * 2 + 1) = highColorPalette[159];

  0031e	0f b7 05 3e 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+318
  00325	66 89 44 9a 02	 mov	 WORD PTR [edx+ebx*4+2], ax

; 2354 : 								*(ptDest2 + surfacePitch * 2 + 2) = highColorPalette[161];

  0032a	0f b7 05 42 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+322
  00331	66 89 44 9a 04	 mov	 WORD PTR [edx+ebx*4+4], ax

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  00336	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  0033c	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  0033f	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  00345	e9 a0 fd ff ff	 jmp	 $LN152@DrawMapEff
$LN32@DrawMapEff:

; 2355 : 							}
; 2356 : 							else {
; 2357 : 								*(ptDest) = (char)161;

  0034a	c6 01 a1	 mov	 BYTE PTR [ecx], -95	; ffffffa1H

; 2358 : 								*(ptDest + 1) = (char)159;

  0034d	c6 41 01 9f	 mov	 BYTE PTR [ecx+1], -97	; ffffff9fH

; 2359 : 								*(ptDest + 2) = (char)161;

  00351	c6 41 02 a1	 mov	 BYTE PTR [ecx+2], -95	; ffffffa1H

; 2360 : 								*(ptDest + surfacePitch) = (char)159;

  00355	c6 04 19 9f	 mov	 BYTE PTR [ecx+ebx], -97	; ffffff9fH

; 2361 : 								*(ptDest + surfacePitch + 1) = (char)159;

  00359	c6 44 19 01 9f	 mov	 BYTE PTR [ecx+ebx+1], -97 ; ffffff9fH

; 2362 : 								*(ptDest + surfacePitch + 2) = (char)159;

  0035e	c6 44 19 02 9f	 mov	 BYTE PTR [ecx+ebx+2], -97 ; ffffff9fH

; 2363 : 								*(ptDest + surfacePitch * 2) = (char)161;

  00363	c6 04 59 a1	 mov	 BYTE PTR [ecx+ebx*2], -95 ; ffffffa1H

; 2364 : 								*(ptDest + surfacePitch * 2 + 1) = (char)159;

  00367	c6 44 59 01 9f	 mov	 BYTE PTR [ecx+ebx*2+1], -97 ; ffffff9fH

; 2365 : 								*(ptDest + surfacePitch * 2 + 2) = (char)161;

  0036c	c6 44 59 02 a1	 mov	 BYTE PTR [ecx+ebx*2+2], -95 ; ffffffa1H

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  00371	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  00377	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  0037a	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  00380	e9 65 fd ff ff	 jmp	 $LN152@DrawMapEff
$LN28@DrawMapEff:

; 2366 : 							}
; 2367 : 					}
; 2368 : 					else if (buf->mode == 1) {

  00385	66 83 f8 01	 cmp	 ax, 1
  00389	0f 85 3d 04 00
	00		 jne	 $LN143@DrawMapEff

; 2369 : #ifdef _HI_COLOR_32
; 2370 : 						if (displayBpp == 32) {

  0038f	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR ?displayBpp@@3HA, 32 ; displayBpp, 00000020H
  00396	0f 85 9e 00 00
	00		 jne	 $LN35@DrawMapEff

; 2371 : 							*(ptDest32) = highColor32Palette[162];

  0039c	a1 88 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+648
  003a1	89 07		 mov	 DWORD PTR [edi], eax

; 2372 : 							*(ptDest32 + 1) = highColor32Palette[159];

  003a3	a1 7c 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+636
  003a8	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 2373 : 							*(ptDest32 + 2) = highColor32Palette[159];

  003ab	a1 7c 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+636
  003b0	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 2374 : 							*(ptDest32 + 3) = highColor32Palette[162];

  003b3	a1 88 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+648
  003b8	89 47 0c	 mov	 DWORD PTR [edi+12], eax

; 2375 : 							*(ptDest32 + surfacePitch) = highColor32Palette[159];

  003bb	a1 7c 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+636
  003c0	89 04 9f	 mov	 DWORD PTR [edi+ebx*4], eax

; 2376 : 							*(ptDest32 + surfacePitch + 1) = highColor32Palette[159];

  003c3	a1 7c 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+636
  003c8	89 44 9f 04	 mov	 DWORD PTR [edi+ebx*4+4], eax

; 2377 : 							*(ptDest32 + surfacePitch + 2) = highColor32Palette[159];

  003cc	a1 7c 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+636
  003d1	89 44 9f 08	 mov	 DWORD PTR [edi+ebx*4+8], eax

; 2378 : 							*(ptDest32 + surfacePitch + 3) = highColor32Palette[159];

  003d5	a1 7c 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+636
  003da	89 44 9f 0c	 mov	 DWORD PTR [edi+ebx*4+12], eax

; 2379 : 							*(ptDest32 + surfacePitch * 2) = highColor32Palette[159];

  003de	a1 7c 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+636
  003e3	89 04 df	 mov	 DWORD PTR [edi+ebx*8], eax

; 2380 : 							*(ptDest32 + surfacePitch * 2 + 1) = highColor32Palette[159];

  003e6	a1 7c 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+636
  003eb	89 44 df 04	 mov	 DWORD PTR [edi+ebx*8+4], eax

; 2381 : 							*(ptDest32 + surfacePitch * 2 + 2) = highColor32Palette[159];

  003ef	a1 7c 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+636
  003f4	89 44 df 08	 mov	 DWORD PTR [edi+ebx*8+8], eax

; 2382 : 							*(ptDest32 + surfacePitch * 2 + 3) = highColor32Palette[159];

  003f8	a1 7c 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+636
  003fd	89 44 df 0c	 mov	 DWORD PTR [edi+ebx*8+12], eax

; 2383 : 							*(ptDest32 + surfacePitch * 3) = highColor32Palette[162];

  00401	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  00404	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]
  00407	a1 88 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+648
  0040c	89 01		 mov	 DWORD PTR [ecx], eax

; 2384 : 							*(ptDest32 + surfacePitch * 3 + 1) = highColor32Palette[159];

  0040e	a1 7c 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+636
  00413	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 2385 : 							*(ptDest32 + surfacePitch * 3 + 2) = highColor32Palette[159];

  00416	a1 7c 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+636
  0041b	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 2386 : 							*(ptDest32 + surfacePitch * 3 + 3) = highColor32Palette[162];

  0041e	a1 88 02 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+648
  00423	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  00426	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  0042c	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  0042f	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  00435	e9 b0 fc ff ff	 jmp	 $LN152@DrawMapEff
$LN35@DrawMapEff:

; 2387 : 						}
; 2388 : 						else
; 2389 : #endif
; 2390 : 							if (displayBpp == 16) {

  0043a	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR ?displayBpp@@3HA, 16 ; displayBpp, 00000010H
  00441	0f 85 c8 00 00
	00		 jne	 $LN37@DrawMapEff

; 2391 : 								*(ptDest2) = highColorPalette[162];

  00447	0f b7 05 44 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+324
  0044e	66 89 02	 mov	 WORD PTR [edx], ax

; 2392 : 								*(ptDest2 + 1) = highColorPalette[159];

  00451	0f b7 05 3e 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+318
  00458	66 89 42 02	 mov	 WORD PTR [edx+2], ax

; 2393 : 								*(ptDest2 + 2) = highColorPalette[159];

  0045c	0f b7 05 3e 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+318
  00463	66 89 42 04	 mov	 WORD PTR [edx+4], ax

; 2394 : 								*(ptDest2 + 3) = highColorPalette[162];

  00467	a1 44 01 00 00	 mov	 eax, DWORD PTR ?highColorPalette@@3PAGA+324
  0046c	66 89 42 06	 mov	 WORD PTR [edx+6], ax

; 2395 : 								*(ptDest2 + surfacePitch) = highColorPalette[159];

  00470	0f b7 05 3e 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+318
  00477	66 89 04 5a	 mov	 WORD PTR [edx+ebx*2], ax

; 2396 : 								*(ptDest2 + surfacePitch + 1) = highColorPalette[159];

  0047b	0f b7 05 3e 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+318
  00482	66 89 44 5a 02	 mov	 WORD PTR [edx+ebx*2+2], ax

; 2397 : 								*(ptDest2 + surfacePitch + 2) = highColorPalette[159];

  00487	0f b7 05 3e 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+318
  0048e	66 89 44 5a 04	 mov	 WORD PTR [edx+ebx*2+4], ax

; 2398 : 								*(ptDest2 + surfacePitch + 3) = highColorPalette[159];

  00493	0f b7 05 3e 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+318
  0049a	66 89 44 5a 06	 mov	 WORD PTR [edx+ebx*2+6], ax

; 2399 : 								*(ptDest2 + surfacePitch * 2) = highColorPalette[159];

  0049f	0f b7 05 3e 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+318
  004a6	66 89 04 9a	 mov	 WORD PTR [edx+ebx*4], ax

; 2400 : 								*(ptDest2 + surfacePitch * 2 + 1) = highColorPalette[159];

  004aa	0f b7 05 3e 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+318
  004b1	66 89 44 9a 02	 mov	 WORD PTR [edx+ebx*4+2], ax

; 2401 : 								*(ptDest2 + surfacePitch * 2 + 2) = highColorPalette[159];

  004b6	0f b7 05 3e 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+318
  004bd	66 89 44 9a 04	 mov	 WORD PTR [edx+ebx*4+4], ax

; 2402 : 								*(ptDest2 + surfacePitch * 2 + 3) = highColorPalette[159];

  004c2	0f b7 05 3e 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+318
  004c9	66 89 44 9a 06	 mov	 WORD PTR [edx+ebx*4+6], ax

; 2403 : 								*(ptDest2 + surfacePitch * 3) = highColorPalette[162];

  004ce	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  004d1	8d 0c 42	 lea	 ecx, DWORD PTR [edx+eax*2]
  004d4	a1 44 01 00 00	 mov	 eax, DWORD PTR ?highColorPalette@@3PAGA+324
  004d9	66 89 01	 mov	 WORD PTR [ecx], ax

; 2404 : 								*(ptDest2 + surfacePitch * 3 + 1) = highColorPalette[159];

  004dc	0f b7 05 3e 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+318
  004e3	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 2405 : 								*(ptDest2 + surfacePitch * 3 + 2) = highColorPalette[159];

  004e7	0f b7 05 3e 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+318
  004ee	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 2406 : 								*(ptDest2 + surfacePitch * 3 + 3) = highColorPalette[162];

  004f2	a1 44 01 00 00	 mov	 eax, DWORD PTR ?highColorPalette@@3PAGA+324
  004f7	66 89 41 06	 mov	 WORD PTR [ecx+6], ax

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  004fb	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  00501	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  00504	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  0050a	e9 db fb ff ff	 jmp	 $LN152@DrawMapEff
$LN37@DrawMapEff:

; 2407 : 							}
; 2408 : 							else {
; 2409 : 								*(ptDest) = (char)162;

  0050f	c6 01 a2	 mov	 BYTE PTR [ecx], -94	; ffffffa2H

; 2410 : 								*(ptDest + 1) = (char)159;

  00512	c6 41 01 9f	 mov	 BYTE PTR [ecx+1], -97	; ffffff9fH

; 2411 : 								*(ptDest + 2) = (char)159;

  00516	c6 41 02 9f	 mov	 BYTE PTR [ecx+2], -97	; ffffff9fH

; 2412 : 								*(ptDest + 3) = (char)162;

  0051a	c6 41 03 a2	 mov	 BYTE PTR [ecx+3], -94	; ffffffa2H

; 2413 : 								*(ptDest + surfacePitch) = (char)159;

  0051e	c6 04 19 9f	 mov	 BYTE PTR [ecx+ebx], -97	; ffffff9fH

; 2414 : 								*(ptDest + surfacePitch + 1) = (char)159;

  00522	c6 44 19 01 9f	 mov	 BYTE PTR [ecx+ebx+1], -97 ; ffffff9fH

; 2415 : 								*(ptDest + surfacePitch + 2) = (char)159;

  00527	c6 44 19 02 9f	 mov	 BYTE PTR [ecx+ebx+2], -97 ; ffffff9fH

; 2416 : 								*(ptDest + surfacePitch + 3) = (char)159;

  0052c	c6 44 19 03 9f	 mov	 BYTE PTR [ecx+ebx+3], -97 ; ffffff9fH

; 2417 : 								*(ptDest + surfacePitch * 2) = (char)159;

  00531	c6 04 59 9f	 mov	 BYTE PTR [ecx+ebx*2], -97 ; ffffff9fH

; 2418 : 								*(ptDest + surfacePitch * 2 + 1) = (char)159;

  00535	c6 44 59 01 9f	 mov	 BYTE PTR [ecx+ebx*2+1], -97 ; ffffff9fH

; 2419 : 								*(ptDest + surfacePitch * 2 + 2) = (char)159;

  0053a	c6 44 59 02 9f	 mov	 BYTE PTR [ecx+ebx*2+2], -97 ; ffffff9fH

; 2420 : 								*(ptDest + surfacePitch * 2 + 3) = (char)159;

  0053f	c6 44 59 03 9f	 mov	 BYTE PTR [ecx+ebx*2+3], -97 ; ffffff9fH

; 2421 : 								*(ptDest + surfacePitch * 3) = (char)162;

  00544	8d 04 59	 lea	 eax, DWORD PTR [ecx+ebx*2]
  00547	c6 04 03 a2	 mov	 BYTE PTR [ebx+eax], -94	; ffffffa2H

; 2422 : 								*(ptDest + surfacePitch * 3 + 1) = (char)159;

  0054b	c6 44 03 01 9f	 mov	 BYTE PTR [ebx+eax+1], -97 ; ffffff9fH

; 2423 : 								*(ptDest + surfacePitch * 3 + 2) = (char)159;

  00550	c6 44 03 02 9f	 mov	 BYTE PTR [ebx+eax+2], -97 ; ffffff9fH

; 2424 : 								*(ptDest + surfacePitch * 3 + 3) = (char)162;

  00555	c6 44 03 03 a2	 mov	 BYTE PTR [ebx+eax+3], -94 ; ffffffa2H

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  0055a	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  00560	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  00563	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  00569	e9 7c fb ff ff	 jmp	 $LN152@DrawMapEff
$LN26@DrawMapEff:

; 2425 : 							}
; 2426 : 					}
; 2427 : 				}
; 2428 : 				else if (buf->type == MAP_EFFECT_TYPE_STAR) {

  0056e	66 83 f8 03	 cmp	 ax, 3
  00572	0f 85 dd 05 00
	00		 jne	 $LN39@DrawMapEff

; 2429 : 					if (buf->mode == 0) {

  00578	0f b7 46 40	 movzx	 eax, WORD PTR [esi+64]
  0057c	66 85 c0	 test	 ax, ax
  0057f	0f 85 33 01 00
	00		 jne	 $LN41@DrawMapEff

; 2430 : #ifdef _HI_COLOR_32
; 2431 : 						if (displayBpp == 32) {

  00585	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR ?displayBpp@@3HA, 32 ; displayBpp, 00000020H
  0058c	75 69		 jne	 SHORT $LN43@DrawMapEff

; 2432 : 							// ?????
; 2433 : 							*(ptDest32 - surfacePitch - 1) = highColor32Palette[8];

  0058e	8d 14 9d 00 00
	00 00		 lea	 edx, DWORD PTR [ebx*4]
  00595	8b cf		 mov	 ecx, edi
  00597	2b ca		 sub	 ecx, edx
  00599	a1 20 00 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+32
  0059e	89 41 fc	 mov	 DWORD PTR [ecx-4], eax

; 2434 : 							*(ptDest32 - surfacePitch) = highColor32Palette[255];

  005a1	a1 fc 03 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+1020
  005a6	89 01		 mov	 DWORD PTR [ecx], eax

; 2435 : 							*(ptDest32 - surfacePitch + 1) = highColor32Palette[8];

  005a8	a1 20 00 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+32
  005ad	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 2436 : 							*(ptDest32 - 1) = highColor32Palette[255];

  005b0	a1 fc 03 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+1020
  005b5	89 47 fc	 mov	 DWORD PTR [edi-4], eax

; 2437 : 							*(ptDest32) = highColor32Palette[255];

  005b8	a1 fc 03 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+1020
  005bd	89 07		 mov	 DWORD PTR [edi], eax

; 2438 : 							*(ptDest32 + 1) = highColorPalette[255];

  005bf	0f b7 05 fe 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+510
  005c6	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 2439 : 							*(ptDest32 + surfacePitch - 2) = highColor32Palette[8];

  005c9	a1 20 00 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+32
  005ce	89 44 9f f8	 mov	 DWORD PTR [edi+ebx*4-8], eax

; 2440 : 							*(ptDest32 + surfacePitch) = highColor32Palette[255];

  005d2	a1 fc 03 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+1020
  005d7	89 04 3a	 mov	 DWORD PTR [edx+edi], eax

; 2441 : 							*(ptDest32 + surfacePitch + 2) = highColor32Palette[8];

  005da	a1 20 00 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+32
  005df	89 44 9f 08	 mov	 DWORD PTR [edi+ebx*4+8], eax

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  005e3	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  005e9	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  005ec	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  005f2	e9 f3 fa ff ff	 jmp	 $LN152@DrawMapEff
$LN43@DrawMapEff:

; 2442 : 						}
; 2443 : 						else
; 2444 : #endif
; 2445 : 							if (displayBpp == 16) {

  005f7	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR ?displayBpp@@3HA, 16 ; displayBpp, 00000010H
  005fe	75 7c		 jne	 SHORT $LN45@DrawMapEff

; 2446 : 								// ?????
; 2447 : 								*(ptDest2 - surfacePitch - 1) = highColorPalette[8];

  00600	8d 14 1b	 lea	 edx, DWORD PTR [ebx+ebx]
  00603	8b 9d 78 ff ff
	ff		 mov	 ebx, DWORD PTR _ptDest2$9[ebp]
  00609	8b cb		 mov	 ecx, ebx
  0060b	2b ca		 sub	 ecx, edx
  0060d	a1 10 00 00 00	 mov	 eax, DWORD PTR ?highColorPalette@@3PAGA+16
  00612	66 89 41 fe	 mov	 WORD PTR [ecx-2], ax

; 2448 : 								*(ptDest2 - surfacePitch) = highColorPalette[255];

  00616	0f b7 05 fe 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+510
  0061d	66 89 01	 mov	 WORD PTR [ecx], ax

; 2449 : 								*(ptDest2 - surfacePitch + 1) = highColorPalette[8];

  00620	a1 10 00 00 00	 mov	 eax, DWORD PTR ?highColorPalette@@3PAGA+16
  00625	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 2450 : 								*(ptDest2 - 1) = highColorPalette[255];

  00629	0f b7 05 fe 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+510
  00630	66 89 43 fe	 mov	 WORD PTR [ebx-2], ax

; 2451 : 								*(ptDest2) = highColorPalette[255];

  00634	0f b7 05 fe 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+510
  0063b	66 89 03	 mov	 WORD PTR [ebx], ax

; 2452 : 								*(ptDest2 + 1) = highColorPalette[255];

  0063e	0f b7 05 fe 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+510
  00645	66 89 43 02	 mov	 WORD PTR [ebx+2], ax

; 2453 : 								*(ptDest2 + surfacePitch - 1) = highColorPalette[8];

  00649	a1 10 00 00 00	 mov	 eax, DWORD PTR ?highColorPalette@@3PAGA+16
  0064e	66 89 44 1a fe	 mov	 WORD PTR [edx+ebx-2], ax

; 2454 : 								*(ptDest2 + surfacePitch) = highColorPalette[255];

  00653	0f b7 05 fe 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+510
  0065a	66 89 04 1a	 mov	 WORD PTR [edx+ebx], ax

; 2455 : 								*(ptDest2 + surfacePitch + 1) = highColorPalette[8];

  0065e	a1 10 00 00 00	 mov	 eax, DWORD PTR ?highColorPalette@@3PAGA+16
  00663	66 89 44 1a 02	 mov	 WORD PTR [edx+ebx+2], ax

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  00668	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  0066e	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  00671	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  00677	e9 6e fa ff ff	 jmp	 $LN152@DrawMapEff
$LN45@DrawMapEff:

; 2456 : 							}
; 2457 : 							else {
; 2458 : 								// ?????
; 2459 : 								*(ptDest - surfacePitch - 1) = (char)8;

  0067c	8b c1		 mov	 eax, ecx
  0067e	2b c3		 sub	 eax, ebx
  00680	c6 40 ff 08	 mov	 BYTE PTR [eax-1], 8

; 2460 : 								*(ptDest - surfacePitch) = (char)255;

  00684	c6 00 ff	 mov	 BYTE PTR [eax], -1

; 2461 : 								*(ptDest - surfacePitch + 1) = (char)8;

  00687	c6 40 01 08	 mov	 BYTE PTR [eax+1], 8

; 2462 : 								*(ptDest - 1) = (char)255;

  0068b	c6 41 ff ff	 mov	 BYTE PTR [ecx-1], -1

; 2463 : 								*(ptDest) = (char)255;

  0068f	c6 01 ff	 mov	 BYTE PTR [ecx], -1

; 2464 : 								*(ptDest + 1) = (char)255;

  00692	c6 41 01 ff	 mov	 BYTE PTR [ecx+1], -1

; 2465 : 								*(ptDest + surfacePitch - 1) = (char)8;

  00696	c6 44 19 ff 08	 mov	 BYTE PTR [ecx+ebx-1], 8

; 2466 : 								*(ptDest + surfacePitch) = (char)255;

  0069b	c6 04 19 ff	 mov	 BYTE PTR [ecx+ebx], -1

; 2467 : 								*(ptDest + surfacePitch + 1) = (char)8;

  0069f	c6 44 19 01 08	 mov	 BYTE PTR [ecx+ebx+1], 8

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  006a4	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  006aa	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  006ad	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  006b3	e9 32 fa ff ff	 jmp	 $LN152@DrawMapEff
$LN41@DrawMapEff:

; 2468 : 							}
; 2469 : 					}
; 2470 : 					else if (buf->mode == 1) {

  006b8	66 83 f8 01	 cmp	 ax, 1
  006bc	0f 85 d7 00 00
	00		 jne	 $LN47@DrawMapEff

; 2471 : #ifdef _HI_COLOR_32
; 2472 : 						if (displayBpp == 32) {

  006c2	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR ?displayBpp@@3HA, 32 ; displayBpp, 00000020H
  006c9	75 45		 jne	 SHORT $LN49@DrawMapEff

; 2473 : 							// ?????
; 2474 : 							*(ptDest32 - surfacePitch) = highColor32Palette[251];

  006cb	8d 14 9d 00 00
	00 00		 lea	 edx, DWORD PTR [ebx*4]
  006d2	8b cf		 mov	 ecx, edi
  006d4	2b ca		 sub	 ecx, edx
  006d6	a1 ec 03 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+1004
  006db	89 01		 mov	 DWORD PTR [ecx], eax

; 2475 : 							*(ptDest32 - 1) = highColor32Palette[251];

  006dd	a1 ec 03 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+1004
  006e2	89 47 fc	 mov	 DWORD PTR [edi-4], eax

; 2476 : 							*(ptDest32) = highColor32Palette[251];

  006e5	a1 ec 03 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+1004
  006ea	89 07		 mov	 DWORD PTR [edi], eax

; 2477 : 							*(ptDest32 + 1) = highColor32Palette[251];

  006ec	a1 ec 03 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+1004
  006f1	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 2478 : 							*(ptDest32 + surfacePitch) = highColor32Palette[251];

  006f4	a1 ec 03 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+1004
  006f9	89 04 3a	 mov	 DWORD PTR [edx+edi], eax

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  006fc	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  00702	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  00705	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  0070b	e9 da f9 ff ff	 jmp	 $LN152@DrawMapEff
$LN49@DrawMapEff:

; 2479 : 						}
; 2480 : 						else
; 2481 : #endif
; 2482 : 							if (displayBpp == 16) {

  00710	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR ?displayBpp@@3HA, 16 ; displayBpp, 00000010H
  00717	75 56		 jne	 SHORT $LN51@DrawMapEff

; 2483 : 								// ?????
; 2484 : 								*(ptDest2 - surfacePitch) = highColorPalette[251];

  00719	8d 14 1b	 lea	 edx, DWORD PTR [ebx+ebx]
  0071c	8b 9d 78 ff ff
	ff		 mov	 ebx, DWORD PTR _ptDest2$9[ebp]
  00722	8b cb		 mov	 ecx, ebx
  00724	2b ca		 sub	 ecx, edx
  00726	0f b7 05 f6 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+502
  0072d	66 89 01	 mov	 WORD PTR [ecx], ax

; 2485 : 								*(ptDest2 - 1) = highColorPalette[251];

  00730	0f b7 05 f6 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+502
  00737	66 89 43 fe	 mov	 WORD PTR [ebx-2], ax

; 2486 : 								*(ptDest2) = highColorPalette[251];

  0073b	0f b7 05 f6 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+502
  00742	66 89 03	 mov	 WORD PTR [ebx], ax

; 2487 : 								*(ptDest2 + 1) = highColorPalette[251];

  00745	0f b7 05 f6 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+502
  0074c	66 89 43 02	 mov	 WORD PTR [ebx+2], ax

; 2488 : 								*(ptDest2 + surfacePitch) = highColorPalette[251];

  00750	0f b7 05 f6 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+502
  00757	66 89 04 1a	 mov	 WORD PTR [edx+ebx], ax

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  0075b	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  00761	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  00764	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  0076a	e9 7b f9 ff ff	 jmp	 $LN152@DrawMapEff
$LN51@DrawMapEff:

; 2489 : 							}
; 2490 : 							else {
; 2491 : 								// ?????
; 2492 : 								*(ptDest - surfacePitch) = (char)251;

  0076f	8b c1		 mov	 eax, ecx
  00771	2b c3		 sub	 eax, ebx
  00773	c6 00 fb	 mov	 BYTE PTR [eax], -5	; fffffffbH

; 2493 : 								*(ptDest - 1) = (char)251;

  00776	c6 41 ff fb	 mov	 BYTE PTR [ecx-1], -5	; fffffffbH

; 2494 : 								*(ptDest) = (char)251;

  0077a	c6 01 fb	 mov	 BYTE PTR [ecx], -5	; fffffffbH

; 2495 : 								*(ptDest + 1) = (char)251;

  0077d	c6 41 01 fb	 mov	 BYTE PTR [ecx+1], -5	; fffffffbH

; 2496 : 								*(ptDest + surfacePitch) = (char)251;

  00781	c6 04 19 fb	 mov	 BYTE PTR [ecx+ebx], -5	; fffffffbH

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  00785	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  0078b	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  0078e	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  00794	e9 51 f9 ff ff	 jmp	 $LN152@DrawMapEff
$LN47@DrawMapEff:

; 2497 : 							}
; 2498 : 					}
; 2499 : 					else if (buf->mode == 2) {

  00799	66 83 f8 02	 cmp	 ax, 2
  0079d	0f 85 aa 00 00
	00		 jne	 $LN53@DrawMapEff

; 2500 : #ifdef _HI_COLOR_32
; 2501 : 						if (displayBpp == 32) {

  007a3	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR ?displayBpp@@3HA, 32 ; displayBpp, 00000020H
  007aa	75 34		 jne	 SHORT $LN55@DrawMapEff

; 2502 : 							// ???????
; 2503 : 							*(ptDest32) = highColor32Palette[251];

  007ac	a1 ec 03 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+1004
  007b1	89 07		 mov	 DWORD PTR [edi], eax

; 2504 : 							*(ptDest32 + 1) = highColor32Palette[255];

  007b3	a1 fc 03 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+1020
  007b8	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 2505 : 							*(ptDest32 + surfacePitch) = highColor32Palette[255];

  007bb	a1 fc 03 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+1020
  007c0	89 04 9f	 mov	 DWORD PTR [edi+ebx*4], eax

; 2506 : 							*(ptDest32 + surfacePitch + 1) = highColor32Palette[251];

  007c3	a1 ec 03 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+1004

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  007c8	89 44 9f 04	 mov	 DWORD PTR [edi+ebx*4+4], eax
$LN143@DrawMapEff:
  007cc	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
$LN5@DrawMapEff:
  007d2	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  007d5	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  007db	e9 0a f9 ff ff	 jmp	 $LN152@DrawMapEff
$LN55@DrawMapEff:

; 2507 : 						}
; 2508 : 						else
; 2509 : #endif
; 2510 : 							if (displayBpp == 16) {

  007e0	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR ?displayBpp@@3HA, 16 ; displayBpp, 00000010H
  007e7	75 40		 jne	 SHORT $LN57@DrawMapEff

; 2511 : 								// ???????
; 2512 : 								*(ptDest2) = highColorPalette[251];

  007e9	0f b7 05 f6 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+502
  007f0	66 89 02	 mov	 WORD PTR [edx], ax

; 2513 : 								*(ptDest2 + 1) = highColorPalette[255];

  007f3	0f b7 05 fe 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+510
  007fa	66 89 42 02	 mov	 WORD PTR [edx+2], ax

; 2514 : 								*(ptDest2 + surfacePitch) = highColorPalette[255];

  007fe	0f b7 05 fe 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+510
  00805	66 89 04 5a	 mov	 WORD PTR [edx+ebx*2], ax

; 2515 : 								*(ptDest2 + surfacePitch + 1) = highColorPalette[251];

  00809	0f b7 05 f6 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+502
  00810	66 89 44 5a 02	 mov	 WORD PTR [edx+ebx*2+2], ax

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  00815	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  0081b	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  0081e	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  00824	e9 c1 f8 ff ff	 jmp	 $LN152@DrawMapEff
$LN57@DrawMapEff:

; 2516 : 							}
; 2517 : 							else {
; 2518 : 								// ???????
; 2519 : 								*(ptDest) = (char)251;

  00829	c6 01 fb	 mov	 BYTE PTR [ecx], -5	; fffffffbH

; 2520 : 								*(ptDest + 1) = (char)255;

  0082c	c6 41 01 ff	 mov	 BYTE PTR [ecx+1], -1

; 2521 : 								*(ptDest + surfacePitch) = (char)255;

  00830	c6 04 19 ff	 mov	 BYTE PTR [ecx+ebx], -1

; 2522 : 								*(ptDest + surfacePitch + 1) = (char)251;

  00834	c6 44 19 01 fb	 mov	 BYTE PTR [ecx+ebx+1], -5 ; fffffffbH

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  00839	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  0083f	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  00842	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  00848	e9 9d f8 ff ff	 jmp	 $LN152@DrawMapEff
$LN53@DrawMapEff:

; 2523 : 							}
; 2524 : 					}
; 2525 : 					else if (buf->mode == 3) {

  0084d	66 83 f8 03	 cmp	 ax, 3
  00851	0f 85 aa 00 00
	00		 jne	 $LN59@DrawMapEff

; 2526 : #ifdef _HI_COLOR_32
; 2527 : 						if (displayBpp == 32) {

  00857	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR ?displayBpp@@3HA, 32 ; displayBpp, 00000020H
  0085e	75 34		 jne	 SHORT $LN61@DrawMapEff

; 2528 : 							// ???????
; 2529 : 							*(ptDest32) = highColor32Palette[255];

  00860	a1 fc 03 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+1020
  00865	89 07		 mov	 DWORD PTR [edi], eax

; 2530 : 							*(ptDest32 + 1) = highColor32Palette[251];

  00867	a1 ec 03 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+1004
  0086c	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 2531 : 							*(ptDest32 + surfacePitch) = highColor32Palette[251];

  0086f	a1 ec 03 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+1004
  00874	89 04 9f	 mov	 DWORD PTR [edi+ebx*4], eax

; 2532 : 							*(ptDest32 + surfacePitch + 1) = highColor32Palette[255];

  00877	a1 fc 03 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+1020

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  0087c	89 44 9f 04	 mov	 DWORD PTR [edi+ebx*4+4], eax
  00880	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  00886	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  00889	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  0088f	e9 56 f8 ff ff	 jmp	 $LN152@DrawMapEff
$LN61@DrawMapEff:

; 2533 : 						}
; 2534 : 						else
; 2535 : #endif
; 2536 : 							if (displayBpp == 16) {

  00894	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR ?displayBpp@@3HA, 16 ; displayBpp, 00000010H
  0089b	75 40		 jne	 SHORT $LN63@DrawMapEff

; 2537 : 								// ???????
; 2538 : 								*(ptDest2) = highColorPalette[255];

  0089d	0f b7 05 fe 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+510
  008a4	66 89 02	 mov	 WORD PTR [edx], ax

; 2539 : 								*(ptDest2 + 1) = highColorPalette[251];

  008a7	0f b7 05 f6 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+502
  008ae	66 89 42 02	 mov	 WORD PTR [edx+2], ax

; 2540 : 								*(ptDest2 + surfacePitch) = highColorPalette[251];

  008b2	0f b7 05 f6 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+502
  008b9	66 89 04 5a	 mov	 WORD PTR [edx+ebx*2], ax

; 2541 : 								*(ptDest2 + surfacePitch + 1) = highColorPalette[255];

  008bd	0f b7 05 fe 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+510
  008c4	66 89 44 5a 02	 mov	 WORD PTR [edx+ebx*2+2], ax

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  008c9	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  008cf	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  008d2	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  008d8	e9 0d f8 ff ff	 jmp	 $LN152@DrawMapEff
$LN63@DrawMapEff:

; 2542 : 							}
; 2543 : 							else {
; 2544 : 								// ???????
; 2545 : 								*(ptDest) = (char)255;

  008dd	c6 01 ff	 mov	 BYTE PTR [ecx], -1

; 2546 : 								*(ptDest + 1) = (char)251;

  008e0	c6 41 01 fb	 mov	 BYTE PTR [ecx+1], -5	; fffffffbH

; 2547 : 								*(ptDest + surfacePitch) = (char)251;

  008e4	c6 04 19 fb	 mov	 BYTE PTR [ecx+ebx], -5	; fffffffbH

; 2548 : 								*(ptDest + surfacePitch + 1) = (char)255;

  008e8	c6 44 19 01 ff	 mov	 BYTE PTR [ecx+ebx+1], -1

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  008ed	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  008f3	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  008f6	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  008fc	e9 e9 f7 ff ff	 jmp	 $LN152@DrawMapEff
$LN59@DrawMapEff:

; 2549 : 							}
; 2550 : 					}
; 2551 : 					else if (buf->mode == 4) {

  00901	66 83 f8 04	 cmp	 ax, 4
  00905	0f 85 aa 00 00
	00		 jne	 $LN65@DrawMapEff

; 2552 : #ifdef _HI_COLOR_32
; 2553 : 						if (displayBpp == 32) {

  0090b	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR ?displayBpp@@3HA, 32 ; displayBpp, 00000020H
  00912	75 34		 jne	 SHORT $LN67@DrawMapEff

; 2554 : 							// ???????
; 2555 : 							*(ptDest32) = highColor32Palette[251];

  00914	a1 ec 03 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+1004
  00919	89 07		 mov	 DWORD PTR [edi], eax

; 2556 : 							*(ptDest32 + 1) = highColor32Palette[193];

  0091b	a1 04 03 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+772
  00920	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 2557 : 							*(ptDest32 + surfacePitch) = highColor32Palette[193];

  00923	a1 04 03 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+772
  00928	89 04 9f	 mov	 DWORD PTR [edi+ebx*4], eax

; 2558 : 							*(ptDest32 + surfacePitch + 1) = highColor32Palette[193];

  0092b	a1 04 03 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+772

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  00930	89 44 9f 04	 mov	 DWORD PTR [edi+ebx*4+4], eax
  00934	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  0093a	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  0093d	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  00943	e9 a2 f7 ff ff	 jmp	 $LN152@DrawMapEff
$LN67@DrawMapEff:

; 2559 : 						}
; 2560 : 						else
; 2561 : #endif	
; 2562 : 							if (displayBpp == 16) {

  00948	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR ?displayBpp@@3HA, 16 ; displayBpp, 00000010H
  0094f	75 40		 jne	 SHORT $LN69@DrawMapEff

; 2563 : 								// ???????
; 2564 : 								*(ptDest2) = highColorPalette[251];

  00951	0f b7 05 f6 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+502
  00958	66 89 02	 mov	 WORD PTR [edx], ax

; 2565 : 								*(ptDest2 + 1) = highColorPalette[193];

  0095b	0f b7 05 82 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+386
  00962	66 89 42 02	 mov	 WORD PTR [edx+2], ax

; 2566 : 								*(ptDest2 + surfacePitch) = highColorPalette[193];

  00966	0f b7 05 82 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+386
  0096d	66 89 04 5a	 mov	 WORD PTR [edx+ebx*2], ax

; 2567 : 								*(ptDest2 + surfacePitch + 1) = highColorPalette[193];

  00971	0f b7 05 82 01
	00 00		 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA+386
  00978	66 89 44 5a 02	 mov	 WORD PTR [edx+ebx*2+2], ax

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  0097d	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  00983	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  00986	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  0098c	e9 59 f7 ff ff	 jmp	 $LN152@DrawMapEff
$LN69@DrawMapEff:

; 2568 : 							}
; 2569 : 							else {
; 2570 : 								// ???????
; 2571 : 								*(ptDest) = (char)251;

  00991	c6 01 fb	 mov	 BYTE PTR [ecx], -5	; fffffffbH

; 2572 : 								*(ptDest + 1) = (char)193;

  00994	c6 41 01 c1	 mov	 BYTE PTR [ecx+1], -63	; ffffffc1H

; 2573 : 								*(ptDest + surfacePitch) = (char)193;

  00998	c6 04 19 c1	 mov	 BYTE PTR [ecx+ebx], -63	; ffffffc1H

; 2574 : 								*(ptDest + surfacePitch + 1) = (char)193;

  0099c	c6 44 19 01 c1	 mov	 BYTE PTR [ecx+ebx+1], -63 ; ffffffc1H

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  009a1	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  009a7	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  009aa	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  009b0	e9 35 f7 ff ff	 jmp	 $LN152@DrawMapEff
$LN65@DrawMapEff:

; 2575 : 							}
; 2576 : 					}
; 2577 : 					else if (buf->mode == 5) {

  009b5	66 83 f8 05	 cmp	 ax, 5
  009b9	75 61		 jne	 SHORT $LN71@DrawMapEff

; 2578 : #ifdef _HI_COLOR_32
; 2579 : 						if (displayBpp == 32) {

  009bb	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR ?displayBpp@@3HA, 32 ; displayBpp, 00000020H
  009c2	75 1b		 jne	 SHORT $LN73@DrawMapEff

; 2580 : 							// ?????
; 2581 : 							*(ptDest32) = highColor32Palette[198];

  009c4	a1 18 03 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+792
  009c9	89 07		 mov	 DWORD PTR [edi], eax

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  009cb	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  009d1	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  009d4	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  009da	e9 0b f7 ff ff	 jmp	 $LN152@DrawMapEff
$LN73@DrawMapEff:

; 2582 : 						}
; 2583 : 						else
; 2584 : #endif
; 2585 : 							if (displayBpp == 16) {

  009df	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR ?displayBpp@@3HA, 16 ; displayBpp, 00000010H
  009e6	75 1d		 jne	 SHORT $LN75@DrawMapEff

; 2586 : 								// ?????
; 2587 : 								*(ptDest2) = highColorPalette[198];

  009e8	66 a1 8c 01 00
	00		 mov	 ax, WORD PTR ?highColorPalette@@3PAGA+396
  009ee	66 89 02	 mov	 WORD PTR [edx], ax

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  009f1	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  009f7	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  009fa	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  00a00	e9 e5 f6 ff ff	 jmp	 $LN152@DrawMapEff
$LN75@DrawMapEff:

; 2588 : 							}
; 2589 : 							else {
; 2590 : 								// ?????
; 2591 : 								*(ptDest) = (char)198;

  00a05	c6 01 c6	 mov	 BYTE PTR [ecx], -58	; ffffffc6H

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  00a08	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  00a0e	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  00a11	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  00a17	e9 ce f6 ff ff	 jmp	 $LN152@DrawMapEff
$LN71@DrawMapEff:

; 2592 : 							}
; 2593 : 					}
; 2594 : 					else if (buf->mode == 6) {

  00a1c	66 83 f8 06	 cmp	 ax, 6
  00a20	75 61		 jne	 SHORT $LN77@DrawMapEff

; 2595 : #ifdef _HI_COLOR_32
; 2596 : 						if (displayBpp == 32) {

  00a22	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR ?displayBpp@@3HA, 32 ; displayBpp, 00000020H
  00a29	75 1b		 jne	 SHORT $LN79@DrawMapEff

; 2597 : 							// ?????
; 2598 : 							*(ptDest32) = highColor32Palette[193];

  00a2b	a1 04 03 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+772
  00a30	89 07		 mov	 DWORD PTR [edi], eax

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  00a32	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  00a38	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  00a3b	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  00a41	e9 a4 f6 ff ff	 jmp	 $LN152@DrawMapEff
$LN79@DrawMapEff:

; 2599 : 						}
; 2600 : 						else
; 2601 : #endif
; 2602 : 							if (displayBpp == 16) {

  00a46	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR ?displayBpp@@3HA, 16 ; displayBpp, 00000010H
  00a4d	75 1d		 jne	 SHORT $LN81@DrawMapEff

; 2603 : 								// ?????
; 2604 : 								*(ptDest2) = highColorPalette[193];

  00a4f	66 a1 82 01 00
	00		 mov	 ax, WORD PTR ?highColorPalette@@3PAGA+386
  00a55	66 89 02	 mov	 WORD PTR [edx], ax

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  00a58	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  00a5e	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  00a61	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  00a67	e9 7e f6 ff ff	 jmp	 $LN152@DrawMapEff
$LN81@DrawMapEff:

; 2605 : 							}
; 2606 : 							else {
; 2607 : 								// ?????
; 2608 : 								*(ptDest) = (char)193;

  00a6c	c6 01 c1	 mov	 BYTE PTR [ecx], -63	; ffffffc1H

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  00a6f	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  00a75	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  00a78	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  00a7e	e9 67 f6 ff ff	 jmp	 $LN152@DrawMapEff
$LN77@DrawMapEff:

; 2609 : 							}
; 2610 : 					}
; 2611 : 					else if (buf->mode == 7) {

  00a83	66 83 f8 07	 cmp	 ax, 7
  00a87	75 61		 jne	 SHORT $LN83@DrawMapEff

; 2612 : #ifdef _HI_COLOR_32
; 2613 : 						if (displayBpp == 32) {

  00a89	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR ?displayBpp@@3HA, 32 ; displayBpp, 00000020H
  00a90	75 1b		 jne	 SHORT $LN85@DrawMapEff

; 2614 : 							// ?????
; 2615 : 							*(ptDest32) = highColor32Palette[208];

  00a92	a1 40 03 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+832
  00a97	89 07		 mov	 DWORD PTR [edi], eax

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  00a99	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  00a9f	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  00aa2	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  00aa8	e9 3d f6 ff ff	 jmp	 $LN152@DrawMapEff
$LN85@DrawMapEff:

; 2616 : 						}
; 2617 : 						else
; 2618 : #endif
; 2619 : 							if (displayBpp == 16) {

  00aad	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR ?displayBpp@@3HA, 16 ; displayBpp, 00000010H
  00ab4	75 1d		 jne	 SHORT $LN87@DrawMapEff

; 2620 : 								// ?????
; 2621 : 								*(ptDest2) = highColorPalette[208];

  00ab6	66 a1 a0 01 00
	00		 mov	 ax, WORD PTR ?highColorPalette@@3PAGA+416
  00abc	66 89 02	 mov	 WORD PTR [edx], ax

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  00abf	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  00ac5	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  00ac8	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  00ace	e9 17 f6 ff ff	 jmp	 $LN152@DrawMapEff
$LN87@DrawMapEff:

; 2622 : 							}
; 2623 : 							else {
; 2624 : 								// ?????
; 2625 : 								*(ptDest) = (char)208;

  00ad3	c6 01 d0	 mov	 BYTE PTR [ecx], -48	; ffffffd0H

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  00ad6	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  00adc	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  00adf	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  00ae5	e9 00 f6 ff ff	 jmp	 $LN152@DrawMapEff
$LN83@DrawMapEff:

; 2626 : 							}
; 2627 : 					}
; 2628 : 					else if (buf->mode == 8) {

  00aea	66 83 f8 08	 cmp	 ax, 8
  00aee	0f 85 d8 fc ff
	ff		 jne	 $LN143@DrawMapEff

; 2629 : #ifdef _HI_COLOR_32
; 2630 : 						if (displayBpp == 32) {

  00af4	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR ?displayBpp@@3HA, 32 ; displayBpp, 00000020H
  00afb	75 1b		 jne	 SHORT $LN90@DrawMapEff

; 2631 : 							// ???
; 2632 : 							*(ptDest32) = highColor32Palette[251];

  00afd	a1 ec 03 00 00	 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA+1004
  00b02	89 07		 mov	 DWORD PTR [edi], eax

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  00b04	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  00b0a	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  00b0d	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  00b13	e9 d2 f5 ff ff	 jmp	 $LN152@DrawMapEff
$LN90@DrawMapEff:

; 2633 : 						}
; 2634 : 						else
; 2635 : #endif
; 2636 : 							if (displayBpp == 16) {

  00b18	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR ?displayBpp@@3HA, 16 ; displayBpp, 00000010H
  00b1f	75 1d		 jne	 SHORT $LN92@DrawMapEff

; 2637 : 								// ???
; 2638 : 								*(ptDest2) = highColorPalette[251];

  00b21	66 a1 f6 01 00
	00		 mov	 ax, WORD PTR ?highColorPalette@@3PAGA+502
  00b27	66 89 02	 mov	 WORD PTR [edx], ax

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  00b2a	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  00b30	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  00b33	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  00b39	e9 ac f5 ff ff	 jmp	 $LN152@DrawMapEff
$LN92@DrawMapEff:

; 2639 : 							}
; 2640 : 							else {
; 2641 : 								// ???
; 2642 : 								*(ptDest) = (char)251;

  00b3e	c6 01 fb	 mov	 BYTE PTR [ecx], -5	; fffffffbH

; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 				else if (buf->type == MAP_EFFECT_TYPE_HOTARU) {
; 2698 : 				}
; 2699 : 			}
; 2700 : 			buf = buf->next;

  00b41	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _ww$1$[ebp]
  00b47	8b 76 38	 mov	 esi, DWORD PTR [esi+56]

; 2701 : 		}

  00b4a	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _surfacePitch$1$[ebp]
  00b50	e9 95 f5 ff ff	 jmp	 $LN152@DrawMapEff
$LN39@DrawMapEff:

; 2643 : 							}
; 2644 : 					}
; 2645 : 				}
; 2646 : 				else if (buf->type == MAP_EFFECT_TYPE_KAMIFUBUKI) {

  00b55	66 83 f8 04	 cmp	 ax, 4
  00b59	0f 85 6d fc ff
	ff		 jne	 $LN143@DrawMapEff

; 2647 : 					// ????
; 2648 : 					if (buf->mode == 0) {

  00b5f	0f b7 46 40	 movzx	 eax, WORD PTR [esi+64]
  00b63	0f b7 56 3e	 movzx	 edx, WORD PTR [esi+62]
  00b67	66 85 c0	 test	 ax, ax
  00b6a	75 1c		 jne	 SHORT $LN96@DrawMapEff

; 2649 : 						if (buf->type2 == 0)

  00b6c	66 85 d2	 test	 dx, dx
  00b6f	75 04		 jne	 SHORT $LN98@DrawMapEff

; 2650 : 							color = (char)223;

  00b71	b3 df		 mov	 bl, -33			; ffffffdfH
  00b73	eb 61		 jmp	 SHORT $LN116@DrawMapEff
$LN98@DrawMapEff:

; 2651 : 						else if (buf->type2 == 1)

  00b75	bb 9f ff ff ff	 mov	 ebx, -97		; ffffff9fH
  00b7a	66 83 fa 01	 cmp	 dx, 1
  00b7e	b8 d9 ff ff ff	 mov	 eax, -39		; ffffffd9H
  00b83	0f 44 d8	 cmove	 ebx, eax

; 2652 : 							color = (char)217;
; 2653 : 						else
; 2654 : 							color = (char)159;
; 2655 : 					}

  00b86	eb 4e		 jmp	 SHORT $LN116@DrawMapEff
$LN96@DrawMapEff:

; 2656 : 					else if (buf->mode == 1) {

  00b88	66 83 f8 01	 cmp	 ax, 1
  00b8c	75 14		 jne	 SHORT $LN102@DrawMapEff

; 2657 : 						if (buf->type2 == 0)

  00b8e	66 85 d2	 test	 dx, dx
  00b91	75 04		 jne	 SHORT $LN104@DrawMapEff

; 2658 : 							color = (char)212;

  00b93	b3 d4		 mov	 bl, -44			; ffffffd4H
  00b95	eb 3f		 jmp	 SHORT $LN116@DrawMapEff
$LN104@DrawMapEff:

; 2659 : 						else if (buf->type2 == 1)

  00b97	66 83 fa 01	 cmp	 dx, 1
  00b9b	ba d0 ff ff ff	 mov	 edx, -48		; ffffffd0H

; 2660 : 							color = (char)208;
; 2661 : 						else
; 2662 : 							color = (char)159;
; 2663 : 					}

  00ba0	eb 2c		 jmp	 SHORT $LN147@DrawMapEff
$LN102@DrawMapEff:

; 2664 : 					else if (buf->mode == 2) {

  00ba2	66 83 f8 02	 cmp	 ax, 2
  00ba6	75 14		 jne	 SHORT $LN108@DrawMapEff

; 2665 : 						if (buf->type2 == 0)

  00ba8	66 85 d2	 test	 dx, dx
  00bab	75 04		 jne	 SHORT $LN110@DrawMapEff

; 2666 : 							color = (char)130;

  00bad	b3 82		 mov	 bl, -126		; ffffff82H
  00baf	eb 25		 jmp	 SHORT $LN116@DrawMapEff
$LN110@DrawMapEff:

; 2667 : 						else if (buf->type2 == 1)

  00bb1	66 83 fa 01	 cmp	 dx, 1
  00bb5	ba 93 ff ff ff	 mov	 edx, -109		; ffffff93H

; 2668 : 							color = (char)147;
; 2669 : 						else
; 2670 : 							color = (char)159;
; 2671 : 					}

  00bba	eb 12		 jmp	 SHORT $LN147@DrawMapEff
$LN108@DrawMapEff:

; 2672 : 					else {
; 2673 : 						if (buf->type2 == 0)

  00bbc	66 85 d2	 test	 dx, dx
  00bbf	75 04		 jne	 SHORT $LN114@DrawMapEff

; 2674 : 							color = (char)116;

  00bc1	b3 74		 mov	 bl, 116			; 00000074H
  00bc3	eb 11		 jmp	 SHORT $LN116@DrawMapEff
$LN114@DrawMapEff:

; 2675 : 						else if (buf->type2 == 1)

  00bc5	66 83 fa 01	 cmp	 dx, 1
  00bc9	ba 63 00 00 00	 mov	 edx, 99			; 00000063H
$LN147@DrawMapEff:

; 2676 : 							color = (char)99;
; 2677 : 						else
; 2678 : 							color = (char)159;
; 2679 : 					}
; 2680 : 					for (i = 0; i < buf->h; i++) {

  00bce	bb 9f ff ff ff	 mov	 ebx, -97		; ffffff9fH
  00bd3	0f 44 da	 cmove	 ebx, edx
$LN116@DrawMapEff:
  00bd6	33 c0		 xor	 eax, eax
$LN150@DrawMapEff:
  00bd8	89 85 60 ff ff
	ff		 mov	 DWORD PTR _i$5[ebp], eax
  00bde	3b 46 2c	 cmp	 eax, DWORD PTR [esi+44]
  00be1	0f 8d e5 fb ff
	ff		 jge	 $LN143@DrawMapEff

; 2681 : 						for (j = 0; j < buf->w; j++) {

  00be7	33 d2		 xor	 edx, edx
$LN149@DrawMapEff:
  00be9	89 95 54 ff ff
	ff		 mov	 DWORD PTR _j$2[ebp], edx
  00bef	3b 56 28	 cmp	 edx, DWORD PTR [esi+40]
  00bf2	0f 8d a4 00 00
	00		 jge	 $LN8@DrawMapEff

; 2682 : 							if (0 <= (buf->ex + j) && (buf->ex + j) < ww && 0 <= (buf->ey + i) && (buf->ey + i) < hh) {

  00bf8	8b 7e 20	 mov	 edi, DWORD PTR [esi+32]
  00bfb	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  00bfe	85 c0		 test	 eax, eax
  00c00	0f 88 90 00 00
	00		 js	 $LN122@DrawMapEff
  00c06	3b 85 7c ff ff
	ff		 cmp	 eax, DWORD PTR _ww$1$[ebp]
  00c0c	0f 8d 84 00 00
	00		 jge	 $LN122@DrawMapEff
  00c12	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00c15	03 85 60 ff ff
	ff		 add	 eax, DWORD PTR _i$5[ebp]
  00c1b	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _ptDest$8[ebp]
  00c21	78 73		 js	 SHORT $LN122@DrawMapEff
  00c23	3b 85 68 ff ff
	ff		 cmp	 eax, DWORD PTR _hh$1$[ebp]
  00c29	7d 6b		 jge	 SHORT $LN122@DrawMapEff

; 2683 : #ifdef _HI_COLOR_32
; 2684 : 								if (displayBpp == 32) {

  00c2b	8b b5 6c ff ff
	ff		 mov	 esi, DWORD PTR _surfacePitch$1$[ebp]
  00c31	0f af f0	 imul	 esi, eax
  00c34	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR ?displayBpp@@3HA, 32 ; displayBpp, 00000020H
  00c3b	75 21		 jne	 SHORT $LN119@DrawMapEff

; 2685 : 									*(ptDest32 + surfacePitch * (i + buf->ey) + j + buf->ex) = highColor32Palette[(unsigned char)color];

  00c3d	0f b6 c3	 movzx	 eax, bl
  00c40	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?highColor32Palette@@3PAIA[eax*4]
  00c47	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  00c4a	03 c2		 add	 eax, edx
  00c4c	8b b5 64 ff ff
	ff		 mov	 esi, DWORD PTR _ptDest32$6[ebp]
  00c52	89 0c 86	 mov	 DWORD PTR [esi+eax*4], ecx

; 2681 : 						for (j = 0; j < buf->w; j++) {

  00c55	8b b5 70 ff ff
	ff		 mov	 esi, DWORD PTR _buf$1$[ebp]
  00c5b	42		 inc	 edx
  00c5c	eb 8b		 jmp	 SHORT $LN149@DrawMapEff
$LN119@DrawMapEff:

; 2686 : 								}
; 2687 : 								else
; 2688 : #endif
; 2689 : 									if (displayBpp == 16)

  00c5e	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  00c61	03 c6		 add	 eax, esi
  00c63	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR ?displayBpp@@3HA, 16 ; displayBpp, 00000010H
  00c6a	75 21		 jne	 SHORT $LN121@DrawMapEff

; 2690 : 										*(ptDest2 + surfacePitch * (i + buf->ey) + j + buf->ex) = highColorPalette[(unsigned char)color];

  00c6c	0f b6 cb	 movzx	 ecx, bl
  00c6f	66 8b 0c 4d 00
	00 00 00	 mov	 cx, WORD PTR ?highColorPalette@@3PAGA[ecx*2]
  00c77	8b b5 78 ff ff
	ff		 mov	 esi, DWORD PTR _ptDest2$9[ebp]
  00c7d	66 89 0c 46	 mov	 WORD PTR [esi+eax*2], cx

; 2681 : 						for (j = 0; j < buf->w; j++) {

  00c81	8b b5 70 ff ff
	ff		 mov	 esi, DWORD PTR _buf$1$[ebp]
  00c87	42		 inc	 edx
  00c88	e9 5c ff ff ff	 jmp	 $LN149@DrawMapEff
$LN121@DrawMapEff:

; 2691 : 									else
; 2692 : 										*(ptDest + surfacePitch * (i + buf->ey) + j + buf->ex) = color;

  00c8d	88 1c 08	 mov	 BYTE PTR [eax+ecx], bl

; 2681 : 						for (j = 0; j < buf->w; j++) {

  00c90	8b b5 70 ff ff
	ff		 mov	 esi, DWORD PTR _buf$1$[ebp]
$LN122@DrawMapEff:
  00c96	42		 inc	 edx
  00c97	e9 4d ff ff ff	 jmp	 $LN149@DrawMapEff
$LN8@DrawMapEff:

; 2676 : 							color = (char)99;
; 2677 : 						else
; 2678 : 							color = (char)159;
; 2679 : 					}
; 2680 : 					for (i = 0; i < buf->h; i++) {

  00c9c	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _i$5[ebp]
  00ca2	40		 inc	 eax
  00ca3	e9 30 ff ff ff	 jmp	 $LN150@DrawMapEff
$LN3@DrawMapEff:

; 2702 : 		if (lpDraw->lpBACKBUFFER->Unlock(NULL) != DD_OK)

  00ca8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00cad	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00cb0	8b 08		 mov	 ecx, DWORD PTR [eax]
  00cb2	6a 00		 push	 0
  00cb4	50		 push	 eax
  00cb5	ff 91 80 00 00
	00		 call	 DWORD PTR [ecx+128]

; 2703 : 			return;
; 2704 : 		return;

  00cbb	eb 0d		 jmp	 SHORT $LN128@DrawMapEff
__catch$?DrawMapEffect@@YAXXZ$0:

; 2705 : 	}
; 2706 : 	catch (...)
; 2707 : 	{
; 2708 : 
; 2709 : 	}

  00cbd	b8 00 00 00 00	 mov	 eax, $LN129@DrawMapEff
  00cc2	c3		 ret	 0
$LN129@DrawMapEff:
  00cc3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN128@DrawMapEff:

; 2710 : 
; 2711 : 	
; 2712 : }

  00cca	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00ccd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00cd4	59		 pop	 ecx
  00cd5	5f		 pop	 edi
  00cd6	5e		 pop	 esi
  00cd7	5b		 pop	 ebx
  00cd8	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00cdb	33 cd		 xor	 ecx, ebp
  00cdd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ce2	8b e5		 mov	 esp, ebp
  00ce4	5d		 pop	 ebp
  00ce5	c3		 ret	 0
  00ce6	cc		 int	 3
  00ce7	cc		 int	 3
  00ce8	cc		 int	 3
  00ce9	cc		 int	 3
  00cea	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?DrawMapEffect@@YAXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 50 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-176]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?DrawMapEffect@@YAXXZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?DrawMapEffect@@YAXXZ ENDP				; DrawMapEffect
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?saveBmpFile16@@YAHPBDPAEHH@Z
_TEXT	SEGMENT
_buf$GSCopy$1$ = -68					; size = 4
_writtensize$ = -64					; size = 4
_infoheader$ = -60					; size = 40
_fileheader$ = -20					; size = 14
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_buf$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
?saveBmpFile16@@YAHPBDPAEHH@Z PROC			; saveBmpFile16, COMDAT

; 3749 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  00016	53		 push	 ebx

; 3750 : 	HANDLE fh;
; 3751 : 	BITMAPFILEHEADER fileheader;
; 3752 : 	BITMAPINFOHEADER infoheader;
; 3753 : 
; 3754 : 	DWORD writtensize;
; 3755 : 	BYTE zero = 0;
; 3756 : 
; 3757 : 	fh = CreateFile( filename, GENERIC_WRITE, (DWORD)NULL,

  00017	6a 00		 push	 0
  00019	68 80 00 00 00	 push	 128			; 00000080H
  0001e	6a 02		 push	 2
  00020	6a 00		 push	 0
  00022	6a 00		 push	 0
  00024	68 00 00 00 40	 push	 1073741824		; 40000000H
  00029	50		 push	 eax
  0002a	89 4d bc	 mov	 DWORD PTR _buf$GSCopy$1$[ebp], ecx
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00033	8b d8		 mov	 ebx, eax

; 3758 : 			(LPSECURITY_ATTRIBUTES)NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL );
; 3759 : 
; 3760 : 	if( fh == INVALID_HANDLE_VALUE ) return FALSE;

  00035	83 fb ff	 cmp	 ebx, -1
  00038	75 11		 jne	 SHORT $LN2@saveBmpFil
  0003a	33 c0		 xor	 eax, eax
  0003c	5b		 pop	 ebx

; 3785 : 
; 3786 : 	return TRUE;
; 3787 : }

  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00040	33 cd		 xor	 ecx, ebp
  00042	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
$LN2@saveBmpFil:

; 3761 : 
; 3762 : 	fileheader.bfType = 0x4D42;
; 3763 : 	fileheader.bfSize = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + width * height * 3;

  0004b	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  0004e	b8 42 4d 00 00	 mov	 eax, 19778		; 00004d42H
  00053	8b 4d 14	 mov	 ecx, DWORD PTR _height$[ebp]
  00056	66 89 45 ec	 mov	 WORD PTR _fileheader$[ebp], ax
  0005a	8b c2		 mov	 eax, edx
  0005c	0f af c1	 imul	 eax, ecx
  0005f	56		 push	 esi

; 3764 : 	fileheader.bfReserved1 = 0;
; 3765 : 	fileheader.bfReserved2 = 0;
; 3766 : 	fileheader.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);
; 3767 : 
; 3768 : 	infoheader.biSize = sizeof(BITMAPINFOHEADER);
; 3769 : 	infoheader.biWidth = width;
; 3770 : 	infoheader.biHeight = height;
; 3771 : 	infoheader.biPlanes = 1;
; 3772 : 	infoheader.biBitCount = 24;
; 3773 : 	infoheader.biCompression = 0;
; 3774 : 	infoheader.biSizeImage = width * height * 3;
; 3775 : 	infoheader.biXPelsPerMeter = 0;
; 3776 : 	infoheader.biYPelsPerMeter = 0;
; 3777 : 	infoheader.biClrUsed = 0;
; 3778 : 	infoheader.biClrImportant = 0;
; 3779 : 
; 3780 : 	WriteFile(fh,(void*)(&fileheader),sizeof(fileheader),&writtensize,NULL);

  00060	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__WriteFile@20
  00066	57		 push	 edi
  00067	c7 45 f6 36 00
	00 00		 mov	 DWORD PTR _fileheader$[ebp+10], 54 ; 00000036H
  0006e	c7 45 c4 28 00
	00 00		 mov	 DWORD PTR _infoheader$[ebp], 40 ; 00000028H
  00075	89 55 c8	 mov	 DWORD PTR _infoheader$[ebp+4], edx
  00078	89 4d cc	 mov	 DWORD PTR _infoheader$[ebp+8], ecx
  0007b	8d 3c 40	 lea	 edi, DWORD PTR [eax+eax*2]
  0007e	c7 45 d0 01 00
	18 00		 mov	 DWORD PTR _infoheader$[ebp+12], 1572865 ; 00180001H
  00085	8d 47 36	 lea	 eax, DWORD PTR [edi+54]
  00088	89 7d d8	 mov	 DWORD PTR _infoheader$[ebp+20], edi
  0008b	89 45 ee	 mov	 DWORD PTR _fileheader$[ebp+2], eax
  0008e	33 c0		 xor	 eax, eax
  00090	50		 push	 eax
  00091	89 45 f2	 mov	 DWORD PTR _fileheader$[ebp+6], eax
  00094	89 45 d4	 mov	 DWORD PTR _infoheader$[ebp+16], eax
  00097	89 45 dc	 mov	 DWORD PTR _infoheader$[ebp+24], eax
  0009a	89 45 e0	 mov	 DWORD PTR _infoheader$[ebp+28], eax
  0009d	89 45 e4	 mov	 DWORD PTR _infoheader$[ebp+32], eax
  000a0	89 45 e8	 mov	 DWORD PTR _infoheader$[ebp+36], eax
  000a3	8d 45 c0	 lea	 eax, DWORD PTR _writtensize$[ebp]
  000a6	50		 push	 eax
  000a7	6a 0e		 push	 14			; 0000000eH
  000a9	8d 45 ec	 lea	 eax, DWORD PTR _fileheader$[ebp]
  000ac	50		 push	 eax
  000ad	53		 push	 ebx
  000ae	ff d6		 call	 esi

; 3781 : 	WriteFile(fh,(void*)(&infoheader),sizeof(BITMAPINFOHEADER),&writtensize,NULL);

  000b0	6a 00		 push	 0
  000b2	8d 45 c0	 lea	 eax, DWORD PTR _writtensize$[ebp]
  000b5	50		 push	 eax
  000b6	6a 28		 push	 40			; 00000028H
  000b8	8d 45 c4	 lea	 eax, DWORD PTR _infoheader$[ebp]
  000bb	50		 push	 eax
  000bc	53		 push	 ebx
  000bd	ff d6		 call	 esi

; 3782 : 	WriteFile(fh,(void*)buf,width * height * 3,&writtensize,NULL);

  000bf	6a 00		 push	 0
  000c1	8d 4d c0	 lea	 ecx, DWORD PTR _writtensize$[ebp]
  000c4	51		 push	 ecx
  000c5	57		 push	 edi
  000c6	ff 75 bc	 push	 DWORD PTR _buf$GSCopy$1$[ebp]
  000c9	53		 push	 ebx
  000ca	ff d6		 call	 esi

; 3783 : 
; 3784 : 	CloseHandle( fh );

  000cc	53		 push	 ebx
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 3785 : 
; 3786 : 	return TRUE;
; 3787 : }

  000d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	33 cd		 xor	 ecx, ebp
  000df	5b		 pop	 ebx
  000e0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
?saveBmpFile16@@YAHPBDPAEHH@Z ENDP			; saveBmpFile16
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?saveBmpFile@@YAHPBDPAEHHHHHPAUtagRGBQUAD@@H@Z
_TEXT	SEGMENT
_buf$GSCopy$1$ = -100					; size = 4
_x$GSCopy$1$ = -96					; size = 4
_y$GSCopy$1$ = -92					; size = 4
_rgbpal$GSCopy$1$ = -88					; size = 4
_fh$1$ = -84						; size = 4
_srcpitch$GSCopy$1$ = -80				; size = 4
_height$GSCopy$1$ = -76					; size = 4
_linesize$1$ = -72					; size = 4
_writtensize$ = -68					; size = 4
_zero$ = -61						; size = 1
_infoheader$ = -60					; size = 40
_fileheader$ = -20					; size = 14
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_buf$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_width$ = 24						; size = 4
_height$ = 28						; size = 4
_srcpitch$ = 32						; size = 4
_rgbpal$ = 36						; size = 4
_colorCnt$ = 40						; size = 4
?saveBmpFile@@YAHPBDPAEHHHHHPAUtagRGBQUAD@@H@Z PROC	; saveBmpFile, COMDAT

; 3691 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _filename$[ebp]
  00016	89 45 9c	 mov	 DWORD PTR _buf$GSCopy$1$[ebp], eax
  00019	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  0001c	89 45 a0	 mov	 DWORD PTR _x$GSCopy$1$[ebp], eax
  0001f	8b 45 14	 mov	 eax, DWORD PTR _y$[ebp]
  00022	89 45 a4	 mov	 DWORD PTR _y$GSCopy$1$[ebp], eax
  00025	8b 45 20	 mov	 eax, DWORD PTR _srcpitch$[ebp]
  00028	56		 push	 esi
  00029	8b 75 1c	 mov	 esi, DWORD PTR _height$[ebp]
  0002c	89 45 b0	 mov	 DWORD PTR _srcpitch$GSCopy$1$[ebp], eax
  0002f	8b 45 24	 mov	 eax, DWORD PTR _rgbpal$[ebp]

; 3692 : 	HANDLE fh;
; 3693 : 	BITMAPFILEHEADER fileheader;
; 3694 : 	BITMAPINFOHEADER infoheader;
; 3695 : 
; 3696 : 	int linesize = (width+3)/4;
; 3697 : 	DWORD writtensize;
; 3698 : 	BYTE zero = 0;
; 3699 : 	int i;
; 3700 : 
; 3701 : 	fh = CreateFile( filename, GENERIC_WRITE, (DWORD)NULL,

  00032	6a 00		 push	 0
  00034	89 45 a8	 mov	 DWORD PTR _rgbpal$GSCopy$1$[ebp], eax
  00037	8b 45 18	 mov	 eax, DWORD PTR _width$[ebp]
  0003a	68 80 00 00 00	 push	 128			; 00000080H
  0003f	83 c0 03	 add	 eax, 3
  00042	89 75 b4	 mov	 DWORD PTR _height$GSCopy$1$[ebp], esi
  00045	6a 02		 push	 2
  00047	99		 cdq
  00048	6a 00		 push	 0
  0004a	83 e2 03	 and	 edx, 3
  0004d	c6 45 c3 00	 mov	 BYTE PTR _zero$[ebp], 0
  00051	6a 00		 push	 0
  00053	03 c2		 add	 eax, edx
  00055	68 00 00 00 40	 push	 1073741824		; 40000000H
  0005a	c1 f8 02	 sar	 eax, 2
  0005d	51		 push	 ecx
  0005e	89 45 b8	 mov	 DWORD PTR _linesize$1$[ebp], eax
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00067	8b c8		 mov	 ecx, eax
  00069	89 4d ac	 mov	 DWORD PTR _fh$1$[ebp], ecx

; 3702 : 			(LPSECURITY_ATTRIBUTES)NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL );
; 3703 : 
; 3704 : 	if( fh == INVALID_HANDLE_VALUE )

  0006c	83 f9 ff	 cmp	 ecx, -1
  0006f	75 11		 jne	 SHORT $LN5@saveBmpFil

; 3705 : 	{
; 3706 : 		return FALSE;

  00071	33 c0		 xor	 eax, eax
  00073	5e		 pop	 esi

; 3744 : 
; 3745 : 	return TRUE;
; 3746 : }

  00074	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00077	33 cd		 xor	 ecx, ebp
  00079	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
$LN5@saveBmpFil:

; 3711 : 	fileheader.bfSize = sizeof( BITMAPFILEHEADER )

  00082	0f af 75 b8	 imul	 esi, DWORD PTR _linesize$1$[ebp]
  00086	b8 42 4d 00 00	 mov	 eax, 19778		; 00004d42H
  0008b	53		 push	 ebx
  0008c	57		 push	 edi
  0008d	8b 7d 28	 mov	 edi, DWORD PTR _colorCnt$[ebp]
  00090	66 89 45 ec	 mov	 WORD PTR _fileheader$[ebp], ax

; 3712 : 		+sizeof( BITMAPINFOHEADER )+sizeof(RGBQUAD)*(colorCnt)+linesize*height;
; 3713 : 	fileheader.bfReserved1 = 0;
; 3714 : 	fileheader.bfReserved2 = 0;
; 3715 : 	fileheader.bfOffBits = sizeof( BITMAPFILEHEADER )
; 3716 : 		+sizeof( BITMAPINFOHEADER )+sizeof(RGBQUAD)*(colorCnt);
; 3717 : 
; 3718 : 	WriteFile( fh, (void*)(&fileheader), sizeof( fileheader ), &writtensize, NULL );

  00094	6a 00		 push	 0
  00096	8d 1c bd 00 00
	00 00		 lea	 ebx, DWORD PTR [edi*4]
  0009d	8d 43 36	 lea	 eax, DWORD PTR [ebx+54]
  000a0	03 c6		 add	 eax, esi
  000a2	89 45 ee	 mov	 DWORD PTR _fileheader$[ebp+2], eax
  000a5	33 c0		 xor	 eax, eax
  000a7	89 45 f2	 mov	 DWORD PTR _fileheader$[ebp+6], eax
  000aa	8d 43 36	 lea	 eax, DWORD PTR [ebx+54]
  000ad	89 45 f6	 mov	 DWORD PTR _fileheader$[ebp+10], eax
  000b0	8d 45 bc	 lea	 eax, DWORD PTR _writtensize$[ebp]
  000b3	50		 push	 eax
  000b4	6a 0e		 push	 14			; 0000000eH
  000b6	8d 45 ec	 lea	 eax, DWORD PTR _fileheader$[ebp]
  000b9	50		 push	 eax
  000ba	51		 push	 ecx
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20

; 3719 : 
; 3720 : 
; 3721 : 	infoheader.biSize = sizeof( BITMAPINFOHEADER );
; 3722 : 	infoheader.biWidth = width;

  000c1	8b 45 18	 mov	 eax, DWORD PTR _width$[ebp]
  000c4	89 45 c8	 mov	 DWORD PTR _infoheader$[ebp+4], eax

; 3723 : 	infoheader.biHeight = height;

  000c7	8b 45 b4	 mov	 eax, DWORD PTR _height$GSCopy$1$[ebp]
  000ca	89 45 cc	 mov	 DWORD PTR _infoheader$[ebp+8], eax

; 3724 : 	infoheader.biPlanes = 1;
; 3725 : 	infoheader.biBitCount = 8;
; 3726 : 	infoheader.biCompression = NULL;
; 3727 : 	infoheader.biSizeImage = sizeof( BITMAPINFOHEADER )

  000cd	8d 46 28	 lea	 eax, DWORD PTR [esi+40]

; 3728 : 		+sizeof(RGBQUAD)*(colorCnt)+linesize*height;
; 3729 : 	infoheader.biXPelsPerMeter = 0;
; 3730 : 	infoheader.biYPelsPerMeter = 0;
; 3731 : 	infoheader.biClrUsed = colorCnt;
; 3732 : 	infoheader.biClrImportant = 0;
; 3733 : 
; 3734 : 	WriteFile( fh, (void*)(&infoheader), sizeof(BITMAPINFOHEADER), &writtensize, NULL );

  000d0	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__WriteFile@20
  000d6	03 c3		 add	 eax, ebx
  000d8	6a 00		 push	 0
  000da	89 45 d8	 mov	 DWORD PTR _infoheader$[ebp+20], eax
  000dd	8d 45 bc	 lea	 eax, DWORD PTR _writtensize$[ebp]
  000e0	50		 push	 eax
  000e1	6a 28		 push	 40			; 00000028H
  000e3	8d 45 c4	 lea	 eax, DWORD PTR _infoheader$[ebp]
  000e6	89 7d e4	 mov	 DWORD PTR _infoheader$[ebp+32], edi
  000e9	8b 7d ac	 mov	 edi, DWORD PTR _fh$1$[ebp]
  000ec	50		 push	 eax
  000ed	57		 push	 edi
  000ee	c7 45 c4 28 00
	00 00		 mov	 DWORD PTR _infoheader$[ebp], 40 ; 00000028H
  000f5	c7 45 d0 01 00
	08 00		 mov	 DWORD PTR _infoheader$[ebp+12], 524289 ; 00080001H
  000fc	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _infoheader$[ebp+16], 0
  00103	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _infoheader$[ebp+24], 0
  0010a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _infoheader$[ebp+28], 0
  00111	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _infoheader$[ebp+36], 0
  00118	ff d6		 call	 esi

; 3735 : 	WriteFile( fh, (void*)rgbpal, sizeof(RGBQUAD)*(colorCnt), &writtensize, NULL );

  0011a	6a 00		 push	 0
  0011c	8d 45 bc	 lea	 eax, DWORD PTR _writtensize$[ebp]
  0011f	50		 push	 eax
  00120	53		 push	 ebx
  00121	ff 75 a8	 push	 DWORD PTR _rgbpal$GSCopy$1$[ebp]
  00124	57		 push	 edi
  00125	ff d6		 call	 esi

; 3736 : 
; 3737 : 	for( i = 0; i < height; i++ )

  00127	8b 5d b4	 mov	 ebx, DWORD PTR _height$GSCopy$1$[ebp]
  0012a	85 db		 test	 ebx, ebx
  0012c	7e 44		 jle	 SHORT $LN3@saveBmpFil

; 3707 : 	}
; 3708 : 
; 3709 : 
; 3710 : 	fileheader.bfType = 0x4D42;

  0012e	8b 75 a4	 mov	 esi, DWORD PTR _y$GSCopy$1$[ebp]
  00131	8b 45 18	 mov	 eax, DWORD PTR _width$[ebp]
  00134	4e		 dec	 esi
  00135	29 45 b8	 sub	 DWORD PTR _linesize$1$[ebp], eax
  00138	03 f3		 add	 esi, ebx
  0013a	0f af 75 b0	 imul	 esi, DWORD PTR _srcpitch$GSCopy$1$[ebp]
  0013e	03 75 a0	 add	 esi, DWORD PTR _x$GSCopy$1$[ebp]
  00141	03 75 9c	 add	 esi, DWORD PTR _buf$GSCopy$1$[ebp]
$LL4@saveBmpFil:

; 3738 : 	{
; 3739 : 		WriteFile( fh, (void*)(buf+srcpitch*(height+y-1-i)+x), width, &writtensize, NULL );

  00144	6a 00		 push	 0
  00146	8d 4d bc	 lea	 ecx, DWORD PTR _writtensize$[ebp]
  00149	51		 push	 ecx
  0014a	50		 push	 eax
  0014b	56		 push	 esi
  0014c	57		 push	 edi
  0014d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20

; 3740 : 		WriteFile( fh, (void*)(&zero), linesize-width, &writtensize, NULL );

  00153	6a 00		 push	 0
  00155	8d 45 bc	 lea	 eax, DWORD PTR _writtensize$[ebp]
  00158	50		 push	 eax
  00159	ff 75 b8	 push	 DWORD PTR _linesize$1$[ebp]
  0015c	8d 45 c3	 lea	 eax, DWORD PTR _zero$[ebp]
  0015f	50		 push	 eax
  00160	57		 push	 edi
  00161	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  00167	2b 75 b0	 sub	 esi, DWORD PTR _srcpitch$GSCopy$1$[ebp]
  0016a	8b 45 18	 mov	 eax, DWORD PTR _width$[ebp]
  0016d	83 eb 01	 sub	 ebx, 1
  00170	75 d2		 jne	 SHORT $LL4@saveBmpFil
$LN3@saveBmpFil:

; 3741 : 	}
; 3742 : 
; 3743 : 	CloseHandle( fh );

  00172	57		 push	 edi
  00173	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 3744 : 
; 3745 : 	return TRUE;
; 3746 : }

  00179	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017c	b8 01 00 00 00	 mov	 eax, 1
  00181	5f		 pop	 edi
  00182	5b		 pop	 ebx
  00183	33 cd		 xor	 ecx, ebp
  00185	5e		 pop	 esi
  00186	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018b	8b e5		 mov	 esp, ebp
  0018d	5d		 pop	 ebp
  0018e	c3		 ret	 0
?saveBmpFile@@YAHPBDPAEHHHHHPAUtagRGBQUAD@@H@Z ENDP	; saveBmpFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\time.h
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?snapShot@@YAXXZ
_TEXT	SEGMENT
_longTime$ = -1424					; size = 8
_mem$1$ = -1416						; size = 4
_clientPoint$ = -1412					; size = 8
tv783 = -1404						; size = 4
_w$1$ = -1400						; size = 4
_h$1$ = -1396						; size = 4
_ddsdDesc$ = -1392					; size = 108
_rgbpal$ = -1284					; size = 1024
_fileName$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
?snapShot@@YAXXZ PROC					; snapShot, COMDAT

; 3543 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 05 00
	00		 sub	 esp, 1424		; 00000590H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3544 : 	DDSURFACEDESC ddsdDesc;
; 3545 : 	RGBQUAD rgbpal[256];
; 3546 : 	char fileName[256];
; 3547 : 	int i;
; 3548 : 	struct tm *nowTime;
; 3549 : 	time_t longTime;
; 3550 : 	FILE *fp;
; 3551 : 	int w, h;
; 3552 : 	POINT 	clientPoint; // ????????????????????
; 3553 : 
; 3554 : 	// ?????????
; 3555 : 	clientPoint.x = 0;
; 3556 : 	clientPoint.y = 0;
; 3557 : 	// ??????????????????
; 3558 : 	ClientToScreen( hWnd, &clientPoint ); 

  00013	8d 85 7c fa ff
	ff		 lea	 eax, DWORD PTR _clientPoint$[ebp]
  00019	c7 85 7c fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _clientPoint$[ebp], 0
  00023	50		 push	 eax
  00024	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  0002a	c7 85 80 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _clientPoint$[ebp+4], 0
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ClientToScreen@8

; 3559 : 
; 3560 : 	// ??????
; 3561 : 	if( _mkdir( "screenshot" ) != 0 )

  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CMHOPIGK@screenshot@
  0003f	e8 00 00 00 00	 call	 __mkdir
  00044	83 c4 04	 add	 esp, 4
  00047	85 c0		 test	 eax, eax
  00049	74 0e		 je	 SHORT $LN17@snapShot

; 3562 : 	{
; 3563 : 		if( errno != EEXIST )

  0004b	e8 00 00 00 00	 call	 __errno
  00050	83 38 11	 cmp	 DWORD PTR [eax], 17	; 00000011H
  00053	0f 85 92 02 00
	00		 jne	 $LN31@snapShot
$LN17@snapShot:
  00059	53		 push	 ebx
  0005a	56		 push	 esi
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\time.h

; 522  :             return _time64(_Time);

  0005b	8d 85 70 fa ff
	ff		 lea	 eax, DWORD PTR _longTime$[ebp]
  00061	57		 push	 edi
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 __time64

; 499  :             return _localtime64(_Time);

  00068	8d 85 70 fa ff
	ff		 lea	 eax, DWORD PTR _longTime$[ebp]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 __localtime64
  00074	83 c4 08	 add	 esp, 8
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp

; 3569 : 	nowTime = localtime( &longTime );

  00077	8b f8		 mov	 edi, eax

; 3570 : 
; 3571 : 	for( i =  0; i < 1000; i ++ )

  00079	33 f6		 xor	 esi, esi
  0007b	8d 5e 64	 lea	 ebx, DWORD PTR [esi+100]
  0007e	66 90		 npad	 2
$LL4@snapShot:

; 3572 : 	{
; 3573 : 		sprintf( fileName, "screenshot\\sa%02d%02d%02d_%03d.bmp",

  00080	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00083	56		 push	 esi
  00084	ff 77 0c	 push	 DWORD PTR [edi+12]
  00087	40		 inc	 eax
  00088	50		 push	 eax
  00089	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0008c	99		 cdq
  0008d	f7 fb		 idiv	 ebx
  0008f	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _fileName$[ebp]
  00095	52		 push	 edx
  00096	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@EDDPAJGO@screenshot?2sa?$CF02d?$CF02d?$CF02d_?$CF03d?4@
  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 _sprintf

; 3574 : 			(nowTime->tm_year % 100), nowTime->tm_mon+1, nowTime->tm_mday, i );
; 3575 :  
; 3576 : 		if( (fp = fopen( fileName, "r" )) != NULL )

  000a1	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _fileName$[ebp]
  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r@
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 _fopen
  000b2	83 c4 20	 add	 esp, 32			; 00000020H
  000b5	85 c0		 test	 eax, eax
  000b7	74 12		 je	 SHORT $LN18@snapShot

; 3577 : 		{
; 3578 : 			// ??????????????????
; 3579 : 			fclose( fp );

  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 _fclose
  000bf	46		 inc	 esi
  000c0	83 c4 04	 add	 esp, 4
  000c3	81 fe e8 03 00
	00		 cmp	 esi, 1000		; 000003e8H
  000c9	7c b5		 jl	 SHORT $LL4@snapShot
$LN18@snapShot:

; 3580 : 			continue;
; 3581 : 		}
; 3582 : 		else
; 3583 : 		{
; 3584 : 			break;
; 3585 : 		}
; 3586 :     }
; 3587 : 
; 3588 : 	if(displayBpp != 16){

  000cb	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR ?displayBpp@@3HA, 16 ; displayBpp, 00000010H
  000d2	74 49		 je	 SHORT $LN6@snapShot

; 3589 : 		// ????
; 3590 : 		for( i = 0; i < 256; i++ ){

  000d4	33 c9		 xor	 ecx, ecx
  000d6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL7@snapShot:

; 3591 : 			rgbpal[i].rgbRed   = Palette[i].peRed;

  000e0	0f b6 81 00 00
	00 00		 movzx	 eax, BYTE PTR ?Palette@@3PAUtagPALETTEENTRY@@A[ecx]
  000e7	88 84 0d fe fa
	ff ff		 mov	 BYTE PTR _rgbpal$[ebp+ecx+2], al

; 3592 : 			rgbpal[i].rgbGreen = Palette[i].peGreen;

  000ee	0f b6 81 01 00
	00 00		 movzx	 eax, BYTE PTR ?Palette@@3PAUtagPALETTEENTRY@@A[ecx+1]
  000f5	88 84 0d fd fa
	ff ff		 mov	 BYTE PTR _rgbpal$[ebp+ecx+1], al

; 3593 : 			rgbpal[i].rgbBlue  = Palette[i].peBlue;

  000fc	0f b6 81 02 00
	00 00		 movzx	 eax, BYTE PTR ?Palette@@3PAUtagPALETTEENTRY@@A[ecx+2]
  00103	88 84 0d fc fa
	ff ff		 mov	 BYTE PTR _rgbpal$[ebp+ecx], al

; 3594 : 			rgbpal[i].rgbReserved = 0;

  0010a	c6 84 0d ff fa
	ff ff 00	 mov	 BYTE PTR _rgbpal$[ebp+ecx+3], 0
  00112	83 c1 04	 add	 ecx, 4
  00115	81 f9 00 04 00
	00		 cmp	 ecx, 1024		; 00000400H
  0011b	7c c3		 jl	 SHORT $LL7@snapShot
$LN6@snapShot:

; 3595 : 		}
; 3596 : 	}
; 3597 : 	memset( &ddsdDesc, 0, sizeof( DDSURFACEDESC ) );

  0011d	6a 68		 push	 104			; 00000068H
  0011f	8d 85 94 fa ff
	ff		 lea	 eax, DWORD PTR _ddsdDesc$[ebp+4]
  00125	6a 00		 push	 0
  00127	50		 push	 eax
  00128	e8 00 00 00 00	 call	 _memset

; 3598 : 	ddsdDesc.dwSize = sizeof( DDSURFACEDESC );
; 3599 : 	if( lpDraw->lpFRONTBUFFER->Lock( NULL, &ddsdDesc, 0, NULL ) != DD_OK ){

  0012d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00132	8d 95 90 fa ff
	ff		 lea	 edx, DWORD PTR _ddsdDesc$[ebp]
  00138	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013b	c7 85 90 fa ff
	ff 6c 00 00 00	 mov	 DWORD PTR _ddsdDesc$[ebp], 108 ; 0000006cH
  00145	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00148	6a 00		 push	 0
  0014a	6a 00		 push	 0
  0014c	52		 push	 edx
  0014d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0014f	6a 00		 push	 0
  00151	50		 push	 eax
  00152	ff 51 64	 call	 DWORD PTR [ecx+100]
  00155	85 c0		 test	 eax, eax
  00157	0f 85 8b 01 00
	00		 jne	 $LN53@snapShot

; 3600 : #ifdef  _STONDEBUG_
; 3601 : 		MessageBox(hWnd,"前景缓冲区锁定失败！", "확인", MB_OK | MB_ICONSTOP );
; 3602 : #endif
; 3603 : 		return;
; 3604 : 	}
; 3605 : 	/*
; 3606 : 	if( ResoMode == 1 )
; 3607 : 	{
; 3608 : 		w = 320;
; 3609 : 		h = 240;
; 3610 : 	}
; 3611 : 	else
; 3612 : 	{
; 3613 : 		w = 640;
; 3614 : 		h = 480;
; 3615 : 	}*/
; 3616 : 	switch (ResoMode)

  0015d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ResoMode@@3HA ; ResoMode
  00162	83 e8 00	 sub	 eax, 0
  00165	74 2c		 je	 SHORT $LN24@snapShot
  00167	83 e8 03	 sub	 eax, 3
  0016a	74 1b		 je	 SHORT $LN23@snapShot
  0016c	83 e8 01	 sub	 eax, 1
  0016f	74 0a		 je	 SHORT $LN22@snapShot

; 3629 : 			break;
; 3630 : 		default:
; 3631 : 			w = 320;

  00171	bb 40 01 00 00	 mov	 ebx, 320		; 00000140H

; 3632 : 			h = 240;

  00176	8d 43 b0	 lea	 eax, DWORD PTR [ebx-80]
  00179	eb 22		 jmp	 SHORT $LN56@snapShot
$LN22@snapShot:

; 3617 : 	{
; 3618 : 		case 分辨率::mode1024:
; 3619 : 			w = 1024;

  0017b	bb 00 04 00 00	 mov	 ebx, 1024		; 00000400H

; 3620 : 			h = 768;

  00180	b8 00 03 00 00	 mov	 eax, 768		; 00000300H

; 3621 : 			break;

  00185	eb 16		 jmp	 SHORT $LN56@snapShot
$LN23@snapShot:

; 3622 : 		case  分辨率::mode800:
; 3623 : 			w = 800;

  00187	bb 20 03 00 00	 mov	 ebx, 800		; 00000320H

; 3624 : 			h = 600;

  0018c	b8 58 02 00 00	 mov	 eax, 600		; 00000258H

; 3625 : 			break;

  00191	eb 0a		 jmp	 SHORT $LN56@snapShot
$LN24@snapShot:

; 3626 : 		case  分辨率::mode640:
; 3627 : 			w = 640;

  00193	bb 80 02 00 00	 mov	 ebx, 640		; 00000280H

; 3628 : 			h = 480;

  00198	b8 e0 01 00 00	 mov	 eax, 480		; 000001e0H
$LN56@snapShot:

; 3633 : 			break;
; 3634 : 	}
; 3635 : 	if(displayBpp == 16){

  0019d	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR ?displayBpp@@3HA, 16 ; displayBpp, 00000010H
  001a4	89 85 8c fa ff
	ff		 mov	 DWORD PTR _h$1$[ebp], eax
  001aa	89 9d 88 fa ff
	ff		 mov	 DWORD PTR _w$1$[ebp], ebx
  001b0	0f 85 ea 00 00
	00		 jne	 $LN26@snapShot

; 3636 : 		BYTE *mem = new BYTE[w * h * 3],*pmem,pR,pG,pB;

  001b6	0f af c3	 imul	 eax, ebx
  001b9	68 34 0e 00 00	 push	 3636			; 00000e34H
  001be	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@LPEMAEJF@?2VBOXSVR?2_stoneage?2repos?2ssm?9sa@
  001c3	6a 01		 push	 1
  001c5	8d 34 40	 lea	 esi, DWORD PTR [eax+eax*2]
  001c8	56		 push	 esi
  001c9	e8 00 00 00 00	 call	 ??_U@YAPAXIHPBDH@Z	; operator new[]
  001ce	83 c4 10	 add	 esp, 16			; 00000010H
  001d1	89 85 78 fa ff
	ff		 mov	 DWORD PTR _mem$1$[ebp], eax

; 3637 : 		if(mem == NULL){

  001d7	85 c0		 test	 eax, eax
  001d9	0f 84 09 01 00
	00		 je	 $LN53@snapShot

; 3638 : #ifdef  _STONDEBUG_
; 3639 : 			MessageBox(hWnd,"记忆体配置失败失败！", "확인", MB_OK | MB_ICONSTOP );
; 3640 : #endif
; 3641 : 			return;
; 3642 : 		}
; 3643 : 		WORD *work = (WORD*)ddsdDesc.lpSurface;
; 3644 : 		pmem = mem;
; 3645 : 		pmem += w * h * 3;
; 3646 : 
; 3647 : 		// source face 一次移动二个byte
; 3648 : 		ddsdDesc.lPitch >>= 1;

  001df	8b 95 a0 fa ff
	ff		 mov	 edx, DWORD PTR _ddsdDesc$[ebp+16]
  001e5	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]

; 3649 : 		// work 是整个荧幕的位置,要作偏移
; 3650 : 		work += ddsdDesc.lPitch * g_clientPoint.y + g_clientPoint.x;

  001e8	8b 85 b4 fa ff
	ff		 mov	 eax, DWORD PTR _ddsdDesc$[ebp+36]
  001ee	d1 fa		 sar	 edx, 1
  001f0	89 95 a0 fa ff
	ff		 mov	 DWORD PTR _ddsdDesc$[ebp+16], edx
  001f6	0f af 15 04 00
	00 00		 imul	 edx, DWORD PTR ?g_clientPoint@@3UtagPOINT@@A+4
  001fd	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?g_clientPoint@@3UtagPOINT@@A
  00203	8d 3c 50	 lea	 edi, DWORD PTR [eax+edx*2]
  00206	8b 95 8c fa ff
	ff		 mov	 edx, DWORD PTR _h$1$[ebp]
  0020c	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  0020f	89 95 84 fa ff
	ff		 mov	 DWORD PTR tv783[ebp], edx
$LL12@snapShot:

; 3651 : 		for(int y=0;y<h;y++){
; 3652 : 			pmem -= w * 3;

  00215	2b c8		 sub	 ecx, eax
  00217	33 f6		 xor	 esi, esi
  00219	0f 1f 80 00 00
	00 00		 npad	 7
$LL15@snapShot:

; 3653 : 			for(int x=0;x<w;x++){
; 3654 : 				// 565 显示模式
; 3655 : 				if(gBitRShift == 2){

  00220	0f b7 14 77	 movzx	 edx, WORD PTR [edi+esi*2]
  00224	8a da		 mov	 bl, dl
  00226	8b c2		 mov	 eax, edx
  00228	c0 e3 03	 shl	 bl, 3
  0022b	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?gBitRShift@@3HA, 2 ; gBitRShift
  00232	75 0b		 jne	 SHORT $LN29@snapShot

; 3656 : 					pR = (BYTE)((((work[x] & 0xf800)) >> 11) << 3);
; 3657 : 					pG = (BYTE)((((work[x] & 0x07e0)) >> 5) << 2);

  00234	c1 e8 03	 shr	 eax, 3
  00237	24 fc		 and	 al, 252			; 000000fcH
  00239	66 c1 ea 08	 shr	 dx, 8

; 3658 : 					pB = (BYTE)((work[x] & 0x001f) << 3);
; 3659 : 				}

  0023d	eb 09		 jmp	 SHORT $LN57@snapShot
$LN29@snapShot:

; 3660 : 				// 555 显示模式
; 3661 : 				else{
; 3662 : 					pR = (BYTE)((work[x] >> 10) << 3);
; 3663 : 					pG = (BYTE)(((work[x] & 0x03e0) >> 5) << 3);

  0023f	c1 e8 02	 shr	 eax, 2
  00242	24 f8		 and	 al, 248			; 000000f8H
  00244	66 c1 ea 07	 shr	 dx, 7
$LN57@snapShot:

; 3664 : 					pB = (BYTE)((work[x] & 0x001f) << 3);
; 3665 : 				}
; 3666 : 				*pmem++ = pB;

  00248	0f b7 d2	 movzx	 edx, dx
  0024b	46		 inc	 esi
  0024c	88 19		 mov	 BYTE PTR [ecx], bl
  0024e	80 e2 f8	 and	 dl, 248			; 000000f8H
  00251	8b 9d 88 fa ff
	ff		 mov	 ebx, DWORD PTR _w$1$[ebp]

; 3667 : 				*pmem++ = pG;

  00257	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 3668 : 				*pmem++ = pR;

  0025a	88 51 02	 mov	 BYTE PTR [ecx+2], dl
  0025d	83 c1 03	 add	 ecx, 3
  00260	3b f3		 cmp	 esi, ebx
  00262	7c bc		 jl	 SHORT $LL15@snapShot

; 3669 : 			}
; 3670 : 			// 换行
; 3671 : 			work += ddsdDesc.lPitch;

  00264	8b 85 a0 fa ff
	ff		 mov	 eax, DWORD PTR _ddsdDesc$[ebp+16]
  0026a	8d 3c 47	 lea	 edi, DWORD PTR [edi+eax*2]

; 3672 : 			pmem -= w * 3;

  0026d	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  00270	2b c8		 sub	 ecx, eax
  00272	83 ad 84 fa ff
	ff 01		 sub	 DWORD PTR tv783[ebp], 1
  00279	75 9a		 jne	 SHORT $LL12@snapShot

; 3673 : 		}
; 3674 : 		
; 3675 : 		saveBmpFile16(fileName,mem,w,h);

  0027b	ff b5 8c fa ff
	ff		 push	 DWORD PTR _h$1$[ebp]
  00281	8b b5 78 fa ff
	ff		 mov	 esi, DWORD PTR _mem$1$[ebp]
  00287	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _fileName$[ebp]
  0028d	53		 push	 ebx
  0028e	56		 push	 esi
  0028f	50		 push	 eax
  00290	e8 00 00 00 00	 call	 ?saveBmpFile16@@YAHPBDPAEHH@Z ; saveBmpFile16

; 3676 : 		delete[] mem;

  00295	56		 push	 esi
  00296	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0029b	83 c4 14	 add	 esp, 20			; 00000014H

; 3677 : 	}

  0029e	eb 35		 jmp	 SHORT $LN27@snapShot
$LN26@snapShot:

; 3678 : 	else
; 3679 : 		saveBmpFile( fileName, (BYTE*)ddsdDesc.lpSurface,

  002a0	68 00 01 00 00	 push	 256			; 00000100H
  002a5	8d 8d fc fa ff
	ff		 lea	 ecx, DWORD PTR _rgbpal$[ebp]
  002ab	51		 push	 ecx
  002ac	ff b5 a0 fa ff
	ff		 push	 DWORD PTR _ddsdDesc$[ebp+16]
  002b2	50		 push	 eax
  002b3	53		 push	 ebx
  002b4	ff b5 80 fa ff
	ff		 push	 DWORD PTR _clientPoint$[ebp+4]
  002ba	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _fileName$[ebp]
  002c0	ff b5 7c fa ff
	ff		 push	 DWORD PTR _clientPoint$[ebp]
  002c6	ff b5 b4 fa ff
	ff		 push	 DWORD PTR _ddsdDesc$[ebp+36]
  002cc	50		 push	 eax
  002cd	e8 00 00 00 00	 call	 ?saveBmpFile@@YAHPBDPAEHHHHHPAUtagRGBQUAD@@H@Z ; saveBmpFile
  002d2	83 c4 24	 add	 esp, 36			; 00000024H
$LN27@snapShot:

; 3680 : 			clientPoint.x, clientPoint.y, w, h, ddsdDesc.lPitch, rgbpal, 256 );
; 3681 : 
; 3682 : 	if( lpDraw->lpFRONTBUFFER->Unlock( NULL ) != DD_OK )

  002d5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  002da	6a 00		 push	 0
  002dc	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  002df	50		 push	 eax
  002e0	8b 08		 mov	 ecx, DWORD PTR [eax]
  002e2	ff 91 80 00 00
	00		 call	 DWORD PTR [ecx+128]
$LN53@snapShot:
  002e8	5f		 pop	 edi
  002e9	5e		 pop	 esi
  002ea	5b		 pop	 ebx
$LN31@snapShot:

; 3683 : 		return;
; 3684 : }

  002eb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ee	33 cd		 xor	 ecx, ebp
  002f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002f5	8b e5		 mov	 esp, ebp
  002f7	5d		 pop	 ebp
  002f8	c3		 ret	 0
?snapShot@@YAXXZ ENDP					; snapShot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?getNearestColorIndex@@YAHKPAUtagPALETTEENTRY@@H@Z
_TEXT	SEGMENT
tv614 = -4						; size = 4
tv611 = 8						; size = 4
_color$ = 8						; size = 4
tv609 = 12						; size = 4
_palette$ = 12						; size = 4
tv612 = 16						; size = 4
_entry$ = 16						; size = 4
?getNearestColorIndex@@YAHKPAUtagPALETTEENTRY@@H@Z PROC	; getNearestColorIndex, COMDAT

; 2232 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2233 : 	double distance, mindist;
; 2234 : 	int min_index;
; 2235 : 	int i;
; 2236 : 	mindist = (palette[0].peRed - GetRValue(color))*(palette[0].peRed - GetRValue(color))

  00004	8b 55 08	 mov	 edx, DWORD PTR _color$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 7d 0c	 mov	 edi, DWORD PTR _palette$[ebp]

; 2237 : 		+ (palette[0].peGreen - GetGValue(color))*(palette[0].peGreen - GetGValue(color))
; 2238 : 		+ (palette[0].peBlue - GetBValue(color))*(palette[0].peBlue - GetBValue(color));
; 2239 : 	min_index = 0;

  0000d	33 db		 xor	 ebx, ebx
  0000f	0f b7 c2	 movzx	 eax, dx
  00012	c1 e8 08	 shr	 eax, 8
  00015	89 45 08	 mov	 DWORD PTR tv611[ebp], eax
  00018	0f b6 77 01	 movzx	 esi, BYTE PTR [edi+1]
  0001c	0f b6 4f 02	 movzx	 ecx, BYTE PTR [edi+2]
  00020	2b f0		 sub	 esi, eax
  00022	8b c2		 mov	 eax, edx
  00024	0f af f6	 imul	 esi, esi
  00027	c1 e8 10	 shr	 eax, 16			; 00000010H
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	2b c8		 sub	 ecx, eax
  0002f	89 45 0c	 mov	 DWORD PTR tv609[ebp], eax
  00032	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00035	0f b6 d2	 movzx	 edx, dl
  00038	2b c2		 sub	 eax, edx
  0003a	0f af c9	 imul	 ecx, ecx
  0003d	0f af c0	 imul	 eax, eax
  00040	89 55 fc	 mov	 DWORD PTR tv614[ebp], edx
  00043	03 c1		 add	 eax, ecx
  00045	03 c6		 add	 eax, esi
  00047	8d 73 10	 lea	 esi, DWORD PTR [ebx+16]
  0004a	66 0f 6e c8	 movd	 xmm1, eax

; 2240 : 	for (i = 16; i < entry - 16; i++) {

  0004e	8b 45 10	 mov	 eax, DWORD PTR _entry$[ebp]
  00051	83 c0 f0	 add	 eax, -16		; fffffff0H
  00054	89 45 10	 mov	 DWORD PTR tv612[ebp], eax
  00057	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  0005b	3b c6		 cmp	 eax, esi
  0005d	7e 40		 jle	 SHORT $LN11@getNearest

; 2233 : 	double distance, mindist;
; 2234 : 	int min_index;
; 2235 : 	int i;
; 2236 : 	mindist = (palette[0].peRed - GetRValue(color))*(palette[0].peRed - GetRValue(color))

  0005f	83 c7 42	 add	 edi, 66			; 00000042H
$LL4@getNearest:

; 2241 : 		distance = (palette[i].peRed - GetRValue(color))*(palette[i].peRed - GetRValue(color))

  00062	0f b6 4f ff	 movzx	 ecx, BYTE PTR [edi-1]
  00066	0f b6 47 fe	 movzx	 eax, BYTE PTR [edi-2]
  0006a	2b 45 fc	 sub	 eax, DWORD PTR tv614[ebp]
  0006d	2b 4d 08	 sub	 ecx, DWORD PTR tv611[ebp]
  00070	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00073	2b 55 0c	 sub	 edx, DWORD PTR tv609[ebp]
  00076	0f af c0	 imul	 eax, eax
  00079	0f af c9	 imul	 ecx, ecx
  0007c	0f af d2	 imul	 edx, edx
  0007f	03 c1		 add	 eax, ecx
  00081	03 c2		 add	 eax, edx
  00083	66 0f 6e c0	 movd	 xmm0, eax
  00087	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0

; 2242 : 			+ (palette[i].peGreen - GetGValue(color))*(palette[i].peGreen - GetGValue(color))
; 2243 : 			+ (palette[i].peBlue - GetBValue(color))*(palette[i].peBlue - GetBValue(color));
; 2244 : 		if (distance < mindist) {

  0008b	66 0f 2f c8	 comisd	 xmm1, xmm0
  0008f	76 05		 jbe	 SHORT $LN2@getNearest

; 2245 : 			min_index = i;

  00091	8b de		 mov	 ebx, esi

; 2246 : 			mindist = distance;

  00093	0f 28 c8	 movaps	 xmm1, xmm0
$LN2@getNearest:

; 2240 : 	for (i = 16; i < entry - 16; i++) {

  00096	46		 inc	 esi
  00097	83 c7 04	 add	 edi, 4
  0009a	3b 75 10	 cmp	 esi, DWORD PTR tv612[ebp]
  0009d	7c c3		 jl	 SHORT $LL4@getNearest
$LN11@getNearest:
  0009f	5f		 pop	 edi

; 2247 : 		}
; 2248 : 	}
; 2249 : 	return min_index;
; 2250 : }

  000a0	5e		 pop	 esi
  000a1	8b c3		 mov	 eax, ebx
  000a3	5b		 pop	 ebx
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
?getNearestColorIndex@@YAHKPAUtagPALETTEENTRY@@H@Z ENDP	; getNearestColorIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?getAutoMapColor@@YAHI@Z
_TEXT	SEGMENT
?height@?1??getAutoMapColor@@YAHI@Z@4HA$1 = -16		; size = 4
_red$1$ = -12						; size = 4
_green$1$ = -8						; size = 4
_blue$1$ = -4						; size = 4
_GraphicNo$ = 8						; size = 4
?getAutoMapColor@@YAHI@Z PROC				; getAutoMapColor, COMDAT

; 2196 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 2197 : 	int index = 0;
; 2198 : 	static int width, height;
; 2199 : 	static unsigned char *graBuf;
; 2200 : 	unsigned int red = 0, green = 0, blue = 0;
; 2201 : 	unsigned int cnt = 0;
; 2202 : 	int color;
; 2203 : 
; 2204 : 	int i, j;
; 2205 : 	// real.bin????????????????
; 2206 : 	if (realGetImage(GraphicNo, (unsigned char **)&graBuf, &width, &height) == FALSE) return 0;

  00008	68 00 00 00 00	 push	 OFFSET ?height@?1??getAutoMapColor@@YAHI@Z@4HA
  0000d	68 00 00 00 00	 push	 OFFSET ?width@?1??getAutoMapColor@@YAHI@Z@4HA
  00012	68 00 00 00 00	 push	 OFFSET ?graBuf@?1??getAutoMapColor@@YAHI@Z@4PAEA
  00017	ff 75 08	 push	 DWORD PTR _GraphicNo$[ebp]
  0001a	33 c0		 xor	 eax, eax
  0001c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _red$1$[ebp], 0
  00023	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _green$1$[ebp], 0
  0002a	33 db		 xor	 ebx, ebx
  0002c	89 45 fc	 mov	 DWORD PTR _blue$1$[ebp], eax
  0002f	e8 00 00 00 00	 call	 ?realGetImage@@YAHHPAPAEPAH1@Z ; realGetImage
  00034	83 c4 10	 add	 esp, 16			; 00000010H
  00037	85 c0		 test	 eax, eax
  00039	0f 84 a9 00 00
	00		 je	 $LN20@getAutoMap

; 2207 : 	// ???????????
; 2208 : 	for (i = 0; i < height; i++) {

  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?height@?1??getAutoMapColor@@YAHI@Z@4HA
  00045	89 4d f0	 mov	 DWORD PTR ?height@?1??getAutoMapColor@@YAHI@Z@4HA$1[ebp], ecx
  00048	85 c9		 test	 ecx, ecx
  0004a	0f 8e 98 00 00
	00		 jle	 $LN20@getAutoMap
  00050	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?width@?1??getAutoMapColor@@YAHI@Z@4HA
  00056	57		 push	 edi
  00057	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?graBuf@?1??getAutoMapColor@@YAHI@Z@4PAEA
  0005d	0f 1f 00	 npad	 3
$LL4@getAutoMap:

; 2209 : 		for (j = 0; j < width; j++) {

  00060	33 c0		 xor	 eax, eax
  00062	85 f6		 test	 esi, esi
  00064	7e 32		 jle	 SHORT $LN2@getAutoMap
$LL7@getAutoMap:

; 2210 : 			index = graBuf[i*width + j];

  00066	0f b6 14 07	 movzx	 edx, BYTE PTR [edi+eax]

; 2211 : 			if (index != DEF_COLORKEY) {	// ???????

  0006a	85 d2		 test	 edx, edx
  0006c	74 22		 je	 SHORT $LN5@getAutoMap

; 2212 : 				red += Palette[index].peRed;

  0006e	0f b6 0c 95 00
	00 00 00	 movzx	 ecx, BYTE PTR ?Palette@@3PAUtagPALETTEENTRY@@A[edx*4]
  00076	01 4d f4	 add	 DWORD PTR _red$1$[ebp], ecx

; 2213 : 				green += Palette[index].peGreen;

  00079	0f b6 0c 95 01
	00 00 00	 movzx	 ecx, BYTE PTR ?Palette@@3PAUtagPALETTEENTRY@@A[edx*4+1]
  00081	01 4d f8	 add	 DWORD PTR _green$1$[ebp], ecx

; 2214 : 				blue += Palette[index].peBlue;

  00084	0f b6 0c 95 02
	00 00 00	 movzx	 ecx, BYTE PTR ?Palette@@3PAUtagPALETTEENTRY@@A[edx*4+2]
  0008c	01 4d fc	 add	 DWORD PTR _blue$1$[ebp], ecx

; 2215 : 				cnt++;

  0008f	43		 inc	 ebx
$LN5@getAutoMap:

; 2209 : 		for (j = 0; j < width; j++) {

  00090	40		 inc	 eax
  00091	3b c6		 cmp	 eax, esi
  00093	7c d1		 jl	 SHORT $LL7@getAutoMap
  00095	8b 4d f0	 mov	 ecx, DWORD PTR ?height@?1??getAutoMapColor@@YAHI@Z@4HA$1[ebp]
$LN2@getAutoMap:

; 2207 : 	// ???????????
; 2208 : 	for (i = 0; i < height; i++) {

  00098	03 fe		 add	 edi, esi
  0009a	83 e9 01	 sub	 ecx, 1
  0009d	89 4d f0	 mov	 DWORD PTR ?height@?1??getAutoMapColor@@YAHI@Z@4HA$1[ebp], ecx
  000a0	75 be		 jne	 SHORT $LL4@getAutoMap

; 2216 : 			}
; 2217 : 		}
; 2218 : 	}
; 2219 : 
; 2220 : 	if (cnt == 0) return 0;

  000a2	5f		 pop	 edi
  000a3	85 db		 test	 ebx, ebx
  000a5	74 41		 je	 SHORT $LN20@getAutoMap

; 2221 : 	// ???????????????????
; 2222 : 	color = getNearestColorIndex(RGB(red / cnt, green / cnt, blue / cnt), Palette, 256);

  000a7	8b 45 fc	 mov	 eax, DWORD PTR _blue$1$[ebp]
  000aa	33 d2		 xor	 edx, edx
  000ac	f7 f3		 div	 ebx
  000ae	33 d2		 xor	 edx, edx
  000b0	0f b6 f0	 movzx	 esi, al
  000b3	8b 45 f8	 mov	 eax, DWORD PTR _green$1$[ebp]
  000b6	f7 f3		 div	 ebx
  000b8	33 d2		 xor	 edx, edx
  000ba	c1 e6 08	 shl	 esi, 8
  000bd	0f b6 c8	 movzx	 ecx, al
  000c0	8b 45 f4	 mov	 eax, DWORD PTR _red$1$[ebp]
  000c3	0b f1		 or	 esi, ecx
  000c5	f7 f3		 div	 ebx
  000c7	68 00 01 00 00	 push	 256			; 00000100H
  000cc	0f b6 c0	 movzx	 eax, al
  000cf	c1 e6 08	 shl	 esi, 8
  000d2	0b f0		 or	 esi, eax
  000d4	68 00 00 00 00	 push	 OFFSET ?Palette@@3PAUtagPALETTEENTRY@@A ; Palette
  000d9	56		 push	 esi
  000da	e8 00 00 00 00	 call	 ?getNearestColorIndex@@YAHKPAUtagPALETTEENTRY@@H@Z ; getNearestColorIndex
  000df	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e2	5e		 pop	 esi

; 2223 : 
; 2224 : 	return color;
; 2225 : }

  000e3	5b		 pop	 ebx
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c3		 ret	 0
$LN20@getAutoMap:
  000e8	5e		 pop	 esi

; 2216 : 			}
; 2217 : 		}
; 2218 : 	}
; 2219 : 
; 2220 : 	if (cnt == 0) return 0;

  000e9	33 c0		 xor	 eax, eax

; 2223 : 
; 2224 : 	return color;
; 2225 : }

  000eb	5b		 pop	 ebx
  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c3		 ret	 0
?getAutoMapColor@@YAHI@Z ENDP				; getAutoMapColor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?DrawAutoMapping@@YAXHHPAEHH@Z
_TEXT	SEGMENT
_pc_color$1$ = -164					; size = 4
_w$GSCopy$1$ = -160					; size = 4
_surfacePitch$1$ = -156					; size = 4
_pc_color$ = -156					; size = 4
_mul$1$ = -152						; size = 4
_i$ = -148						; size = 4
_j$ = -144						; size = 4
_y$GSCopy$1$ = -140					; size = 4
_tmpPtDest2$3$ = -140					; size = 4
_tmpPtDest2$2$ = -140					; size = 4
_tmpPtDest2$1$ = -140					; size = 4
_xx$1$ = -136						; size = 4
_color$ = -136						; size = 4
_tmpPtDest$3$ = -132					; size = 4
_tmpPtDest$2$ = -132					; size = 4
_tmpPtDest$1$ = -132					; size = 4
_yy$1$ = -132						; size = 4
_ddsd$ = -128						; size = 108
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_autoMap$ = 16						; size = 4
_w$ = 20						; size = 4
_h$ = 24						; size = 4
?DrawAutoMapping@@YAXHHPAEHH@Z PROC			; DrawAutoMapping, COMDAT

; 2040 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?DrawAutoMapping@@YAXHHPAEHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b 5d 08	 mov	 ebx, DWORD PTR _x$[ebp]
  00034	8b 75 0c	 mov	 esi, DWORD PTR _y$[ebp]
  00037	89 b5 74 ff ff
	ff		 mov	 DWORD PTR _y$GSCopy$1$[ebp], esi
  0003d	8b 4d 14	 mov	 ecx, DWORD PTR _w$[ebp]
  00040	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _w$GSCopy$1$[ebp], ecx

; 2041 : 	DDSURFACEDESC ddsd;	// ??????
; 2042 : 	char *ptDest;		// ??????
; 2043 : 	char *tmpPtDest;	// ???
; 2044 : 	char *tmpPtDest2;	// ????
; 2045 : 	int surfacePitch;	// ??????????
; 2046 : 	int i, j;			// ???????
; 2047 : 	int color, pc_color;
; 2048 : 	static short pcFlush = 0;
; 2049 : 	static unsigned int pcFlushTime = 0;
; 2050 : 	int xx, yy;
; 2051 : 	int ww, hh;
; 2052 : 	int mul;
; 2053 : 
; 2054 : 	xx = 18;

  00046	c7 85 78 ff ff
	ff 12 00 00 00	 mov	 DWORD PTR _xx$1$[ebp], 18 ; 00000012H

; 2055 : 	yy = 118;

  00050	c7 85 7c ff ff
	ff 76 00 00 00	 mov	 DWORD PTR _yy$1$[ebp], 118 ; 00000076H

; 2056 : 	ww = w;

  0005a	8b f9		 mov	 edi, ecx

; 2057 : 	hh = h;
; 2058 : 	mul = 1;

  0005c	c7 85 68 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _mul$1$[ebp], 1

; 2059 : 
; 2060 : 	try

  00066	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 2061 : 	{
; 2062 : 		//???????????????
; 2063 : 		if (ResoMode == 1)

  0006d	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?ResoMode@@3HA, 1 ; ResoMode
  00074	75 48		 jne	 SHORT $LN21@DrawAutoMa

; 2064 : 		{
; 2065 : 			x = x / 2;

  00076	8b c3		 mov	 eax, ebx
  00078	99		 cdq
  00079	2b c2		 sub	 eax, edx
  0007b	8b d8		 mov	 ebx, eax
  0007d	d1 fb		 sar	 ebx, 1

; 2066 : 			y = y / 2;

  0007f	8b c6		 mov	 eax, esi
  00081	99		 cdq
  00082	2b c2		 sub	 eax, edx
  00084	d1 f8		 sar	 eax, 1
  00086	89 85 74 ff ff
	ff		 mov	 DWORD PTR _y$GSCopy$1$[ebp], eax

; 2067 : 			xx = xx / 2 + 1;

  0008c	c7 85 78 ff ff
	ff 0a 00 00 00	 mov	 DWORD PTR _xx$1$[ebp], 10 ; 0000000aH

; 2068 : 			yy = yy / 2 - 1;

  00096	c7 85 7c ff ff
	ff 3a 00 00 00	 mov	 DWORD PTR _yy$1$[ebp], 58 ; 0000003aH

; 2069 : 			ww = ww / 2;

  000a0	8b c1		 mov	 eax, ecx
  000a2	99		 cdq
  000a3	2b c2		 sub	 eax, edx
  000a5	8b f8		 mov	 edi, eax
  000a7	d1 ff		 sar	 edi, 1

; 2070 : 			hh = hh / 2;

  000a9	8b 45 18	 mov	 eax, DWORD PTR _h$[ebp]
  000ac	99		 cdq
  000ad	2b c2		 sub	 eax, edx
  000af	d1 f8		 sar	 eax, 1
  000b1	89 45 18	 mov	 DWORD PTR _h$[ebp], eax

; 2071 : 			mul = 2;

  000b4	c7 85 68 ff ff
	ff 02 00 00 00	 mov	 DWORD PTR _mul$1$[ebp], 2
$LN21@DrawAutoMa:

; 2072 : 		}
; 2073 : 
; 2074 : 		if (pcFlushTime + 1000 <= TimeGetTime())

  000be	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  000c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pcFlushTime@?1??DrawAutoMapping@@YAXHHPAEHH@Z@4IA
  000c9	81 c1 e8 03 00
	00		 add	 ecx, 1000		; 000003e8H
  000cf	3b c8		 cmp	 ecx, eax
  000d1	77 23		 ja	 SHORT $LN55@DrawAutoMa

; 2075 : 		{
; 2076 : 			pcFlushTime = TimeGetTime();

  000d3	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  000d8	a3 00 00 00 00	 mov	 DWORD PTR ?pcFlushTime@?1??DrawAutoMapping@@YAXHHPAEHH@Z@4IA, eax

; 2077 : 			pcFlush++;

  000dd	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?pcFlush@?1??DrawAutoMapping@@YAXHHPAEHH@Z@4FA
  000e3	66 40		 inc	 ax
  000e5	66 a3 00 00 00
	00		 mov	 WORD PTR ?pcFlush@?1??DrawAutoMapping@@YAXHHPAEHH@Z@4FA, ax

; 2078 : 			pcFlush &= 1;

  000eb	83 e0 01	 and	 eax, 1
  000ee	66 a3 00 00 00
	00		 mov	 WORD PTR ?pcFlush@?1??DrawAutoMapping@@YAXHHPAEHH@Z@4FA, ax

; 2072 : 		}
; 2073 : 
; 2074 : 		if (pcFlushTime + 1000 <= TimeGetTime())

  000f4	eb 06		 jmp	 SHORT $LN22@DrawAutoMa
$LN55@DrawAutoMa:
  000f6	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?pcFlush@?1??DrawAutoMapping@@YAXHHPAEHH@Z@4FA
$LN22@DrawAutoMa:

; 2079 : 		}
; 2080 : 		if (pcFlush) {

  000fc	33 c9		 xor	 ecx, ecx
  000fe	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  00103	66 85 c0	 test	 ax, ax
  00106	0f 45 ca	 cmovne	 ecx, edx
  00109	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _pc_color$1$[ebp], ecx
  0010f	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _pc_color$[ebp], ecx

; 2081 : 			pc_color = 255;
; 2082 : 		}
; 2083 : 		else {
; 2084 : 			pc_color = 0;
; 2085 : 		}
; 2086 : 		// ?????
; 2087 : 		ZeroMemory(&ddsd, sizeof(DDSURFACEDESC));

  00115	6a 6c		 push	 108			; 0000006cH
  00117	6a 00		 push	 0
  00119	8d 45 80	 lea	 eax, DWORD PTR _ddsd$[ebp]
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 _memset
  00122	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2088 : 		ddsd.dwSize = sizeof(DDSURFACEDESC);

  00125	c7 45 80 6c 00
	00 00		 mov	 DWORD PTR _ddsd$[ebp], 108 ; 0000006cH

; 2089 : 
; 2090 : 		// ?????????????????( ?? ddsd ??????? )
; 2091 : 		if (lpDraw->lpBACKBUFFER->Lock(NULL, &ddsd, DDLOCK_WAIT, NULL) != DD_OK)

  0012c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00131	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00134	8b 08		 mov	 ecx, DWORD PTR [eax]
  00136	6a 00		 push	 0
  00138	6a 01		 push	 1
  0013a	8d 55 80	 lea	 edx, DWORD PTR _ddsd$[ebp]
  0013d	52		 push	 edx
  0013e	6a 00		 push	 0
  00140	50		 push	 eax
  00141	ff 51 64	 call	 DWORD PTR [ecx+100]
  00144	85 c0		 test	 eax, eax
  00146	0f 85 87 02 00
	00		 jne	 $LN35@DrawAutoMa

; 2092 : 		{
; 2093 : 			//MessageBoxNew( hWnd, "Surface的lock失败！", "확인", MB_OK | MB_ICONSTOP );
; 2094 : 			return;
; 2095 : 		}
; 2096 : 		// ??????????
; 2097 : 		surfacePitch = ddsd.lPitch;

  0014c	8b 75 90	 mov	 esi, DWORD PTR _ddsd$[ebp+16]
  0014f	89 b5 64 ff ff
	ff		 mov	 DWORD PTR _surfacePitch$1$[ebp], esi

; 2098 : 		// ?????????????
; 2099 : 		ptDest = (char *)(ddsd.lpSurface) + (y + yy) * surfacePitch;

  00155	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _yy$1$[ebp]
  0015b	03 8d 74 ff ff
	ff		 add	 ecx, DWORD PTR _y$GSCopy$1$[ebp]
  00161	0f af ce	 imul	 ecx, esi
  00164	03 4d a4	 add	 ecx, DWORD PTR _ddsd$[ebp+36]

; 2100 : 		if (displayBpp == 8) {

  00167	a1 00 00 00 00	 mov	 eax, DWORD PTR ?displayBpp@@3HA ; displayBpp
  0016c	83 f8 08	 cmp	 eax, 8
  0016f	0f 85 ad 00 00
	00		 jne	 $LN26@DrawAutoMa

; 2101 : 			ptDest += (x + xx);

  00175	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _xx$1$[ebp]
  0017b	03 c3		 add	 eax, ebx
  0017d	03 c8		 add	 ecx, eax

; 2102 : 			tmpPtDest = ptDest;
; 2103 : 			tmpPtDest2 = ptDest;

  0017f	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _tmpPtDest2$1$[ebp], ecx

; 2104 : 			for (i = 0; i < hh; i++) {

  00185	33 db		 xor	 ebx, ebx
$LN58@DrawAutoMa:
  00187	89 9d 6c ff ff
	ff		 mov	 DWORD PTR _i$[ebp], ebx
  0018d	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _tmpPtDest$1$[ebp], ecx
  00193	8b 55 18	 mov	 edx, DWORD PTR _h$[ebp]
  00196	3b da		 cmp	 ebx, edx
  00198	7d 51		 jge	 SHORT $LN3@DrawAutoMa

; 2105 : 				ptDest = tmpPtDest;
; 2106 : 				for (j = 0; j < ww; j++) {

  0019a	33 d2		 xor	 edx, edx
$LN57@DrawAutoMa:
  0019c	89 95 70 ff ff
	ff		 mov	 DWORD PTR _j$[ebp], edx
  001a2	3b d7		 cmp	 edx, edi
  001a4	7d 37		 jge	 SHORT $LN6@DrawAutoMa

; 2107 : 					color = autoMap[(i*mul)*w + (j*mul)];

  001a6	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _w$GSCopy$1$[ebp]
  001ac	0f af c3	 imul	 eax, ebx
  001af	03 c2		 add	 eax, edx
  001b1	0f af 85 68 ff
	ff ff		 imul	 eax, DWORD PTR _mul$1$[ebp]
  001b8	8b 75 10	 mov	 esi, DWORD PTR _autoMap$[ebp]
  001bb	0f b6 04 30	 movzx	 eax, BYTE PTR [eax+esi]
  001bf	89 85 78 ff ff
	ff		 mov	 DWORD PTR _color$[ebp], eax

; 2108 : 					*(ptDest - 1) = color;

  001c5	88 41 ff	 mov	 BYTE PTR [ecx-1], al

; 2109 : 					*(ptDest) = color;

  001c8	88 01		 mov	 BYTE PTR [ecx], al

; 2110 : 					*(ptDest + 1) = color;

  001ca	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 2111 : 					*(ptDest - surfacePitch) = color;

  001cd	8b b5 64 ff ff
	ff		 mov	 esi, DWORD PTR _surfacePitch$1$[ebp]
  001d3	2b ce		 sub	 ecx, esi
  001d5	88 01		 mov	 BYTE PTR [ecx], al

; 2112 : 					ptDest -= (surfacePitch - 2);

  001d7	83 c1 02	 add	 ecx, 2

; 2105 : 				ptDest = tmpPtDest;
; 2106 : 				for (j = 0; j < ww; j++) {

  001da	42		 inc	 edx
  001db	eb bf		 jmp	 SHORT $LN57@DrawAutoMa
$LN6@DrawAutoMa:

; 2113 : 				}
; 2114 : 				tmpPtDest += (surfacePitch + 2);

  001dd	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _tmpPtDest$1$[ebp]
  001e3	83 c1 02	 add	 ecx, 2
  001e6	03 ce		 add	 ecx, esi

; 2104 : 			for (i = 0; i < hh; i++) {

  001e8	43		 inc	 ebx
  001e9	eb 9c		 jmp	 SHORT $LN58@DrawAutoMa
$LN3@DrawAutoMa:

; 2115 : 			}
; 2116 : 			ptDest = tmpPtDest2 + (surfacePitch + 2)*hh / 2 - (surfacePitch - 2)*ww / 2;

  001eb	8d 46 02	 lea	 eax, DWORD PTR [esi+2]
  001ee	0f af c2	 imul	 eax, edx
  001f1	99		 cdq
  001f2	2b c2		 sub	 eax, edx
  001f4	8b c8		 mov	 ecx, eax
  001f6	d1 f9		 sar	 ecx, 1
  001f8	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]
  001fb	0f af c7	 imul	 eax, edi
  001fe	99		 cdq
  001ff	2b c2		 sub	 eax, edx
  00201	d1 f8		 sar	 eax, 1
  00203	2b c8		 sub	 ecx, eax
  00205	03 8d 74 ff ff
	ff		 add	 ecx, DWORD PTR _tmpPtDest2$1$[ebp]

; 2117 : 			// ?????????????????
; 2118 : 			*(ptDest - 1) = pc_color;

  0020b	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _pc_color$1$[ebp]
  00211	88 41 ff	 mov	 BYTE PTR [ecx-1], al

; 2119 : 			*(ptDest) = pc_color;

  00214	88 01		 mov	 BYTE PTR [ecx], al

; 2120 : 			*(ptDest + 1) = pc_color;

  00216	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 2121 : 			*(ptDest - surfacePitch) = pc_color;

  00219	2b ce		 sub	 ecx, esi
  0021b	88 01		 mov	 BYTE PTR [ecx], al

; 2122 : 		}

  0021d	e9 93 01 00 00	 jmp	 $LN30@DrawAutoMa
$LN26@DrawAutoMa:

; 2123 : 		else
; 2124 : #ifdef _HI_COLOR_32
; 2125 : 			if (displayBpp == 32) {

  00222	83 f8 20	 cmp	 eax, 32			; 00000020H
  00225	0f 85 b8 00 00
	00		 jne	 $LN28@DrawAutoMa

; 2126 : 				ptDest += ((x + xx) << 2);

  0022b	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _xx$1$[ebp]
  00231	03 c3		 add	 eax, ebx
  00233	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 2127 : 				tmpPtDest = ptDest;
; 2128 : 				tmpPtDest2 = ptDest;

  00236	89 85 74 ff ff
	ff		 mov	 DWORD PTR _tmpPtDest2$2$[ebp], eax

; 2129 : 				for (i = 0; i < hh; i++) {

  0023c	33 db		 xor	 ebx, ebx
$LN60@DrawAutoMa:
  0023e	89 9d 6c ff ff
	ff		 mov	 DWORD PTR _i$[ebp], ebx
  00244	89 85 7c ff ff
	ff		 mov	 DWORD PTR _tmpPtDest$2$[ebp], eax
  0024a	8b 55 18	 mov	 edx, DWORD PTR _h$[ebp]
  0024d	3b da		 cmp	 ebx, edx
  0024f	7d 5a		 jge	 SHORT $LN9@DrawAutoMa

; 2130 : 					ptDest = tmpPtDest;

  00251	8b c8		 mov	 ecx, eax

; 2131 : 					for (j = 0; j < ww; j++) {

  00253	33 d2		 xor	 edx, edx
$LN59@DrawAutoMa:
  00255	89 95 70 ff ff
	ff		 mov	 DWORD PTR _j$[ebp], edx
  0025b	3b d7		 cmp	 edx, edi
  0025d	7d 3e		 jge	 SHORT $LN12@DrawAutoMa

; 2132 : 						color = highColor32Palette[autoMap[(i*mul)*w + (j*mul)]];

  0025f	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _w$GSCopy$1$[ebp]
  00265	0f af c3	 imul	 eax, ebx
  00268	03 c2		 add	 eax, edx
  0026a	0f af 85 68 ff
	ff ff		 imul	 eax, DWORD PTR _mul$1$[ebp]
  00271	8b 75 10	 mov	 esi, DWORD PTR _autoMap$[ebp]
  00274	0f b6 04 30	 movzx	 eax, BYTE PTR [eax+esi]
  00278	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA[eax*4]
  0027f	89 85 78 ff ff
	ff		 mov	 DWORD PTR _color$[ebp], eax

; 2133 : 						*(int *)(ptDest - 4) = color;

  00285	89 41 fc	 mov	 DWORD PTR [ecx-4], eax

; 2134 : 						*(int *)(ptDest) = color;

  00288	89 01		 mov	 DWORD PTR [ecx], eax

; 2135 : 						*(int *)(ptDest + 4) = color;

  0028a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 2136 : 						*(int *)(ptDest - surfacePitch) = color;

  0028d	8b b5 64 ff ff
	ff		 mov	 esi, DWORD PTR _surfacePitch$1$[ebp]
  00293	2b ce		 sub	 ecx, esi
  00295	89 01		 mov	 DWORD PTR [ecx], eax

; 2137 : 						ptDest -= (surfacePitch - 8);

  00297	83 c1 08	 add	 ecx, 8

; 2131 : 					for (j = 0; j < ww; j++) {

  0029a	42		 inc	 edx
  0029b	eb b8		 jmp	 SHORT $LN59@DrawAutoMa
$LN12@DrawAutoMa:

; 2138 : 					}
; 2139 : 					tmpPtDest += (surfacePitch + 8);

  0029d	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _tmpPtDest$2$[ebp]
  002a3	83 c0 08	 add	 eax, 8
  002a6	03 c6		 add	 eax, esi

; 2129 : 				for (i = 0; i < hh; i++) {

  002a8	43		 inc	 ebx
  002a9	eb 93		 jmp	 SHORT $LN60@DrawAutoMa
$LN9@DrawAutoMa:

; 2140 : 				}
; 2141 : 				ptDest = tmpPtDest2 + (surfacePitch + 4)*hh - (surfacePitch - 4)*ww;

  002ab	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  002ae	0f af ca	 imul	 ecx, edx
  002b1	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  002b4	0f af c7	 imul	 eax, edi
  002b7	2b c8		 sub	 ecx, eax
  002b9	03 8d 74 ff ff
	ff		 add	 ecx, DWORD PTR _tmpPtDest2$2$[ebp]

; 2142 : 				color = highColor32Palette[pc_color];

  002bf	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _pc_color$1$[ebp]
  002c5	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA[eax*4]
  002cc	89 85 78 ff ff
	ff		 mov	 DWORD PTR _color$[ebp], eax

; 2143 : 				// ?????????????????
; 2144 : 				*(int *)(ptDest - 4) = color;

  002d2	89 41 fc	 mov	 DWORD PTR [ecx-4], eax

; 2145 : 				*(int *)(ptDest) = color;

  002d5	89 01		 mov	 DWORD PTR [ecx], eax

; 2146 : 				*(int *)(ptDest + 4) = color;

  002d7	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 2147 : 				*(int *)(ptDest - surfacePitch) = color;

  002da	2b ce		 sub	 ecx, esi
  002dc	89 01		 mov	 DWORD PTR [ecx], eax

; 2148 : 			}

  002de	e9 d2 00 00 00	 jmp	 $LN30@DrawAutoMa
$LN28@DrawAutoMa:

; 2149 : 			else
; 2150 : #endif
; 2151 : 				if (displayBpp == 16) {

  002e3	83 f8 10	 cmp	 eax, 16			; 00000010H
  002e6	0f 85 c9 00 00
	00		 jne	 $LN30@DrawAutoMa

; 2152 : 					ptDest += ((x + xx) << 1);

  002ec	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _xx$1$[ebp]
  002f2	03 c3		 add	 eax, ebx
  002f4	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]

; 2153 : 					tmpPtDest = ptDest;
; 2154 : 					tmpPtDest2 = ptDest;

  002f7	89 85 74 ff ff
	ff		 mov	 DWORD PTR _tmpPtDest2$3$[ebp], eax

; 2155 : 					for (i = 0; i < hh; i++) {

  002fd	33 db		 xor	 ebx, ebx
$LN62@DrawAutoMa:
  002ff	89 9d 6c ff ff
	ff		 mov	 DWORD PTR _i$[ebp], ebx
  00305	89 85 7c ff ff
	ff		 mov	 DWORD PTR _tmpPtDest$3$[ebp], eax
  0030b	8b 4d 18	 mov	 ecx, DWORD PTR _h$[ebp]
  0030e	3b d9		 cmp	 ebx, ecx
  00310	7d 5f		 jge	 SHORT $LN15@DrawAutoMa

; 2156 : 						ptDest = tmpPtDest;

  00312	8b c8		 mov	 ecx, eax

; 2157 : 						for (j = 0; j < ww; j++) {

  00314	33 d2		 xor	 edx, edx
$LN61@DrawAutoMa:
  00316	89 95 70 ff ff
	ff		 mov	 DWORD PTR _j$[ebp], edx
  0031c	3b d7		 cmp	 edx, edi
  0031e	7d 43		 jge	 SHORT $LN18@DrawAutoMa

; 2158 : 							color = highColorPalette[autoMap[(i*mul)*w + (j*mul)]];

  00320	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _w$GSCopy$1$[ebp]
  00326	0f af c3	 imul	 eax, ebx
  00329	03 c2		 add	 eax, edx
  0032b	0f af 85 68 ff
	ff ff		 imul	 eax, DWORD PTR _mul$1$[ebp]
  00332	8b 75 10	 mov	 esi, DWORD PTR _autoMap$[ebp]
  00335	0f b6 04 30	 movzx	 eax, BYTE PTR [eax+esi]
  00339	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA[eax*2]
  00341	89 85 78 ff ff
	ff		 mov	 DWORD PTR _color$[ebp], eax

; 2159 : 							*(short*)(ptDest - 2) = color;

  00347	66 89 41 fe	 mov	 WORD PTR [ecx-2], ax

; 2160 : 							*(short*)(ptDest) = color;

  0034b	66 89 01	 mov	 WORD PTR [ecx], ax

; 2161 : 							*(short*)(ptDest + 2) = color;

  0034e	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 2162 : 							*(short*)(ptDest - surfacePitch) = color;

  00352	8b b5 64 ff ff
	ff		 mov	 esi, DWORD PTR _surfacePitch$1$[ebp]
  00358	2b ce		 sub	 ecx, esi
  0035a	66 89 01	 mov	 WORD PTR [ecx], ax

; 2163 : 							ptDest -= (surfacePitch - 4);

  0035d	83 c1 04	 add	 ecx, 4

; 2157 : 						for (j = 0; j < ww; j++) {

  00360	42		 inc	 edx
  00361	eb b3		 jmp	 SHORT $LN61@DrawAutoMa
$LN18@DrawAutoMa:

; 2164 : 						}
; 2165 : 						tmpPtDest += (surfacePitch + 4);

  00363	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _tmpPtDest$3$[ebp]
  00369	83 c0 04	 add	 eax, 4
  0036c	03 c6		 add	 eax, esi

; 2155 : 					for (i = 0; i < hh; i++) {

  0036e	43		 inc	 ebx
  0036f	eb 8e		 jmp	 SHORT $LN62@DrawAutoMa
$LN15@DrawAutoMa:

; 2166 : 					}
; 2167 : 					ptDest = tmpPtDest2 + (surfacePitch + 4)*hh / 2 - (surfacePitch - 4)*ww / 2;

  00371	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00374	0f af c1	 imul	 eax, ecx
  00377	99		 cdq
  00378	2b c2		 sub	 eax, edx
  0037a	8b c8		 mov	 ecx, eax
  0037c	d1 f9		 sar	 ecx, 1
  0037e	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  00381	0f af c7	 imul	 eax, edi
  00384	99		 cdq
  00385	2b c2		 sub	 eax, edx
  00387	d1 f8		 sar	 eax, 1
  00389	2b c8		 sub	 ecx, eax
  0038b	03 8d 74 ff ff
	ff		 add	 ecx, DWORD PTR _tmpPtDest2$3$[ebp]

; 2168 : 					color = highColorPalette[pc_color];

  00391	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _pc_color$1$[ebp]
  00397	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA[eax*2]
  0039f	89 85 78 ff ff
	ff		 mov	 DWORD PTR _color$[ebp], eax

; 2169 : 					// ?????????????????
; 2170 : 					*(short*)(ptDest - 2) = color;

  003a5	66 89 41 fe	 mov	 WORD PTR [ecx-2], ax

; 2171 : 					*(short*)(ptDest) = color;

  003a9	66 89 01	 mov	 WORD PTR [ecx], ax

; 2172 : 					*(short*)(ptDest + 2) = color;

  003ac	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 2173 : 					*(short*)(ptDest - surfacePitch) = color;

  003b0	2b ce		 sub	 ecx, esi
  003b2	66 89 01	 mov	 WORD PTR [ecx], ax
$LN30@DrawAutoMa:

; 2174 : 				}
; 2175 : 
; 2176 : 		// ???????????????????
; 2177 : 		if (lpDraw->lpBACKBUFFER->Unlock(NULL) != DD_OK)

  003b5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  003ba	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  003bd	8b 08		 mov	 ecx, DWORD PTR [eax]
  003bf	6a 00		 push	 0
  003c1	50		 push	 eax
  003c2	ff 91 80 00 00
	00		 call	 DWORD PTR [ecx+128]
  003c8	85 c0		 test	 eax, eax
  003ca	75 07		 jne	 SHORT $LN35@DrawAutoMa
$LN36@DrawAutoMa:

; 2188 : 
; 2189 : 
; 2190 : 	return;
; 2191 : }

  003cc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN35@DrawAutoMa:
  003d3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  003d6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003dd	59		 pop	 ecx
  003de	5f		 pop	 edi
  003df	5e		 pop	 esi
  003e0	5b		 pop	 ebx
  003e1	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003e4	33 cd		 xor	 ecx, ebp
  003e6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003eb	8b e5		 mov	 esp, ebp
  003ed	5d		 pop	 ebp
  003ee	c3		 ret	 0
__catch$?DrawAutoMapping@@YAXHHPAEHH@Z$0:

; 2178 : 		{
; 2179 : 			//MessageBoxNew( hWnd, "Surface的Unlock失败！", "확인", MB_OK | MB_ICONSTOP );
; 2180 : 			return;
; 2181 : 		}
; 2182 : 
; 2183 : 	}
; 2184 : 	catch (...)
; 2185 : 	{
; 2186 : 
; 2187 : 	}

  003ef	b8 00 00 00 00	 mov	 eax, $LN36@DrawAutoMa
  003f4	c3		 ret	 0
  003f5	cc		 int	 3
  003f6	cc		 int	 3
  003f7	cc		 int	 3
  003f8	cc		 int	 3
  003f9	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?DrawAutoMapping@@YAXHHPAEHH@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 58 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-168]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?DrawAutoMapping@@YAXHHPAEHH@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?DrawAutoMapping@@YAXHHPAEHH@Z ENDP			; DrawAutoMapping
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?PaletteChange@@YAXHH@Z
_TEXT	SEGMENT
_palNo$ = 8						; size = 4
_time$ = 12						; size = 4
?PaletteChange@@YAXHH@Z PROC				; PaletteChange, COMDAT

; 521  : 	static bool bChanged = false;
; 522  : 	if (bChanged) return;

  00000	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?bChanged@?1??PaletteChange@@YAXHH@Z@4_NA, 0
  00007	75 1b		 jne	 SHORT $LN4@PaletteCha

; 523  : 
; 524  : #ifdef 画面色盘锁定白天
; 525  : 	palNo = LS_NOON;  //锁定中午颜色最好看
; 526  : 	time = 0;
; 527  : #endif 
; 528  : 
; 529  : 	bChanged = true;

  00009	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?bChanged@?1??PaletteChange@@YAXHH@Z@4_NA, 1

; 530  : 	if( palNo >= MAX_PAL )
; 531  : 		return;
; 532  : 	PalState.palNo = palNo;

  00010	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?PalState@@3UPALETTE_STATE@@A, 0

; 533  : 	PalState.time = time;
; 534  : 	if( PalState.time <= 0 )
; 535  : 		PalState.time = 1;

  0001a	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?PalState@@3UPALETTE_STATE@@A+4, 1
$LN4@PaletteCha:

; 536  : }

  00024	c3		 ret	 0
?PaletteChange@@YAXHH@Z ENDP				; PaletteChange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?PaletteProc@@YAXXZ
_TEXT	SEGMENT
_fp$1$ = -4						; size = 4
?PaletteProc@@YAXXZ PROC				; PaletteProc, COMDAT

; 540  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 541  : 	FILE *fp; // ????????
; 542  : 	static PALETTEENTRY	pal[256];	// ?????
; 543  : 	static float	dRed[256];		// ?????
; 544  : 	static float	dGreen[256];	// ?????
; 545  : 	static float	dBlue[256];		// ?????
; 546  : 	static float	dRedBak[256];	// ?????
; 547  : 	static float	dGreenBak[256];	// ?????
; 548  : 	static float	dBlueBak[256];	// ?????
; 549  : 	static int 	timeCnt;			// ????????
; 550  : 	static int 	changeCnt;			// ?????????
; 551  : 	static int 	palNoBak = 0;		// ?????
; 552  : 	static int 	openFlag = FALSE;	// ???????????
; 553  : 	int i;
; 554  : 	// ????????????
; 555  : 	if (palNoBak == PalState.palNo && openFlag == FALSE)

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PalState@@3UPALETTE_STATE@@A
  00009	56		 push	 esi
  0000a	39 05 00 00 00
	00		 cmp	 DWORD PTR ?palNoBak@?1??PaletteProc@@YAXXZ@4HA, eax
  00010	75 1f		 jne	 SHORT $LN39@PalettePro
  00012	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?openFlag@?1??PaletteProc@@YAXXZ@4HA
  00018	85 d2		 test	 edx, edx
  0001a	0f 84 91 02 00
	00		 je	 $LN23@PalettePro

; 556  : 		return;
; 557  : 	// ???????????
; 558  : 	if (palNoBak != PalState.palNo) {

  00020	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?timeCnt@?1??PaletteProc@@YAXXZ@4HA
  00026	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?changeCnt@?1??PaletteProc@@YAXXZ@4HA
  0002c	e9 47 01 00 00	 jmp	 $LN12@PalettePro
$LN39@PalettePro:
  00031	53		 push	 ebx
  00032	57		 push	 edi

; 559  : 		// ????????????
; 560  : 		fp = fopen(palFileName[PalState.palNo], "rb");

  00033	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  00038	ff 34 85 00 00
	00 00		 push	 DWORD PTR ?palFileName@@3PAPADA[eax*4]
  0003f	e8 00 00 00 00	 call	 _fopen
  00044	8b d8		 mov	 ebx, eax
  00046	83 c4 08	 add	 esp, 8
  00049	89 5d fc	 mov	 DWORD PTR _fp$1$[ebp], ebx
  0004c	bf 10 00 00 00	 mov	 edi, 16			; 00000010H
$LL4@PalettePro:

; 561  : 		// ??????????
; 562  : 		for (i = 16; i < 240; i++) {
; 563  : 			pal[i].peBlue = fgetc(fp);

  00051	53		 push	 ebx
  00052	e8 00 00 00 00	 call	 _fgetc

; 564  : 			pal[i].peGreen = fgetc(fp);

  00057	53		 push	 ebx
  00058	88 04 bd 02 00
	00 00		 mov	 BYTE PTR ?pal@?1??PaletteProc@@YAXXZ@4PAUtagPALETTEENTRY@@A[edi*4+2], al
  0005f	e8 00 00 00 00	 call	 _fgetc

; 565  : 			pal[i].peRed = fgetc(fp);

  00064	53		 push	 ebx
  00065	88 04 bd 01 00
	00 00		 mov	 BYTE PTR ?pal@?1??PaletteProc@@YAXXZ@4PAUtagPALETTEENTRY@@A[edi*4+1], al
  0006c	e8 00 00 00 00	 call	 _fgetc
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH
  00074	8a d8		 mov	 bl, al
  00076	88 1c bd 00 00
	00 00		 mov	 BYTE PTR ?pal@?1??PaletteProc@@YAXXZ@4PAUtagPALETTEENTRY@@A[edi*4], bl

; 566  : 			// 168??( 0, 0, 0 )??
; 567  : 			if (i == 168) {

  0007d	81 ff a8 00 00
	00		 cmp	 edi, 168		; 000000a8H
  00083	75 17		 jne	 SHORT $LN13@PalettePro

; 568  : 				pal[168].peBlue = 0;
; 569  : 				pal[168].peGreen = 0;

  00085	66 c7 05 a1 02
	00 00 00 00	 mov	 WORD PTR ?pal@?1??PaletteProc@@YAXXZ@4PAUtagPALETTEENTRY@@A+673, 0

; 570  : 				pal[168].peRed = 0;

  0008e	c6 05 a0 02 00
	00 00		 mov	 BYTE PTR ?pal@?1??PaletteProc@@YAXXZ@4PAUtagPALETTEENTRY@@A+672, 0
  00095	8a 1c bd 00 00
	00 00		 mov	 bl, BYTE PTR ?pal@?1??PaletteProc@@YAXXZ@4PAUtagPALETTEENTRY@@A[edi*4]
$LN13@PalettePro:

; 571  : 			}
; 572  : 			// ?????
; 573  : 			dBlueBak[i] = Palette[i].peBlue;

  0009c	0f b6 0c bd 02
	00 00 00	 movzx	 ecx, BYTE PTR ?Palette@@3PAUtagPALETTEENTRY@@A[edi*4+2]

; 574  : 			dGreenBak[i] = Palette[i].peGreen;

  000a4	0f b6 14 bd 01
	00 00 00	 movzx	 edx, BYTE PTR ?Palette@@3PAUtagPALETTEENTRY@@A[edi*4+1]

; 575  : 			dRedBak[i] = Palette[i].peRed;

  000ac	0f b6 34 bd 00
	00 00 00	 movzx	 esi, BYTE PTR ?Palette@@3PAUtagPALETTEENTRY@@A[edi*4]

; 576  : 			// ??
; 577  : 			dBlue[i] = (float)(pal[i].peBlue - Palette[i].peBlue) / (float)PalState.time;

  000b4	0f b6 04 bd 02
	00 00 00	 movzx	 eax, BYTE PTR ?pal@?1??PaletteProc@@YAXXZ@4PAUtagPALETTEENTRY@@A[edi*4+2]
  000bc	66 0f 6e 0d 04
	00 00 00	 movd	 xmm1, DWORD PTR ?PalState@@3UPALETTE_STATE@@A+4
  000c4	2b c1		 sub	 eax, ecx
  000c6	66 0f 6e c1	 movd	 xmm0, ecx
  000ca	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000cd	0f 5b c9	 cvtdq2ps xmm1, xmm1
  000d0	f3 0f 11 04 bd
	00 00 00 00	 movss	 DWORD PTR ?dBlueBak@?1??PaletteProc@@YAXXZ@4PAMA[edi*4], xmm0
  000d9	66 0f 6e c2	 movd	 xmm0, edx
  000dd	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000e0	f3 0f 11 04 bd
	00 00 00 00	 movss	 DWORD PTR ?dGreenBak@?1??PaletteProc@@YAXXZ@4PAMA[edi*4], xmm0
  000e9	66 0f 6e c6	 movd	 xmm0, esi
  000ed	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000f0	f3 0f 11 04 bd
	00 00 00 00	 movss	 DWORD PTR ?dRedBak@?1??PaletteProc@@YAXXZ@4PAMA[edi*4], xmm0
  000f9	66 0f 6e c0	 movd	 xmm0, eax
  000fd	0f 5b c0	 cvtdq2ps xmm0, xmm0

; 578  : 			dGreen[i] = (float)(pal[i].peGreen - Palette[i].peGreen) / (float)PalState.time;

  00100	0f b6 04 bd 01
	00 00 00	 movzx	 eax, BYTE PTR ?pal@?1??PaletteProc@@YAXXZ@4PAUtagPALETTEENTRY@@A[edi*4+1]
  00108	2b c2		 sub	 eax, edx
  0010a	f3 0f 5e c1	 divss	 xmm0, xmm1
  0010e	f3 0f 11 04 bd
	00 00 00 00	 movss	 DWORD PTR ?dBlue@?1??PaletteProc@@YAXXZ@4PAMA[edi*4], xmm0
  00117	66 0f 6e c0	 movd	 xmm0, eax
  0011b	0f 5b c0	 cvtdq2ps xmm0, xmm0

; 579  : 			dRed[i] = (float)(pal[i].peRed - Palette[i].peRed) / (float)PalState.time;

  0011e	0f b6 c3	 movzx	 eax, bl
  00121	2b c6		 sub	 eax, esi
  00123	8b 5d fc	 mov	 ebx, DWORD PTR _fp$1$[ebp]
  00126	f3 0f 5e c1	 divss	 xmm0, xmm1
  0012a	f3 0f 11 04 bd
	00 00 00 00	 movss	 DWORD PTR ?dGreen@?1??PaletteProc@@YAXXZ@4PAMA[edi*4], xmm0
  00133	66 0f 6e c0	 movd	 xmm0, eax
  00137	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0013a	f3 0f 5e c1	 divss	 xmm0, xmm1
  0013e	f3 0f 11 04 bd
	00 00 00 00	 movss	 DWORD PTR ?dRed@?1??PaletteProc@@YAXXZ@4PAMA[edi*4], xmm0
  00147	47		 inc	 edi
  00148	81 ff f0 00 00
	00		 cmp	 edi, 240		; 000000f0H
  0014e	0f 8c fd fe ff
	ff		 jl	 $LL4@PalettePro

; 580  : #if 0
; 581  : 			// ??????????
; 582  : 			if (WindowMode) {
; 583  : 				Palette[i].peFlags = PC_NOCOLLAPSE | PC_RESERVED;
; 584  : 			}
; 585  : 			else {
; 586  : 				Palette[i].peFlags = PC_EXPLICIT;
; 587  : 			}
; 588  : #endif
; 589  : 		}
; 590  : 		fclose(fp);				// ??????

  00154	53		 push	 ebx
  00155	e8 00 00 00 00	 call	 _fclose

; 591  : 		timeCnt = 0;				// ????????????????????
; 592  : 		changeCnt = 0;				// ????????????????????;
; 593  : 		palNoBak = PalState.palNo;	// ??????

  0015a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PalState@@3UPALETTE_STATE@@A
  0015f	83 c4 04	 add	 esp, 4

; 594  : 		openFlag = TRUE;			// ?????

  00162	ba 01 00 00 00	 mov	 edx, 1
  00167	a3 00 00 00 00	 mov	 DWORD PTR ?palNoBak@?1??PaletteProc@@YAXXZ@4HA, eax
  0016c	33 c9		 xor	 ecx, ecx
  0016e	89 15 00 00 00
	00		 mov	 DWORD PTR ?openFlag@?1??PaletteProc@@YAXXZ@4HA, edx
  00174	33 f6		 xor	 esi, esi
  00176	5f		 pop	 edi
  00177	5b		 pop	 ebx
$LN12@PalettePro:

; 595  : 	}
; 596  : 	// ?????
; 597  : 	timeCnt++;

  00178	41		 inc	 ecx
  00179	89 0d 00 00 00
	00		 mov	 DWORD PTR ?timeCnt@?1??PaletteProc@@YAXXZ@4HA, ecx
  0017f	3b 0d 04 00 00
	00		 cmp	 ecx, DWORD PTR ?PalState@@3UPALETTE_STATE@@A+4

; 598  : 	// ????
; 599  : 	if (timeCnt <= PalState.time) {

  00185	0f 8f 78 00 00
	00		 jg	 $LN14@PalettePro

; 600  : 		// ??????????
; 601  : 		for (i = 16; i < 240; i++) {

  0018b	33 c9		 xor	 ecx, ecx
  0018d	0f 1f 00	 npad	 3
$LL31@PalettePro:

; 602  : 			// ?????
; 603  : 			dBlueBak[i] += dBlue[i];

  00190	f3 0f 10 91 40
	00 00 00	 movss	 xmm2, DWORD PTR ?dBlue@?1??PaletteProc@@YAXXZ@4PAMA[ecx+64]
  00198	f3 0f 58 91 40
	00 00 00	 addss	 xmm2, DWORD PTR ?dBlueBak@?1??PaletteProc@@YAXXZ@4PAMA[ecx+64]

; 604  : 			dGreenBak[i] += dGreen[i];

  001a0	f3 0f 10 89 40
	00 00 00	 movss	 xmm1, DWORD PTR ?dGreen@?1??PaletteProc@@YAXXZ@4PAMA[ecx+64]
  001a8	f3 0f 58 89 40
	00 00 00	 addss	 xmm1, DWORD PTR ?dGreenBak@?1??PaletteProc@@YAXXZ@4PAMA[ecx+64]

; 605  : 			dRedBak[i] += dRed[i];

  001b0	f3 0f 10 81 40
	00 00 00	 movss	 xmm0, DWORD PTR ?dRed@?1??PaletteProc@@YAXXZ@4PAMA[ecx+64]
  001b8	f3 0f 58 81 40
	00 00 00	 addss	 xmm0, DWORD PTR ?dRedBak@?1??PaletteProc@@YAXXZ@4PAMA[ecx+64]

; 606  : 			// ?????
; 607  : 			Palette[i].peBlue = (BYTE)dBlueBak[i];

  001c0	f3 0f 2c c2	 cvttss2si eax, xmm2
  001c4	f3 0f 11 91 40
	00 00 00	 movss	 DWORD PTR ?dBlueBak@?1??PaletteProc@@YAXXZ@4PAMA[ecx+64], xmm2
  001cc	88 81 42 00 00
	00		 mov	 BYTE PTR ?Palette@@3PAUtagPALETTEENTRY@@A[ecx+66], al

; 608  : 			Palette[i].peGreen = (BYTE)dGreenBak[i];

  001d2	f3 0f 2c c1	 cvttss2si eax, xmm1
  001d6	f3 0f 11 89 40
	00 00 00	 movss	 DWORD PTR ?dGreenBak@?1??PaletteProc@@YAXXZ@4PAMA[ecx+64], xmm1
  001de	88 81 41 00 00
	00		 mov	 BYTE PTR ?Palette@@3PAUtagPALETTEENTRY@@A[ecx+65], al

; 609  : 			Palette[i].peRed = (BYTE)dRedBak[i];

  001e4	f3 0f 2c c0	 cvttss2si eax, xmm0
  001e8	f3 0f 11 81 40
	00 00 00	 movss	 DWORD PTR ?dRedBak@?1??PaletteProc@@YAXXZ@4PAMA[ecx+64], xmm0
  001f0	88 81 40 00 00
	00		 mov	 BYTE PTR ?Palette@@3PAUtagPALETTEENTRY@@A[ecx+64], al
  001f6	83 c1 04	 add	 ecx, 4
  001f9	81 f9 80 03 00
	00		 cmp	 ecx, 896		; 00000380H
  001ff	7c 8f		 jl	 SHORT $LL31@PalettePro

; 610  : 		}
; 611  : 	}

  00201	eb 51		 jmp	 SHORT $LN15@PalettePro
$LN14@PalettePro:

; 612  : 	else {
; 613  : 		// ????????????????????
; 614  : 		// ??????????
; 615  : 		for (i = 16; i < 240; i++) {

  00203	33 c9		 xor	 ecx, ecx
  00205	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL10@PalettePro:

; 616  : 			Palette[i].peBlue = pal[i].peBlue;

  00210	0f b6 81 42 00
	00 00		 movzx	 eax, BYTE PTR ?pal@?1??PaletteProc@@YAXXZ@4PAUtagPALETTEENTRY@@A[ecx+66]
  00217	88 81 42 00 00
	00		 mov	 BYTE PTR ?Palette@@3PAUtagPALETTEENTRY@@A[ecx+66], al

; 617  : 			Palette[i].peGreen = pal[i].peGreen;

  0021d	0f b6 81 41 00
	00 00		 movzx	 eax, BYTE PTR ?pal@?1??PaletteProc@@YAXXZ@4PAUtagPALETTEENTRY@@A[ecx+65]
  00224	88 81 41 00 00
	00		 mov	 BYTE PTR ?Palette@@3PAUtagPALETTEENTRY@@A[ecx+65], al

; 618  : 			Palette[i].peRed = pal[i].peRed;

  0022a	0f b6 81 40 00
	00 00		 movzx	 eax, BYTE PTR ?pal@?1??PaletteProc@@YAXXZ@4PAUtagPALETTEENTRY@@A[ecx+64]
  00231	88 81 40 00 00
	00		 mov	 BYTE PTR ?Palette@@3PAUtagPALETTEENTRY@@A[ecx+64], al
  00237	83 c1 04	 add	 ecx, 4
  0023a	81 f9 80 03 00
	00		 cmp	 ecx, 896		; 00000380H
  00240	7c ce		 jl	 SHORT $LL10@PalettePro

; 619  : 		}
; 620  : 		openFlag = FALSE;	// ??????

  00242	33 d2		 xor	 edx, edx

; 621  : 		transEffectPaletteStatus = 2;

  00244	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?transEffectPaletteStatus@@3HA, 2 ; transEffectPaletteStatus
  0024e	89 15 00 00 00
	00		 mov	 DWORD PTR ?openFlag@?1??PaletteProc@@YAXXZ@4HA, edx
$LN15@PalettePro:

; 622  : 	}
; 623  : 	// ??????????????????
; 624  : 	if (changeCnt == 0 || openFlag == FALSE) {

  00254	85 f6		 test	 esi, esi
  00256	74 04		 je	 SHORT $LN17@PalettePro
  00258	85 d2		 test	 edx, edx
  0025a	75 0a		 jne	 SHORT $LN16@PalettePro
$LN17@PalettePro:

; 625  : 		// ?????????????
; 626  : 		PalChangeFlag = TRUE;

  0025c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?PalChangeFlag@@3HA, 1 ; PalChangeFlag
$LN16@PalettePro:

; 627  : 		// ????????
; 628  : 		//lpDraw->lpPALETTE->SetEntries( 0, 0, 256, Palette );
; 629  : 	}
; 630  : 	// ????????
; 631  : 	changeCnt++;
; 632  : 	// ??????????
; 633  : 	if (transmigrationEffectFlag)

  00266	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?transmigrationEffectFlag@@3HA, 0 ; transmigrationEffectFlag
  0026d	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00270	a3 00 00 00 00	 mov	 DWORD PTR ?changeCnt@?1??PaletteProc@@YAXXZ@4HA, eax
  00275	8b c8		 mov	 ecx, eax
  00277	74 0e		 je	 SHORT $LN19@PalettePro

; 634  : 	{
; 635  : 		// ??????
; 636  : 		if (changeCnt >= 10) changeCnt = 0;

  00279	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0027c	7c 09		 jl	 SHORT $LN19@PalettePro
  0027e	33 c0		 xor	 eax, eax
  00280	33 c9		 xor	 ecx, ecx
  00282	a3 00 00 00 00	 mov	 DWORD PTR ?changeCnt@?1??PaletteProc@@YAXXZ@4HA, eax
$LN19@PalettePro:

; 637  : 	}
; 638  : 	if (WindowMode) {

  00287	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?WindowMode@@3HA, 0 ; WindowMode
  0028e	74 14		 je	 SHORT $LN20@PalettePro

; 639  : 		if (changeCnt >= PAL_CHANGE_INTERVAL_WIN)

  00290	83 f9 78	 cmp	 ecx, 120		; 00000078H
  00293	7c 1c		 jl	 SHORT $LN23@PalettePro

; 640  : 			changeCnt = 0;

  00295	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?changeCnt@?1??PaletteProc@@YAXXZ@4HA, 0
  0029f	5e		 pop	 esi

; 644  : 			changeCnt = 0;
; 645  : 	}
; 646  : }

  002a0	8b e5		 mov	 esp, ebp
  002a2	5d		 pop	 ebp
  002a3	c3		 ret	 0
$LN20@PalettePro:

; 641  : 	}
; 642  : 	else {
; 643  : 		if (changeCnt >= PAL_CHANGE_INTERVAL_FULL)

  002a4	33 d2		 xor	 edx, edx
  002a6	83 f9 3c	 cmp	 ecx, 60			; 0000003cH
  002a9	0f 4d c2	 cmovge	 eax, edx
  002ac	a3 00 00 00 00	 mov	 DWORD PTR ?changeCnt@?1??PaletteProc@@YAXXZ@4HA, eax
$LN23@PalettePro:
  002b1	5e		 pop	 esi

; 644  : 			changeCnt = 0;
; 645  : 	}
; 646  : }

  002b2	8b e5		 mov	 esp, ebp
  002b4	5d		 pop	 ebp
  002b5	c3		 ret	 0
?PaletteProc@@YAXXZ ENDP				; PaletteProc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?PutText@@YAXD@Z
_TEXT	SEGMENT
_hOldFont$1$ = -44					; size = 4
tv662 = -40						; size = 4
tv654 = -40						; size = 4
tv651 = -40						; size = 4
_colorFlag$2 = -36					; size = 4
_i$3 = -32						; size = 4
_color$4 = -28						; size = 4
_hDc$5 = -24						; size = 4
tv676 = -17						; size = 1
__$EHRec$ = -16						; size = 16
_fontPrio$ = 8						; size = 1
?PutText@@YAXD@Z PROC					; PutText, COMDAT

; 3186 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?PutText@@YAXD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 3187 : 
; 3188 : 	try

  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 3189 : 	{
; 3190 : 		HDC  hDc;
; 3191 : #ifdef _READ16BITBMP
; 3192 : 		HDC  hDcSys;
; 3193 : #endif
; 3194 : 		int i;
; 3195 : 		BOOL colorFlag = FALSE;

  00032	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _colorFlag$2[ebp], 0

; 3196 : 		int	color;
; 3197 : 		if (FontCnt == 0) return;

  00039	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?FontCnt@@3HA, 0 ; FontCnt
  00040	0f 84 15 03 00
	00		 je	 $LN44@PutText

; 3198 : 
; 3199 : 		// JL fix 2018/7/7 
; 3200 : 		if (lpDraw == NULL) return;

  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0004b	85 c0		 test	 eax, eax
  0004d	0f 84 08 03 00
	00		 je	 $LN44@PutText

; 3201 : 		if (lpDraw->lpBACKBUFFER == NULL) return;

  00053	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00056	85 c9		 test	 ecx, ecx
  00058	0f 84 fd 02 00
	00		 je	 $LN44@PutText

; 3202 : 
; 3203 : 		lpDraw->lpBACKBUFFER->GetDC(&hDc);

  0005e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00060	8d 55 e8	 lea	 edx, DWORD PTR _hDc$5[ebp]
  00063	52		 push	 edx
  00064	51		 push	 ecx
  00065	ff 50 44	 call	 DWORD PTR [eax+68]

; 3204 : #ifdef _READ16BITBMP
; 3205 : 		if (g_bUseAlpha) lpDraw->lpBACKBUFFERSYS->GetDC(&hDcSys);
; 3206 : #endif
; 3207 : 		SetBkMode(hDc, TRANSPARENT);

  00068	6a 01		 push	 1
  0006a	ff 75 e8	 push	 DWORD PTR _hDc$5[ebp]
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkMode@8

; 3208 : #ifdef _READ16BITBMP
; 3209 : 		if (g_bUseAlpha) SetBkMode(hDcSys, TRANSPARENT);
; 3210 : #endif
; 3211 : 		HFONT hOldFont = (HFONT)SelectObject(hDc, hFont);

  00073	ff 35 00 00 00
	00		 push	 DWORD PTR ?hFont@@3PAUHFONT__@@A ; hFont
  00079	ff 75 e8	 push	 DWORD PTR _hDc$5[ebp]
  0007c	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__SelectObject@8
  00082	ff d3		 call	 ebx
  00084	89 45 d4	 mov	 DWORD PTR _hOldFont$1$[ebp], eax

; 3212 : #ifdef _READ16BITBMP
; 3213 : 		if (g_bUseAlpha) SelectObject(hDcSys, hFont);
; 3214 : #endif
; 3215 : 		SetTextColor(hDc, 0);

  00087	6a 00		 push	 0
  00089	ff 75 e8	 push	 DWORD PTR _hDc$5[ebp]
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTextColor@8

; 3216 : #ifdef _READ16BITBMP
; 3217 : 		if (g_bUseAlpha) SetTextColor(hDcSys, 0);
; 3218 : #endif
; 3219 : 		for (i = 0; i < FontCnt; i++) {

  00092	33 ff		 xor	 edi, edi
  00094	89 7d e0	 mov	 DWORD PTR _i$3[ebp], edi
  00097	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?newFont@?BD@??PutText@@YAXD@Z@4PAUHFONT__@@A
  0009d	0f 1f 00	 npad	 3
$LL4@PutText:
  000a0	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?FontCnt@@3HA ; FontCnt
  000a6	0f 8d 24 01 00
	00		 jge	 $LN3@PutText

; 3220 : 			if (FontBuffer[i].fontPrio == fontPrio) {

  000ac	69 f7 10 01 00
	00		 imul	 esi, edi, 272
  000b2	0f b6 8e 05 01
	00 00		 movzx	 ecx, BYTE PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[esi+261]
  000b9	0f be 45 08	 movsx	 eax, BYTE PTR _fontPrio$[ebp]
  000bd	3b c8		 cmp	 ecx, eax
  000bf	0f 85 02 01 00
	00		 jne	 $LN59@PutText

; 3221 : 				if (ResoMode == 1) {

  000c5	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?ResoMode@@3HA, 1 ; ResoMode
  000cc	75 4f		 jne	 SHORT $LN16@PutText

; 3222 : 					TextOut(hDc, FontBuffer[i].x / 2 + 1, FontBuffer[i].y / 2 + 1, FontBuffer[i].str, (int)strlen(FontBuffer[i].str));

  000ce	8d 96 05 00 00
	00		 lea	 edx, DWORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[esi+5]
  000d4	8b ca		 mov	 ecx, edx
  000d6	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  000d9	89 45 d8	 mov	 DWORD PTR tv651[ebp], eax
  000dc	0f 1f 40 00	 npad	 4
$LL55@PutText:
  000e0	8a 01		 mov	 al, BYTE PTR [ecx]
  000e2	41		 inc	 ecx
  000e3	84 c0		 test	 al, al
  000e5	75 f9		 jne	 SHORT $LL55@PutText
  000e7	2b 4d d8	 sub	 ecx, DWORD PTR tv651[ebp]
  000ea	51		 push	 ecx
  000eb	52		 push	 edx
  000ec	0f bf 86 02 00
	00 00		 movsx	 eax, WORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[esi+2]
  000f3	99		 cdq
  000f4	2b c2		 sub	 eax, edx
  000f6	d1 f8		 sar	 eax, 1
  000f8	40		 inc	 eax
  000f9	50		 push	 eax
  000fa	0f bf 86 00 00
	00 00		 movsx	 eax, WORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[esi]
  00101	99		 cdq
  00102	2b c2		 sub	 eax, edx
  00104	d1 f8		 sar	 eax, 1
  00106	40		 inc	 eax
  00107	50		 push	 eax
  00108	ff 75 e8	 push	 DWORD PTR _hDc$5[ebp]
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TextOutA@20

; 3216 : #ifdef _READ16BITBMP
; 3217 : 		if (g_bUseAlpha) SetTextColor(hDcSys, 0);
; 3218 : #endif
; 3219 : 		for (i = 0; i < FontCnt; i++) {

  00111	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?newFont@?BD@??PutText@@YAXD@Z@4PAUHFONT__@@A
  00117	47		 inc	 edi
  00118	89 7d e0	 mov	 DWORD PTR _i$3[ebp], edi
  0011b	eb 83		 jmp	 SHORT $LL4@PutText
$LN16@PutText:

; 3223 : 				}
; 3224 : 				else {
; 3225 : #ifdef _FONT_SIZE
; 3226 : 					static HFONT newFont = NULL;
; 3227 : 					static HFONT oldFont = NULL;
; 3228 : 					if (newFont != NULL) {

  0011d	85 d2		 test	 edx, edx
  0011f	74 07		 je	 SHORT $LN18@PutText

; 3229 : 						DeleteObject(newFont);

  00121	52		 push	 edx
  00122	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
$LN18@PutText:

; 3230 : 					}
; 3231 : 					if (FontBuffer[i].size <= 0)

  00128	8b 86 0c 01 00
	00		 mov	 eax, DWORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[esi+268]
  0012e	85 c0		 test	 eax, eax
  00130	7f 0d		 jg	 SHORT $LN19@PutText

; 3232 : 						SelectObject(hDc, hFont);

  00132	ff 35 00 00 00
	00		 push	 DWORD PTR ?hFont@@3PAUHFONT__@@A ; hFont
  00138	ff 75 e8	 push	 DWORD PTR _hDc$5[ebp]
  0013b	ff d3		 call	 ebx
  0013d	eb 1d		 jmp	 SHORT $LN21@PutText
$LN19@PutText:

; 3233 : 					else {
; 3234 : 						newFont = CreateNewFont(FontBuffer[i].size);

  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 ?CreateNewFont@@YAPAUHFONT__@@H@Z ; CreateNewFont
  00145	83 c4 04	 add	 esp, 4
  00148	a3 00 00 00 00	 mov	 DWORD PTR ?newFont@?BD@??PutText@@YAXD@Z@4PAUHFONT__@@A, eax

; 3235 : 						if (newFont != NULL)

  0014d	85 c0		 test	 eax, eax
  0014f	74 0b		 je	 SHORT $LN21@PutText

; 3236 : 							oldFont = (HFONT)SelectObject(hDc, newFont);

  00151	50		 push	 eax
  00152	ff 75 e8	 push	 DWORD PTR _hDc$5[ebp]
  00155	ff d3		 call	 ebx
  00157	a3 00 00 00 00	 mov	 DWORD PTR ?oldFont@?BD@??PutText@@YAXD@Z@4PAUHFONT__@@A, eax
$LN21@PutText:

; 3237 : 					}
; 3238 : #endif
; 3239 : #ifndef _CHANNEL_MODIFY
; 3240 : 					TextOut(hDc, FontBuffer[i].x + 1, FontBuffer[i].y + 1, FontBuffer[i].str, (int)strlen(FontBuffer[i].str));
; 3241 : #ifdef _READ16BITBMP
; 3242 : 					if (g_bUseAlpha) TextOut(hDcSys, FontBuffer[i].x + 1, FontBuffer[i].y + 1, FontBuffer[i].str, (int)strlen(FontBuffer[i].str));
; 3243 : #endif
; 3244 : #else
; 3245 : 					if (FontBuffer[i].fontPrio != FONT_PRIO_CHATBUFFER) {

  0015c	8a 86 05 01 00
	00		 mov	 al, BYTE PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[esi+261]
  00162	88 45 ef	 mov	 BYTE PTR tv676[ebp], al
  00165	8d 96 05 00 00
	00		 lea	 edx, DWORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[esi+5]
  0016b	8b ca		 mov	 ecx, edx
  0016d	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00170	89 45 d8	 mov	 DWORD PTR tv654[ebp], eax
$LL56@PutText:
  00173	8a 01		 mov	 al, BYTE PTR [ecx]
  00175	41		 inc	 ecx
  00176	84 c0		 test	 al, al
  00178	75 f9		 jne	 SHORT $LL56@PutText
  0017a	2b 4d d8	 sub	 ecx, DWORD PTR tv654[ebp]
  0017d	0f bf 86 02 00
	00 00		 movsx	 eax, WORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[esi+2]
  00184	40		 inc	 eax
  00185	0f bf b6 00 00
	00 00		 movsx	 esi, WORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[esi]
  0018c	51		 push	 ecx
  0018d	52		 push	 edx
  0018e	50		 push	 eax
  0018f	80 7d ef 03	 cmp	 BYTE PTR tv676[ebp], 3

; 3246 : #ifdef _FONT_PARAGRAPH_COLOR
; 3247 : 						char *s = FontBuffer[i].str;
; 3248 : 						int x = 0;
; 3249 : 						int len = 0;
; 3250 : 						while (char *ss = strstr(s, "/")) {
; 3251 : 							ss++;
; 3252 : 							len = ss - s - 1;
; 3253 : 							if (ss[0] >= 'a' && ss[0] <= 'z') {
; 3254 : 								ss++;
; 3255 : 							}
; 3256 : 							else {
; 3257 : 								len++;
; 3258 : 							}
; 3259 : 							TextOut(hDc, FontBuffer[i].x + 1 + x * 7, FontBuffer[i].y + 1, s, len);
; 3260 : #ifdef _READ16BITBMP
; 3261 : 							if (g_bUseAlpha) {
; 3262 : 								TextOut(hDcSys, FontBuffer[i].x + x * 7, FontBuffer[i].y + 1, s, len);
; 3263 : 							}
; 3264 : #endif
; 3265 : 							s = ss;
; 3266 : 							x += len;
; 3267 : 						}
; 3268 : 						TextOut(hDc, FontBuffer[i].x + 1 + x * 7, FontBuffer[i].y + 1, s, strlen(s));
; 3269 : #ifdef _READ16BITBMP
; 3270 : 						if (g_bUseAlpha) TextOut(hDcSys, FontBuffer[i].x + x * 7, FontBuffer[i].y + 1, s, strlen(s));
; 3271 : #endif
; 3272 : #else
; 3273 : 						TextOut(hDc, FontBuffer[i].x + 1, FontBuffer[i].y + 1, FontBuffer[i].str, (int)strlen(FontBuffer[i].str));

  00193	8d 46 01	 lea	 eax, DWORD PTR [esi+1]

; 3237 : 					}
; 3238 : #endif
; 3239 : #ifndef _CHANNEL_MODIFY
; 3240 : 					TextOut(hDc, FontBuffer[i].x + 1, FontBuffer[i].y + 1, FontBuffer[i].str, (int)strlen(FontBuffer[i].str));
; 3241 : #ifdef _READ16BITBMP
; 3242 : 					if (g_bUseAlpha) TextOut(hDcSys, FontBuffer[i].x + 1, FontBuffer[i].y + 1, FontBuffer[i].str, (int)strlen(FontBuffer[i].str));
; 3243 : #endif
; 3244 : #else
; 3245 : 					if (FontBuffer[i].fontPrio != FONT_PRIO_CHATBUFFER) {

  00196	75 03		 jne	 SHORT $LN64@PutText

; 3274 : #ifdef _READ16BITBMP
; 3275 : 						if (g_bUseAlpha) TextOut(hDcSys, FontBuffer[i].x + 1, FontBuffer[i].y + 1, FontBuffer[i].str, (int)strlen(FontBuffer[i].str));
; 3276 : #endif
; 3277 : #endif
; 3278 : 					}
; 3279 : 					else {
; 3280 : #ifdef _TALK_WINDOW
; 3281 : 						if (g_bTalkWindow) {
; 3282 : 							break;
; 3283 : 						}
; 3284 : #endif
; 3285 : 
; 3286 : #ifdef _FONT_PARAGRAPH_COLOR
; 3287 : 						char *s = FontBuffer[i].str;
; 3288 : 						int x = 0;
; 3289 : 						int len = 0;
; 3290 : 						while (char *ss = strstr(s, "/")) {
; 3291 : 							ss++;
; 3292 : 							len = ss - s - 1;
; 3293 : 
; 3294 : 							if (ss[0] < 'a' || ss[0] > 'z') {
; 3295 : 								len--;
; 3296 : 							}
; 3297 : 							if (false) {
; 3298 : 								TextOut(hDc, FontBuffer[i].x + 1 + x * 7, FontBuffer[i].y + 1, s, len + 2);
; 3299 : #ifdef _READ16BITBMP
; 3300 : 								if (g_bUseAlpha) TextOut(hDcSys, FontBuffer[i].x + 1 + x * 7, FontBuffer[i].y + 1, s, len + 2);
; 3301 : #endif
; 3302 : 							}
; 3303 : 							else {
; 3304 : 								TextOut(hDc, FontBuffer[i].x + 1 + 22 + x * 7, FontBuffer[i].y + 1, s, len + 2);
; 3305 : #ifdef _READ16BITBMP
; 3306 : 								if (g_bUseAlpha) TextOut(hDcSys, FontBuffer[i].x + 1 + 22 + x * 7, FontBuffer[i].y + 1, s, len + 2);
; 3307 : #endif
; 3308 : 							}
; 3309 : 							if (ss[0] >= 'a' && ss[0] <= 'z') {
; 3310 : 								ss++;
; 3311 : 							}
; 3312 : 							s = ss;
; 3313 : 							x += len + 2;
; 3314 : 						}
; 3315 : 
; 3316 : 						if (false) {
; 3317 : 							TextOut(hDc, FontBuffer[i].x + 1 + x * 7, FontBuffer[i].y + 1, s, strlen(s));
; 3318 : #ifdef _READ16BITBMP
; 3319 : 							if (g_bUseAlpha) TextOut(hDcSys, FontBuffer[i].x + 1 + x * 7, FontBuffer[i].y + 1, s, strlen(s));
; 3320 : #endif
; 3321 : 						}
; 3322 : 						else {
; 3323 : 							TextOut(hDc, FontBuffer[i].x + 1 + 22 + x * 7, FontBuffer[i].y + 1, s, strlen(s));
; 3324 : #ifdef _READ16BITBMP
; 3325 : 							if (g_bUseAlpha) TextOut(hDcSys, FontBuffer[i].x + 1 + 22 + x * 7, FontBuffer[i].y + 1, s, strlen(s));
; 3326 : #endif
; 3327 : 						}
; 3328 : #else
; 3329 : 
; 3330 : 						if (false) {
; 3331 : 							TextOut(hDc, FontBuffer[i].x + 1, FontBuffer[i].y + 1, FontBuffer[i].str, (int)strlen(FontBuffer[i].str));
; 3332 : #ifdef _READ16BITBMP
; 3333 : 							if (g_bUseAlpha) TextOut(hDcSys, FontBuffer[i].x + 1, FontBuffer[i].y + 1, FontBuffer[i].str, (int)strlen(FontBuffer[i].str));
; 3334 : #endif
; 3335 : 						}
; 3336 : 						else {
; 3337 : 							TextOut(hDc, FontBuffer[i].x + 1 + 22, FontBuffer[i].y + 1, FontBuffer[i].str, (int)strlen(FontBuffer[i].str));

  00198	8d 46 17	 lea	 eax, DWORD PTR [esi+23]
$LN64@PutText:

; 3338 : #ifdef _READ16BITBMP
; 3339 : 							if (g_bUseAlpha) TextOut(hDcSys, FontBuffer[i].x + 1 + 22, FontBuffer[i].y + 1, FontBuffer[i].str, (int)strlen(FontBuffer[i].str));
; 3340 : #endif
; 3341 : 						}
; 3342 : #endif
; 3343 : #ifndef LABEL_STR_
; 3344 : 						TextOut(hDc, 1 + 1, 432 + DISPLACEMENT_Y + 1, g_szChannelTitle[TalkMode], (int)strlen(g_szChannelTitle[TalkMode]));
; 3345 : #ifdef _READ16BITBMP
; 3346 : 						if (g_bUseAlpha) TextOut(hDcSys, 2 + 1, 432 + DISPLACEMENT_Y + 1, g_szChannelTitle[TalkMode], (int)strlen(g_szChannelTitle[TalkMode]));
; 3347 : #endif
; 3348 : #endif
; 3349 : 					}
; 3350 : #endif
; 3351 : #ifdef _FONT_SIZE
; 3352 : 					if (newFont != NULL) {

  0019b	50		 push	 eax
  0019c	ff 75 e8	 push	 DWORD PTR _hDc$5[ebp]
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TextOutA@20
  001a5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?newFont@?BD@??PutText@@YAXD@Z@4PAUHFONT__@@A
  001ab	85 d2		 test	 edx, edx
  001ad	74 18		 je	 SHORT $LN59@PutText

; 3353 : 						DeleteObject(newFont);

  001af	52		 push	 edx
  001b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 3354 : 						SelectObject(hDc, oldFont);

  001b6	ff 35 00 00 00
	00		 push	 DWORD PTR ?oldFont@?BD@??PutText@@YAXD@Z@4PAUHFONT__@@A
  001bc	ff 75 e8	 push	 DWORD PTR _hDc$5[ebp]
  001bf	ff d3		 call	 ebx

; 3216 : #ifdef _READ16BITBMP
; 3217 : 		if (g_bUseAlpha) SetTextColor(hDcSys, 0);
; 3218 : #endif
; 3219 : 		for (i = 0; i < FontCnt; i++) {

  001c1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?newFont@?BD@??PutText@@YAXD@Z@4PAUHFONT__@@A
$LN59@PutText:
  001c7	47		 inc	 edi
  001c8	89 7d e0	 mov	 DWORD PTR _i$3[ebp], edi
  001cb	e9 d0 fe ff ff	 jmp	 $LL4@PutText
$LN3@PutText:

; 3355 : 					}
; 3356 : #endif
; 3357 : 				}
; 3358 : 			}
; 3359 : 		}
; 3360 : 		// ????? SetTextColor?????????????? ?
; 3361 : 		for (color = 0; color < FONT_PAL_NUM; color++) {

  001d0	33 d2		 xor	 edx, edx
$LN68@PutText:
  001d2	89 55 e4	 mov	 DWORD PTR _color$4[ebp], edx
  001d5	83 fa 1a	 cmp	 edx, 26			; 0000001aH
  001d8	0f 8d 5d 01 00
	00		 jge	 $LN6@PutText

; 3362 : 			for (i = 0; i < FontCnt; i++) {

  001de	33 ff		 xor	 edi, edi
$LN67@PutText:
  001e0	89 7d e0	 mov	 DWORD PTR _i$3[ebp], edi
  001e3	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?FontCnt@@3HA ; FontCnt
  001e9	0f 8d 3f 01 00
	00		 jge	 $LN9@PutText

; 3363 : 				if (FontBuffer[i].fontPrio == fontPrio) {

  001ef	69 f7 10 01 00
	00		 imul	 esi, edi, 272
  001f5	0f b6 8e 05 01
	00 00		 movzx	 ecx, BYTE PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[esi+261]
  001fc	0f be 45 08	 movsx	 eax, BYTE PTR _fontPrio$[ebp]
  00200	3b c8		 cmp	 ecx, eax
  00202	75 6d		 jne	 SHORT $LN60@PutText

; 3364 : 					if (FontBuffer[i].color == color) {

  00204	0f be 86 04 00
	00 00		 movsx	 eax, BYTE PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[esi+4]
  0020b	3b c2		 cmp	 eax, edx
  0020d	75 62		 jne	 SHORT $LN60@PutText

; 3365 : 						if (colorFlag == FALSE) {

  0020f	83 7d dc 00	 cmp	 DWORD PTR _colorFlag$2[ebp], 0
  00213	75 17		 jne	 SHORT $LN29@PutText

; 3366 : 							SetTextColor(hDc, FontPal[color]);

  00215	ff 34 95 00 00
	00 00		 push	 DWORD PTR ?FontPal@@3PAKA[edx*4]
  0021c	ff 75 e8	 push	 DWORD PTR _hDc$5[ebp]
  0021f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTextColor@8

; 3367 : #ifdef _READ16BITBMP
; 3368 : 							if (g_bUseAlpha) SetTextColor(hDcSys, FontPal[color]);
; 3369 : #endif
; 3370 : 							colorFlag = TRUE;

  00225	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _colorFlag$2[ebp], 1
$LN29@PutText:

; 3371 : 						}
; 3372 : 						if (ResoMode == 1) {

  0022c	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?ResoMode@@3HA, 1 ; ResoMode
  00233	75 42		 jne	 SHORT $LN30@PutText

; 3373 : 							TextOut(hDc, FontBuffer[i].x >> 1, FontBuffer[i].y >> 1, FontBuffer[i].str, (int)strlen(FontBuffer[i].str));

  00235	8d 96 05 00 00
	00		 lea	 edx, DWORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[esi+5]
  0023b	8b c2		 mov	 eax, edx
  0023d	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]
$LL57@PutText:
  00240	8a 08		 mov	 cl, BYTE PTR [eax]
  00242	40		 inc	 eax
  00243	84 c9		 test	 cl, cl
  00245	75 f9		 jne	 SHORT $LL57@PutText
  00247	2b c3		 sub	 eax, ebx
  00249	50		 push	 eax
  0024a	52		 push	 edx
  0024b	0f bf 86 02 00
	00 00		 movsx	 eax, WORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[esi+2]
  00252	d1 f8		 sar	 eax, 1
  00254	50		 push	 eax
  00255	0f bf 86 00 00
	00 00		 movsx	 eax, WORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[esi]
  0025c	d1 f8		 sar	 eax, 1
  0025e	50		 push	 eax
  0025f	ff 75 e8	 push	 DWORD PTR _hDc$5[ebp]
  00262	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TextOutA@20
$LN61@PutText:

; 3362 : 			for (i = 0; i < FontCnt; i++) {

  00268	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__SelectObject@8
  0026e	8b 55 e4	 mov	 edx, DWORD PTR _color$4[ebp]
$LN60@PutText:
  00271	47		 inc	 edi
  00272	e9 69 ff ff ff	 jmp	 $LN67@PutText
$LN30@PutText:

; 3374 : 						}
; 3375 : 						else {
; 3376 : #ifdef _FONT_SIZE
; 3377 : 							static HFONT newFont = NULL;
; 3378 : 							static HFONT oldFont = NULL;
; 3379 : 							if (newFont != NULL) {

  00277	a1 00 00 00 00	 mov	 eax, DWORD PTR ?newFont@?DL@??PutText@@YAXD@Z@4PAUHFONT__@@A
  0027c	85 c0		 test	 eax, eax
  0027e	74 07		 je	 SHORT $LN32@PutText

; 3380 : 								DeleteObject(newFont);

  00280	50		 push	 eax
  00281	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
$LN32@PutText:

; 3381 : 								//SelectObject( hDc, oldFont );
; 3382 : 							}
; 3383 : 							if (FontBuffer[i].size <= 0)

  00287	8b 86 0c 01 00
	00		 mov	 eax, DWORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[esi+268]
  0028d	85 c0		 test	 eax, eax
  0028f	7f 0d		 jg	 SHORT $LN33@PutText

; 3384 : 								SelectObject(hDc, hFont);

  00291	ff 35 00 00 00
	00		 push	 DWORD PTR ?hFont@@3PAUHFONT__@@A ; hFont
  00297	ff 75 e8	 push	 DWORD PTR _hDc$5[ebp]
  0029a	ff d3		 call	 ebx
  0029c	eb 1d		 jmp	 SHORT $LN35@PutText
$LN33@PutText:

; 3385 : 							else {
; 3386 : 								newFont = CreateNewFont(FontBuffer[i].size);

  0029e	50		 push	 eax
  0029f	e8 00 00 00 00	 call	 ?CreateNewFont@@YAPAUHFONT__@@H@Z ; CreateNewFont
  002a4	83 c4 04	 add	 esp, 4
  002a7	a3 00 00 00 00	 mov	 DWORD PTR ?newFont@?DL@??PutText@@YAXD@Z@4PAUHFONT__@@A, eax

; 3387 : 								if (newFont != NULL)

  002ac	85 c0		 test	 eax, eax
  002ae	74 0b		 je	 SHORT $LN35@PutText

; 3388 : 									oldFont = (HFONT)SelectObject(hDc, newFont);

  002b0	50		 push	 eax
  002b1	ff 75 e8	 push	 DWORD PTR _hDc$5[ebp]
  002b4	ff d3		 call	 ebx
  002b6	a3 00 00 00 00	 mov	 DWORD PTR ?oldFont@?DL@??PutText@@YAXD@Z@4PAUHFONT__@@A, eax
$LN35@PutText:

; 3389 : 							}
; 3390 : #endif
; 3391 : 
; 3392 : #ifndef _CHANNEL_MODIFY
; 3393 : 							TextOut(hDc, FontBuffer[i].x, FontBuffer[i].y, FontBuffer[i].str, (int)strlen(FontBuffer[i].str));
; 3394 : #ifdef _READ16BITBMP
; 3395 : 							if (g_bUseAlpha) TextOut(hDcSys, FontBuffer[i].x, FontBuffer[i].y, FontBuffer[i].str, (int)strlen(FontBuffer[i].str));
; 3396 : #endif
; 3397 : #else
; 3398 : 							if (FontBuffer[i].fontPrio != FONT_PRIO_CHATBUFFER) {

  002bb	8a 9e 05 01 00
	00		 mov	 bl, BYTE PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[esi+261]
  002c1	8d 96 05 00 00
	00		 lea	 edx, DWORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[esi+5]
  002c7	8b ca		 mov	 ecx, edx
  002c9	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  002cc	89 45 d8	 mov	 DWORD PTR tv662[ebp], eax
  002cf	90		 npad	 1
$LL58@PutText:
  002d0	8a 01		 mov	 al, BYTE PTR [ecx]
  002d2	41		 inc	 ecx
  002d3	84 c0		 test	 al, al
  002d5	75 f9		 jne	 SHORT $LL58@PutText
  002d7	2b 4d d8	 sub	 ecx, DWORD PTR tv662[ebp]
  002da	0f bf 86 02 00
	00 00		 movsx	 eax, WORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[esi+2]
  002e1	0f bf b6 00 00
	00 00		 movsx	 esi, WORD PTR ?FontBuffer@@3PAUFONT_BUFFER@@A[esi]
  002e8	51		 push	 ecx
  002e9	52		 push	 edx
  002ea	50		 push	 eax
  002eb	80 fb 03	 cmp	 bl, 3
  002ee	74 03		 je	 SHORT $LN36@PutText

; 3399 : #ifdef _FONT_PARAGRAPH_COLOR
; 3400 : 								char *s = FontBuffer[i].str;
; 3401 : 								int x = 0;
; 3402 : 								int len = 0;
; 3403 : 								while (char *ss = strstr(s, "/")) {
; 3404 : 									ss++;
; 3405 : 									len = ss - s - 1;
; 3406 : 									if (ss[0] < 'a' || ss[0] > 'z') {
; 3407 : 										len++;
; 3408 : 									}
; 3409 : 									TextOut(hDc, FontBuffer[i].x + x * 7, FontBuffer[i].y, s, len);
; 3410 : #ifdef _READ16BITBMP
; 3411 : 									if (g_bUseAlpha) {
; 3412 : 										TextOut(hDcSys, FontBuffer[i].x + x * 7, FontBuffer[i].y, s, len);
; 3413 : 									}
; 3414 : #endif
; 3415 : 
; 3416 : 									if (ss[0] >= 'a' && ss[0] <= 'z') {
; 3417 : 										SetTextColor(hDc, FontPal[ss[0] - 'a']);
; 3418 : 										ss++;
; 3419 : 									}
; 3420 : 
; 3421 : 									s = ss;
; 3422 : 									x += len;
; 3423 : 								}
; 3424 : 								TextOut(hDc, FontBuffer[i].x + x * 7, FontBuffer[i].y, s, strlen(s));
; 3425 : #ifdef _READ16BITBMP
; 3426 : 								if (g_bUseAlpha) TextOut(hDcSys, FontBuffer[i].x + x * 7, FontBuffer[i].y, s, strlen(s));
; 3427 : #endif
; 3428 : 								SetTextColor(hDc, FontPal[color]);
; 3429 : #else
; 3430 : 								TextOut(hDc, FontBuffer[i].x, FontBuffer[i].y, FontBuffer[i].str, (int)strlen(FontBuffer[i].str));

  002f0	56		 push	 esi

; 3431 : #ifdef _READ16BITBMP
; 3432 : 								if (g_bUseAlpha) TextOut(hDcSys, FontBuffer[i].x, FontBuffer[i].y, FontBuffer[i].str, (int)strlen(FontBuffer[i].str));
; 3433 : #endif
; 3434 : #endif
; 3435 : 							}

  002f1	eb 04		 jmp	 SHORT $LN65@PutText
$LN36@PutText:

; 3436 : 							else {
; 3437 : #ifdef _TALK_WINDOW
; 3438 : 								if (g_bTalkWindow) break;
; 3439 : #endif
; 3440 : 
; 3441 : #ifdef _FONT_PARAGRAPH_COLOR
; 3442 : 								char *s = FontBuffer[i].str;
; 3443 : 								int x = 0;
; 3444 : 								int len = 0;
; 3445 : 								while (char *ss = strstr(s, "/")) {
; 3446 : 									ss++;
; 3447 : 									len = ss - s - 1;
; 3448 : 
; 3449 : 									if (ss[0] < 'a' || ss[0] > 'z') {
; 3450 : 										len--;
; 3451 : 									}
; 3452 : 									if (false) {
; 3453 : 										TextOut(hDc, FontBuffer[i].x + x * 7, FontBuffer[i].y, s, len + 2);
; 3454 : #ifdef _READ16BITBMP
; 3455 : 										if (g_bUseAlpha) TextOut(hDcSys, FontBuffer[i].x + x * 7, FontBuffer[i].y, s, len + 2);
; 3456 : #endif
; 3457 : 									}
; 3458 : 									else {
; 3459 : 										TextOut(hDc, FontBuffer[i].x + 22 + x * 7, FontBuffer[i].y, s, len + 2);
; 3460 : #ifdef _READ16BITBMP
; 3461 : 										if (g_bUseAlpha) TextOut(hDcSys, FontBuffer[i].x + 22 + x * 7, FontBuffer[i].y, s, len + 2);
; 3462 : #endif
; 3463 : 									}
; 3464 : 
; 3465 : 									if (ss[0] >= 'a' && ss[0] <= 'z') {
; 3466 : 										SetTextColor(hDc, FontPal[ss[0] - 'a']);
; 3467 : 										ss++;
; 3468 : 									}
; 3469 : 
; 3470 : 									s = ss;
; 3471 : 									x += len + 2;
; 3472 : 								}
; 3473 : 
; 3474 : 								if (false) {
; 3475 : 									TextOut(hDc, FontBuffer[i].x + x * 7, FontBuffer[i].y, s, strlen(s));
; 3476 : #ifdef _READ16BITBMP
; 3477 : 									if (g_bUseAlpha) TextOut(hDcSys, FontBuffer[i].x + x * 7, FontBuffer[i].y, s, strlen(s));
; 3478 : #endif
; 3479 : 								}
; 3480 : 								else {
; 3481 : 									TextOut(hDc, FontBuffer[i].x + 22 + x * 7, FontBuffer[i].y, s, strlen(s));
; 3482 : #ifdef _READ16BITBMP
; 3483 : 									if (g_bUseAlpha) TextOut(hDcSys, FontBuffer[i].x + 22 + x * 7, FontBuffer[i].y, s, strlen(s));
; 3484 : #endif
; 3485 : 								}
; 3486 : 								SetTextColor(hDc, FontPal[color]);
; 3487 : #else
; 3488 : 
; 3489 : 								if (false) {
; 3490 : 									TextOut(hDc, FontBuffer[i].x, FontBuffer[i].y, FontBuffer[i].str, (int)strlen(FontBuffer[i].str));
; 3491 : #ifdef _READ16BITBMP
; 3492 : 									if (g_bUseAlpha) TextOut(hDcSys, FontBuffer[i].x, FontBuffer[i].y, FontBuffer[i].str, (int)strlen(FontBuffer[i].str));
; 3493 : #endif
; 3494 : 								}
; 3495 : 								else {
; 3496 : 									TextOut(hDc, FontBuffer[i].x + 22, FontBuffer[i].y, FontBuffer[i].str, (int)strlen(FontBuffer[i].str));

  002f3	8d 46 16	 lea	 eax, DWORD PTR [esi+22]
  002f6	50		 push	 eax
$LN65@PutText:

; 3497 : #ifdef _READ16BITBMP
; 3498 : 									if (g_bUseAlpha) TextOut(hDcSys, FontBuffer[i].x + 22, FontBuffer[i].y, FontBuffer[i].str, (int)strlen(FontBuffer[i].str));
; 3499 : #endif
; 3500 : 								}
; 3501 : #endif
; 3502 : #ifndef LABEL_STR_
; 3503 : 								TextOut(hDc, 1, 432 + DISPLACEMENT_Y, g_szChannelTitle[TalkMode], (int)strlen(g_szChannelTitle[TalkMode]));
; 3504 : #ifdef _READ16BITBMP
; 3505 : 								if (g_bUseAlpha) TextOut(hDcSys, 2, 432 + DISPLACEMENT_Y, g_szChannelTitle[TalkMode], (int)strlen(g_szChannelTitle[TalkMode]));
; 3506 : #endif
; 3507 : #endif
; 3508 : 							}
; 3509 : #endif
; 3510 : #ifdef _FONT_SIZE
; 3511 : 							if (newFont != NULL) {

  002f7	ff 75 e8	 push	 DWORD PTR _hDc$5[ebp]
  002fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TextOutA@20
  00300	a1 00 00 00 00	 mov	 eax, DWORD PTR ?newFont@?DL@??PutText@@YAXD@Z@4PAUHFONT__@@A
  00305	85 c0		 test	 eax, eax
  00307	0f 84 5b ff ff
	ff		 je	 $LN61@PutText

; 3512 : 								DeleteObject(newFont);

  0030d	50		 push	 eax
  0030e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 3513 : 								SelectObject(hDc, oldFont);

  00314	ff 35 00 00 00
	00		 push	 DWORD PTR ?oldFont@?DL@??PutText@@YAXD@Z@4PAUHFONT__@@A
  0031a	ff 75 e8	 push	 DWORD PTR _hDc$5[ebp]
  0031d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__SelectObject@8
  00323	ff d3		 call	 ebx

; 3362 : 			for (i = 0; i < FontCnt; i++) {

  00325	8b 55 e4	 mov	 edx, DWORD PTR _color$4[ebp]
  00328	47		 inc	 edi
  00329	e9 b2 fe ff ff	 jmp	 $LN67@PutText
$LN9@PutText:

; 3514 : 							}
; 3515 : #endif
; 3516 : 						}
; 3517 : 					}
; 3518 : 				}
; 3519 : 			}
; 3520 : 			colorFlag = FALSE;

  0032e	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _colorFlag$2[ebp], 0

; 3355 : 					}
; 3356 : #endif
; 3357 : 				}
; 3358 : 			}
; 3359 : 		}
; 3360 : 		// ????? SetTextColor?????????????? ?
; 3361 : 		for (color = 0; color < FONT_PAL_NUM; color++) {

  00335	42		 inc	 edx
  00336	e9 97 fe ff ff	 jmp	 $LN68@PutText
$LN6@PutText:

; 3521 : 		}
; 3522 : 		SelectObject(hDc, hOldFont);

  0033b	ff 75 d4	 push	 DWORD PTR _hOldFont$1$[ebp]
  0033e	ff 75 e8	 push	 DWORD PTR _hDc$5[ebp]
  00341	ff d3		 call	 ebx

; 3523 : 		lpDraw->lpBACKBUFFER->ReleaseDC(hDc);

  00343	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00348	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0034b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0034d	ff 75 e8	 push	 DWORD PTR _hDc$5[ebp]
  00350	50		 push	 eax
  00351	ff 51 68	 call	 DWORD PTR [ecx+104]
$LN45@PutText:

; 3535 : 
; 3536 : 
; 3537 : }

  00354	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN44@PutText:
  0035b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0035e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00365	59		 pop	 ecx
  00366	5f		 pop	 edi
  00367	5e		 pop	 esi
  00368	5b		 pop	 ebx
  00369	8b e5		 mov	 esp, ebp
  0036b	5d		 pop	 ebp
  0036c	c3		 ret	 0
__catch$?PutText@@YAXD@Z$0:

; 3524 : #ifdef _READ16BITBMP
; 3525 : 		if (g_bUseAlpha) {
; 3526 : 			SelectObject(hDcSys, hOldFont);
; 3527 : 			lpDraw->lpBACKBUFFERSYS->ReleaseDC(hDcSys);
; 3528 : 		}
; 3529 : #endif
; 3530 : 	}
; 3531 : 	catch (...)
; 3532 : 	{
; 3533 : 
; 3534 : 	}

  0036d	b8 00 00 00 00	 mov	 eax, $LN45@PutText
  00372	c3		 ret	 0
  00373	cc		 int	 3
  00374	cc		 int	 3
  00375	cc		 int	 3
  00376	cc		 int	 3
  00377	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?PutText@@YAXD@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?PutText@@YAXD@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?PutText@@YAXD@Z ENDP					; PutText
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?InitFont@@YAXH@Z
_TEXT	SEGMENT
_fontNo$ = 8						; size = 4
?InitFont@@YAXH@Z PROC					; InitFont, COMDAT

; 3156 : 	extern int 编码;
; 3157 : 	char* fontName[] = { "굴림체","EUC-KR" };
; 3158 : 	if (hFont != NULL)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hFont@@3PAUHFONT__@@A ; hFont
  00005	85 c0		 test	 eax, eax
  00007	74 07		 je	 SHORT $LN2@InitFont

; 3159 : 	{
; 3160 : 		DeleteObject(hFont);

  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
$LN2@InitFont:

; 3161 : 	}
; 3162 : 
; 3163 : 	if (ResoMode == 1)

  00010	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?ResoMode@@3HA, 1 ; ResoMode
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_06MFMMLLPC@?$LB?$LM?$LI?$LC?C?$LM@
  0001c	6a 11		 push	 17			; 00000011H
  0001e	6a 00		 push	 0
  00020	6a 00		 push	 0
  00022	6a 00		 push	 0
  00024	68 81 00 00 00	 push	 129			; 00000081H
  00029	6a 00		 push	 0
  0002b	6a 00		 push	 0
  0002d	6a 00		 push	 0
  0002f	68 90 01 00 00	 push	 400			; 00000190H
  00034	6a 00		 push	 0
  00036	6a 00		 push	 0
  00038	6a 00		 push	 0
  0003a	75 0e		 jne	 SHORT $LN3@InitFont

; 3164 : 	{
; 3165 : 		hFont = CreateFont(FONT_SIZE / 2, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, HANGEUL_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, FIXED_PITCH | FF_ROMAN, TEXT("굴림체"));

  0003c	6a 07		 push	 7

; 3170 : 	}
; 3171 : }

  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFontA@56
  00044	a3 00 00 00 00	 mov	 DWORD PTR ?hFont@@3PAUHFONT__@@A, eax ; hFont
  00049	c3		 ret	 0
$LN3@InitFont:

; 3166 : 	}
; 3167 : 	else
; 3168 : 	{
; 3169 : 		hFont = CreateFont(FONT_SIZE, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, HANGEUL_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, FIXED_PITCH | FF_ROMAN, TEXT("굴림체"));

  0004a	6a 0e		 push	 14			; 0000000eH

; 3170 : 	}
; 3171 : }

  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFontA@56
  00052	a3 00 00 00 00	 mov	 DWORD PTR ?hFont@@3PAUHFONT__@@A, eax ; hFont
  00057	c3		 ret	 0
?InitFont@@YAXH@Z ENDP					; InitFont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?DrawBox@@YAXPAUtagRECT@@EH@Z
_TEXT	SEGMENT
_j$2 = -168						; size = 4
_surfacePitch$3 = -164					; size = 4
_w$1$ = -160						; size = 4
tv1183 = -160						; size = 4
tv1178 = -160						; size = 4
tv1173 = -160						; size = 4
_pDest2$4 = -156					; size = 4
_rect$GSCopy$1$ = -152					; size = 4
tv1174 = -152						; size = 4
tv1169 = -152						; size = 4
tv1166 = -152						; size = 4
_pDest32$5 = -148					; size = 4
_bottom$3$ = -144					; size = 4
_bottom$1$ = -144					; size = 4
tv1154 = -144						; size = 4
_pDest$6 = -140						; size = 4
$T7 = -136						; size = 4
_h$1$ = -136						; size = 4
tv1140 = -136						; size = 4
_i$8 = -132						; size = 4
_ddsd$9 = -128						; size = 108
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_rect$ = 8						; size = 4
_color$ = 12						; size = 1
_fill$ = 16						; size = 4
?DrawBox@@YAXPAUtagRECT@@EH@Z PROC			; DrawBox, COMDAT

; 1610 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?DrawBox@@YAXPAUtagRECT@@EH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 9c 00 00
	00		 sub	 esp, 156		; 0000009cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b 55 08	 mov	 edx, DWORD PTR _rect$[ebp]
  00034	89 95 68 ff ff
	ff		 mov	 DWORD PTR _rect$GSCopy$1$[ebp], edx
  0003a	8a 5d 0c	 mov	 bl, BYTE PTR _color$[ebp]

; 1611 : 
; 1612 : 	try

  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00044	8b 3a		 mov	 edi, DWORD PTR [edx]

; 1613 : 	{
; 1614 : 		DDSURFACEDESC ddsd;	// ??????
; 1615 : #ifdef _READ16BITBMP
; 1616 : 		DDSURFACEDESC ddsdsys;
; 1617 : 		int surfacePitchsys, bottomSys;
; 1618 : 		surfacePitchsys = bottomSys = 0;
; 1619 : 		short *pDestSys;
; 1620 : #endif
; 1621 : #ifdef _HI_COLOR_32
; 1622 : 		int *pDest32;
; 1623 : #ifdef _READ16BITBMP
; 1624 : 		int *pDestSys32;
; 1625 : #endif
; 1626 : #endif
; 1627 : 		char *pDest;		// ??????
; 1628 : 		short *pDest2;		// ????????????
; 1629 : 		int surfacePitch;	// ??????????
; 1630 : 		int i, j;			// ???????
; 1631 : 		int bottom;			// ??????????
; 1632 : 		int w;				// ??
; 1633 : 		int h;				// ?
; 1634 : 		short pixel;		// 16BitColor????
; 1635 : 
; 1636 : 							//???????????????
; 1637 : 		if (ResoMode == 1) {

  00046	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00049	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?ResoMode@@3HA, 1 ; ResoMode
  00050	75 1f		 jne	 SHORT $LN124@DrawBox

; 1638 : 			rect->top = (rect->top >> 1) - 1;

  00052	d1 f8		 sar	 eax, 1
  00054	48		 dec	 eax
  00055	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1639 : 			rect->left = (rect->left >> 1) - 1;

  00058	d1 ff		 sar	 edi, 1
  0005a	4f		 dec	 edi
  0005b	89 3a		 mov	 DWORD PTR [edx], edi

; 1640 : 			rect->right = (rect->right >> 1) + 1;

  0005d	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00060	d1 fe		 sar	 esi, 1
  00062	46		 inc	 esi
  00063	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 1641 : 			rect->bottom = (rect->bottom >> 1) + 1;

  00066	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00069	d1 f9		 sar	 ecx, 1
  0006b	41		 inc	 ecx
  0006c	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  0006f	eb 06		 jmp	 SHORT $LN145@DrawBox
$LN124@DrawBox:
  00071	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00074	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
$LN145@DrawBox:

; 1642 : 		}
; 1643 : 
; 1644 : 		// ????????
; 1645 : 		if (rect->left < 0) rect->left = 0;

  00077	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
  0007d	85 ff		 test	 edi, edi
  0007f	79 08		 jns	 SHORT $LN143@DrawBox
  00081	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00087	33 ff		 xor	 edi, edi
$LN143@DrawBox:

; 1646 : 		if (rect->right >= lpDraw->xSize) rect->right = lpDraw->xSize;

  00089	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0008e	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [eax+132]
  00094	3b f0		 cmp	 esi, eax
  00096	7c 05		 jl	 SHORT $LN56@DrawBox
  00098	89 42 08	 mov	 DWORD PTR [edx+8], eax
  0009b	8b f0		 mov	 esi, eax
$LN56@DrawBox:

; 1647 : 		if (rect->top < 0) rect->top = 0;

  0009d	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR $T7[ebp], 0
  000a4	7d 11		 jge	 SHORT $LN57@DrawBox
  000a6	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
  000ad	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp], 0
$LN57@DrawBox:

; 1648 : 		if (rect->bottom >= lpDraw->ySize) rect->bottom = lpDraw->ySize;

  000b7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  000bc	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [eax+136]
  000c2	3b c8		 cmp	 ecx, eax
  000c4	7c 05		 jl	 SHORT $LN58@DrawBox
  000c6	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  000c9	8b c8		 mov	 ecx, eax
$LN58@DrawBox:

; 1649 : 
; 1650 : 		w = rect->right - rect->left;

  000cb	2b f7		 sub	 esi, edi
  000cd	89 b5 60 ff ff
	ff		 mov	 DWORD PTR _w$1$[ebp], esi

; 1651 : 		h = rect->bottom - rect->top;

  000d3	2b 8d 78 ff ff
	ff		 sub	 ecx, DWORD PTR $T7[ebp]
  000d9	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _h$1$[ebp], ecx

; 1652 : 
; 1653 : 		if (fill != 2 && (w <= 2 || h <= 2)) return;

  000df	83 7d 10 02	 cmp	 DWORD PTR _fill$[ebp], 2
  000e3	74 13		 je	 SHORT $LN142@DrawBox
  000e5	83 fe 02	 cmp	 esi, 2
  000e8	0f 8e be 05 00
	00		 jle	 $LN88@DrawBox
  000ee	83 f9 02	 cmp	 ecx, 2
  000f1	7f 0d		 jg	 SHORT $LN61@DrawBox
  000f3	e9 b4 05 00 00	 jmp	 $LN88@DrawBox
$LN142@DrawBox:

; 1654 : 		if (fill == 2 && w == 0) return;

  000f8	85 f6		 test	 esi, esi
  000fa	0f 84 ac 05 00
	00		 je	 $LN88@DrawBox
$LN61@DrawBox:

; 1655 : 
; 1656 : 		// ?????
; 1657 : 		ZeroMemory(&ddsd, sizeof(DDSURFACEDESC));

  00100	6a 6c		 push	 108			; 0000006cH
  00102	6a 00		 push	 0
  00104	8d 45 80	 lea	 eax, DWORD PTR _ddsd$9[ebp]
  00107	50		 push	 eax
  00108	e8 00 00 00 00	 call	 _memset
  0010d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1658 : 		ddsd.dwSize = sizeof(DDSURFACEDESC);

  00110	c7 45 80 6c 00
	00 00		 mov	 DWORD PTR _ddsd$9[ebp], 108 ; 0000006cH

; 1659 : #ifdef _READ16BITBMP
; 1660 : 		if (g_bUseAlpha) {
; 1661 : 			ZeroMemory(&ddsdsys, sizeof(DDSURFACEDESC));
; 1662 : 			ddsdsys.dwSize = sizeof(DDSURFACEDESC);
; 1663 : 		}
; 1664 : #endif
; 1665 : 
; 1666 : 		// ?????????????????( ?? ddsd ??????? )
; 1667 : 		if (lpDraw->lpBACKBUFFER->Lock(NULL, &ddsd, DDLOCK_WAIT, NULL) != DD_OK) {

  00117	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0011c	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0011f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00121	6a 00		 push	 0
  00123	6a 01		 push	 1
  00125	8d 55 80	 lea	 edx, DWORD PTR _ddsd$9[ebp]
  00128	52		 push	 edx
  00129	6a 00		 push	 0
  0012b	50		 push	 eax
  0012c	ff 51 64	 call	 DWORD PTR [ecx+100]
  0012f	85 c0		 test	 eax, eax
  00131	0f 85 75 05 00
	00		 jne	 $LN88@DrawBox

; 1668 : 			//MessageBoxNew( hWnd, "Surface的lock失败！", "확인", MB_OK | MB_ICONSTOP );
; 1669 : 			return;
; 1670 : 		}
; 1671 : #ifdef _READ16BITBMP
; 1672 : 		if (g_bUseAlpha) {
; 1673 : 			if (lpDraw->lpBACKBUFFERSYS->Lock(NULL, &ddsdsys, DDLOCK_WAIT, NULL) != DD_OK) {
; 1674 : 				lpDraw->lpBACKBUFFER->Unlock(NULL);
; 1675 : 				return;
; 1676 : 			}
; 1677 : 			surfacePitchsys = ddsdsys.lPitch;
; 1678 : 		}
; 1679 : #endif
; 1680 : 
; 1681 : 		// ??????????
; 1682 : 		surfacePitch = ddsd.lPitch;

  00137	8b 7d 90	 mov	 edi, DWORD PTR _ddsd$9[ebp+16]
  0013a	89 bd 5c ff ff
	ff		 mov	 DWORD PTR _surfacePitch$3[ebp], edi
  00140	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _rect$GSCopy$1$[ebp]
  00146	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00148	89 8d 70 ff ff
	ff		 mov	 DWORD PTR tv1154[ebp], ecx
  0014e	8b 52 04	 mov	 edx, DWORD PTR [edx+4]

; 1683 : 		// ?????????????
; 1684 : #ifdef _HI_COLOR_32
; 1685 : 		if (displayBpp == 32) {

  00151	a1 00 00 00 00	 mov	 eax, DWORD PTR ?displayBpp@@3HA ; displayBpp
  00156	83 f8 20	 cmp	 eax, 32			; 00000020H
  00159	75 26		 jne	 SHORT $LN63@DrawBox

; 1686 : 			// 32 Bit Color
; 1687 : 			surfacePitch = surfacePitch >> 1;

  0015b	d1 ff		 sar	 edi, 1
  0015d	89 bd 5c ff ff
	ff		 mov	 DWORD PTR _surfacePitch$3[ebp], edi

; 1688 : 			pDest32 = (int *)ddsd.lpSurface + rect->top * surfacePitch + rect->left + 1;

  00163	8b c2		 mov	 eax, edx
  00165	0f af c7	 imul	 eax, edi
  00168	03 c1		 add	 eax, ecx
  0016a	8b 4d a4	 mov	 ecx, DWORD PTR _ddsd$9[ebp+36]
  0016d	83 c1 04	 add	 ecx, 4
  00170	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00173	89 85 6c ff ff
	ff		 mov	 DWORD PTR _pDest32$5[ebp], eax

; 1689 : #ifdef _READ16BITBMP
; 1690 : 			if (g_bUseAlpha) {
; 1691 : 				surfacePitchsys = surfacePitchsys >> 2;
; 1692 : 				pDestSys32 = (int *)ddsdsys.lpSurface + rect->top * surfacePitchsys + rect->left + 1;
; 1693 : 			}
; 1694 : #endif
; 1695 : 		}

  00179	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _pDest$6[ebp]
  0017f	eb 3c		 jmp	 SHORT $LN146@DrawBox
$LN63@DrawBox:

; 1696 : 		else
; 1697 : #endif
; 1698 : 			if (displayBpp == 16) {

  00181	83 f8 10	 cmp	 eax, 16			; 00000010H
  00184	8b c2		 mov	 eax, edx
  00186	75 24		 jne	 SHORT $LN65@DrawBox

; 1699 : 				// 16 Bit Color
; 1700 : 				surfacePitch = surfacePitch >> 1;

  00188	d1 ff		 sar	 edi, 1
  0018a	89 bd 5c ff ff
	ff		 mov	 DWORD PTR _surfacePitch$3[ebp], edi

; 1701 : 				pDest2 = (short *)ddsd.lpSurface + rect->top * surfacePitch + rect->left + 1;

  00190	0f af c7	 imul	 eax, edi
  00193	03 c1		 add	 eax, ecx
  00195	8b 4d a4	 mov	 ecx, DWORD PTR _ddsd$9[ebp+36]
  00198	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  0019b	83 c1 02	 add	 ecx, 2
  0019e	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _pDest2$4[ebp], ecx

; 1702 : #ifdef _READ16BITBMP
; 1703 : 				if (g_bUseAlpha) {
; 1704 : 					surfacePitchsys = surfacePitchsys >> 1;
; 1705 : 					pDestSys = (short*)ddsdsys.lpSurface + rect->top * surfacePitchsys + rect->left + 1;
; 1706 : 				}
; 1707 : #endif
; 1708 : 			}

  001a4	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _pDest$6[ebp]
  001aa	eb 17		 jmp	 SHORT $LN66@DrawBox
$LN65@DrawBox:

; 1709 : 			else {
; 1710 : 				// 8 Bit Color
; 1711 : 				pDest = (char *)(ddsd.lpSurface) + rect->top * surfacePitch + rect->left + 1;

  001ac	0f af c7	 imul	 eax, edi
  001af	03 c1		 add	 eax, ecx
  001b1	8b 4d a4	 mov	 ecx, DWORD PTR _ddsd$9[ebp+36]
  001b4	41		 inc	 ecx
  001b5	03 c1		 add	 eax, ecx
  001b7	89 85 74 ff ff
	ff		 mov	 DWORD PTR _pDest$6[ebp], eax
$LN146@DrawBox:

; 1712 : 			}
; 1713 : 			// ???????
; 1714 : 			if (fill == FALSE) {

  001bd	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _pDest2$4[ebp]
$LN66@DrawBox:
  001c3	83 7d 10 00	 cmp	 DWORD PTR _fill$[ebp], 0
  001c7	0f 85 6b 02 00
	00		 jne	 $LN67@DrawBox

; 1715 : #ifdef _HI_COLOR_32
; 1716 : 				if (displayBpp == 32) {

  001cd	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _h$1$[ebp]
  001d3	49		 dec	 ecx
  001d4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?displayBpp@@3HA ; displayBpp
  001d9	83 f8 20	 cmp	 eax, 32			; 00000020H
  001dc	0f 85 e5 00 00
	00		 jne	 $LN69@DrawBox

; 1717 : 					// 32 Bit Color
; 1718 : 					int pixel;
; 1719 : 					surfacePitch = surfacePitch >> 1;

  001e2	d1 ff		 sar	 edi, 1
  001e4	89 bd 5c ff ff
	ff		 mov	 DWORD PTR _surfacePitch$3[ebp], edi

; 1720 : 					pDest32 = (int *)ddsd.lpSurface + rect->top * surfacePitch + rect->left + 1;

  001ea	0f af d7	 imul	 edx, edi
  001ed	03 95 70 ff ff
	ff		 add	 edx, DWORD PTR tv1154[ebp]
  001f3	8b 45 a4	 mov	 eax, DWORD PTR _ddsd$9[ebp+36]
  001f6	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  001f9	83 c0 04	 add	 eax, 4
  001fc	89 85 6c ff ff
	ff		 mov	 DWORD PTR _pDest32$5[ebp], eax

; 1721 : 					// ??????????
; 1722 : 					bottom = (h - 1) * surfacePitch;

  00202	0f af cf	 imul	 ecx, edi
  00205	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _bottom$1$[ebp], ecx

; 1723 : #ifdef _READ16BITBMP
; 1724 : 					bottomSys = (h - 1) * surfacePitchsys;
; 1725 : #endif
; 1726 : 
; 1727 : 					pixel = highColor32Palette[color];

  0020b	0f b6 c3	 movzx	 eax, bl
  0020e	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR ?highColor32Palette@@3PAIA[eax*4]

; 1728 : 
; 1729 : 					// ????
; 1730 : 					for (i = 0; i < w - 2; i++) {

  00215	33 c9		 xor	 ecx, ecx
  00217	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _i$8[ebp], ecx
  0021d	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR _pDest32$5[ebp]
$LL4@DrawBox:
  00223	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]
  00226	3b c8		 cmp	 ecx, eax
  00228	7d 2a		 jge	 SHORT $LN3@DrawBox

; 1731 : 						// ????
; 1732 : 						*(pDest32 + i) = pixel;

  0022a	89 14 8b	 mov	 DWORD PTR [ebx+ecx*4], edx

; 1733 : 						*(pDest32 + surfacePitch + i) = pixel;

  0022d	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  00230	89 14 83	 mov	 DWORD PTR [ebx+eax*4], edx

; 1734 : 						// ?????
; 1735 : 						*(pDest32 + bottom - surfacePitch + i) = pixel;

  00233	8b c1		 mov	 eax, ecx
  00235	2b c7		 sub	 eax, edi
  00237	03 85 70 ff ff
	ff		 add	 eax, DWORD PTR _bottom$1$[ebp]
  0023d	89 14 83	 mov	 DWORD PTR [ebx+eax*4], edx

; 1736 : 						*(pDest32 + bottom + i) = pixel;

  00240	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _bottom$1$[ebp]
  00246	03 c1		 add	 eax, ecx
  00248	89 14 83	 mov	 DWORD PTR [ebx+eax*4], edx

; 1728 : 
; 1729 : 					// ????
; 1730 : 					for (i = 0; i < w - 2; i++) {

  0024b	41		 inc	 ecx
  0024c	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _i$8[ebp], ecx
  00252	eb cf		 jmp	 SHORT $LL4@DrawBox
$LN3@DrawBox:

; 1737 : #ifdef _READ16BITBMP
; 1738 : 						if (g_bUseAlpha) {
; 1739 : 							*(pDestSys32 + i) = pixel;
; 1740 : 							*(pDestSys32 + surfacePitchsys + i) = pixel;
; 1741 : 							*(pDestSys32 + bottomSys - surfacePitchsys + i) = pixel;
; 1742 : 							*(pDestSys32 + bottomSys + i) = pixel;
; 1743 : 						}
; 1744 : #endif
; 1745 : 					}
; 1746 : 
; 1747 : 					// ???
; 1748 : 					*(pDest32 + surfacePitch + surfacePitch + 1) = pixel;					// ?

  00254	89 54 fb 04	 mov	 DWORD PTR [ebx+edi*8+4], edx

; 1749 : 					*(pDest32 + surfacePitch + surfacePitch + w - 4) = pixel;				// ?

  00258	8d 04 7e	 lea	 eax, DWORD PTR [esi+edi*2]
  0025b	89 54 83 f0	 mov	 DWORD PTR [ebx+eax*4-16], edx

; 1750 : 					*(pDest32 + bottom - (surfacePitch + surfacePitch) + 1) = pixel;		// ??

  0025f	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  00262	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _bottom$1$[ebp]
  00268	2b c8		 sub	 ecx, eax
  0026a	89 54 8b 04	 mov	 DWORD PTR [ebx+ecx*4+4], edx

; 1751 : 					*(pDest32 + bottom - (surfacePitch + surfacePitch) + w - 4) = pixel;	// ??

  0026e	8d 04 7d 04 00
	00 00		 lea	 eax, DWORD PTR [edi*2+4]
  00275	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _bottom$1$[ebp]
  0027b	2b c8		 sub	 ecx, eax
  0027d	03 ce		 add	 ecx, esi
  0027f	89 14 8b	 mov	 DWORD PTR [ebx+ecx*4], edx

; 1752 : 
; 1753 : 																							// ???????????????
; 1754 : 					pDest32 += surfacePitch - 1;

  00282	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  00289	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv1174[ebp], eax
  0028f	8d 4b fc	 lea	 ecx, DWORD PTR [ebx-4]
  00292	03 c8		 add	 ecx, eax

; 1755 : #ifdef _READ16BITBMP
; 1756 : 					if (g_bUseAlpha) {
; 1757 : 						*(pDestSys32 + surfacePitchsys + surfacePitchsys + 1) = pixel;
; 1758 : 						*(pDestSys32 + surfacePitchsys + surfacePitchsys + w - 4) = pixel;
; 1759 : 						*(pDestSys32 + bottomSys - (surfacePitchsys + surfacePitchsys) + 1) = pixel;
; 1760 : 						*(pDestSys32 + bottomSys - (surfacePitchsys + surfacePitchsys) + w - 4) = pixel;
; 1761 : 						pDestSys32 += surfacePitchsys - 1;
; 1762 : 					}
; 1763 : #endif
; 1764 : 
; 1765 : 					// ???
; 1766 : 					for (i = 0; i < h - 2; i++) {

  00294	33 ff		 xor	 edi, edi
  00296	8b d8		 mov	 ebx, eax
$LN147@DrawBox:
  00298	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _pDest32$5[ebp], ecx
  0029e	89 bd 7c ff ff
	ff		 mov	 DWORD PTR _i$8[ebp], edi
  002a4	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _h$1$[ebp]
  002aa	83 c0 fe	 add	 eax, -2			; fffffffeH
  002ad	3b f8		 cmp	 edi, eax
  002af	0f 8d d5 03 00
	00		 jge	 $LN83@DrawBox

; 1767 : 						// ?????
; 1768 : 						*pDest32 = pixel;

  002b5	89 11		 mov	 DWORD PTR [ecx], edx

; 1769 : 						*(pDest32 + 1) = pixel;

  002b7	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 1770 : 						// ?????
; 1771 : 						*(pDest32 + w - 1) = pixel;

  002ba	89 54 b1 fc	 mov	 DWORD PTR [ecx+esi*4-4], edx

; 1772 : 						*(pDest32 + w - 2) = pixel;

  002be	89 54 b1 f8	 mov	 DWORD PTR [ecx+esi*4-8], edx

; 1773 : 						// ???????????????
; 1774 : 						pDest32 += surfacePitch;

  002c2	03 cb		 add	 ecx, ebx

; 1755 : #ifdef _READ16BITBMP
; 1756 : 					if (g_bUseAlpha) {
; 1757 : 						*(pDestSys32 + surfacePitchsys + surfacePitchsys + 1) = pixel;
; 1758 : 						*(pDestSys32 + surfacePitchsys + surfacePitchsys + w - 4) = pixel;
; 1759 : 						*(pDestSys32 + bottomSys - (surfacePitchsys + surfacePitchsys) + 1) = pixel;
; 1760 : 						*(pDestSys32 + bottomSys - (surfacePitchsys + surfacePitchsys) + w - 4) = pixel;
; 1761 : 						pDestSys32 += surfacePitchsys - 1;
; 1762 : 					}
; 1763 : #endif
; 1764 : 
; 1765 : 					// ???
; 1766 : 					for (i = 0; i < h - 2; i++) {

  002c4	47		 inc	 edi
  002c5	eb d1		 jmp	 SHORT $LN147@DrawBox
$LN69@DrawBox:

; 1775 : #ifdef _READ16BITBMP
; 1776 : 						if (g_bUseAlpha) {
; 1777 : 							*pDestSys32 = pixel;
; 1778 : 							*(pDestSys32 + 1) = pixel;
; 1779 : 							*(pDestSys32 + w - 1) = pixel;
; 1780 : 							*(pDestSys32 + w - 2) = pixel;
; 1781 : 							pDestSys32 += surfacePitchsys;
; 1782 : 						}
; 1783 : #endif
; 1784 : 					}
; 1785 : 				}
; 1786 : 				else
; 1787 : #endif
; 1788 : 					if (displayBpp == 16) {

  002c7	8b d7		 mov	 edx, edi
  002c9	0f af d1	 imul	 edx, ecx
  002cc	89 95 70 ff ff
	ff		 mov	 DWORD PTR _bottom$3$[ebp], edx
  002d2	83 f8 10	 cmp	 eax, 16			; 00000010H
  002d5	0f 85 c5 00 00
	00		 jne	 $LN71@DrawBox

; 1789 : 						// 16 Bit Color
; 1790 : 
; 1791 : 						// ??????????
; 1792 : 						bottom = (h - 1) * surfacePitch;
; 1793 : #ifdef _READ16BITBMP
; 1794 : 						bottomSys = (h - 1) * surfacePitchsys;
; 1795 : #endif
; 1796 : 
; 1797 : 						pixel = highColorPalette[color];

  002db	0f b6 c3	 movzx	 eax, bl
  002de	0f b7 0c 45 00
	00 00 00	 movzx	 ecx, WORD PTR ?highColorPalette@@3PAGA[eax*2]

; 1798 : 
; 1799 : 						// ????
; 1800 : 						for (i = 0; i < w - 2; i++) {

  002e6	33 d2		 xor	 edx, edx
  002e8	89 95 7c ff ff
	ff		 mov	 DWORD PTR _i$8[ebp], edx
  002ee	8b 9d 64 ff ff
	ff		 mov	 ebx, DWORD PTR _pDest2$4[ebp]
$LL10@DrawBox:
  002f4	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]
  002f7	3b d0		 cmp	 edx, eax
  002f9	7d 2e		 jge	 SHORT $LN9@DrawBox

; 1801 : 							// ????
; 1802 : 							*(pDest2 + i) = pixel;

  002fb	66 89 0c 53	 mov	 WORD PTR [ebx+edx*2], cx

; 1803 : 							*(pDest2 + surfacePitch + i) = pixel;

  002ff	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  00302	66 89 0c 43	 mov	 WORD PTR [ebx+eax*2], cx

; 1804 : 							// ?????
; 1805 : 							*(pDest2 + bottom - surfacePitch + i) = pixel;

  00306	8b c2		 mov	 eax, edx
  00308	2b c7		 sub	 eax, edi
  0030a	03 85 70 ff ff
	ff		 add	 eax, DWORD PTR _bottom$3$[ebp]
  00310	66 89 0c 43	 mov	 WORD PTR [ebx+eax*2], cx

; 1806 : 							*(pDest2 + bottom + i) = pixel;

  00314	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _bottom$3$[ebp]
  0031a	03 c2		 add	 eax, edx
  0031c	66 89 0c 43	 mov	 WORD PTR [ebx+eax*2], cx

; 1798 : 
; 1799 : 						// ????
; 1800 : 						for (i = 0; i < w - 2; i++) {

  00320	42		 inc	 edx
  00321	89 95 7c ff ff
	ff		 mov	 DWORD PTR _i$8[ebp], edx
  00327	eb cb		 jmp	 SHORT $LL10@DrawBox
$LN9@DrawBox:

; 1807 : #ifdef _READ16BITBMP
; 1808 : 							if (g_bUseAlpha) {
; 1809 : 								*(pDestSys + i) = pixel;
; 1810 : 								*(pDestSys + surfacePitchsys + i) = pixel;
; 1811 : 								*(pDestSys + bottomSys - surfacePitchsys + i) = pixel;
; 1812 : 								*(pDestSys + bottomSys + i) = pixel;
; 1813 : 							}
; 1814 : #endif
; 1815 : 						}
; 1816 : 
; 1817 : 						// ???
; 1818 : 						*(pDest2 + surfacePitch + surfacePitch + 1) = pixel;					// ?

  00329	66 89 4c bb 02	 mov	 WORD PTR [ebx+edi*4+2], cx

; 1819 : 						*(pDest2 + surfacePitch + surfacePitch + w - 4) = pixel;				// ?

  0032e	8d 04 7e	 lea	 eax, DWORD PTR [esi+edi*2]
  00331	66 89 4c 43 f8	 mov	 WORD PTR [ebx+eax*2-8], cx

; 1820 : 						*(pDest2 + bottom - (surfacePitch + surfacePitch) + 1) = pixel;		// ??

  00336	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  00339	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv1166[ebp], eax
  0033f	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _bottom$3$[ebp]
  00345	8b c2		 mov	 eax, edx
  00347	2b 85 68 ff ff
	ff		 sub	 eax, DWORD PTR tv1166[ebp]
  0034d	66 89 4c 43 02	 mov	 WORD PTR [ebx+eax*2+2], cx

; 1821 : 						*(pDest2 + bottom - (surfacePitch + surfacePitch) + w - 4) = pixel;	// ??

  00352	8d 04 7d 04 00
	00 00		 lea	 eax, DWORD PTR [edi*2+4]
  00359	2b d0		 sub	 edx, eax
  0035b	03 d6		 add	 edx, esi
  0035d	66 89 0c 53	 mov	 WORD PTR [ebx+edx*2], cx

; 1822 : 
; 1823 : 																							// ???????????????
; 1824 : 						pDest2 += surfacePitch - 1;

  00361	8d 53 fe	 lea	 edx, DWORD PTR [ebx-2]
  00364	8d 14 7a	 lea	 edx, DWORD PTR [edx+edi*2]

; 1825 : #ifdef _READ16BITBMP
; 1826 : 						if (g_bUseAlpha) {
; 1827 : 							*(pDestSys + surfacePitchsys + surfacePitchsys + 1) = pixel;
; 1828 : 							*(pDestSys + surfacePitchsys + surfacePitchsys + w - 4) = pixel;
; 1829 : 							*(pDestSys + bottomSys - (surfacePitchsys + surfacePitchsys) + 1) = pixel;
; 1830 : 							*(pDestSys + bottomSys - (surfacePitchsys + surfacePitchsys) + w - 4) = pixel;
; 1831 : 							pDestSys += surfacePitchsys - 1;
; 1832 : 						}
; 1833 : #endif
; 1834 : 
; 1835 : 						// ???
; 1836 : 						for (i = 0; i < h - 2; i++) {

  00367	33 ff		 xor	 edi, edi
$LN148@DrawBox:
  00369	89 95 64 ff ff
	ff		 mov	 DWORD PTR _pDest2$4[ebp], edx
  0036f	89 bd 7c ff ff
	ff		 mov	 DWORD PTR _i$8[ebp], edi
  00375	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _h$1$[ebp]
  0037b	83 c0 fe	 add	 eax, -2			; fffffffeH
  0037e	3b f8		 cmp	 edi, eax
  00380	0f 8d 04 03 00
	00		 jge	 $LN83@DrawBox

; 1837 : 							// ?????
; 1838 : 							*pDest2 = pixel;

  00386	66 89 0a	 mov	 WORD PTR [edx], cx

; 1839 : 							*(pDest2 + 1) = pixel;

  00389	66 89 4a 02	 mov	 WORD PTR [edx+2], cx

; 1840 : 							// ?????
; 1841 : 							*(pDest2 + w - 1) = pixel;

  0038d	66 89 4c 72 fe	 mov	 WORD PTR [edx+esi*2-2], cx

; 1842 : 							*(pDest2 + w - 2) = pixel;

  00392	66 89 4c 72 fc	 mov	 WORD PTR [edx+esi*2-4], cx

; 1843 : 							// ???????????????
; 1844 : 							pDest2 += surfacePitch;

  00397	03 95 68 ff ff
	ff		 add	 edx, DWORD PTR tv1166[ebp]

; 1825 : #ifdef _READ16BITBMP
; 1826 : 						if (g_bUseAlpha) {
; 1827 : 							*(pDestSys + surfacePitchsys + surfacePitchsys + 1) = pixel;
; 1828 : 							*(pDestSys + surfacePitchsys + surfacePitchsys + w - 4) = pixel;
; 1829 : 							*(pDestSys + bottomSys - (surfacePitchsys + surfacePitchsys) + 1) = pixel;
; 1830 : 							*(pDestSys + bottomSys - (surfacePitchsys + surfacePitchsys) + w - 4) = pixel;
; 1831 : 							pDestSys += surfacePitchsys - 1;
; 1832 : 						}
; 1833 : #endif
; 1834 : 
; 1835 : 						// ???
; 1836 : 						for (i = 0; i < h - 2; i++) {

  0039d	47		 inc	 edi
  0039e	eb c9		 jmp	 SHORT $LN148@DrawBox
$LN71@DrawBox:

; 1845 : #ifdef _READ16BITBMP
; 1846 : 							if (g_bUseAlpha) {
; 1847 : 								*pDestSys = pixel;
; 1848 : 								*(pDestSys + 1) = pixel;
; 1849 : 								*(pDestSys + w - 1) = pixel;
; 1850 : 								*(pDestSys + w - 2) = pixel;
; 1851 : 								pDestSys += surfacePitchsys;
; 1852 : 							}
; 1853 : #endif
; 1854 : 						}
; 1855 : 					}
; 1856 : 					else {
; 1857 : 						// 8 Bit Color
; 1858 : 
; 1859 : 						// ?????????
; 1860 : 						bottom = (h - 1) * surfacePitch;
; 1861 : 
; 1862 : 						// ????
; 1863 : 						for (i = 0; i < w - 2; i++) {

  003a0	33 c9		 xor	 ecx, ecx
$LN149@DrawBox:
  003a2	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _i$8[ebp], ecx
  003a8	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]
  003ab	3b c8		 cmp	 ecx, eax
  003ad	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _pDest$6[ebp]
  003b3	7d 25		 jge	 SHORT $LN15@DrawBox

; 1864 : 							// ????
; 1865 : 							*(pDest + i) = color;

  003b5	03 c1		 add	 eax, ecx
  003b7	88 18		 mov	 BYTE PTR [eax], bl

; 1866 : 							*(pDest + i + surfacePitch) = color;

  003b9	88 1c 38	 mov	 BYTE PTR [eax+edi], bl

; 1867 : 							// ?????
; 1868 : 							*(pDest + i + bottom) = color;

  003bc	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  003bf	8b b5 74 ff ff
	ff		 mov	 esi, DWORD PTR _pDest$6[ebp]
  003c5	88 1c 30	 mov	 BYTE PTR [eax+esi], bl

; 1869 : 							*(pDest + i + bottom - surfacePitch) = color;

  003c8	8b c1		 mov	 eax, ecx
  003ca	2b c7		 sub	 eax, edi
  003cc	03 c2		 add	 eax, edx
  003ce	88 1c 30	 mov	 BYTE PTR [eax+esi], bl

; 1870 : 						}

  003d1	8b b5 60 ff ff
	ff		 mov	 esi, DWORD PTR _w$1$[ebp]

; 1845 : #ifdef _READ16BITBMP
; 1846 : 							if (g_bUseAlpha) {
; 1847 : 								*pDestSys = pixel;
; 1848 : 								*(pDestSys + 1) = pixel;
; 1849 : 								*(pDestSys + w - 1) = pixel;
; 1850 : 								*(pDestSys + w - 2) = pixel;
; 1851 : 								pDestSys += surfacePitchsys;
; 1852 : 							}
; 1853 : #endif
; 1854 : 						}
; 1855 : 					}
; 1856 : 					else {
; 1857 : 						// 8 Bit Color
; 1858 : 
; 1859 : 						// ?????????
; 1860 : 						bottom = (h - 1) * surfacePitch;
; 1861 : 
; 1862 : 						// ????
; 1863 : 						for (i = 0; i < w - 2; i++) {

  003d7	41		 inc	 ecx
  003d8	eb c8		 jmp	 SHORT $LN149@DrawBox
$LN15@DrawBox:

; 1871 : 
; 1872 : 						// ???
; 1873 : 						*(pDest + surfacePitch + surfacePitch + 1) = color;					// ?

  003da	8d 0c 3f	 lea	 ecx, DWORD PTR [edi+edi]
  003dd	88 5c 01 01	 mov	 BYTE PTR [ecx+eax+1], bl

; 1874 : 						*(pDest + surfacePitch + surfacePitch + w - 4) = color;				// ?

  003e1	8d 04 78	 lea	 eax, DWORD PTR [eax+edi*2]
  003e4	88 5c 30 fc	 mov	 BYTE PTR [eax+esi-4], bl

; 1875 : 						*(pDest + bottom - (surfacePitch + surfacePitch) + 1) = color;		// ??

  003e8	8b c2		 mov	 eax, edx
  003ea	2b c1		 sub	 eax, ecx
  003ec	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _pDest$6[ebp]
  003f2	88 5c 08 01	 mov	 BYTE PTR [eax+ecx+1], bl

; 1876 : 						*(pDest + bottom - (surfacePitch + surfacePitch) + w - 4) = color;	// ??

  003f6	8d 04 7d 04 00
	00 00		 lea	 eax, DWORD PTR [edi*2+4]
  003fd	2b d0		 sub	 edx, eax
  003ff	03 d1		 add	 edx, ecx
  00401	88 1c 32	 mov	 BYTE PTR [edx+esi], bl

; 1877 : 
; 1878 : 																							// ???????????????
; 1879 : 						pDest += surfacePitch - 1;

  00404	49		 dec	 ecx
  00405	03 cf		 add	 ecx, edi

; 1880 : 
; 1881 : 						// ???
; 1882 : 						for (i = 0; i < h - 2; i++) {

  00407	33 d2		 xor	 edx, edx
$LN150@DrawBox:
  00409	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _pDest$6[ebp], ecx
  0040f	89 95 7c ff ff
	ff		 mov	 DWORD PTR _i$8[ebp], edx
  00415	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _h$1$[ebp]
  0041b	83 c0 fe	 add	 eax, -2			; fffffffeH
  0041e	3b d0		 cmp	 edx, eax
  00420	0f 8d 64 02 00
	00		 jge	 $LN83@DrawBox

; 1883 : 							// ?????
; 1884 : 							*pDest = color;

  00426	88 19		 mov	 BYTE PTR [ecx], bl

; 1885 : 							*(pDest + 1) = color;

  00428	88 59 01	 mov	 BYTE PTR [ecx+1], bl

; 1886 : 							// ?????
; 1887 : 							*(pDest + w - 1) = color;

  0042b	88 5c 31 ff	 mov	 BYTE PTR [ecx+esi-1], bl

; 1888 : 							*(pDest + w - 2) = color;

  0042f	88 5c 31 fe	 mov	 BYTE PTR [ecx+esi-2], bl

; 1889 : 							// ???????????????
; 1890 : 							pDest += surfacePitch;

  00433	03 cf		 add	 ecx, edi

; 1880 : 
; 1881 : 						// ???
; 1882 : 						for (i = 0; i < h - 2; i++) {

  00435	42		 inc	 edx
  00436	eb d1		 jmp	 SHORT $LN150@DrawBox
$LN67@DrawBox:

; 1891 : 						}
; 1892 : 					}
; 1893 : 			}
; 1894 : 			else if (fill == 1) {	// ??????

  00438	83 7d 10 01	 cmp	 DWORD PTR _fill$[ebp], 1
  0043c	0f 85 ba 01 00
	00		 jne	 $LN73@DrawBox

; 1895 : #ifdef _HI_COLOR_32
; 1896 : 				if (displayBpp == 32) {

  00442	0f b6 db	 movzx	 ebx, bl
  00445	89 9d 68 ff ff
	ff		 mov	 DWORD PTR tv1169[ebp], ebx
  0044b	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR ?displayBpp@@3HA, 32 ; displayBpp, 00000020H
  00452	0f 85 a0 00 00
	00		 jne	 $LN75@DrawBox

; 1897 : 					int pixel;
; 1898 : 					surfacePitch = surfacePitch >> 1;

  00458	d1 ff		 sar	 edi, 1
  0045a	89 bd 5c ff ff
	ff		 mov	 DWORD PTR _surfacePitch$3[ebp], edi

; 1899 : 					// 32 Bit Color
; 1900 : 					pDest32 = (int *)ddsd.lpSurface + rect->top * surfacePitch + rect->left + 1;

  00460	0f af d7	 imul	 edx, edi
  00463	03 95 70 ff ff
	ff		 add	 edx, DWORD PTR tv1154[ebp]
  00469	8b 45 a4	 mov	 eax, DWORD PTR _ddsd$9[ebp+36]
  0046c	83 c0 04	 add	 eax, 4
  0046f	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00472	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _pDest32$5[ebp], ecx

; 1901 : 					pixel = highColor32Palette[color];

  00478	8b 14 9d 00 00
	00 00		 mov	 edx, DWORD PTR ?highColor32Palette@@3PAIA[ebx*4]

; 1902 : 
; 1903 : 					// ???????
; 1904 : 					for (i = 0; i < w - 2; i++) {

  0047f	33 c0		 xor	 eax, eax
$LN151@DrawBox:
  00481	89 85 7c ff ff
	ff		 mov	 DWORD PTR _i$8[ebp], eax
  00487	8d 5e fe	 lea	 ebx, DWORD PTR [esi-2]
  0048a	3b c3		 cmp	 eax, ebx
  0048c	7d 06		 jge	 SHORT $LN21@DrawBox

; 1905 : 						*(pDest32 + i) = pixel;

  0048e	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 1902 : 
; 1903 : 					// ???????
; 1904 : 					for (i = 0; i < w - 2; i++) {

  00491	40		 inc	 eax
  00492	eb ed		 jmp	 SHORT $LN151@DrawBox
$LN21@DrawBox:

; 1906 : #ifdef _READ16BITBMP
; 1907 : 						if (g_bUseAlpha) {
; 1908 : 							*(pDestSys32 + i) = pixel;
; 1909 : 						}
; 1910 : #endif
; 1911 : 					}
; 1912 : 					pDest32 += surfacePitch;

  00494	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  0049b	89 85 60 ff ff
	ff		 mov	 DWORD PTR tv1183[ebp], eax
  004a1	03 c8		 add	 ecx, eax

; 1913 : #ifdef _READ16BITBMP
; 1914 : 					if (g_bUseAlpha) {
; 1915 : 						pDestSys32 += surfacePitchsys;
; 1916 : 					}
; 1917 : #endif
; 1918 : 					for (i = 0; i < h - 2; i++) {

  004a3	33 ff		 xor	 edi, edi
$LN153@DrawBox:
  004a5	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _pDest32$5[ebp], ecx
  004ab	89 bd 7c ff ff
	ff		 mov	 DWORD PTR _i$8[ebp], edi
  004b1	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _h$1$[ebp]
  004b7	83 c0 fe	 add	 eax, -2			; fffffffeH
  004ba	3b f8		 cmp	 edi, eax
  004bc	7d 1b		 jge	 SHORT $LN24@DrawBox

; 1919 : 						for (j = 0; j < w; j++) {

  004be	33 c0		 xor	 eax, eax
$LN152@DrawBox:
  004c0	89 85 58 ff ff
	ff		 mov	 DWORD PTR _j$2[ebp], eax
  004c6	3b c6		 cmp	 eax, esi
  004c8	7d 06		 jge	 SHORT $LN27@DrawBox

; 1920 : 							*(pDest32 + j) = pixel;

  004ca	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 1919 : 						for (j = 0; j < w; j++) {

  004cd	40		 inc	 eax
  004ce	eb f0		 jmp	 SHORT $LN152@DrawBox
$LN27@DrawBox:

; 1921 : #ifdef _READ16BITBMP
; 1922 : 							if (g_bUseAlpha) *(pDestSys32 + j) = pixel;
; 1923 : #endif
; 1924 : 						}
; 1925 : 						pDest32 += surfacePitch;

  004d0	03 8d 60 ff ff
	ff		 add	 ecx, DWORD PTR tv1183[ebp]

; 1913 : #ifdef _READ16BITBMP
; 1914 : 					if (g_bUseAlpha) {
; 1915 : 						pDestSys32 += surfacePitchsys;
; 1916 : 					}
; 1917 : #endif
; 1918 : 					for (i = 0; i < h - 2; i++) {

  004d6	47		 inc	 edi
  004d7	eb cc		 jmp	 SHORT $LN153@DrawBox
$LN24@DrawBox:

; 1926 : #ifdef _READ16BITBMP
; 1927 : 						if (g_bUseAlpha) pDestSys32 += surfacePitchsys;
; 1928 : #endif
; 1929 : 					}
; 1930 : 					pDest32++;

  004d9	83 c1 04	 add	 ecx, 4
  004dc	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _pDest32$5[ebp], ecx

; 1931 : #ifdef _READ16BITBMP
; 1932 : 					if (g_bUseAlpha) pDestSys32++;
; 1933 : #endif
; 1934 : 					for (i = 0; i < w - 2; i++) {

  004e2	33 c0		 xor	 eax, eax
$LN154@DrawBox:
  004e4	89 85 7c ff ff
	ff		 mov	 DWORD PTR _i$8[ebp], eax
  004ea	3b c3		 cmp	 eax, ebx
  004ec	0f 8d 98 01 00
	00		 jge	 $LN83@DrawBox

; 1935 : 						*(pDest32 + i) = pixel;

  004f2	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 1931 : #ifdef _READ16BITBMP
; 1932 : 					if (g_bUseAlpha) pDestSys32++;
; 1933 : #endif
; 1934 : 					for (i = 0; i < w - 2; i++) {

  004f5	40		 inc	 eax
  004f6	eb ec		 jmp	 SHORT $LN154@DrawBox
$LN75@DrawBox:

; 1936 : #ifdef _READ16BITBMP
; 1937 : 						if (g_bUseAlpha) *(pDestSys32 + i) = pixel;
; 1938 : #endif
; 1939 : 					}
; 1940 : 				}
; 1941 : 				else
; 1942 : #endif
; 1943 : 					if (displayBpp == 16) {

  004f8	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR ?displayBpp@@3HA, 16 ; displayBpp, 00000010H
  004ff	0f 85 83 00 00
	00		 jne	 $LN77@DrawBox

; 1944 : 						pixel = highColorPalette[color];

  00505	0f b7 14 5d 00
	00 00 00	 movzx	 edx, WORD PTR ?highColorPalette@@3PAGA[ebx*2]

; 1945 : 						for (i = 0; i < w - 2; i++) {

  0050d	33 c0		 xor	 eax, eax
$LN155@DrawBox:
  0050f	89 85 7c ff ff
	ff		 mov	 DWORD PTR _i$8[ebp], eax
  00515	8d 5e fe	 lea	 ebx, DWORD PTR [esi-2]
  00518	3b c3		 cmp	 eax, ebx
  0051a	7d 07		 jge	 SHORT $LN33@DrawBox

; 1946 : 							*(pDest2 + i) = pixel;

  0051c	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 1945 : 						for (i = 0; i < w - 2; i++) {

  00520	40		 inc	 eax
  00521	eb ec		 jmp	 SHORT $LN155@DrawBox
$LN33@DrawBox:

; 1947 : #ifdef _READ16BITBMP
; 1948 : 							if (g_bUseAlpha) {
; 1949 : 								*(pDestSys + i) = pixel;
; 1950 : 							}
; 1951 : #endif
; 1952 : 						}
; 1953 : 						pDest2 += surfacePitch - 1;

  00523	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  00526	89 85 60 ff ff
	ff		 mov	 DWORD PTR tv1173[ebp], eax
  0052c	83 c1 fe	 add	 ecx, -2			; fffffffeH
  0052f	03 c8		 add	 ecx, eax

; 1954 : #ifdef _READ16BITBMP
; 1955 : 						if (g_bUseAlpha) {
; 1956 : 							pDestSys += surfacePitchsys - 1;
; 1957 : 						}
; 1958 : #endif
; 1959 : 						for (i = 0; i < h - 2; i++) {

  00531	33 ff		 xor	 edi, edi
$LN157@DrawBox:
  00533	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _pDest2$4[ebp], ecx
  00539	89 bd 7c ff ff
	ff		 mov	 DWORD PTR _i$8[ebp], edi
  0053f	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _h$1$[ebp]
  00545	83 c0 fe	 add	 eax, -2			; fffffffeH
  00548	3b f8		 cmp	 edi, eax
  0054a	7d 1c		 jge	 SHORT $LN36@DrawBox

; 1960 : 							for (j = 0; j < w; j++) {

  0054c	33 c0		 xor	 eax, eax
$LN156@DrawBox:
  0054e	89 85 58 ff ff
	ff		 mov	 DWORD PTR _j$2[ebp], eax
  00554	3b c6		 cmp	 eax, esi
  00556	7d 07		 jge	 SHORT $LN39@DrawBox

; 1961 : 								*(pDest2 + j) = pixel;

  00558	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 1960 : 							for (j = 0; j < w; j++) {

  0055c	40		 inc	 eax
  0055d	eb ef		 jmp	 SHORT $LN156@DrawBox
$LN39@DrawBox:

; 1962 : #ifdef _READ16BITBMP
; 1963 : 								if (g_bUseAlpha) *(pDestSys + j) = pixel;
; 1964 : #endif
; 1965 : 							}
; 1966 : 							pDest2 += surfacePitch;

  0055f	03 8d 60 ff ff
	ff		 add	 ecx, DWORD PTR tv1173[ebp]

; 1954 : #ifdef _READ16BITBMP
; 1955 : 						if (g_bUseAlpha) {
; 1956 : 							pDestSys += surfacePitchsys - 1;
; 1957 : 						}
; 1958 : #endif
; 1959 : 						for (i = 0; i < h - 2; i++) {

  00565	47		 inc	 edi
  00566	eb cb		 jmp	 SHORT $LN157@DrawBox
$LN36@DrawBox:

; 1967 : #ifdef _READ16BITBMP
; 1968 : 							if (g_bUseAlpha) pDestSys += surfacePitchsys;
; 1969 : #endif
; 1970 : 						}
; 1971 : 						pDest2++;

  00568	83 c1 02	 add	 ecx, 2
  0056b	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _pDest2$4[ebp], ecx

; 1972 : #ifdef _READ16BITBMP
; 1973 : 						if (g_bUseAlpha) pDestSys++;
; 1974 : #endif
; 1975 : 						for (i = 0; i < w - 2; i++) {

  00571	33 c0		 xor	 eax, eax
$LN158@DrawBox:
  00573	89 85 7c ff ff
	ff		 mov	 DWORD PTR _i$8[ebp], eax
  00579	3b c3		 cmp	 eax, ebx
  0057b	0f 8d 09 01 00
	00		 jge	 $LN83@DrawBox

; 1976 : 							*(pDest2 + i) = pixel;

  00581	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 1972 : #ifdef _READ16BITBMP
; 1973 : 						if (g_bUseAlpha) pDestSys++;
; 1974 : #endif
; 1975 : 						for (i = 0; i < w - 2; i++) {

  00585	40		 inc	 eax
  00586	eb eb		 jmp	 SHORT $LN158@DrawBox
$LN77@DrawBox:

; 1977 : #ifdef _READ16BITBMP
; 1978 : 							if (g_bUseAlpha) *(pDestSys + i) = pixel;
; 1979 : #endif
; 1980 : 						}
; 1981 : 					}
; 1982 : 					else {
; 1983 : 						pDest++;

  00588	40		 inc	 eax
  00589	89 85 74 ff ff
	ff		 mov	 DWORD PTR _pDest$6[ebp], eax

; 1984 : 						memset(pDest, color, w - 2);

  0058f	8d 4e fe	 lea	 ecx, DWORD PTR [esi-2]
  00592	89 8d 60 ff ff
	ff		 mov	 DWORD PTR tv1178[ebp], ecx
  00598	51		 push	 ecx
  00599	53		 push	 ebx
  0059a	50		 push	 eax
  0059b	e8 00 00 00 00	 call	 _memset
  005a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1985 : 						pDest += surfacePitch - 1;

  005a3	8b 9d 74 ff ff
	ff		 mov	 ebx, DWORD PTR _pDest$6[ebp]
  005a9	4b		 dec	 ebx
  005aa	03 df		 add	 ebx, edi
  005ac	89 9d 74 ff ff
	ff		 mov	 DWORD PTR _pDest$6[ebp], ebx

; 1986 : 						for (i = 0; i < h - 2; i++) {

  005b2	33 c9		 xor	 ecx, ecx
$LN159@DrawBox:
  005b4	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _i$8[ebp], ecx
  005ba	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _h$1$[ebp]
  005c0	83 c0 fe	 add	 eax, -2			; fffffffeH
  005c3	3b c8		 cmp	 ecx, eax
  005c5	7d 21		 jge	 SHORT $LN45@DrawBox

; 1987 : 							memset(pDest, color, w);

  005c7	56		 push	 esi
  005c8	ff b5 68 ff ff
	ff		 push	 DWORD PTR tv1169[ebp]
  005ce	53		 push	 ebx
  005cf	e8 00 00 00 00	 call	 _memset
  005d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1988 : 							pDest += surfacePitch;

  005d7	03 df		 add	 ebx, edi
  005d9	89 9d 74 ff ff
	ff		 mov	 DWORD PTR _pDest$6[ebp], ebx

; 1986 : 						for (i = 0; i < h - 2; i++) {

  005df	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _i$8[ebp]
  005e5	41		 inc	 ecx
  005e6	eb cc		 jmp	 SHORT $LN159@DrawBox
$LN45@DrawBox:

; 1989 : 						}
; 1990 : 						memset(pDest + 1, color, w - 2);

  005e8	ff b5 60 ff ff
	ff		 push	 DWORD PTR tv1178[ebp]
  005ee	ff b5 68 ff ff
	ff		 push	 DWORD PTR tv1169[ebp]
  005f4	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]

; 1991 : 					}
; 1992 : 			}

  005f7	e9 85 00 00 00	 jmp	 $LN160@DrawBox
$LN73@DrawBox:

; 1993 : 			else if (fill == 2) {

  005fc	83 7d 10 02	 cmp	 DWORD PTR _fill$[ebp], 2
  00600	0f 85 84 00 00
	00		 jne	 $LN83@DrawBox

; 1994 : #ifdef _HI_COLOR_32
; 1995 : 				if (displayBpp == 32) {

  00606	0f b6 db	 movzx	 ebx, bl
  00609	89 9d 78 ff ff
	ff		 mov	 DWORD PTR tv1140[ebp], ebx
  0060f	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?displayBpp@@3HA ; displayBpp
  00615	83 fb 20	 cmp	 ebx, 32			; 00000020H
  00618	75 3f		 jne	 SHORT $LN80@DrawBox

; 1996 : 					int pixel;
; 1997 : 					surfacePitch = surfacePitch >> 1;

  0061a	d1 ff		 sar	 edi, 1
  0061c	89 bd 5c ff ff
	ff		 mov	 DWORD PTR _surfacePitch$3[ebp], edi

; 1998 : 					pixel = highColor32Palette[color];

  00622	8b 9d 78 ff ff
	ff		 mov	 ebx, DWORD PTR tv1140[ebp]
  00628	8b 1c 9d 00 00
	00 00		 mov	 ebx, DWORD PTR ?highColor32Palette@@3PAIA[ebx*4]

; 1999 : 					pDest32 = (int *)ddsd.lpSurface + rect->top * surfacePitch + rect->left + 1;

  0062f	0f af d7	 imul	 edx, edi
  00632	03 95 70 ff ff
	ff		 add	 edx, DWORD PTR tv1154[ebp]
  00638	8b 4d a4	 mov	 ecx, DWORD PTR _ddsd$9[ebp+36]
  0063b	83 c1 04	 add	 ecx, 4
  0063e	8d 0c 91	 lea	 ecx, DWORD PTR [ecx+edx*4]
  00641	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _pDest32$5[ebp], ecx

; 2000 : 					for (i = 0; i < w; i++) {

  00647	33 c0		 xor	 eax, eax
$LN161@DrawBox:
  00649	89 85 7c ff ff
	ff		 mov	 DWORD PTR _i$8[ebp], eax
  0064f	3b c6		 cmp	 eax, esi
  00651	7d 37		 jge	 SHORT $LN83@DrawBox

; 2001 : 						*(pDest32 + i) = pixel;

  00653	89 1c 81	 mov	 DWORD PTR [ecx+eax*4], ebx

; 2000 : 					for (i = 0; i < w; i++) {

  00656	40		 inc	 eax
  00657	eb f0		 jmp	 SHORT $LN161@DrawBox
$LN80@DrawBox:

; 2002 : #ifdef _READ16BITBMP
; 2003 : 						if (g_bUseAlpha) *(pDestSys32 + i) = pixel;
; 2004 : #endif
; 2005 : 					}
; 2006 : 				}
; 2007 : 				else
; 2008 : #endif
; 2009 : 					if (displayBpp == 16) {

  00659	83 fb 10	 cmp	 ebx, 16			; 00000010H
  0065c	8b 9d 78 ff ff
	ff		 mov	 ebx, DWORD PTR tv1140[ebp]
  00662	75 1b		 jne	 SHORT $LN82@DrawBox

; 2010 : 						pixel = highColorPalette[color];

  00664	0f b7 14 5d 00
	00 00 00	 movzx	 edx, WORD PTR ?highColorPalette@@3PAGA[ebx*2]

; 2011 : 						for (i = 0; i < w; i++) {

  0066c	33 c0		 xor	 eax, eax
$LN162@DrawBox:
  0066e	89 85 7c ff ff
	ff		 mov	 DWORD PTR _i$8[ebp], eax
  00674	3b c6		 cmp	 eax, esi
  00676	7d 12		 jge	 SHORT $LN83@DrawBox

; 2012 : 							*(pDest2 + i) = pixel;

  00678	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 2011 : 						for (i = 0; i < w; i++) {

  0067c	40		 inc	 eax
  0067d	eb ef		 jmp	 SHORT $LN162@DrawBox
$LN82@DrawBox:

; 2013 : #ifdef _READ16BITBMP
; 2014 : 							if (g_bUseAlpha) *(pDestSys + i) = pixel;
; 2015 : #endif
; 2016 : 						}
; 2017 : 					}
; 2018 : 					else {
; 2019 : 						memset(pDest, color, w);

  0067f	56		 push	 esi
  00680	53		 push	 ebx
$LN160@DrawBox:

; 2020 : 					}
; 2021 : 			}
; 2022 : 			if (lpDraw->lpBACKBUFFER->Unlock(NULL) != DD_OK) {

  00681	50		 push	 eax
  00682	e8 00 00 00 00	 call	 _memset
  00687	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN83@DrawBox:
  0068a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0068f	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00692	8b 08		 mov	 ecx, DWORD PTR [eax]
  00694	6a 00		 push	 0
  00696	50		 push	 eax
  00697	ff 91 80 00 00
	00		 call	 DWORD PTR [ecx+128]

; 2023 : 				return;
; 2024 : 			}
; 2025 : #ifdef _READ16BITBMP
; 2026 : 			if (g_bUseAlpha) if (lpDraw->lpBACKBUFFERSYS->Unlock(NULL) != DD_OK) return;
; 2027 : #endif
; 2028 : 
; 2029 : 			return;

  0069d	eb 0d		 jmp	 SHORT $LN88@DrawBox
__catch$?DrawBox@@YAXPAUtagRECT@@EH@Z$0:

; 2030 : 	}
; 2031 : 	catch (...)
; 2032 : 	{
; 2033 : 
; 2034 : 	}

  0069f	b8 00 00 00 00	 mov	 eax, $LN89@DrawBox
  006a4	c3		 ret	 0
$LN89@DrawBox:
  006a5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN88@DrawBox:

; 2035 : 
; 2036 : 
; 2037 : }

  006ac	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  006af	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  006b6	59		 pop	 ecx
  006b7	5f		 pop	 edi
  006b8	5e		 pop	 esi
  006b9	5b		 pop	 ebx
  006ba	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006bd	33 cd		 xor	 ecx, ebp
  006bf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006c4	8b e5		 mov	 esp, ebp
  006c6	5d		 pop	 ebp
  006c7	c3		 ret	 0
  006c8	cc		 int	 3
  006c9	cc		 int	 3
  006ca	cc		 int	 3
  006cb	cc		 int	 3
  006cc	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?DrawBox@@YAXPAUtagRECT@@EH@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 54 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-172]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?DrawBox@@YAXPAUtagRECT@@EH@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?DrawBox@@YAXPAUtagRECT@@EH@Z ENDP			; DrawBox
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?DrawDebugLine@@YAXE@Z
_TEXT	SEGMENT
_pDest$ = -172						; size = 4
_surfacePitch$3$ = -168					; size = 4
_pDest2$ = -164						; size = 4
_pDest32$2 = -160					; size = 4
_l$ = -156						; size = 4
_k$ = -152						; size = 4
_j$ = -148						; size = 4
_m$ = -144						; size = 4
_i$ = -140						; size = 4
_surfacePitch$2$ = -136					; size = 4
_surfacePitch$1$ = -136					; size = 4
_k$1$ = -136						; size = 4
_color$GSCopy$1$ = -129					; size = 1
_ddsd$ = -128						; size = 108
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_color$ = 8						; size = 1
?DrawDebugLine@@YAXE@Z PROC				; DrawDebugLine, COMDAT

; 2721 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?DrawDebugLine@@YAXE@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8a 45 08	 mov	 al, BYTE PTR _color$[ebp]
  00034	88 85 7f ff ff
	ff		 mov	 BYTE PTR _color$GSCopy$1$[ebp], al

; 2722 : 	DDSURFACEDESC ddsd;	// ??????
; 2723 : 	char *pDest;		// ??????
; 2724 : 	short *pDest2;		// ????????????
; 2725 : 	int surfacePitch;	// ??????????
; 2726 : 	int i, j, k, l, m;
; 2727 : 	short pixel;
; 2728 : 
; 2729 : 	try

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 2730 : 	{
; 2731 : 		// ????????????
; 2732 : 		if (WindowMode) return;

  00041	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?WindowMode@@3HA, 0 ; WindowMode
  00048	0f 85 d3 01 00
	00		 jne	 $LN29@DrawDebugL

; 2733 : 
; 2734 : 		// ?????
; 2735 : 		ZeroMemory(&ddsd, sizeof(DDSURFACEDESC));

  0004e	6a 6c		 push	 108			; 0000006cH
  00050	6a 00		 push	 0
  00052	8d 45 80	 lea	 eax, DWORD PTR _ddsd$[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 _memset
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2736 : 		ddsd.dwSize = sizeof(DDSURFACEDESC);

  0005e	c7 45 80 6c 00
	00 00		 mov	 DWORD PTR _ddsd$[ebp], 108 ; 0000006cH

; 2737 : 
; 2738 : 		// ?????????????????( ?? ddsd ??????? )
; 2739 : 		if (lpDraw->lpFRONTBUFFER->Lock(NULL, &ddsd, DDLOCK_WAIT, NULL) != DD_OK) {

  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0006a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0006d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006f	6a 00		 push	 0
  00071	6a 01		 push	 1
  00073	8d 55 80	 lea	 edx, DWORD PTR _ddsd$[ebp]
  00076	52		 push	 edx
  00077	6a 00		 push	 0
  00079	50		 push	 eax
  0007a	ff 51 64	 call	 DWORD PTR [ecx+100]
  0007d	85 c0		 test	 eax, eax
  0007f	0f 85 9c 01 00
	00		 jne	 $LN29@DrawDebugL

; 2740 : 			//MessageBoxNew( hWnd, "Surface的lock失败！", "확인", MB_OK | MB_ICONSTOP );
; 2741 : 			return;
; 2742 : 		}
; 2743 : 		//??
; 2744 : 		j = lpDraw->xSize;

  00085	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0008a	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  00090	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _j$[ebp], ecx

; 2745 : 		k = lpDraw->ySize;

  00096	8b 98 88 00 00
	00		 mov	 ebx, DWORD PTR [eax+136]
  0009c	89 9d 78 ff ff
	ff		 mov	 DWORD PTR _k$1$[ebp], ebx
  000a2	89 9d 68 ff ff
	ff		 mov	 DWORD PTR _k$[ebp], ebx

; 2746 : 		l = 8;

  000a8	be 08 00 00 00	 mov	 esi, 8
  000ad	89 b5 64 ff ff
	ff		 mov	 DWORD PTR _l$[ebp], esi

; 2747 : 		//???????????????
; 2748 : 		if (ResoMode == 1) {

  000b3	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?ResoMode@@3HA, 1 ; ResoMode
  000ba	75 21		 jne	 SHORT $LN20@DrawDebugL

; 2749 : 			j >>= 1;

  000bc	d1 f9		 sar	 ecx, 1
  000be	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _j$[ebp], ecx

; 2750 : 			k >>= 1;

  000c4	d1 fb		 sar	 ebx, 1
  000c6	89 9d 78 ff ff
	ff		 mov	 DWORD PTR _k$1$[ebp], ebx
  000cc	89 9d 68 ff ff
	ff		 mov	 DWORD PTR _k$[ebp], ebx

; 2751 : 			l >>= 1;

  000d2	be 04 00 00 00	 mov	 esi, 4
  000d7	89 b5 64 ff ff
	ff		 mov	 DWORD PTR _l$[ebp], esi
$LN20@DrawDebugL:

; 2752 : 		}
; 2753 : #ifdef _HI_COLOR_32
; 2754 : 		if (displayBpp == 32)

  000dd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?displayBpp@@3HA ; displayBpp
  000e2	83 f8 20	 cmp	 eax, 32			; 00000020H
  000e5	75 59		 jne	 SHORT $LN21@DrawDebugL

; 2755 : 		{
; 2756 : 			int pixel;
; 2757 : 			int *pDest32;
; 2758 : 			pixel = highColor32Palette[color];

  000e7	0f b6 85 7f ff
	ff ff		 movzx	 eax, BYTE PTR _color$GSCopy$1$[ebp]
  000ee	8b 3c 85 00 00
	00 00		 mov	 edi, DWORD PTR ?highColor32Palette@@3PAIA[eax*4]

; 2759 : 			// ?????????????
; 2760 : 			pDest32 = (int *)ddsd.lpSurface + j;

  000f5	8b 45 a4	 mov	 eax, DWORD PTR _ddsd$[ebp+36]
  000f8	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  000fb	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _pDest32$2[ebp], ecx

; 2761 : 			// ??????????
; 2762 : 			surfacePitch = ddsd.lPitch >> 1;

  00101	8b 45 90	 mov	 eax, DWORD PTR _ddsd$[ebp+16]
  00104	d1 f8		 sar	 eax, 1
  00106	89 85 78 ff ff
	ff		 mov	 DWORD PTR _surfacePitch$1$[ebp], eax

; 2763 : 			// ???
; 2764 : 			for (i = 0; i < k; i++)

  0010c	33 d2		 xor	 edx, edx
$LN48@DrawDebugL:
  0010e	89 95 74 ff ff
	ff		 mov	 DWORD PTR _i$[ebp], edx
  00114	3b d3		 cmp	 edx, ebx
  00116	0f 8d c5 00 00
	00		 jge	 $LN15@DrawDebugL

; 2765 : 			{
; 2766 : 				// ??????
; 2767 : 				for (m = 0; m < l; m++)

  0011c	33 c0		 xor	 eax, eax
$LN47@DrawDebugL:
  0011e	89 85 70 ff ff
	ff		 mov	 DWORD PTR _m$[ebp], eax
  00124	3b c6		 cmp	 eax, esi
  00126	7d 06		 jge	 SHORT $LN6@DrawDebugL

; 2768 : 				{
; 2769 : 					*(pDest32 + m) = pixel;

  00128	89 3c 81	 mov	 DWORD PTR [ecx+eax*4], edi

; 2765 : 			{
; 2766 : 				// ??????
; 2767 : 				for (m = 0; m < l; m++)

  0012b	40		 inc	 eax
  0012c	eb f0		 jmp	 SHORT $LN47@DrawDebugL
$LN6@DrawDebugL:

; 2770 : 				}
; 2771 : 				// ???????????????
; 2772 : 				pDest32 += surfacePitch;

  0012e	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _surfacePitch$1$[ebp]
  00134	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
  00137	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _pDest32$2[ebp], ecx

; 2763 : 			// ???
; 2764 : 			for (i = 0; i < k; i++)

  0013d	42		 inc	 edx
  0013e	eb ce		 jmp	 SHORT $LN48@DrawDebugL
$LN21@DrawDebugL:

; 2773 : 			}
; 2774 : 		}
; 2775 : 		else
; 2776 : #endif
; 2777 : 			if (displayBpp == 16)

  00140	83 f8 10	 cmp	 eax, 16			; 00000010H
  00143	75 57		 jne	 SHORT $LN23@DrawDebugL

; 2778 : 			{
; 2779 : 				pixel = highColorPalette[color];

  00145	0f b6 85 7f ff
	ff ff		 movzx	 eax, BYTE PTR _color$GSCopy$1$[ebp]
  0014c	0f b7 3c 45 00
	00 00 00	 movzx	 edi, WORD PTR ?highColorPalette@@3PAGA[eax*2]

; 2780 : 				// ?????????????
; 2781 : 				pDest2 = (short *)ddsd.lpSurface + j;

  00154	8b 45 a4	 mov	 eax, DWORD PTR _ddsd$[ebp+36]
  00157	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0015a	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _pDest2$[ebp], ecx

; 2782 : 				// ??????????
; 2783 : 				surfacePitch = ddsd.lPitch >> 1;

  00160	8b 45 90	 mov	 eax, DWORD PTR _ddsd$[ebp+16]
  00163	d1 f8		 sar	 eax, 1
  00165	89 85 78 ff ff
	ff		 mov	 DWORD PTR _surfacePitch$2$[ebp], eax

; 2784 : 				// ???
; 2785 : 				for (i = 0; i < k; i++)

  0016b	33 d2		 xor	 edx, edx
$LN50@DrawDebugL:
  0016d	89 95 74 ff ff
	ff		 mov	 DWORD PTR _i$[ebp], edx
  00173	3b d3		 cmp	 edx, ebx
  00175	7d 6a		 jge	 SHORT $LN15@DrawDebugL

; 2786 : 				{
; 2787 : 					// ??????
; 2788 : 					for (m = 0; m < l; m++)

  00177	33 c0		 xor	 eax, eax
$LN49@DrawDebugL:
  00179	89 85 70 ff ff
	ff		 mov	 DWORD PTR _m$[ebp], eax
  0017f	3b c6		 cmp	 eax, esi
  00181	7d 07		 jge	 SHORT $LN12@DrawDebugL

; 2789 : 					{
; 2790 : 						*(pDest2 + m) = pixel;

  00183	66 89 3c 41	 mov	 WORD PTR [ecx+eax*2], di

; 2786 : 				{
; 2787 : 					// ??????
; 2788 : 					for (m = 0; m < l; m++)

  00187	40		 inc	 eax
  00188	eb ef		 jmp	 SHORT $LN49@DrawDebugL
$LN12@DrawDebugL:

; 2791 : 					}
; 2792 : 					// ???????????????
; 2793 : 					pDest2 += surfacePitch;

  0018a	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _surfacePitch$2$[ebp]
  00190	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  00193	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _pDest2$[ebp], ecx

; 2784 : 				// ???
; 2785 : 				for (i = 0; i < k; i++)

  00199	42		 inc	 edx
  0019a	eb d1		 jmp	 SHORT $LN50@DrawDebugL
$LN23@DrawDebugL:

; 2794 : 				}
; 2795 : 			}
; 2796 : 			else
; 2797 : 			{
; 2798 : 				// ?????????????
; 2799 : 				pDest = (char *)(ddsd.lpSurface) + j;

  0019c	8b 5d a4	 mov	 ebx, DWORD PTR _ddsd$[ebp+36]
  0019f	03 d9		 add	 ebx, ecx
  001a1	89 9d 54 ff ff
	ff		 mov	 DWORD PTR _pDest$[ebp], ebx

; 2800 : 
; 2801 : 				// ??????????
; 2802 : 				surfacePitch = ddsd.lPitch;

  001a7	8b 45 90	 mov	 eax, DWORD PTR _ddsd$[ebp+16]
  001aa	89 85 58 ff ff
	ff		 mov	 DWORD PTR _surfacePitch$3$[ebp], eax

; 2803 : 
; 2804 : 				// ???
; 2805 : 				for (i = 0; i < k; i++)

  001b0	33 ff		 xor	 edi, edi
$LN51@DrawDebugL:
  001b2	89 bd 74 ff ff
	ff		 mov	 DWORD PTR _i$[ebp], edi
  001b8	3b bd 78 ff ff
	ff		 cmp	 edi, DWORD PTR _k$1$[ebp]
  001be	7d 21		 jge	 SHORT $LN15@DrawDebugL

; 2806 : 				{
; 2807 : 					// ??????
; 2808 : 					memset(pDest, color, l);

  001c0	56		 push	 esi
  001c1	0f b6 85 7f ff
	ff ff		 movzx	 eax, BYTE PTR _color$GSCopy$1$[ebp]
  001c8	50		 push	 eax
  001c9	53		 push	 ebx
  001ca	e8 00 00 00 00	 call	 _memset
  001cf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2809 : 					// ???????????????
; 2810 : 					pDest += surfacePitch;

  001d2	03 9d 58 ff ff
	ff		 add	 ebx, DWORD PTR _surfacePitch$3$[ebp]
  001d8	89 9d 54 ff ff
	ff		 mov	 DWORD PTR _pDest$[ebp], ebx

; 2803 : 
; 2804 : 				// ???
; 2805 : 				for (i = 0; i < k; i++)

  001de	47		 inc	 edi
  001df	eb d1		 jmp	 SHORT $LN51@DrawDebugL
$LN15@DrawDebugL:

; 2811 : 				}
; 2812 : 			}
; 2813 : 
; 2814 : 		// ???????????????????
; 2815 : 		if (lpDraw->lpFRONTBUFFER->Unlock(NULL) != DD_OK) {

  001e1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  001e6	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  001e9	8b 08		 mov	 ecx, DWORD PTR [eax]
  001eb	6a 00		 push	 0
  001ed	50		 push	 eax
  001ee	ff 91 80 00 00
	00		 call	 DWORD PTR [ecx+128]
  001f4	85 c0		 test	 eax, eax
  001f6	74 22		 je	 SHORT $LN30@DrawDebugL

; 2816 : 			MessageBoxNew(hWnd, "Surface的Unlock失败！", "확인", MB_OK | MB_ICONSTOP);

  001f8	6a 10		 push	 16			; 00000010H
  001fa	68 00 00 00 00	 push	 OFFSET ??_C@_04IJNKKJEO@?H?$KO?$MA?N@
  001ff	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@IOHJJJNA@Surface?n?$NMUnlock?c?w?$DP?$KD?$KB@
  00204	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  0020a	e8 00 00 00 00	 call	 ?MessageBoxNew@@YAHPAUHWND__@@PBD1I@Z ; MessageBoxNew
  0020f	83 c4 10	 add	 esp, 16			; 00000010H

; 2817 : 			return;

  00212	eb 0d		 jmp	 SHORT $LN29@DrawDebugL
__catch$?DrawDebugLine@@YAXE@Z$0:

; 2818 : 		}
; 2819 : 	}
; 2820 : 	catch (...)
; 2821 : 	{
; 2822 : 
; 2823 : 	}

  00214	b8 00 00 00 00	 mov	 eax, $LN30@DrawDebugL
  00219	c3		 ret	 0
$LN30@DrawDebugL:

; 2824 : 
; 2825 : 
; 2826 : 	return;
; 2827 : }

  0021a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN29@DrawDebugL:
  00221	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00224	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0022b	59		 pop	 ecx
  0022c	5f		 pop	 edi
  0022d	5e		 pop	 esi
  0022e	5b		 pop	 ebx
  0022f	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00232	33 cd		 xor	 ecx, ebp
  00234	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00239	8b e5		 mov	 esp, ebp
  0023b	5d		 pop	 ebp
  0023c	c3		 ret	 0
  0023d	cc		 int	 3
  0023e	cc		 int	 3
  0023f	cc		 int	 3
  00240	cc		 int	 3
  00241	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?DrawDebugLine@@YAXE@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 50 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-176]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?DrawDebugLine@@YAXE@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?DrawDebugLine@@YAXE@Z ENDP				; DrawDebugLine
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?ReleaseDirectDraw@@YAXXZ
_TEXT	SEGMENT
_i$2 = -20						; size = 4
__$EHRec$ = -16						; size = 16
?ReleaseDirectDraw@@YAXXZ PROC				; ReleaseDirectDraw, COMDAT

; 3001 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ReleaseDirectDraw@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 3002 : 	try

  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 3003 : 	{
; 3004 : 		int i;
; 3005 : 		// ????????????????
; 3006 : 		for (i = 0; i < SurfaceCnt; i++) {

  00032	33 f6		 xor	 esi, esi
$LN28@ReleaseDir:
  00034	89 75 ec	 mov	 DWORD PTR _i$2[ebp], esi
  00037	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?SurfaceCnt@@3HA ; SurfaceCnt
  0003d	7d 4d		 jge	 SHORT $LN3@ReleaseDir

; 3007 : 			if (SurfaceInfo[i].lpSurface != NULL) {

  0003f	8d 3c f5 00 00
	00 00		 lea	 edi, DWORD PTR [esi*8]
  00046	2b fe		 sub	 edi, esi
  00048	83 3c bd 00 00
	00 00 00	 cmp	 DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[edi*4], 0
  00050	74 37		 je	 SHORT $LN25@ReleaseDir

; 3008 : 				if (SurfaceInfo[i].lpAlphaData != NULL) {

  00052	8b 04 bd 08 00
	00 00		 mov	 eax, DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[edi*4+8]
  00059	85 c0		 test	 eax, eax
  0005b	74 14		 je	 SHORT $LN26@ReleaseDir

; 3009 : 					FREE(SurfaceInfo[i].lpAlphaData);

  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _free
  00063	83 c4 04	 add	 esp, 4

; 3010 : 					SurfaceInfo[i].lpAlphaData = NULL;

  00066	c7 04 bd 08 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[edi*4+8], 0
$LN26@ReleaseDir:

; 3011 : 				}
; 3012 : 				SurfaceInfo[i].lpSurface->Release();

  00071	8b 04 bd 00 00
	00 00		 mov	 eax, DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[edi*4]
  00078	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007a	50		 push	 eax
  0007b	ff 51 08	 call	 DWORD PTR [ecx+8]

; 3013 : 				SurfaceInfo[i].lpSurface = NULL;

  0007e	c7 04 bd 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[edi*4], 0
$LN25@ReleaseDir:

; 3003 : 	{
; 3004 : 		int i;
; 3005 : 		// ????????????????
; 3006 : 		for (i = 0; i < SurfaceCnt; i++) {

  00089	46		 inc	 esi
  0008a	eb a8		 jmp	 SHORT $LN28@ReleaseDir
$LN3@ReleaseDir:

; 3014 : #ifdef _READ16BITBMP
; 3015 : 				if (g_bUseAlpha) {
; 3016 : 					SurfaceInfoSys[i].lpSurface->Release();
; 3017 : 					SurfaceInfoSys[i].lpSurface = NULL;
; 3018 : 				}
; 3019 : #endif
; 3020 : 			}
; 3021 : #ifdef _READ16BITBMP
; 3022 : 			if (g_bUseAlpha) {
; 3023 : 				if (SurfaceInfo[i].lpAlphaData != NULL) {
; 3024 : 					FREE(SurfaceInfo[i].lpAlphaData);
; 3025 : #ifdef _STONDEBUG_
; 3026 : 					g_iMallocCount--;
; 3027 : #endif
; 3028 : 					SurfaceInfo[i].lpAlphaData = NULL;
; 3029 : 				}
; 3030 : 			}
; 3031 : #endif
; 3032 : 		}
; 3033 : #ifdef __SKYISLAND
; 3034 : 		extern void SkyIslandRelease();
; 3035 : 		SkyIslandRelease();

  0008c	e8 00 00 00 00	 call	 ?SkyIslandRelease@@YAXXZ ; SkyIslandRelease

; 3036 : #endif
; 3037 : 		// ??????????
; 3038 : 		if (lpBattleSurface != NULL) {

  00091	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?lpBattleSurface@@3PAUIDirectDrawSurface@@A ; lpBattleSurface
  00097	85 c9		 test	 ecx, ecx
  00099	74 10		 je	 SHORT $LN8@ReleaseDir

; 3039 : 			// ????
; 3040 : 			lpBattleSurface->Release();

  0009b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009d	51		 push	 ecx
  0009e	ff 50 08	 call	 DWORD PTR [eax+8]

; 3041 : 			lpBattleSurface = NULL;

  000a1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?lpBattleSurface@@3PAUIDirectDrawSurface@@A, 0 ; lpBattleSurface
$LN8@ReleaseDir:

; 3042 : 		}
; 3043 : 		if (lpDraw) {

  000ab	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  000b0	85 c0		 test	 eax, eax
  000b2	0f 84 b6 00 00
	00		 je	 $LN9@ReleaseDir

; 3044 : 			// ?????
; 3045 : 			if (lpDraw->lpPALETTE != NULL) {

  000b8	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  000be	85 c9		 test	 ecx, ecx
  000c0	74 1a		 je	 SHORT $LN10@ReleaseDir

; 3046 : 				lpDraw->lpPALETTE->Release();

  000c2	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c4	51		 push	 ecx
  000c5	ff 50 08	 call	 DWORD PTR [eax+8]

; 3047 : 				lpDraw->lpPALETTE = NULL;

  000c8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  000cd	c7 80 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+128], 0
  000d7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
$LN10@ReleaseDir:

; 3048 : 			}
; 3049 : 			// ??????
; 3050 : 			if (lpDraw->lpCLIPPER != NULL) {

  000dc	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000df	85 c9		 test	 ecx, ecx
  000e1	74 17		 je	 SHORT $LN11@ReleaseDir

; 3051 : 				lpDraw->lpCLIPPER->Release();

  000e3	8b 01		 mov	 eax, DWORD PTR [ecx]
  000e5	51		 push	 ecx
  000e6	ff 50 08	 call	 DWORD PTR [eax+8]

; 3052 : 				lpDraw->lpCLIPPER = NULL;

  000e9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  000ee	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  000f5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
$LN11@ReleaseDir:

; 3053 : 			}
; 3054 : 			// ?????????
; 3055 : 			if (lpDraw->lpBACKBUFFER != NULL) {

  000fa	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000fd	85 c9		 test	 ecx, ecx
  000ff	74 17		 je	 SHORT $LN12@ReleaseDir

; 3056 : 				lpDraw->lpBACKBUFFER->Release();

  00101	8b 01		 mov	 eax, DWORD PTR [ecx]
  00103	51		 push	 ecx
  00104	ff 50 08	 call	 DWORD PTR [eax+8]

; 3057 : 				lpDraw->lpBACKBUFFER = NULL;

  00107	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0010c	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00113	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
$LN12@ReleaseDir:

; 3058 : 			}
; 3059 : #ifdef _READ16BITBMP
; 3060 : 			if (g_bUseAlpha) {
; 3061 : 				if (lpDraw->lpBACKBUFFERSYS != NULL) {
; 3062 : 					lpDraw->lpBACKBUFFERSYS->Release();
; 3063 : 					lpDraw->lpBACKBUFFERSYS = NULL;
; 3064 : 				}
; 3065 : 				if (lpBattleSurfaceSys != NULL) {
; 3066 : 					lpBattleSurfaceSys->Release();
; 3067 : 					lpBattleSurfaceSys = NULL;
; 3068 : 				}
; 3069 : 			}
; 3070 : #endif
; 3071 : 			// ???????????
; 3072 : 			if (lpDraw->lpFRONTBUFFER != NULL) {

  00118	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0011b	85 c9		 test	 ecx, ecx
  0011d	74 17		 je	 SHORT $LN13@ReleaseDir

; 3073 : 				lpDraw->lpFRONTBUFFER->Release();

  0011f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00121	51		 push	 ecx
  00122	ff 50 08	 call	 DWORD PTR [eax+8]

; 3074 : 				lpDraw->lpFRONTBUFFER = NULL;

  00125	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0012a	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00131	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
$LN13@ReleaseDir:

; 3075 : 			}
; 3076 : 			// DirectDraw??
; 3077 : 			if (lpDraw->lpDD2 != NULL) {

  00136	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00139	85 c9		 test	 ecx, ecx
  0013b	74 17		 je	 SHORT $LN14@ReleaseDir

; 3078 : 				lpDraw->lpDD2->Release();

  0013d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0013f	51		 push	 ecx
  00140	ff 50 08	 call	 DWORD PTR [eax+8]

; 3079 : 				lpDraw->lpDD2 = NULL;

  00143	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00148	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0014f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
$LN14@ReleaseDir:

; 3080 : 			}
; 3081 : 
; 3082 : 			// DIRECT_DRAW ??
; 3083 : 			HeapFree(GetProcessHeap(), NULL, lpDraw);

  00154	50		 push	 eax
  00155	6a 00		 push	 0
  00157	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  0015d	50		 push	 eax
  0015e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapFree@12

; 3084 : 			lpDraw = NULL;

  00164	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A, 0 ; lpDraw
$LN9@ReleaseDir:

; 3085 : 		}
; 3086 : 		// DirectDraw ??????? FALSE ???
; 3087 : 		DDinitFlag = FALSE;

  0016e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?DDinitFlag@@3HA, 0 ; DDinitFlag
$LN19@ReleaseDir:

; 3093 : 
; 3094 : }

  00178	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0017f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00182	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00189	59		 pop	 ecx
  0018a	5f		 pop	 edi
  0018b	5e		 pop	 esi
  0018c	5b		 pop	 ebx
  0018d	8b e5		 mov	 esp, ebp
  0018f	5d		 pop	 ebp
  00190	c3		 ret	 0
__catch$?ReleaseDirectDraw@@YAXXZ$0:

; 3088 : 	}
; 3089 : 	catch (...)
; 3090 : 	{
; 3091 : 
; 3092 : 	}

  00191	b8 00 00 00 00	 mov	 eax, $LN19@ReleaseDir
  00196	c3		 ret	 0
  00197	cc		 int	 3
  00198	cc		 int	 3
  00199	cc		 int	 3
  0019a	cc		 int	 3
  0019b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?ReleaseDirectDraw@@YAXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ReleaseDirectDraw@@YAXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ReleaseDirectDraw@@YAXXZ ENDP				; ReleaseDirectDraw
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?CheckSurfaceLost@@YAHXZ
_TEXT	SEGMENT
_i$2 = -24						; size = 4
_SurfaceLostFlag$3 = -20				; size = 4
__$EHRec$ = -16						; size = 16
?CheckSurfaceLost@@YAHXZ PROC				; CheckSurfaceLost, COMDAT

; 3098 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CheckSurfaceLost@@YAHXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 3099 : 	try

  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 3100 : 	{
; 3101 : 		BOOL SurfaceLostFlag = FALSE;

  00032	33 ff		 xor	 edi, edi
  00034	89 7d ec	 mov	 DWORD PTR _SurfaceLostFlag$3[ebp], edi

; 3102 : 		int i;
; 3103 : 		// ?????????????????
; 3104 : 		for (i = 0; i < SurfaceCnt; i++) {

  00037	33 f6		 xor	 esi, esi
  00039	8d 5f 01	 lea	 ebx, DWORD PTR [edi+1]
$LN24@CheckSurfa:
  0003c	89 75 e8	 mov	 DWORD PTR _i$2[ebp], esi
  0003f	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?SurfaceCnt@@3HA ; SurfaceCnt
  00045	7d 25		 jge	 SHORT $LN3@CheckSurfa

; 3105 : 			// ??????????
; 3106 : 			if (SurfaceInfo[i].lpSurface != NULL) {

  00047	8d 04 f5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*8]
  0004e	2b c6		 sub	 eax, esi
  00050	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[eax*4]
  00057	85 c9		 test	 ecx, ecx
  00059	74 0e		 je	 SHORT $LN7@CheckSurfa

; 3107 : 				// ????????????????
; 3108 : #ifdef _READ16BITBMP
; 3109 : 				if (g_bUseAlpha)
; 3110 : 					if (SurfaceInfoSys[i].lpSurface->IsLost()) SurfaceLostFlag = TRUE;
; 3111 : #endif
; 3112 : 				if (SurfaceInfo[i].lpSurface->IsLost()) SurfaceLostFlag = TRUE;

  0005b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005d	51		 push	 ecx
  0005e	ff 50 60	 call	 DWORD PTR [eax+96]
  00061	85 c0		 test	 eax, eax
  00063	0f 45 fb	 cmovne	 edi, ebx
  00066	89 7d ec	 mov	 DWORD PTR _SurfaceLostFlag$3[ebp], edi
$LN7@CheckSurfa:

; 3102 : 		int i;
; 3103 : 		// ?????????????????
; 3104 : 		for (i = 0; i < SurfaceCnt; i++) {

  00069	46		 inc	 esi
  0006a	eb d0		 jmp	 SHORT $LN24@CheckSurfa
$LN3@CheckSurfa:

; 3113 : 			}
; 3114 : 		}
; 3115 : 		// ???????????
; 3116 : 		if (lpBattleSurface != NULL) {

  0006c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?lpBattleSurface@@3PAUIDirectDrawSurface@@A ; lpBattleSurface
  00072	85 c9		 test	 ecx, ecx
  00074	74 0e		 je	 SHORT $LN9@CheckSurfa

; 3117 : 			// ????
; 3118 : 			if (lpBattleSurface->IsLost()) {

  00076	8b 01		 mov	 eax, DWORD PTR [ecx]
  00078	51		 push	 ecx
  00079	ff 50 60	 call	 DWORD PTR [eax+96]
  0007c	85 c0		 test	 eax, eax
  0007e	0f 45 fb	 cmovne	 edi, ebx
  00081	89 7d ec	 mov	 DWORD PTR _SurfaceLostFlag$3[ebp], edi
$LN9@CheckSurfa:

; 3119 : 				SurfaceLostFlag = TRUE;
; 3120 : 			}
; 3121 : 		}
; 3122 : #ifdef __SKYISLAND
; 3123 : #ifndef __CARYTEST
; 3124 : 		extern BOOL SkyIslandCheckSurface();
; 3125 : 		if (SkyIslandCheckSurface())

  00084	e8 00 00 00 00	 call	 ?SkyIslandCheckSurface@@YAHXZ ; SkyIslandCheckSurface
  00089	85 c0		 test	 eax, eax
  0008b	0f 45 fb	 cmovne	 edi, ebx
  0008e	89 7d ec	 mov	 DWORD PTR _SurfaceLostFlag$3[ebp], edi

; 3126 : 			SurfaceLostFlag = TRUE;
; 3127 : #endif
; 3128 : #endif
; 3129 : 		// ??????????
; 3130 : 		if (lpDraw->lpBACKBUFFER != NULL) {

  00091	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00096	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00099	85 c9		 test	 ecx, ecx
  0009b	74 13		 je	 SHORT $LN12@CheckSurfa

; 3131 : 			// ????????????????
; 3132 : 			if (lpDraw->lpBACKBUFFER->IsLost()) {

  0009d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009f	51		 push	 ecx
  000a0	ff 50 60	 call	 DWORD PTR [eax+96]
  000a3	85 c0		 test	 eax, eax
  000a5	0f 45 fb	 cmovne	 edi, ebx
  000a8	89 7d ec	 mov	 DWORD PTR _SurfaceLostFlag$3[ebp], edi
  000ab	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
$LN12@CheckSurfa:

; 3133 : 				SurfaceLostFlag = TRUE;
; 3134 : 			}
; 3135 : 		}
; 3136 : 		// ????????????
; 3137 : 		if (lpDraw->lpFRONTBUFFER != NULL) {

  000b0	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000b3	85 c0		 test	 eax, eax
  000b5	74 0e		 je	 SHORT $LN14@CheckSurfa

; 3138 : 			// ????????????????
; 3139 : 			if (lpDraw->lpFRONTBUFFER->IsLost()) {

  000b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b9	50		 push	 eax
  000ba	ff 51 60	 call	 DWORD PTR [ecx+96]
  000bd	85 c0		 test	 eax, eax
  000bf	0f 45 fb	 cmovne	 edi, ebx
  000c2	89 7d ec	 mov	 DWORD PTR _SurfaceLostFlag$3[ebp], edi
$LN14@CheckSurfa:

; 3140 : 				SurfaceLostFlag = TRUE;
; 3141 : 			}
; 3142 : 		}
; 3143 : 
; 3144 : 		return SurfaceLostFlag;

  000c5	8b c7		 mov	 eax, edi

; 3149 : 	}
; 3150 : 
; 3151 : }

  000c7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000ca	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d1	59		 pop	 ecx
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
__catch$?CheckSurfaceLost@@YAHXZ$0:

; 3145 : 	}
; 3146 : 	catch (...)
; 3147 : 	{
; 3148 : 		return true;

  000d9	b8 00 00 00 00	 mov	 eax, $LN19@CheckSurfa
  000de	c3		 ret	 0
$LN19@CheckSurfa:
  000df	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000e6	b8 01 00 00 00	 mov	 eax, 1

; 3149 : 	}
; 3150 : 
; 3151 : }

  000eb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000ee	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f5	59		 pop	 ecx
  000f6	5f		 pop	 edi
  000f7	5e		 pop	 esi
  000f8	5b		 pop	 ebx
  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
  000fd	cc		 int	 3
  000fe	cc		 int	 3
  000ff	cc		 int	 3
  00100	cc		 int	 3
  00101	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?CheckSurfaceLost@@YAHXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CheckSurfaceLost@@YAHXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CheckSurfaceLost@@YAHXZ ENDP				; CheckSurfaceLost
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?Flip@@YAXXZ
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
?Flip@@YAXXZ PROC					; Flip, COMDAT

; 685  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Flip@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 686  : #ifdef _NB_顶部详情
; 687  : 	CalculateFrameRate();

  00029	e8 00 00 00 00	 call	 ?CalculateFrameRate@@YAXXZ ; CalculateFrameRate

; 688  : #endif
; 689  : 
; 690  : 	//JL hook
; 691  : 	if (g_hideSA || !lpDraw->lpFRONTBUFFER){

  0002e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_hideSA@@3HA, 0 ; g_hideSA
  00035	75 44		 jne	 SHORT $LN3@Flip
  00037	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0003c	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00040	74 39		 je	 SHORT $LN3@Flip

; 692  : 		return;
; 693  : 	}
; 694  : 
; 695  : 	try{

  00042	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 696  : 		if (WindowMode == TRUE) {

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0004e	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?WindowMode@@3HA, 1 ; WindowMode
  00055	75 36		 jne	 SHORT $LN5@Flip

; 697  : 			lpDraw->lpFRONTBUFFER->Blt(&g_clientRect, lpDraw->lpBACKBUFFER, &g_moveRect, DDBLT_WAIT, NULL);

  00057	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005c	6a 00		 push	 0
  0005e	68 00 00 00 01	 push	 16777216		; 01000000H
  00063	68 00 00 00 00	 push	 OFFSET ?g_moveRect@@3UtagRECT@@A ; g_moveRect
  00068	ff 70 0c	 push	 DWORD PTR [eax+12]
  0006b	68 00 00 00 00	 push	 OFFSET ?g_clientRect@@3UtagRECT@@A ; g_clientRect
  00070	51		 push	 ecx
  00071	ff 52 14	 call	 DWORD PTR [edx+20]
$LN11@Flip:

; 706  : 
; 707  : 
; 708  : 	return;
; 709  : }

  00074	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN3@Flip:
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
$LN5@Flip:

; 698  : 		}else{
; 699  : 			//		lpDraw->lpDD2->WaitForVerticalBlank(DDWAITVB_BLOCKEND, NULL);  JL fix
; 700  : 			lpDraw->lpFRONTBUFFER->Flip(NULL, DDFLIP_WAIT);

  0008d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00090	8b 08		 mov	 ecx, DWORD PTR [eax]
  00092	6a 01		 push	 1
  00094	6a 00		 push	 0
  00096	50		 push	 eax
  00097	ff 51 2c	 call	 DWORD PTR [ecx+44]
  0009a	eb d8		 jmp	 SHORT $LN11@Flip
__catch$?Flip@@YAXXZ$0:

; 701  : 		}
; 702  : 	}
; 703  : 	catch (...){
; 704  : 
; 705  : 	}

  0009c	b8 00 00 00 00	 mov	 eax, $LN11@Flip
  000a1	c3		 ret	 0
  000a2	cc		 int	 3
  000a3	cc		 int	 3
  000a4	cc		 int	 3
  000a5	cc		 int	 3
  000a6	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?Flip@@YAXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Flip@@YAXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Flip@@YAXXZ ENDP					; Flip
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?DrawBitmapToSurface@@YAXPAUIDirectDrawSurface@@HHPAUtagBITMAPINFO@@@Z
_TEXT	SEGMENT
_hDcDest$2 = -20					; size = 4
__$EHRec$ = -16						; size = 16
_lpSurface$ = 8						; size = 4
_offsetX$ = 12						; size = 4
_offsetY$ = 16						; size = 4
_pBmpInfo$ = 20						; size = 4
?DrawBitmapToSurface@@YAXPAUIDirectDrawSurface@@HHPAUtagBITMAPINFO@@@Z PROC ; DrawBitmapToSurface, COMDAT

; 886  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?DrawBitmapToSurface@@YAXPAUIDirectDrawSurface@@HHPAUtagBITMAPINFO@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 887  : 	try

  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 888  : 	{
; 889  : 		HDC hDcDest;
; 890  : 		// ??????????????????
; 891  : 		lpSurface->GetDC(&hDcDest);

  00032	8b 75 08	 mov	 esi, DWORD PTR _lpSurface$[ebp]
  00035	8b 06		 mov	 eax, DWORD PTR [esi]
  00037	8d 4d ec	 lea	 ecx, DWORD PTR _hDcDest$2[ebp]
  0003a	51		 push	 ecx
  0003b	56		 push	 esi
  0003c	ff 50 44	 call	 DWORD PTR [eax+68]

; 892  : 		StretchDIBits(hDcDest,

  0003f	8b 45 14	 mov	 eax, DWORD PTR _pBmpInfo$[ebp]
  00042	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00045	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00048	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  0004d	6a 00		 push	 0
  0004f	50		 push	 eax
  00050	05 28 04 00 00	 add	 eax, 1064		; 00000428H
  00055	50		 push	 eax
  00056	51		 push	 ecx
  00057	52		 push	 edx
  00058	ff 75 10	 push	 DWORD PTR _offsetY$[ebp]
  0005b	ff 75 0c	 push	 DWORD PTR _offsetX$[ebp]
  0005e	51		 push	 ecx
  0005f	52		 push	 edx
  00060	6a 00		 push	 0
  00062	6a 00		 push	 0
  00064	ff 75 ec	 push	 DWORD PTR _hDcDest$2[ebp]
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchDIBits@52

; 893  : 			0, 0,
; 894  : 			//cary
; 895  : 			pBmpInfo->bmiHeader.biWidth, pBmpInfo->bmiHeader.biHeight,
; 896  : 			//SurfaceSizeX, SurfaceSizeY,
; 897  : 			offsetX, offsetY,
; 898  : 			pBmpInfo->bmiHeader.biWidth, pBmpInfo->bmiHeader.biHeight,
; 899  : 			//SurfaceSizeX, SurfaceSizeY,
; 900  : 			//end
; 901  : 			(void *)((BYTE *)pBmpInfo + (sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * 256)),
; 902  : 			pBmpInfo,
; 903  : 
; 904  : 			//DIB_PAL_COLORS,	
; 905  : 			DIB_RGB_COLORS,
; 906  : 			//DIB_PAL_INDICES,
; 907  : 
; 908  : 			SRCCOPY);
; 909  : 		//NOTSRCCOPY );
; 910  : 		//DSTINVERT );
; 911  : 		//BLACKNESS );
; 912  : 		lpSurface->ReleaseDC(hDcDest);

  0006d	8b 06		 mov	 eax, DWORD PTR [esi]
  0006f	ff 75 ec	 push	 DWORD PTR _hDcDest$2[ebp]
  00072	56		 push	 esi
  00073	ff 50 68	 call	 DWORD PTR [eax+104]

; 920  : 
; 921  : }

  00076	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00079	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00080	59		 pop	 ecx
  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
__catch$?DrawBitmapToSurface@@YAXPAUIDirectDrawSurface@@HHPAUtagBITMAPINFO@@@Z$0:

; 913  : 
; 914  : 		return;
; 915  : 	}
; 916  : 	catch (...)
; 917  : 	{
; 918  : 
; 919  : 	}

  00088	b8 00 00 00 00	 mov	 eax, $LN7@DrawBitmap
  0008d	c3		 ret	 0
$LN7@DrawBitmap:
  0008e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 920  : 
; 921  : }

  00095	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00098	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009f	59		 pop	 ecx
  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi
  000a2	5b		 pop	 ebx
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
  000a7	cc		 int	 3
  000a8	cc		 int	 3
  000a9	cc		 int	 3
  000aa	cc		 int	 3
  000ab	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?DrawBitmapToSurface@@YAXPAUIDirectDrawSurface@@HHPAUtagBITMAPINFO@@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?DrawBitmapToSurface@@YAXPAUIDirectDrawSurface@@HHPAUtagBITMAPINFO@@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?DrawBitmapToSurface@@YAXPAUIDirectDrawSurface@@HHPAUtagBITMAPINFO@@@Z ENDP ; DrawBitmapToSurface
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?DrawSurfaceFast2@@YAJFFPAUtagRECT@@PAUIDirectDrawSurface@@@Z
_TEXT	SEGMENT
tv330 = -44						; size = 4
_y0$1$ = -40						; size = 4
_w$1$ = -36						; size = 4
tv331 = -32						; size = 4
tv315 = -28						; size = 4
_h$1$ = -24						; size = 4
_x0$1$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_bx$ = 8						; size = 2
_by$ = 12						; size = 2
_rect$ = 16						; size = 4
_lpSurface$ = 20					; size = 4
?DrawSurfaceFast2@@YAJFFPAUtagRECT@@PAUIDirectDrawSurface@@@Z PROC ; DrawSurfaceFast2, COMDAT

; 2943 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?DrawSurfaceFast2@@YAJFFPAUtagRECT@@PAUIDirectDrawSurface@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 2944 : 
; 2945 : 	try

  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 2946 : 	{
; 2947 : 		short x0, y0;
; 2948 : 		long w, h;
; 2949 : 
; 2950 : 		x0 = bx;

  00032	0f b7 75 08	 movzx	 esi, WORD PTR _bx$[ebp]
  00036	89 75 ec	 mov	 DWORD PTR _x0$1$[ebp], esi

; 2951 : 		y0 = by;

  00039	0f b7 45 0c	 movzx	 eax, WORD PTR _by$[ebp]
  0003d	89 45 d8	 mov	 DWORD PTR _y0$1$[ebp], eax

; 2952 : 		w = rect->right - rect->left;

  00040	8b 75 10	 mov	 esi, DWORD PTR _rect$[ebp]
  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	2b 06		 sub	 eax, DWORD PTR [esi]
  00048	89 45 dc	 mov	 DWORD PTR _w$1$[ebp], eax

; 2953 : 		h = rect->bottom - rect->top;

  0004b	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0004e	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00051	2b cf		 sub	 ecx, edi
  00053	89 4d e8	 mov	 DWORD PTR _h$1$[ebp], ecx

; 2954 : 
; 2955 : 		// ????????
; 2956 : 		//   ????? RECT ??????????????
; 2957 : 
; 2958 : 		// ???????????
; 2959 : 		if (bx >= lpDraw->xSize || bx + w <= 0 || by >= lpDraw->ySize || by + h <= 0) {

  00056	0f bf 5d 08	 movsx	 ebx, WORD PTR _bx$[ebp]
  0005a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00060	3b 99 84 00 00
	00		 cmp	 ebx, DWORD PTR [ecx+132]
  00066	0f 8d c2 00 00
	00		 jge	 $LN4@DrawSurfac
  0006c	03 c3		 add	 eax, ebx
  0006e	89 45 e0	 mov	 DWORD PTR tv331[ebp], eax
  00071	85 c0		 test	 eax, eax
  00073	0f 8e b5 00 00
	00		 jle	 $LN4@DrawSurfac
  00079	0f bf 55 0c	 movsx	 edx, WORD PTR _by$[ebp]
  0007d	3b 91 88 00 00
	00		 cmp	 edx, DWORD PTR [ecx+136]
  00083	0f 8d a5 00 00
	00		 jge	 $LN4@DrawSurfac
  00089	8b 45 e8	 mov	 eax, DWORD PTR _h$1$[ebp]
  0008c	03 c2		 add	 eax, edx
  0008e	89 45 d4	 mov	 DWORD PTR tv330[ebp], eax
  00091	85 c0		 test	 eax, eax
  00093	0f 8e 95 00 00
	00		 jle	 $LN4@DrawSurfac

; 2961 : 		}
; 2962 : 
; 2963 : 		// ??????
; 2964 : 		if (bx < 0) {

  00099	66 83 7d 08 00	 cmp	 WORD PTR _bx$[ebp], 0
  0009e	7d 11		 jge	 SHORT $LN5@DrawSurfac

; 2965 : 			rect->left -= bx;

  000a0	8b 06		 mov	 eax, DWORD PTR [esi]
  000a2	2b c3		 sub	 eax, ebx
  000a4	89 06		 mov	 DWORD PTR [esi], eax

; 2966 : 			x0 = 0;

  000a6	33 c0		 xor	 eax, eax
  000a8	89 45 ec	 mov	 DWORD PTR _x0$1$[ebp], eax
  000ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
$LN5@DrawSurfac:

; 2967 : 		}
; 2968 : 		// ??????
; 2969 : 		if (bx + w > lpDraw->xSize) {

  000b1	8b 81 84 00 00
	00		 mov	 eax, DWORD PTR [ecx+132]
  000b7	39 45 e0	 cmp	 DWORD PTR tv331[ebp], eax
  000ba	7e 11		 jle	 SHORT $LN6@DrawSurfac

; 2970 : 			rect->right -= bx + w - lpDraw->xSize;

  000bc	2b c3		 sub	 eax, ebx
  000be	2b 45 dc	 sub	 eax, DWORD PTR _w$1$[ebp]
  000c1	03 46 08	 add	 eax, DWORD PTR [esi+8]
  000c4	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
$LN6@DrawSurfac:

; 2971 : 		}
; 2972 : 		// ?????
; 2973 : 		if (by < 0) {

  000cd	66 83 7d 0c 00	 cmp	 WORD PTR _by$[ebp], 0
  000d2	7d 0f		 jge	 SHORT $LN14@DrawSurfac

; 2974 : 			rect->top -= by;

  000d4	2b fa		 sub	 edi, edx
  000d6	89 7e 04	 mov	 DWORD PTR [esi+4], edi

; 2975 : 			y0 = 0;

  000d9	33 c0		 xor	 eax, eax
  000db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw

; 2971 : 		}
; 2972 : 		// ?????
; 2973 : 		if (by < 0) {

  000e1	eb 03		 jmp	 SHORT $LN7@DrawSurfac
$LN14@DrawSurfac:
  000e3	8b 45 d8	 mov	 eax, DWORD PTR _y0$1$[ebp]
$LN7@DrawSurfac:

; 2976 : 		}
; 2977 : 		// ??????
; 2978 : 		if (by + h > lpDraw->ySize) {

  000e6	0f b7 f8	 movzx	 edi, ax
  000e9	8b 81 88 00 00
	00		 mov	 eax, DWORD PTR [ecx+136]
  000ef	39 45 d4	 cmp	 DWORD PTR tv330[ebp], eax
  000f2	7e 11		 jle	 SHORT $LN8@DrawSurfac

; 2979 : 			rect->bottom -= by + h - lpDraw->ySize;

  000f4	2b c2		 sub	 eax, edx
  000f6	2b 45 e8	 sub	 eax, DWORD PTR _h$1$[ebp]
  000f9	03 46 0c	 add	 eax, DWORD PTR [esi+12]
  000fc	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  000ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
$LN8@DrawSurfac:

; 2980 : 		}
; 2981 : 
; 2982 : #ifdef _STONDEBUG_		
; 2983 : 		// ?????????????????
; 2984 : 		SurfaceDispCnt++;
; 2985 : #endif
; 2986 : 
; 2987 : 		// ???????????
; 2988 : 		//return lpDraw->lpBACKBUFFER->BltFast( x0, y0, lpSurface, rect, DDBLTFAST_SRCCOLORKEY | DDBLTFAST_WAIT );
; 2989 : 		return lpDraw->lpBACKBUFFER->BltFast(x0, y0, lpSurface, rect, DDBLTFAST_WAIT);

  00105	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00108	8b 11		 mov	 edx, DWORD PTR [ecx]
  0010a	6a 10		 push	 16			; 00000010H
  0010c	56		 push	 esi
  0010d	ff 75 14	 push	 DWORD PTR _lpSurface$[ebp]
  00110	57		 push	 edi
  00111	8b 75 ec	 mov	 esi, DWORD PTR _x0$1$[ebp]
  00114	0f b7 c6	 movzx	 eax, si
  00117	50		 push	 eax
  00118	51		 push	 ecx
  00119	ff 52 1c	 call	 DWORD PTR [edx+28]

; 2994 : 	}
; 2995 : 	
; 2996 : }

  0011c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0011f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00126	59		 pop	 ecx
  00127	5f		 pop	 edi
  00128	5e		 pop	 esi
  00129	5b		 pop	 ebx
  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c3		 ret	 0
$LN4@DrawSurfac:

; 2960 : 			return DD_OK;

  0012e	33 c0		 xor	 eax, eax

; 2994 : 	}
; 2995 : 	
; 2996 : }

  00130	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00133	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013a	59		 pop	 ecx
  0013b	5f		 pop	 edi
  0013c	5e		 pop	 esi
  0013d	5b		 pop	 ebx
  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c3		 ret	 0
__catch$?DrawSurfaceFast2@@YAJFFPAUtagRECT@@PAUIDirectDrawSurface@@@Z$0:

; 2990 : 	}
; 2991 : 	catch (...)
; 2992 : 	{
; 2993 : 		return  E_FAIL;

  00142	b8 00 00 00 00	 mov	 eax, $LN13@DrawSurfac
  00147	c3		 ret	 0
$LN13@DrawSurfac:
  00148	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0014f	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H

; 2994 : 	}
; 2995 : 	
; 2996 : }

  00154	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00157	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0015e	59		 pop	 ecx
  0015f	5f		 pop	 edi
  00160	5e		 pop	 esi
  00161	5b		 pop	 ebx
  00162	8b e5		 mov	 esp, ebp
  00164	5d		 pop	 ebp
  00165	c3		 ret	 0
  00166	cc		 int	 3
  00167	cc		 int	 3
  00168	cc		 int	 3
  00169	cc		 int	 3
  0016a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?DrawSurfaceFast2@@YAJFFPAUtagRECT@@PAUIDirectDrawSurface@@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?DrawSurfaceFast2@@YAJFFPAUtagRECT@@PAUIDirectDrawSurface@@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?DrawSurfaceFast2@@YAJFFPAUtagRECT@@PAUIDirectDrawSurface@@@Z ENDP ; DrawSurfaceFast2
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?DrawBitmapToSurface2@@YAXPAUsurfaceInfo@@HHHHPAUtagBITMAPINFO@@@Z
_TEXT	SEGMENT
_lpSurface$1$ = -172					; size = 4
_surfacePitch$1$ = -168					; size = 4
_j$2 = -164						; size = 4
_j$3 = -160						; size = 4
_pDest$4 = -156						; size = 4
_i$5 = -152						; size = 4
_bmpWidth$1$ = -148					; size = 4
_alphatemp$1$ = -144					; size = 4
_pDest2$1$ = -140					; size = 4
_alphatemp$6 = -140					; size = 4
_offsetX$GSCopy$1$ = -136				; size = 4
_sizeY$1$ = -136					; size = 4
_pSource$7 = -132					; size = 4
_ddsd$8 = -128						; size = 108
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_surface_info$ = 8					; size = 4
_offsetX$ = 12						; size = 4
_offsetY$ = 16						; size = 4
_sizeX$ = 20						; size = 4
_sizeY$ = 24						; size = 4
_pBmpInfo$ = 28						; size = 4
?DrawBitmapToSurface2@@YAXPAUsurfaceInfo@@HHHHPAUtagBITMAPINFO@@@Z PROC ; DrawBitmapToSurface2, COMDAT

; 1263 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?DrawBitmapToSurface2@@YAXPAUsurfaceInfo@@HHHHPAUtagBITMAPINFO@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b 75 08	 mov	 esi, DWORD PTR _surface_info$[ebp]
  00034	8b 45 0c	 mov	 eax, DWORD PTR _offsetX$[ebp]
  00037	89 85 78 ff ff
	ff		 mov	 DWORD PTR _offsetX$GSCopy$1$[ebp], eax
  0003d	8b 5d 10	 mov	 ebx, DWORD PTR _offsetY$[ebp]

; 1264 : 	
; 1265 : 	try

  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1266 : 	{
; 1267 : #ifdef _CACHE_SURFACE_
; 1268 : 		LPDIRECTDRAWSURFACE lpSurface = surface_info->lpSurface;
; 1269 : 		DDSURFACEDESC ddsd;
; 1270 : 		char *pDest;			//目的地指标//
; 1271 : 		char *pCache;			//缓存
; 1272 : 		char *pSource; 			//来源指标//
; 1273 : 		BYTE *alphatemp;
; 1274 : 		int surfacePitch;		//source face 宽度//
; 1275 : 		int bmpWidth;			//bmp图的宽度//
; 1276 : 		int i;
; 1277 : 
; 1278 : 		if (lpSurface == NULL) return;
; 1279 : 
; 1280 : 		surface_info->sizeX = sizeX;
; 1281 : 		surface_info->sizeY = sizeY;
; 1282 : 		surface_info->palNo = -1;
; 1283 : 		surface_info->colordepth = NewColor16Flg;
; 1284 : 
; 1285 : 		if (surface_info->lpCacheData == NULL)
; 1286 : 		{
; 1287 : 			surface_info->lpCacheData = (char *)MALLOC(SurfaceSizeX*SurfaceSizeY);
; 1288 : 			if (surface_info->lpCacheData == NULL) return;
; 1289 : 		}
; 1290 : 		memset(surface_info->lpCacheData, 0, SurfaceSizeX*SurfaceSizeY);
; 1291 : 		pCache = surface_info->lpCacheData;
; 1292 : 
; 1293 : 		ZeroMemory(&ddsd, sizeof(DDSURFACEDESC));
; 1294 : 		ddsd.dwSize = sizeof(DDSURFACEDESC);
; 1295 : 		if (lpSurface->Lock(NULL, &ddsd, DDLOCK_WAIT, NULL) != DD_OK) {
; 1296 : 			return;
; 1297 : 		}
; 1298 : 		pDest = (char *)(ddsd.lpSurface);
; 1299 : 
; 1300 : 
; 1301 : 
; 1302 : #if 0
; 1303 : 		pSource = (char *)pBmpInfo + BmpOffBits
; 1304 : 			+ offsetY * pBmpInfo->bmiHeader.biWidth + offsetX;
; 1305 : #else
; 1306 : 		pSource = pRealBinBits
; 1307 : 			+ offsetY * RealBinWidth + offsetX;
; 1308 : 		if (NewColor16Flg == 2 && displayBpp == 16) {
; 1309 : 			surface_info->lpAlphaData = (BYTE*)MALLOC(SurfaceSizeX*SurfaceSizeY);
; 1310 : 			memset(surface_info->lpAlphaData, 0, SurfaceSizeX*SurfaceSizeY);
; 1311 : 			alphatemp = surface_info->lpAlphaData;
; 1312 : 		}
; 1313 : #endif
; 1314 : 		surfacePitch = ddsd.lPitch;
; 1315 : #if 0
; 1316 : 		bmpWidth = pBmpInfo->bmiHeader.biWidth;
; 1317 : #else
; 1318 : 		bmpWidth = RealBinWidth;
; 1319 : #endif
; 1320 : 		if (ResoMode == 1) {
; 1321 : 			pSource -= bmpWidth;
; 1322 : 			sizeY >>= 1;
; 1323 : 		}
; 1324 : 		for (i = 0; i < sizeY; i++) {
; 1325 : 			if (ResoMode == 1) {
; 1326 : 				_asm {
; 1327 : 					mov		edi, [pDest]
; 1328 : 					mov		esi, [pSource]
; 1329 : 					mov		eax, [sizeX]
; 1330 : 					shr		ax, 1
; 1331 : 					mov		cx, ax
; 1332 : 					inc		esi
; 1333 : 					loop_100 :
; 1334 : 					mov		al, [esi]
; 1335 : 						mov[edi], al
; 1336 : 						inc		esi
; 1337 : 						inc		esi
; 1338 : 						inc		edi
; 1339 : 						dec 	cx
; 1340 : 						jne		loop_100
; 1341 : 				}
; 1342 : 				pSource -= bmpWidth * 2;
; 1343 : 			}
; 1344 : 			else {
; 1345 : #ifdef _HI_COLOR_32
; 1346 : 				if (displayBpp == 32) {
; 1347 : 					if (NewColor16Flg)
; 1348 : 					{
; 1349 : 						int j;
; 1350 : 						int pixel;
; 1351 : 						int * pDest2;
; 1352 : 						pDest2 = (int *)pDest;
; 1353 : 						for (j = 0; j < sizeX; j++) {
; 1354 : #ifdef _NEW_COLOR_
; 1355 : 							if (NewColor16Flg == 1) {		//rgb565
; 1356 : 								short *pDest3 = (short *)((pSource - pRealBinBits) * 2 + pRealBinBits);
; 1357 : 								if (pDest3[j] == DEF_COLORKEY)
; 1358 : 									pDest2[j] = 0;
; 1359 : 								else {
; 1360 : 									pDest2[j] = (((pDest3[j] & 0x001F) << 3) | ((pDest3[j] & 0x07E0) << 5) | ((pDest3[j] & 0xF800) << 8) | 0xFF000000);
; 1361 : 								}
; 1362 : 							}
; 1363 : 							else if (NewColor16Flg == 2) {	//rgba8888
; 1364 : 								int *pDest3 = (int *)((pSource - pRealBinBits) * 4 + pRealBinBits);
; 1365 : 								if ((pDest3[j] & 0xFF000000) >> 24 == DEF_COLORKEY)
; 1366 : 									pDest2[j] = 0;
; 1367 : 								else {
; 1368 : 									pDest2[j] = pDest3[j];
; 1369 : 								}
; 1370 : 							}
; 1371 : #endif
; 1372 : 						}
; 1373 : 					}
; 1374 : 					else //256色 缓存数据
; 1375 : 					{
; 1376 : 						memcpy(pCache, pSource, sizeX);
; 1377 : 					}
; 1378 : 				}
; 1379 : 				else
; 1380 : #endif
; 1381 : 					if (displayBpp == 16) {
; 1382 : 						if (NewColor16Flg)
; 1383 : 						{
; 1384 : 
; 1385 : 							int j;
; 1386 : 							short pixel;
; 1387 : 							short *pDest2 = (short *)pDest;
; 1388 : 							for (j = 0; j < sizeX; j++) {
; 1389 : #ifdef _NEW_COLOR_
; 1390 : 								if (NewColor16Flg == 1) {		//rgb565
; 1391 : 									short *pDest3 = (short *)((pSource - pRealBinBits) * 2 + pRealBinBits);
; 1392 : 									if (pDest3[j] == DEF_COLORKEY)
; 1393 : 										pDest2[j] = 0;
; 1394 : 									else pDest2[j] = pDest3[j];
; 1395 : 								}
; 1396 : 								else if (NewColor16Flg == 2) {	//rgba8888
; 1397 : #define COLOR_TO_MTK_COLOR_SIMUL(color) ((((color) >> 19) & 0x1f) << 11) \
; 1398 : 	| ((((color) >> 10) & 0x3f) << 5)\
; 1399 : 	| (((color) >> 3) & 0x1f)
; 1400 : 									int *pDest3 = (int *)((pSource - pRealBinBits) * 4 + pRealBinBits);
; 1401 : 									if ((pDest3[j] & 0xFF000000) >> 24 == DEF_COLORKEY) {
; 1402 : 										pDest2[j] = 0;
; 1403 : 										alphatemp[i * 64 + j] = 0;
; 1404 : 									}
; 1405 : 									else {
; 1406 : 										alphatemp[i * 64 + j] = (pDest3[j] & 0xFF000000) >> 24;
; 1407 : 										pDest2[j] = COLOR_TO_MTK_COLOR_SIMUL(pDest3[j]);
; 1408 : 									}
; 1409 : 								}
; 1410 : #endif
; 1411 : 							}
; 1412 : 						}
; 1413 : 						else  //256色
; 1414 : 						{
; 1415 : 							memcpy(pCache, pSource, sizeX);
; 1416 : 						}
; 1417 : 					}
; 1418 : 					else {
; 1419 : 						memcpy(pDest, pSource, sizeX);
; 1420 : 					}
; 1421 : 					pSource -= bmpWidth;
; 1422 : 
; 1423 : 			}
; 1424 : 			pDest += surfacePitch;
; 1425 : 			pCache += SurfaceSizeX;
; 1426 : 		}
; 1427 : 		if (lpSurface->Unlock(NULL) != DD_OK) {
; 1428 : 			return;
; 1429 : 		}
; 1430 : #else
; 1431 : 		LPDIRECTDRAWSURFACE lpSurface = surface_info->lpSurface;

  00047	8b 3e		 mov	 edi, DWORD PTR [esi]
  00049	89 bd 54 ff ff
	ff		 mov	 DWORD PTR _lpSurface$1$[ebp], edi

; 1432 : 		DDSURFACEDESC ddsd;
; 1433 : 		char *pDest;			//目的地指标//
; 1434 : 		char *pSource; 		//来源指标//
; 1435 : 		BYTE *alphatemp;
; 1436 : 		int surfacePitch;	//source face 宽度//
; 1437 : 		int bmpWidth;			//bmp图的宽度//
; 1438 : 		int i;
; 1439 : 
; 1440 : 		if (lpSurface == NULL) return;

  0004f	85 ff		 test	 edi, edi
  00051	0f 84 fb 03 00
	00		 je	 $LN50@DrawBitmap

; 1441 : 		ZeroMemory(&ddsd, sizeof(DDSURFACEDESC));

  00057	6a 6c		 push	 108			; 0000006cH
  00059	6a 00		 push	 0
  0005b	8d 45 80	 lea	 eax, DWORD PTR _ddsd$8[ebp]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 _memset
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1442 : 		ddsd.dwSize = sizeof(DDSURFACEDESC);

  00067	c7 45 80 6c 00
	00 00		 mov	 DWORD PTR _ddsd$8[ebp], 108 ; 0000006cH

; 1443 : 		if (lpSurface->Lock(NULL, &ddsd, DDLOCK_WAIT, NULL) != DD_OK) {

  0006e	8b 07		 mov	 eax, DWORD PTR [edi]
  00070	6a 00		 push	 0
  00072	6a 01		 push	 1
  00074	8d 4d 80	 lea	 ecx, DWORD PTR _ddsd$8[ebp]
  00077	51		 push	 ecx
  00078	6a 00		 push	 0
  0007a	57		 push	 edi
  0007b	ff 50 64	 call	 DWORD PTR [eax+100]
  0007e	85 c0		 test	 eax, eax
  00080	0f 85 cc 03 00
	00		 jne	 $LN50@DrawBitmap

; 1444 : 			return;
; 1445 : 		}
; 1446 : 		pDest = (char *)(ddsd.lpSurface);

  00086	8b 7d a4	 mov	 edi, DWORD PTR _ddsd$8[ebp+36]
  00089	89 bd 74 ff ff
	ff		 mov	 DWORD PTR _pDest2$1$[ebp], edi
  0008f	89 bd 64 ff ff
	ff		 mov	 DWORD PTR _pDest$4[ebp], edi

; 1447 : #if 0
; 1448 : 		pSource = (char *)pBmpInfo + BmpOffBits
; 1449 : 			+ offsetY * pBmpInfo->bmiHeader.biWidth + offsetX;
; 1450 : #else
; 1451 : 		pSource = pRealBinBits

  00095	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?RealBinWidth@@3HA ; RealBinWidth
  0009b	89 95 6c ff ff
	ff		 mov	 DWORD PTR _bmpWidth$1$[ebp], edx
  000a1	0f af da	 imul	 ebx, edx
  000a4	03 9d 78 ff ff
	ff		 add	 ebx, DWORD PTR _offsetX$GSCopy$1$[ebp]
  000aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pRealBinBits@@3PADA ; pRealBinBits
  000b0	03 d9		 add	 ebx, ecx
  000b2	89 9d 7c ff ff
	ff		 mov	 DWORD PTR _pSource$7[ebp], ebx

; 1452 : 			+ offsetY * RealBinWidth + offsetX;
; 1453 : 		if (NewColor16Flg == 2 && displayBpp == 16) {

  000b8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?NewColor16Flg@@3HA ; NewColor16Flg
  000bd	83 f8 02	 cmp	 eax, 2
  000c0	75 53		 jne	 SHORT $LN61@DrawBitmap
  000c2	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR ?displayBpp@@3HA, 16 ; displayBpp, 00000010H
  000c9	75 4a		 jne	 SHORT $LN61@DrawBitmap

; 1454 : 			surface_info->lpAlphaData = (BYTE*)MALLOC(SurfaceSizeX*SurfaceSizeY);

  000cb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SurfaceSizeY@@3HA ; SurfaceSizeY
  000d0	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR ?SurfaceSizeX@@3HA ; SurfaceSizeX
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 _malloc
  000dd	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1455 : 			memset(surface_info->lpAlphaData, 0, SurfaceSizeX*SurfaceSizeY);

  000e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?SurfaceSizeY@@3HA ; SurfaceSizeY
  000e6	0f af 0d 00 00
	00 00		 imul	 ecx, DWORD PTR ?SurfaceSizeX@@3HA ; SurfaceSizeX
  000ed	51		 push	 ecx
  000ee	6a 00		 push	 0
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 _memset
  000f6	83 c4 10	 add	 esp, 16			; 00000010H

; 1456 : 			alphatemp = surface_info->lpAlphaData;

  000f9	8b 76 08	 mov	 esi, DWORD PTR [esi+8]

; 1452 : 			+ offsetY * RealBinWidth + offsetX;
; 1453 : 		if (NewColor16Flg == 2 && displayBpp == 16) {

  000fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pRealBinBits@@3PADA ; pRealBinBits
  00102	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?RealBinWidth@@3HA ; RealBinWidth
  00108	89 95 6c ff ff
	ff		 mov	 DWORD PTR _bmpWidth$1$[ebp], edx
  0010e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?NewColor16Flg@@3HA ; NewColor16Flg
  00113	eb 06		 jmp	 SHORT $LN65@DrawBitmap
$LN61@DrawBitmap:

; 1457 : 		}
; 1458 : #endif
; 1459 : 		surfacePitch = ddsd.lPitch;

  00115	8b b5 74 ff ff
	ff		 mov	 esi, DWORD PTR _alphatemp$6[ebp]
$LN65@DrawBitmap:
  0011b	89 b5 70 ff ff
	ff		 mov	 DWORD PTR _alphatemp$1$[ebp], esi
  00121	8b 75 90	 mov	 esi, DWORD PTR _ddsd$8[ebp+16]
  00124	89 b5 58 ff ff
	ff		 mov	 DWORD PTR _surfacePitch$1$[ebp], esi

; 1460 : #if 0
; 1461 : 		bmpWidth = pBmpInfo->bmiHeader.biWidth;
; 1462 : #else
; 1463 : 		bmpWidth = RealBinWidth;
; 1464 : #endif
; 1465 : 		if (ResoMode == 1) {

  0012a	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?ResoMode@@3HA, 1 ; ResoMode
  00131	75 0f		 jne	 SHORT $LN63@DrawBitmap

; 1466 : 			pSource -= bmpWidth;

  00133	2b da		 sub	 ebx, edx
  00135	89 9d 7c ff ff
	ff		 mov	 DWORD PTR _pSource$7[ebp], ebx

; 1467 : 			sizeY >>= 1;

  0013b	8b 55 18	 mov	 edx, DWORD PTR _sizeY$[ebp]
  0013e	d1 fa		 sar	 edx, 1

; 1460 : #if 0
; 1461 : 		bmpWidth = pBmpInfo->bmiHeader.biWidth;
; 1462 : #else
; 1463 : 		bmpWidth = RealBinWidth;
; 1464 : #endif
; 1465 : 		if (ResoMode == 1) {

  00140	eb 03		 jmp	 SHORT $LN66@DrawBitmap
$LN63@DrawBitmap:
  00142	8b 55 18	 mov	 edx, DWORD PTR _sizeY$[ebp]
$LN66@DrawBitmap:

; 1468 : 		}
; 1469 : 		for (i = 0; i < sizeY; i++) {

  00145	89 95 78 ff ff
	ff		 mov	 DWORD PTR _sizeY$1$[ebp], edx
  0014b	33 f6		 xor	 esi, esi
  0014d	89 b5 68 ff ff
	ff		 mov	 DWORD PTR _i$5[ebp], esi
  00153	8b 55 14	 mov	 edx, DWORD PTR _sizeX$[ebp]
  00156	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@DrawBitmap:
  00160	3b b5 78 ff ff
	ff		 cmp	 esi, DWORD PTR _sizeY$1$[ebp]
  00166	0f 8d c6 02 00
	00		 jge	 $LN3@DrawBitmap

; 1470 : 			if (ResoMode == 1) {

  0016c	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?ResoMode@@3HA, 1 ; ResoMode
  00173	75 48		 jne	 SHORT $LN16@DrawBitmap

; 1471 : 				_asm {
; 1472 : 					mov		edi, [pDest]

  00175	8b bd 64 ff ff
	ff		 mov	 edi, DWORD PTR _pDest$4[ebp]

; 1473 : 					mov		esi, [pSource]

  0017b	8b b5 7c ff ff
	ff		 mov	 esi, DWORD PTR _pSource$7[ebp]

; 1474 : 					mov		eax, [sizeX]

  00181	8b 45 14	 mov	 eax, DWORD PTR _sizeX$[ebp]

; 1475 : 					shr		ax, 1

  00184	66 d1 e8	 shr	 ax, 1

; 1476 : 					mov		cx, ax

  00187	66 8b c8	 mov	 cx, ax

; 1477 : 					inc		esi

  0018a	46		 inc	 esi
$loop_100$69:

; 1478 : 					loop_100 :
; 1479 : 					mov		al, [esi]

  0018b	8a 06		 mov	 al, BYTE PTR [esi]

; 1480 : 						mov[edi], al

  0018d	88 07		 mov	 BYTE PTR [edi], al

; 1481 : 						inc		esi

  0018f	46		 inc	 esi

; 1482 : 						inc		esi

  00190	46		 inc	 esi

; 1483 : 						inc		edi

  00191	47		 inc	 edi

; 1484 : 						dec 	cx

  00192	66 49		 dec	 cx

; 1485 : 						jne		loop_100

  00194	75 f5		 jne	 SHORT $loop_100$69

; 1486 : 				}
; 1487 : 				pSource -= bmpWidth * 2;

  00196	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _bmpWidth$1$[ebp]
  0019c	f7 d8		 neg	 eax
  0019e	8d 1c 43	 lea	 ebx, DWORD PTR [ebx+eax*2]
  001a1	89 9d 7c ff ff
	ff		 mov	 DWORD PTR _pSource$7[ebp], ebx

; 1488 : 			}

  001a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pRealBinBits@@3PADA ; pRealBinBits
  001ad	a1 00 00 00 00	 mov	 eax, DWORD PTR ?NewColor16Flg@@3HA ; NewColor16Flg
  001b2	8b bd 74 ff ff
	ff		 mov	 edi, DWORD PTR _pDest2$1$[ebp]
  001b8	e9 51 02 00 00	 jmp	 $LN17@DrawBitmap
$LN16@DrawBitmap:

; 1489 : 			else {
; 1490 : #ifdef _HI_COLOR_32
; 1491 : 				if (displayBpp == 32) {

  001bd	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR ?displayBpp@@3HA, 32 ; displayBpp, 00000020H
  001c4	0f 85 0e 01 00
	00		 jne	 $LN18@DrawBitmap

; 1492 : 					int j;
; 1493 : 					int pixel;
; 1494 : 					int * pDest2;
; 1495 : 					pDest2 = (int *)pDest;
; 1496 : 					for (j = 0; j < sizeX; j++) {

  001ca	33 f6		 xor	 esi, esi
  001cc	89 b5 60 ff ff
	ff		 mov	 DWORD PTR _j$3[ebp], esi
$LL7@DrawBitmap:
  001d2	3b f2		 cmp	 esi, edx
  001d4	0f 8d 28 02 00
	00		 jge	 $LN33@DrawBitmap

; 1497 : #ifdef _NEW_COLOR_
; 1498 : 						if (NewColor16Flg == 1) {

  001da	83 f8 01	 cmp	 eax, 1
  001dd	75 6b		 jne	 SHORT $LN20@DrawBitmap

; 1499 : 							short *pDest3 = (short *)((pSource - pRealBinBits) * 2 + pRealBinBits);

  001df	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  001e2	2b c1		 sub	 eax, ecx

; 1500 : 							if (pDest3[j] == DEF_COLORKEY)

  001e4	0f b7 04 70	 movzx	 eax, WORD PTR [eax+esi*2]
  001e8	66 85 c0	 test	 ax, ax
  001eb	75 1b		 jne	 SHORT $LN22@DrawBitmap

; 1501 : 								pDest2[j] = 0;

  001ed	c7 04 b7 00 00
	00 00		 mov	 DWORD PTR [edi+esi*4], 0

; 1492 : 					int j;
; 1493 : 					int pixel;
; 1494 : 					int * pDest2;
; 1495 : 					pDest2 = (int *)pDest;
; 1496 : 					for (j = 0; j < sizeX; j++) {

  001f4	46		 inc	 esi
  001f5	89 b5 60 ff ff
	ff		 mov	 DWORD PTR _j$3[ebp], esi
  001fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pRealBinBits@@3PADA ; pRealBinBits
  00201	a1 00 00 00 00	 mov	 eax, DWORD PTR ?NewColor16Flg@@3HA ; NewColor16Flg
  00206	eb ca		 jmp	 SHORT $LL7@DrawBitmap
$LN22@DrawBitmap:

; 1502 : 							else {
; 1503 : 								pDest2[j] = (((pDest3[j] & 0x001F) << 3) | ((pDest3[j] & 0x07E0) << 5) | ((pDest3[j] & 0xF800) << 8) | 0xFF000000);

  00208	0f bf c8	 movsx	 ecx, ax
  0020b	8b d1		 mov	 edx, ecx
  0020d	81 e2 00 f8 ff
	ff		 and	 edx, -2048		; fffff800H
  00213	81 ca 00 00 ff
	ff		 or	 edx, -65536		; ffff0000H
  00219	c1 e2 03	 shl	 edx, 3
  0021c	8b c1		 mov	 eax, ecx
  0021e	25 e0 07 00 00	 and	 eax, 2016		; 000007e0H
  00223	0b d0		 or	 edx, eax
  00225	c1 e2 02	 shl	 edx, 2
  00228	83 e1 1f	 and	 ecx, 31			; 0000001fH
  0022b	0b d1		 or	 edx, ecx
  0022d	c1 e2 03	 shl	 edx, 3
  00230	89 14 b7	 mov	 DWORD PTR [edi+esi*4], edx

; 1504 : 							}
; 1505 : 						}

  00233	8b 55 14	 mov	 edx, DWORD PTR _sizeX$[ebp]

; 1492 : 					int j;
; 1493 : 					int pixel;
; 1494 : 					int * pDest2;
; 1495 : 					pDest2 = (int *)pDest;
; 1496 : 					for (j = 0; j < sizeX; j++) {

  00236	46		 inc	 esi
  00237	89 b5 60 ff ff
	ff		 mov	 DWORD PTR _j$3[ebp], esi
  0023d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pRealBinBits@@3PADA ; pRealBinBits
  00243	a1 00 00 00 00	 mov	 eax, DWORD PTR ?NewColor16Flg@@3HA ; NewColor16Flg
  00248	eb 88		 jmp	 SHORT $LL7@DrawBitmap
$LN20@DrawBitmap:

; 1506 : 						else if (NewColor16Flg == 2) {

  0024a	83 f8 02	 cmp	 eax, 2
  0024d	75 36		 jne	 SHORT $LN24@DrawBitmap

; 1507 : 							int *pDest3 = (int *)((pSource - pRealBinBits) * 4 + pRealBinBits);

  0024f	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00252	8d 0c 9d 00 00
	00 00		 lea	 ecx, DWORD PTR [ebx*4]
  00259	2b c8		 sub	 ecx, eax

; 1508 : 							if ((pDest3[j] & 0xFF000000) >> 24 == DEF_COLORKEY)

  0025b	80 7c b1 03 00	 cmp	 BYTE PTR [ecx+esi*4+3], 0
  00260	75 1e		 jne	 SHORT $LN26@DrawBitmap

; 1509 : 								pDest2[j] = 0;

  00262	c7 04 b7 00 00
	00 00		 mov	 DWORD PTR [edi+esi*4], 0

; 1492 : 					int j;
; 1493 : 					int pixel;
; 1494 : 					int * pDest2;
; 1495 : 					pDest2 = (int *)pDest;
; 1496 : 					for (j = 0; j < sizeX; j++) {

  00269	46		 inc	 esi
  0026a	89 b5 60 ff ff
	ff		 mov	 DWORD PTR _j$3[ebp], esi
  00270	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pRealBinBits@@3PADA ; pRealBinBits
  00276	a1 00 00 00 00	 mov	 eax, DWORD PTR ?NewColor16Flg@@3HA ; NewColor16Flg
  0027b	e9 52 ff ff ff	 jmp	 $LL7@DrawBitmap
$LN26@DrawBitmap:

; 1510 : 							else {
; 1511 : 								pDest2[j] = pDest3[j];

  00280	8b 04 b1	 mov	 eax, DWORD PTR [ecx+esi*4]

; 1512 : 							}
; 1513 : 						}

  00283	eb 39		 jmp	 SHORT $LN67@DrawBitmap
$LN24@DrawBitmap:

; 1514 : 						else {
; 1515 : #endif
; 1516 : 							if (pSource[j] == DEF_COLORKEY) {

  00285	8a 04 1e	 mov	 al, BYTE PTR [esi+ebx]
  00288	84 c0		 test	 al, al
  0028a	75 1e		 jne	 SHORT $LN28@DrawBitmap

; 1517 : 								pDest2[j] = 0;

  0028c	c7 04 b7 00 00
	00 00		 mov	 DWORD PTR [edi+esi*4], 0

; 1492 : 					int j;
; 1493 : 					int pixel;
; 1494 : 					int * pDest2;
; 1495 : 					pDest2 = (int *)pDest;
; 1496 : 					for (j = 0; j < sizeX; j++) {

  00293	46		 inc	 esi
  00294	89 b5 60 ff ff
	ff		 mov	 DWORD PTR _j$3[ebp], esi
  0029a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pRealBinBits@@3PADA ; pRealBinBits
  002a0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?NewColor16Flg@@3HA ; NewColor16Flg
  002a5	e9 28 ff ff ff	 jmp	 $LL7@DrawBitmap
$LN28@DrawBitmap:

; 1518 : 							}
; 1519 : 							else {
; 1520 : 								pixel = highColor32Palette[(unsigned char)pSource[j]];

  002aa	0f b6 c0	 movzx	 eax, al
  002ad	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?highColor32Palette@@3PAIA[eax*4]

; 1521 : 								if (pixel == 0) {

  002b4	85 c0		 test	 eax, eax
  002b6	b9 01 00 00 00	 mov	 ecx, 1
  002bb	0f 44 c1	 cmove	 eax, ecx
$LN67@DrawBitmap:

; 1492 : 					int j;
; 1493 : 					int pixel;
; 1494 : 					int * pDest2;
; 1495 : 					pDest2 = (int *)pDest;
; 1496 : 					for (j = 0; j < sizeX; j++) {

  002be	89 04 b7	 mov	 DWORD PTR [edi+esi*4], eax
  002c1	46		 inc	 esi
  002c2	89 b5 60 ff ff
	ff		 mov	 DWORD PTR _j$3[ebp], esi
  002c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pRealBinBits@@3PADA ; pRealBinBits
  002ce	a1 00 00 00 00	 mov	 eax, DWORD PTR ?NewColor16Flg@@3HA ; NewColor16Flg
  002d3	e9 fa fe ff ff	 jmp	 $LL7@DrawBitmap
$LN18@DrawBitmap:

; 1522 : 									pDest2[j] = 1;
; 1523 : 								}
; 1524 : 								else {
; 1525 : 									pDest2[j] = pixel;
; 1526 : 								}
; 1527 : 							}
; 1528 : #ifdef _NEW_COLOR_
; 1529 : 						}
; 1530 : #endif
; 1531 : 					}
; 1532 : 				}
; 1533 : 				else
; 1534 : #endif
; 1535 : 					if (displayBpp == 16) {

  002d8	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR ?displayBpp@@3HA, 16 ; displayBpp, 00000010H
  002df	0f 85 04 01 00
	00		 jne	 $LN32@DrawBitmap

; 1536 : 						int j;
; 1537 : 						short pixel;
; 1538 : 						short *pDest2 = (short *)pDest;
; 1539 : 						for (j = 0; j < sizeX; j++) {

  002e5	33 f6		 xor	 esi, esi
  002e7	89 b5 5c ff ff
	ff		 mov	 DWORD PTR _j$2[ebp], esi
  002ed	0f 1f 00	 npad	 3
$LL10@DrawBitmap:
  002f0	3b f2		 cmp	 esi, edx
  002f2	0f 8d 0a 01 00
	00		 jge	 $LN33@DrawBitmap

; 1540 : #ifdef _NEW_COLOR_
; 1541 : 							if (NewColor16Flg == 1) {

  002f8	83 f8 01	 cmp	 eax, 1
  002fb	75 19		 jne	 SHORT $LN34@DrawBitmap

; 1542 : 								short *pDest3 = (short *)((pSource - pRealBinBits) * 2 + pRealBinBits);

  002fd	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  00300	2b c1		 sub	 eax, ecx

; 1543 : 								if (pDest3[j] == DEF_COLORKEY)

  00302	0f b7 04 70	 movzx	 eax, WORD PTR [eax+esi*2]
  00306	66 85 c0	 test	 ax, ax
  00309	0f 85 bf 00 00
	00		 jne	 $LN44@DrawBitmap

; 1544 : 									pDest2[j] = 0;

  0030f	33 c0		 xor	 eax, eax
  00311	e9 b8 00 00 00	 jmp	 $LN44@DrawBitmap
$LN34@DrawBitmap:

; 1545 : 								else pDest2[j] = pDest3[j];
; 1546 : 							}
; 1547 : 							else if (NewColor16Flg == 2) {

  00316	83 f8 02	 cmp	 eax, 2
  00319	0f 85 8f 00 00
	00		 jne	 $LN38@DrawBitmap

; 1548 : #define COLOR_TO_MTK_COLOR_SIMUL(color) ((((color) >> 19) & 0x1f) << 11) \
; 1549 : 	|((((color) >> 10) & 0x3f) << 5)\
; 1550 : 	|(((color) >> 3) & 0x1f)
; 1551 : 								int *pDest3 = (int *)((pSource - pRealBinBits) * 4 + pRealBinBits);

  0031f	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00322	8d 0c 9d 00 00
	00 00		 lea	 ecx, DWORD PTR [ebx*4]
  00329	2b c8		 sub	 ecx, eax

; 1552 : 								if ((pDest3[j] & 0xFF000000) >> 24 == DEF_COLORKEY) {

  0032b	8a 54 b1 03	 mov	 dl, BYTE PTR [ecx+esi*4+3]
  0032f	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _i$5[ebp]
  00335	c1 e0 06	 shl	 eax, 6
  00338	03 85 70 ff ff
	ff		 add	 eax, DWORD PTR _alphatemp$1$[ebp]
  0033e	84 d2		 test	 dl, dl
  00340	75 20		 jne	 SHORT $LN40@DrawBitmap

; 1553 : 									pDest2[j] = 0;

  00342	33 d2		 xor	 edx, edx
  00344	66 89 14 77	 mov	 WORD PTR [edi+esi*2], dx

; 1554 : 									alphatemp[i * 64 + j] = 0;

  00348	88 14 30	 mov	 BYTE PTR [eax+esi], dl

; 1555 : 								}

  0034b	8b 55 14	 mov	 edx, DWORD PTR _sizeX$[ebp]

; 1536 : 						int j;
; 1537 : 						short pixel;
; 1538 : 						short *pDest2 = (short *)pDest;
; 1539 : 						for (j = 0; j < sizeX; j++) {

  0034e	46		 inc	 esi
  0034f	89 b5 5c ff ff
	ff		 mov	 DWORD PTR _j$2[ebp], esi
  00355	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pRealBinBits@@3PADA ; pRealBinBits
  0035b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?NewColor16Flg@@3HA ; NewColor16Flg
  00360	eb 8e		 jmp	 SHORT $LL10@DrawBitmap
$LN40@DrawBitmap:

; 1556 : 								else {
; 1557 : 									alphatemp[i * 64 + j] = (pDest3[j] & 0xFF000000) >> 24;

  00362	88 14 30	 mov	 BYTE PTR [eax+esi], dl

; 1558 : 									pDest2[j] = COLOR_TO_MTK_COLOR_SIMUL(pDest3[j]);

  00365	8b 14 b1	 mov	 edx, DWORD PTR [ecx+esi*4]
  00368	8b ca		 mov	 ecx, edx
  0036a	c1 f9 03	 sar	 ecx, 3
  0036d	c1 e9 02	 shr	 ecx, 2
  00370	c1 e9 03	 shr	 ecx, 3
  00373	81 e1 00 f8 ff
	ff		 and	 ecx, -2048		; fffff800H
  00379	8b c2		 mov	 eax, edx
  0037b	c1 e8 02	 shr	 eax, 2
  0037e	c1 e8 03	 shr	 eax, 3
  00381	25 e0 07 00 00	 and	 eax, 2016		; 000007e0H
  00386	0b c8		 or	 ecx, eax
  00388	c1 ea 03	 shr	 edx, 3
  0038b	83 e2 1f	 and	 edx, 31			; 0000001fH
  0038e	0b ca		 or	 ecx, edx
  00390	66 89 0c 77	 mov	 WORD PTR [edi+esi*2], cx

; 1559 : 								}
; 1560 : 							}

  00394	8b 55 14	 mov	 edx, DWORD PTR _sizeX$[ebp]

; 1536 : 						int j;
; 1537 : 						short pixel;
; 1538 : 						short *pDest2 = (short *)pDest;
; 1539 : 						for (j = 0; j < sizeX; j++) {

  00397	46		 inc	 esi
  00398	89 b5 5c ff ff
	ff		 mov	 DWORD PTR _j$2[ebp], esi
  0039e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pRealBinBits@@3PADA ; pRealBinBits
  003a4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?NewColor16Flg@@3HA ; NewColor16Flg
  003a9	e9 42 ff ff ff	 jmp	 $LL10@DrawBitmap
$LN38@DrawBitmap:

; 1561 : 							else {
; 1562 : #endif
; 1563 : 								if (pSource[j] == DEF_COLORKEY) {

  003ae	8a 04 1e	 mov	 al, BYTE PTR [esi+ebx]
  003b1	84 c0		 test	 al, al
  003b3	75 04		 jne	 SHORT $LN42@DrawBitmap

; 1564 : 									pDest2[j] = 0;

  003b5	33 c0		 xor	 eax, eax

; 1565 : 								}

  003b7	eb 15		 jmp	 SHORT $LN44@DrawBitmap
$LN42@DrawBitmap:

; 1566 : 								else {
; 1567 : 									pixel = highColorPalette[(unsigned char)pSource[j]];

  003b9	0f b6 c0	 movzx	 eax, al
  003bc	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?highColorPalette@@3PAGA[eax*2]

; 1568 : 									if (pixel == 0) {

  003c4	66 85 c0	 test	 ax, ax
  003c7	75 05		 jne	 SHORT $LN44@DrawBitmap

; 1569 : 										pDest2[j] = 1;

  003c9	b8 01 00 00 00	 mov	 eax, 1
$LN44@DrawBitmap:

; 1536 : 						int j;
; 1537 : 						short pixel;
; 1538 : 						short *pDest2 = (short *)pDest;
; 1539 : 						for (j = 0; j < sizeX; j++) {

  003ce	66 89 04 77	 mov	 WORD PTR [edi+esi*2], ax
  003d2	46		 inc	 esi
  003d3	89 b5 5c ff ff
	ff		 mov	 DWORD PTR _j$2[ebp], esi
  003d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pRealBinBits@@3PADA ; pRealBinBits
  003df	a1 00 00 00 00	 mov	 eax, DWORD PTR ?NewColor16Flg@@3HA ; NewColor16Flg
  003e4	e9 07 ff ff ff	 jmp	 $LL10@DrawBitmap
$LN32@DrawBitmap:

; 1570 : 									}
; 1571 : 									else {
; 1572 : 										pDest2[j] = pixel;
; 1573 : 									}
; 1574 : 								}
; 1575 : #ifdef _NEW_COLOR_
; 1576 : 							}
; 1577 : #endif
; 1578 : 						}
; 1579 : 
; 1580 : 
; 1581 : 
; 1582 : 
; 1583 : 
; 1584 : 					}
; 1585 : 					else {
; 1586 : 						memcpy(pDest, pSource, sizeX);

  003e9	52		 push	 edx
  003ea	53		 push	 ebx
  003eb	57		 push	 edi
  003ec	e8 00 00 00 00	 call	 _memcpy
  003f1	83 c4 0c	 add	 esp, 12			; 0000000cH
  003f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pRealBinBits@@3PADA ; pRealBinBits
  003fa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?NewColor16Flg@@3HA ; NewColor16Flg
  003ff	8b 55 14	 mov	 edx, DWORD PTR _sizeX$[ebp]
$LN33@DrawBitmap:

; 1587 : 					}
; 1588 : 					pSource -= bmpWidth;

  00402	2b 9d 6c ff ff
	ff		 sub	 ebx, DWORD PTR _bmpWidth$1$[ebp]
  00408	89 9d 7c ff ff
	ff		 mov	 DWORD PTR _pSource$7[ebp], ebx
$LN17@DrawBitmap:

; 1589 : 
; 1590 : 			}
; 1591 : 			pDest += surfacePitch;

  0040e	03 bd 58 ff ff
	ff		 add	 edi, DWORD PTR _surfacePitch$1$[ebp]
  00414	89 bd 74 ff ff
	ff		 mov	 DWORD PTR _pDest2$1$[ebp], edi
  0041a	89 bd 64 ff ff
	ff		 mov	 DWORD PTR _pDest$4[ebp], edi

; 1468 : 		}
; 1469 : 		for (i = 0; i < sizeY; i++) {

  00420	8b b5 68 ff ff
	ff		 mov	 esi, DWORD PTR _i$5[ebp]
  00426	46		 inc	 esi
  00427	89 b5 68 ff ff
	ff		 mov	 DWORD PTR _i$5[ebp], esi
  0042d	e9 2e fd ff ff	 jmp	 $LL4@DrawBitmap
$LN3@DrawBitmap:

; 1592 : 		}
; 1593 : 		if (lpSurface->Unlock(NULL) != DD_OK) {

  00432	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _lpSurface$1$[ebp]
  00438	8b 01		 mov	 eax, DWORD PTR [ecx]
  0043a	6a 00		 push	 0
  0043c	51		 push	 ecx
  0043d	ff 90 80 00 00
	00		 call	 DWORD PTR [eax+128]

; 1594 : 			return;
; 1595 : 		}
; 1596 : 		return;

  00443	eb 0d		 jmp	 SHORT $LN50@DrawBitmap
__catch$?DrawBitmapToSurface2@@YAXPAUsurfaceInfo@@HHHHPAUtagBITMAPINFO@@@Z$0:

; 1597 : #endif
; 1598 : 
; 1599 : 	}
; 1600 : 	catch (...)
; 1601 : 	{
; 1602 : 
; 1603 : 	}

  00445	b8 00 00 00 00	 mov	 eax, $LN51@DrawBitmap
  0044a	c3		 ret	 0
$LN51@DrawBitmap:
  0044b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN50@DrawBitmap:

; 1604 : 	
; 1605 : 
; 1606 : }

  00452	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00455	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0045c	59		 pop	 ecx
  0045d	5f		 pop	 edi
  0045e	5e		 pop	 esi
  0045f	5b		 pop	 ebx
  00460	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00463	33 cd		 xor	 ecx, ebp
  00465	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0046a	8b e5		 mov	 esp, ebp
  0046c	5d		 pop	 ebp
  0046d	c3		 ret	 0
  0046e	cc		 int	 3
  0046f	cc		 int	 3
  00470	cc		 int	 3
  00471	cc		 int	 3
  00472	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?DrawBitmapToSurface2@@YAXPAUsurfaceInfo@@HHHHPAUtagBITMAPINFO@@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 50 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-176]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?DrawBitmapToSurface2@@YAXPAUsurfaceInfo@@HHHHPAUtagBITMAPINFO@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?DrawBitmapToSurface2@@YAXPAUsurfaceInfo@@HHHHPAUtagBITMAPINFO@@@Z ENDP ; DrawBitmapToSurface2
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?DrawSurfaceFast@@YAJFFPAUIDirectDrawSurface@@@Z
_TEXT	SEGMENT
_lpSurface$GSCopy$1$ = -80				; size = 4
tv358 = -76						; size = 4
tv359 = -72						; size = 4
$T2 = -68						; size = 4
_y0$1$ = -64						; size = 4
_x0$1$ = -60						; size = 4
tv355 = -60						; size = 4
_rect$1$ = -56						; size = 4
_rectD$3 = -52						; size = 16
_rect$4 = -36						; size = 16
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_bx$ = 8						; size = 2
_by$ = 12						; size = 2
_lpSurface$ = 16					; size = 4
?DrawSurfaceFast@@YAJFFPAUIDirectDrawSurface@@@Z PROC	; DrawSurfaceFast, COMDAT

; 2887 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?DrawSurfaceFast@@YAJFFPAUIDirectDrawSurface@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002e	8b 45 10	 mov	 eax, DWORD PTR _lpSurface$[ebp]
  00031	89 45 b0	 mov	 DWORD PTR _lpSurface$GSCopy$1$[ebp], eax

; 2888 : 	try

  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 2889 : 	{
; 2890 : 		short x0, y0;
; 2891 : 		long w, h;
; 2892 : 		RECT rect = { 0, 0, SurfaceSizeX, SurfaceSizeY };

  0003b	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _rect$4[ebp], 0
  00042	33 f6		 xor	 esi, esi
  00044	89 75 c8	 mov	 DWORD PTR _rect$1$[ebp], esi
  00047	89 75 e0	 mov	 DWORD PTR _rect$4[ebp+4], esi
  0004a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?SurfaceSizeX@@3HA ; SurfaceSizeX
  00050	89 7d e4	 mov	 DWORD PTR _rect$4[ebp+8], edi
  00053	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?SurfaceSizeY@@3HA ; SurfaceSizeY
  00059	89 55 e8	 mov	 DWORD PTR _rect$4[ebp+12], edx

; 2893 : 		x0 = bx;

  0005c	0f b7 4d 08	 movzx	 ecx, WORD PTR _bx$[ebp]
  00060	89 4d c4	 mov	 DWORD PTR _x0$1$[ebp], ecx

; 2894 : 		y0 = by;

  00063	66 8b 4d 0c	 mov	 cx, WORD PTR _by$[ebp]
  00067	0f b7 d9	 movzx	 ebx, cx
  0006a	89 5d c0	 mov	 DWORD PTR _y0$1$[ebp], ebx

; 2895 : 		w = rect.right - rect.left;
; 2896 : 		h = rect.bottom - rect.top;
; 2897 : 		if (bx >= lpDraw->xSize || bx + w <= 0 || by >= lpDraw->ySize || by + h <= 0) {

  0006d	0f bf 5d 08	 movsx	 ebx, WORD PTR _bx$[ebp]
  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00076	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [eax+132]
  0007c	3b d8		 cmp	 ebx, eax
  0007e	0f 8d e6 00 00
	00		 jge	 $LN4@DrawSurfac
  00084	8d 34 3b	 lea	 esi, DWORD PTR [ebx+edi]
  00087	89 75 b8	 mov	 DWORD PTR tv359[ebp], esi
  0008a	85 f6		 test	 esi, esi
  0008c	0f 8e d8 00 00
	00		 jle	 $LN4@DrawSurfac
  00092	0f bf c9	 movsx	 ecx, cx
  00095	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0009b	3b 8e 88 00 00
	00		 cmp	 ecx, DWORD PTR [esi+136]
  000a1	0f 8d c3 00 00
	00		 jge	 $LN4@DrawSurfac
  000a7	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  000aa	89 75 b4	 mov	 DWORD PTR tv358[ebp], esi
  000ad	85 f6		 test	 esi, esi
  000af	0f 8e b5 00 00
	00		 jle	 $LN4@DrawSurfac

; 2899 : 		}
; 2900 : 		if (bx < 0) {

  000b5	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  000bc	66 83 7d 08 00	 cmp	 WORD PTR _bx$[ebp], 0
  000c1	7d 1c		 jge	 SHORT $LN5@DrawSurfac

; 2901 : 			rect.left -= bx;

  000c3	8b c3		 mov	 eax, ebx
  000c5	f7 d8		 neg	 eax
  000c7	89 45 bc	 mov	 DWORD PTR $T2[ebp], eax
  000ca	89 45 dc	 mov	 DWORD PTR _rect$4[ebp], eax

; 2902 : 			x0 = 0;

  000cd	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _x0$1$[ebp], 0
  000d4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  000d9	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [eax+132]
$LN5@DrawSurfac:

; 2903 : 		}
; 2904 : 		if (bx + w > lpDraw->xSize) {

  000df	8b 75 c4	 mov	 esi, DWORD PTR _x0$1$[ebp]
  000e2	0f b7 f6	 movzx	 esi, si
  000e5	89 75 c4	 mov	 DWORD PTR tv355[ebp], esi
  000e8	39 45 b8	 cmp	 DWORD PTR tv359[ebp], eax
  000eb	8b 75 c8	 mov	 esi, DWORD PTR _rect$1$[ebp]
  000ee	7e 09		 jle	 SHORT $LN6@DrawSurfac

; 2905 : 			rect.right -= bx + w - lpDraw->xSize;

  000f0	2b c3		 sub	 eax, ebx
  000f2	2b c7		 sub	 eax, edi
  000f4	03 f8		 add	 edi, eax
  000f6	89 7d e4	 mov	 DWORD PTR _rect$4[ebp+8], edi
$LN6@DrawSurfac:

; 2906 : 		}
; 2907 : 		if (by < 0) {

  000f9	66 83 7d 0c 00	 cmp	 WORD PTR _by$[ebp], 0
  000fe	7d 0c		 jge	 SHORT $LN7@DrawSurfac

; 2908 : 			rect.top -= by;

  00100	8b f1		 mov	 esi, ecx
  00102	f7 de		 neg	 esi
  00104	89 75 e0	 mov	 DWORD PTR _rect$4[ebp+4], esi

; 2909 : 			y0 = 0;

  00107	33 c0		 xor	 eax, eax
  00109	89 45 c0	 mov	 DWORD PTR _y0$1$[ebp], eax
$LN7@DrawSurfac:

; 2910 : 		}
; 2911 : 		if (by + h > lpDraw->ySize) {

  0010c	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00112	8b 83 88 00 00
	00		 mov	 eax, DWORD PTR [ebx+136]
  00118	39 45 b4	 cmp	 DWORD PTR tv358[ebp], eax
  0011b	7e 09		 jle	 SHORT $LN8@DrawSurfac

; 2912 : 			rect.bottom -= by + h - lpDraw->ySize;

  0011d	2b c1		 sub	 eax, ecx
  0011f	2b c2		 sub	 eax, edx
  00121	03 d0		 add	 edx, eax
  00123	89 55 e8	 mov	 DWORD PTR _rect$4[ebp+12], edx
$LN8@DrawSurfac:

; 2913 : 		}
; 2914 : 
; 2915 : #ifdef _STONDEBUG_		
; 2916 : 		SurfaceDispCnt++;
; 2917 : #endif
; 2918 : 		RECT rectD;
; 2919 : 
; 2920 : 		rectD.left = x0;

  00126	8b 45 c4	 mov	 eax, DWORD PTR tv355[ebp]
  00129	0f b7 c0	 movzx	 eax, ax
  0012c	89 45 cc	 mov	 DWORD PTR _rectD$3[ebp], eax

; 2921 : 		rectD.top = y0;

  0012f	8b 5d c0	 mov	 ebx, DWORD PTR _y0$1$[ebp]
  00132	0f b7 cb	 movzx	 ecx, bx
  00135	89 4d d0	 mov	 DWORD PTR _rectD$3[ebp+4], ecx

; 2922 : 		rectD.right = x0 + (rect.right - rect.left);

  00138	2b 45 bc	 sub	 eax, DWORD PTR $T2[ebp]
  0013b	03 c7		 add	 eax, edi
  0013d	89 45 d4	 mov	 DWORD PTR _rectD$3[ebp+8], eax

; 2923 : 		rectD.bottom = y0 + (rect.bottom - rect.top);

  00140	2b ce		 sub	 ecx, esi
  00142	03 ca		 add	 ecx, edx
  00144	89 4d d8	 mov	 DWORD PTR _rectD$3[ebp+12], ecx

; 2924 : 		return lpDraw->lpBACKBUFFER->Blt(&rectD, lpSurface, &rect, DDBLT_KEYSRC | DDBLT_WAIT, NULL);

  00147	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0014d	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00150	8b 08		 mov	 ecx, DWORD PTR [eax]
  00152	6a 00		 push	 0
  00154	68 00 80 00 01	 push	 16809984		; 01008000H
  00159	8d 55 dc	 lea	 edx, DWORD PTR _rect$4[ebp]
  0015c	52		 push	 edx
  0015d	ff 75 b0	 push	 DWORD PTR _lpSurface$GSCopy$1$[ebp]
  00160	8d 55 cc	 lea	 edx, DWORD PTR _rectD$3[ebp]
  00163	52		 push	 edx
  00164	50		 push	 eax
  00165	ff 51 14	 call	 DWORD PTR [ecx+20]
  00168	eb 16		 jmp	 SHORT $LN12@DrawSurfac
$LN4@DrawSurfac:

; 2898 : 			return DD_OK;

  0016a	33 c0		 xor	 eax, eax
  0016c	eb 12		 jmp	 SHORT $LN12@DrawSurfac
__catch$?DrawSurfaceFast@@YAJFFPAUIDirectDrawSurface@@@Z$0:

; 2925 : 	}
; 2926 : 	catch (...)
; 2927 : 	{
; 2928 : 		return  E_FAIL;

  0016e	b8 00 00 00 00	 mov	 eax, $LN13@DrawSurfac
  00173	c3		 ret	 0
$LN13@DrawSurfac:
  00174	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0017b	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
$LN12@DrawSurfac:

; 2929 : 	}
; 2930 : 	
; 2931 : }

  00180	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00183	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0018a	59		 pop	 ecx
  0018b	5f		 pop	 edi
  0018c	5e		 pop	 esi
  0018d	5b		 pop	 ebx
  0018e	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00191	33 cd		 xor	 ecx, ebp
  00193	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00198	8b e5		 mov	 esp, ebp
  0019a	5d		 pop	 ebp
  0019b	c3		 ret	 0
  0019c	cc		 int	 3
  0019d	cc		 int	 3
  0019e	cc		 int	 3
  0019f	cc		 int	 3
  001a0	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?DrawSurfaceFast@@YAJFFPAUIDirectDrawSurface@@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00016	33 c8		 xor	 ecx, eax
  00018	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?DrawSurfaceFast@@YAJFFPAUIDirectDrawSurface@@@Z
  00022	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?DrawSurfaceFast@@YAJFFPAUIDirectDrawSurface@@@Z ENDP	; DrawSurfaceFast
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?CreateSurface@@YAPAUIDirectDrawSurface@@FFKI@Z
_TEXT	SEGMENT
_ddck$2 = -28						; size = 8
_lpSurface$3 = -20					; size = 4
__$EHRec$ = -16						; size = 16
_bxsize$ = 8						; size = 2
_bysize$ = 12						; size = 2
_ColorKey$ = 16						; size = 4
_VramOrSysram$ = 20					; size = 4
?CreateSurface@@YAPAUIDirectDrawSurface@@FFKI@Z PROC	; CreateSurface, COMDAT

; 846  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CreateSurface@@YAPAUIDirectDrawSurface@@FFKI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 847  : 	try

  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 848  : 	{
; 849  : 		DDCOLORKEY ddck;
; 850  : 		LPDIRECTDRAWSURFACE lpSurface;
; 851  : #ifdef _NEW_ALPHA_
; 852  : 		VramOrSysram = DDSCAPS_SYSTEMMEMORY;
; 853  : #endif
; 854  : 		lpDraw->ddsd.dwFlags = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00037	c7 40 18 07 00
	00 00		 mov	 DWORD PTR [eax+24], 7

; 855  : 		lpDraw->ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | VramOrSysram;

  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00043	c7 40 7c 40 08
	00 00		 mov	 DWORD PTR [eax+124], 2112 ; 00000840H

; 856  : 		lpDraw->ddsd.dwWidth = bxsize;

  0004a	0f bf 4d 08	 movsx	 ecx, WORD PTR _bxsize$[ebp]
  0004e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00053	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 857  : 		lpDraw->ddsd.dwHeight = bysize;

  00056	0f bf 4d 0c	 movsx	 ecx, WORD PTR _bysize$[ebp]
  0005a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0005f	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 858  : 		if (lpDraw->lpDD2->CreateSurface(&lpDraw->ddsd, &lpSurface, NULL) != DD_OK)

  00062	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00067	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006c	6a 00		 push	 0
  0006e	8d 75 ec	 lea	 esi, DWORD PTR _lpSurface$3[ebp]
  00071	56		 push	 esi
  00072	83 c0 14	 add	 eax, 20			; 00000014H
  00075	50		 push	 eax
  00076	51		 push	 ecx
  00077	ff 52 18	 call	 DWORD PTR [edx+24]
  0007a	85 c0		 test	 eax, eax
  0007c	75 3a		 jne	 SHORT $LN10@CreateSurf

; 859  : 			return (LPDIRECTDRAWSURFACE)NULL;
; 860  : 
; 861  : 		ddck.dwColorSpaceLowValue = ColorKey;

  0007e	8b 45 10	 mov	 eax, DWORD PTR _ColorKey$[ebp]
  00081	89 45 e4	 mov	 DWORD PTR _ddck$2[ebp], eax

; 862  : 		ddck.dwColorSpaceHighValue = ColorKey;

  00084	89 45 e8	 mov	 DWORD PTR _ddck$2[ebp+4], eax

; 863  : 		lpSurface->SetColorKey(DDCKEY_SRCBLT, &ddck);

  00087	8b 45 ec	 mov	 eax, DWORD PTR _lpSurface$3[ebp]
  0008a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008c	8d 55 e4	 lea	 edx, DWORD PTR _ddck$2[ebp]
  0008f	52		 push	 edx
  00090	6a 08		 push	 8
  00092	50		 push	 eax
  00093	ff 51 74	 call	 DWORD PTR [ecx+116]

; 864  : 
; 865  : 		return lpSurface;

  00096	8b 45 ec	 mov	 eax, DWORD PTR _lpSurface$3[ebp]

; 870  : 	}
; 871  : 
; 872  : 	
; 873  : }

  00099	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0009c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a3	59		 pop	 ecx
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
__catch$?CreateSurface@@YAPAUIDirectDrawSurface@@FFKI@Z$0:

; 866  : 	}
; 867  : 	catch (...)
; 868  : 	{
; 869  : 		return (LPDIRECTDRAWSURFACE)NULL;

  000ab	b8 00 00 00 00	 mov	 eax, $LN8@CreateSurf
  000b0	c3		 ret	 0
$LN8@CreateSurf:
  000b1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN10@CreateSurf:

; 870  : 	}
; 871  : 
; 872  : 	
; 873  : }

  000b8	33 c0		 xor	 eax, eax
  000ba	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000bd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c4	59		 pop	 ecx
  000c5	5f		 pop	 edi
  000c6	5e		 pop	 esi
  000c7	5b		 pop	 ebx
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
  000cc	cc		 int	 3
  000cd	cc		 int	 3
  000ce	cc		 int	 3
  000cf	cc		 int	 3
  000d0	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?CreateSurface@@YAPAUIDirectDrawSurface@@FFKI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CreateSurface@@YAPAUIDirectDrawSurface@@FFKI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CreateSurface@@YAPAUIDirectDrawSurface@@FFKI@Z ENDP	; CreateSurface
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?LoadDirectDrawBitmap@@YAPAUtagBITMAPINFO@@PAD@Z
_TEXT	SEGMENT
_BmpFileHeader$2 = -172					; size = 14
_ofSt$3 = -156						; size = 136
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_pFile$ = 8						; size = 4
?LoadDirectDrawBitmap@@YAPAUtagBITMAPINFO@@PAD@Z PROC	; LoadDirectDrawBitmap, COMDAT

; 799  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadDirectDrawBitmap@@YAPAUtagBITMAPINFO@@PAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b 45 08	 mov	 eax, DWORD PTR _pFile$[ebp]

; 800  : 	try

  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 801  : 	{
; 802  : 		HFILE hFile;
; 803  : 		OFSTRUCT ofSt;
; 804  : 		BITMAPFILEHEADER BmpFileHeader;
; 805  : 		LPBITMAPINFO lpBmpInfo;
; 806  : 
; 807  : 		//???????
; 808  : 		if ((hFile = OpenFile(pFile, &ofSt, OF_READ)) == HFILE_ERROR)

  0003b	6a 00		 push	 0
  0003d	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _ofSt$3[ebp]
  00043	51		 push	 ecx
  00044	50		 push	 eax
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenFile@12
  0004b	8b f0		 mov	 esi, eax
  0004d	83 fe ff	 cmp	 esi, -1
  00050	74 7b		 je	 SHORT $LN11@LoadDirect

; 809  : 			return (LPBITMAPINFO)NULL; // File Open Error
; 810  : 
; 811  : 									   //?????????????????
; 812  : 		_hread(hFile, &BmpFileHeader, sizeof(BITMAPFILEHEADER));

  00052	6a 0e		 push	 14			; 0000000eH
  00054	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _BmpFileHeader$2[ebp]
  0005a	50		 push	 eax
  0005b	56		 push	 esi
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___hread@12

; 813  : 
; 814  : 		//??????????
; 815  : 		if ((lpBmpInfo = (LPBITMAPINFO)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, BmpFileHeader.bfSize)) == NULL) {

  00062	ff b5 56 ff ff
	ff		 push	 DWORD PTR _BmpFileHeader$2[ebp+2]
  00068	6a 08		 push	 8
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  00070	50		 push	 eax
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapAlloc@12
  00077	8b f8		 mov	 edi, eax
  00079	85 ff		 test	 edi, edi
  0007b	75 1c		 jne	 SHORT $LN4@LoadDirect

; 816  : 			MessageBoxNew(hWnd, "Heap的配置记忆体失败！", "확인", MB_OK | MB_ICONSTOP);

  0007d	6a 10		 push	 16			; 00000010H
  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_04IJNKKJEO@?H?$KO?$MA?N@
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KMOPGAB@Heap?n?$NM?$NL?U?v?G?$DP?$DP?$DP?c?w?$DP?$KD?$KB@
  00089	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  0008f	e8 00 00 00 00	 call	 ?MessageBoxNew@@YAHPAUHWND__@@PBD1I@Z ; MessageBoxNew
  00094	83 c4 10	 add	 esp, 16			; 00000010H

; 817  : 			return (LPBITMAPINFO)NULL; //Memory Error

  00097	eb 34		 jmp	 SHORT $LN11@LoadDirect
$LN4@LoadDirect:

; 818  : 		}
; 819  : 
; 820  : 		//????????
; 821  : 		_hread(hFile, (void *)lpBmpInfo, BmpFileHeader.bfSize);

  00099	ff b5 56 ff ff
	ff		 push	 DWORD PTR _BmpFileHeader$2[ebp+2]
  0009f	57		 push	 edi
  000a0	56		 push	 esi
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___hread@12

; 822  : 
; 823  : 		//????????
; 824  : 		_lclose(hFile);

  000a7	56		 push	 esi
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___lclose@4

; 825  : 
; 826  : 		// ???????????????????
; 827  : 		BmpOffBits = BmpFileHeader.bfOffBits - sizeof(BITMAPFILEHEADER);

  000ae	8b 85 5e ff ff
	ff		 mov	 eax, DWORD PTR _BmpFileHeader$2[ebp+10]
  000b4	83 c0 f2	 add	 eax, -14		; fffffff2H
  000b7	a3 00 00 00 00	 mov	 DWORD PTR ?BmpOffBits@@3HA, eax ; BmpOffBits

; 828  : 
; 829  : 		return lpBmpInfo;

  000bc	8b c7		 mov	 eax, edi
  000be	eb 0f		 jmp	 SHORT $LN8@LoadDirect
__catch$?LoadDirectDrawBitmap@@YAPAUtagBITMAPINFO@@PAD@Z$0:

; 830  : 	}
; 831  : 	catch (...)
; 832  : 	{
; 833  : 		return (LPBITMAPINFO)NULL;

  000c0	b8 00 00 00 00	 mov	 eax, $LN9@LoadDirect
  000c5	c3		 ret	 0
$LN9@LoadDirect:
  000c6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN11@LoadDirect:

; 834  : 	}
; 835  : 	
; 836  : }

  000cd	33 c0		 xor	 eax, eax
$LN8@LoadDirect:
  000cf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000d2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d9	59		 pop	 ecx
  000da	5f		 pop	 edi
  000db	5e		 pop	 esi
  000dc	5b		 pop	 ebx
  000dd	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e0	33 cd		 xor	 ecx, ebp
  000e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c3		 ret	 0
  000eb	cc		 int	 3
  000ec	cc		 int	 3
  000ed	cc		 int	 3
  000ee	cc		 int	 3
  000ef	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?LoadDirectDrawBitmap@@YAPAUtagBITMAPINFO@@PAD@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 50 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-176]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadDirectDrawBitmap@@YAPAUtagBITMAPINFO@@PAD@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadDirectDrawBitmap@@YAPAUtagBITMAPINFO@@PAD@Z ENDP	; LoadDirectDrawBitmap
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?ClearSurface@@YAXPAUIDirectDrawSurface@@@Z
_TEXT	SEGMENT
_ddbltfx$2 = -116					; size = 100
__$EHRec$ = -16						; size = 16
_lpSurface$ = 8						; size = 4
?ClearSurface@@YAXPAUIDirectDrawSurface@@@Z PROC	; ClearSurface, COMDAT

; 762  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ClearSurface@@YAXPAUIDirectDrawSurface@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 68	 sub	 esp, 104		; 00000068H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 763  : 
; 764  : 	try

  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 765  : 	{
; 766  : 		DDBLTFX ddbltfx;
; 767  : 		if (!lpSurface)

  00032	8b 75 08	 mov	 esi, DWORD PTR _lpSurface$[ebp]
  00035	85 f6		 test	 esi, esi
  00037	74 3a		 je	 SHORT $LN7@ClearSurfa

; 768  : 		{
; 769  : 			return;
; 770  : 		}
; 771  : 
; 772  : 		ZeroMemory(&ddbltfx, sizeof(DDBLTFX));

  00039	6a 64		 push	 100			; 00000064H
  0003b	6a 00		 push	 0
  0003d	8d 45 8c	 lea	 eax, DWORD PTR _ddbltfx$2[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _memset
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH

; 773  : 		ddbltfx.dwSize = sizeof(DDBLTFX);

  00049	c7 45 8c 64 00
	00 00		 mov	 DWORD PTR _ddbltfx$2[ebp], 100 ; 00000064H

; 774  : 		ddbltfx.dwFillColor = DEF_COLORKEY; // ???

  00050	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _ddbltfx$2[ebp+80], 0

; 775  : 
; 776  : 		lpSurface->Blt(NULL, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &ddbltfx);

  00057	8b 06		 mov	 eax, DWORD PTR [esi]
  00059	8d 4d 8c	 lea	 ecx, DWORD PTR _ddbltfx$2[ebp]
  0005c	51		 push	 ecx
  0005d	68 00 04 00 01	 push	 16778240		; 01000400H
  00062	6a 00		 push	 0
  00064	6a 00		 push	 0
  00066	6a 00		 push	 0
  00068	56		 push	 esi
  00069	ff 50 14	 call	 DWORD PTR [eax+20]
$LN8@ClearSurfa:

; 782  : 
; 783  : 	
; 784  : 
; 785  : 
; 786  : 
; 787  : 	return;
; 788  : }

  0006c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN7@ClearSurfa:
  00073	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007d	59		 pop	 ecx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
__catch$?ClearSurface@@YAXPAUIDirectDrawSurface@@@Z$0:

; 777  : 	}
; 778  : 	catch (...)
; 779  : 	{
; 780  : 
; 781  : 	}

  00085	b8 00 00 00 00	 mov	 eax, $LN8@ClearSurfa
  0008a	c3		 ret	 0
  0008b	cc		 int	 3
  0008c	cc		 int	 3
  0008d	cc		 int	 3
  0008e	cc		 int	 3
  0008f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?ClearSurface@@YAXPAUIDirectDrawSurface@@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a 88	 mov	 ecx, DWORD PTR [edx-120]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ClearSurface@@YAXPAUIDirectDrawSurface@@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ClearSurface@@YAXPAUIDirectDrawSurface@@@Z ENDP	; ClearSurface
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?ClearBackSurface@@YAXXZ
_TEXT	SEGMENT
_ddbltfx$ = -116					; size = 100
__$EHRec$ = -16						; size = 16
?ClearBackSurface@@YAXXZ PROC				; ClearBackSurface, COMDAT

; 717  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ClearBackSurface@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 68	 sub	 esp, 104		; 00000068H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 718  : 	DDBLTFX ddbltfx;
; 719  : 
; 720  : 	try

  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 721  : 	{
; 722  : 		ZeroMemory(&ddbltfx, sizeof(DDBLTFX));

  00032	6a 64		 push	 100			; 00000064H
  00034	6a 00		 push	 0
  00036	8d 45 8c	 lea	 eax, DWORD PTR _ddbltfx$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _memset
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 723  : 		ddbltfx.dwSize = sizeof(DDBLTFX);

  00042	c7 45 8c 64 00
	00 00		 mov	 DWORD PTR _ddbltfx$[ebp], 100 ; 00000064H

; 724  : #ifdef  _STONDEBUG_
; 725  : 		QueryPerformanceCounter(&tf);
; 726  : 		iTotalProcTime = (int)tf.QuadPart;
; 727  : #endif
; 728  : 		if (lpDraw->lpBACKBUFFER)

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0004e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00051	85 c9		 test	 ecx, ecx
  00053	74 15		 je	 SHORT $LN8@ClearBackS

; 729  : 		{
; 730  : 			HRESULT hr = lpDraw->lpBACKBUFFER->Blt(NULL, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &ddbltfx);

  00055	8b 01		 mov	 eax, DWORD PTR [ecx]
  00057	8d 55 8c	 lea	 edx, DWORD PTR _ddbltfx$[ebp]
  0005a	52		 push	 edx
  0005b	68 00 04 00 01	 push	 16778240		; 01000400H
  00060	6a 00		 push	 0
  00062	6a 00		 push	 0
  00064	6a 00		 push	 0
  00066	51		 push	 ecx
  00067	ff 50 14	 call	 DWORD PTR [eax+20]
$LN8@ClearBackS:

; 752  : 
; 753  : 
; 754  : }

  0006a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00071	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00074	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007b	59		 pop	 ecx
  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
__catch$?ClearBackSurface@@YAXXZ$0:

; 731  : 		}
; 732  : 
; 733  : #ifdef _READ16BITBMP
; 734  : 		if (g_bUseAlpha) {
; 735  : 			if (lpDraw->lpBACKBUFFERSYS)
; 736  : 			{
; 737  : 				lpDraw->lpBACKBUFFERSYS->Blt(NULL, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &ddbltfx);
; 738  : 			}
; 739  : 
; 740  : 		}
; 741  : #endif
; 742  : #ifdef  _STONDEBUG_
; 743  : 		QueryPerformanceCounter(&tf);
; 744  : 		iTotalUseTime += (((int)tf.QuadPart - iTotalProcTime)) / 100;
; 745  : 		iTotalRunCount++;
; 746  : #endif
; 747  : 	}
; 748  : 	catch (...)
; 749  : 	{
; 750  : 
; 751  : 	}

  00083	b8 00 00 00 00	 mov	 eax, $LN8@ClearBackS
  00088	c3		 ret	 0
  00089	cc		 int	 3
  0008a	cc		 int	 3
  0008b	cc		 int	 3
  0008c	cc		 int	 3
  0008d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?ClearBackSurface@@YAXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a 88	 mov	 ecx, DWORD PTR [edx-120]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ClearBackSurface@@YAXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ClearBackSurface@@YAXXZ ENDP				; ClearBackSurface
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?InitPalette@@YAHXZ
_TEXT	SEGMENT
tv4019 = -8						; size = 4
tv4020 = -4						; size = 4
?InitPalette@@YAHXZ PROC				; InitPalette, COMDAT

; 344  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 345  : 	int i;
; 346  : 	FILE *fp;
; 347  : 
; 348  : 	PALETTEENTRY pal[32] = {
; 349  : 		// ?????
; 350  : 	{ 0x00, 0x00, 0x00, PC_NOCOLLAPSE | PC_RESERVED }, // 0:?
; 351  : 	{ 0x80, 0x00, 0x00, PC_NOCOLLAPSE | PC_RESERVED }, // 1:??
; 352  : 	{ 0x00, 0x80, 0x00, PC_NOCOLLAPSE | PC_RESERVED }, // 2:???
; 353  : 	{ 0x80, 0x80, 0x00, PC_NOCOLLAPSE | PC_RESERVED }, // 3:???
; 354  : 	{ 0x00, 0x00, 0x80, PC_NOCOLLAPSE | PC_RESERVED }, // 4:??
; 355  : 	{ 0x80, 0x00, 0x80, PC_NOCOLLAPSE | PC_RESERVED }, // 5:???
; 356  : 	{ 0x00, 0x80, 0x80, PC_NOCOLLAPSE | PC_RESERVED }, // 6:???
; 357  : 	{ 0xc0, 0xc0, 0xc0, PC_NOCOLLAPSE | PC_RESERVED }, // 7:???
; 358  : 	{ 0xc0, 0xdc, 0xc0, PC_NOCOLLAPSE | PC_RESERVED }, // 8:?
; 359  : 	{ 0xa6, 0xca, 0xf0, PC_NOCOLLAPSE | PC_RESERVED }, // 9:?
; 360  : 
; 361  : 	//新系统色盘//
; 362  : 	{ 0xde, 0x00, 0x00, PC_NOCOLLAPSE | PC_RESERVED },//10
; 363  : 	{ 0xff, 0x5f, 0x00, PC_NOCOLLAPSE | PC_RESERVED },//11
; 364  : 	{ 0xff, 0xff, 0xa0, PC_NOCOLLAPSE | PC_RESERVED },//12
; 365  : 	{ 0x00, 0x5f, 0xd2, PC_NOCOLLAPSE | PC_RESERVED },//13
; 366  : 	{ 0x50, 0xd2, 0xff, PC_NOCOLLAPSE | PC_RESERVED },//14
; 367  : 	{ 0x28, 0xe1, 0x28, PC_NOCOLLAPSE | PC_RESERVED },//15
; 368  : 
; 369  : 	//新系统色盘//
; 370  : 	{ 0xf5, 0xc3, 0x96, PC_NOCOLLAPSE | PC_RESERVED },
; 371  : 	{ 0xe1, 0xa0, 0x5f, PC_NOCOLLAPSE | PC_RESERVED },
; 372  : 	{ 0xc3, 0x7d, 0x46, PC_NOCOLLAPSE | PC_RESERVED },
; 373  : 	{ 0x9b, 0x55, 0x1e, PC_NOCOLLAPSE | PC_RESERVED },
; 374  : 	{ 0x46, 0x41, 0x37, PC_NOCOLLAPSE | PC_RESERVED },
; 375  : 	{ 0x28, 0x23, 0x1e, PC_NOCOLLAPSE | PC_RESERVED },
; 376  : 
; 377  : 	// ?????
; 378  : 	{ 0xff, 0xfb, 0xf0, PC_NOCOLLAPSE | PC_RESERVED }, // 246
; 379  : 	{ 0xa0, 0xa0, 0xa4, PC_NOCOLLAPSE | PC_RESERVED }, // 247
; 380  : 	{ 0x80, 0x80, 0x80, PC_NOCOLLAPSE | PC_RESERVED }, // 248
; 381  : 	{ 0xff, 0x00, 0x00, PC_NOCOLLAPSE | PC_RESERVED }, // 249
; 382  : 	{ 0x00, 0xff, 0x00, PC_NOCOLLAPSE | PC_RESERVED }, // 250
; 383  : 	{ 0xff, 0xff, 0x00, PC_NOCOLLAPSE | PC_RESERVED }, // 251
; 384  : 	{ 0x00, 0x00, 0xff, PC_NOCOLLAPSE | PC_RESERVED }, // 252
; 385  : 	{ 0xff, 0x00, 0xff, PC_NOCOLLAPSE | PC_RESERVED }, // 253
; 386  : 	{ 0x00, 0xff, 0xff, PC_NOCOLLAPSE | PC_RESERVED }, // 254
; 387  : 	{ 0xff, 0xff, 0xff, PC_NOCOLLAPSE | PC_RESERVED }  // 255
; 388  : 	};
; 389  : 
; 390  : 
; 391  : 	// ??????????
; 392  : 	for (i = 0; i < 10; i++) {
; 393  : 		Palette[i].peBlue = pal[i].peBlue;
; 394  : 		Palette[i].peGreen = pal[i].peGreen;

  00006	c7 05 01 00 00
	00 00 00 02 80	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+1, -2147352576 ; 80020000H

; 395  : 		Palette[i].peRed = pal[i].peRed;
; 396  : 		Palette[i].peFlags = PC_EXPLICIT;
; 397  : 
; 398  : 		Palette[i + 246].peBlue = pal[i + 22].peBlue;
; 399  : 		Palette[i + 246].peGreen = pal[i + 22].peGreen;
; 400  : 		Palette[i + 246].peRed = pal[i + 22].peRed;
; 401  : 		Palette[i + 246].peFlags = PC_EXPLICIT;
; 402  : 	}
; 403  : 
; 404  : 	// ??????????
; 405  : 	for (i = 0; i < 6; i++) {
; 406  : 		Palette[i + 10].peBlue = pal[i + 10].peBlue;
; 407  : 		Palette[i + 10].peGreen = pal[i + 10].peGreen;
; 408  : 		Palette[i + 10].peRed = pal[i + 10].peRed;
; 409  : 		Palette[i + 10].peFlags = PC_NOCOLLAPSE | PC_RESERVED;
; 410  : 
; 411  : 		Palette[i + 240].peBlue = pal[i + 16].peBlue;
; 412  : 		Palette[i + 240].peGreen = pal[i + 16].peGreen;
; 413  : 		Palette[i + 240].peRed = pal[i + 16].peRed;
; 414  : 		Palette[i + 240].peFlags = PC_NOCOLLAPSE | PC_RESERVED;
; 415  : 	}
; 416  : 
; 417  : 	//只有第一次才作(没有初始化时)// ????????????????
; 418  : 	if (PalState.flag == FALSE) {

  00010	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR ?PalState@@3UPALETTE_STATE@@A+8, 0
  00017	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?Palette@@3PAUtagPALETTEENTRY@@A, 0
  0001e	c7 05 d9 03 00
	00 fb f0 02 a0	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+985, -1610419973 ; a002f0fbH
  00028	56		 push	 esi
  00029	57		 push	 edi
  0002a	c7 05 d5 03 00
	00 23 1e 05 ff	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+981, -16441821 ; ff051e23H
  00034	c7 05 05 00 00
	00 00 00 02 00	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+5, 131072 ; 00020000H
  0003e	c7 05 dd 03 00
	00 a0 a4 02 80	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+989, -2147310432 ; 8002a4a0H
  00048	c7 05 09 00 00
	00 80 00 02 80	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+9, -2147352448 ; 80020080H
  00052	c7 05 e1 03 00
	00 80 80 02 ff	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+993, -16613248 ; ff028080H
  0005c	c7 05 0d 00 00
	00 80 00 02 00	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+13, 131200 ; 00020080H
  00066	c7 05 e5 03 00
	00 00 00 02 00	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+997, 131072 ; 00020000H
  00070	c7 05 11 00 00
	00 00 80 02 80	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+17, -2147319808 ; 80028000H
  0007a	c7 05 e9 03 00
	00 ff 00 02 ff	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+1001, -16645889 ; ff0200ffH
  00084	c7 05 15 00 00
	00 00 80 02 00	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+21, 163840 ; 00028000H
  0008e	c7 05 ed 03 00
	00 ff 00 02 00	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+1005, 131327 ; 000200ffH
  00098	c7 05 19 00 00
	00 80 80 02 c0	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+25, -1073577856 ; c0028080H
  000a2	c7 05 f1 03 00
	00 00 ff 02 ff	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+1009, -16580864 ; ff02ff00H
  000ac	c7 05 1d 00 00
	00 c0 c0 02 c0	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+29, -1073561408 ; c002c0c0H
  000b6	c7 05 f5 03 00
	00 00 ff 02 00	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+1013, 196352 ; 0002ff00H
  000c0	c7 05 21 00 00
	00 dc c0 02 a6	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+33, -1509768996 ; a602c0dcH
  000ca	c7 05 f9 03 00
	00 ff ff 02 ff	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+1017, -16580609 ; ff02ffffH
  000d4	c7 05 25 00 00
	00 ca f0 02 de	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+37, -570232630 ; de02f0caH
  000de	66 c7 05 fd 03
	00 00 ff ff	 mov	 WORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+1021, 65535 ; 0000ffffH
  000e7	c6 05 ff 03 00
	00 02		 mov	 BYTE PTR ?Palette@@3PAUtagPALETTEENTRY@@A+1023, 2
  000ee	c7 05 29 00 00
	00 00 00 05 ff	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+41, -16449536 ; ff050000H
  000f8	c7 05 c1 03 00
	00 c3 96 05 e1	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+961, -519727421 ; e10596c3H
  00102	c6 05 c0 03 00
	00 f5		 mov	 BYTE PTR ?Palette@@3PAUtagPALETTEENTRY@@A+960, 245 ; 000000f5H
  00109	c7 05 2d 00 00
	00 5f 00 05 ff	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+45, -16449441 ; ff05005fH
  00113	c7 05 c5 03 00
	00 a0 5f 05 c3	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+965, -1023058016 ; c3055fa0H
  0011d	c7 05 31 00 00
	00 ff a0 05 00	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+49, 368895 ; 0005a0ffH
  00127	c7 05 c9 03 00
	00 7d 46 05 9b	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+969, -1694153091 ; 9b05467dH
  00131	c7 05 35 00 00
	00 5f d2 05 50	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+53, 1342558815 ; 5005d25fH
  0013b	c7 05 cd 03 00
	00 55 1e 05 46	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+973, 1174740565 ; 46051e55H
  00145	c7 05 39 00 00
	00 d2 ff 05 28	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+57, 671481810 ; 2805ffd2H
  0014f	c7 05 d1 03 00
	00 41 37 05 28	 mov	 DWORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+977, 671430465 ; 28053741H
  00159	66 c7 05 3d 00
	00 00 e1 28	 mov	 WORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+61, 10465 ; 000028e1H
  00162	c6 05 3f 00 00
	00 05		 mov	 BYTE PTR ?Palette@@3PAUtagPALETTEENTRY@@A+63, 5
  00169	75 7a		 jne	 SHORT $LN19@InitPalett

; 419  : 		fp = fopen(palFileName[0], "rb");

  0016b	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  00170	ff 35 00 00 00
	00		 push	 DWORD PTR ?palFileName@@3PAPADA
  00176	e8 00 00 00 00	 call	 _fopen
  0017b	8b f8		 mov	 edi, eax
  0017d	83 c4 08	 add	 esp, 8

; 420  : 		if (fp == NULL) {

  00180	85 ff		 test	 edi, edi
  00182	75 22		 jne	 SHORT $LN18@InitPalett

; 421  : 			MessageBoxNew(hWnd, "인덱스 파일 읽기", "Error", MB_OK | MB_ICONSTOP);

  00184	6a 10		 push	 16			; 00000010H
  00186	68 00 00 00 00	 push	 OFFSET ??_C@_05NAOIJFC@Error@
  0018b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MMJDDNEI@?$MA?N?$LF?$KG?$LN?$LK?5?F?D?$MA?O?5?$MA?P?$LB?b@
$LN67@InitPalett:

; 516  : 		}

  00190	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  00196	e8 00 00 00 00	 call	 ?MessageBoxNew@@YAHPAUHWND__@@PBD1I@Z ; MessageBoxNew
  0019b	83 c4 10	 add	 esp, 16			; 00000010H
  0019e	33 c0		 xor	 eax, eax
  001a0	5f		 pop	 edi
  001a1	5e		 pop	 esi
  001a2	8b e5		 mov	 esp, ebp
  001a4	5d		 pop	 ebp
  001a5	c3		 ret	 0
$LN18@InitPalett:

; 422  : 			return FALSE;
; 423  : 		}
; 424  : 		else {
; 425  : 			//可自由使用的调色盘设定// ??????????
; 426  : 			for (i = 16; i < 240; i++) {

  001a6	be 41 00 00 00	 mov	 esi, OFFSET ?Palette@@3PAUtagPALETTEENTRY@@A+65
  001ab	0f 1f 44 00 00	 npad	 5
$LL10@InitPalett:

; 427  : 				//档案读入// ????????
; 428  : 				Palette[i].peBlue = fgetc(fp);

  001b0	57		 push	 edi
  001b1	e8 00 00 00 00	 call	 _fgetc

; 429  : 				Palette[i].peGreen = fgetc(fp);

  001b6	57		 push	 edi
  001b7	88 46 01	 mov	 BYTE PTR [esi+1], al
  001ba	e8 00 00 00 00	 call	 _fgetc

; 430  : 				Palette[i].peRed = fgetc(fp);

  001bf	57		 push	 edi
  001c0	88 06		 mov	 BYTE PTR [esi], al
  001c2	e8 00 00 00 00	 call	 _fgetc
  001c7	88 46 ff	 mov	 BYTE PTR [esi-1], al
  001ca	83 c4 0c	 add	 esp, 12			; 0000000cH

; 431  : 				Palette[i].peFlags = PC_NOCOLLAPSE | PC_RESERVED;

  001cd	c6 46 02 05	 mov	 BYTE PTR [esi+2], 5
  001d1	83 c6 04	 add	 esi, 4
  001d4	81 fe c1 03 00
	00		 cmp	 esi, OFFSET ?Palette@@3PAUtagPALETTEENTRY@@A+961
  001da	7c d4		 jl	 SHORT $LL10@InitPalett

; 432  : 			}
; 433  : 			fclose(fp);

  001dc	57		 push	 edi
  001dd	e8 00 00 00 00	 call	 _fclose
  001e2	83 c4 04	 add	 esp, 4
$LN19@InitPalett:

; 434  : 		}
; 435  : 	}
; 436  : 	if (!transmigrationEffectFlag)

  001e5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?transmigrationEffectFlag@@3HA, 0 ; transmigrationEffectFlag
  001ec	75 10		 jne	 SHORT $LN20@InitPalett

; 437  : 	{
; 438  : 		Palette[168].peBlue = 0;
; 439  : 		Palette[168].peGreen = 0;

  001ee	66 c7 05 a1 02
	00 00 00 00	 mov	 WORD PTR ?Palette@@3PAUtagPALETTEENTRY@@A+673, 0

; 440  : 		Palette[168].peRed = 0;

  001f7	c6 05 a0 02 00
	00 00		 mov	 BYTE PTR ?Palette@@3PAUtagPALETTEENTRY@@A+672, 0
$LN20@InitPalett:

; 441  : 		//Palette[168].peFlags 	= PC_EXPLICIT;
; 442  : 	}
; 443  : 
; 444  : #if 0
; 445  : 	else {
; 446  : 		// ??????????
; 447  : 		for (i = 16; i < 240; i++) {
; 448  : 			// ??????????
; 449  : 			if (WindowMode) {
; 450  : 				Palette[i].peFlags = PC_NOCOLLAPSE | PC_RESERVED;
; 451  : 			}
; 452  : 			else {
; 453  : 				Palette[i].peFlags = PC_EXPLICIT;
; 454  : 			}
; 455  : 		}
; 456  : 	}
; 457  : #endif
; 458  : 	lpDraw->lpDD2->CreatePalette(DDPCAPS_8BIT, Palette, &lpDraw->lpPALETTE, NULL);

  001fe	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00203	6a 00		 push	 0
  00205	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00208	83 e8 80	 sub	 eax, -128		; ffffff80H
  0020b	50		 push	 eax
  0020c	68 00 00 00 00	 push	 OFFSET ?Palette@@3PAUtagPALETTEENTRY@@A ; Palette
  00211	6a 04		 push	 4
  00213	8b 11		 mov	 edx, DWORD PTR [ecx]
  00215	51		 push	 ecx
  00216	ff 52 14	 call	 DWORD PTR [edx+20]

; 459  : 	if (lpDraw->lpPALETTE == NULL) {

  00219	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0021f	8b 91 80 00 00
	00		 mov	 edx, DWORD PTR [ecx+128]
  00225	85 d2		 test	 edx, edx
  00227	75 11		 jne	 SHORT $LN21@InitPalett

; 460  : 		MessageBoxNew(hWnd, "팔레트 처리 실패", "Error", MB_OK | MB_ICONSTOP);

  00229	6a 10		 push	 16			; 00000010H
  0022b	68 00 00 00 00	 push	 OFFSET ??_C@_05NAOIJFC@Error@
  00230	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KCGIAGNL@?F?H?$LH?$LJ?F?$KO?5?C?$LD?$LI?$KO?5?$LN?G?F?P@

; 461  : 		return FALSE;

  00235	e9 56 ff ff ff	 jmp	 $LN67@InitPalett
$LN21@InitPalett:

; 462  : 	}
; 463  : 	// WON REM 
; 464  : #ifdef _HI_COLOR_16
; 465  : 	//#ifdef _STONDEBUG_
; 466  : 	if (displayBpp == 8) {

  0023a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?displayBpp@@3HA ; displayBpp
  0023f	83 f8 08	 cmp	 eax, 8
  00242	75 4c		 jne	 SHORT $LN23@InitPalett

; 467  : 		if (lpDraw->lpFRONTBUFFER->SetPalette(lpDraw->lpPALETTE) != DD_OK) {

  00244	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00247	52		 push	 edx
  00248	50		 push	 eax
  00249	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024b	ff 51 7c	 call	 DWORD PTR [ecx+124]
  0024e	85 c0		 test	 eax, eax
  00250	74 39		 je	 SHORT $LN66@InitPalett

; 468  : 			MessageBoxNew(hWnd, "팔레트 처리 실패", "Error", MB_OK);

  00252	6a 00		 push	 0
  00254	68 00 00 00 00	 push	 OFFSET ??_C@_05NAOIJFC@Error@
  00259	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KCGIAGNL@?F?H?$LH?$LJ?F?$KO?5?C?$LD?$LI?$KO?5?$LN?G?F?P@
  0025e	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  00264	e8 00 00 00 00	 call	 ?MessageBoxNew@@YAHPAUHWND__@@PBD1I@Z ; MessageBoxNew

; 469  : 			MessageBoxNew(hWnd, "16비트 하이 컬러 또는 32비트 하이 컬러 프레임을 사용해주세요", "Error", MB_OK);

  00269	6a 00		 push	 0
  0026b	68 00 00 00 00	 push	 OFFSET ??_C@_05NAOIJFC@Error@
  00270	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@ECLMIGIM@16?$LK?q?F?$KO?5?G?O?$MA?L?5?D?C?$LH?$KP?5?$LG?G?$LE?B?532?$LK?q?F?$KO?5?G?O@
  00275	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  0027b	e8 00 00 00 00	 call	 ?MessageBoxNew@@YAHPAUHWND__@@PBD1I@Z ; MessageBoxNew
  00280	83 c4 20	 add	 esp, 32			; 00000020H

; 516  : 		}

  00283	33 c0		 xor	 eax, eax
  00285	5f		 pop	 edi
  00286	5e		 pop	 esi
  00287	8b e5		 mov	 esp, ebp
  00289	5d		 pop	 ebp
  0028a	c3		 ret	 0
$LN66@InitPalett:

; 467  : 		if (lpDraw->lpFRONTBUFFER->SetPalette(lpDraw->lpPALETTE) != DD_OK) {

  0028b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?displayBpp@@3HA ; displayBpp
$LN23@InitPalett:
  00290	53		 push	 ebx

; 470  : 			return FALSE;
; 471  : 		}
; 472  : 	}
; 473  : #else
; 474  : 	// Robin 05/02
; 475  : #ifdef SWITCH_MODE
; 476  : 	if (lpDraw->lpFRONTBUFFER->SetPalette(lpDraw->lpPALETTE) != DD_OK) {
; 477  : 		if (MessageBoxNew(hWnd, "请使用２５６色的显示模示", "확인", MB_RETRYCANCEL | MB_ICONEXCLAMATION) == IDCANCEL)
; 478  : 			return FALSE;
; 479  : 		return FALSE;
; 480  : 	}
; 481  : #else
; 482  : 	while (lpDraw->lpFRONTBUFFER->SetPalette(lpDraw->lpPALETTE) != DD_OK) {
; 483  : 		if (MessageBoxNew(hWnd, "请使用２５６色的显示模示", "확인", MB_RETRYCANCEL | MB_ICONEXCLAMATION) == IDCANCEL)
; 484  : 			return FALSE;
; 485  : 	}
; 486  : #endif
; 487  : 
; 488  : #endif
; 489  : 
; 490  : #ifdef _HI_COLOR_32
; 491  : 	if (displayBpp == 32) {

  00291	83 f8 20	 cmp	 eax, 32			; 00000020H
  00294	0f 85 89 00 00
	00		 jne	 $LN24@InitPalett

; 492  : 		highColor32Palette[0] = 0;

  0029a	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?gBitRShift@@3HA
  002a1	33 f6		 xor	 esi, esi
  002a3	0f b6 1d 00 00
	00 00		 movzx	 ebx, BYTE PTR ?rBitRShift@@3HA
  002aa	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?bBitLShift@@3HA ; bBitLShift
  002b0	89 45 fc	 mov	 DWORD PTR tv4020[ebp], eax
  002b3	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?bBitRShift@@3HA
  002ba	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?highColor32Palette@@3PAIA, 0
  002c4	89 45 f8	 mov	 DWORD PTR tv4019[ebp], eax
  002c7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL13@InitPalett:

; 493  : 		for (i = 1; i < 256; i++) {
; 494  : 			highColor32Palette[i] =

  002d0	0f b6 96 06 00
	00 00		 movzx	 edx, BYTE PTR ?Palette@@3PAUtagPALETTEENTRY@@A[esi+6]
  002d7	8a c8		 mov	 cl, al
  002d9	0f b6 86 04 00
	00 00		 movzx	 eax, BYTE PTR ?Palette@@3PAUtagPALETTEENTRY@@A[esi+4]
  002e0	d3 ea		 shr	 edx, cl
  002e2	8b cf		 mov	 ecx, edi
  002e4	d3 e2		 shl	 edx, cl
  002e6	8a cb		 mov	 cl, bl
  002e8	d3 e8		 shr	 eax, cl
  002ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?rBitLShift@@3HA ; rBitLShift
  002f0	d3 e0		 shl	 eax, cl
  002f2	8a 4d fc	 mov	 cl, BYTE PTR tv4020[ebp]
  002f5	03 d0		 add	 edx, eax
  002f7	0f b6 86 05 00
	00 00		 movzx	 eax, BYTE PTR ?Palette@@3PAUtagPALETTEENTRY@@A[esi+5]
  002fe	d3 e8		 shr	 eax, cl
  00300	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gBitLShift@@3HA ; gBitLShift
  00306	d3 e0		 shl	 eax, cl
  00308	03 d0		 add	 edx, eax
  0030a	8b 45 f8	 mov	 eax, DWORD PTR tv4019[ebp]
  0030d	89 96 04 00 00
	00		 mov	 DWORD PTR ?highColor32Palette@@3PAIA[esi+4], edx
  00313	83 c6 04	 add	 esi, 4
  00316	81 fe fc 03 00
	00		 cmp	 esi, 1020		; 000003fcH
  0031c	7c b2		 jl	 SHORT $LL13@InitPalett

; 495  : 				((Palette[i].peBlue >> bBitRShift) << bBitLShift)
; 496  : 				+ ((Palette[i].peGreen >> gBitRShift) << gBitLShift)
; 497  : 				+ ((Palette[i].peRed >> rBitRShift) << rBitLShift);
; 498  : 	}
; 499  : 			}

  0031e	e9 7c 00 00 00	 jmp	 $LN15@InitPalett
$LN24@InitPalett:

; 500  : 	else
; 501  : #endif
; 502  : 		if (displayBpp == 16) {

  00323	83 f8 10	 cmp	 eax, 16			; 00000010H
  00326	75 77		 jne	 SHORT $LN15@InitPalett

; 503  : 			// ??????????????
; 504  : 			highColorPalette[0] = 0;

  00328	8a 1d 00 00 00
	00		 mov	 bl, BYTE PTR ?gBitRShift@@3HA
  0032e	33 c0		 xor	 eax, eax
  00330	8a 3d 00 00 00
	00		 mov	 bh, BYTE PTR ?rBitRShift@@3HA
  00336	bf 02 00 00 00	 mov	 edi, OFFSET ?highColorPalette@@3PAGA+2
  0033b	66 a3 00 00 00
	00		 mov	 WORD PTR ?highColorPalette@@3PAGA, ax
  00341	be 04 00 00 00	 mov	 esi, OFFSET ?Palette@@3PAUtagPALETTEENTRY@@A+4
$LL16@InitPalett:

; 505  : 			for (i = 1; i < 256; i++) {
; 506  : 				highColorPalette[i] =

  00346	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  0034a	8d 7f 02	 lea	 edi, DWORD PTR [edi+2]
  0034d	8a cb		 mov	 cl, bl
  0034f	d2 e8		 shr	 al, cl
  00351	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gBitLShift@@3HA ; gBitLShift
  00357	0c 01		 or	 al, 1
  00359	0f b6 d0	 movzx	 edx, al
  0035c	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  00360	66 d3 e2	 shl	 dx, cl
  00363	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?bBitRShift@@3HA
  00369	d2 e8		 shr	 al, cl
  0036b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?bBitLShift@@3HA ; bBitLShift
  00371	0f b6 c0	 movzx	 eax, al
  00374	66 d3 e0	 shl	 ax, cl
  00377	8a cf		 mov	 cl, bh
  00379	66 03 d0	 add	 dx, ax
  0037c	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0037f	d2 e8		 shr	 al, cl
  00381	83 c6 04	 add	 esi, 4
  00384	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?rBitLShift@@3HA ; rBitLShift
  0038a	0f b6 c0	 movzx	 eax, al
  0038d	66 d3 e0	 shl	 ax, cl
  00390	66 03 d0	 add	 dx, ax
  00393	66 89 57 fe	 mov	 WORD PTR [edi-2], dx
  00397	81 fe 00 04 00
	00		 cmp	 esi, OFFSET ?Palette@@3PAUtagPALETTEENTRY@@A+1024
  0039d	7c a7		 jl	 SHORT $LL16@InitPalett
$LN15@InitPalett:

; 507  : 					((Palette[i].peBlue >> bBitRShift) << bBitLShift)
; 508  : 					//cary 2001 10 16
; 509  : 					+ (((Palette[i].peGreen >> gBitRShift) | 1) << gBitLShift)
; 510  : 					+ ((Palette[i].peRed >> rBitRShift) << rBitLShift);
; 511  : 			}
; 512  : 		}
; 513  : 
; 514  : 	PalState.flag = TRUE;
; 515  : 	return TRUE;

  0039f	5b		 pop	 ebx
  003a0	5f		 pop	 edi
  003a1	c7 05 08 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?PalState@@3UPALETTE_STATE@@A+8, 1
  003ab	b8 01 00 00 00	 mov	 eax, 1

; 516  : 		}

  003b0	5e		 pop	 esi
  003b1	8b e5		 mov	 esp, ebp
  003b3	5d		 pop	 ebp
  003b4	c3		 ret	 0
?InitPalette@@YAHXZ ENDP				; InitPalette
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\directDraw.cpp
;	COMDAT ?InitDirectDraw@@YAHXZ
_TEXT	SEGMENT
_ddscaps$ = -316					; size = 4
_dwWriteByte$ = -312					; size = 4
_hResult$6$ = -308					; size = 4
_hResult$5$ = -308					; size = 4
_hResult$4$ = -308					; size = 4
_hResult$3$ = -308					; size = 4
_hResult$2$ = -308					; size = 4
_hResult$1$ = -308					; size = 4
_ddPixelFormat$1 = -304					; size = 32
_szErrMsg$ = -264					; size = 256
__$ArrayPad$ = -4					; size = 4
?InitDirectDraw@@YAHXZ PROC				; InitDirectDraw, COMDAT

; 94   : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	56		 push	 esi
  00027	57		 push	 edi

; 95   : 	DWORD dwWriteByte;
; 96   : 	HANDLE hErrorLogFile;
; 97   : 	HRESULT hResult;
; 98   : 	char szErrMsg[256];
; 99   : 	DDSCAPS ddscaps;		// ?????????????
; 100  : 
; 101  : 	HDC hDcDest = GetDC(hWnd);

  00028	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4
  00034	8b f0		 mov	 esi, eax

; 102  : 	displayBpp = GetDeviceCaps(hDcDest, BITSPIXEL);

  00036	6a 0c		 push	 12			; 0000000cH
  00038	56		 push	 esi
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 103  : 	ReleaseDC(hWnd, hDcDest);

  0003f	56		 push	 esi
  00040	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  00046	a3 00 00 00 00	 mov	 DWORD PTR ?displayBpp@@3HA, eax ; displayBpp
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8

; 104  : 
; 105  : 	if ((hResult = DirectDrawCreate(NULL, &lpDraw->lpDD, NULL)) != DD_OK) {

  00051	6a 00		 push	 0
  00053	ff 35 00 00 00
	00		 push	 DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00059	6a 00		 push	 0
  0005b	e8 00 00 00 00	 call	 _DirectDrawCreate@12
  00060	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CreateFileA@28
  00066	89 85 cc fe ff
	ff		 mov	 DWORD PTR _hResult$1$[ebp], eax
  0006c	85 c0		 test	 eax, eax
  0006e	0f 84 fc 00 00
	00		 je	 $LN3@InitDirect

; 106  : 		hErrorLogFile = CreateFile("ErrorLog.txt", GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

  00074	6a 00		 push	 0
  00076	68 80 00 00 00	 push	 128			; 00000080H
  0007b	6a 02		 push	 2
  0007d	6a 00		 push	 0
  0007f	6a 01		 push	 1
  00081	68 00 00 00 40	 push	 1073741824		; 40000000H
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FNIPCMMK@ErrorLog?4txt@
  0008b	ff d7		 call	 edi

; 107  : 		sprintf_s(szErrMsg, "DirectDrawCreate error(1):error result (%x)", hResult);

  0008d	ff b5 cc fe ff
	ff		 push	 DWORD PTR _hResult$1$[ebp]
  00093	8b f0		 mov	 esi, eax
  00095	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szErrMsg$[ebp]
  0009b	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@HMMIJENE@DirectDrawCreate?5error?$CI1?$CJ?3error@
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ; sprintf_s<256>
  000a6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 108  : 		WriteFile(hErrorLogFile, szErrMsg, sizeof(szErrMsg), &dwWriteByte, NULL);

  000a9	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _dwWriteByte$[ebp]
  000af	6a 00		 push	 0
  000b1	50		 push	 eax
  000b2	68 00 01 00 00	 push	 256			; 00000100H
  000b7	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szErrMsg$[ebp]
  000bd	50		 push	 eax
  000be	56		 push	 esi
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20

; 109  : 		CloseHandle(hErrorLogFile);

  000c5	56		 push	 esi
  000c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 110  : 		if ((hResult = DirectDrawCreate((GUID *)DDCREATE_EMULATIONONLY, &lpDraw->lpDD, NULL)) != DD_OK) {

  000cc	6a 00		 push	 0
  000ce	ff 35 00 00 00
	00		 push	 DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  000d4	6a 02		 push	 2
  000d6	e8 00 00 00 00	 call	 _DirectDrawCreate@12
  000db	89 85 cc fe ff
	ff		 mov	 DWORD PTR _hResult$2$[ebp], eax
  000e1	85 c0		 test	 eax, eax
  000e3	0f 84 87 00 00
	00		 je	 $LN3@InitDirect

; 111  : 			MessageBoxNew(hWnd, "DirectDrawCreate Error", "확인", MB_OK | MB_ICONSTOP);

  000e9	6a 10		 push	 16			; 00000010H
  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_04IJNKKJEO@?H?$KO?$MA?N@
  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@MKFLKCNM@DirectDrawCreate?5Error@
  000f5	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  000fb	e8 00 00 00 00	 call	 ?MessageBoxNew@@YAHPAUHWND__@@PBD1I@Z ; MessageBoxNew
  00100	83 c4 10	 add	 esp, 16			; 00000010H

; 112  : 			hErrorLogFile = CreateFile("ErrorLog.txt", GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

  00103	6a 00		 push	 0
  00105	68 80 00 00 00	 push	 128			; 00000080H
  0010a	6a 02		 push	 2
  0010c	6a 00		 push	 0
  0010e	6a 01		 push	 1
  00110	68 00 00 00 40	 push	 1073741824		; 40000000H
  00115	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FNIPCMMK@ErrorLog?4txt@
  0011a	ff d7		 call	 edi

; 113  : 			sprintf_s(szErrMsg, "DirectDrawCreate error(2):error result (%x)", hResult);

  0011c	ff b5 cc fe ff
	ff		 push	 DWORD PTR _hResult$2$[ebp]
  00122	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@HNGBGDH@DirectDrawCreate?5error?$CI2?$CJ?3error@
$LN28@InitDirect:

; 340  : 	return TRUE;
; 341  : }

  00127	8b f0		 mov	 esi, eax
  00129	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szErrMsg$[ebp]
  0012f	50		 push	 eax
  00130	e8 00 00 00 00	 call	 ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ; sprintf_s<256>
  00135	83 c4 0c	 add	 esp, 12			; 0000000cH
  00138	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _dwWriteByte$[ebp]
  0013e	6a 00		 push	 0
  00140	50		 push	 eax
  00141	68 00 01 00 00	 push	 256			; 00000100H
  00146	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szErrMsg$[ebp]
  0014c	50		 push	 eax
  0014d	56		 push	 esi
  0014e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  00154	56		 push	 esi
  00155	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN26@InitDirect:
  0015b	33 c0		 xor	 eax, eax
  0015d	5f		 pop	 edi
  0015e	5e		 pop	 esi
  0015f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00162	33 cd		 xor	 ecx, ebp
  00164	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00169	8b e5		 mov	 esp, ebp
  0016b	5d		 pop	 ebp
  0016c	8b e3		 mov	 esp, ebx
  0016e	5b		 pop	 ebx
  0016f	c3		 ret	 0
$LN3@InitDirect:

; 114  : 			WriteFile(hErrorLogFile, szErrMsg, sizeof(szErrMsg), &dwWriteByte, NULL);
; 115  : 			CloseHandle(hErrorLogFile);
; 116  : 			return FALSE;
; 117  : 		}
; 118  : 	}
; 119  : 	if ((hResult = lpDraw->lpDD->QueryInterface(IID_IDirectDraw2, (LPVOID *)&lpDraw->lpDD2)) != DD_OK) {

  00170	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00175	8b 08		 mov	 ecx, DWORD PTR [eax]
  00177	83 c0 04	 add	 eax, 4
  0017a	50		 push	 eax
  0017b	68 00 00 00 00	 push	 OFFSET _IID_IDirectDraw2
  00180	51		 push	 ecx
  00181	8b 11		 mov	 edx, DWORD PTR [ecx]
  00183	ff 12		 call	 DWORD PTR [edx]
  00185	89 85 cc fe ff
	ff		 mov	 DWORD PTR _hResult$3$[ebp], eax
  0018b	85 c0		 test	 eax, eax
  0018d	74 43		 je	 SHORT $LN4@InitDirect

; 120  : 		MessageBoxNew(hWnd, "QueryInterface Error", "확인", MB_OK | MB_ICONSTOP);

  0018f	6a 10		 push	 16			; 00000010H
  00191	68 00 00 00 00	 push	 OFFSET ??_C@_04IJNKKJEO@?H?$KO?$MA?N@
  00196	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@GFNNOOOA@QueryInterface?5Error@
  0019b	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  001a1	e8 00 00 00 00	 call	 ?MessageBoxNew@@YAHPAUHWND__@@PBD1I@Z ; MessageBoxNew
  001a6	83 c4 10	 add	 esp, 16			; 00000010H

; 121  : 		hErrorLogFile = CreateFile("ErrorLog.txt", GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

  001a9	6a 00		 push	 0
  001ab	68 80 00 00 00	 push	 128			; 00000080H
  001b0	6a 02		 push	 2
  001b2	6a 00		 push	 0
  001b4	6a 01		 push	 1
  001b6	68 00 00 00 40	 push	 1073741824		; 40000000H
  001bb	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FNIPCMMK@ErrorLog?4txt@
  001c0	ff d7		 call	 edi

; 122  : 		sprintf_s(szErrMsg, "QueryInterface error:error result (%x)", hResult);

  001c2	ff b5 cc fe ff
	ff		 push	 DWORD PTR _hResult$3$[ebp]
  001c8	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@HAIHOBCK@QueryInterface?5error?3error?5resu@

; 123  : 		WriteFile(hErrorLogFile, szErrMsg, sizeof(szErrMsg), &dwWriteByte, NULL);
; 124  : 		CloseHandle(hErrorLogFile);
; 125  : 		return FALSE;

  001cd	e9 55 ff ff ff	 jmp	 $LN28@InitDirect
$LN4@InitDirect:

; 126  : 	}
; 127  : #ifdef _BACK_WINDOW
; 128  : #undef _BACK_VERSION
; 129  : #endif
; 130  : #ifndef _BACK_VERSION
; 131  : 	if (WindowMode) {

  001d2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?WindowMode@@3HA, 0 ; WindowMode
  001d9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  001de	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001e1	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e3	0f 84 ef 01 00
	00		 je	 $LN5@InitDirect

; 132  : #ifdef SWITCH_MODE
; 133  : 		if (g_OriginalMode.dmSize == 0) {
; 134  : 			g_OriginalMode.dmSize = sizeof(DEVMODE);
; 135  : 			EnumDisplaySettings(NULL, ENUM_CURRENT_SETTINGS, &g_OriginalMode);
; 136  : 		}
; 137  : 		if (displayBpp != (int)g_OriginalMode.dmBitsPerPel || lpDraw->xSize != (int)g_OriginalMode.dmPelsWidth || lpDraw->ySize != (int)g_OriginalMode.dmPelsHeight) {
; 138  : 			DEVMODE	DevMode;
; 139  : 			int done = 0, iMode = 0;
; 140  : 			DevMode.dmSize = sizeof(DEVMODE);
; 141  : 			while (EnumDisplaySettings(NULL, iMode, &DevMode)) {
; 142  : 				if ((int)DevMode.dmBitsPerPel == displayBpp && DevMode.dmPelsWidth == g_OriginalMode.dmPelsWidth && DevMode.dmPelsHeight == g_OriginalMode.dmPelsHeight) {
; 143  : 					ChangeDisplaySettingsEx(NULL, &DevMode, NULL, CDS_UPDATEREGISTRY, NULL);
; 144  : 					done = 1;
; 145  : 					break;
; 146  : 				}
; 147  : 				iMode++;
; 148  : 				DevMode.dmSize = sizeof(DEVMODE);
; 149  : 			}
; 150  : 			if (done == 0) {
; 151  : 				iMode = 0;
; 152  : 				DevMode.dmSize = sizeof(DEVMODE);
; 153  : 				while (EnumDisplaySettings(NULL, iMode, &DevMode)) {
; 154  : 					if ((int)DevMode.dmBitsPerPel == displayBpp && (int)DevMode.dmPelsWidth >= lpDraw->xSize && (int)DevMode.dmPelsHeight >= lpDraw->ySize) {
; 155  : 						DevMode.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;
; 156  : 						ChangeDisplaySettingsEx(NULL, &DevMode, NULL, CDS_UPDATEREGISTRY, NULL);
; 157  : 						break;
; 158  : 					}
; 159  : 					iMode++;
; 160  : 					DevMode.dmSize = sizeof(DEVMODE);
; 161  : 				}
; 162  : 				if (done == 0)   return FALSE;
; 163  : 			}
; 164  : 		}
; 165  : #endif
; 166  : 		if (lpDraw->lpDD2->SetCooperativeLevel(hWnd, DDSCL_NORMAL) != DD_OK) {

  001e9	6a 08		 push	 8
  001eb	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  001f1	50		 push	 eax
  001f2	ff 51 50	 call	 DWORD PTR [ecx+80]
  001f5	85 c0		 test	 eax, eax
  001f7	74 1f		 je	 SHORT $LN7@InitDirect
$LN27@InitDirect:

; 340  : 	return TRUE;
; 341  : }

  001f9	6a 10		 push	 16			; 00000010H
  001fb	68 00 00 00 00	 push	 OFFSET ??_C@_04IJNKKJEO@?H?$KO?$MA?N@
  00200	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@PLBEKNJA@SetCooperativeLevel?5Error@
  00205	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  0020b	e8 00 00 00 00	 call	 ?MessageBoxNew@@YAHPAUHWND__@@PBD1I@Z ; MessageBoxNew
  00210	83 c4 10	 add	 esp, 16			; 00000010H
  00213	e9 43 ff ff ff	 jmp	 $LN26@InitDirect
$LN7@InitDirect:

; 167  : 			MessageBoxNew(hWnd, "SetCooperativeLevel Error", "확인", MB_OK | MB_ICONSTOP);
; 168  : 			return FALSE;
; 169  : 		}
; 170  : 
; 171  : 		ZeroMemory(&lpDraw->ddsd, sizeof(lpDraw->ddsd));

  00218	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0021d	6a 6c		 push	 108			; 0000006cH
  0021f	83 c0 14	 add	 eax, 20			; 00000014H
  00222	6a 00		 push	 0
  00224	50		 push	 eax
  00225	e8 00 00 00 00	 call	 _memset

; 172  : 		lpDraw->ddsd.dwSize = sizeof(lpDraw->ddsd);

  0022a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0022f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00232	c7 40 14 6c 00
	00 00		 mov	 DWORD PTR [eax+20], 108	; 0000006cH

; 173  : 		lpDraw->ddsd.dwFlags = DDSD_CAPS;

  00239	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw

; 174  : 		lpDraw->ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
; 175  : 		if ((hResult = lpDraw->lpDD2->CreateSurface(&lpDraw->ddsd, &lpDraw->lpFRONTBUFFER, NULL)) != DD_OK) {

  0023e	6a 00		 push	 0
  00240	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [eax+24], 1
  00247	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0024c	c7 40 7c 00 02
	00 00		 mov	 DWORD PTR [eax+124], 512 ; 00000200H
  00253	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00259	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0025c	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  0025f	50		 push	 eax
  00260	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]
  00263	50		 push	 eax
  00264	8b 32		 mov	 esi, DWORD PTR [edx]
  00266	52		 push	 edx
  00267	ff 56 18	 call	 DWORD PTR [esi+24]
  0026a	89 85 cc fe ff
	ff		 mov	 DWORD PTR _hResult$4$[ebp], eax
  00270	85 c0		 test	 eax, eax
  00272	74 43		 je	 SHORT $LN8@InitDirect

; 176  : 			MessageBoxNew(hWnd, "메인화면처리실패。", "확인", MB_OK | MB_ICONSTOP);

  00274	6a 10		 push	 16			; 00000010H
  00276	68 00 00 00 00	 push	 OFFSET ??_C@_04IJNKKJEO@?H?$KO?$MA?N@
  0027b	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@MODJDGBN@?$LI?$NO?$MA?N?H?$KN?$LI?i?C?$LD?$LI?$KO?$LN?G?F?P?$KB?$KD@
  00280	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  00286	e8 00 00 00 00	 call	 ?MessageBoxNew@@YAHPAUHWND__@@PBD1I@Z ; MessageBoxNew
  0028b	83 c4 10	 add	 esp, 16			; 00000010H

; 177  : 			hErrorLogFile = CreateFile("ErrorLog.txt", GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

  0028e	6a 00		 push	 0
  00290	68 80 00 00 00	 push	 128			; 00000080H
  00295	6a 02		 push	 2
  00297	6a 00		 push	 0
  00299	6a 01		 push	 1
  0029b	68 00 00 00 40	 push	 1073741824		; 40000000H
  002a0	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FNIPCMMK@ErrorLog?4txt@
  002a5	ff d7		 call	 edi

; 178  : 			sprintf_s(szErrMsg, "Create frontbuffer error(1):error result (%x)", hResult);

  002a7	ff b5 cc fe ff
	ff		 push	 DWORD PTR _hResult$4$[ebp]
  002ad	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@JBEGDDIO@Create?5frontbuffer?5error?$CI1?$CJ?3err@

; 179  : 			WriteFile(hErrorLogFile, szErrMsg, sizeof(szErrMsg), &dwWriteByte, NULL);
; 180  : 			CloseHandle(hErrorLogFile);
; 181  : 			return FALSE;

  002b2	e9 70 fe ff ff	 jmp	 $LN28@InitDirect
$LN8@InitDirect:

; 182  : 		}
; 183  : 		if (lpDraw->lpDD2->CreateClipper(0, &lpDraw->lpCLIPPER, NULL) != DD_OK) {

  002b7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  002bc	6a 00		 push	 0
  002be	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002c1	83 c0 10	 add	 eax, 16			; 00000010H
  002c4	50		 push	 eax
  002c5	6a 00		 push	 0
  002c7	51		 push	 ecx
  002c8	8b 11		 mov	 edx, DWORD PTR [ecx]
  002ca	ff 52 10	 call	 DWORD PTR [edx+16]
  002cd	85 c0		 test	 eax, eax
  002cf	74 1f		 je	 SHORT $LN9@InitDirect

; 184  : 			MessageBoxNew(hWnd, "clipper처리실패。", "확인", MB_OK | MB_ICONSTOP);

  002d1	6a 10		 push	 16			; 00000010H
  002d3	68 00 00 00 00	 push	 OFFSET ??_C@_04IJNKKJEO@?H?$KO?$MA?N@
  002d8	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OBNPBHMK@clipper?C?$LD?$LI?$KO?$LN?G?F?P?$KB?$KD@
  002dd	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  002e3	e8 00 00 00 00	 call	 ?MessageBoxNew@@YAHPAUHWND__@@PBD1I@Z ; MessageBoxNew
  002e8	83 c4 10	 add	 esp, 16			; 00000010H

; 185  : 			return FALSE;

  002eb	e9 6b fe ff ff	 jmp	 $LN26@InitDirect
$LN9@InitDirect:

; 186  : 		}
; 187  : 		lpDraw->lpCLIPPER->SetHWnd(0, hWnd);

  002f0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  002f5	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  002fb	6a 00		 push	 0
  002fd	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00300	50		 push	 eax
  00301	8b 08		 mov	 ecx, DWORD PTR [eax]
  00303	ff 51 20	 call	 DWORD PTR [ecx+32]

; 188  : 		lpDraw->lpFRONTBUFFER->SetClipper(lpDraw->lpCLIPPER);

  00306	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0030b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0030e	ff 70 10	 push	 DWORD PTR [eax+16]
  00311	51		 push	 ecx
  00312	8b 11		 mov	 edx, DWORD PTR [ecx]
  00314	ff 52 70	 call	 DWORD PTR [edx+112]

; 189  : 		ZeroMemory(&lpDraw->ddsd, sizeof(lpDraw->ddsd));

  00317	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0031c	6a 6c		 push	 108			; 0000006cH
  0031e	83 c0 14	 add	 eax, 20			; 00000014H
  00321	6a 00		 push	 0
  00323	50		 push	 eax
  00324	e8 00 00 00 00	 call	 _memset

; 190  : 		lpDraw->ddsd.dwSize = sizeof(lpDraw->ddsd);

  00329	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0032e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00331	c7 40 14 6c 00
	00 00		 mov	 DWORD PTR [eax+20], 108	; 0000006cH

; 191  : 		lpDraw->ddsd.dwFlags = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;

  00338	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw

; 192  : 		lpDraw->ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY;
; 193  : 		lpDraw->ddsd.dwWidth = lpDraw->xSize;
; 194  : 		lpDraw->ddsd.dwHeight = lpDraw->ySize;
; 195  : 		if ((hResult = lpDraw->lpDD2->CreateSurface(&lpDraw->ddsd, &lpDraw->lpBACKBUFFER, NULL)) != DD_OK) {

  0033d	6a 00		 push	 0
  0033f	c7 40 18 07 00
	00 00		 mov	 DWORD PTR [eax+24], 7
  00346	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0034b	c7 40 7c 40 08
	00 00		 mov	 DWORD PTR [eax+124], 2112 ; 00000840H
  00352	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00358	8b 81 84 00 00
	00		 mov	 eax, DWORD PTR [ecx+132]
  0035e	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  00361	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00367	8b 81 88 00 00
	00		 mov	 eax, DWORD PTR [ecx+136]
  0036d	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00370	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00376	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00379	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]
  0037c	50		 push	 eax
  0037d	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]
  00380	50		 push	 eax
  00381	8b 32		 mov	 esi, DWORD PTR [edx]
  00383	52		 push	 edx
  00384	ff 56 18	 call	 DWORD PTR [esi+24]
  00387	89 85 cc fe ff
	ff		 mov	 DWORD PTR _hResult$5$[ebp], eax
  0038d	85 c0		 test	 eax, eax
  0038f	0f 84 49 01 00
	00		 je	 $LN6@InitDirect

; 196  : 			MessageBoxNew(hWnd, "레지스트리 처리 실패", "확인", MB_OK | MB_ICONSTOP);

  00395	6a 10		 push	 16			; 00000010H
  00397	68 00 00 00 00	 push	 OFFSET ??_C@_04IJNKKJEO@?H?$KO?$MA?N@
  0039c	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@NIDKJJHH@?$LH?$LJ?A?v?$LN?$LK?F?$KO?$LI?$KO?5?C?$LD?$LI?$KO?5?$LN?G?F?P@
  003a1	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  003a7	e8 00 00 00 00	 call	 ?MessageBoxNew@@YAHPAUHWND__@@PBD1I@Z ; MessageBoxNew
  003ac	83 c4 10	 add	 esp, 16			; 00000010H

; 197  : 			hErrorLogFile = CreateFile("ErrorLog.txt", GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

  003af	6a 00		 push	 0
  003b1	68 80 00 00 00	 push	 128			; 00000080H
  003b6	6a 02		 push	 2
  003b8	6a 00		 push	 0
  003ba	6a 01		 push	 1
  003bc	68 00 00 00 40	 push	 1073741824		; 40000000H
  003c1	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FNIPCMMK@ErrorLog?4txt@
  003c6	ff d7		 call	 edi

; 198  : 			sprintf_s(szErrMsg, "Create backbuffer error:error result (%x)", hResult);

  003c8	ff b5 cc fe ff
	ff		 push	 DWORD PTR _hResult$5$[ebp]
  003ce	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@MMFDMNJJ@Create?5backbuffer?5error?3error?5r@

; 199  : 			WriteFile(hErrorLogFile, szErrMsg, sizeof(szErrMsg), &dwWriteByte, NULL);
; 200  : 			CloseHandle(hErrorLogFile);
; 201  : 			return FALSE;

  003d3	e9 4f fd ff ff	 jmp	 $LN28@InitDirect
$LN5@InitDirect:

; 202  : 	}
; 203  : #ifdef _READ16BITBMP
; 204  : 		if (g_bUseAlpha) {
; 205  : 			lpDraw->ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY;
; 206  : 			if ((hResult = lpDraw->lpDD2->CreateSurface(&lpDraw->ddsd, &lpDraw->lpBACKBUFFERSYS, NULL)) != DD_OK) {
; 207  : 				MessageBoxNew(hWnd, "暂存区处理失败(sys)", "확인", MB_OK | MB_ICONSTOP);
; 208  : 				hErrorLogFile = CreateFile("ErrorLog.txt", GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
; 209  : 				sprintf_s(szErrMsg, "Create backbuffer error:error result (%x)", hResult);
; 210  : 				WriteFile(hErrorLogFile, szErrMsg, sizeof(szErrMsg), &dwWriteByte, NULL);
; 211  : 				CloseHandle(hErrorLogFile);
; 212  : 				return FALSE;
; 213  : 			}
; 214  : 		}
; 215  : #endif
; 216  : }
; 217  : 	else
; 218  : #endif
; 219  : #ifdef _BACK_WINDOW
; 220  : #define _BACK_VERSION
; 221  : #endif
; 222  : 	{
; 223  : 		if (lpDraw->lpDD2->SetCooperativeLevel(hWnd, DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN | DDSCL_ALLOWMODEX) != DD_OK) {

  003d8	6a 51		 push	 81			; 00000051H
  003da	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  003e0	50		 push	 eax
  003e1	ff 51 50	 call	 DWORD PTR [ecx+80]
  003e4	85 c0		 test	 eax, eax
  003e6	0f 85 0d fe ff
	ff		 jne	 $LN27@InitDirect

; 224  : 			MessageBoxNew(hWnd, "SetCooperativeLevel Error", "확인", MB_OK | MB_ICONSTOP);
; 225  : 			return FALSE;
; 226  : 		}
; 227  : 		lpDraw->lpDD2->SetDisplayMode(lpDraw->xSize, lpDraw->ySize, displayBpp, 0, 0);

  003ec	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  003f1	6a 00		 push	 0
  003f3	6a 00		 push	 0
  003f5	ff 35 00 00 00
	00		 push	 DWORD PTR ?displayBpp@@3HA ; displayBpp
  003fb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  003fe	ff b0 88 00 00
	00		 push	 DWORD PTR [eax+136]
  00404	ff b0 84 00 00
	00		 push	 DWORD PTR [eax+132]
  0040a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0040c	51		 push	 ecx
  0040d	ff 52 54	 call	 DWORD PTR [edx+84]

; 228  : 		ZeroMemory(&lpDraw->ddsd, sizeof(lpDraw->ddsd));

  00410	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00415	6a 6c		 push	 108			; 0000006cH
  00417	83 c0 14	 add	 eax, 20			; 00000014H
  0041a	6a 00		 push	 0
  0041c	50		 push	 eax
  0041d	e8 00 00 00 00	 call	 _memset

; 229  : 		lpDraw->ddsd.dwSize = sizeof(lpDraw->ddsd);

  00422	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00427	83 c4 0c	 add	 esp, 12			; 0000000cH
  0042a	c7 40 14 6c 00
	00 00		 mov	 DWORD PTR [eax+20], 108	; 0000006cH

; 230  : 		lpDraw->ddsd.dwFlags = DDSD_CAPS | DDSD_BACKBUFFERCOUNT;

  00431	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw

; 231  : 		lpDraw->ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | DDSCAPS_FLIP | DDSCAPS_COMPLEX;
; 232  : 		lpDraw->ddsd.dwBackBufferCount = 1;
; 233  : 		if ((hResult = lpDraw->lpDD2->CreateSurface(&lpDraw->ddsd, &lpDraw->lpFRONTBUFFER, NULL)) != DD_OK) {

  00436	6a 00		 push	 0
  00438	c7 40 18 21 00
	00 00		 mov	 DWORD PTR [eax+24], 33	; 00000021H
  0043f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00444	c7 40 7c 18 02
	00 00		 mov	 DWORD PTR [eax+124], 536 ; 00000218H
  0044b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00450	c7 40 28 01 00
	00 00		 mov	 DWORD PTR [eax+40], 1
  00457	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0045d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00460	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00463	50		 push	 eax
  00464	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]
  00467	50		 push	 eax
  00468	8b 32		 mov	 esi, DWORD PTR [edx]
  0046a	52		 push	 edx
  0046b	ff 56 18	 call	 DWORD PTR [esi+24]
  0046e	89 85 cc fe ff
	ff		 mov	 DWORD PTR _hResult$6$[ebp], eax
  00474	85 c0		 test	 eax, eax
  00476	74 43		 je	 SHORT $LN12@InitDirect

; 234  : 			MessageBoxNew(hWnd, "메인 화면 처리 실패 2。", "확인", MB_OK | MB_ICONSTOP);

  00478	6a 10		 push	 16			; 00000010H
  0047a	68 00 00 00 00	 push	 OFFSET ??_C@_04IJNKKJEO@?H?$KO?$MA?N@
  0047f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CJPGPEBL@?$LI?$NO?$MA?N?5?H?$KN?$LI?i?5?C?$LD?$LI?$KO?5?$LN?G?F?P?52?$KB?$KD@
  00484	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  0048a	e8 00 00 00 00	 call	 ?MessageBoxNew@@YAHPAUHWND__@@PBD1I@Z ; MessageBoxNew
  0048f	83 c4 10	 add	 esp, 16			; 00000010H

; 235  : 			hErrorLogFile = CreateFile("ErrorLog.txt", GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

  00492	6a 00		 push	 0
  00494	68 80 00 00 00	 push	 128			; 00000080H
  00499	6a 02		 push	 2
  0049b	6a 00		 push	 0
  0049d	6a 01		 push	 1
  0049f	68 00 00 00 40	 push	 1073741824		; 40000000H
  004a4	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FNIPCMMK@ErrorLog?4txt@
  004a9	ff d7		 call	 edi

; 236  : 			sprintf_s(szErrMsg, "Create frontbuffer error(2):error result (%x)", hResult);

  004ab	ff b5 cc fe ff
	ff		 push	 DWORD PTR _hResult$6$[ebp]
  004b1	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@OKFILBGN@Create?5frontbuffer?5error?$CI2?$CJ?3err@

; 237  : 			WriteFile(hErrorLogFile, szErrMsg, sizeof(szErrMsg), &dwWriteByte, NULL);
; 238  : 			CloseHandle(hErrorLogFile);
; 239  : 			return FALSE;

  004b6	e9 6c fc ff ff	 jmp	 $LN28@InitDirect
$LN12@InitDirect:

; 240  : 		}
; 241  : 		ddscaps.dwCaps = DDSCAPS_BACKBUFFER;
; 242  : 		lpDraw->lpFRONTBUFFER->GetAttachedSurface(&ddscaps, &lpDraw->lpBACKBUFFER);

  004bb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  004c0	c7 85 c4 fe ff
	ff 04 00 00 00	 mov	 DWORD PTR _ddscaps$[ebp], 4
  004ca	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  004cd	83 c0 0c	 add	 eax, 12			; 0000000cH
  004d0	50		 push	 eax
  004d1	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _ddscaps$[ebp]
  004d7	50		 push	 eax
  004d8	8b 11		 mov	 edx, DWORD PTR [ecx]
  004da	51		 push	 ecx
  004db	ff 52 30	 call	 DWORD PTR [edx+48]
$LN6@InitDirect:

; 243  : #ifdef _READ16BITBMP
; 244  : 		if (g_bUseAlpha) {
; 245  : 			ZeroMemory(&lpDraw->ddsd, sizeof(lpDraw->ddsd));
; 246  : 			lpDraw->ddsd.dwSize = sizeof(lpDraw->ddsd);
; 247  : 			lpDraw->ddsd.dwFlags = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;
; 248  : 			lpDraw->ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
; 249  : 			lpDraw->ddsd.dwWidth = lpDraw->xSize;
; 250  : 			lpDraw->ddsd.dwHeight = lpDraw->ySize;
; 251  : 			lpDraw->ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY;
; 252  : 			if ((hResult = lpDraw->lpDD2->CreateSurface(&lpDraw->ddsd, &lpDraw->lpBACKBUFFERSYS, NULL)) != DD_OK) {
; 253  : 				MessageBoxNew(hWnd, "暂存区处理失败二(sys)", "확인", MB_OK | MB_ICONSTOP);
; 254  : 				hErrorLogFile = CreateFile("ErrorLog.txt", GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
; 255  : 				sprintf_s(szErrMsg, "Create backbuffer error:error result (%x)", hResult);
; 256  : 				WriteFile(hErrorLogFile, szErrMsg, sizeof(szErrMsg), &dwWriteByte, NULL);
; 257  : 				CloseHandle(hErrorLogFile);
; 258  : 				return FALSE;
; 259  : 			}
; 260  : 		}
; 261  : #endif
; 262  : 	}
; 263  : 	// WON REM 
; 264  : #ifdef _HI_COLOR_32
; 265  : 	if (displayBpp == 32) {

  004de	a1 00 00 00 00	 mov	 eax, DWORD PTR ?displayBpp@@3HA ; displayBpp
  004e3	83 f8 20	 cmp	 eax, 32			; 00000020H
  004e6	0f 85 a3 00 00
	00		 jne	 $LN13@InitDirect
$LN24@InitDirect:

; 290  : 			// ??????????NULL????
; 291  : 			if (lpDraw->lpBACKBUFFER == NULL)
; 292  : 				return FALSE;
; 293  : 
; 294  : 			DDPIXELFORMAT ddPixelFormat;	// ?????
; 295  : 											// ?????
; 296  : 			ZeroMemory(&ddPixelFormat, sizeof(DDPIXELFORMAT));
; 297  : 			ddPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
; 298  : 
; 299  : 			if (lpDraw->lpBACKBUFFER->GetPixelFormat(&ddPixelFormat) != DD_OK)
; 300  : 				return FALSE;
; 301  : 
; 302  : 			rBitRShift = 8 - getBitCount(ddPixelFormat.dwRBitMask);	// ?????????
; 303  : 			gBitRShift = 8 - getBitCount(ddPixelFormat.dwGBitMask);	// ?????????
; 304  : 			bBitRShift = 8 - getBitCount(ddPixelFormat.dwBBitMask);	// ?????????
; 305  : 
; 306  : 			rBitLShift = getBitCount(ddPixelFormat.dwBBitMask) + getBitCount(ddPixelFormat.dwGBitMask);	// ?????????
; 307  : 			gBitLShift = getBitCount(ddPixelFormat.dwBBitMask);							// ?????????
; 308  : 			bBitLShift = 0;													// ?????????
; 309  : 	}
; 310  : 
; 311  : #endif
; 312  : 	// ??????????
; 313  : 	if ((lpBattleSurface = CreateSurface(DEF_APPSIZEX, DEF_APPSIZEY, DEF_COLORKEY, DDSCAPS_VIDEOMEMORY)) == NULL) {

  004ec	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  004f1	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  004f5	0f 84 60 fc ff
	ff		 je	 $LN26@InitDirect
  004fb	0f 57 c0	 xorps	 xmm0, xmm0
  004fe	8d 95 d0 fe ff
	ff		 lea	 edx, DWORD PTR _ddPixelFormat$1[ebp]
  00504	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR _ddPixelFormat$1[ebp], xmm0
  0050b	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR _ddPixelFormat$1[ebp+16], xmm0
  00512	c7 85 d0 fe ff
	ff 20 00 00 00	 mov	 DWORD PTR _ddPixelFormat$1[ebp], 32 ; 00000020H
  0051c	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0051f	52		 push	 edx
  00520	50		 push	 eax
  00521	8b 08		 mov	 ecx, DWORD PTR [eax]
  00523	ff 51 54	 call	 DWORD PTR [ecx+84]
  00526	85 c0		 test	 eax, eax
  00528	0f 85 2d fc ff
	ff		 jne	 $LN26@InitDirect
  0052e	ff b5 e0 fe ff
	ff		 push	 DWORD PTR _ddPixelFormat$1[ebp+16]
  00534	e8 00 00 00 00	 call	 ?getBitCount@@YAHH@Z	; getBitCount
  00539	ff b5 e4 fe ff
	ff		 push	 DWORD PTR _ddPixelFormat$1[ebp+20]
  0053f	bf 08 00 00 00	 mov	 edi, 8
  00544	8b cf		 mov	 ecx, edi
  00546	2b c8		 sub	 ecx, eax
  00548	89 0d 00 00 00
	00		 mov	 DWORD PTR ?rBitRShift@@3HA, ecx ; rBitRShift
  0054e	e8 00 00 00 00	 call	 ?getBitCount@@YAHH@Z	; getBitCount
  00553	ff b5 e8 fe ff
	ff		 push	 DWORD PTR _ddPixelFormat$1[ebp+24]
  00559	8b f0		 mov	 esi, eax
  0055b	8b cf		 mov	 ecx, edi
  0055d	2b ce		 sub	 ecx, esi
  0055f	89 0d 00 00 00
	00		 mov	 DWORD PTR ?gBitRShift@@3HA, ecx ; gBitRShift
  00565	e8 00 00 00 00	 call	 ?getBitCount@@YAHH@Z	; getBitCount
  0056a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0056d	a3 00 00 00 00	 mov	 DWORD PTR ?gBitLShift@@3HA, eax ; gBitLShift
  00572	2b f8		 sub	 edi, eax
  00574	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bBitLShift@@3HA, 0 ; bBitLShift
  0057e	89 3d 00 00 00
	00		 mov	 DWORD PTR ?bBitRShift@@3HA, edi ; bBitRShift
  00584	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  00587	89 0d 00 00 00
	00		 mov	 DWORD PTR ?rBitLShift@@3HA, ecx ; rBitLShift
  0058d	eb 09		 jmp	 SHORT $LN17@InitDirect
$LN13@InitDirect:

; 266  : 		if (lpDraw->lpBACKBUFFER == NULL)
; 267  : 			return FALSE;
; 268  : 
; 269  : 		DDPIXELFORMAT ddPixelFormat;
; 270  : 		ZeroMemory(&ddPixelFormat, sizeof(DDPIXELFORMAT));
; 271  : 		ddPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
; 272  : 
; 273  : 		if (lpDraw->lpBACKBUFFER->GetPixelFormat(&ddPixelFormat) != DD_OK)
; 274  : 			return FALSE;
; 275  : 
; 276  : 		rBitRShift = 8 - getBitCount(ddPixelFormat.dwRBitMask);	// ?????????
; 277  : 		gBitRShift = 8 - getBitCount(ddPixelFormat.dwGBitMask);	// ?????????
; 278  : 		bBitRShift = 8 - getBitCount(ddPixelFormat.dwBBitMask);	// ?????????
; 279  : 
; 280  : 		rBitLShift = getBitCount(ddPixelFormat.dwBBitMask) + getBitCount(ddPixelFormat.dwGBitMask);	// ?????????
; 281  : 		gBitLShift = getBitCount(ddPixelFormat.dwBBitMask);							// ?????????
; 282  : 		bBitLShift = 0;													// ?????????
; 283  : 	}
; 284  : 	else
; 285  : 
; 286  : #endif
; 287  : #ifdef _HI_COLOR_16
; 288  : 		// ??????????????????
; 289  : 		if (displayBpp == 16) {

  0058f	83 f8 10	 cmp	 eax, 16			; 00000010H
  00592	0f 84 54 ff ff
	ff		 je	 $LN24@InitDirect
$LN17@InitDirect:

; 290  : 			// ??????????NULL????
; 291  : 			if (lpDraw->lpBACKBUFFER == NULL)
; 292  : 				return FALSE;
; 293  : 
; 294  : 			DDPIXELFORMAT ddPixelFormat;	// ?????
; 295  : 											// ?????
; 296  : 			ZeroMemory(&ddPixelFormat, sizeof(DDPIXELFORMAT));
; 297  : 			ddPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
; 298  : 
; 299  : 			if (lpDraw->lpBACKBUFFER->GetPixelFormat(&ddPixelFormat) != DD_OK)
; 300  : 				return FALSE;
; 301  : 
; 302  : 			rBitRShift = 8 - getBitCount(ddPixelFormat.dwRBitMask);	// ?????????
; 303  : 			gBitRShift = 8 - getBitCount(ddPixelFormat.dwGBitMask);	// ?????????
; 304  : 			bBitRShift = 8 - getBitCount(ddPixelFormat.dwBBitMask);	// ?????????
; 305  : 
; 306  : 			rBitLShift = getBitCount(ddPixelFormat.dwBBitMask) + getBitCount(ddPixelFormat.dwGBitMask);	// ?????????
; 307  : 			gBitLShift = getBitCount(ddPixelFormat.dwBBitMask);							// ?????????
; 308  : 			bBitLShift = 0;													// ?????????
; 309  : 	}
; 310  : 
; 311  : #endif
; 312  : 	// ??????????
; 313  : 	if ((lpBattleSurface = CreateSurface(DEF_APPSIZEX, DEF_APPSIZEY, DEF_COLORKEY, DDSCAPS_VIDEOMEMORY)) == NULL) {

  00598	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?DEF_APPSIZEY@@3HA
  0059f	68 00 40 00 00	 push	 16384			; 00004000H
  005a4	6a 00		 push	 0
  005a6	50		 push	 eax
  005a7	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?DEF_APPSIZEX@@3HA
  005ae	50		 push	 eax
  005af	e8 00 00 00 00	 call	 ?CreateSurface@@YAPAUIDirectDrawSurface@@FFKI@Z ; CreateSurface
  005b4	83 c4 10	 add	 esp, 16			; 00000010H
  005b7	a3 00 00 00 00	 mov	 DWORD PTR ?lpBattleSurface@@3PAUIDirectDrawSurface@@A, eax ; lpBattleSurface
  005bc	85 c0		 test	 eax, eax
  005be	75 46		 jne	 SHORT $LN21@InitDirect

; 314  : #ifdef _STONDEBUG_
; 315  : 		MessageBoxNew(hWnd, "建立VideoRam BattleSurface失败！", "확인", MB_OK | MB_ICONSTOP);
; 316  : #endif
; 317  : 		if ((lpBattleSurface = CreateSurface(DEF_APPSIZEX, DEF_APPSIZEY, DEF_COLORKEY, DDSCAPS_SYSTEMMEMORY)) == NULL) {

  005c0	68 00 08 00 00	 push	 2048			; 00000800H
  005c5	50		 push	 eax
  005c6	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?DEF_APPSIZEY@@3HA
  005cd	50		 push	 eax
  005ce	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?DEF_APPSIZEX@@3HA
  005d5	50		 push	 eax
  005d6	e8 00 00 00 00	 call	 ?CreateSurface@@YAPAUIDirectDrawSurface@@FFKI@Z ; CreateSurface
  005db	83 c4 10	 add	 esp, 16			; 00000010H
  005de	a3 00 00 00 00	 mov	 DWORD PTR ?lpBattleSurface@@3PAUIDirectDrawSurface@@A, eax ; lpBattleSurface
  005e3	85 c0		 test	 eax, eax
  005e5	75 1f		 jne	 SHORT $LN21@InitDirect

; 318  : 			MessageBoxNew(hWnd, "BattleSurface 구성 실패！", "확인", MB_OK | MB_ICONSTOP);

  005e7	6a 10		 push	 16			; 00000010H
  005e9	68 00 00 00 00	 push	 OFFSET ??_C@_04IJNKKJEO@?H?$KO?$MA?N@
  005ee	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@COBJPLEN@BattleSurface?5?$LB?$LI?$LM?$LK?5?$LN?G?F?P?$KD?$KB@
  005f3	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  005f9	e8 00 00 00 00	 call	 ?MessageBoxNew@@YAHPAUHWND__@@PBD1I@Z ; MessageBoxNew
  005fe	83 c4 10	 add	 esp, 16			; 00000010H

; 319  : 			return FALSE;

  00601	e9 55 fb ff ff	 jmp	 $LN26@InitDirect
$LN21@InitDirect:

; 320  : 		}
; 321  : 	}
; 322  : #ifdef _READ16BITBMP
; 323  : 	if (g_bUseAlpha) {
; 324  : 		if ((lpBattleSurfaceSys = CreateSurface(DEF_APPSIZEX, DEF_APPSIZEY, DEF_COLORKEY, DDSCAPS_SYSTEMMEMORY)) == NULL) {
; 325  : 			MessageBoxNew(hWnd, "建立BattleSurface(sys)失败！", "확인", MB_OK | MB_ICONSTOP);
; 326  : 			return FALSE;
; 327  : 		}
; 328  : 	}
; 329  : #endif
; 330  : #ifdef __SKYISLAND
; 331  : 	ClearSurface(lpBattleSurface);

  00606	50		 push	 eax
  00607	e8 00 00 00 00	 call	 ?ClearSurface@@YAXPAUIDirectDrawSurface@@@Z ; ClearSurface
  0060c	83 c4 04	 add	 esp, 4

; 332  : #ifdef _READ16BITBMP
; 333  : 	if (g_bUseAlpha) ClearSurface(lpBattleSurfaceSys);
; 334  : #endif
; 335  : 	extern void SkyIslandLoadBmp();
; 336  : 	SkyIslandLoadBmp();

  0060f	e8 00 00 00 00	 call	 ?SkyIslandLoadBmp@@YAXXZ ; SkyIslandLoadBmp

; 337  : #endif
; 338  : 	DDinitFlag = TRUE;

  00614	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?DDinitFlag@@3HA, 1 ; DDinitFlag

; 339  : 	SetAnimTbl();

  0061e	e8 00 00 00 00	 call	 ?SetAnimTbl@@YAXXZ	; SetAnimTbl

; 340  : 	return TRUE;
; 341  : }

  00623	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00626	b8 01 00 00 00	 mov	 eax, 1
  0062b	5f		 pop	 edi
  0062c	33 cd		 xor	 ecx, ebp
  0062e	5e		 pop	 esi
  0062f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00634	8b e5		 mov	 esp, ebp
  00636	5d		 pop	 ebp
  00637	8b e3		 mov	 esp, ebx
  00639	5b		 pop	 ebx
  0063a	c3		 ret	 0
?InitDirectDraw@@YAHXZ ENDP				; InitDirectDraw
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);
; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1777 : 
; 1778 :         __crt_va_end(_ArgList);
; 1779 :         return _Result;
; 1780 :     }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
