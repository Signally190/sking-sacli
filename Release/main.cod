; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30133.0 

	TITLE	\\VBOXSVR\_stoneage\repos\ssm-sacli\Release\main.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?StoneageNg@@3PAUHINSTANCE__@@A			; StoneageNg
PUBLIC	?PcLanded@@3ULanded@@A				; PcLanded
PUBLIC	?„¿‹˙ÒÏ‘Ù@@3HA					; „¿‹˙ÒÏ‘Ù
PUBLIC	?„¿‹˙ÒÏ‘Ù?‘‡÷ı@@3HA				; „¿‹˙ÒÏ‘Ù?‘‡÷ı
PUBLIC	?„¿‹˙ÒÏ‘ÙAIŸº„“@@3HA				; „¿‹˙ÒÏ‘ÙAIŸº„“
PUBLIC	?„¿‹˙ÒÏ‘Ù??@@3HA				; „¿‹˙ÒÏ‘Ù??
PUBLIC	?„¿‹˙ÒÏ‘Ù˘‚?@@3HA				; „¿‹˙ÒÏ‘Ù˘‚?
PUBLIC	?„¿‹˙ÒÏ‘ÙÏ—⁄™€∞˙æ@@3HA				; „¿‹˙ÒÏ‘ÙÏ—⁄™€∞˙æ
PUBLIC	?„¿‹˙ÒÏ?‘Ù??@@3HA				; „¿‹˙ÒÏ?‘Ù??
PUBLIC	?Ìª?‘Ù?„¿‹˙??@@3HA				; Ìª?‘Ù?„¿‹˙??
PUBLIC	?hInst@@3PAUHINSTANCE__@@A			; hInst
PUBLIC	?hCheckMutex@@3PAXA				; hCheckMutex
PUBLIC	?NoDelay@@3HA					; NoDelay
PUBLIC	?g_clientRect@@3UtagRECT@@A			; g_clientRect
PUBLIC	?g_clientPoint@@3UtagPOINT@@A			; g_clientPoint
PUBLIC	?g_moveRect@@3UtagRECT@@A			; g_moveRect
PUBLIC	?g_iMallocCount@@3HA				; g_iMallocCount
PUBLIC	?wndclass@@3UtagWNDCLASSA@@A			; wndclass
PUBLIC	?hProcessSnap@@3PAXA				; hProcessSnap
PUBLIC	?hParentProcess@@3PAXA				; hParentProcess
PUBLIC	?dwPID@@3KA					; dwPID
PUBLIC	?pe32@@3UtagPROCESSENTRY32@@A			; pe32
PUBLIC	?hWnd@@3PAUHWND__@@A				; hWnd
PUBLIC	?WindowMode@@3HA				; WindowMode
PUBLIC	?LowResoCmdFlag@@3HA				; LowResoCmdFlag
PUBLIC	?CmdShow@@3HA					; CmdShow
PUBLIC	?CmdLine@@3PADA					; CmdLine
PUBLIC	?hMutex@@3PAXA					; hMutex
PUBLIC	?realBinName@@3PADA				; realBinName
PUBLIC	?adrnBinName@@3PADA				; adrnBinName
PUBLIC	?sprBinName@@3PADA				; sprBinName
PUBLIC	?sprAdrnBinName@@3PADA				; sprAdrnBinName
PUBLIC	?offlineFlag@@3HA				; offlineFlag
PUBLIC	?DebugKey0@@3PADA				; DebugKey0
PUBLIC	?DebugKey1@@3PADA				; DebugKey1
PUBLIC	?DebugKey2@@3PADA				; DebugKey2
_BSS	SEGMENT
?StoneageNg@@3PAUHINSTANCE__@@A DD 01H DUP (?)		; StoneageNg
?PcLanded@@3ULanded@@A DB 0a0H DUP (?)			; PcLanded
?„¿‹˙ÒÏ‘Ù@@3HA DD 01H DUP (?)				; „¿‹˙ÒÏ‘Ù
?„¿‹˙ÒÏ‘Ù?‘‡÷ı@@3HA DD 01H DUP (?)			; „¿‹˙ÒÏ‘Ù?‘‡÷ı
?„¿‹˙ÒÏ‘ÙAIŸº„“@@3HA DD 01H DUP (?)			; „¿‹˙ÒÏ‘ÙAIŸº„“
?„¿‹˙ÒÏ‘Ù??@@3HA DD 01H DUP (?)				; „¿‹˙ÒÏ‘Ù??
?„¿‹˙ÒÏ‘Ù˘‚?@@3HA DD 01H DUP (?)			; „¿‹˙ÒÏ‘Ù˘‚?
?„¿‹˙ÒÏ‘ÙÏ—⁄™€∞˙æ@@3HA DD 01H DUP (?)			; „¿‹˙ÒÏ‘ÙÏ—⁄™€∞˙æ
?„¿‹˙ÒÏ?‘Ù??@@3HA DD 01H DUP (?)			; „¿‹˙ÒÏ?‘Ù??
?Ìª?‘Ù?„¿‹˙??@@3HA DD 01H DUP (?)			; Ìª?‘Ù?„¿‹˙??
?hInst@@3PAUHINSTANCE__@@A DD 01H DUP (?)		; hInst
?hCheckMutex@@3PAXA DD 01H DUP (?)			; hCheckMutex
?g_clientRect@@3UtagRECT@@A DB 010H DUP (?)		; g_clientRect
	ALIGN	8

?g_clientPoint@@3UtagPOINT@@A DQ 01H DUP (?)		; g_clientPoint
?g_moveRect@@3UtagRECT@@A DB 010H DUP (?)		; g_moveRect
?g_iMallocCount@@3HA DD 01H DUP (?)			; g_iMallocCount
?wndclass@@3UtagWNDCLASSA@@A DB 028H DUP (?)		; wndclass
?hProcessSnap@@3PAXA DD 01H DUP (?)			; hProcessSnap
?hParentProcess@@3PAXA DD 01H DUP (?)			; hParentProcess
?dwPID@@3KA DD	01H DUP (?)				; dwPID
?pe32@@3UtagPROCESSENTRY32@@A DB 0128H DUP (?)		; pe32
?hWnd@@3PAUHWND__@@A DD 01H DUP (?)			; hWnd
?WindowMode@@3HA DD 01H DUP (?)				; WindowMode
?LowResoCmdFlag@@3HA DD 01H DUP (?)			; LowResoCmdFlag
?CmdShow@@3HA DD 01H DUP (?)				; CmdShow
?CmdLine@@3PADA DD 01H DUP (?)				; CmdLine
?hMutex@@3PAXA DD 01H DUP (?)				; hMutex
?realBinName@@3PADA DB 0100H DUP (?)			; realBinName
?adrnBinName@@3PADA DB 0100H DUP (?)			; adrnBinName
?sprBinName@@3PADA DB 0100H DUP (?)			; sprBinName
?sprAdrnBinName@@3PADA DB 0100H DUP (?)			; sprAdrnBinName
?offlineFlag@@3HA DD 01H DUP (?)			; offlineFlag
?DebugKey0@@3PADA DB 0100H DUP (?)			; DebugKey0
?DebugKey1@@3PADA DB 0100H DUP (?)			; DebugKey1
?DebugKey2@@3PADA DB 0100H DUP (?)			; DebugKey2
_BSS	ENDS
_DATA	SEGMENT
?NoDelay@@3HA DD 01H					; NoDelay
_DATA	ENDS
CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_sprintf
PUBLIC	_sprintf_s
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??0bad_cast@std@@QAE@XZ				; std::bad_cast::bad_cast
PUBLIC	??1bad_cast@std@@UAE@XZ				; std::bad_cast::~bad_cast
PUBLIC	??0bad_cast@std@@QAE@ABV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??_Gbad_cast@std@@UAEPAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	?_Throw_bad_cast@std@@YAXXZ			; std::_Throw_bad_cast
PUBLIC	??1thread@std@@QAE@XZ				; std::thread::~thread
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??_Gruntime_error@std@@UAEPAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
PUBLIC	??1_System_error@std@@UAE@XZ			; std::_System_error::~_System_error
PUBLIC	??0_System_error@std@@QAE@ABV01@@Z		; std::_System_error::_System_error
PUBLIC	??_G_System_error@std@@UAEPAXI@Z		; std::_System_error::`scalar deleting destructor'
PUBLIC	??1system_error@std@@UAE@XZ			; std::system_error::~system_error
PUBLIC	??0system_error@std@@QAE@ABV01@@Z		; std::system_error::system_error
PUBLIC	??_Gsystem_error@std@@UAEPAXI@Z			; std::system_error::`scalar deleting destructor'
PUBLIC	?name@_Iostream_error_category2@std@@UBEPBDXZ	; std::_Iostream_error_category2::name
PUBLIC	?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category2::message
PUBLIC	??_G_Iostream_error_category2@std@@UAEPAXI@Z	; std::_Iostream_error_category2::`scalar deleting destructor'
PUBLIC	??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>
PUBLIC	??1_Facet_base@std@@UAE@XZ			; std::_Facet_base::~_Facet_base
PUBLIC	??_G_Facet_base@std@@UAEPAXI@Z			; std::_Facet_base::`scalar deleting destructor'
PUBLIC	??0_Locinfo@std@@QAE@PBD@Z			; std::_Locinfo::_Locinfo
PUBLIC	??1_Locinfo@std@@QAE@XZ				; std::_Locinfo::~_Locinfo
PUBLIC	??1?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::~_Yarn<char>
PUBLIC	??1?$_Yarn@_W@std@@QAE@XZ			; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
PUBLIC	?_Incref@facet@locale@std@@UAEXXZ		; std::locale::facet::_Incref
PUBLIC	?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ; std::locale::facet::_Decref
PUBLIC	??1facet@locale@std@@MAE@XZ			; std::locale::facet::~facet
PUBLIC	??_Gfacet@locale@std@@MAEPAXI@Z			; std::locale::facet::`scalar deleting destructor'
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	??1ctype_base@std@@UAE@XZ			; std::ctype_base::~ctype_base
PUBLIC	??_Gctype_base@std@@UAEPAXI@Z			; std::ctype_base::`scalar deleting destructor'
PUBLIC	??1?$ctype@D@std@@MAE@XZ			; std::ctype<char>::~ctype<char>
PUBLIC	?do_tolower@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_tolower
PUBLIC	?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_tolower
PUBLIC	?do_toupper@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_toupper
PUBLIC	?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_toupper
PUBLIC	?do_widen@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_widen
PUBLIC	?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z	; std::ctype<char>::do_widen
PUBLIC	?do_narrow@?$ctype@D@std@@MBEDDD@Z		; std::ctype<char>::do_narrow
PUBLIC	?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z	; std::ctype<char>::do_narrow
PUBLIC	??_G?$ctype@D@std@@MAEPAXI@Z			; std::ctype<char>::`scalar deleting destructor'
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
PUBLIC	??1failure@ios_base@std@@UAE@XZ			; std::ios_base::failure::~failure
PUBLIC	??0failure@ios_base@std@@QAE@ABV012@@Z		; std::ios_base::failure::failure
PUBLIC	??_Gfailure@ios_base@std@@UAEPAXI@Z		; std::ios_base::failure::`scalar deleting destructor'
PUBLIC	?clear@ios_base@std@@QAEXH_N@Z			; std::ios_base::clear
PUBLIC	_WinMain@16
PUBLIC	?WindMsgProc@@YGJPAUHWND__@@IIJ@Z		; WindMsgProc
PUBLIC	?SystemTask@@YAHXZ				; SystemTask
PUBLIC	?AnalyzeCmdLine@@YAXXZ				; AnalyzeCmdLine
PUBLIC	?ChangeWindowMode@@YAXXZ			; ChangeWindowMode
PUBLIC	?SetResoMode@@YAXH@Z				; SetResoMode
PUBLIC	?MessageBoxNew@@YAHPAUHWND__@@PBD1I@Z		; MessageBoxNew
PUBLIC	?CreateCompatibleDEVMODE@@YAXPAU_devicemodeA@@KKKK@Z ; CreateCompatibleDEVMODE
PUBLIC	?detectSpeedHack@@YAXXZ				; detectSpeedHack
PUBLIC	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
PUBLIC	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	_main
PUBLIC	?RecoverDirectDraw@@YAXXZ			; RecoverDirectDraw
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
PUBLIC	??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
PUBLIC	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
PUBLIC	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
PUBLIC	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
PUBLIC	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
PUBLIC	??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
PUBLIC	??$_Float_put_desired_precision@O@std@@YAH_JH@Z	; std::_Float_put_desired_precision<long double>
PUBLIC	??$_Float_put_desired_precision@N@std@@YAH_JH@Z	; std::_Float_put_desired_precision<double>
PUBLIC	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
PUBLIC	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
PUBLIC	?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::numpunct<char>::_Getcat
PUBLIC	??1?$numpunct@D@std@@MAE@XZ			; std::numpunct<char>::~numpunct<char>
PUBLIC	?do_decimal_point@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_decimal_point
PUBLIC	?do_thousands_sep@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_thousands_sep
PUBLIC	?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_grouping
PUBLIC	?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_falsename
PUBLIC	?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_truename
PUBLIC	??_G?$numpunct@D@std@@MAEPAXI@Z			; std::numpunct<char>::`scalar deleting destructor'
PUBLIC	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
PUBLIC	??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>
PUBLIC	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >
PUBLIC	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z	; std::_Maklocstr<char>
PUBLIC	??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z	; std::_Maklocchr<char>
PUBLIC	??$make_unique@V?$tuple@P6AXXZ@std@@A6AXXZ$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXXZ@std@@U?$default_delete@V?$tuple@P6AXXZ@std@@@2@@0@A6AXXZ@Z ; std::make_unique<std::tuple<void (__cdecl*)(void)>,void (__cdecl&)(void),0>
PUBLIC	??1?$unique_ptr@V?$tuple@P6AXXZ@std@@U?$default_delete@V?$tuple@P6AXXZ@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(void)>,std::default_delete<std::tuple<void (__cdecl*)(void)> > >::~unique_ptr<std::tuple<void (__cdecl*)(void)>,std::default_delete<std::tuple<void (__cdecl*)(void)> > >
PUBLIC	??$_Invoke@V?$tuple@P6AXXZ@std@@$0A@@thread@std@@CGIPAX@Z ; std::thread::_Invoke<std::tuple<void (__cdecl*)(void)>,0>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast@			; `string'
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
PUBLIC	??_7_System_error@std@@6B@			; std::_System_error::`vftable'
PUBLIC	??_C@_02LMMGGCAJ@?3?5@				; `string'
PUBLIC	??_7system_error@std@@6B@			; std::system_error::`vftable'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_R0?AVsystem_error@std@@@8			; std::system_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
PUBLIC	??_R0?AV_System_error@std@@@8			; std::_System_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
PUBLIC	??_7_Iostream_error_category2@std@@6B@		; std::_Iostream_error_category2::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream@			; `string'
PUBLIC	?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB ; `std::_Iostream_error_category2::message'::`5'::_Iostream_error
PUBLIC	??_7_Facet_base@std@@6B@			; std::_Facet_base::`vftable'
PUBLIC	??_C@_0BA@ELKIONDK@bad?5locale?5name@		; `string'
PUBLIC	??_C@_05LAPONLG@false@				; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??_7?$ctype@D@std@@6B@				; std::ctype<char>::`vftable'
PUBLIC	??_7failure@ios_base@std@@6B@			; std::ios_base::failure::`vftable'
PUBLIC	??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@	; `string'
PUBLIC	??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@	; `string'
PUBLIC	??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@	; `string'
PUBLIC	__TI5?AVfailure@ios_base@std@@
PUBLIC	__CTA5?AVfailure@ios_base@std@@
PUBLIC	??_R0?AVfailure@ios_base@std@@@8		; std::ios_base::failure `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0BB@FMGGALCC@Output?5standard?6@		; `string'
PUBLIC	??_C@_0O@NBCMJDEF@Output?5error?6@		; `string'
PUBLIC	??_C@_0P@FDFFMAOB@CheckForUpdate@		; `string'
PUBLIC	??_C@_0BB@NLNMPB@?$KD?S?$KD?t?$KD?o?$KD?n?$KD?e?$KD?A?$KD?g?$KD?e@ ; `string'
PUBLIC	??_C@_04IJNKKJEO@?H?$KO?$MA?N@			; `string'
PUBLIC	??_C@_0CK@MPCLFILL@?t?x?c?$LH?$PL?y?$DP?$DP?c?w?$DP?$KD?$KB?6?$KD?$KM?$DP?$DP?z?$LM?q?l?c?f?d?L?$DP?$PL?d?$PN?g@ ; `string'
PUBLIC	??_C@_0O@DKGBMFPD@data?2real?4bin@		; `string'
PUBLIC	??_C@_0O@HIHIJMIB@data?2adrn?4bin@		; `string'
PUBLIC	??_C@_0N@LCHFCHHG@data?2spr?4bin@		; `string'
PUBLIC	??_C@_0BB@PFEKOFDI@data?2spradrn?4bin@		; `string'
PUBLIC	??_C@_08MPGDICFK@realbin?3@			; `string'
PUBLIC	??_C@_0BB@BDNGKHBG@data?2real_?$CFd?4bin@	; `string'
PUBLIC	??_C@_08INHKNLCI@adrnbin?3@			; `string'
PUBLIC	??_C@_0BB@ELLBFFLH@data?2adrn_?$CFd?4bin@	; `string'
PUBLIC	??_C@_07NALMGOPD@sprbin?3@			; `string'
PUBLIC	??_C@_0BA@ICLKDLOG@data?2spr_?$CFd?4bin@	; `string'
PUBLIC	??_C@_0M@EPOMFNLL@spradrnbin?3@			; `string'
PUBLIC	??_C@_0BE@LHBEADJK@data?2spradrn_?$CFd?4bin@	; `string'
PUBLIC	??_C@_07CGONDAHB@nodelay@			; `string'
PUBLIC	??_C@_0BD@HCDANIG@Direct?5?t?x?c?$LH?$PL?y?c?w?$DP?$KD?$KB@ ; `string'
PUBLIC	??_C@_0BA@LIOBMBPJ@?$NP?d?$DP?5?t?x?c?$LH?$PL?y?c?w?$DP?$KD?$KB@ ; `string'
PUBLIC	??_C@_0BH@OHJJEBKC@SurfaceBusyFlag?5error?$CB@	; `string'
PUBLIC	??_C@_0CA@DDNACEOP@HeapAlloc?5Error?5?$CI?5DIRECT_DRAW?5?$CJ@ ; `string'
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
PUBLIC	??_C@_02BBAHNLBA@?$CFp@				; `string'
PUBLIC	??_C@_02CLHGNPPK@Lu@				; `string'
PUBLIC	??_C@_02HIKPPMOK@Ld@				; `string'
PUBLIC	??_C@_02BDDLJJBK@lu@				; `string'
PUBLIC	??_C@_02EAOCLKAK@ld@				; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	??_7?$numpunct@D@std@@6B@			; std::numpunct<char>::`vftable'
PUBLIC	??_C@_02MDKMJEGG@eE@				; `string'
PUBLIC	??_C@_02OOPEBDOJ@pP@				; `string'
PUBLIC	??_C@_01LFCBOECM@?4@				; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A ; `std::_Immortalize_memcpy_image<std::_Iostream_error_category2>'::`2'::_Static
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error@std@@6B@			; std::_System_error::`RTTI Complete Object Locator'
PUBLIC	??_R3_System_error@std@@8			; std::_System_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error@std@@8			; std::_System_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error@std@@8		; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4system_error@std@@6B@			; std::system_error::`RTTI Complete Object Locator'
PUBLIC	??_R3system_error@std@@8			; std::system_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2system_error@std@@8			; std::system_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@system_error@std@@8		; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category2@std@@6B@		; std::_Iostream_error_category2::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category2@std@@@8	; std::_Iostream_error_category2 `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category2@std@@8		; std::_Iostream_error_category2::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category2@std@@8		; std::_Iostream_error_category2::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category2@std@@8	; std::_Iostream_error_category2::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Facet_base@std@@6B@			; std::_Facet_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Facet_base@std@@@8			; std::_Facet_base `RTTI Type Descriptor'
PUBLIC	??_R3_Facet_base@std@@8				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Facet_base@std@@8				; std::_Facet_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Facet_base@std@@8		; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_R13?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AU_Crt_new_delete@std@@@8			; std::_Crt_new_delete `RTTI Type Descriptor'
PUBLIC	??_R3_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4facet@locale@std@@6B@			; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC	??_R4ctype_base@std@@6B@			; std::ctype_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUctype_base@std@@@8			; std::ctype_base `RTTI Type Descriptor'
PUBLIC	??_R3ctype_base@std@@8				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ctype_base@std@@8				; std::ctype_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ctype_base@std@@8			; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ctype@D@std@@6B@				; std::ctype<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$ctype@D@std@@@8			; std::ctype<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$ctype@D@std@@8				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@D@std@@8				; std::ctype<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@D@std@@8			; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4failure@ios_base@std@@6B@			; std::ios_base::failure::`RTTI Complete Object Locator'
PUBLIC	??_R3failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@failure@ios_base@std@@8		; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$numpunct@D@std@@6B@			; std::numpunct<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$numpunct@D@std@@@8			; std::numpunct<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$numpunct@D@std@@8		; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@40000000
PUBLIC	__real@416312d000000000
PUBLIC	__real@4202a05f20000000
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___stdio_common_vsprintf_s:PROC
EXTRN	_strstr:PROC
EXTRN	_frexp:PROC
EXTRN	_calloc:PROC
EXTRN	_free:PROC
EXTRN	_exit:PROC
EXTRN	_atoi:PROC
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	__Xtime_get_ticks:PROC
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	_terminate:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	_strcspn:PROC
EXTRN	??_Ebad_cast@std@@UAEPAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?_Xruntime_error@std@@YAXPBD@Z:PROC		; std::_Xruntime_error
EXTRN	__beginthreadex:PROC
EXTRN	__Cnd_do_broadcast_at_thread_exit:PROC
EXTRN	?_Throw_Cpp_error@std@@YAXH@Z:PROC		; std::_Throw_Cpp_error
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	??_E_System_error@std@@UAEPAXI@Z:PROC		; std::_System_error::`vector deleting destructor'
EXTRN	??_Esystem_error@std@@UAEPAXI@Z:PROC		; std::system_error::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	??_E_Iostream_error_category2@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category2::`vector deleting destructor'
EXTRN	??_E_Facet_base@std@@UAEPAXI@Z:PROC		; std::_Facet_base::`vector deleting destructor'
EXTRN	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	_localeconv:PROC
EXTRN	__Getctype:PROC
EXTRN	__Getcvt:PROC
EXTRN	__Tolower:PROC
EXTRN	__Toupper:PROC
EXTRN	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z:PROC ; std::_Locinfo::_Locinfo_ctor
EXTRN	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z:PROC	; std::_Locinfo::_Locinfo_dtor
EXTRN	??_Efacet@locale@std@@MAEPAXI@Z:PROC		; std::locale::facet::`vector deleting destructor'
EXTRN	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	??_Ectype_base@std@@UAEPAXI@Z:PROC		; std::ctype_base::`vector deleting destructor'
EXTRN	??_E?$ctype@D@std@@MAEPAXI@Z:PROC		; std::ctype<char>::`vector deleting destructor'
EXTRN	??_Efailure@ios_base@std@@UAEPAXI@Z:PROC	; std::ios_base::failure::`vector deleting destructor'
EXTRN	?TimeGetTime@@YAIXZ:PROC			; TimeGetTime
EXTRN	__imp__GetCommandLineA@0:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__HeapAlloc@12:PROC
EXTRN	__imp__GetProcessHeap@0:PROC
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	__imp__CreateMutexA@12:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__GetCurrentProcessId@0:PROC
EXTRN	__imp__GetModuleHandleA@4:PROC
EXTRN	__imp__GetDeviceCaps@8:PROC
EXTRN	__imp__GetStockObject@4:PROC
EXTRN	__imp__TranslateMessage@4:PROC
EXTRN	__imp__DispatchMessageA@4:PROC
EXTRN	__imp__PeekMessageA@20:PROC
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	__imp__PostMessageA@16:PROC
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__PostQuitMessage@4:PROC
EXTRN	__imp__RegisterClassA@4:PROC
EXTRN	__imp__CreateWindowExA@48:PROC
EXTRN	__imp__IsWindow@4:PROC
EXTRN	__imp__DestroyWindow@4:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__SetWindowPos@28:PROC
EXTRN	__imp__SetTimer@16:PROC
EXTRN	__imp__UpdateWindow@4:PROC
EXTRN	__imp__GetDC@4:PROC
EXTRN	__imp__ReleaseDC@8:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp__AdjustWindowRectEx@16:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp__ShowCursor@4:PROC
EXTRN	__imp__ClientToScreen@8:PROC
EXTRN	__imp__SetRect@20:PROC
EXTRN	__imp__OffsetRect@12:PROC
EXTRN	__imp__SetWindowLongA@12:PROC
EXTRN	__imp__LoadCursorA@8:PROC
EXTRN	__imp__LoadIconA@8:PROC
EXTRN	__imp__ChangeDisplaySettingsA@8:PROC
EXTRN	__imp__LCMapStringA@24:PROC
EXTRN	?InitOffScreenSurface@@YAHXZ:PROC		; InitOffScreenSurface
EXTRN	?InitDirectDraw@@YAHXZ:PROC			; InitDirectDraw
EXTRN	?InitPalette@@YAHXZ:PROC			; InitPalette
EXTRN	?ClearBackSurface@@YAXXZ:PROC			; ClearBackSurface
EXTRN	?CheckSurfaceLost@@YAHXZ:PROC			; CheckSurfaceLost
EXTRN	?ReleaseDirectDraw@@YAXXZ:PROC			; ReleaseDirectDraw
EXTRN	?GameMain@@YAHXZ:PROC				; GameMain
EXTRN	?repairMap@@YAXXZ:PROC				; repairMap
EXTRN	?JL_GetAddress@@YAHH@Z:PROC			; JL_GetAddress
EXTRN	?JL_SetAddr@@YAXHH@Z:PROC			; JL_SetAddr
EXTRN	?PutBmp@@YAXXZ:PROC				; PutBmp
EXTRN	?StockStrBufferChar@@YAXD@Z:PROC		; StockStrBufferChar
EXTRN	?ClearChatBuffer@@YAXXZ:PROC			; ClearChatBuffer
EXTRN	?KeyboardLeft@@YAXXZ:PROC			; KeyboardLeft
EXTRN	?KeyboardRight@@YAXXZ:PROC			; KeyboardRight
EXTRN	?KeyboardReturn@@YAXXZ:PROC			; KeyboardReturn
EXTRN	?KeyboardBackSpace@@YAXXZ:PROC			; KeyboardBackSpace
EXTRN	?MouseNowPoint@@YAXHH@Z:PROC			; MouseNowPoint
EXTRN	?MouseCrickLeftDownPoint@@YAXHH@Z:PROC		; MouseCrickLeftDownPoint
EXTRN	?MouseCrickLeftUpPoint@@YAXHH@Z:PROC		; MouseCrickLeftUpPoint
EXTRN	?MouseCrickRightDownPoint@@YAXHH@Z:PROC		; MouseCrickRightDownPoint
EXTRN	?MouseCrickRightUpPoint@@YAXHH@Z:PROC		; MouseCrickRightUpPoint
EXTRN	?MouseDblCrickLeftUpPoint@@YAXHH@Z:PROC		; MouseDblCrickLeftUpPoint
EXTRN	?MouseDblCrickRightUpPoint@@YAXHH@Z:PROC	; MouseDblCrickRightUpPoint
EXTRN	_CreateToolhelp32Snapshot@8:PROC
EXTRN	_Process32First@8:PROC
EXTRN	_Process32Next@8:PROC
EXTRN	?ChangeMode@@YAXH@Z:PROC			; ChangeMode
EXTRN	?ImeMessage@@YAHIIJ@Z:PROC			; ImeMessage
EXTRN	?ReadBattleMap@@YAHH@Z:PROC			; ReadBattleMap
EXTRN	?GB2312ToBIG5@@YAPADPBD@Z:PROC			; GB2312ToBIG5
EXTRN	??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z:PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vector deleting destructor'
EXTRN	??_E?$numpunct@D@std@@MAEPAXI@Z:PROC		; std::numpunct<char>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alldiv:PROC
EXTRN	__ltod3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
EXTRN	?id@?$ctype@D@std@@2V0locale@2@A:DWORD		; std::ctype<char>::id
EXTRN	?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE ; std::cout
EXTRN	?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE ; std::cerr
EXTRN	?SurfaceSizeX@@3HA:DWORD			; SurfaceSizeX
EXTRN	?SurfaceSizeY@@3HA:DWORD			; SurfaceSizeY
EXTRN	?Palette@@3PAUtagPALETTEENTRY@@A:BYTE		; Palette
EXTRN	?lpDraw@@3PAUDIRECT_DRAW@@A:DWORD		; lpDraw
EXTRN	?BackBufferDrawType@@3HA:DWORD			; BackBufferDrawType
EXTRN	?ResoMode@@3HA:DWORD				; ResoMode
EXTRN	?NowTime@@3KA:DWORD				; NowTime
EXTRN	?ProcNo@@3IA:DWORD				; ProcNo
EXTRN	?DispBuffer@@3UDISP_BUFFER@@A:BYTE		; DispBuffer
EXTRN	?SurfaceBusyFlag@@3HA:DWORD			; SurfaceBusyFlag
EXTRN	?joy_con@@3PAKA:QWORD				; joy_con
EXTRN	?di_key@@3PAEA:BYTE				; di_key
EXTRN	?pDInputDevice@@3PAUIDirectInputDeviceA@@A:DWORD ; pDInputDevice
EXTRN	?pDInputDevice2@@3PAUIDirectInputDevice2A@@A:DWORD ; pDInputDevice2
EXTRN	?joy_flg@@3DA:BYTE				; joy_flg
EXTRN	?keyboad_flg@@3DA:BYTE				; keyboad_flg
EXTRN	?DInputActiveFlag@@3HA:DWORD			; DInputActiveFlag
EXTRN	?pNowStrBuffer@@3PAUSTR_BUFFER@@A:DWORD		; pNowStrBuffer
EXTRN	?FontCnt@@3HA:DWORD				; FontCnt
EXTRN	?mouse@@3UMOUSE@@A:BYTE				; mouse
EXTRN	?BattleMapNo@@3HA:DWORD				; BattleMapNo
EXTRN	?fastDrawTile@@3FB:WORD				; fastDrawTile
EXTRN	?fastDrawTileFlag@@3FA:WORD			; fastDrawTileFlag
EXTRN	???@@3HA:DWORD					; ??
EXTRN	?displayBpp@@3HA:DWORD				; displayBpp
EXTRN	?g_WgRecvHwnd@@3HA:DWORD			; g_WgRecvHwnd
EXTRN	?g_playerAddr@@3HA:DWORD			; g_playerAddr
EXTRN	?g_WgRecvHwnd@@3HA:DWORD			; g_WgRecvHwnd
EXTRN	?g_playerAddr@@3HA:DWORD			; g_playerAddr
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::numpunct<char> >::_Psave
_BSS	ENDS
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __real@4202a05f20000000
CONST	SEGMENT
__real@4202a05f20000000 DQ 04202a05f20000000r	; 1e+10
CONST	ENDS
;	COMDAT __real@416312d000000000
CONST	SEGMENT
__real@416312d000000000 DQ 0416312d000000000r	; 1e+07
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$numpunct@D@std@@8 DD FLAT:??_R0?AV?$numpunct@D@std@@@8 ; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R2?$numpunct@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$numpunct@D@std@@8 ; std::numpunct<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R3?$numpunct@D@std@@8 DD 00H				; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
data$rs	SEGMENT
??_R0?AV?$numpunct@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::numpunct<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$numpunct@D@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT
??_R4?$numpunct@D@std@@6B@ DD 00H			; std::numpunct<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$numpunct@D@std@@@8
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@'
	DB	'std@@@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@failure@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@failure@ios_base@std@@8 DD FLAT:??_R0?AVfailure@ios_base@std@@@8 ; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT
??_R2failure@ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@system_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT
??_R3failure@ios_base@std@@8 DD 00H			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT
??_R4failure@ios_base@std@@6B@ DD 00H			; std::ios_base::failure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ctype@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@D@std@@8 DD FLAT:??_R0?AV?$ctype@D@std@@@8 ; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT
??_R2?$ctype@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ctype_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT
??_R3?$ctype@D@std@@8 DD 00H				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
data$rs	SEGMENT
??_R0?AV?$ctype@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ctype@D@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@D@std@@6B@ DD 00H				; std::ctype<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ctype@D@std@@@8
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ctype_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ctype_base@std@@8 DD FLAT:??_R0?AUctype_base@std@@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ctype_base@std@@8
rdata$r	SEGMENT
??_R2ctype_base@std@@8 DD FLAT:??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ctype_base@std@@8
rdata$r	SEGMENT
??_R3ctype_base@std@@8 DD 00H				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
data$rs	SEGMENT
??_R0?AUctype_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUctype_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4ctype_base@std@@6B@
rdata$r	SEGMENT
??_R4ctype_base@std@@6B@ DD 00H				; std::ctype_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUctype_base@std@@@8
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT
??_R4facet@locale@std@@6B@ DD 00H			; std::locale::facet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfacet@locale@std@@@8
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R2_Crt_new_delete@std@@8 DD FLAT:??_R1A@?0A@EA@_Crt_new_delete@std@@8 ; std::_Crt_new_delete::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R3_Crt_new_delete@std@@8 DD 00H			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU_Crt_new_delete@std@@@8
data$rs	SEGMENT
??_R0?AU_Crt_new_delete@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Crt_new_delete `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU_Crt_new_delete@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R13?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD FLAT:??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
data$rs	SEGMENT
??_R0?AVfacet@locale@std@@@8 DD FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfacet@locale@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD FLAT:??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Facet_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Facet_base@std@@8 DD FLAT:??_R0?AV_Facet_base@std@@@8 ; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Facet_base@std@@8
rdata$r	SEGMENT
??_R2_Facet_base@std@@8 DD FLAT:??_R1A@?0A@EA@_Facet_base@std@@8 ; std::_Facet_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Facet_base@std@@8
rdata$r	SEGMENT
??_R3_Facet_base@std@@8 DD 00H				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Facet_base@std@@@8
data$rs	SEGMENT
??_R0?AV_Facet_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Facet_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Facet_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4_Facet_base@std@@6B@
rdata$r	SEGMENT
??_R4_Facet_base@std@@6B@ DD 00H			; std::_Facet_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Facet_base@std@@@8
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category2@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category2@std@@8 DD FLAT:??_R0?AV_Iostream_error_category2@std@@@8 ; std::_Iostream_error_category2::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category2@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category2@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category2@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category2@std@@8 ; std::_Iostream_error_category2::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category2@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category2@std@@8 DD 00H		; std::_Iostream_error_category2::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Iostream_error_category2@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category2@std@@@8
data$rs	SEGMENT
??_R0?AV_Iostream_error_category2@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category2 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category2@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4_Iostream_error_category2@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category2@std@@6B@ DD 00H		; std::_Iostream_error_category2::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category2@std@@@8
	DD	FLAT:??_R3_Iostream_error_category2@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@system_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@system_error@std@@8 DD FLAT:??_R0?AVsystem_error@std@@@8 ; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2system_error@std@@8
rdata$r	SEGMENT
??_R2system_error@std@@8 DD FLAT:??_R1A@?0A@EA@system_error@std@@8 ; std::system_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3system_error@std@@8
rdata$r	SEGMENT
??_R3system_error@std@@8 DD 00H				; std::system_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4system_error@std@@6B@
rdata$r	SEGMENT
??_R4system_error@std@@6B@ DD 00H			; std::system_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error@std@@8 DD FLAT:??_R0?AV_System_error@std@@@8 ; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error@std@@8
rdata$r	SEGMENT
??_R2_System_error@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error@std@@8 ; std::_System_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error@std@@8
rdata$r	SEGMENT
??_R3_System_error@std@@8 DD 00H			; std::_System_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4_System_error@std@@6B@
rdata$r	SEGMENT
??_R4_System_error@std@@6B@ DD 00H			; std::_System_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$rs	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD FLAT:??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD FLAT:??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 00H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A
_DATA	SEGMENT
?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A DD FLAT:??_7_Iostream_error_category2@std@@6B@ ; `std::_Immortalize_memcpy_image<std::_Iostream_error_category2>'::`2'::_Static
	DD	05H
_DATA	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4@
CONST	SEGMENT
??_C@_01LFCBOECM@?4@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OOPEBDOJ@pP@
CONST	SEGMENT
??_C@_02OOPEBDOJ@pP@ DB 'pP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MDKMJEGG@eE@
CONST	SEGMENT
??_C@_02MDKMJEGG@eE@ DB 'eE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7?$numpunct@D@std@@6B@
CONST	SEGMENT
??_7?$numpunct@D@std@@6B@ DD FLAT:??_R4?$numpunct@D@std@@6B@ ; std::numpunct<char>::`vftable'
	DD	FLAT:??_E?$numpunct@D@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_decimal_point@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
CONST	ENDS
;	COMDAT ??_C@_02EAOCLKAK@ld@
CONST	SEGMENT
??_C@_02EAOCLKAK@ld@ DB 'ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BDDLJJBK@lu@
CONST	SEGMENT
??_C@_02BDDLJJBK@lu@ DB 'lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIKPPMOK@Ld@
CONST	SEGMENT
??_C@_02HIKPPMOK@Ld@ DB 'Ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CLHGNPPK@Lu@
CONST	SEGMENT
??_C@_02CLHGNPPK@Lu@ DB 'Lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp@
CONST	SEGMENT
??_C@_02BBAHNLBA@?$CFp@ DB '%p', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
CONST	SEGMENT
??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD FLAT:??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
	DD	FLAT:??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
CONST	ENDS
;	COMDAT ??_C@_0CA@DDNACEOP@HeapAlloc?5Error?5?$CI?5DIRECT_DRAW?5?$CJ@
CONST	SEGMENT
??_C@_0CA@DDNACEOP@HeapAlloc?5Error?5?$CI?5DIRECT_DRAW?5?$CJ@ DB 'HeapAll'
	DB	'oc Error ( DIRECT_DRAW )', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OHJJEBKC@SurfaceBusyFlag?5error?$CB@
CONST	SEGMENT
??_C@_0BH@OHJJEBKC@SurfaceBusyFlag?5error?$CB@ DB 'SurfaceBusyFlag error!'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LIOBMBPJ@?$NP?d?$DP?5?t?x?c?$LH?$PL?y?c?w?$DP?$KD?$KB@
CONST	SEGMENT
??_C@_0BA@LIOBMBPJ@?$NP?d?$DP?5?t?x?c?$LH?$PL?y?c?w?$DP?$KD?$KB@ DB 0dfH, 0e4H
	DB	'? ', 0f4H, 0f8H, 0e3H, 0b7H, 0fbH, 0f9H, 0e3H, 0f7H, '?', 0a3H
	DB	0a1H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HCDANIG@Direct?5?t?x?c?$LH?$PL?y?c?w?$DP?$KD?$KB@
CONST	SEGMENT
??_C@_0BD@HCDANIG@Direct?5?t?x?c?$LH?$PL?y?c?w?$DP?$KD?$KB@ DB 'Direct ', 0f4H
	DB	0f8H, 0e3H, 0b7H, 0fbH, 0f9H, 0e3H, 0f7H, '?', 0a3H, 0a1H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CGONDAHB@nodelay@
CONST	SEGMENT
??_C@_07CGONDAHB@nodelay@ DB 'nodelay', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LHBEADJK@data?2spradrn_?$CFd?4bin@
CONST	SEGMENT
??_C@_0BE@LHBEADJK@data?2spradrn_?$CFd?4bin@ DB 'data\spradrn_%d.bin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EPOMFNLL@spradrnbin?3@
CONST	SEGMENT
??_C@_0M@EPOMFNLL@spradrnbin?3@ DB 'spradrnbin:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ICLKDLOG@data?2spr_?$CFd?4bin@
CONST	SEGMENT
??_C@_0BA@ICLKDLOG@data?2spr_?$CFd?4bin@ DB 'data\spr_%d.bin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07NALMGOPD@sprbin?3@
CONST	SEGMENT
??_C@_07NALMGOPD@sprbin?3@ DB 'sprbin:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ELLBFFLH@data?2adrn_?$CFd?4bin@
CONST	SEGMENT
??_C@_0BB@ELLBFFLH@data?2adrn_?$CFd?4bin@ DB 'data\adrn_%d.bin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08INHKNLCI@adrnbin?3@
CONST	SEGMENT
??_C@_08INHKNLCI@adrnbin?3@ DB 'adrnbin:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BDNGKHBG@data?2real_?$CFd?4bin@
CONST	SEGMENT
??_C@_0BB@BDNGKHBG@data?2real_?$CFd?4bin@ DB 'data\real_%d.bin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MPGDICFK@realbin?3@
CONST	SEGMENT
??_C@_08MPGDICFK@realbin?3@ DB 'realbin:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PFEKOFDI@data?2spradrn?4bin@
CONST	SEGMENT
??_C@_0BB@PFEKOFDI@data?2spradrn?4bin@ DB 'data\spradrn.bin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LCHFCHHG@data?2spr?4bin@
CONST	SEGMENT
??_C@_0N@LCHFCHHG@data?2spr?4bin@ DB 'data\spr.bin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HIHIJMIB@data?2adrn?4bin@
CONST	SEGMENT
??_C@_0O@HIHIJMIB@data?2adrn?4bin@ DB 'data\adrn.bin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DKGBMFPD@data?2real?4bin@
CONST	SEGMENT
??_C@_0O@DKGBMFPD@data?2real?4bin@ DB 'data\real.bin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@MPCLFILL@?t?x?c?$LH?$PL?y?$DP?$DP?c?w?$DP?$KD?$KB?6?$KD?$KM?$DP?$DP?z?$LM?q?l?c?f?d?L?$DP?$PL?d?$PN?g@
CONST	SEGMENT
??_C@_0CK@MPCLFILL@?t?x?c?$LH?$PL?y?$DP?$DP?c?w?$DP?$KD?$KB?6?$KD?$KM?$DP?$DP?z?$LM?q?l?c?f?d?L?$DP?$PL?d?$PN?g@ DB 0f4H
	DB	0f8H, 0e3H, 0b7H, 0fbH, 0f9H, '??', 0e3H, 0f7H, '?', 0a3H, 0a1H
	DB	0aH, 0a3H, 0acH, '??', 0faH, 0bcH, 0f1H, 0ecH, 0e3H, 0e6H, 0e4H
	DB	0ccH, '?', 0fbH, 0e4H, 0fdH, 0e7H, '?', 0cbH, 0d4H, 0dcH, 0d7H
	DB	0ecH, 0d1H, '?', 0a3H, 0a1H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IJNKKJEO@?H?$KO?$MA?N@
CONST	SEGMENT
??_C@_04IJNKKJEO@?H?$KO?$MA?N@ DB 0c8H, 0aeH, 0c0H, 0ceH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NLNMPB@?$KD?S?$KD?t?$KD?o?$KD?n?$KD?e?$KD?A?$KD?g?$KD?e@
CONST	SEGMENT
??_C@_0BB@NLNMPB@?$KD?S?$KD?t?$KD?o?$KD?n?$KD?e?$KD?A?$KD?g?$KD?e@ DB 0a3H
	DB	0d3H, 0a3H, 0f4H, 0a3H, 0efH, 0a3H, 0eeH, 0a3H, 0e5H, 0a3H, 0c1H
	DB	0a3H, 0e7H, 0a3H, 0e5H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FDFFMAOB@CheckForUpdate@
CONST	SEGMENT
??_C@_0P@FDFFMAOB@CheckForUpdate@ DB 'CheckForUpdate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NBCMJDEF@Output?5error?6@
CONST	SEGMENT
??_C@_0O@NBCMJDEF@Output?5error?6@ DB 'Output error', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FMGGALCC@Output?5standard?6@
CONST	SEGMENT
??_C@_0BB@FMGGALCC@Output?5standard?6@ DB 'Output standard', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
xdata$x	SEGMENT
__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20 DD 00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0failure@ios_base@std@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
data$r	SEGMENT
??_R0?AVfailure@ios_base@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::ios_base::failure `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfailure@ios_base@std@@', 00H
data$r	ENDS
;	COMDAT __CTA5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__CTA5?AVfailure@ios_base@std@@ DD 05H
	DD	FLAT:__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
	DD	FLAT:__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__TI5?AVfailure@ios_base@std@@ DD 00H
	DD	FLAT:??1failure@ios_base@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA5?AVfailure@ios_base@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
CONST	SEGMENT
??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@ DB 'ios_base::eofbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
CONST	SEGMENT
??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@ DB 'ios_base::failbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
CONST	SEGMENT
??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@ DB 'ios_base::badbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT
??_7failure@ios_base@std@@6B@ DD FLAT:??_R4failure@ios_base@std@@6B@ ; std::ios_base::failure::`vftable'
	DD	FLAT:??_Efailure@ios_base@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT
??_7?$ctype@D@std@@6B@ DD FLAT:??_R4?$ctype@D@std@@6B@	; std::ctype<char>::`vftable'
	DD	FLAT:??_E?$ctype@D@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEDDD@Z
CONST	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DD FLAT:??_R4ctype_base@std@@6B@ ; std::ctype_base::`vftable'
	DD	FLAT:??_Ectype_base@std@@UAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT
??_7facet@locale@std@@6B@ DD FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
	DD	FLAT:??_Efacet@locale@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ELKIONDK@bad?5locale?5name@
CONST	SEGMENT
??_C@_0BA@ELKIONDK@bad?5locale?5name@ DB 'bad locale name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7_Facet_base@std@@6B@
CONST	SEGMENT
??_7_Facet_base@std@@6B@ DD FLAT:??_R4_Facet_base@std@@6B@ ; std::_Facet_base::`vftable'
	DD	FLAT:??_E_Facet_base@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB
CONST	SEGMENT
?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB DB 069H ; `std::_Iostream_error_category2::message'::`5'::_Iostream_error
	DB	06fH
	DB	073H
	DB	074H
	DB	072H
	DB	065H
	DB	061H
	DB	06dH
	DB	020H
	DB	073H
	DB	074H
	DB	072H
	DB	065H
	DB	061H
	DB	06dH
	DB	020H
	DB	065H
	DB	072H
	DB	072H
	DB	06fH
	DB	072H
	DB	00H
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream@ DB 'iostream', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category2@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category2@std@@6B@ DD FLAT:??_R4_Iostream_error_category2@std@@6B@ ; std::_Iostream_error_category2::`vftable'
	DD	FLAT:??_E_Iostream_error_category2@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category2@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT __CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0_System_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AV_System_error@std@@@8
data$r	SEGMENT
??_R0?AV_System_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0system_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVsystem_error@std@@@8
data$r	SEGMENT
??_R0?AVsystem_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::system_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVsystem_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_7system_error@std@@6B@
CONST	SEGMENT
??_7system_error@std@@6B@ DD FLAT:??_R4system_error@std@@6B@ ; std::system_error::`vftable'
	DD	FLAT:??_Esystem_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7_System_error@std@@6B@
CONST	SEGMENT
??_7_System_error@std@@6B@ DD FLAT:??_R4_System_error@std@@6B@ ; std::_System_error::`vftable'
	DD	FLAT:??_E_System_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
data$r	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast@ DB 'bad cast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DD FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DD	FLAT:??_Ebad_cast@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Invoke@V?$tuple@P6AXXZ@std@@$0A@@thread@std@@CGIPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Invoke@V?$tuple@P6AXXZ@std@@$0A@@thread@std@@CGIPAX@Z$0
__ehfuncinfo$??$_Invoke@V?$tuple@P6AXXZ@std@@$0A@@thread@std@@CGIPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Invoke@V?$tuple@P6AXXZ@std@@$0A@@thread@std@@CGIPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$make_unique@V?$tuple@P6AXXZ@std@@A6AXXZ$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXXZ@std@@U?$default_delete@V?$tuple@P6AXXZ@std@@@2@@0@A6AXXZ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$make_unique@V?$tuple@P6AXXZ@std@@A6AXXZ$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXXZ@std@@U?$default_delete@V?$tuple@P6AXXZ@std@@@2@@0@A6AXXZ@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$make_unique@V?$tuple@P6AXXZ@std@@A6AXXZ$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXXZ@std@@U?$default_delete@V?$tuple@P6AXXZ@std@@@2@@0@A6AXXZ@Z$0
__ehfuncinfo$??$make_unique@V?$tuple@P6AXXZ@std@@A6AXXZ$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXXZ@std@@U?$default_delete@V?$tuple@P6AXXZ@std@@@2@@0@A6AXXZ@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$make_unique@V?$tuple@P6AXXZ@std@@A6AXXZ$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXXZ@std@@U?$default_delete@V?$tuple@P6AXXZ@std@@@2@@0@A6AXXZ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Start@A6AXXZ$$V@thread@std@@AAEXA6AXXZ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Start@A6AXXZ$$V@thread@std@@AAEXA6AXXZ@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Start@A6AXXZ$$V@thread@std@@AAEXA6AXXZ@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Start@A6AXXZ$$V@thread@std@@AAEXA6AXXZ@Z$1
__ehfuncinfo$??$_Start@A6AXXZ$$V@thread@std@@AAEXA6AXXZ@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Start@A6AXXZ$$V@thread@std@@AAEXA6AXXZ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$numpunct@D@std@@MAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$numpunct@D@std@@MAEPAXI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$numpunct@D@std@@MAEPAXI@Z$1
__ehfuncinfo$??_G?$numpunct@D@std@@MAEPAXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??_G?$numpunct@D@std@@MAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$numpunct@D@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$0
__ehfuncinfo$?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$0
__ehfuncinfo$?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$0
__ehfuncinfo$?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$0
__ehfuncinfo$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$numpunct@D@std@@MAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$numpunct@D@std@@MAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$numpunct@D@std@@MAE@XZ$1
__ehfuncinfo$??1?$numpunct@D@std@@MAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$numpunct@D@std@@MAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$2
	DD	03H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z$2
__ehfuncinfo$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$0
__ehfuncinfo$?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$0
__ehfuncinfo$?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$0
__ehfuncinfo$?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$1
__ehfuncinfo$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z$1
__ehfuncinfo$??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$3
__ehfuncinfo$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$3
__ehfuncinfo$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z$0
__ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z$0
__ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$6
__ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z$0
__ehfuncinfo$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ$1
__ehfuncinfo$??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$6
	DD	03H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$2
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0A6AXXZ$$V$0A@@thread@std@@QAE@A6AXXZ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0A6AXXZ$$V$0A@@thread@std@@QAE@A6AXXZ@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$?0A6AXXZ$$V$0A@@thread@std@@QAE@A6AXXZ@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0A6AXXZ$$V$0A@@thread@std@@QAE@A6AXXZ@Z$1
__ehfuncinfo$??$?0A6AXXZ$$V$0A@@thread@std@@QAE@A6AXXZ@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?0A6AXXZ$$V$0A@@thread@std@@QAE@A6AXXZ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$4
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$2
__ehfuncinfo$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$6 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$0
__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$6
__ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$4
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0
__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2
__ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$_WinMain@16 DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_WinMain@16$1
	DD	00H
	DD	FLAT:__unwindfunclet$_WinMain@16$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_WinMain@16$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_WinMain@16$0
__ehfuncinfo$_WinMain@16 DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$_WinMain@16
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?getloc@ios_base@std@@QBE?AVlocale@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getloc@ios_base@std@@QBE?AVlocale@2@XZ$0
__ehfuncinfo$?getloc@ios_base@std@@QBE?AVlocale@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getloc@ios_base@std@@QBE?AVlocale@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_Gfailure@ios_base@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_Gfailure@ios_base@std@@UAEPAXI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??_Gfailure@ios_base@std@@UAEPAXI@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??_Gfailure@ios_base@std@@UAEPAXI@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??_Gfailure@ios_base@std@@UAEPAXI@Z$3
__ehfuncinfo$??_Gfailure@ios_base@std@@UAEPAXI@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??_Gfailure@ios_base@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0failure@ios_base@std@@QAE@ABV012@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0failure@ios_base@std@@QAE@ABV012@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0failure@ios_base@std@@QAE@ABV012@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0failure@ios_base@std@@QAE@ABV012@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0failure@ios_base@std@@QAE@ABV012@@Z$0
__ehfuncinfo$??0failure@ios_base@std@@QAE@ABV012@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0failure@ios_base@std@@QAE@ABV012@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1failure@ios_base@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1failure@ios_base@std@@UAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1failure@ios_base@std@@UAE@XZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1failure@ios_base@std@@UAE@XZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1failure@ios_base@std@@UAE@XZ$3
__ehfuncinfo$??1failure@ios_base@std@@UAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1failure@ios_base@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z$0
__ehfuncinfo$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$7
	DD	03H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$6
	DD	03H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$ctype@D@std@@MAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$ctype@D@std@@MAEPAXI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$ctype@D@std@@MAEPAXI@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$ctype@D@std@@MAEPAXI@Z$2
__ehfuncinfo$??_G?$ctype@D@std@@MAEPAXI@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??_G?$ctype@D@std@@MAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$ctype@D@std@@IAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$ctype@D@std@@MAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$ctype@D@std@@MAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$ctype@D@std@@MAE@XZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$ctype@D@std@@MAE@XZ$2
__ehfuncinfo$??1?$ctype@D@std@@MAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1?$ctype@D@std@@MAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z$0
__ehfuncinfo$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_Gctype_base@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_Gctype_base@std@@UAEPAXI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??_Gctype_base@std@@UAEPAXI@Z$1
__ehfuncinfo$??_Gctype_base@std@@UAEPAXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??_Gctype_base@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1ctype_base@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1ctype_base@std@@UAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1ctype_base@std@@UAE@XZ$1
__ehfuncinfo$??1ctype_base@std@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1ctype_base@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ctype_base@std@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ctype_base@std@@QAE@I@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0ctype_base@std@@QAE@I@Z$0
__ehfuncinfo$??0ctype_base@std@@QAE@I@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0ctype_base@std@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_Gfacet@locale@std@@MAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_Gfacet@locale@std@@MAEPAXI@Z$0
__ehfuncinfo$??_Gfacet@locale@std@@MAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_Gfacet@locale@std@@MAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1facet@locale@std@@MAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1facet@locale@std@@MAE@XZ$0
__ehfuncinfo$??1facet@locale@std@@MAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1facet@locale@std@@MAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0facet@locale@std@@IAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0facet@locale@std@@IAE@I@Z$0
__ehfuncinfo$??0facet@locale@std@@IAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0facet@locale@std@@IAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??Bid@locale@std@@QAEIXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??Bid@locale@std@@QAEIXZ$0
__ehfuncinfo$??Bid@locale@std@@QAEIXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??Bid@locale@std@@QAEIXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$_Yarn@_W@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Yarn@_W@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$_Yarn@D@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Yarn@D@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Locinfo@std@@QAE@XZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??1_Locinfo@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
__unwindtable$??1_Locinfo@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0_Locinfo@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0_Locinfo@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
__ehfuncinfo$?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_Gsystem_error@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_Gsystem_error@std@@UAEPAXI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??_Gsystem_error@std@@UAEPAXI@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??_Gsystem_error@std@@UAEPAXI@Z$2
__ehfuncinfo$??_Gsystem_error@std@@UAEPAXI@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??_Gsystem_error@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0system_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0system_error@std@@QAE@ABV01@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0system_error@std@@QAE@ABV01@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0system_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0system_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0system_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1system_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1system_error@std@@UAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1system_error@std@@UAE@XZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1system_error@std@@UAE@XZ$2
__ehfuncinfo$??1system_error@std@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1system_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0system_error@std@@QAE@Verror_code@1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$1
__ehfuncinfo$??0system_error@std@@QAE@Verror_code@1@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0system_error@std@@QAE@Verror_code@1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G_System_error@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G_System_error@std@@UAEPAXI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??_G_System_error@std@@UAEPAXI@Z$1
__ehfuncinfo$??_G_System_error@std@@UAEPAXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??_G_System_error@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0_System_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_System_error@std@@QAE@ABV01@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0_System_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0_System_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0_System_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1_System_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1_System_error@std@@UAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1_System_error@std@@UAE@XZ$1
__ehfuncinfo$??1_System_error@std@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1_System_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$6
	DD	01H
	DD	FLAT:__unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$7
	DD	01H
	DD	FLAT:__unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$3
__ehfuncinfo$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$0
__ehfuncinfo$?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_Gruntime_error@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_Gruntime_error@std@@UAEPAXI@Z$0
__ehfuncinfo$??_Gruntime_error@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_Gruntime_error@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0runtime_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0runtime_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1runtime_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1runtime_error@std@@UAE@XZ$0
__ehfuncinfo$??1runtime_error@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1runtime_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_Gbad_cast@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_Gbad_cast@std@@UAEPAXI@Z$0
__ehfuncinfo$??_Gbad_cast@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_Gbad_cast@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_cast@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_cast@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0bad_cast@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_cast@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1bad_cast@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1bad_cast@std@@UAE@XZ$0
__ehfuncinfo$??1bad_cast@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1bad_cast@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_cast@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_cast@std@@QAE@XZ$0
__ehfuncinfo$??0bad_cast@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_cast@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_Gbad_array_new_length@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_Gbad_array_new_length@std@@UAEPAXI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??_Gbad_array_new_length@std@@UAEPAXI@Z$1
__ehfuncinfo$??_Gbad_array_new_length@std@@UAEPAXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??_Gbad_array_new_length@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_array_new_length@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_array_new_length@std@@QAE@ABV01@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_array_new_length@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0bad_array_new_length@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0bad_array_new_length@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1bad_array_new_length@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1bad_array_new_length@std@@UAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1bad_array_new_length@std@@UAE@XZ$1
__ehfuncinfo$??1bad_array_new_length@std@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1bad_array_new_length@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_array_new_length@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_array_new_length@std@@QAE@XZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_array_new_length@std@@QAE@XZ$0
__ehfuncinfo$??0bad_array_new_length@std@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0bad_array_new_length@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_Gbad_alloc@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_Gbad_alloc@std@@UAEPAXI@Z$0
__ehfuncinfo$??_Gbad_alloc@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_Gbad_alloc@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1bad_alloc@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0
__ehfuncinfo$??1bad_alloc@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1bad_alloc@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@AAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@AAE@QBD@Z$0
__ehfuncinfo$??0bad_alloc@std@@AAE@QBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@AAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_Gexception@std@@UAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1exception@std@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0exception@std@@QAE@ABV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0exception@std@@QAE@QBD@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\thread
;	COMDAT ??$_Invoke@V?$tuple@P6AXXZ@std@@$0A@@thread@std@@CGIPAX@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__FnVals$ = 8						; size = 4
__RawVals$ = 8						; size = 4
??$_Invoke@V?$tuple@P6AXXZ@std@@$0A@@thread@std@@CGIPAX@Z PROC ; std::thread::_Invoke<std::tuple<void (__cdecl*)(void)>,0>, COMDAT

; 51   :     static unsigned int __stdcall _Invoke(void* _RawVals) noexcept /* terminates */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Invoke@V?$tuple@P6AXXZ@std@@$0A@@thread@std@@CGIPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1370 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00023	8b 75 08	 mov	 esi, DWORD PTR __RawVals$[ebp]
  00026	89 75 08	 mov	 DWORD PTR __FnVals$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\thread

; 53   :         const unique_ptr<_Tuple> _FnVals(static_cast<_Tuple*>(_RawVals));

  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits

; 1585 :     return static_cast<_Callable&&>(_Obj)();

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	ff d0		 call	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\thread

; 56   :         _Cnd_do_broadcast_at_thread_exit(); // TRANSITION, ABI

  00034	e8 00 00 00 00	 call	 __Cnd_do_broadcast_at_thread_exit

; 57   :         return 0;

  00039	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\memory

; 3120 :         delete _Ptr;

  00040	6a 04		 push	 4
  00042	56		 push	 esi
  00043	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00048	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\thread

; 57   :         return 0;

  0004b	33 c0		 xor	 eax, eax

; 58   :     }

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	5e		 pop	 esi
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Invoke@V?$tuple@P6AXXZ@std@@$0A@@thread@std@@CGIPAX@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR __FnVals$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V?$tuple@P6AXXZ@std@@U?$default_delete@V?$tuple@P6AXXZ@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(void)>,std::default_delete<std::tuple<void (__cdecl*)(void)> > >::~unique_ptr<std::tuple<void (__cdecl*)(void)>,std::default_delete<std::tuple<void (__cdecl*)(void)> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Invoke@V?$tuple@P6AXXZ@std@@$0A@@thread@std@@CGIPAX@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Invoke@V?$tuple@P6AXXZ@std@@$0A@@thread@std@@CGIPAX@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Invoke@V?$tuple@P6AXXZ@std@@$0A@@thread@std@@CGIPAX@Z ENDP ; std::thread::_Invoke<std::tuple<void (__cdecl*)(void)>,0>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\memory
;	COMDAT ??1?$unique_ptr@V?$tuple@P6AXXZ@std@@U?$default_delete@V?$tuple@P6AXXZ@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$unique_ptr@V?$tuple@P6AXXZ@std@@U?$default_delete@V?$tuple@P6AXXZ@std@@@2@@std@@QAE@XZ PROC ; std::unique_ptr<std::tuple<void (__cdecl*)(void)>,std::default_delete<std::tuple<void (__cdecl*)(void)> > >::~unique_ptr<std::tuple<void (__cdecl*)(void)>,std::default_delete<std::tuple<void (__cdecl*)(void)> > >, COMDAT
; _this$ = ecx

; 3229 :         if (_Mypair._Myval2) {

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	85 c0		 test	 eax, eax
  00004	74 0b		 je	 SHORT $LN2@unique_ptr

; 3120 :         delete _Ptr;

  00006	6a 04		 push	 4
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000e	83 c4 08	 add	 esp, 8
$LN2@unique_ptr:

; 3230 :             _Mypair._Get_first()(_Mypair._Myval2);
; 3231 :         }
; 3232 :     }

  00011	c3		 ret	 0
??1?$unique_ptr@V?$tuple@P6AXXZ@std@@U?$default_delete@V?$tuple@P6AXXZ@std@@@2@@std@@QAE@XZ ENDP ; std::unique_ptr<std::tuple<void (__cdecl*)(void)>,std::default_delete<std::tuple<void (__cdecl*)(void)> > >::~unique_ptr<std::tuple<void (__cdecl*)(void)>,std::default_delete<std::tuple<void (__cdecl*)(void)> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\memory
;	COMDAT ??$make_unique@V?$tuple@P6AXXZ@std@@A6AXXZ$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXXZ@std@@U?$default_delete@V?$tuple@P6AXXZ@std@@@2@@0@A6AXXZ@Z
_TEXT	SEGMENT
$T2 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_<_Args_0>$ = 12					; size = 4
??$make_unique@V?$tuple@P6AXXZ@std@@A6AXXZ$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXXZ@std@@U?$default_delete@V?$tuple@P6AXXZ@std@@@2@@0@A6AXXZ@Z PROC ; std::make_unique<std::tuple<void (__cdecl*)(void)>,void (__cdecl&)(void),0>, COMDAT

; 3415 : _NODISCARD unique_ptr<_Ty> make_unique(_Types&&... _Args) { // make a unique_ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$make_unique@V?$tuple@P6AXXZ@std@@A6AXXZ$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXXZ@std@@U?$default_delete@V?$tuple@P6AXXZ@std@@@2@@0@A6AXXZ@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 3416 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

  00025	6a 04		 push	 4
  00027	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  0002e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00033	8b d0		 mov	 edx, eax
  00035	83 c4 04	 add	 esp, 4
  00038	85 d2		 test	 edx, edx
  0003a	74 07		 je	 SHORT $LN3@make_uniqu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple

; 170  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

  0003c	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0003f	89 0a		 mov	 DWORD PTR [edx], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\memory

; 3416 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

  00041	eb 02		 jmp	 SHORT $LN4@make_uniqu
$LN3@make_uniqu:
  00043	33 d2		 xor	 edx, edx
$LN4@make_uniqu:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1370 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00045	89 55 f0	 mov	 DWORD PTR $T3[ebp], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\memory

; 3416 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

  00048	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1375 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

  00052	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1375 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00059	89 10		 mov	 DWORD PTR [eax], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\memory

; 3416 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

  0005b	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  00062	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0

; 3417 : }

  00066	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00069	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00070	59		 pop	 ecx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$make_unique@V?$tuple@P6AXXZ@std@@A6AXXZ$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXXZ@std@@U?$default_delete@V?$tuple@P6AXXZ@std@@@2@@0@A6AXXZ@Z$0:
  00000	8d 4d f0	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V?$tuple@P6AXXZ@std@@U?$default_delete@V?$tuple@P6AXXZ@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(void)>,std::default_delete<std::tuple<void (__cdecl*)(void)> > >::~unique_ptr<std::tuple<void (__cdecl*)(void)>,std::default_delete<std::tuple<void (__cdecl*)(void)> > >
__unwindfunclet$??$make_unique@V?$tuple@P6AXXZ@std@@A6AXXZ$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXXZ@std@@U?$default_delete@V?$tuple@P6AXXZ@std@@@2@@0@A6AXXZ@Z$1:
  00008	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  0000b	83 e0 01	 and	 eax, 1
  0000e	0f 84 0c 00 00
	00		 je	 $LN7@make_uniqu
  00014	83 65 ec fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00018	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V?$tuple@P6AXXZ@std@@U?$default_delete@V?$tuple@P6AXXZ@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(void)>,std::default_delete<std::tuple<void (__cdecl*)(void)> > >::~unique_ptr<std::tuple<void (__cdecl*)(void)>,std::default_delete<std::tuple<void (__cdecl*)(void)> > >
$LN7@make_uniqu:
  00020	c3		 ret	 0
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
  00024	cc		 int	 3
  00025	cc		 int	 3
__ehhandler$??$make_unique@V?$tuple@P6AXXZ@std@@A6AXXZ$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXXZ@std@@U?$default_delete@V?$tuple@P6AXXZ@std@@@2@@0@A6AXXZ@Z:
  00026	90		 npad	 1
  00027	90		 npad	 1
  00028	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00032	33 c8		 xor	 ecx, eax
  00034	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00039	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$make_unique@V?$tuple@P6AXXZ@std@@A6AXXZ$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXXZ@std@@U?$default_delete@V?$tuple@P6AXXZ@std@@@2@@0@A6AXXZ@Z
  0003e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$make_unique@V?$tuple@P6AXXZ@std@@A6AXXZ$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXXZ@std@@U?$default_delete@V?$tuple@P6AXXZ@std@@@2@@0@A6AXXZ@Z ENDP ; std::make_unique<std::tuple<void (__cdecl*)(void)>,void (__cdecl&)(void),0>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z PROC		; std::_Maklocchr<char>, COMDAT

; 495  : _Elem __CRTDECL _Maklocchr(char _Byte, _Elem*, const _Locinfo::_Cvtvec&) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 496  :     // convert char to _Elem using _Cvtvec
; 497  :     return static_cast<_Elem>(static_cast<unsigned char>(_Byte));

  00003	8a 45 08	 mov	 al, BYTE PTR __Byte$[ebp]

; 498  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ENDP		; std::_Maklocchr<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT

; 522  : _Elem* __CRTDECL _Maklocstr(const char* _Ptr, _Elem*, const _Locinfo::_Cvtvec&) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 523  :     // convert C string to _Elem sequence using _Cvtvec
; 524  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL11@Maklocstr:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL11@Maklocstr
  00017	56		 push	 esi
  00018	2b c2		 sub	 eax, edx
  0001a	57		 push	 edi

; 525  : 
; 526  :     _Elem* _Ptrdest = static_cast<_Elem*>(_calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__));

  0001b	6a 01		 push	 1
  0001d	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  00020	57		 push	 edi
  00021	e8 00 00 00 00	 call	 _calloc
  00026	8b f0		 mov	 esi, eax
  00028	83 c4 08	 add	 esp, 8

; 527  : 
; 528  :     if (!_Ptrdest) {

  0002b	85 f6		 test	 esi, esi
  0002d	74 17		 je	 SHORT $LN14@Maklocstr

; 530  :     }
; 531  : 
; 532  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

  0002f	85 ff		 test	 edi, edi
  00031	74 0d		 je	 SHORT $LN4@Maklocstr
  00033	57		 push	 edi
  00034	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00037	56		 push	 esi
  00038	e8 00 00 00 00	 call	 _memcpy
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@Maklocstr:

; 533  :         *_Ptrnext = static_cast<_Elem>(static_cast<unsigned char>(*_Ptr));
; 534  :     }
; 535  : 
; 536  :     return _Ptrdest;

  00040	5f		 pop	 edi
  00041	8b c6		 mov	 eax, esi
  00043	5e		 pop	 esi

; 537  : }

  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
$LN14@Maklocstr:

; 529  :         _Xbad_alloc();

  00046	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN12@Maklocstr:
  0004b	cc		 int	 3
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ PROC	; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >, COMDAT
; _this$ = ecx

; 34   :     _CONSTEXPR20_DYNALLOC ~_Tidy_guard() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 35   :         if (_Target) {

  00023	8b 31		 mov	 esi, DWORD PTR [ecx]
  00025	85 f6		 test	 esi, esi
  00027	74 1b		 je	 SHORT $LN2@Tidy_guard
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 227  :         _CSTD free(const_cast<char*>(_Grouping));

  00029	ff 76 08	 push	 DWORD PTR [esi+8]
  0002c	e8 00 00 00 00	 call	 _free

; 228  :         _CSTD free(const_cast<_Elem*>(_Falsename));

  00031	ff 76 10	 push	 DWORD PTR [esi+16]
  00034	e8 00 00 00 00	 call	 _free

; 229  :         _CSTD free(const_cast<_Elem*>(_Truename));

  00039	ff 76 14	 push	 DWORD PTR [esi+20]
  0003c	e8 00 00 00 00	 call	 _free
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@Tidy_guard:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 38   :     }

  00044	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00047	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004e	59		 pop	 ecx
  0004f	5e		 pop	 esi
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ ENDP	; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 134  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 135  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 137  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 85   :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 138  :         _Throw_bad_array_new_length(); // add overflow
; 139  :     }
; 140  : 
; 141  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 85   :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 145  : 
; 146  : #ifdef _DEBUG
; 147  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 148  : #endif // _DEBUG
; 149  :     return _Ptr;
; 150  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\memory
;	COMDAT ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >, COMDAT
; _this$ = ecx

; 3229 :         if (_Mypair._Myval2) {

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	85 c9		 test	 ecx, ecx
  00004	74 06		 je	 SHORT $LN6@unique_ptr

; 3120 :         delete _Ptr;

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	6a 01		 push	 1
  0000a	ff 10		 call	 DWORD PTR [eax]
$LN6@unique_ptr:

; 3230 :             _Mypair._Get_first()(_Mypair._Myval2);
; 3231 :         }
; 3232 :     }

  0000c	c3		 ret	 0
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z
_TEXT	SEGMENT
tv475 = -12						; size = 4
tv473 = -8						; size = 4
__New_size$1$ = -8					; size = 4
tv474 = -4						; size = 4
__Old_size$1$ = -4					; size = 4
__Old$1$ = 8						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
tv476 = 24						; size = 4
_<_Args_2>$ = 24					; size = 1
??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>, COMDAT
; _this$ = ecx

; 4538 :         const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 4539 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4540 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4541 :         auto& _My_data            = _Mypair._Myval2;
; 4542 :         const size_type _Old_size = _My_data._Mysize;
; 4543 :         if (max_size() - _Old_size < _Size_increase) {

  00008	8b 75 08	 mov	 esi, DWORD PTR __Size_increase$[ebp]
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  00013	8b c1		 mov	 eax, ecx
  00015	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  00018	2b c2		 sub	 eax, edx
  0001a	89 55 fc	 mov	 DWORD PTR __Old_size$1$[ebp], edx
  0001d	3b c6		 cmp	 eax, esi
  0001f	0f 82 4b 01 00
	00		 jb	 $LN59@Reallocate

; 4548 :         const size_type _Old_capacity = _My_data._Myres;

  00025	8b 5f 14	 mov	 ebx, DWORD PTR [edi+20]
  00028	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0002b	8b f0		 mov	 esi, eax

; 4545 :         }
; 4546 : 
; 4547 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	89 45 f8	 mov	 DWORD PTR __New_size$1$[ebp], eax

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00030	83 ce 0f	 or	 esi, 15			; 0000000fH

; 4548 :         const size_type _Old_capacity = _My_data._Myres;

  00033	89 5d 08	 mov	 DWORD PTR __Old$1$[ebp], ebx

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00036	3b f1		 cmp	 esi, ecx

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00038	76 17		 jbe	 SHORT $LN9@Reallocate

; 4490 :             return _Max;

  0003a	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0003f	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00047	8b 55 fc	 mov	 edx, DWORD PTR __Old_size$1$[ebp]
  0004a	83 c4 04	 add	 esp, 4
  0004d	8b d8		 mov	 ebx, eax
  0004f	eb 5b		 jmp	 SHORT $LN16@Reallocate
$LN9@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4493 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00051	8b c3		 mov	 eax, ebx
  00053	d1 e8		 shr	 eax, 1
  00055	2b c8		 sub	 ecx, eax
  00057	3b d9		 cmp	 ebx, ecx
  00059	76 1a		 jbe	 SHORT $LN10@Reallocate

; 4494 :             return _Max;

  0005b	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00060	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0006b	8b 55 fc	 mov	 edx, DWORD PTR __Old_size$1$[ebp]
  0006e	83 c4 04	 add	 esp, 4
  00071	8b d8		 mov	 ebx, eax
  00073	eb 37		 jmp	 SHORT $LN16@Reallocate
$LN10@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4497 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00075	03 c3		 add	 eax, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00077	3b f0		 cmp	 esi, eax
  00079	0f 42 f0	 cmovb	 esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4551 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0007c	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0007f	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00084	72 10		 jb	 SHORT $LN17@Reallocate

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0008c	8b 55 fc	 mov	 edx, DWORD PTR __Old_size$1$[ebp]
  0008f	83 c4 04	 add	 esp, 4
  00092	8b d8		 mov	 ebx, eax
  00094	eb 16		 jmp	 SHORT $LN16@Reallocate
$LN17@Reallocate:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  00096	85 c0		 test	 eax, eax
  00098	74 10		 je	 SHORT $LN18@Reallocate

; 85   :         return ::operator new(_Bytes);

  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 244  :         return _Traits::_Allocate(_Bytes);

  000a0	8b 55 fc	 mov	 edx, DWORD PTR __Old_size$1$[ebp]

; 85   :         return ::operator new(_Bytes);

  000a3	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000a6	8b d8		 mov	 ebx, eax
  000a8	eb 02		 jmp	 SHORT $LN16@Reallocate
$LN18@Reallocate:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000aa	33 db		 xor	 ebx, ebx
$LN16@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4559 :         _My_data._Mysize      = _New_size;

  000ac	8b 45 f8	 mov	 eax, DWORD PTR __New_size$1$[ebp]
  000af	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 4560 :         _My_data._Myres       = _New_capacity;
; 4561 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  000b2	0f be 45 18	 movsx	 eax, BYTE PTR _<_Args_2>$[ebp]
  000b6	89 45 18	 mov	 DWORD PTR tv476[ebp], eax
  000b9	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  000bc	2b d0		 sub	 edx, eax
  000be	89 77 14	 mov	 DWORD PTR [edi+20], esi

; 4562 :         if (_BUF_SIZE <= _Old_capacity) {

  000c1	50		 push	 eax
  000c2	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
  000c5	89 4d fc	 mov	 DWORD PTR tv474[ebp], ecx
  000c8	8d 34 03	 lea	 esi, DWORD PTR [ebx+eax]
  000cb	8b 4d 14	 mov	 ecx, DWORD PTR _<_Args_1>$[ebp]
  000ce	03 ce		 add	 ecx, esi
  000d0	89 75 f4	 mov	 DWORD PTR tv475[ebp], esi
  000d3	83 7d 08 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
  000d7	89 4d f8	 mov	 DWORD PTR tv473[ebp], ecx
  000da	72 60		 jb	 SHORT $LN3@Reallocate

; 4563 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  000dc	8b 37		 mov	 esi, DWORD PTR [edi]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000de	56		 push	 esi
  000df	53		 push	 ebx
  000e0	e8 00 00 00 00	 call	 _memcpy

; 446  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  000e5	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  000e8	ff 75 18	 push	 DWORD PTR tv476[ebp]
  000eb	ff 75 f4	 push	 DWORD PTR tv475[ebp]
  000ee	e8 00 00 00 00	 call	 _memset

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000f3	ff 75 fc	 push	 DWORD PTR tv474[ebp]

; 3408 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  000f6	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  000f9	03 c6		 add	 eax, esi

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000fb	50		 push	 eax
  000fc	ff 75 f8	 push	 DWORD PTR tv473[ebp]
  000ff	e8 00 00 00 00	 call	 _memcpy

; 4564 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4565 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  00104	8b 4d 08	 mov	 ecx, DWORD PTR __Old$1$[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00107	83 c4 24	 add	 esp, 36			; 00000024H

; 4564 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4565 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  0010a	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0010b	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00111	72 12		 jb	 SHORT $LN44@Reallocate

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00113	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  00116	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00119	2b f2		 sub	 esi, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0011b	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  0011e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00121	77 52		 ja	 SHORT $LN41@Reallocate

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00123	8b f2		 mov	 esi, edx
$LN44@Reallocate:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00125	51		 push	 ecx
  00126	56		 push	 esi
  00127	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0012c	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4572 :         return *this;

  0012f	89 1f		 mov	 DWORD PTR [edi], ebx
  00131	8b c7		 mov	 eax, edi
  00133	5f		 pop	 edi
  00134	5e		 pop	 esi
  00135	5b		 pop	 ebx

; 4573 :     }

  00136	8b e5		 mov	 esp, ebp
  00138	5d		 pop	 ebp
  00139	c2 14 00	 ret	 20			; 00000014H
$LN3@Reallocate:

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0013c	57		 push	 edi
  0013d	53		 push	 ebx
  0013e	e8 00 00 00 00	 call	 _memcpy

; 446  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  00143	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  00146	ff 75 18	 push	 DWORD PTR tv476[ebp]
  00149	56		 push	 esi
  0014a	e8 00 00 00 00	 call	 _memset

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0014f	ff 75 fc	 push	 DWORD PTR tv474[ebp]

; 3408 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  00152	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00155	03 c7		 add	 eax, edi

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00157	50		 push	 eax
  00158	ff 75 f8	 push	 DWORD PTR tv473[ebp]
  0015b	e8 00 00 00 00	 call	 _memcpy
  00160	83 c4 24	 add	 esp, 36			; 00000024H

; 4572 :         return *this;

  00163	89 1f		 mov	 DWORD PTR [edi], ebx
  00165	8b c7		 mov	 eax, edi
  00167	5f		 pop	 edi
  00168	5e		 pop	 esi
  00169	5b		 pop	 ebx

; 4573 :     }

  0016a	8b e5		 mov	 esp, ebp
  0016c	5d		 pop	 ebp
  0016d	c2 14 00	 ret	 20			; 00000014H
$LN59@Reallocate:

; 4544 :             _Xlen_string(); // result too long

  00170	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN41@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00175	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN57@Reallocate:
  0017a	cc		 int	 3
??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\streambuf
;	COMDAT ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputc, COMDAT
; _this$ = ecx

; 167  :     int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch) { // put a character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 259  :         return *_IPnext ? *_IPcount : 0;

  00003	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00006	83 38 00	 cmp	 DWORD PTR [eax], 0
  00009	74 22		 je	 SHORT $LN3@sputc
  0000b	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0000e	8b 02		 mov	 eax, DWORD PTR [edx]

; 168  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  00010	85 c0		 test	 eax, eax
  00012	7e 19		 jle	 SHORT $LN3@sputc

; 254  :         --*_IPcount;

  00014	48		 dec	 eax
  00015	89 02		 mov	 DWORD PTR [edx], eax

; 255  :         return (*_IPnext)++;

  00017	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  0001a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001c	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0001f	89 01		 mov	 DWORD PTR [ecx], eax

; 168  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  00021	8a 45 08	 mov	 al, BYTE PTR __Ch$[ebp]
  00024	88 02		 mov	 BYTE PTR [edx], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 466  :         return static_cast<unsigned char>(_Ch);

  00026	0f b6 c0	 movzx	 eax, al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\streambuf

; 169  :     }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
$LN3@sputc:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 466  :         return static_cast<unsigned char>(_Ch);

  0002d	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\streambuf

; 168  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  00031	8b 11		 mov	 edx, DWORD PTR [ecx]
  00033	89 45 08	 mov	 DWORD PTR __Ch$[ebp], eax

; 169  :     }

  00036	5d		 pop	 ebp

; 168  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  00037	ff 62 0c	 jmp	 DWORD PTR [edx+12]
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$numpunct@D@std@@MAEPAXI@Z PROC			; std::numpunct<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$numpunct@D@std@@MAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 161  :     virtual __CLR_OR_THIS_CALL ~numpunct() noexcept {

  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 227  :         _CSTD free(const_cast<char*>(_Grouping));

  00036	ff 76 08	 push	 DWORD PTR [esi+8]
  00039	e8 00 00 00 00	 call	 _free

; 228  :         _CSTD free(const_cast<_Elem*>(_Falsename));

  0003e	ff 76 10	 push	 DWORD PTR [esi+16]
  00041	e8 00 00 00 00	 call	 _free

; 229  :         _CSTD free(const_cast<_Elem*>(_Truename));

  00046	ff 76 14	 push	 DWORD PTR [esi+20]
  00049	e8 00 00 00 00	 call	 _free
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 163  :     }

  00051	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 155  :         virtual __CLR_OR_THIS_CALL ~facet() noexcept override {}

  00058	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  0005e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00065	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00069	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0006f	74 0b		 je	 SHORT $LN12@scalar
  00071	6a 18		 push	 24			; 00000018H
  00073	56		 push	 esi
  00074	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00079	83 c4 08	 add	 esp, 8
$LN12@scalar:
  0007c	8b c6		 mov	 eax, esi
  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5e		 pop	 esi
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$numpunct@D@std@@MAEPAXI@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
__unwindfunclet$??_G?$numpunct@D@std@@MAEPAXI@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1_Facet_base@std@@UAE@XZ ; std::_Facet_base::~_Facet_base
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??_G?$numpunct@D@std@@MAEPAXI@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$numpunct@D@std@@MAEPAXI@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$numpunct@D@std@@MAEPAXI@Z ENDP			; std::numpunct<char>::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_truename, COMDAT
; _this$ = ecx

; 221  :     virtual string_type __CLR_OR_THIS_CALL do_truename() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 222  :         return string_type(_Truename);

  0002c	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0002f	8b ca		 mov	 ecx, edx

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00031	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00034	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00037	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 4596 :         _My_data._Mysize = 0;

  0003d	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00044	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0004b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0004e	66 90		 npad	 2
$LL19@do_truenam:

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00050	8a 01		 mov	 al, BYTE PTR [ecx]
  00052	41		 inc	 ecx
  00053	84 c0		 test	 al, al
  00055	75 f9		 jne	 SHORT $LL19@do_truenam
  00057	2b cf		 sub	 ecx, edi

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00059	51		 push	 ecx
  0005a	52		 push	 edx
  0005b	8b ce		 mov	 ecx, esi
  0005d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 222  :         return string_type(_Truename);

  00062	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00069	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  00070	8b c6		 mov	 eax, esi

; 223  :     }

  00072	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00075	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007c	59		 pop	 ecx
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN4@do_truenam
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@do_truenam:
  00018	c3		 ret	 0
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
__ehhandler$?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ:
  0001e	90		 npad	 1
  0001f	90		 npad	 1
  00020	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00024	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00027	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_truename
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_falsename, COMDAT
; _this$ = ecx

; 217  :     virtual string_type __CLR_OR_THIS_CALL do_falsename() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 218  :         return string_type(_Falsename);

  0002c	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0002f	8b ca		 mov	 ecx, edx

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00031	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00034	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00037	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 4596 :         _My_data._Mysize = 0;

  0003d	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00044	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0004b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0004e	66 90		 npad	 2
$LL19@do_falsena:

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00050	8a 01		 mov	 al, BYTE PTR [ecx]
  00052	41		 inc	 ecx
  00053	84 c0		 test	 al, al
  00055	75 f9		 jne	 SHORT $LL19@do_falsena
  00057	2b cf		 sub	 ecx, edi

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00059	51		 push	 ecx
  0005a	52		 push	 edx
  0005b	8b ce		 mov	 ecx, esi
  0005d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 218  :         return string_type(_Falsename);

  00062	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00069	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  00070	8b c6		 mov	 eax, esi

; 219  :     }

  00072	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00075	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007c	59		 pop	 ecx
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN4@do_falsena
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@do_falsena:
  00018	c3		 ret	 0
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
__ehhandler$?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ:
  0001e	90		 npad	 1
  0001f	90		 npad	 1
  00020	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00024	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00027	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_falsename
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_grouping, COMDAT
; _this$ = ecx

; 213  :     virtual string __CLR_OR_THIS_CALL do_grouping() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 214  :         return string(_Grouping);

  0002c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0002f	8b ca		 mov	 ecx, edx

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00031	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00034	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00037	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 4596 :         _My_data._Mysize = 0;

  0003d	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00044	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0004b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0004e	66 90		 npad	 2
$LL19@do_groupin:

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00050	8a 01		 mov	 al, BYTE PTR [ecx]
  00052	41		 inc	 ecx
  00053	84 c0		 test	 al, al
  00055	75 f9		 jne	 SHORT $LL19@do_groupin
  00057	2b cf		 sub	 ecx, edi

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00059	51		 push	 ecx
  0005a	52		 push	 edx
  0005b	8b ce		 mov	 ecx, esi
  0005d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 214  :         return string(_Grouping);

  00062	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00069	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  00070	8b c6		 mov	 eax, esi

; 215  :     }

  00072	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00075	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007c	59		 pop	 ecx
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN4@do_groupin
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@do_groupin:
  00018	c3		 ret	 0
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
__ehhandler$?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ:
  0001e	90		 npad	 1
  0001f	90		 npad	 1
  00020	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00024	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00027	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_grouping
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_thousands_sep, COMDAT
; _this$ = ecx

; 210  :         return _Kseparator;

  00000	8a 41 0d	 mov	 al, BYTE PTR [ecx+13]

; 211  :     }

  00003	c3		 ret	 0
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_thousands_sep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?do_decimal_point@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
?do_decimal_point@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_decimal_point, COMDAT
; _this$ = ecx

; 206  :         return _Dp;

  00000	8a 41 0c	 mov	 al, BYTE PTR [ecx+12]

; 207  :     }

  00003	c3		 ret	 0
?do_decimal_point@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_decimal_point
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ??1?$numpunct@D@std@@MAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$numpunct@D@std@@MAE@XZ PROC			; std::numpunct<char>::~numpunct<char>, COMDAT
; _this$ = ecx

; 161  :     virtual __CLR_OR_THIS_CALL ~numpunct() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$numpunct@D@std@@MAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 227  :         _CSTD free(const_cast<char*>(_Grouping));

  00036	ff 76 08	 push	 DWORD PTR [esi+8]
  00039	e8 00 00 00 00	 call	 _free

; 228  :         _CSTD free(const_cast<_Elem*>(_Falsename));

  0003e	ff 76 10	 push	 DWORD PTR [esi+16]
  00041	e8 00 00 00 00	 call	 _free

; 229  :         _CSTD free(const_cast<_Elem*>(_Truename));

  00046	ff 76 14	 push	 DWORD PTR [esi+20]
  00049	e8 00 00 00 00	 call	 _free
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 163  :     }

  00051	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 155  :         virtual __CLR_OR_THIS_CALL ~facet() noexcept override {}

  00058	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  0005e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00065	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 163  :     }

  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5e		 pop	 esi
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$numpunct@D@std@@MAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
__unwindfunclet$??1?$numpunct@D@std@@MAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1_Facet_base@std@@UAE@XZ ; std::_Facet_base::~_Facet_base
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??1?$numpunct@D@std@@MAE@XZ:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$numpunct@D@std@@MAE@XZ
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$numpunct@D@std@@MAE@XZ ENDP			; std::numpunct<char>::~numpunct<char>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -208						; size = 44
$T3 = -164						; size = 44
$T4 = -120						; size = 52
$T5 = -68						; size = 44
__Cvt$6 = -68						; size = 44
$T7 = -24						; size = 4
$T8 = -20						; size = 4
__Ploc$GSCopy$1$ = -16					; size = 4
__Guard$9 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::numpunct<char>::_Getcat, COMDAT

; 152  :     static size_t _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c5		 xor	 eax, ebp
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 7d 08	 mov	 edi, DWORD PTR __Ppf$[ebp]
  0002e	33 db		 xor	 ebx, ebx
  00030	8b 45 0c	 mov	 eax, DWORD PTR __Ploc$[ebp]
  00033	89 45 f0	 mov	 DWORD PTR __Ploc$GSCopy$1$[ebp], eax
  00036	89 5d ec	 mov	 DWORD PTR $T8[ebp], ebx

; 153  :         // return locale category mask and construct standard facet
; 154  :         if (_Ppf && !*_Ppf) {

  00039	85 ff		 test	 edi, edi
  0003b	0f 84 3f 01 00
	00		 je	 $LN47@Getcat
  00041	39 1f		 cmp	 DWORD PTR [edi], ebx
  00043	0f 85 37 01 00
	00		 jne	 $LN47@Getcat

; 155  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->c_str()), 0, true);

  00049	6a 18		 push	 24			; 00000018H
  0004b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00050	8b f0		 mov	 esi, eax
  00052	83 c4 04	 add	 esp, 4
  00055	89 75 e8	 mov	 DWORD PTR $T7[ebp], esi
  00058	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0005b	85 f6		 test	 esi, esi
  0005d	0f 84 f8 00 00
	00		 je	 $LN4@Getcat
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 370  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  00063	8b 4d f0	 mov	 ecx, DWORD PTR __Ploc$GSCopy$1$[ebp]
  00066	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00069	85 c9		 test	 ecx, ecx
  0006b	74 0c		 je	 SHORT $LN12@Getcat
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocinfo

; 109  :         return _Myptr ? _Myptr : &_Nul;

  0006d	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00070	85 c0		 test	 eax, eax
  00072	75 0a		 jne	 SHORT $LN13@Getcat
  00074	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 370  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  00077	eb 05		 jmp	 SHORT $LN13@Getcat
$LN12@Getcat:
  00079	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@@
$LN13@Getcat:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 155  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->c_str()), 0, true);

  0007e	50		 push	 eax
  0007f	8d 4d 88	 lea	 ecx, DWORD PTR $T4[ebp]
  00082	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00087	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0008b	bb 01 00 00 00	 mov	 ebx, 1
  00090	89 5d ec	 mov	 DWORD PTR $T8[ebp], ebx
  00093	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 153  :         {}

  00099	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  000a0	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@

; 152  :             : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) // non-atomic initialization

  000a6	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 148  :     numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false) : locale::facet(_Refs) {

  000ad	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  000b4	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocinfo

; 207  :         return localeconv();

  000ba	e8 00 00 00 00	 call	 _localeconv

; 203  :         return ::_Getcvt();

  000bf	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 __Getcvt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 186  :         _Grouping  = nullptr;

  000cb	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 187  :         _Falsename = nullptr;

  000d2	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 188  :         _Truename  = nullptr;

  000d9	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 189  : 
; 190  :         _Tidy_guard<numpunct> _Guard{this};

  000e0	89 75 f0	 mov	 DWORD PTR __Guard$9[ebp], esi
  000e3	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocinfo

; 203  :         return ::_Getcvt();

  000e7	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  000ed	50		 push	 eax
  000ee	e8 00 00 00 00	 call	 __Getcvt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 191  :         _Grouping      = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char*>(nullptr), _Lobj._Getcvt());

  000f3	8d 45 bc	 lea	 eax, DWORD PTR $T5[ebp]
  000f6	50		 push	 eax
  000f7	6a 00		 push	 0
  000f9	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  000fe	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  00103	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 192  :         _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);

  00106	8d 45 bc	 lea	 eax, DWORD PTR __Cvt$6[ebp]
  00109	50		 push	 eax
  0010a	6a 00		 push	 0
  0010c	68 00 00 00 00	 push	 OFFSET ??_C@_05LAPONLG@false@
  00111	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  00116	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 193  :         _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);

  00119	8d 45 bc	 lea	 eax, DWORD PTR __Cvt$6[ebp]
  0011c	50		 push	 eax
  0011d	6a 00		 push	 0
  0011f	68 00 00 00 00	 push	 OFFSET ??_C@_04LOAJBDKD@true@
  00124	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  00129	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 194  :         _Guard._Target = nullptr;
; 195  : 
; 196  :         if (_Isdef) { // apply defaults for required facets
; 197  :             // _Grouping = _Maklocstr("", static_cast<char *>(nullptr), _Cvt);
; 198  :             _Dp         = _Maklocchr('.', static_cast<_Elem*>(nullptr), _Cvt);

  0012c	8d 45 bc	 lea	 eax, DWORD PTR __Cvt$6[ebp]
  0012f	50		 push	 eax
  00130	6a 00		 push	 0
  00132	6a 2e		 push	 46			; 0000002eH
  00134	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR __Guard$9[ebp], 0
  0013b	e8 00 00 00 00	 call	 ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ; std::_Maklocchr<char>
  00140	88 46 0c	 mov	 BYTE PTR [esi+12], al

; 199  :             _Kseparator = _Maklocchr(',', static_cast<_Elem*>(nullptr), _Cvt);

  00143	8d 45 bc	 lea	 eax, DWORD PTR __Cvt$6[ebp]
  00146	50		 push	 eax
  00147	6a 00		 push	 0
  00149	6a 2c		 push	 44			; 0000002cH
  0014b	e8 00 00 00 00	 call	 ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ; std::_Maklocchr<char>
  00150	83 c4 44	 add	 esp, 68			; 00000044H
  00153	88 46 0d	 mov	 BYTE PTR [esi+13], al

; 150  :     }

  00156	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl

; 155  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->c_str()), 0, true);

  00159	eb 02		 jmp	 SHORT $LN5@Getcat
$LN4@Getcat:
  0015b	33 f6		 xor	 esi, esi
$LN5@Getcat:
  0015d	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
  00164	89 37		 mov	 DWORD PTR [edi], esi
  00166	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0016d	f6 c3 01	 test	 bl, 1
  00170	74 0e		 je	 SHORT $LN47@Getcat
  00172	83 e3 fe	 and	 ebx, -2			; fffffffeH
  00175	8d 4d 88	 lea	 ecx, DWORD PTR $T4[ebp]
  00178	89 5d ec	 mov	 DWORD PTR $T8[ebp], ebx
  0017b	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN47@Getcat:

; 156  :         }
; 157  :         return _X_NUMERIC;
; 158  :     }

  00180	b8 04 00 00 00	 mov	 eax, 4
  00185	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00188	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0018f	59		 pop	 ecx
  00190	5f		 pop	 edi
  00191	5e		 pop	 esi
  00192	5b		 pop	 ebx
  00193	8b e5		 mov	 esp, ebp
  00195	5d		 pop	 ebp
  00196	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	6a 18		 push	 24			; 00000018H
  00002	8b 45 e8	 mov	 eax, DWORD PTR $T7[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1:
  0000f	8b 45 ec	 mov	 eax, DWORD PTR $T8[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	0f 84 0c 00 00
	00		 je	 $LN8@Getcat
  0001b	83 65 ec fe	 and	 DWORD PTR $T8[ebp], -2	; fffffffeH
  0001f	8d 4d 88	 lea	 ecx, DWORD PTR $T4[ebp]
  00022	e9 00 00 00 00	 jmp	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN8@Getcat:
  00027	c3		 ret	 0
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$3:
  00028	8b 4d e8	 mov	 ecx, DWORD PTR $T7[ebp]
  0002b	e9 00 00 00 00	 jmp	 ??1_Facet_base@std@@UAE@XZ ; std::_Facet_base::~_Facet_base
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$2:
  00030	8b 4d e8	 mov	 ecx, DWORD PTR $T7[ebp]
  00033	e9 00 00 00 00	 jmp	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$4:
  00038	8d 4d f0	 lea	 ecx, DWORD PTR __Guard$9[ebp]
  0003b	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >
  00040	cc		 int	 3
  00041	cc		 int	 3
  00042	cc		 int	 3
  00043	cc		 int	 3
  00044	cc		 int	 3
__ehhandler$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  00045	90		 npad	 1
  00046	90		 npad	 1
  00047	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0004b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0004e	8b 8a 2c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-212]
  00054	33 c8		 xor	 ecx, eax
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00060	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::numpunct<char>::_Getcat
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::grouping, COMDAT
; _this$ = ecx

; 126  :     string grouping() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 127  :         return do_grouping();

  0002a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002c	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  0002f	ff 52 14	 call	 DWORD PTR [edx+20]
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00039	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  00040	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 128  :     }

  00043	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00046	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004d	59		 pop	 ecx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN4@grouping
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@grouping:
  00018	c3		 ret	 0
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
__ehhandler$?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ:
  0001e	90		 npad	 1
  0001f	90		 npad	 1
  00020	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00024	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00027	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::grouping
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
__Lock$2 = -24						; size = 4
__Lock$3 = -20						; size = 4
__Psave$4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Psave_guard$5 = 8					; size = 4
__Loc$ = 8						; size = 4
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::numpunct<char> >, COMDAT

; 428  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 429  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

  00028	6a 00		 push	 0
  0002a	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 105  :             if (_Id == 0) { // still zero, allocate stamp

  00039	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id

; 430  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

  0003f	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
  00045	89 5d f0	 mov	 DWORD PTR __Psave$4[ebp], ebx

; 105  :             if (_Id == 0) { // still zero, allocate stamp

  00048	85 ff		 test	 edi, edi
  0004a	75 37		 jne	 SHORT $LN11@use_facet

; 106  :                 _BEGIN_LOCK(_LOCK_LOCALE)

  0004c	57		 push	 edi
  0004d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00050	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00055	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 107  :                 if (_Id == 0) {

  00059	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, edi ; std::numpunct<char>::id
  0005f	75 10		 jne	 SHORT $LN12@use_facet

; 108  :                     _Id = static_cast<size_t>(++_Id_cnt);

  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00066	40		 inc	 eax
  00067	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  0006c	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, eax ; std::numpunct<char>::id
$LN12@use_facet:

; 109  :                 }
; 110  :                 _END_LOCK()

  00071	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00075	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00078	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0007d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
$LN11@use_facet:

; 374  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  00083	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00086	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00089	3b 79 0c	 cmp	 edi, DWORD PTR [ecx+12]
  0008c	73 0c		 jae	 SHORT $LN20@use_facet
  0008e	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00091	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]

; 375  :         if (_Facptr || !_Ptr->_Xparent) {

  00094	85 f6		 test	 esi, esi
  00096	75 65		 jne	 SHORT $LN35@use_facet
  00098	eb 02		 jmp	 SHORT $LN37@use_facet
$LN20@use_facet:

; 111  :             }
; 112  :             return _Id;
; 113  :         }
; 114  : 
; 115  :     private:
; 116  :         size_t _Id; // the identifier stamp
; 117  : 
; 118  :         __PURE_APPDOMAIN_GLOBAL static int _Id_cnt;
; 119  :     };
; 120  : 
; 121  :     class _Locimp;
; 122  : 
; 123  :     // CLASS facet
; 124  :     class _CRTIMP2_PURE_IMPORT facet : public _Facet_base, public _Crt_new_delete {
; 125  :         // base class for all locale facets, performs reference counting
; 126  :     private:
; 127  :         friend struct _Facet_guard;
; 128  : 
; 129  :     public:
; 130  :         static size_t __CLRCALL_OR_CDECL _Getcat(const facet** = nullptr, const locale* = nullptr) {
; 131  :             // get category value, or -1 if no corresponding C category
; 132  :             return static_cast<size_t>(-1);
; 133  :         }
; 134  : 
; 135  :         virtual void __CLR_OR_THIS_CALL _Incref() noexcept override { // increment use count
; 136  :             _MT_INCR(_Myrefs);
; 137  :         }
; 138  : 
; 139  :         virtual _Facet_base* __CLR_OR_THIS_CALL _Decref() noexcept override { // decrement use count
; 140  :             if (_MT_DECR(_Myrefs) == 0) {
; 141  :                 return this;
; 142  :             }
; 143  : 
; 144  :             return nullptr;
; 145  :         }
; 146  : 
; 147  :     private:
; 148  :         _Atomic_counter_t _Myrefs; // the reference count
; 149  : 
; 150  :     protected:
; 151  :         explicit __CLR_OR_THIS_CALL facet(size_t _Initrefs = 0)
; 152  :             : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) // non-atomic initialization
; 153  :         {}
; 154  : 
; 155  :         virtual __CLR_OR_THIS_CALL ~facet() noexcept override {}
; 156  : 
; 157  :     public:
; 158  :         __CLR_OR_THIS_CALL facet(const facet&) = delete;
; 159  :         facet& __CLR_OR_THIS_CALL operator=(const facet&) = delete;
; 160  :     };
; 161  : 
; 162  :     struct _NODISCARD _Facet_guard {
; 163  :         facet* _Target;
; 164  :         ~_Facet_guard() {
; 165  :             if (_Target) {
; 166  :                 delete _Target->_Decref();
; 167  :             }
; 168  :         }
; 169  :     };
; 170  : 
; 171  :     // CLASS _Locimp
; 172  :     class _CRTIMP2_PURE_IMPORT _Locimp : public facet { // reference-counted actual implementation of a locale
; 173  :     protected:
; 174  :         __CLR_OR_THIS_CALL ~_Locimp() noexcept {
; 175  :             _Locimp_dtor(this);
; 176  :         }
; 177  : 
; 178  :     private:
; 179  :         static _Locimp* __CLRCALL_PURE_OR_CDECL _New_Locimp(bool _Transparent = false);
; 180  :         static _Locimp* __CLRCALL_PURE_OR_CDECL _New_Locimp(const _Locimp& _Right);
; 181  : 
; 182  :         static void __CLRCALL_PURE_OR_CDECL _Locimp_dtor(_Locimp*);
; 183  :         static void __CLRCALL_PURE_OR_CDECL _Locimp_Addfac(_Locimp*, facet*, size_t); // add a facet
; 184  :         static void __CLRCALL_PURE_OR_CDECL _Locimp_ctor(_Locimp*, const _Locimp&);
; 185  : 
; 186  :         friend locale;
; 187  : 
; 188  :         __CLR_OR_THIS_CALL _Locimp(bool _Transparent)
; 189  :             : locale::facet(1), _Facetvec(nullptr), _Facetcount(0), _Catmask(none), _Xparent(_Transparent), _Name("*") {
; 190  :         }
; 191  : 
; 192  :         __CLR_OR_THIS_CALL _Locimp(const _Locimp& _Right)
; 193  :             : locale::facet(1), _Facetvec(nullptr), _Facetcount(_Right._Facetcount), _Catmask(_Right._Catmask),
; 194  :               _Xparent(_Right._Xparent), _Name(_Right._Name.c_str()) {
; 195  :             _Locimp_ctor(this, _Right);
; 196  :         }
; 197  : 
; 198  :         void __CLR_OR_THIS_CALL _Addfac(facet* _Pfacet, size_t _Id) { // add a facet
; 199  :             _Locimp_Addfac(this, _Pfacet, _Id);
; 200  :         }
; 201  : 
; 202  :         static _Locimp* __CLRCALL_OR_CDECL _Makeloc(
; 203  :             const _Locinfo&, category, _Locimp*, const locale*); // make essential facets
; 204  : 
; 205  :         static void __CLRCALL_OR_CDECL _Makewloc(
; 206  :             const _Locinfo&, category, _Locimp*, const locale*); // make wchar_t facets
; 207  : 
; 208  : #ifdef _NATIVE_WCHAR_T_DEFINED
; 209  :         static void __CLRCALL_OR_CDECL _Makeushloc(
; 210  :             const _Locinfo&, category, _Locimp*, const locale*); // make ushort facets
; 211  : #endif // _NATIVE_WCHAR_T_DEFINED
; 212  : 
; 213  :         static void __CLRCALL_OR_CDECL _Makexloc(
; 214  :             const _Locinfo&, category, _Locimp*, const locale*); // make remaining facets
; 215  : 
; 216  :         facet** _Facetvec; // pointer to vector of facets
; 217  :         size_t _Facetcount; // size of vector of facets
; 218  :         category _Catmask; // mask describing implemented categories
; 219  :         bool _Xparent; // true if locale is transparent
; 220  :         _Yarn<char> _Name; // locale name, or "*" if not known
; 221  : 
; 222  :         __PURE_APPDOMAIN_GLOBAL static _Locimp* _Clocptr;
; 223  : 
; 224  :     public:
; 225  :         _Locimp& __CLR_OR_THIS_CALL operator=(const _Locimp&) = delete;
; 226  :     };
; 227  : 
; 228  :     template <class _Elem, class _Traits, class _Alloc>
; 229  :     bool operator()(
; 230  :         const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) const {
; 231  :         // compare _Left and _Right strings using collate facet in locale
; 232  :         const auto& _Coll_fac = _STD use_facet<_STD collate<_Elem>>(*this);
; 233  : 
; 234  :         const _Elem* const _Left_data  = _Left.data();
; 235  :         const _Elem* const _Right_data = _Right.data();
; 236  :         return _Coll_fac.compare(_Left_data, _Left_data + _Left.size(), _Right_data, _Right_data + _Right.size()) < 0;
; 237  :     }
; 238  : 
; 239  :     template <class _Facet>
; 240  :     locale combine(const locale& _Loc) const { // combine two locales
; 241  :         _Facet* _Facptr;
; 242  : 
; 243  :         _TRY_BEGIN
; 244  :         _Facptr = const_cast<_Facet*>(_STD addressof(_STD use_facet<_Facet>(_Loc)));
; 245  :         _CATCH_ALL
; 246  :         _Xruntime_error("locale::combine facet missing");
; 247  :         _CATCH_END
; 248  : 
; 249  :         _Locimp* _Newimp = _Locimp::_New_Locimp(*_Ptr);
; 250  :         _Newimp->_Addfac(_Facptr, _Facet::id);
; 251  :         _Newimp->_Catmask = none;
; 252  :         _Newimp->_Name    = "*";
; 253  :         return locale(_Newimp);
; 254  :     }
; 255  : 
; 256  :     template <class _Facet>
; 257  :     locale(const locale& _Loc, const _Facet* _Facptr) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
; 258  :         if (_Facptr) { // replace facet
; 259  :             _Ptr->_Addfac(const_cast<_Facet*>(_Facptr), _Facet::id);
; 260  :             _Ptr->_Catmask = none;
; 261  :             _Ptr->_Name    = "*";
; 262  :         }
; 263  :     }
; 264  : 
; 265  :     locale(_Uninitialized) {} // defer construction
; 266  : 
; 267  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {
; 268  :         _Ptr->_Incref();
; 269  :     }
; 270  : 
; 271  :     locale() noexcept : _Ptr(_Init(true)) {}
; 272  : 
; 273  : #if !defined(MRTDLL) || !defined(_CRTBLD)
; 274  :     locale(const locale& _Loc, const locale& _Other, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
; 275  :         // construct a locale by copying named facets
; 276  :         if (_Cat != none) { // worth adding, do it
; 277  :             _Facet_guard _Guard{_Ptr};
; 278  :             _BEGIN_LOCINFO(_Lobj)
; 279  :             _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, &_Other);
; 280  :             _Lobj._Addcats(_Loc._Ptr->_Catmask, _Loc.name().c_str());
; 281  :             _Lobj._Addcats(_Other._Ptr->_Catmask, _Other.name().c_str());
; 282  :             _Ptr->_Catmask = _Loc._Ptr->_Catmask | _Other._Ptr->_Catmask;
; 283  :             _Ptr->_Name    = _Lobj._Getname();
; 284  :             _END_LOCINFO()
; 285  :             _Guard._Target = nullptr;
; 286  :         }
; 287  :     }
; 288  : 
; 289  : private:
; 290  :     void _Construct(const string& _Str, category _Cat) {
; 291  :         // construct a locale with named facets
; 292  :         bool _Bad = false;
; 293  :         _Init();
; 294  :         if (_Cat != none) { // worth adding, do it
; 295  :             _Facet_guard _Guard{_Ptr};
; 296  :             _BEGIN_LOCINFO(_Lobj(_Cat, _Str.c_str()))
; 297  :             if (_Badname(_Lobj)) {
; 298  :                 _Bad = true;
; 299  :             } else { // name okay, build the locale
; 300  :                 _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, nullptr);
; 301  :                 _Ptr->_Catmask = _Cat;
; 302  :                 _Ptr->_Name    = _Str.c_str();
; 303  :             }
; 304  :             _END_LOCINFO()
; 305  :             _Guard._Target = nullptr;
; 306  :         }
; 307  : 
; 308  :         if (_Bad) { // Don't throw within _BEGIN_LOCINFO if we can avoid it
; 309  :             delete _Ptr->_Decref();
; 310  :             _Xruntime_error("bad locale name");
; 311  :         }
; 312  :     }
; 313  : 
; 314  : public:
; 315  :     explicit locale(const char* _Locname, category _Cat = all) : _Ptr(_Locimp::_New_Locimp()) {
; 316  :         // construct a locale with named facets
; 317  :         // _Locname might have been returned from setlocale().
; 318  :         // Therefore, _Construct() takes const string&.
; 319  :         if (_Locname) {
; 320  :             _Construct(_Locname, _Cat);
; 321  :             return;
; 322  :         }
; 323  : 
; 324  :         _Xruntime_error("bad locale name");
; 325  :     }
; 326  : 
; 327  :     locale(const locale& _Loc, const char* _Locname, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
; 328  :         // construct a locale by copying, replacing named facets
; 329  :         // _Locname might have been returned from setlocale().
; 330  :         // Therefore, _Construct() takes const string&.
; 331  :         if (_Locname) {
; 332  :             _Construct(_Locname, _Cat);
; 333  :             return;
; 334  :         }
; 335  : 
; 336  :         _Xruntime_error("bad locale name");
; 337  :     }
; 338  : 
; 339  :     explicit locale(const string& _Str, category _Cat = all) : _Ptr(_Locimp::_New_Locimp()) {
; 340  :         // construct a locale with named facets
; 341  :         _Construct(_Str, _Cat);
; 342  :     }
; 343  : 
; 344  :     locale(const locale& _Loc, const string& _Str, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
; 345  :         // construct a locale by copying, replacing named facets
; 346  :         _Construct(_Str, _Cat);
; 347  :     }
; 348  : #endif // !MRTDLL || !_CRTBLD
; 349  : 
; 350  :     ~locale() noexcept {
; 351  :         if (_Ptr) {
; 352  :             delete _Ptr->_Decref();
; 353  :         }
; 354  :     }
; 355  : 
; 356  :     const locale& operator=(const locale& _Right) noexcept {
; 357  :         if (_Ptr != _Right._Ptr) { // different implementation, point at new one
; 358  :             delete _Ptr->_Decref();
; 359  :             _Ptr = _Right._Ptr;
; 360  :             _Ptr->_Incref();
; 361  :         }
; 362  :         return *this;
; 363  :     }
; 364  : 
; 365  :     string name() const {
; 366  :         return _Ptr ? _Ptr->_Name.c_str() : string();
; 367  :     }
; 368  : 
; 369  :     _Ret_z_ const char* c_str() const {
; 370  :         return _Ptr ? _Ptr->_Name.c_str() : "";
; 371  :     }
; 372  : 
; 373  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object
; 374  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  0009a	33 f6		 xor	 esi, esi
$LN37@use_facet:

; 375  :         if (_Facptr || !_Ptr->_Xparent) {

  0009c	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  000a0	74 10		 je	 SHORT $LN15@use_facet

; 376  :             return _Facptr; // found facet or not transparent
; 377  :         }
; 378  : 
; 379  :         // look in current locale
; 380  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

  000a2	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 381  :         if (_Id < _Ptr0->_Facetcount) {

  000a7	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  000aa	73 0a		 jae	 SHORT $LN38@use_facet

; 382  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

  000ac	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000af	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
$LN15@use_facet:

; 431  : 
; 432  :     const size_t _Id         = _Facet::id;
; 433  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);
; 434  : 
; 435  :     if (!_Pf) {

  000b2	85 f6		 test	 esi, esi
  000b4	75 47		 jne	 SHORT $LN35@use_facet
$LN38@use_facet:

; 436  :         if (_Psave) {

  000b6	85 db		 test	 ebx, ebx
  000b8	74 04		 je	 SHORT $LN3@use_facet

; 437  :             _Pf = _Psave; // lazy facet already allocated

  000ba	8b f3		 mov	 esi, ebx
  000bc	eb 3f		 jmp	 SHORT $LN35@use_facet
$LN3@use_facet:

; 438  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

  000be	ff 75 08	 push	 DWORD PTR __Loc$[ebp]
  000c1	8d 45 f0	 lea	 eax, DWORD PTR __Psave$4[ebp]
  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 ?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::numpunct<char>::_Getcat
  000ca	83 c4 08	 add	 esp, 8
  000cd	83 f8 ff	 cmp	 eax, -1
  000d0	74 4e		 je	 SHORT $LN43@use_facet
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1370 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  000d2	8b 75 f0	 mov	 esi, DWORD PTR __Psave$4[ebp]
  000d5	89 75 08	 mov	 DWORD PTR __Psave_guard$5[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 446  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

  000d8	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 447  : 
; 448  : #if defined(_M_CEE)
; 449  :             _Facet_Register_m(_Pfmod);
; 450  : #else // defined(_M_CEE)
; 451  :             _Facet_Register(_Pfmod);

  000dc	56		 push	 esi
  000dd	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register

; 452  : #endif // defined(_M_CEE)
; 453  : 
; 454  :             _Pfmod->_Incref();

  000e2	8b 06		 mov	 eax, DWORD PTR [esi]
  000e4	83 c4 04	 add	 esp, 4
  000e7	8b ce		 mov	 ecx, esi
  000e9	ff 50 04	 call	 DWORD PTR [eax+4]

; 455  :             _Facetptr<_Facet>::_Psave = _Psave;

  000ec	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::numpunct<char> >::_Psave
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

  000f2	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Psave_guard$5[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 459  :         }

  000f9	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
$LN35@use_facet:

; 460  :     }
; 461  : 
; 462  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

  000fd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00104	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00107	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0010c	8b c6		 mov	 eax, esi

; 463  :     _END_LOCK()
; 464  : } // end of use_facet body

  0010e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00111	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00118	59		 pop	 ecx
  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi
  0011b	5b		 pop	 ebx
  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c3		 ret	 0
$LN43@use_facet:

; 439  : #if _HAS_EXCEPTIONS
; 440  :             _Throw_bad_cast(); // lazy disallowed

  00120	e8 00 00 00 00	 call	 ?_Throw_bad_cast@std@@YAXXZ ; std::_Throw_bad_cast
$LN40@use_facet:
  00125	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$2:
  00008	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$1:
  00010	8d 4d 08	 lea	 ecx, DWORD PTR __Psave_guard$5[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
__ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z:
  0001d	90		 npad	 1
  0001e	90		 npad	 1
  0001f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00023	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00026	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::numpunct<char> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ??$_Float_put_desired_precision@N@std@@YAH_JH@Z
_TEXT	SEGMENT
__Precision$ = 8					; size = 8
__Float_flags$ = 16					; size = 4
??$_Float_put_desired_precision@N@std@@YAH_JH@Z PROC	; std::_Float_put_desired_precision<double>, COMDAT

; 1167 : int _Float_put_desired_precision(const streamsize _Precision, const ios_base::fmtflags _Float_flags) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1168 :     const bool _Is_hex = _Float_flags == (ios_base::fixed | ios_base::scientific);

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __Float_flags$[ebp]
  00006	81 f9 00 30 00
	00		 cmp	 ecx, 12288		; 00003000H

; 1169 :     if (_Is_hex) {

  0000c	75 07		 jne	 SHORT $LN2@Float_put_

; 1170 :         return _Hex_float_precision<_Ty>::value;

  0000e	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH

; 1185 :     }
; 1186 : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
$LN2@Float_put_:

; 1171 :     }
; 1172 : 
; 1173 :     if (_Precision > 0) {

  00015	8b 55 0c	 mov	 edx, DWORD PTR __Precision$[ebp+4]
  00018	8b 45 08	 mov	 eax, DWORD PTR __Precision$[ebp]
  0001b	85 d2		 test	 edx, edx
  0001d	7c 06		 jl	 SHORT $LN3@Float_put_
  0001f	7f 14		 jg	 SHORT $LN6@Float_put_
  00021	85 c0		 test	 eax, eax
  00023	75 10		 jne	 SHORT $LN6@Float_put_
$LN3@Float_put_:

; 1174 :         return static_cast<int>(_Precision);
; 1175 :     } else if (_Precision == 0) {

  00025	0b c2		 or	 eax, edx
  00027	75 07		 jne	 SHORT $LN5@Float_put_

; 1176 :         const bool _Is_default_float = _Float_flags == 0;

  00029	85 c9		 test	 ecx, ecx

; 1177 :         if (_Is_default_float) {

  0002b	0f 94 c0	 sete	 al

; 1185 :     }
; 1186 : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
$LN5@Float_put_:

; 1178 :             return 1;
; 1179 :         } else {
; 1180 :             return 0;
; 1181 :         }
; 1182 :     } else {
; 1183 :         constexpr int _Default_precision = 6;
; 1184 :         return _Default_precision;

  00030	b8 06 00 00 00	 mov	 eax, 6
$LN6@Float_put_:

; 1185 :     }
; 1186 : }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Float_put_desired_precision@N@std@@YAH_JH@Z ENDP	; std::_Float_put_desired_precision<double>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ??$_Float_put_desired_precision@O@std@@YAH_JH@Z
_TEXT	SEGMENT
__Precision$ = 8					; size = 8
__Float_flags$ = 16					; size = 4
??$_Float_put_desired_precision@O@std@@YAH_JH@Z PROC	; std::_Float_put_desired_precision<long double>, COMDAT

; 1167 : int _Float_put_desired_precision(const streamsize _Precision, const ios_base::fmtflags _Float_flags) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1168 :     const bool _Is_hex = _Float_flags == (ios_base::fixed | ios_base::scientific);

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __Float_flags$[ebp]
  00006	81 f9 00 30 00
	00		 cmp	 ecx, 12288		; 00003000H

; 1169 :     if (_Is_hex) {

  0000c	75 07		 jne	 SHORT $LN2@Float_put_

; 1170 :         return _Hex_float_precision<_Ty>::value;

  0000e	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH

; 1185 :     }
; 1186 : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
$LN2@Float_put_:

; 1171 :     }
; 1172 : 
; 1173 :     if (_Precision > 0) {

  00015	8b 55 0c	 mov	 edx, DWORD PTR __Precision$[ebp+4]
  00018	8b 45 08	 mov	 eax, DWORD PTR __Precision$[ebp]
  0001b	85 d2		 test	 edx, edx
  0001d	7c 06		 jl	 SHORT $LN3@Float_put_
  0001f	7f 14		 jg	 SHORT $LN6@Float_put_
  00021	85 c0		 test	 eax, eax
  00023	75 10		 jne	 SHORT $LN6@Float_put_
$LN3@Float_put_:

; 1174 :         return static_cast<int>(_Precision);
; 1175 :     } else if (_Precision == 0) {

  00025	0b c2		 or	 eax, edx
  00027	75 07		 jne	 SHORT $LN5@Float_put_

; 1176 :         const bool _Is_default_float = _Float_flags == 0;

  00029	85 c9		 test	 ecx, ecx

; 1177 :         if (_Is_default_float) {

  0002b	0f 94 c0	 sete	 al

; 1185 :     }
; 1186 : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
$LN5@Float_put_:

; 1178 :             return 1;
; 1179 :         } else {
; 1180 :             return 0;
; 1181 :         }
; 1182 :     } else {
; 1183 :         constexpr int _Default_precision = 6;
; 1184 :         return _Default_precision;

  00030	b8 06 00 00 00	 mov	 eax, 6
$LN6@Float_put_:

; 1185 :     }
; 1186 : }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Float_put_desired_precision@O@std@@YAH_JH@Z ENDP	; std::_Float_put_desired_precision<long double>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1207 :     virtual __CLR_OR_THIS_CALL ~num_put() noexcept {}

  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
  0002f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 155  :         virtual __CLR_OR_THIS_CALL ~facet() noexcept override {}

  00036	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  0003c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00043	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00047	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0004d	74 0b		 je	 SHORT $LN10@scalar
  0004f	6a 08		 push	 8
  00051	56		 push	 esi
  00052	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00057	83 c4 08	 add	 esp, 8
$LN10@scalar:
  0005a	8b c6		 mov	 eax, esi
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00066	59		 pop	 ecx
  00067	5e		 pop	 esi
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
__unwindfunclet$??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1_Facet_base@std@@UAE@XZ ; std::_Facet_base::~_Facet_base
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\iterator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\iterator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\iterator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ch$ = 24						; size = 1
__Count$ = 28						; size = 4
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep, COMDAT

; 1600 :     _OutIt __CLRCALL_OR_CDECL _Rep(_OutIt _Dest, _Elem _Ch, size_t _Count) const { // put _Count * _Ch to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1601 :         for (; 0 < _Count; --_Count, (void) ++_Dest) {

  00004	8b 75 14	 mov	 esi, DWORD PTR __Dest$[ebp+4]
  00007	57		 push	 edi
  00008	8b 7d 1c	 mov	 edi, DWORD PTR __Count$[ebp]
  0000b	85 ff		 test	 edi, edi
  0000d	74 4a		 je	 SHORT $LN3@Rep
  0000f	53		 push	 ebx
  00010	8a 5d 18	 mov	 bl, BYTE PTR __Ch$[ebp]
$LL4@Rep:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\iterator

; 528  :         if (!_Strbuf || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

  00013	85 f6		 test	 esi, esi
  00015	74 38		 je	 SHORT $LN8@Rep
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\streambuf

; 259  :         return *_IPnext ? *_IPcount : 0;

  00017	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0001a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001d	74 1d		 je	 SHORT $LN12@Rep
  0001f	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00022	8b 01		 mov	 eax, DWORD PTR [ecx]

; 168  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  00024	85 c0		 test	 eax, eax
  00026	7e 14		 jle	 SHORT $LN12@Rep

; 254  :         --*_IPcount;

  00028	48		 dec	 eax
  00029	89 01		 mov	 DWORD PTR [ecx], eax

; 255  :         return (*_IPnext)++;

  0002b	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  0002e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00030	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00033	89 01		 mov	 DWORD PTR [ecx], eax

; 168  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  00035	88 1a		 mov	 BYTE PTR [edx], bl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 466  :         return static_cast<unsigned char>(_Ch);

  00037	0f b6 c3	 movzx	 eax, bl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\streambuf

; 168  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  0003a	eb 0b		 jmp	 SHORT $LN13@Rep
$LN12@Rep:
  0003c	8b 16		 mov	 edx, DWORD PTR [esi]
  0003e	8b ce		 mov	 ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 466  :         return static_cast<unsigned char>(_Ch);

  00040	0f b6 c3	 movzx	 eax, bl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\streambuf

; 168  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  00043	50		 push	 eax
  00044	ff 52 0c	 call	 DWORD PTR [edx+12]
$LN13@Rep:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\iterator

; 528  :         if (!_Strbuf || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

  00047	8b 75 14	 mov	 esi, DWORD PTR __Dest$[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 470  :         return _Left == _Right;

  0004a	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\iterator

; 528  :         if (!_Strbuf || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

  0004d	75 04		 jne	 SHORT $LN2@Rep
$LN8@Rep:

; 529  :             _Failed = true;

  0004f	c6 45 10 01	 mov	 BYTE PTR __Dest$[ebp], 1
$LN2@Rep:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1601 :         for (; 0 < _Count; --_Count, (void) ++_Dest) {

  00053	83 ef 01	 sub	 edi, 1
  00056	75 bb		 jne	 SHORT $LL4@Rep
  00058	5b		 pop	 ebx
$LN3@Rep:

; 1602 :             *_Dest = _Ch;
; 1603 :         }
; 1604 : 
; 1605 :         return _Dest;

  00059	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005c	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005f	5f		 pop	 edi
  00060	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00063	89 08		 mov	 DWORD PTR [eax], ecx
  00065	5e		 pop	 esi

; 1606 :     }

  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\iterator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\iterator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\iterator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\iterator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ptr$ = 24						; size = 4
__Count$ = 28						; size = 4
__Ch$1$ = 31						; size = 1
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put, COMDAT

; 1592 :         _OutIt _Dest, const _Elem* _Ptr, size_t _Count) const { // put [_Ptr, _Ptr + _Count) to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1593 :         for (; 0 < _Count; --_Count, (void) ++_Dest, ++_Ptr) {

  00004	8b 75 14	 mov	 esi, DWORD PTR __Dest$[ebp+4]
  00007	57		 push	 edi
  00008	8b 7d 1c	 mov	 edi, DWORD PTR __Count$[ebp]
  0000b	85 ff		 test	 edi, edi
  0000d	74 53		 je	 SHORT $LN3@Put
  0000f	53		 push	 ebx
  00010	8b 5d 18	 mov	 ebx, DWORD PTR __Ptr$[ebp]
$LL4@Put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\iterator

; 528  :         if (!_Strbuf || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

  00013	85 f6		 test	 esi, esi
  00015	74 40		 je	 SHORT $LN8@Put
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\streambuf

; 259  :         return *_IPnext ? *_IPcount : 0;

  00017	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\iterator

; 528  :         if (!_Strbuf || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

  0001a	8a 0b		 mov	 cl, BYTE PTR [ebx]
  0001c	88 4d 1f	 mov	 BYTE PTR __Ch$1$[ebp], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\streambuf

; 259  :         return *_IPnext ? *_IPcount : 0;

  0001f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00022	74 20		 je	 SHORT $LN12@Put
  00024	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00027	8b 02		 mov	 eax, DWORD PTR [edx]

; 168  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  00029	85 c0		 test	 eax, eax
  0002b	7e 17		 jle	 SHORT $LN12@Put

; 254  :         --*_IPcount;

  0002d	48		 dec	 eax
  0002e	89 02		 mov	 DWORD PTR [edx], eax

; 255  :         return (*_IPnext)++;

  00030	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00038	89 01		 mov	 DWORD PTR [ecx], eax

; 168  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  0003a	8a 45 1f	 mov	 al, BYTE PTR __Ch$1$[ebp]
  0003d	88 02		 mov	 BYTE PTR [edx], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 466  :         return static_cast<unsigned char>(_Ch);

  0003f	0f b6 c0	 movzx	 eax, al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\streambuf

; 168  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  00042	eb 0b		 jmp	 SHORT $LN13@Put
$LN12@Put:
  00044	8b 16		 mov	 edx, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 466  :         return static_cast<unsigned char>(_Ch);

  00046	0f b6 c1	 movzx	 eax, cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\streambuf

; 168  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  00049	8b ce		 mov	 ecx, esi
  0004b	50		 push	 eax
  0004c	ff 52 0c	 call	 DWORD PTR [edx+12]
$LN13@Put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\iterator

; 528  :         if (!_Strbuf || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

  0004f	8b 75 14	 mov	 esi, DWORD PTR __Dest$[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 470  :         return _Left == _Right;

  00052	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\iterator

; 528  :         if (!_Strbuf || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

  00055	75 04		 jne	 SHORT $LN2@Put
$LN8@Put:

; 529  :             _Failed = true;

  00057	c6 45 10 01	 mov	 BYTE PTR __Dest$[ebp], 1
$LN2@Put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1593 :         for (; 0 < _Count; --_Count, (void) ++_Dest, ++_Ptr) {

  0005b	43		 inc	 ebx
  0005c	83 ef 01	 sub	 edi, 1
  0005f	75 b2		 jne	 SHORT $LL4@Put
  00061	5b		 pop	 ebx
$LN3@Put:

; 1594 :             *_Dest = *_Ptr;
; 1595 :         }
; 1596 : 
; 1597 :         return _Dest;

  00062	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00065	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00068	5f		 pop	 edi
  00069	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0006c	89 08		 mov	 DWORD PTR [eax], ecx
  0006e	5e		 pop	 esi

; 1598 :     }

  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$1$ = -104				; size = 4
$T2 = -100						; size = 4
$T3 = -96						; size = 8
__Buf$GSCopy$1$ = -92					; size = 4
$T4 = -92						; size = 1
$T5 = -88						; size = 8
$T6 = -88						; size = 8
$T7 = -88						; size = 8
$T8 = -88						; size = 8
$T9 = -88						; size = 8
$T10 = -88						; size = 8
$T11 = -88						; size = 8
__Iosbase$GSCopy$1$ = -80				; size = 4
$T12 = -76						; size = 4
__Count$GSCopy$2$ = -72					; size = 4
__Prefix$1$ = -72					; size = 4
__Punct_fac$1$ = -68					; size = 4
__Ctype_fac$1$ = -68					; size = 4
__Kseparator$13 = -68					; size = 1
__Grouping$ = -64					; size = 24
__Groupstring$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Buf$ = 32						; size = 4
__Count$ = 36						; size = 4
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput, COMDAT

; 1538 :         size_t _Count) const { // put formatted integer to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 7d 24	 mov	 edi, DWORD PTR __Count$[ebp]
  0002e	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00031	8b 55 18	 mov	 edx, DWORD PTR __Iosbase$[ebp]
  00034	8b 4d 20	 mov	 ecx, DWORD PTR __Buf$[ebp]
  00037	89 45 98	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  0003a	89 55 b0	 mov	 DWORD PTR __Iosbase$GSCopy$1$[ebp], edx
  0003d	89 4d a4	 mov	 DWORD PTR __Buf$GSCopy$1$[ebp], ecx
  00040	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR $T12[ebp], 0

; 1539 :         auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));

  00047	85 ff		 test	 edi, edi
  00049	74 11		 je	 SHORT $LN17@Iput
  0004b	8a 01		 mov	 al, BYTE PTR [ecx]
  0004d	3c 2b		 cmp	 al, 43			; 0000002bH
  0004f	74 04		 je	 SHORT $LN16@Iput
  00051	3c 2d		 cmp	 al, 45			; 0000002dH
  00053	75 07		 jne	 SHORT $LN17@Iput
$LN16@Iput:
  00055	be 01 00 00 00	 mov	 esi, 1
  0005a	eb 02		 jmp	 SHORT $LN127@Iput
$LN17@Iput:
  0005c	33 f6		 xor	 esi, esi
$LN127@Iput:

; 1540 :         if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex && _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1541 :             && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {

  0005e	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00061	25 00 0e 00 00	 and	 eax, 3584		; 00000e00H
  00066	89 75 b8	 mov	 DWORD PTR __Prefix$1$[ebp], esi
  00069	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  0006e	75 20		 jne	 SHORT $LN4@Iput
  00070	8d 46 02	 lea	 eax, DWORD PTR [esi+2]
  00073	3b c7		 cmp	 eax, edi
  00075	77 19		 ja	 SHORT $LN4@Iput
  00077	80 3c 31 30	 cmp	 BYTE PTR [ecx+esi], 48	; 00000030H
  0007b	75 13		 jne	 SHORT $LN4@Iput
  0007d	8a 4c 31 01	 mov	 cl, BYTE PTR [ecx+esi+1]
  00081	80 f9 78	 cmp	 cl, 120			; 00000078H
  00084	74 05		 je	 SHORT $LN5@Iput
  00086	80 f9 58	 cmp	 cl, 88			; 00000058H
  00089	75 05		 jne	 SHORT $LN4@Iput
$LN5@Iput:

; 1542 :             _Prefix += 2;

  0008b	8b f0		 mov	 esi, eax
  0008d	89 75 b8	 mov	 DWORD PTR __Prefix$1$[ebp], esi
$LN4@Iput:

; 1545 :         const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

  00090	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 373  :         return *_Ploc;

  00097	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 267  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  0009a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009d	89 4d ac	 mov	 DWORD PTR $T11[ebp+4], ecx
  000a0	89 4d 9c	 mov	 DWORD PTR $T2[ebp], ecx

; 268  :         _Ptr->_Incref();

  000a3	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a5	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1545 :         const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

  000a8	8d 45 a8	 lea	 eax, DWORD PTR $T11[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 373  :         return *_Ploc;

  000ab	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR $T12[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1545 :         const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  000b8	bb 01 00 00 00	 mov	 ebx, 1
  000bd	89 45 bc	 mov	 DWORD PTR __Ctype_fac$1$[ebp], eax
  000c0	89 5d b4	 mov	 DWORD PTR $T12[ebp], ebx
  000c3	83 c4 04	 add	 esp, 4
  000c6	83 e3 fe	 and	 ebx, -2			; fffffffeH
  000c9	89 5d b4	 mov	 DWORD PTR $T12[ebp], ebx
  000cc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000d3	8b 4d 9c	 mov	 ecx, DWORD PTR $T2[ebp]
  000d6	85 c9		 test	 ecx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 351  :         if (_Ptr) {

  000d8	74 11		 je	 SHORT $LN32@Iput

; 352  :             delete _Ptr->_Decref();

  000da	8b 01		 mov	 eax, DWORD PTR [ecx]
  000dc	ff 50 08	 call	 DWORD PTR [eax+8]
  000df	8b c8		 mov	 ecx, eax
  000e1	85 c9		 test	 ecx, ecx
  000e3	74 06		 je	 SHORT $LN32@Iput
  000e5	8b 01		 mov	 eax, DWORD PTR [ecx]
  000e7	6a 01		 push	 1
  000e9	ff 10		 call	 DWORD PTR [eax]
$LN32@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1546 :         basic_string<_Elem> _Groupstring(_Count, _Elem(0)); // reserve space

  000eb	6a 00		 push	 0
  000ed	57		 push	 edi
  000ee	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  000f1	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000f6	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2296 :         value_type* _Result = _Bx._Buf;

  000fd	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]

; 2319 :         return _BUF_SIZE <= _Myres;

  00100	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1547 :         _Ctype_fac.widen(_Buf, _Buf + _Count, &_Groupstring[0]);

  00104	8b 4d a4	 mov	 ecx, DWORD PTR __Buf$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2297 :         if (_Large_string_engaged()) {

  00107	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 2694 :         return do_widen(_First, _Last, _Dest);

  0010b	8b 55 bc	 mov	 edx, DWORD PTR __Ctype_fac$1$[ebp]
  0010e	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1547 :         _Ctype_fac.widen(_Buf, _Buf + _Count, &_Groupstring[0]);

  0010f	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 2694 :         return do_widen(_First, _Last, _Dest);

  00112	50		 push	 eax
  00113	8b 12		 mov	 edx, DWORD PTR [edx]
  00115	51		 push	 ecx
  00116	8b 4d bc	 mov	 ecx, DWORD PTR __Ctype_fac$1$[ebp]
  00119	ff 52 1c	 call	 DWORD PTR [edx+28]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1549 :         const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

  0011c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 373  :         return *_Ploc;

  00120	8b 55 b0	 mov	 edx, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00123	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 267  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  00126	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00129	89 4d a4	 mov	 DWORD PTR $T3[ebp+4], ecx

; 268  :         _Ptr->_Incref();

  0012c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0012e	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1549 :         const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

  00131	8d 45 a0	 lea	 eax, DWORD PTR $T3[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 373  :         return *_Ploc;

  00134	83 cb 02	 or	 ebx, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1549 :         const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

  00137	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 373  :         return *_Ploc;

  00138	89 5d b4	 mov	 DWORD PTR $T12[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1549 :         const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

  0013b	e8 00 00 00 00	 call	 ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
  00140	83 e3 fd	 and	 ebx, -3			; fffffffdH
  00143	89 45 bc	 mov	 DWORD PTR __Punct_fac$1$[ebp], eax
  00146	83 c4 04	 add	 esp, 4
  00149	89 5d b4	 mov	 DWORD PTR $T12[ebp], ebx
  0014c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 351  :         if (_Ptr) {

  00150	8b 4d a4	 mov	 ecx, DWORD PTR $T3[ebp+4]
  00153	85 c9		 test	 ecx, ecx
  00155	74 14		 je	 SHORT $LN52@Iput

; 352  :             delete _Ptr->_Decref();

  00157	8b 01		 mov	 eax, DWORD PTR [ecx]
  00159	ff 50 08	 call	 DWORD PTR [eax+8]
  0015c	8b c8		 mov	 ecx, eax
  0015e	85 c9		 test	 ecx, ecx
  00160	74 06		 je	 SHORT $LN124@Iput
  00162	8b 01		 mov	 eax, DWORD PTR [ecx]
  00164	6a 01		 push	 1
  00166	ff 10		 call	 DWORD PTR [eax]
$LN124@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1550 :         const string _Grouping = _Punct_fac.grouping();

  00168	8b 45 bc	 mov	 eax, DWORD PTR __Punct_fac$1$[ebp]
$LN52@Iput:
  0016b	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  0016e	51		 push	 ecx
  0016f	8b c8		 mov	 ecx, eax
  00171	e8 00 00 00 00	 call	 ?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
  00176	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2305 :         const value_type* _Result = _Bx._Buf;

  0017a	8d 5d c0	 lea	 ebx, DWORD PTR __Grouping$[ebp]

; 2319 :         return _BUF_SIZE <= _Myres;

  0017d	83 7d d4 10	 cmp	 DWORD PTR __Grouping$[ebp+20], 16 ; 00000010H

; 2306 :         if (_Large_string_engaged()) {

  00181	0f 43 5d c0	 cmovae	 ebx, DWORD PTR __Grouping$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1552 :         if (*_Pg != CHAR_MAX && '\0' < *_Pg) { // grouping specified, add thousands separators

  00185	8a 03		 mov	 al, BYTE PTR [ebx]
  00187	3c 7f		 cmp	 al, 127			; 0000007fH
  00189	0f 84 b0 00 00
	00		 je	 $LN3@Iput
  0018f	84 c0		 test	 al, al
  00191	0f 8e a8 00 00
	00		 jle	 $LN3@Iput

; 123  :         return do_thousands_sep();

  00197	8b 4d bc	 mov	 ecx, DWORD PTR __Punct_fac$1$[ebp]
  0019a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0019c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0019f	ff d0		 call	 eax

; 1553 :             const _Elem _Kseparator = _Punct_fac.thousands_sep();

  001a1	88 45 bc	 mov	 BYTE PTR __Kseparator$13[ebp], al

; 1554 :             while (*_Pg != CHAR_MAX && '\0' < *_Pg && static_cast<size_t>(*_Pg) < _Count - _Prefix) {

  001a4	8a 03		 mov	 al, BYTE PTR [ebx]
  001a6	3c 7f		 cmp	 al, 127			; 0000007fH
  001a8	0f 84 91 00 00
	00		 je	 $LN3@Iput
  001ae	66 90		 npad	 2
$LL2@Iput:
  001b0	84 c0		 test	 al, al
  001b2	0f 8e 87 00 00
	00		 jle	 $LN3@Iput
  001b8	0f be c8	 movsx	 ecx, al
  001bb	8b c7		 mov	 eax, edi
  001bd	2b c6		 sub	 eax, esi
  001bf	3b c8		 cmp	 ecx, eax
  001c1	73 7c		 jae	 SHORT $LN3@Iput

; 1555 :                 // insert thousands separator
; 1556 :                 _Count -= *_Pg;

  001c3	2b f9		 sub	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2324 :         if (_Mysize < _Off) {

  001c5	8b 4d e8	 mov	 ecx, DWORD PTR __Groupstring$[ebp+16]
  001c8	3b cf		 cmp	 ecx, edi
  001ca	0f 82 dd 01 00
	00		 jb	 $LN119@Iput

; 3392 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  001d0	8b 55 ec	 mov	 edx, DWORD PTR __Groupstring$[ebp+20]
  001d3	8b c2		 mov	 eax, edx
  001d5	2b c1		 sub	 eax, ecx

; 3393 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  001d7	83 f8 01	 cmp	 eax, 1
  001da	72 38		 jb	 SHORT $LN68@Iput

; 3394 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  001dc	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 2319 :         return _BUF_SIZE <= _Myres;

  001df	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2296 :         value_type* _Result = _Bx._Buf;

  001e2	8d 75 d8	 lea	 esi, DWORD PTR __Groupstring$[ebp]

; 3394 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  001e5	89 45 e8	 mov	 DWORD PTR __Groupstring$[ebp+16], eax

; 2297 :         if (_Large_string_engaged()) {

  001e8	0f 43 75 d8	 cmovae	 esi, DWORD PTR __Groupstring$[ebp]

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  001ec	2b cf		 sub	 ecx, edi

; 3396 :             _Elem* const _Insert_at = _Old_ptr + _Off;

  001ee	03 f7		 add	 esi, edi

; 3397 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

  001f0	41		 inc	 ecx

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  001f1	51		 push	 ecx
  001f2	56		 push	 esi

; 3397 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

  001f3	8d 46 01	 lea	 eax, DWORD PTR [esi+1]

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  001f6	50		 push	 eax
  001f7	e8 00 00 00 00	 call	 _memmove

; 446  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  001fc	0f be 4d bc	 movsx	 ecx, BYTE PTR __Kseparator$13[ebp]

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00200	83 c4 0c	 add	 esp, 12			; 0000000cH

; 446  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  00203	0f b6 c1	 movzx	 eax, cl
  00206	66 c1 e1 08	 shl	 cx, 8
  0020a	66 0b c8	 or	 cx, ax
  0020d	88 0e		 mov	 BYTE PTR [esi], cl

; 3399 :             return *this;

  0020f	8b 75 b8	 mov	 esi, DWORD PTR __Prefix$1$[ebp]
  00212	eb 17		 jmp	 SHORT $LN67@Iput
$LN68@Iput:

; 3400 :         }
; 3401 : 
; 3402 :         return _Reallocate_grow_by(

  00214	ff 75 bc	 push	 DWORD PTR __Kseparator$13[ebp]
  00217	c6 45 a4 00	 mov	 BYTE PTR $T4[ebp], 0
  0021b	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  0021e	6a 01		 push	 1
  00220	57		 push	 edi
  00221	ff 75 a4	 push	 DWORD PTR $T4[ebp]
  00224	6a 01		 push	 1
  00226	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>
$LN67@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1558 :                 if ('\0' < _Pg[1]) {

  0022b	80 7b 01 00	 cmp	 BYTE PTR [ebx+1], 0
  0022f	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00232	0f 4f d8	 cmovg	 ebx, eax
  00235	8a 03		 mov	 al, BYTE PTR [ebx]
  00237	3c 7f		 cmp	 al, 127			; 0000007fH
  00239	0f 85 71 ff ff
	ff		 jne	 $LL2@Iput
$LN3@Iput:

; 1559 :                     ++_Pg; // not last group, advance
; 1560 :                 }
; 1561 :             }
; 1562 :         }
; 1563 : 
; 1564 :         _Count = _Groupstring.size();
; 1565 : 
; 1566 :         size_t _Fillcount;
; 1567 :         if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Count) {

  0023f	8b 45 b0	 mov	 eax, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00242	8b 4d e8	 mov	 ecx, DWORD PTR __Groupstring$[ebp+16]
  00245	89 4d b8	 mov	 DWORD PTR __Count$GSCopy$2$[ebp], ecx
  00248	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  0024c	8b 78 20	 mov	 edi, DWORD PTR [eax+32]
  0024f	7c 0e		 jl	 SHORT $LN10@Iput
  00251	7f 04		 jg	 SHORT $LN123@Iput
  00253	85 ff		 test	 edi, edi
  00255	74 08		 je	 SHORT $LN10@Iput
$LN123@Iput:
  00257	3b f9		 cmp	 edi, ecx
  00259	76 04		 jbe	 SHORT $LN10@Iput

; 1569 :         } else {
; 1570 :             _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Count;

  0025b	2b f9		 sub	 edi, ecx
  0025d	eb 02		 jmp	 SHORT $LN9@Iput
$LN10@Iput:

; 1568 :             _Fillcount = 0;

  0025f	33 ff		 xor	 edi, edi
$LN9@Iput:

; 1571 :         }
; 1572 : 
; 1573 :         ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;

  00261	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 1574 :         if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { // put leading fill

  00264	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  00267	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  0026c	83 f8 40	 cmp	 eax, 64			; 00000040H
  0026f	0f 84 85 00 00
	00		 je	 $LN13@Iput
  00275	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0027a	74 3f		 je	 SHORT $LN122@Iput

; 1575 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

  0027c	57		 push	 edi
  0027d	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  00280	8d 45 a8	 lea	 eax, DWORD PTR $T10[ebp]
  00283	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  00286	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00289	50		 push	 eax
  0028a	53		 push	 ebx
  0028b	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep

; 1576 :             _Fillcount = 0;

  00290	33 ff		 xor	 edi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00292	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1577 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

  00296	56		 push	 esi
  00297	8b 10		 mov	 edx, DWORD PTR [eax]
  00299	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2296 :         value_type* _Result = _Bx._Buf;

  0029c	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]

; 2297 :         if (_Large_string_engaged()) {

  0029f	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1577 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

  002a3	50		 push	 eax
  002a4	51		 push	 ecx
  002a5	52		 push	 edx
  002a6	8d 45 a8	 lea	 eax, DWORD PTR $T9[ebp]
  002a9	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx
  002ac	50		 push	 eax
  002ad	53		 push	 ebx
  002ae	89 4d 14	 mov	 DWORD PTR __Dest$[ebp+4], ecx
  002b1	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
  002b6	83 c4 30	 add	 esp, 48			; 00000030H
  002b9	eb 5f		 jmp	 SHORT $LN14@Iput
$LN122@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  002bb	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H

; 2296 :         value_type* _Result = _Bx._Buf;

  002bf	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1579 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

  002c2	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2297 :         if (_Large_string_engaged()) {

  002c3	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1579 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

  002c7	50		 push	 eax
  002c8	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  002cb	8d 45 a8	 lea	 eax, DWORD PTR $T8[ebp]
  002ce	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  002d1	50		 push	 eax
  002d2	53		 push	 ebx
  002d3	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put

; 1580 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

  002d8	57		 push	 edi
  002d9	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  002dc	8b 08		 mov	 ecx, DWORD PTR [eax]
  002de	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002e1	50		 push	 eax
  002e2	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  002e5	8d 45 a8	 lea	 eax, DWORD PTR $T7[ebp]
  002e8	51		 push	 ecx
  002e9	50		 push	 eax
  002ea	53		 push	 ebx
  002eb	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  002ee	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  002f3	83 c4 30	 add	 esp, 48			; 00000030H

; 1581 :             _Fillcount = 0;

  002f6	33 ff		 xor	 edi, edi

; 1582 :         } else {

  002f8	eb 20		 jmp	 SHORT $LN14@Iput
$LN13@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  002fa	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H

; 2296 :         value_type* _Result = _Bx._Buf;

  002fe	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1583 :             _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  00301	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2297 :         if (_Large_string_engaged()) {

  00302	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1583 :             _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  00306	50		 push	 eax
  00307	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  0030a	8d 45 a8	 lea	 eax, DWORD PTR $T6[ebp]
  0030d	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00310	50		 push	 eax
  00311	53		 push	 ebx
  00312	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
  00317	83 c4 18	 add	 esp, 24			; 00000018H
$LN14@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3843 :         return _Mypair._Myval2._Myptr()[_Off];

  0031a	8b 10		 mov	 edx, DWORD PTR [eax]
  0031c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 2296 :         value_type* _Result = _Bx._Buf;

  0031f	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]

; 2319 :         return _BUF_SIZE <= _Myres;

  00322	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H

; 3843 :         return _Mypair._Myval2._Myptr()[_Off];

  00326	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx

; 2297 :         if (_Large_string_engaged()) {

  00329	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1586 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

  0032d	29 75 b8	 sub	 DWORD PTR __Count$GSCopy$2$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3843 :         return _Mypair._Myval2._Myptr()[_Off];

  00330	03 c6		 add	 eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1586 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

  00332	ff 75 b8	 push	 DWORD PTR __Count$GSCopy$2$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3843 :         return _Mypair._Myval2._Myptr()[_Off];

  00335	89 4d 14	 mov	 DWORD PTR __Dest$[ebp+4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1586 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

  00338	50		 push	 eax
  00339	51		 push	 ecx
  0033a	52		 push	 edx
  0033b	8d 45 a8	 lea	 eax, DWORD PTR $T5[ebp]
  0033e	50		 push	 eax
  0033f	53		 push	 ebx
  00340	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 368  :         _Wide                      = _Newwidth;

  00345	8b 55 b0	 mov	 edx, DWORD PTR __Iosbase$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1588 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

  00348	8b 75 98	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  0034b	57		 push	 edi
  0034c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0034e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00351	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  00354	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  00357	50		 push	 eax
  00358	51		 push	 ecx
  00359	56		 push	 esi
  0035a	53		 push	 ebx
  0035b	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 368  :         _Wide                      = _Newwidth;

  0035e	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0
  00365	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1588 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

  0036c	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  00371	83 c4 30	 add	 esp, 48			; 00000030H
  00374	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3003 :         _Tidy_deallocate();

  00378	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  0037b	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1588 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

  00380	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3003 :         _Tidy_deallocate();

  00387	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  0038a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1588 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

  0038f	8b c6		 mov	 eax, esi

; 1589 :     }

  00391	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00394	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0039b	59		 pop	 ecx
  0039c	5f		 pop	 edi
  0039d	5e		 pop	 esi
  0039e	5b		 pop	 ebx
  0039f	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003a2	33 cd		 xor	 ecx, ebp
  003a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003a9	8b e5		 mov	 esp, ebp
  003ab	5d		 pop	 ebp
  003ac	c3		 ret	 0
$LN119@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2325 :             _Xran();

  003ad	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN126@Iput:
  003b2	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$4:
  00000	8b 45 b4	 mov	 eax, DWORD PTR $T12[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN26@Iput
  0000c	83 65 b4 fe	 and	 DWORD PTR $T12[ebp], -2	; fffffffeH
  00010	8d 4d a8	 lea	 ecx, DWORD PTR $T11[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
$LN26@Iput:
  00018	c3		 ret	 0
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$1:
  00019	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$5:
  00021	8b 45 b4	 mov	 eax, DWORD PTR $T12[ebp]
  00024	83 e0 02	 and	 eax, 2
  00027	0f 84 0c 00 00
	00		 je	 $LN46@Iput
  0002d	83 65 b4 fd	 and	 DWORD PTR $T12[ebp], -3	; fffffffdH
  00031	8d 4d a0	 lea	 ecx, DWORD PTR $T3[ebp]
  00034	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
$LN46@Iput:
  00039	c3		 ret	 0
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$3:
  0003a	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00042	cc		 int	 3
  00043	cc		 int	 3
  00044	cc		 int	 3
  00045	cc		 int	 3
  00046	cc		 int	 3
__ehhandler$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z:
  00047	90		 npad	 1
  00048	90		 npad	 1
  00049	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0004d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00050	8b 4a 94	 mov	 ecx, DWORD PTR [edx-108]
  00053	33 c8		 xor	 ecx, eax
  00055	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0005d	33 c8		 xor	 ecx, eax
  0005f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00064	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
  00069	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$1$ = -112				; size = 4
$T2 = -108						; size = 8
__Buf$GSCopy$1$ = -104					; size = 4
$T3 = -100						; size = 8
$T4 = -100						; size = 8
$T5 = -100						; size = 8
$T6 = -100						; size = 8
$T7 = -100						; size = 8
$T8 = -100						; size = 8
$T9 = -100						; size = 8
__Eoff$1$ = -92						; size = 4
$T10 = -92						; size = 1
$T11 = -88						; size = 4
__Kseparator$ = -88					; size = 1
__Iosbase$GSCopy$1$ = -84				; size = 4
__Dp$ = -80						; size = 2
__Count$GSCopy$2$ = -76					; size = 4
__Prefix$1$ = -76					; size = 4
__Punct_fac$1$ = -72					; size = 4
__Ctype_fac$1$ = -72					; size = 4
$T12 = -68						; size = 4
__Grouping$ = -64					; size = 24
__Groupstring$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Buf$ = 32						; size = 4
__Count$ = 36						; size = 4
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput, COMDAT

; 1441 :         size_t _Count) const { // put formatted floating-point to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 64	 sub	 esp, 100		; 00000064H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 5d 24	 mov	 ebx, DWORD PTR __Count$[ebp]
  0002e	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00031	8b 4d 18	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00034	8b 7d 20	 mov	 edi, DWORD PTR __Buf$[ebp]
  00037	89 45 90	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  0003a	89 4d ac	 mov	 DWORD PTR __Iosbase$GSCopy$1$[ebp], ecx
  0003d	89 7d 98	 mov	 DWORD PTR __Buf$GSCopy$1$[ebp], edi
  00040	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR $T12[ebp], 0

; 1442 :         auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));

  00047	85 db		 test	 ebx, ebx
  00049	74 11		 je	 SHORT $LN19@Fput
  0004b	8a 07		 mov	 al, BYTE PTR [edi]
  0004d	3c 2b		 cmp	 al, 43			; 0000002bH
  0004f	74 04		 je	 SHORT $LN18@Fput
  00051	3c 2d		 cmp	 al, 45			; 0000002dH
  00053	75 07		 jne	 SHORT $LN19@Fput
$LN18@Fput:
  00055	be 01 00 00 00	 mov	 esi, 1
  0005a	eb 02		 jmp	 SHORT $LN138@Fput
$LN19@Fput:
  0005c	33 f6		 xor	 esi, esi
$LN138@Fput:

; 1443 :         const char* _Exps;
; 1444 :         if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat) {

  0005e	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00061	25 00 30 00 00	 and	 eax, 12288		; 00003000H
  00066	89 75 b4	 mov	 DWORD PTR __Prefix$1$[ebp], esi
  00069	3d 00 30 00 00	 cmp	 eax, 12288		; 00003000H
  0006e	74 07		 je	 SHORT $LN4@Fput

; 1445 :             _Exps = "eE";

  00070	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02MDKMJEGG@eE@

; 1446 :         } else { // correct for hexadecimal floating-point

  00075	eb 25		 jmp	 SHORT $LN6@Fput
$LN4@Fput:

; 1447 :             _Exps = "pP";
; 1448 :             if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1449 :                 && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {

  00077	8d 46 02	 lea	 eax, DWORD PTR [esi+2]
  0007a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02OOPEBDOJ@pP@
  0007f	3b c3		 cmp	 eax, ebx
  00081	77 19		 ja	 SHORT $LN6@Fput
  00083	80 3c 37 30	 cmp	 BYTE PTR [edi+esi], 48	; 00000030H
  00087	75 13		 jne	 SHORT $LN6@Fput
  00089	8a 4c 37 01	 mov	 cl, BYTE PTR [edi+esi+1]
  0008d	80 f9 78	 cmp	 cl, 120			; 00000078H
  00090	74 05		 je	 SHORT $LN7@Fput
  00092	80 f9 58	 cmp	 cl, 88			; 00000058H
  00095	75 05		 jne	 SHORT $LN6@Fput
$LN7@Fput:

; 1450 :                 _Prefix += 2;

  00097	8b f0		 mov	 esi, eax
  00099	89 75 b4	 mov	 DWORD PTR __Prefix$1$[ebp], esi
$LN6@Fput:

; 1451 :             }
; 1452 :         }
; 1453 :         const size_t _Eoff = _CSTD strcspn(&_Buf[0], _Exps); // find exponent

  0009c	52		 push	 edx
  0009d	57		 push	 edi
  0009e	e8 00 00 00 00	 call	 _strcspn
  000a3	89 45 a4	 mov	 DWORD PTR __Eoff$1$[ebp], eax

; 1454 :         char _Dp[2]        = {"."};

  000a6	b8 2e 00 00 00	 mov	 eax, 46			; 0000002eH
  000ab	66 89 45 b0	 mov	 WORD PTR __Dp$[ebp], ax

; 1455 :         _Dp[0]             = _CSTD localeconv()->decimal_point[0];

  000af	e8 00 00 00 00	 call	 _localeconv
  000b4	8b 00		 mov	 eax, DWORD PTR [eax]
  000b6	8a 00		 mov	 al, BYTE PTR [eax]
  000b8	88 45 b0	 mov	 BYTE PTR __Dp$[ebp], al

; 1456 :         const size_t _Poff = _CSTD strcspn(&_Buf[0], &_Dp[0]); // find decimal point

  000bb	8d 45 b0	 lea	 eax, DWORD PTR __Dp$[ebp]
  000be	50		 push	 eax
  000bf	57		 push	 edi
  000c0	e8 00 00 00 00	 call	 _strcspn
  000c5	83 c4 10	 add	 esp, 16			; 00000010H
  000c8	8b f8		 mov	 edi, eax

; 1458 :         const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

  000ca	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 373  :         return *_Ploc;

  000d1	8b 45 ac	 mov	 eax, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  000d4	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 267  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  000d7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000da	89 4d a0	 mov	 DWORD PTR $T9[ebp+4], ecx
  000dd	89 4d a8	 mov	 DWORD PTR $T11[ebp], ecx

; 268  :         _Ptr->_Incref();

  000e0	8b 01		 mov	 eax, DWORD PTR [ecx]
  000e2	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1458 :         const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

  000e5	8d 45 9c	 lea	 eax, DWORD PTR $T9[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 373  :         return *_Ploc;

  000e8	c7 45 bc 01 00
	00 00		 mov	 DWORD PTR $T12[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1458 :         const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

  000ef	50		 push	 eax
  000f0	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  000f5	89 45 b8	 mov	 DWORD PTR __Ctype_fac$1$[ebp], eax
  000f8	83 c4 04	 add	 esp, 4
  000fb	b8 01 00 00 00	 mov	 eax, 1
  00100	89 45 bc	 mov	 DWORD PTR $T12[ebp], eax
  00103	83 e0 fe	 and	 eax, -2			; fffffffeH
  00106	89 45 bc	 mov	 DWORD PTR $T12[ebp], eax
  00109	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00110	8b 4d a8	 mov	 ecx, DWORD PTR $T11[ebp]
  00113	85 c9		 test	 ecx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 351  :         if (_Ptr) {

  00115	74 11		 je	 SHORT $LN34@Fput

; 352  :             delete _Ptr->_Decref();

  00117	8b 01		 mov	 eax, DWORD PTR [ecx]
  00119	ff 50 08	 call	 DWORD PTR [eax+8]
  0011c	8b c8		 mov	 ecx, eax
  0011e	85 c9		 test	 ecx, ecx
  00120	74 06		 je	 SHORT $LN34@Fput
  00122	8b 01		 mov	 eax, DWORD PTR [ecx]
  00124	6a 01		 push	 1
  00126	ff 10		 call	 DWORD PTR [eax]
$LN34@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1459 :         basic_string<_Elem> _Groupstring(_Count, _Elem(0)); // reserve space

  00128	6a 00		 push	 0
  0012a	53		 push	 ebx
  0012b	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  0012e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00133	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2296 :         value_type* _Result = _Bx._Buf;

  0013a	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]

; 2319 :         return _BUF_SIZE <= _Myres;

  0013d	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1460 :         _Ctype_fac.widen(_Buf, _Buf + _Count, &_Groupstring[0]);

  00141	8b 4d 98	 mov	 ecx, DWORD PTR __Buf$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2297 :         if (_Large_string_engaged()) {

  00144	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 2694 :         return do_widen(_First, _Last, _Dest);

  00148	8b 55 b8	 mov	 edx, DWORD PTR __Ctype_fac$1$[ebp]
  0014b	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1460 :         _Ctype_fac.widen(_Buf, _Buf + _Count, &_Groupstring[0]);

  0014c	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 2694 :         return do_widen(_First, _Last, _Dest);

  0014f	50		 push	 eax
  00150	8b 12		 mov	 edx, DWORD PTR [edx]
  00152	51		 push	 ecx
  00153	8b 4d b8	 mov	 ecx, DWORD PTR __Ctype_fac$1$[ebp]
  00156	ff 52 1c	 call	 DWORD PTR [edx+28]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1462 :         const auto& _Punct_fac  = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

  00159	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 373  :         return *_Ploc;

  0015d	8b 45 ac	 mov	 eax, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00160	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 267  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  00163	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00166	89 4d 98	 mov	 DWORD PTR $T2[ebp+4], ecx

; 268  :         _Ptr->_Incref();

  00169	8b 01		 mov	 eax, DWORD PTR [ecx]
  0016b	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 373  :         return *_Ploc;

  0016e	83 4d bc 02	 or	 DWORD PTR $T12[ebp], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1462 :         const auto& _Punct_fac  = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

  00172	8d 45 94	 lea	 eax, DWORD PTR $T2[ebp]
  00175	50		 push	 eax
  00176	e8 00 00 00 00	 call	 ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
  0017b	83 65 bc fd	 and	 DWORD PTR $T12[ebp], -3	; fffffffdH
  0017f	83 c4 04	 add	 esp, 4
  00182	89 45 b8	 mov	 DWORD PTR __Punct_fac$1$[ebp], eax
  00185	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 351  :         if (_Ptr) {

  00189	8b 4d 98	 mov	 ecx, DWORD PTR $T2[ebp+4]
  0018c	85 c9		 test	 ecx, ecx
  0018e	74 14		 je	 SHORT $LN54@Fput

; 352  :             delete _Ptr->_Decref();

  00190	8b 01		 mov	 eax, DWORD PTR [ecx]
  00192	ff 50 08	 call	 DWORD PTR [eax+8]
  00195	8b c8		 mov	 ecx, eax
  00197	85 c9		 test	 ecx, ecx
  00199	74 06		 je	 SHORT $LN135@Fput
  0019b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0019d	6a 01		 push	 1
  0019f	ff 10		 call	 DWORD PTR [eax]
$LN135@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1463 :         const string _Grouping  = _Punct_fac.grouping();

  001a1	8b 45 b8	 mov	 eax, DWORD PTR __Punct_fac$1$[ebp]
$LN54@Fput:
  001a4	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  001a7	51		 push	 ecx
  001a8	8b c8		 mov	 ecx, eax
  001aa	e8 00 00 00 00	 call	 ?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
  001af	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 123  :         return do_thousands_sep();

  001b3	8b 4d b8	 mov	 ecx, DWORD PTR __Punct_fac$1$[ebp]
  001b6	8b 01		 mov	 eax, DWORD PTR [ecx]
  001b8	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  001bb	ff d0		 call	 eax

; 1464 :         const _Elem _Kseparator = _Punct_fac.thousands_sep();

  001bd	88 45 a8	 mov	 BYTE PTR __Kseparator$[ebp], al

; 1465 : 
; 1466 :         if (_Poff != _Count) {

  001c0	3b fb		 cmp	 edi, ebx
  001c2	74 1c		 je	 SHORT $LN139@Fput

; 119  :         return do_decimal_point();

  001c4	8b 4d b8	 mov	 ecx, DWORD PTR __Punct_fac$1$[ebp]
  001c7	8b 01		 mov	 eax, DWORD PTR [ecx]
  001c9	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  001cc	ff d0		 call	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  001ce	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 119  :         return do_decimal_point();

  001d2	8a c8		 mov	 cl, al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2296 :         value_type* _Result = _Bx._Buf;

  001d4	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]

; 2297 :         if (_Large_string_engaged()) {

  001d7	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1470 :         size_t _Off     = _Poff == _Count ? _Eoff : _Poff;

  001db	3b fb		 cmp	 edi, ebx
  001dd	88 0c 38	 mov	 BYTE PTR [eax+edi], cl
$LN139@Fput:
  001e0	0f 44 7d a4	 cmove	 edi, DWORD PTR __Eoff$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2305 :         const value_type* _Result = _Bx._Buf;

  001e4	8d 5d c0	 lea	 ebx, DWORD PTR __Grouping$[ebp]

; 2319 :         return _BUF_SIZE <= _Myres;

  001e7	83 7d d4 10	 cmp	 DWORD PTR __Grouping$[ebp+20], 16 ; 00000010H

; 2306 :         if (_Large_string_engaged()) {

  001eb	0f 43 5d c0	 cmovae	 ebx, DWORD PTR __Grouping$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1472 :         while (*_Pg != CHAR_MAX && '\0' < *_Pg && static_cast<size_t>(*_Pg) < _Off - _Prefix) {

  001ef	8a 03		 mov	 al, BYTE PTR [ebx]
  001f1	3c 7f		 cmp	 al, 127			; 0000007fH
  001f3	0f 84 96 00 00
	00		 je	 $LN3@Fput
  001f9	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@Fput:
  00200	84 c0		 test	 al, al
  00202	0f 8e 87 00 00
	00		 jle	 $LN3@Fput
  00208	0f be c8	 movsx	 ecx, al
  0020b	8b c7		 mov	 eax, edi
  0020d	2b c6		 sub	 eax, esi
  0020f	3b c8		 cmp	 ecx, eax
  00211	73 7c		 jae	 SHORT $LN3@Fput

; 1473 :             // add thousands separator
; 1474 :             _Groupstring.insert(_Off -= *_Pg, 1, _Kseparator);

  00213	2b f9		 sub	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2324 :         if (_Mysize < _Off) {

  00215	8b 4d e8	 mov	 ecx, DWORD PTR __Groupstring$[ebp+16]
  00218	3b cf		 cmp	 ecx, edi
  0021a	0f 82 dd 01 00
	00		 jb	 $LN130@Fput

; 3392 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00220	8b 55 ec	 mov	 edx, DWORD PTR __Groupstring$[ebp+20]
  00223	8b c2		 mov	 eax, edx
  00225	2b c1		 sub	 eax, ecx

; 3393 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00227	83 f8 01	 cmp	 eax, 1
  0022a	72 38		 jb	 SHORT $LN79@Fput

; 3394 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  0022c	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 2319 :         return _BUF_SIZE <= _Myres;

  0022f	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2296 :         value_type* _Result = _Bx._Buf;

  00232	8d 75 d8	 lea	 esi, DWORD PTR __Groupstring$[ebp]

; 3394 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00235	89 45 e8	 mov	 DWORD PTR __Groupstring$[ebp+16], eax

; 2297 :         if (_Large_string_engaged()) {

  00238	0f 43 75 d8	 cmovae	 esi, DWORD PTR __Groupstring$[ebp]

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0023c	2b cf		 sub	 ecx, edi

; 3396 :             _Elem* const _Insert_at = _Old_ptr + _Off;

  0023e	03 f7		 add	 esi, edi

; 3397 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

  00240	41		 inc	 ecx

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00241	51		 push	 ecx
  00242	56		 push	 esi

; 3397 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

  00243	8d 46 01	 lea	 eax, DWORD PTR [esi+1]

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00246	50		 push	 eax
  00247	e8 00 00 00 00	 call	 _memmove

; 446  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  0024c	0f be 4d a8	 movsx	 ecx, BYTE PTR __Kseparator$[ebp]

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00250	83 c4 0c	 add	 esp, 12			; 0000000cH

; 446  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  00253	0f b6 c1	 movzx	 eax, cl
  00256	66 c1 e1 08	 shl	 cx, 8
  0025a	66 0b c8	 or	 cx, ax
  0025d	88 0e		 mov	 BYTE PTR [esi], cl

; 3399 :             return *this;

  0025f	8b 75 b4	 mov	 esi, DWORD PTR __Prefix$1$[ebp]
  00262	eb 17		 jmp	 SHORT $LN78@Fput
$LN79@Fput:

; 3400 :         }
; 3401 : 
; 3402 :         return _Reallocate_grow_by(

  00264	ff 75 a8	 push	 DWORD PTR __Kseparator$[ebp]
  00267	c6 45 a4 00	 mov	 BYTE PTR $T10[ebp], 0
  0026b	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  0026e	6a 01		 push	 1
  00270	57		 push	 edi
  00271	ff 75 a4	 push	 DWORD PTR $T10[ebp]
  00274	6a 01		 push	 1
  00276	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>
$LN78@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1475 :             if ('\0' < _Pg[1]) {

  0027b	80 7b 01 00	 cmp	 BYTE PTR [ebx+1], 0
  0027f	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00282	0f 4f d8	 cmovg	 ebx, eax
  00285	8a 03		 mov	 al, BYTE PTR [ebx]
  00287	3c 7f		 cmp	 al, 127			; 0000007fH
  00289	0f 85 71 ff ff
	ff		 jne	 $LL2@Fput
$LN3@Fput:

; 1476 :                 ++_Pg; // not last group, advance
; 1477 :             }
; 1478 :         }
; 1479 : 
; 1480 :         _Count = _Groupstring.size();
; 1481 : 
; 1482 :         size_t _Fillcount;
; 1483 :         if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Count) {

  0028f	8b 4d ac	 mov	 ecx, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00292	8b 45 e8	 mov	 eax, DWORD PTR __Groupstring$[ebp+16]
  00295	89 45 b4	 mov	 DWORD PTR __Count$GSCopy$2$[ebp], eax
  00298	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0029c	8b 79 20	 mov	 edi, DWORD PTR [ecx+32]
  0029f	7c 0e		 jl	 SHORT $LN12@Fput
  002a1	7f 04		 jg	 SHORT $LN134@Fput
  002a3	85 ff		 test	 edi, edi
  002a5	74 08		 je	 SHORT $LN12@Fput
$LN134@Fput:
  002a7	3b f8		 cmp	 edi, eax
  002a9	76 04		 jbe	 SHORT $LN12@Fput

; 1485 :         } else {
; 1486 :             _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Count;

  002ab	2b f8		 sub	 edi, eax
  002ad	eb 02		 jmp	 SHORT $LN11@Fput
$LN12@Fput:

; 1484 :             _Fillcount = 0;

  002af	33 ff		 xor	 edi, edi
$LN11@Fput:

; 1487 :         }
; 1488 : 
; 1489 :         ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;

  002b1	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1490 :         if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { // put leading fill

  002b4	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  002b7	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  002bc	83 f8 40	 cmp	 eax, 64			; 00000040H
  002bf	0f 84 85 00 00
	00		 je	 $LN15@Fput
  002c5	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  002ca	74 3f		 je	 SHORT $LN133@Fput

; 1491 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

  002cc	57		 push	 edi
  002cd	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  002d0	8d 45 9c	 lea	 eax, DWORD PTR $T8[ebp]
  002d3	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  002d6	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  002d9	50		 push	 eax
  002da	53		 push	 ebx
  002db	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep

; 1492 :             _Fillcount = 0;

  002e0	33 ff		 xor	 edi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  002e2	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1493 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

  002e6	56		 push	 esi
  002e7	8b 10		 mov	 edx, DWORD PTR [eax]
  002e9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2296 :         value_type* _Result = _Bx._Buf;

  002ec	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]

; 2297 :         if (_Large_string_engaged()) {

  002ef	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1493 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

  002f3	50		 push	 eax
  002f4	51		 push	 ecx
  002f5	52		 push	 edx
  002f6	8d 45 9c	 lea	 eax, DWORD PTR $T7[ebp]
  002f9	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx
  002fc	50		 push	 eax
  002fd	53		 push	 ebx
  002fe	89 4d 14	 mov	 DWORD PTR __Dest$[ebp+4], ecx
  00301	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
  00306	83 c4 30	 add	 esp, 48			; 00000030H
  00309	eb 5f		 jmp	 SHORT $LN16@Fput
$LN133@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  0030b	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H

; 2296 :         value_type* _Result = _Bx._Buf;

  0030f	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1495 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

  00312	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2297 :         if (_Large_string_engaged()) {

  00313	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1495 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

  00317	50		 push	 eax
  00318	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  0031b	8d 45 9c	 lea	 eax, DWORD PTR $T6[ebp]
  0031e	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00321	50		 push	 eax
  00322	53		 push	 ebx
  00323	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put

; 1496 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

  00328	57		 push	 edi
  00329	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  0032c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00331	50		 push	 eax
  00332	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  00335	8d 45 9c	 lea	 eax, DWORD PTR $T5[ebp]
  00338	51		 push	 ecx
  00339	50		 push	 eax
  0033a	53		 push	 ebx
  0033b	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  0033e	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  00343	83 c4 30	 add	 esp, 48			; 00000030H

; 1497 :             _Fillcount = 0;

  00346	33 ff		 xor	 edi, edi

; 1498 :         } else {

  00348	eb 20		 jmp	 SHORT $LN16@Fput
$LN15@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  0034a	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H

; 2296 :         value_type* _Result = _Bx._Buf;

  0034e	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1499 :             _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  00351	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2297 :         if (_Large_string_engaged()) {

  00352	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1499 :             _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  00356	50		 push	 eax
  00357	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  0035a	8d 45 9c	 lea	 eax, DWORD PTR $T4[ebp]
  0035d	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00360	50		 push	 eax
  00361	53		 push	 ebx
  00362	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
  00367	83 c4 18	 add	 esp, 24			; 00000018H
$LN16@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3843 :         return _Mypair._Myval2._Myptr()[_Off];

  0036a	8b 10		 mov	 edx, DWORD PTR [eax]
  0036c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 2296 :         value_type* _Result = _Bx._Buf;

  0036f	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]

; 2319 :         return _BUF_SIZE <= _Myres;

  00372	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H

; 3843 :         return _Mypair._Myval2._Myptr()[_Off];

  00376	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx

; 2297 :         if (_Large_string_engaged()) {

  00379	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1502 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

  0037d	29 75 b4	 sub	 DWORD PTR __Count$GSCopy$2$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3843 :         return _Mypair._Myval2._Myptr()[_Off];

  00380	03 c6		 add	 eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1502 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

  00382	ff 75 b4	 push	 DWORD PTR __Count$GSCopy$2$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3843 :         return _Mypair._Myval2._Myptr()[_Off];

  00385	89 4d 14	 mov	 DWORD PTR __Dest$[ebp+4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1502 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

  00388	50		 push	 eax
  00389	51		 push	 ecx
  0038a	52		 push	 edx
  0038b	8d 45 9c	 lea	 eax, DWORD PTR $T3[ebp]
  0038e	50		 push	 eax
  0038f	53		 push	 ebx
  00390	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 368  :         _Wide                      = _Newwidth;

  00395	8b 55 ac	 mov	 edx, DWORD PTR __Iosbase$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1504 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

  00398	8b 75 90	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  0039b	57		 push	 edi
  0039c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0039e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  003a1	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  003a4	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  003a7	50		 push	 eax
  003a8	51		 push	 ecx
  003a9	56		 push	 esi
  003aa	53		 push	 ebx
  003ab	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 368  :         _Wide                      = _Newwidth;

  003ae	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0
  003b5	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1504 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

  003bc	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  003c1	83 c4 30	 add	 esp, 48			; 00000030H
  003c4	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3003 :         _Tidy_deallocate();

  003c8	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  003cb	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1504 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

  003d0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3003 :         _Tidy_deallocate();

  003d7	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  003da	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1504 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

  003df	8b c6		 mov	 eax, esi

; 1505 :     }

  003e1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003e4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003eb	59		 pop	 ecx
  003ec	5f		 pop	 edi
  003ed	5e		 pop	 esi
  003ee	5b		 pop	 ebx
  003ef	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003f2	33 cd		 xor	 ecx, ebp
  003f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003f9	8b e5		 mov	 esp, ebp
  003fb	5d		 pop	 ebp
  003fc	c3		 ret	 0
$LN130@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2325 :             _Xran();

  003fd	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN137@Fput:
  00402	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$4:
  00000	8b 45 bc	 mov	 eax, DWORD PTR $T12[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN28@Fput
  0000c	83 65 bc fe	 and	 DWORD PTR $T12[ebp], -2	; fffffffeH
  00010	8d 4d 9c	 lea	 ecx, DWORD PTR $T9[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
$LN28@Fput:
  00018	c3		 ret	 0
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$1:
  00019	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$5:
  00021	8b 45 bc	 mov	 eax, DWORD PTR $T12[ebp]
  00024	83 e0 02	 and	 eax, 2
  00027	0f 84 0c 00 00
	00		 je	 $LN48@Fput
  0002d	83 65 bc fd	 and	 DWORD PTR $T12[ebp], -3	; fffffffdH
  00031	8d 4d 94	 lea	 ecx, DWORD PTR $T2[ebp]
  00034	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
$LN48@Fput:
  00039	c3		 ret	 0
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$3:
  0003a	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00042	cc		 int	 3
  00043	cc		 int	 3
  00044	cc		 int	 3
  00045	cc		 int	 3
  00046	cc		 int	 3
__ehhandler$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z:
  00047	90		 npad	 1
  00048	90		 npad	 1
  00049	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0004d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00050	8b 4a 8c	 mov	 ecx, DWORD PTR [edx-116]
  00053	33 c8		 xor	 ecx, eax
  00055	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0005d	33 c8		 xor	 ecx, eax
  0005f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00064	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z
  00069	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 1
__Flags$ = 20						; size = 4
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt, COMDAT

; 1393 :         char* _Fmt, char _Spec, ios_base::fmtflags _Flags) const { // generate sprintf format for floating-point

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1394 :         char* _Ptr = _Fmt;
; 1395 :         *_Ptr++    = '%';
; 1396 : 
; 1397 :         if (_Flags & ios_base::showpos) {

  00003	8b 55 14	 mov	 edx, DWORD PTR __Flags$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR __Fmt$[ebp]
  0000a	c6 06 25	 mov	 BYTE PTR [esi], 37	; 00000025H
  0000d	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00010	f6 c2 20	 test	 dl, 32			; 00000020H
  00013	74 04		 je	 SHORT $LN2@Ffmt

; 1398 :             *_Ptr++ = '+';

  00015	c6 00 2b	 mov	 BYTE PTR [eax], 43	; 0000002bH
  00018	40		 inc	 eax
$LN2@Ffmt:

; 1399 :         }
; 1400 : 
; 1401 :         if (_Flags & ios_base::showpoint) {

  00019	f6 c2 10	 test	 dl, 16			; 00000010H
  0001c	74 04		 je	 SHORT $LN3@Ffmt

; 1402 :             *_Ptr++ = '#';

  0001e	c6 00 23	 mov	 BYTE PTR [eax], 35	; 00000023H
  00021	40		 inc	 eax
$LN3@Ffmt:

; 1403 :         }
; 1404 : 
; 1405 :         *_Ptr++ = '.';
; 1406 :         *_Ptr++ = '*'; // for precision argument
; 1407 :         if (_Spec != '\0') {

  00022	8a 4d 10	 mov	 cl, BYTE PTR __Spec$[ebp]
  00025	66 c7 00 2e 2a	 mov	 WORD PTR [eax], 10798	; 00002a2eH
  0002a	83 c0 02	 add	 eax, 2
  0002d	84 c9		 test	 cl, cl
  0002f	74 03		 je	 SHORT $LN4@Ffmt

; 1408 :             *_Ptr++ = _Spec; // 'L' qualifier for long double only

  00031	88 08		 mov	 BYTE PTR [eax], cl
  00033	40		 inc	 eax
$LN4@Ffmt:

; 1409 :         }
; 1410 : 
; 1411 :         char _Ch; // specifier
; 1412 :         ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;

  00034	8b ca		 mov	 ecx, edx
  00036	81 e1 00 30 00
	00		 and	 ecx, 12288		; 00003000H

; 1413 :         if (_Flags & ios_base::uppercase) {

  0003c	f6 c2 04	 test	 dl, 4
  0003f	74 38		 je	 SHORT $LN5@Ffmt

; 1414 :             if (_Ffl == ios_base::fixed) {

  00041	81 f9 00 20 00
	00		 cmp	 ecx, 8192		; 00002000H
  00047	74 38		 je	 SHORT $LN20@Ffmt

; 1415 :                 _Ch = 'f';
; 1416 :             } else if (_Ffl == ios_base::hexfloat) {

  00049	81 f9 00 30 00
	00		 cmp	 ecx, 12288		; 00003000H
  0004f	75 0d		 jne	 SHORT $LN9@Ffmt

; 1417 :                 _Ch = 'A'; // added with TR1

  00051	b1 41		 mov	 cl, 65			; 00000041H

; 1429 :                 _Ch = 'e';
; 1430 :             } else {
; 1431 :                 _Ch = 'g';
; 1432 :             }
; 1433 :         }
; 1434 :         *_Ptr++ = _Ch;

  00053	88 08		 mov	 BYTE PTR [eax], cl

; 1435 : 
; 1436 :         *_Ptr = '\0';

  00055	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1437 :         return _Fmt;

  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi

; 1438 :     }

  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
$LN9@Ffmt:

; 1418 :             } else if (_Ffl == ios_base::scientific) {

  0005e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00064	0f 95 c1	 setne	 cl
  00067	8d 0c 4d 45 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+69]

; 1429 :                 _Ch = 'e';
; 1430 :             } else {
; 1431 :                 _Ch = 'g';
; 1432 :             }
; 1433 :         }
; 1434 :         *_Ptr++ = _Ch;

  0006e	88 08		 mov	 BYTE PTR [eax], cl

; 1435 : 
; 1436 :         *_Ptr = '\0';

  00070	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1437 :         return _Fmt;

  00074	8b c6		 mov	 eax, esi
  00076	5e		 pop	 esi

; 1438 :     }

  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
$LN5@Ffmt:

; 1419 :                 _Ch = 'E';
; 1420 :             } else {
; 1421 :                 _Ch = 'G';
; 1422 :             }
; 1423 :         } else {
; 1424 :             if (_Ffl == ios_base::fixed) {

  00079	81 f9 00 20 00
	00		 cmp	 ecx, 8192		; 00002000H
  0007f	75 0d		 jne	 SHORT $LN13@Ffmt
$LN20@Ffmt:

; 1429 :                 _Ch = 'e';
; 1430 :             } else {
; 1431 :                 _Ch = 'g';
; 1432 :             }
; 1433 :         }
; 1434 :         *_Ptr++ = _Ch;

  00081	b1 66		 mov	 cl, 102			; 00000066H
  00083	88 08		 mov	 BYTE PTR [eax], cl

; 1435 : 
; 1436 :         *_Ptr = '\0';

  00085	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1437 :         return _Fmt;

  00089	8b c6		 mov	 eax, esi
  0008b	5e		 pop	 esi

; 1438 :     }

  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
$LN13@Ffmt:

; 1425 :                 _Ch = 'f';
; 1426 :             } else if (_Ffl == ios_base::hexfloat) {

  0008e	81 f9 00 30 00
	00		 cmp	 ecx, 12288		; 00003000H
  00094	75 0d		 jne	 SHORT $LN15@Ffmt

; 1427 :                 _Ch = 'a'; // added with TR1

  00096	b1 61		 mov	 cl, 97			; 00000061H

; 1429 :                 _Ch = 'e';
; 1430 :             } else {
; 1431 :                 _Ch = 'g';
; 1432 :             }
; 1433 :         }
; 1434 :         *_Ptr++ = _Ch;

  00098	88 08		 mov	 BYTE PTR [eax], cl

; 1435 : 
; 1436 :         *_Ptr = '\0';

  0009a	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1437 :         return _Fmt;

  0009e	8b c6		 mov	 eax, esi
  000a0	5e		 pop	 esi

; 1438 :     }

  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
$LN15@Ffmt:

; 1428 :             } else if (_Ffl == ios_base::scientific) {

  000a3	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000a9	0f 95 c1	 setne	 cl
  000ac	8d 0c 4d 65 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+101]

; 1429 :                 _Ch = 'e';
; 1430 :             } else {
; 1431 :                 _Ch = 'g';
; 1432 :             }
; 1433 :         }
; 1434 :         *_Ptr++ = _Ch;

  000b3	88 08		 mov	 BYTE PTR [eax], cl

; 1435 : 
; 1436 :         *_Ptr = '\0';

  000b5	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1437 :         return _Fmt;

  000b9	8b c6		 mov	 eax, esi
  000bb	5e		 pop	 esi

; 1438 :     }

  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
_TEXT	SEGMENT
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1384 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const void* _Val) const { // put formatted void pointer to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 1c	 mov	 eax, DWORD PTR __Val$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	56		 push	 esi
  00018	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0001b	57		 push	 edi

; 1385 :         char _Buf[2 * _MAX_INT_DIG];
; 1386 : 
; 1387 :         return _Iput(

  0001c	50		 push	 eax
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  00022	8d 45 bc	 lea	 eax, DWORD PTR __Buf$[ebp]
  00025	8b f9		 mov	 edi, ecx
  00027	6a 40		 push	 64			; 00000040H
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _sprintf_s
  0002f	50		 push	 eax
  00030	8d 45 bc	 lea	 eax, DWORD PTR __Buf$[ebp]
  00033	50		 push	 eax
  00034	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00037	56		 push	 esi
  00038	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0003b	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0003e	53		 push	 ebx
  0003f	57		 push	 edi
  00040	e8 00 00 00 00	 call	 ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1388 :             _Dest, _Iosbase, _Fill, _Buf, static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), "%p", _Val)));
; 1389 :     }

  00045	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00048	83 c4 30	 add	 esp, 48			; 00000030H
  0004b	8b c3		 mov	 eax, ebx
  0004d	33 cd		 xor	 ecx, ebp
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 18 00	 ret	 24			; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
_TEXT	SEGMENT
__Precision$ = -84					; size = 8
___$ReturnUdt$GSCopy$1$ = -76				; size = 4
__Bufsize$1$ = -72					; size = 4
__Ptwo$2 = -68						; size = 4
_this$GSCopy$1$ = -64					; size = 4
tv414 = -60						; size = 4
tv400 = -56						; size = 4
__Precision$1$ = -52					; size = 4
__Buf$ = -48						; size = 24
__Fmt$ = -24						; size = 8
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1359 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long double _Val) const { // put formatted long double to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d c0	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00030	8b 7d 14	 mov	 edi, DWORD PTR __Iosbase$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00033	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR __Buf$[ebp], 0

; 2355 :     size_type _Mysize = 0; // current length of string

  0003a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR __Buf$[ebp+16], 0

; 2356 :     size_type _Myres  = 0; // current storage reserved for string

  00041	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __Buf$[ebp+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1359 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long double _Val) const { // put formatted long double to _Dest

  00048	89 45 b4	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4596 :         _My_data._Mysize = 0;

  0004b	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR __Buf$[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00052	c7 45 e4 0f 00
	00 00		 mov	 DWORD PTR __Buf$[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00059	c6 45 d0 00	 mov	 BYTE PTR __Buf$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1360 :         string _Buf;

  0005d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1361 :         char _Fmt[8];
; 1362 :         const auto _Float_flags     = _Iosbase.flags() & ios_base::floatfield;

  00064	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  00067	81 e6 00 30 00
	00		 and	 esi, 12288		; 00003000H

; 1363 :         const bool _Is_fixed        = _Float_flags == ios_base::fixed;
; 1364 :         const bool _Is_hex          = _Float_flags == (ios_base::fixed | ios_base::scientific);
; 1365 :         const streamsize _Precision = _Is_hex ? -1 : _Iosbase.precision(); // precision setting

  0006d	56		 push	 esi
  0006e	81 fe 00 30 00
	00		 cmp	 esi, 12288		; 00003000H
  00074	75 21		 jne	 SHORT $LN4@do_put
  00076	6a ff		 push	 -1
  00078	6a ff		 push	 -1
  0007a	c7 45 cc ff ff
	ff ff		 mov	 DWORD PTR __Precision$1$[ebp], -1
  00081	c7 45 b0 ff ff
	ff ff		 mov	 DWORD PTR __Precision$[ebp+4], -1
  00088	e8 00 00 00 00	 call	 ??$_Float_put_desired_precision@O@std@@YAH_JH@Z ; std::_Float_put_desired_precision<long double>
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00090	8b c8		 mov	 ecx, eax
  00092	e9 82 00 00 00	 jmp	 $LN2@do_put
$LN4@do_put:
  00097	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  0009a	8b 47 18	 mov	 eax, DWORD PTR [edi+24]

; 1366 :         const int _Desired_precision =

  0009d	51		 push	 ecx
  0009e	50		 push	 eax
  0009f	89 45 c8	 mov	 DWORD PTR tv400[ebp], eax
  000a2	e8 00 00 00 00	 call	 ??$_Float_put_desired_precision@O@std@@YAH_JH@Z ; std::_Float_put_desired_precision<long double>

; 1367 :             _Float_put_desired_precision<long double>(_Precision, _Float_flags); // desired precision
; 1368 :         size_t _Bufsize = static_cast<size_t>(_Desired_precision);

  000a7	8b c8		 mov	 ecx, eax
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ac	8b 45 c8	 mov	 eax, DWORD PTR tv400[ebp]
  000af	89 4d b8	 mov	 DWORD PTR __Bufsize$1$[ebp], ecx
  000b2	89 45 cc	 mov	 DWORD PTR __Precision$1$[ebp], eax

; 1369 :         if (_Is_fixed && 1e10 < _CSTD fabsl(_Val)) { // f or F format

  000b5	81 fe 00 20 00
	00		 cmp	 esi, 8192		; 00002000H
  000bb	75 5c		 jne	 SHORT $LN2@do_put
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_math.h

; 841  :         return fabs((double)_X);

  000bd	f2 0f 10 4d 1c	 movsd	 xmm1, QWORD PTR __Val$[ebp]
  000c2	0f 28 c1	 movaps	 xmm0, xmm1
  000c5	89 45 cc	 mov	 DWORD PTR __Precision$1$[ebp], eax
  000c8	0f 54 05 00 00
	00 00		 andps	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1369 :         if (_Is_fixed && 1e10 < _CSTD fabsl(_Val)) { // f or F format

  000cf	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@4202a05f20000000
  000d7	76 40		 jbe	 SHORT $LN2@do_put
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_math.h

; 862  :         return frexp((double)_X, _Y);

  000d9	8d 45 bc	 lea	 eax, DWORD PTR __Ptwo$2[ebp]
  000dc	50		 push	 eax
  000dd	83 ec 08	 sub	 esp, 8
  000e0	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  000e5	e8 00 00 00 00	 call	 _frexp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1372 :             _Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

  000ea	8b 45 bc	 mov	 eax, DWORD PTR __Ptwo$2[ebp]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_math.h

; 862  :         return frexp((double)_X, _Y);

  000ed	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1372 :             _Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

  000f0	99		 cdq
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_math.h

; 862  :         return frexp((double)_X, _Y);

  000f1	dd d8		 fstp	 ST(0)
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1372 :             _Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

  000f3	33 c2		 xor	 eax, edx
  000f5	2b c2		 sub	 eax, edx
  000f7	69 c8 97 75 00
	00		 imul	 ecx, eax, 30103
  000fd	b8 89 b5 f8 14	 mov	 eax, 351843721		; 14f8b589H
  00102	f7 e9		 imul	 ecx
  00104	8b 4d b8	 mov	 ecx, DWORD PTR __Bufsize$1$[ebp]
  00107	c1 fa 0d	 sar	 edx, 13			; 0000000dH
  0010a	8b c2		 mov	 eax, edx
  0010c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0010f	03 c2		 add	 eax, edx
  00111	03 c8		 add	 ecx, eax
  00113	8b 45 c8	 mov	 eax, DWORD PTR tv400[ebp]
  00116	89 45 cc	 mov	 DWORD PTR __Precision$1$[ebp], eax
$LN2@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3955 :         if (_Newsize <= _Old_size) {

  00119	8b 45 e0	 mov	 eax, DWORD PTR __Buf$[ebp+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1375 :         _Buf.resize(_Bufsize + 50); // add fudge factor

  0011c	83 c1 32	 add	 ecx, 50			; 00000032H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3955 :         if (_Newsize <= _Old_size) {

  0011f	3b c8		 cmp	 ecx, eax
  00121	77 14		 ja	 SHORT $LN22@do_put

; 2319 :         return _BUF_SIZE <= _Myres;

  00123	83 7d e4 10	 cmp	 DWORD PTR __Buf$[ebp+20], 16 ; 00000010H

; 2296 :         value_type* _Result = _Bx._Buf;

  00127	8d 45 d0	 lea	 eax, DWORD PTR __Buf$[ebp]

; 4591 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());

  0012a	89 4d e0	 mov	 DWORD PTR __Buf$[ebp+16], ecx

; 2297 :         if (_Large_string_engaged()) {

  0012d	0f 43 45 d0	 cmovae	 eax, DWORD PTR __Buf$[ebp]

; 4591 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());

  00131	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 3957 :         } else {

  00135	eb 0d		 jmp	 SHORT $LN23@do_put
$LN22@do_put:

; 3958 :             append(_Newsize - _Old_size, _Ch);

  00137	2b c8		 sub	 ecx, eax
  00139	6a 00		 push	 0
  0013b	51		 push	 ecx
  0013c	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  0013f	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN23@do_put:

; 2319 :         return _BUF_SIZE <= _Myres;

  00144	83 7d e4 10	 cmp	 DWORD PTR __Buf$[ebp+20], 16 ; 00000010H

; 2296 :         value_type* _Result = _Bx._Buf;

  00148	8d 75 d0	 lea	 esi, DWORD PTR __Buf$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1376 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

  0014b	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR __Val$[ebp]
  00150	8d 45 e8	 lea	 eax, DWORD PTR __Fmt$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2297 :         if (_Large_string_engaged()) {

  00153	0f 43 75 d0	 cmovae	 esi, DWORD PTR __Buf$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1376 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

  00157	83 ec 08	 sub	 esp, 8
  0015a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0015f	ff 75 cc	 push	 DWORD PTR __Precision$1$[ebp]
  00162	ff 77 14	 push	 DWORD PTR [edi+20]
  00165	6a 4c		 push	 76			; 0000004cH
  00167	50		 push	 eax
  00168	ff 75 c0	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  0016b	e8 00 00 00 00	 call	 ?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
  00170	83 c4 10	 add	 esp, 16			; 00000010H
  00173	50		 push	 eax
  00174	ff 75 e0	 push	 DWORD PTR __Buf$[ebp+16]
  00177	56		 push	 esi
  00178	e8 00 00 00 00	 call	 _sprintf_s
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  0017d	83 7d e4 10	 cmp	 DWORD PTR __Buf$[ebp+20], 16 ; 00000010H

; 2305 :         const value_type* _Result = _Bx._Buf;

  00181	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1379 :         return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);

  00184	8b 75 b4	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  00187	0f 43 4d d0	 cmovae	 ecx, DWORD PTR __Buf$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1379 :         return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);

  0018b	50		 push	 eax
  0018c	51		 push	 ecx
  0018d	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00190	57		 push	 edi
  00191	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00194	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00197	56		 push	 esi
  00198	ff 75 c0	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  0019b	e8 00 00 00 00	 call	 ?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
  001a0	83 c4 38	 add	 esp, 56			; 00000038H
  001a3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  001aa	8b 55 e4	 mov	 edx, DWORD PTR __Buf$[ebp+20]
  001ad	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  001b0	72 28		 jb	 SHORT $LN68@do_put
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001b2	8b 4d d0	 mov	 ecx, DWORD PTR __Buf$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  001b5	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001b6	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  001b8	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001be	72 10		 jb	 SHORT $LN67@do_put

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001c0	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001c3	83 c2 23	 add	 edx, 35			; 00000023H
  001c6	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001c8	83 c0 fc	 add	 eax, -4			; fffffffcH
  001cb	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001ce	77 3b		 ja	 SHORT $LN76@do_put
$LN67@do_put:

; 264  :         ::operator delete(_Ptr, _Bytes);

  001d0	52		 push	 edx
  001d1	51		 push	 ecx
  001d2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001d7	83 c4 08	 add	 esp, 8
$LN68@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  001da	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR __Buf$[ebp+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1379 :         return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);

  001e1	8b c6		 mov	 eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  001e3	c7 45 e4 0f 00
	00 00		 mov	 DWORD PTR __Buf$[ebp+20], 15 ; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  001ea	c6 45 d0 00	 mov	 BYTE PTR __Buf$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1380 :     }

  001ee	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001f1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001f8	59		 pop	 ecx
  001f9	5f		 pop	 edi
  001fa	5e		 pop	 esi
  001fb	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001fe	33 cd		 xor	 ecx, ebp
  00200	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00205	8b e5		 mov	 esp, ebp
  00207	5d		 pop	 ebp
  00208	c2 1c 00	 ret	 28			; 0000001cH
$LN76@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0020b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN74@do_put:
  00210	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
_TEXT	SEGMENT
__Precision$ = -84					; size = 8
___$ReturnUdt$GSCopy$1$ = -76				; size = 4
__Bufsize$1$ = -72					; size = 4
__Ptwo$2 = -68						; size = 4
_this$GSCopy$1$ = -64					; size = 4
tv414 = -60						; size = 4
tv400 = -56						; size = 4
__Precision$1$ = -52					; size = 4
__Buf$ = -48						; size = 24
__Fmt$ = -24						; size = 8
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1335 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const { // put formatted double to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d c0	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00030	8b 7d 14	 mov	 edi, DWORD PTR __Iosbase$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00033	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR __Buf$[ebp], 0

; 2355 :     size_type _Mysize = 0; // current length of string

  0003a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR __Buf$[ebp+16], 0

; 2356 :     size_type _Myres  = 0; // current storage reserved for string

  00041	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __Buf$[ebp+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1335 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const { // put formatted double to _Dest

  00048	89 45 b4	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4596 :         _My_data._Mysize = 0;

  0004b	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR __Buf$[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00052	c7 45 e4 0f 00
	00 00		 mov	 DWORD PTR __Buf$[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00059	c6 45 d0 00	 mov	 BYTE PTR __Buf$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1336 :         string _Buf;

  0005d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1337 :         char _Fmt[8];
; 1338 :         const auto _Float_flags     = _Iosbase.flags() & ios_base::floatfield;

  00064	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  00067	81 e6 00 30 00
	00		 and	 esi, 12288		; 00003000H

; 1339 :         const bool _Is_fixed        = _Float_flags == ios_base::fixed;
; 1340 :         const bool _Is_hex          = _Float_flags == (ios_base::fixed | ios_base::scientific);
; 1341 :         const streamsize _Precision = _Is_hex ? -1 : _Iosbase.precision(); // precision setting

  0006d	56		 push	 esi
  0006e	81 fe 00 30 00
	00		 cmp	 esi, 12288		; 00003000H
  00074	75 21		 jne	 SHORT $LN4@do_put
  00076	6a ff		 push	 -1
  00078	6a ff		 push	 -1
  0007a	c7 45 cc ff ff
	ff ff		 mov	 DWORD PTR __Precision$1$[ebp], -1
  00081	c7 45 b0 ff ff
	ff ff		 mov	 DWORD PTR __Precision$[ebp+4], -1
  00088	e8 00 00 00 00	 call	 ??$_Float_put_desired_precision@N@std@@YAH_JH@Z ; std::_Float_put_desired_precision<double>
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00090	8b c8		 mov	 ecx, eax
  00092	e9 82 00 00 00	 jmp	 $LN2@do_put
$LN4@do_put:
  00097	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  0009a	8b 47 18	 mov	 eax, DWORD PTR [edi+24]

; 1342 :         const int _Desired_precision =

  0009d	51		 push	 ecx
  0009e	50		 push	 eax
  0009f	89 45 c8	 mov	 DWORD PTR tv400[ebp], eax
  000a2	e8 00 00 00 00	 call	 ??$_Float_put_desired_precision@N@std@@YAH_JH@Z ; std::_Float_put_desired_precision<double>

; 1343 :             _Float_put_desired_precision<double>(_Precision, _Float_flags); // desired precision
; 1344 :         size_t _Bufsize = static_cast<size_t>(_Desired_precision);

  000a7	8b c8		 mov	 ecx, eax
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ac	8b 45 c8	 mov	 eax, DWORD PTR tv400[ebp]
  000af	89 4d b8	 mov	 DWORD PTR __Bufsize$1$[ebp], ecx
  000b2	89 45 cc	 mov	 DWORD PTR __Precision$1$[ebp], eax

; 1345 :         if (_Is_fixed && 1e10 < _CSTD fabs(_Val)) { // f or F format

  000b5	81 fe 00 20 00
	00		 cmp	 esi, 8192		; 00002000H
  000bb	75 5c		 jne	 SHORT $LN2@do_put
  000bd	f2 0f 10 4d 1c	 movsd	 xmm1, QWORD PTR __Val$[ebp]
  000c2	0f 28 c1	 movaps	 xmm0, xmm1
  000c5	89 45 cc	 mov	 DWORD PTR __Precision$1$[ebp], eax
  000c8	0f 54 05 00 00
	00 00		 andps	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  000cf	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@4202a05f20000000
  000d7	76 40		 jbe	 SHORT $LN2@do_put

; 1346 :             int _Ptwo;
; 1347 :             (void) _CSTD frexp(_Val, &_Ptwo);

  000d9	8d 45 bc	 lea	 eax, DWORD PTR __Ptwo$2[ebp]
  000dc	50		 push	 eax
  000dd	83 ec 08	 sub	 esp, 8
  000e0	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  000e5	e8 00 00 00 00	 call	 _frexp

; 1348 :             _Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

  000ea	8b 45 bc	 mov	 eax, DWORD PTR __Ptwo$2[ebp]
  000ed	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f0	99		 cdq
  000f1	dd d8		 fstp	 ST(0)
  000f3	33 c2		 xor	 eax, edx
  000f5	2b c2		 sub	 eax, edx
  000f7	69 c8 97 75 00
	00		 imul	 ecx, eax, 30103
  000fd	b8 89 b5 f8 14	 mov	 eax, 351843721		; 14f8b589H
  00102	f7 e9		 imul	 ecx
  00104	8b 4d b8	 mov	 ecx, DWORD PTR __Bufsize$1$[ebp]
  00107	c1 fa 0d	 sar	 edx, 13			; 0000000dH
  0010a	8b c2		 mov	 eax, edx
  0010c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0010f	03 c2		 add	 eax, edx
  00111	03 c8		 add	 ecx, eax
  00113	8b 45 c8	 mov	 eax, DWORD PTR tv400[ebp]
  00116	89 45 cc	 mov	 DWORD PTR __Precision$1$[ebp], eax
$LN2@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3955 :         if (_Newsize <= _Old_size) {

  00119	8b 45 e0	 mov	 eax, DWORD PTR __Buf$[ebp+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1351 :         _Buf.resize(_Bufsize + 50); // add fudge factor

  0011c	83 c1 32	 add	 ecx, 50			; 00000032H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3955 :         if (_Newsize <= _Old_size) {

  0011f	3b c8		 cmp	 ecx, eax
  00121	77 14		 ja	 SHORT $LN18@do_put

; 2319 :         return _BUF_SIZE <= _Myres;

  00123	83 7d e4 10	 cmp	 DWORD PTR __Buf$[ebp+20], 16 ; 00000010H

; 2296 :         value_type* _Result = _Bx._Buf;

  00127	8d 45 d0	 lea	 eax, DWORD PTR __Buf$[ebp]

; 4591 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());

  0012a	89 4d e0	 mov	 DWORD PTR __Buf$[ebp+16], ecx

; 2297 :         if (_Large_string_engaged()) {

  0012d	0f 43 45 d0	 cmovae	 eax, DWORD PTR __Buf$[ebp]

; 4591 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());

  00131	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 3957 :         } else {

  00135	eb 0d		 jmp	 SHORT $LN19@do_put
$LN18@do_put:

; 3958 :             append(_Newsize - _Old_size, _Ch);

  00137	2b c8		 sub	 ecx, eax
  00139	6a 00		 push	 0
  0013b	51		 push	 ecx
  0013c	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  0013f	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN19@do_put:

; 2319 :         return _BUF_SIZE <= _Myres;

  00144	83 7d e4 10	 cmp	 DWORD PTR __Buf$[ebp+20], 16 ; 00000010H

; 2296 :         value_type* _Result = _Bx._Buf;

  00148	8d 75 d0	 lea	 esi, DWORD PTR __Buf$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1352 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

  0014b	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR __Val$[ebp]
  00150	8d 45 e8	 lea	 eax, DWORD PTR __Fmt$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2297 :         if (_Large_string_engaged()) {

  00153	0f 43 75 d0	 cmovae	 esi, DWORD PTR __Buf$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1352 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

  00157	83 ec 08	 sub	 esp, 8
  0015a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0015f	ff 75 cc	 push	 DWORD PTR __Precision$1$[ebp]
  00162	ff 77 14	 push	 DWORD PTR [edi+20]
  00165	6a 00		 push	 0
  00167	50		 push	 eax
  00168	ff 75 c0	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  0016b	e8 00 00 00 00	 call	 ?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
  00170	83 c4 10	 add	 esp, 16			; 00000010H
  00173	50		 push	 eax
  00174	ff 75 e0	 push	 DWORD PTR __Buf$[ebp+16]
  00177	56		 push	 esi
  00178	e8 00 00 00 00	 call	 _sprintf_s
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  0017d	83 7d e4 10	 cmp	 DWORD PTR __Buf$[ebp+20], 16 ; 00000010H

; 2305 :         const value_type* _Result = _Bx._Buf;

  00181	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1355 :         return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);

  00184	8b 75 b4	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  00187	0f 43 4d d0	 cmovae	 ecx, DWORD PTR __Buf$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1355 :         return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);

  0018b	50		 push	 eax
  0018c	51		 push	 ecx
  0018d	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00190	57		 push	 edi
  00191	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00194	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00197	56		 push	 esi
  00198	ff 75 c0	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  0019b	e8 00 00 00 00	 call	 ?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
  001a0	83 c4 38	 add	 esp, 56			; 00000038H
  001a3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  001aa	8b 55 e4	 mov	 edx, DWORD PTR __Buf$[ebp+20]
  001ad	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  001b0	72 28		 jb	 SHORT $LN64@do_put
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001b2	8b 4d d0	 mov	 ecx, DWORD PTR __Buf$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  001b5	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001b6	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  001b8	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001be	72 10		 jb	 SHORT $LN63@do_put

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001c0	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001c3	83 c2 23	 add	 edx, 35			; 00000023H
  001c6	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001c8	83 c0 fc	 add	 eax, -4			; fffffffcH
  001cb	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001ce	77 3b		 ja	 SHORT $LN72@do_put
$LN63@do_put:

; 264  :         ::operator delete(_Ptr, _Bytes);

  001d0	52		 push	 edx
  001d1	51		 push	 ecx
  001d2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001d7	83 c4 08	 add	 esp, 8
$LN64@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  001da	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR __Buf$[ebp+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1355 :         return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);

  001e1	8b c6		 mov	 eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  001e3	c7 45 e4 0f 00
	00 00		 mov	 DWORD PTR __Buf$[ebp+20], 15 ; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  001ea	c6 45 d0 00	 mov	 BYTE PTR __Buf$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1356 :     }

  001ee	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001f1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001f8	59		 pop	 ecx
  001f9	5f		 pop	 edi
  001fa	5e		 pop	 esi
  001fb	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001fe	33 cd		 xor	 ecx, ebp
  00200	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00205	8b e5		 mov	 esp, ebp
  00207	5d		 pop	 ebp
  00208	c2 1c 00	 ret	 28			; 0000001cH
$LN72@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0020b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN70@do_put:
  00210	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
_TEXT	SEGMENT
_this$1$ = -84						; size = 4
tv247 = -80						; size = 4
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1326 :         unsigned long long _Val) const { // put formatted unsigned long long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1512 :         if (_Flags & ios_base::showpos) {

  00010	0f b6 45 f5	 movzx	 eax, BYTE PTR __Fmt$[ebp+1]

; 1326 :         unsigned long long _Val) const { // put formatted unsigned long long to _Dest

  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  00019	89 4d ac	 mov	 DWORD PTR _this$1$[ebp], ecx

; 1516 :         if (_Flags & ios_base::showbase) {

  0001c	8b 5d ac	 mov	 ebx, DWORD PTR _this$1$[ebp]
  0001f	c7 45 b0 2b 00
	00 00		 mov	 DWORD PTR tv247[ebp], 43 ; 0000002bH

; 1327 :         char _Buf[2 * _MAX_INT_DIG];
; 1328 :         char _Fmt[8];
; 1329 : 
; 1330 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00026	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 1512 :         if (_Flags & ios_base::showpos) {

  00029	8b d1		 mov	 edx, ecx
  0002b	83 e2 20	 and	 edx, 32			; 00000020H
  0002e	c6 45 f4 25	 mov	 BYTE PTR __Fmt$[ebp], 37 ; 00000025H

; 1326 :         unsigned long long _Val) const { // put formatted unsigned long long to _Dest

  00032	57		 push	 edi

; 1512 :         if (_Flags & ios_base::showpos) {

  00033	0f 45 45 b0	 cmovne	 eax, DWORD PTR tv247[ebp]

; 1513 :             *_Ptr++ = '+';
; 1514 :         }
; 1515 : 
; 1516 :         if (_Flags & ios_base::showbase) {

  00037	f7 c2 20 00 00
	00		 test	 edx, 32			; 00000020H

; 1326 :         unsigned long long _Val) const { // put formatted unsigned long long to _Dest

  0003d	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]

; 1516 :         if (_Flags & ios_base::showbase) {

  00040	8d 55 f6	 lea	 edx, DWORD PTR __Fmt$[ebp+2]
  00043	88 45 f5	 mov	 BYTE PTR __Fmt$[ebp+1], al
  00046	8d 45 f5	 lea	 eax, DWORD PTR __Fmt$[ebp+1]
  00049	0f 45 c2	 cmovne	 eax, edx
  0004c	f6 c1 08	 test	 cl, 8
  0004f	74 04		 je	 SHORT $LN5@do_put

; 1517 :             *_Ptr++ = '#';

  00051	c6 00 23	 mov	 BYTE PTR [eax], 35	; 00000023H
  00054	40		 inc	 eax
$LN5@do_put:

; 1518 :         }
; 1519 : 
; 1520 :         if (_Spec[0] != 'L') {
; 1521 :             *_Ptr++ = _Spec[0]; // qualifier
; 1522 :         } else { // change L to I64
; 1523 :             *_Ptr++ = 'I';
; 1524 :             *_Ptr++ = '6';
; 1525 :             *_Ptr++ = '4';
; 1526 :         }
; 1527 : 
; 1528 :         ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;

  00055	8b d1		 mov	 edx, ecx
  00057	66 c7 00 49 36	 mov	 WORD PTR [eax], 13897	; 00003649H
  0005c	81 e2 00 0e 00
	00		 and	 edx, 3584		; 00000e00H
  00062	c6 40 02 34	 mov	 BYTE PTR [eax+2], 52	; 00000034H

; 1529 :         *_Ptr++                       = _Basefield == ios_base::oct  ? 'o'

  00066	81 fa 00 04 00
	00		 cmp	 edx, 1024		; 00000400H
  0006c	75 04		 jne	 SHORT $LN11@do_put
  0006e	b1 6f		 mov	 cl, 111			; 0000006fH
  00070	eb 17		 jmp	 SHORT $LN10@do_put
$LN11@do_put:
  00072	81 fa 00 08 00
	00		 cmp	 edx, 2048		; 00000800H
  00078	74 04		 je	 SHORT $LN9@do_put
  0007a	b1 75		 mov	 cl, 117			; 00000075H
  0007c	eb 0b		 jmp	 SHORT $LN10@do_put
$LN9@do_put:
  0007e	c0 e1 03	 shl	 cl, 3
  00081	f6 d1		 not	 cl
  00083	80 e1 20	 and	 cl, 32			; 00000020H
  00086	80 c9 58	 or	 cl, 88			; 00000058H
$LN10@do_put:

; 1327 :         char _Buf[2 * _MAX_INT_DIG];
; 1328 :         char _Fmt[8];
; 1329 : 
; 1330 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00089	ff 75 20	 push	 DWORD PTR __Val$[ebp+4]

; 1529 :         *_Ptr++                       = _Basefield == ios_base::oct  ? 'o'

  0008c	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 1327 :         char _Buf[2 * _MAX_INT_DIG];
; 1328 :         char _Fmt[8];
; 1329 : 
; 1330 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  0008f	ff 75 1c	 push	 DWORD PTR __Val$[ebp]

; 1533 :         *_Ptr                         = '\0';

  00092	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 1327 :         char _Buf[2 * _MAX_INT_DIG];
; 1328 :         char _Fmt[8];
; 1329 : 
; 1330 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00096	8d 45 f4	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00099	50		 push	 eax
  0009a	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  0009d	6a 40		 push	 64			; 00000040H
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 _sprintf_s
  000a5	50		 push	 eax
  000a6	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  000a9	50		 push	 eax
  000aa	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  000ad	56		 push	 esi
  000ae	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  000b1	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  000b4	57		 push	 edi
  000b5	53		 push	 ebx
  000b6	e8 00 00 00 00	 call	 ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1331 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Lu", _Iosbase.flags()), _Val)));
; 1332 :     }

  000bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000be	83 c4 34	 add	 esp, 52			; 00000034H
  000c1	8b c7		 mov	 eax, edi
  000c3	33 cd		 xor	 ecx, ebp
  000c5	5f		 pop	 edi
  000c6	5e		 pop	 esi
  000c7	5b		 pop	 ebx
  000c8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c2 1c 00	 ret	 28			; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
_TEXT	SEGMENT
_this$1$ = -84						; size = 4
tv247 = -80						; size = 4
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1317 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long long _Val) const { // put formatted long long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1512 :         if (_Flags & ios_base::showpos) {

  00010	0f b6 45 f5	 movzx	 eax, BYTE PTR __Fmt$[ebp+1]

; 1317 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long long _Val) const { // put formatted long long to _Dest

  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  00019	89 4d ac	 mov	 DWORD PTR _this$1$[ebp], ecx

; 1516 :         if (_Flags & ios_base::showbase) {

  0001c	8b 5d ac	 mov	 ebx, DWORD PTR _this$1$[ebp]
  0001f	c7 45 b0 2b 00
	00 00		 mov	 DWORD PTR tv247[ebp], 43 ; 0000002bH

; 1318 :         char _Buf[2 * _MAX_INT_DIG];
; 1319 :         char _Fmt[8];
; 1320 : 
; 1321 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00026	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 1512 :         if (_Flags & ios_base::showpos) {

  00029	8b d1		 mov	 edx, ecx
  0002b	83 e2 20	 and	 edx, 32			; 00000020H
  0002e	c6 45 f4 25	 mov	 BYTE PTR __Fmt$[ebp], 37 ; 00000025H

; 1317 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long long _Val) const { // put formatted long long to _Dest

  00032	57		 push	 edi

; 1512 :         if (_Flags & ios_base::showpos) {

  00033	0f 45 45 b0	 cmovne	 eax, DWORD PTR tv247[ebp]

; 1513 :             *_Ptr++ = '+';
; 1514 :         }
; 1515 : 
; 1516 :         if (_Flags & ios_base::showbase) {

  00037	f7 c2 20 00 00
	00		 test	 edx, 32			; 00000020H

; 1317 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long long _Val) const { // put formatted long long to _Dest

  0003d	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]

; 1516 :         if (_Flags & ios_base::showbase) {

  00040	8d 55 f6	 lea	 edx, DWORD PTR __Fmt$[ebp+2]
  00043	88 45 f5	 mov	 BYTE PTR __Fmt$[ebp+1], al
  00046	8d 45 f5	 lea	 eax, DWORD PTR __Fmt$[ebp+1]
  00049	0f 45 c2	 cmovne	 eax, edx
  0004c	f6 c1 08	 test	 cl, 8
  0004f	74 04		 je	 SHORT $LN5@do_put

; 1517 :             *_Ptr++ = '#';

  00051	c6 00 23	 mov	 BYTE PTR [eax], 35	; 00000023H
  00054	40		 inc	 eax
$LN5@do_put:

; 1518 :         }
; 1519 : 
; 1520 :         if (_Spec[0] != 'L') {
; 1521 :             *_Ptr++ = _Spec[0]; // qualifier
; 1522 :         } else { // change L to I64
; 1523 :             *_Ptr++ = 'I';
; 1524 :             *_Ptr++ = '6';
; 1525 :             *_Ptr++ = '4';
; 1526 :         }
; 1527 : 
; 1528 :         ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;

  00055	8b d1		 mov	 edx, ecx
  00057	66 c7 00 49 36	 mov	 WORD PTR [eax], 13897	; 00003649H
  0005c	81 e2 00 0e 00
	00		 and	 edx, 3584		; 00000e00H
  00062	c6 40 02 34	 mov	 BYTE PTR [eax+2], 52	; 00000034H

; 1529 :         *_Ptr++                       = _Basefield == ios_base::oct  ? 'o'

  00066	81 fa 00 04 00
	00		 cmp	 edx, 1024		; 00000400H
  0006c	75 04		 jne	 SHORT $LN11@do_put
  0006e	b1 6f		 mov	 cl, 111			; 0000006fH
  00070	eb 17		 jmp	 SHORT $LN10@do_put
$LN11@do_put:
  00072	81 fa 00 08 00
	00		 cmp	 edx, 2048		; 00000800H
  00078	74 04		 je	 SHORT $LN9@do_put
  0007a	b1 64		 mov	 cl, 100			; 00000064H
  0007c	eb 0b		 jmp	 SHORT $LN10@do_put
$LN9@do_put:
  0007e	c0 e1 03	 shl	 cl, 3
  00081	f6 d1		 not	 cl
  00083	80 e1 20	 and	 cl, 32			; 00000020H
  00086	80 c9 58	 or	 cl, 88			; 00000058H
$LN10@do_put:

; 1318 :         char _Buf[2 * _MAX_INT_DIG];
; 1319 :         char _Fmt[8];
; 1320 : 
; 1321 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00089	ff 75 20	 push	 DWORD PTR __Val$[ebp+4]

; 1529 :         *_Ptr++                       = _Basefield == ios_base::oct  ? 'o'

  0008c	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 1318 :         char _Buf[2 * _MAX_INT_DIG];
; 1319 :         char _Fmt[8];
; 1320 : 
; 1321 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  0008f	ff 75 1c	 push	 DWORD PTR __Val$[ebp]

; 1533 :         *_Ptr                         = '\0';

  00092	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 1318 :         char _Buf[2 * _MAX_INT_DIG];
; 1319 :         char _Fmt[8];
; 1320 : 
; 1321 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00096	8d 45 f4	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00099	50		 push	 eax
  0009a	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  0009d	6a 40		 push	 64			; 00000040H
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 _sprintf_s
  000a5	50		 push	 eax
  000a6	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  000a9	50		 push	 eax
  000aa	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  000ad	56		 push	 esi
  000ae	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  000b1	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  000b4	57		 push	 edi
  000b5	53		 push	 ebx
  000b6	e8 00 00 00 00	 call	 ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1322 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Ld", _Iosbase.flags()), _Val)));
; 1323 :     }

  000bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000be	83 c4 34	 add	 esp, 52			; 00000034H
  000c1	8b c7		 mov	 eax, edi
  000c3	33 cd		 xor	 ecx, ebp
  000c5	5f		 pop	 edi
  000c6	5e		 pop	 esi
  000c7	5b		 pop	 ebx
  000c8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c2 1c 00	 ret	 28			; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
_TEXT	SEGMENT
_this$1$ = -84						; size = 4
tv251 = -80						; size = 4
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1308 :         unsigned long _Val) const { // put formatted unsigned long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1512 :         if (_Flags & ios_base::showpos) {

  00010	0f b6 45 f5	 movzx	 eax, BYTE PTR __Fmt$[ebp+1]

; 1308 :         unsigned long _Val) const { // put formatted unsigned long to _Dest

  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  00019	89 4d ac	 mov	 DWORD PTR _this$1$[ebp], ecx

; 1516 :         if (_Flags & ios_base::showbase) {

  0001c	8b 5d ac	 mov	 ebx, DWORD PTR _this$1$[ebp]
  0001f	c7 45 b0 2b 00
	00 00		 mov	 DWORD PTR tv251[ebp], 43 ; 0000002bH

; 1309 :         char _Buf[2 * _MAX_INT_DIG];
; 1310 :         char _Fmt[6];
; 1311 : 
; 1312 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00026	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 1512 :         if (_Flags & ios_base::showpos) {

  00029	8b d1		 mov	 edx, ecx
  0002b	83 e2 20	 and	 edx, 32			; 00000020H
  0002e	c6 45 f4 25	 mov	 BYTE PTR __Fmt$[ebp], 37 ; 00000025H

; 1308 :         unsigned long _Val) const { // put formatted unsigned long to _Dest

  00032	57		 push	 edi

; 1512 :         if (_Flags & ios_base::showpos) {

  00033	0f 45 45 b0	 cmovne	 eax, DWORD PTR tv251[ebp]

; 1513 :             *_Ptr++ = '+';
; 1514 :         }
; 1515 : 
; 1516 :         if (_Flags & ios_base::showbase) {

  00037	f7 c2 20 00 00
	00		 test	 edx, 32			; 00000020H

; 1308 :         unsigned long _Val) const { // put formatted unsigned long to _Dest

  0003d	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]

; 1516 :         if (_Flags & ios_base::showbase) {

  00040	8d 55 f6	 lea	 edx, DWORD PTR __Fmt$[ebp+2]
  00043	88 45 f5	 mov	 BYTE PTR __Fmt$[ebp+1], al
  00046	8d 45 f5	 lea	 eax, DWORD PTR __Fmt$[ebp+1]
  00049	0f 45 c2	 cmovne	 eax, edx
  0004c	f6 c1 08	 test	 cl, 8
  0004f	74 04		 je	 SHORT $LN5@do_put

; 1517 :             *_Ptr++ = '#';

  00051	c6 00 23	 mov	 BYTE PTR [eax], 35	; 00000023H
  00054	40		 inc	 eax
$LN5@do_put:

; 1518 :         }
; 1519 : 
; 1520 :         if (_Spec[0] != 'L') {
; 1521 :             *_Ptr++ = _Spec[0]; // qualifier
; 1522 :         } else { // change L to I64
; 1523 :             *_Ptr++ = 'I';
; 1524 :             *_Ptr++ = '6';
; 1525 :             *_Ptr++ = '4';
; 1526 :         }
; 1527 : 
; 1528 :         ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;

  00055	8b d1		 mov	 edx, ecx
  00057	c6 00 6c	 mov	 BYTE PTR [eax], 108	; 0000006cH
  0005a	81 e2 00 0e 00
	00		 and	 edx, 3584		; 00000e00H

; 1529 :         *_Ptr++                       = _Basefield == ios_base::oct  ? 'o'

  00060	81 fa 00 04 00
	00		 cmp	 edx, 1024		; 00000400H
  00066	75 04		 jne	 SHORT $LN11@do_put
  00068	b1 6f		 mov	 cl, 111			; 0000006fH
  0006a	eb 17		 jmp	 SHORT $LN10@do_put
$LN11@do_put:
  0006c	81 fa 00 08 00
	00		 cmp	 edx, 2048		; 00000800H
  00072	74 04		 je	 SHORT $LN9@do_put
  00074	b1 75		 mov	 cl, 117			; 00000075H
  00076	eb 0b		 jmp	 SHORT $LN10@do_put
$LN9@do_put:
  00078	c0 e1 03	 shl	 cl, 3
  0007b	f6 d1		 not	 cl
  0007d	80 e1 20	 and	 cl, 32			; 00000020H
  00080	80 c9 58	 or	 cl, 88			; 00000058H
$LN10@do_put:

; 1309 :         char _Buf[2 * _MAX_INT_DIG];
; 1310 :         char _Fmt[6];
; 1311 : 
; 1312 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00083	ff 75 1c	 push	 DWORD PTR __Val$[ebp]

; 1529 :         *_Ptr++                       = _Basefield == ios_base::oct  ? 'o'

  00086	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 1530 :                                       : _Basefield != ios_base::hex  ? _Spec[1] // 'd' or 'u'
; 1531 :                                       : _Flags & ios_base::uppercase ? 'X'
; 1532 :                                                                      : 'x';
; 1533 :         *_Ptr                         = '\0';

  00089	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0

; 1309 :         char _Buf[2 * _MAX_INT_DIG];
; 1310 :         char _Fmt[6];
; 1311 : 
; 1312 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  0008d	8d 45 f4	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00090	50		 push	 eax
  00091	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00094	6a 40		 push	 64			; 00000040H
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 _sprintf_s
  0009c	50		 push	 eax
  0009d	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  000a0	50		 push	 eax
  000a1	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  000a4	56		 push	 esi
  000a5	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  000a8	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  000ab	57		 push	 edi
  000ac	53		 push	 ebx
  000ad	e8 00 00 00 00	 call	 ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1313 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "lu", _Iosbase.flags()), _Val)));
; 1314 :     }

  000b2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b5	83 c4 30	 add	 esp, 48			; 00000030H
  000b8	8b c7		 mov	 eax, edi
  000ba	33 cd		 xor	 ecx, ebp
  000bc	5f		 pop	 edi
  000bd	5e		 pop	 esi
  000be	5b		 pop	 ebx
  000bf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c2 18 00	 ret	 24			; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
_TEXT	SEGMENT
_this$1$ = -84						; size = 4
tv251 = -80						; size = 4
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1299 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const { // put formatted long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1512 :         if (_Flags & ios_base::showpos) {

  00010	0f b6 45 f5	 movzx	 eax, BYTE PTR __Fmt$[ebp+1]

; 1299 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const { // put formatted long to _Dest

  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  00019	89 4d ac	 mov	 DWORD PTR _this$1$[ebp], ecx

; 1516 :         if (_Flags & ios_base::showbase) {

  0001c	8b 5d ac	 mov	 ebx, DWORD PTR _this$1$[ebp]
  0001f	c7 45 b0 2b 00
	00 00		 mov	 DWORD PTR tv251[ebp], 43 ; 0000002bH

; 1300 :         char _Buf[2 * _MAX_INT_DIG];
; 1301 :         char _Fmt[6];
; 1302 : 
; 1303 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00026	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 1512 :         if (_Flags & ios_base::showpos) {

  00029	8b d1		 mov	 edx, ecx
  0002b	83 e2 20	 and	 edx, 32			; 00000020H
  0002e	c6 45 f4 25	 mov	 BYTE PTR __Fmt$[ebp], 37 ; 00000025H

; 1299 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const { // put formatted long to _Dest

  00032	57		 push	 edi

; 1512 :         if (_Flags & ios_base::showpos) {

  00033	0f 45 45 b0	 cmovne	 eax, DWORD PTR tv251[ebp]

; 1513 :             *_Ptr++ = '+';
; 1514 :         }
; 1515 : 
; 1516 :         if (_Flags & ios_base::showbase) {

  00037	f7 c2 20 00 00
	00		 test	 edx, 32			; 00000020H

; 1299 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const { // put formatted long to _Dest

  0003d	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]

; 1516 :         if (_Flags & ios_base::showbase) {

  00040	8d 55 f6	 lea	 edx, DWORD PTR __Fmt$[ebp+2]
  00043	88 45 f5	 mov	 BYTE PTR __Fmt$[ebp+1], al
  00046	8d 45 f5	 lea	 eax, DWORD PTR __Fmt$[ebp+1]
  00049	0f 45 c2	 cmovne	 eax, edx
  0004c	f6 c1 08	 test	 cl, 8
  0004f	74 04		 je	 SHORT $LN5@do_put

; 1517 :             *_Ptr++ = '#';

  00051	c6 00 23	 mov	 BYTE PTR [eax], 35	; 00000023H
  00054	40		 inc	 eax
$LN5@do_put:

; 1518 :         }
; 1519 : 
; 1520 :         if (_Spec[0] != 'L') {
; 1521 :             *_Ptr++ = _Spec[0]; // qualifier
; 1522 :         } else { // change L to I64
; 1523 :             *_Ptr++ = 'I';
; 1524 :             *_Ptr++ = '6';
; 1525 :             *_Ptr++ = '4';
; 1526 :         }
; 1527 : 
; 1528 :         ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;

  00055	8b d1		 mov	 edx, ecx
  00057	c6 00 6c	 mov	 BYTE PTR [eax], 108	; 0000006cH
  0005a	81 e2 00 0e 00
	00		 and	 edx, 3584		; 00000e00H

; 1529 :         *_Ptr++                       = _Basefield == ios_base::oct  ? 'o'

  00060	81 fa 00 04 00
	00		 cmp	 edx, 1024		; 00000400H
  00066	75 04		 jne	 SHORT $LN11@do_put
  00068	b1 6f		 mov	 cl, 111			; 0000006fH
  0006a	eb 17		 jmp	 SHORT $LN10@do_put
$LN11@do_put:
  0006c	81 fa 00 08 00
	00		 cmp	 edx, 2048		; 00000800H
  00072	74 04		 je	 SHORT $LN9@do_put
  00074	b1 64		 mov	 cl, 100			; 00000064H
  00076	eb 0b		 jmp	 SHORT $LN10@do_put
$LN9@do_put:
  00078	c0 e1 03	 shl	 cl, 3
  0007b	f6 d1		 not	 cl
  0007d	80 e1 20	 and	 cl, 32			; 00000020H
  00080	80 c9 58	 or	 cl, 88			; 00000058H
$LN10@do_put:

; 1300 :         char _Buf[2 * _MAX_INT_DIG];
; 1301 :         char _Fmt[6];
; 1302 : 
; 1303 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00083	ff 75 1c	 push	 DWORD PTR __Val$[ebp]

; 1529 :         *_Ptr++                       = _Basefield == ios_base::oct  ? 'o'

  00086	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 1530 :                                       : _Basefield != ios_base::hex  ? _Spec[1] // 'd' or 'u'
; 1531 :                                       : _Flags & ios_base::uppercase ? 'X'
; 1532 :                                                                      : 'x';
; 1533 :         *_Ptr                         = '\0';

  00089	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0

; 1300 :         char _Buf[2 * _MAX_INT_DIG];
; 1301 :         char _Fmt[6];
; 1302 : 
; 1303 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  0008d	8d 45 f4	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00090	50		 push	 eax
  00091	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00094	6a 40		 push	 64			; 00000040H
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 _sprintf_s
  0009c	50		 push	 eax
  0009d	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  000a0	50		 push	 eax
  000a1	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  000a4	56		 push	 esi
  000a5	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  000a8	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  000ab	57		 push	 edi
  000ac	53		 push	 ebx
  000ad	e8 00 00 00 00	 call	 ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1304 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "ld", _Iosbase.flags()), _Val)));
; 1305 :     }

  000b2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b5	83 c4 30	 add	 esp, 48			; 00000030H
  000b8	8b c7		 mov	 eax, edi
  000ba	33 cd		 xor	 ecx, ebp
  000bc	5f		 pop	 edi
  000bd	5e		 pop	 esi
  000be	5b		 pop	 ebx
  000bf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c2 18 00	 ret	 24			; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$1$ = -92				; size = 4
$T2 = -88						; size = 8
$T3 = -88						; size = 8
$T4 = -88						; size = 8
__Punct_fac$1$ = -80					; size = 4
_this$GSCopy$1$ = -76					; size = 4
__Fill$GSCopy$ = -72					; size = 1
$T5 = -68						; size = 4
$T6 = -64						; size = 24
$T7 = -64						; size = 24
__Str$8 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 1
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1267 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, bool _Val) const { // put formatted bool to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d b4	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0002d	8b 7d 14	 mov	 edi, DWORD PTR __Iosbase$[ebp]
  00030	8a 45 18	 mov	 al, BYTE PTR __Fill$[ebp]
  00033	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00036	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR $T5[ebp], 0

; 1268 :         if (!(_Iosbase.flags() & ios_base::boolalpha)) {

  0003d	f7 47 14 00 40
	00 00		 test	 DWORD PTR [edi+20], 16384 ; 00004000H
  00044	89 75 a4	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], esi
  00047	88 45 b8	 mov	 BYTE PTR __Fill$GSCopy$[ebp], al
  0004a	75 1a		 jne	 SHORT $LN2@do_put

; 1269 :             return do_put(_Dest, _Iosbase, _Fill, static_cast<long>(_Val));

  0004c	0f b6 45 1c	 movzx	 eax, BYTE PTR __Val$[ebp]
  00050	8b 11		 mov	 edx, DWORD PTR [ecx]
  00052	50		 push	 eax
  00053	ff 75 b8	 push	 DWORD PTR __Fill$GSCopy$[ebp]
  00056	57		 push	 edi
  00057	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0005a	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0005d	56		 push	 esi
  0005e	ff 52 24	 call	 DWORD PTR [edx+36]
  00061	e9 ff 01 00 00	 jmp	 $LN231@do_put
$LN2@do_put:

; 1271 :             const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

  00066	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 373  :         return *_Ploc;

  0006d	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 267  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  00070	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00073	89 4d ac	 mov	 DWORD PTR $T4[ebp+4], ecx

; 268  :         _Ptr->_Incref();

  00076	8b 01		 mov	 eax, DWORD PTR [ecx]
  00078	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1271 :             const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

  0007b	8d 45 a8	 lea	 eax, DWORD PTR $T4[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 373  :         return *_Ploc;

  0007e	c7 45 bc 01 00
	00 00		 mov	 DWORD PTR $T5[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1271 :             const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
  0008b	be 01 00 00 00	 mov	 esi, 1
  00090	8b c8		 mov	 ecx, eax
  00092	89 75 bc	 mov	 DWORD PTR $T5[ebp], esi
  00095	83 c4 04	 add	 esp, 4
  00098	83 e6 fe	 and	 esi, -2			; fffffffeH
  0009b	89 4d b0	 mov	 DWORD PTR __Punct_fac$1$[ebp], ecx
  0009e	89 75 bc	 mov	 DWORD PTR $T5[ebp], esi
  000a1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 351  :         if (_Ptr) {

  000a8	8b 55 ac	 mov	 edx, DWORD PTR $T4[ebp+4]
  000ab	85 d2		 test	 edx, edx
  000ad	74 18		 je	 SHORT $LN24@do_put

; 352  :             delete _Ptr->_Decref();

  000af	8b 02		 mov	 eax, DWORD PTR [edx]
  000b1	8b ca		 mov	 ecx, edx
  000b3	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000b6	ff d0		 call	 eax
  000b8	85 c0		 test	 eax, eax
  000ba	74 08		 je	 SHORT $LN228@do_put
  000bc	8b 10		 mov	 edx, DWORD PTR [eax]
  000be	8b c8		 mov	 ecx, eax
  000c0	6a 01		 push	 1
  000c2	ff 12		 call	 DWORD PTR [edx]
$LN228@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  000c4	8b 4d b0	 mov	 ecx, DWORD PTR __Punct_fac$1$[ebp]
$LN24@do_put:
  000c7	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR __Str$8[ebp], 0

; 2355 :     size_type _Mysize = 0; // current length of string

  000ce	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Str$8[ebp+16], 0

; 2356 :     size_type _Myres  = 0; // current storage reserved for string

  000d5	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Str$8[ebp+20], 0

; 4596 :         _My_data._Mysize = 0;

  000dc	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Str$8[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  000e3	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR __Str$8[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  000ea	c6 45 d8 00	 mov	 BYTE PTR __Str$8[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1272 :             basic_string<_Elem> _Str;

  000ee	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 1273 :             if (_Val) {

  000f5	80 7d 1c 00	 cmp	 BYTE PTR __Val$[ebp], 0
  000f9	74 18		 je	 SHORT $LN4@do_put

; 1274 :                 _Str.assign(_Punct_fac.truename());

  000fb	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 135  :         return do_truename();

  000ff	8d 55 c0	 lea	 edx, DWORD PTR $T7[ebp]
  00102	8b 01		 mov	 eax, DWORD PTR [ecx]
  00104	52		 push	 edx
  00105	ff 50 1c	 call	 DWORD PTR [eax+28]
  00108	83 ce 02	 or	 esi, 2
  0010b	89 75 bc	 mov	 DWORD PTR $T5[ebp], esi

; 1274 :                 _Str.assign(_Punct_fac.truename());

  0010e	83 e6 fd	 and	 esi, -3			; fffffffdH

; 1275 :             } else {

  00111	eb 16		 jmp	 SHORT $LN232@do_put
$LN4@do_put:

; 1276 :                 _Str.assign(_Punct_fac.falsename());

  00113	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 131  :         return do_falsename();

  00117	8d 55 c0	 lea	 edx, DWORD PTR $T6[ebp]
  0011a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0011c	52		 push	 edx
  0011d	ff 50 18	 call	 DWORD PTR [eax+24]
  00120	83 ce 04	 or	 esi, 4
  00123	89 75 bc	 mov	 DWORD PTR $T5[ebp], esi

; 1276 :                 _Str.assign(_Punct_fac.falsename());

  00126	83 e6 fb	 and	 esi, -5			; fffffffbH
$LN232@do_put:

; 1277 :             }
; 1278 : 
; 1279 :             size_t _Fillcount;
; 1280 :             if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Str.size()) {

  00129	0f 10 45 c0	 movups	 xmm0, XMMWORD PTR $T6[ebp]
  0012d	c6 45 d8 00	 mov	 BYTE PTR __Str$8[ebp], 0
  00131	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Str$8[ebp+16], 0
  00138	0f 11 45 d8	 movups	 XMMWORD PTR __Str$8[ebp], xmm0
  0013c	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR __Str$8[ebp+20], 15 ; 0000000fH
  00143	f3 0f 7e 45 d0	 movq	 xmm0, QWORD PTR $T6[ebp+16]
  00148	66 0f d6 45 e8	 movq	 QWORD PTR __Str$8[ebp+16], xmm0
  0014d	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T6[ebp+16], 0
  00154	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR $T6[ebp+20], 15 ; 0000000fH
  0015b	c6 45 c0 00	 mov	 BYTE PTR $T6[ebp], 0
  0015f	89 75 bc	 mov	 DWORD PTR $T5[ebp], esi
  00162	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00166	83 7f 24 00	 cmp	 DWORD PTR [edi+36], 0
  0016a	8b 77 20	 mov	 esi, DWORD PTR [edi+32]
  0016d	8b 45 e8	 mov	 eax, DWORD PTR __Str$8[ebp+16]
  00170	c6 45 c0 00	 mov	 BYTE PTR $T6[ebp], 0
  00174	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR $T6[ebp+20], 15 ; 0000000fH
  0017b	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T6[ebp+16], 0
  00182	7c 0e		 jl	 SHORT $LN8@do_put
  00184	7f 04		 jg	 SHORT $LN226@do_put
  00186	85 f6		 test	 esi, esi
  00188	74 08		 je	 SHORT $LN8@do_put
$LN226@do_put:
  0018a	3b f0		 cmp	 esi, eax
  0018c	76 04		 jbe	 SHORT $LN8@do_put

; 1282 :             } else {
; 1283 :                 _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Str.size();

  0018e	2b f0		 sub	 esi, eax
  00190	eb 02		 jmp	 SHORT $LN7@do_put
$LN8@do_put:

; 1281 :                 _Fillcount = 0;

  00192	33 f6		 xor	 esi, esi
$LN7@do_put:

; 1284 :             }
; 1285 : 
; 1286 :             if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left) { // put leading fill

  00194	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00197	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  0019c	83 f8 40	 cmp	 eax, 64			; 00000040H
  0019f	74 28		 je	 SHORT $LN227@do_put

; 1287 :                 _Dest      = _Rep(_Dest, _Fill, _Fillcount);

  001a1	56		 push	 esi
  001a2	ff 75 b8	 push	 DWORD PTR __Fill$GSCopy$[ebp]
  001a5	8d 45 a8	 lea	 eax, DWORD PTR $T3[ebp]
  001a8	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  001ab	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  001ae	50		 push	 eax
  001af	ff 75 b4	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  001b2	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  001b7	83 c4 18	 add	 esp, 24			; 00000018H

; 1288 :                 _Fillcount = 0;

  001ba	33 f6		 xor	 esi, esi
  001bc	8b 08		 mov	 ecx, DWORD PTR [eax]
  001be	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001c1	89 4d 0c	 mov	 DWORD PTR __Dest$[ebp], ecx
  001c4	89 55 10	 mov	 DWORD PTR __Dest$[ebp+4], edx
  001c7	eb 06		 jmp	 SHORT $LN9@do_put
$LN227@do_put:

; 1284 :             }
; 1285 : 
; 1286 :             if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left) { // put leading fill

  001c9	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp+4]
  001cc	8b 4d 0c	 mov	 ecx, DWORD PTR __Dest$[ebp]
$LN9@do_put:

; 1290 :             _Dest = _Put(_Dest, _Str.c_str(), _Str.size()); // put field

  001cf	ff 75 e8	 push	 DWORD PTR __Str$8[ebp+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  001d2	83 7d ec 10	 cmp	 DWORD PTR __Str$8[ebp+20], 16 ; 00000010H

; 2305 :         const value_type* _Result = _Bx._Buf;

  001d6	8d 45 d8	 lea	 eax, DWORD PTR __Str$8[ebp]

; 2306 :         if (_Large_string_engaged()) {

  001d9	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Str$8[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1290 :             _Dest = _Put(_Dest, _Str.c_str(), _Str.size()); // put field

  001dd	50		 push	 eax
  001de	52		 push	 edx
  001df	51		 push	 ecx
  001e0	8d 45 a8	 lea	 eax, DWORD PTR $T2[ebp]
  001e3	50		 push	 eax
  001e4	ff 75 b4	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  001e7	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put

; 1292 :             return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

  001ec	56		 push	 esi
  001ed	ff 75 b8	 push	 DWORD PTR __Fill$GSCopy$[ebp]
  001f0	8b 75 a4	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  001f3	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001f8	50		 push	 eax
  001f9	51		 push	 ecx
  001fa	56		 push	 esi
  001fb	ff 75 b4	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  001fe	89 4d 0c	 mov	 DWORD PTR __Dest$[ebp], ecx
  00201	89 45 10	 mov	 DWORD PTR __Dest$[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 368  :         _Wide                      = _Newwidth;

  00204	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], 0
  0020b	c7 47 24 00 00
	00 00		 mov	 DWORD PTR [edi+36], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1292 :             return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

  00212	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  00217	83 c4 30	 add	 esp, 48			; 00000030H
  0021a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00221	8b 45 ec	 mov	 eax, DWORD PTR __Str$8[ebp+20]
  00224	83 f8 10	 cmp	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00227	72 2a		 jb	 SHORT $LN222@do_put
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00229	8b 4d d8	 mov	 ecx, DWORD PTR __Str$8[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0022c	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0022f	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00231	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00237	72 10		 jb	 SHORT $LN221@do_put

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00239	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0023c	83 c2 23	 add	 edx, 35			; 00000023H
  0023f	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00241	83 c0 fc	 add	 eax, -4			; fffffffcH
  00244	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00247	77 3b		 ja	 SHORT $LN234@do_put
$LN221@do_put:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00249	52		 push	 edx
  0024a	51		 push	 ecx
  0024b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00250	83 c4 08	 add	 esp, 8
$LN222@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  00253	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Str$8[ebp+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0025a	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR __Str$8[ebp+20], 15 ; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00261	c6 45 d8 00	 mov	 BYTE PTR __Str$8[ebp], 0
$LN231@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1294 :     }

  00265	8b c6		 mov	 eax, esi
  00267	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0026a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00271	59		 pop	 ecx
  00272	5f		 pop	 edi
  00273	5e		 pop	 esi
  00274	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00277	33 cd		 xor	 ecx, ebp
  00279	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0027e	8b e5		 mov	 esp, ebp
  00280	5d		 pop	 ebp
  00281	c2 18 00	 ret	 24			; 00000018H
$LN234@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00284	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN230@do_put:
  00289	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$4:
  00000	8b 45 bc	 mov	 eax, DWORD PTR $T5[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN18@do_put
  0000c	83 65 bc fe	 and	 DWORD PTR $T5[ebp], -2	; fffffffeH
  00010	8d 4d a8	 lea	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
$LN18@do_put:
  00018	c3		 ret	 0
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$1:
  00019	8d 4d d8	 lea	 ecx, DWORD PTR __Str$8[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$5:
  00021	8b 45 bc	 mov	 eax, DWORD PTR $T5[ebp]
  00024	83 e0 02	 and	 eax, 2
  00027	0f 84 0c 00 00
	00		 je	 $LN39@do_put
  0002d	83 65 bc fd	 and	 DWORD PTR $T5[ebp], -3	; fffffffdH
  00031	8d 4d c0	 lea	 ecx, DWORD PTR $T7[ebp]
  00034	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN39@do_put:
  00039	c3		 ret	 0
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$6:
  0003a	8b 45 bc	 mov	 eax, DWORD PTR $T5[ebp]
  0003d	83 e0 04	 and	 eax, 4
  00040	0f 84 0c 00 00
	00		 je	 $LN117@do_put
  00046	83 65 bc fb	 and	 DWORD PTR $T5[ebp], -5	; fffffffbH
  0004a	8d 4d c0	 lea	 ecx, DWORD PTR $T6[ebp]
  0004d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN117@do_put:
  00052	c3		 ret	 0
  00053	cc		 int	 3
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z:
  00058	90		 npad	 1
  00059	90		 npad	 1
  0005a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0005e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00061	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  00064	33 c8		 xor	 ecx, eax
  00066	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006b	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0006e	33 c8		 xor	 ecx, eax
  00070	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00075	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
  0007a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT
; _this$ = ecx

; 1251 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const { // put formatted double to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1252 :         return do_put(_Dest, _Iosbase, _Fill, _Val);

  00003	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR __Val$[ebp]
  00008	83 ec 08	 sub	 esp, 8
  0000b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00012	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00015	ff 75 14	 push	 DWORD PTR __Iosbase$[ebp]
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0001b	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0001e	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00021	ff 50 14	 call	 DWORD PTR [eax+20]
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1253 :     }

  00027	5d		 pop	 ebp
  00028	c2 1c 00	 ret	 28			; 0000001cH
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 1207 :     virtual __CLR_OR_THIS_CALL ~num_put() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
  0002c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 155  :         virtual __CLR_OR_THIS_CALL ~facet() noexcept override {}

  00033	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
  00039	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00040	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1207 :     virtual __CLR_OR_THIS_CALL ~num_put() noexcept {}

  00046	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00049	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00050	59		 pop	 ecx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
__unwindfunclet$??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1_Facet_base@std@@UAE@XZ ; std::_Facet_base::~_Facet_base
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -80						; size = 52
__Lock$3 = -28						; size = 4
__Psave$1$ = -24					; size = 4
$T4 = -24						; size = 4
__Lock$5 = -20						; size = 4
$T6 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Psave_guard$7 = 8					; size = 4
__Loc$ = 8						; size = 4
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >, COMDAT

; 428  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	33 db		 xor	 ebx, ebx

; 429  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

  0002a	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0002d	53		 push	 ebx
  0002e	89 5d f0	 mov	 DWORD PTR $T6[ebp], ebx
  00031	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00036	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx

; 105  :             if (_Id == 0) { // still zero, allocate stamp

  00039	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id

; 430  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
  00044	89 45 e8	 mov	 DWORD PTR __Psave$1$[ebp], eax

; 105  :             if (_Id == 0) { // still zero, allocate stamp

  00047	85 ff		 test	 edi, edi
  00049	75 37		 jne	 SHORT $LN11@use_facet

; 106  :                 _BEGIN_LOCK(_LOCK_LOCALE)

  0004b	57		 push	 edi
  0004c	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  0004f	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00054	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 107  :                 if (_Id == 0) {

  00058	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, edi ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
  0005e	75 10		 jne	 SHORT $LN12@use_facet

; 108  :                     _Id = static_cast<size_t>(++_Id_cnt);

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00065	40		 inc	 eax
  00066	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  0006b	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, eax ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
$LN12@use_facet:

; 109  :                 }
; 110  :                 _END_LOCK()

  00070	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00074	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  00077	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0007c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
$LN11@use_facet:

; 374  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  00082	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00085	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00088	3b 79 0c	 cmp	 edi, DWORD PTR [ecx+12]
  0008b	73 10		 jae	 SHORT $LN20@use_facet
  0008d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00090	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]

; 375  :         if (_Facptr || !_Ptr->_Xparent) {

  00093	85 f6		 test	 esi, esi
  00095	0f 85 e8 00 00
	00		 jne	 $LN60@use_facet
  0009b	eb 02		 jmp	 SHORT $LN63@use_facet
$LN20@use_facet:

; 371  :     }
; 372  : 
; 373  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object
; 374  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  0009d	33 f6		 xor	 esi, esi
$LN63@use_facet:

; 375  :         if (_Facptr || !_Ptr->_Xparent) {

  0009f	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  000a3	74 10		 je	 SHORT $LN15@use_facet

; 376  :             return _Facptr; // found facet or not transparent
; 377  :         }
; 378  : 
; 379  :         // look in current locale
; 380  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

  000a5	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 381  :         if (_Id < _Ptr0->_Facetcount) {

  000aa	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  000ad	73 0e		 jae	 SHORT $LN64@use_facet

; 382  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

  000af	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000b2	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
$LN15@use_facet:

; 431  : 
; 432  :     const size_t _Id         = _Facet::id;
; 433  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);
; 434  : 
; 435  :     if (!_Pf) {

  000b5	85 f6		 test	 esi, esi
  000b7	0f 85 c6 00 00
	00		 jne	 $LN60@use_facet
$LN64@use_facet:

; 436  :         if (_Psave) {

  000bd	8b 45 e8	 mov	 eax, DWORD PTR __Psave$1$[ebp]
  000c0	85 c0		 test	 eax, eax
  000c2	74 07		 je	 SHORT $LN3@use_facet

; 437  :             _Pf = _Psave; // lazy facet already allocated

  000c4	8b f0		 mov	 esi, eax

; 438  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

  000c6	e9 b8 00 00 00	 jmp	 $LN60@use_facet
$LN3@use_facet:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1198 :             *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));

  000cb	6a 08		 push	 8
  000cd	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000d2	8b f0		 mov	 esi, eax
  000d4	83 c4 04	 add	 esp, 4
  000d7	89 75 e8	 mov	 DWORD PTR $T4[ebp], esi
  000da	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000de	85 f6		 test	 esi, esi
  000e0	74 5d		 je	 SHORT $LN25@use_facet
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 370  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  000e2	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  000e5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000e8	85 c9		 test	 ecx, ecx
  000ea	74 0c		 je	 SHORT $LN33@use_facet
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocinfo

; 109  :         return _Myptr ? _Myptr : &_Nul;

  000ec	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  000ef	85 c0		 test	 eax, eax
  000f1	75 0a		 jne	 SHORT $LN34@use_facet
  000f3	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 370  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  000f6	eb 05		 jmp	 SHORT $LN34@use_facet
$LN33@use_facet:
  000f8	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@@
$LN34@use_facet:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1198 :             *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));

  000fd	50		 push	 eax
  000fe	8d 4d b0	 lea	 ecx, DWORD PTR $T2[ebp]
  00101	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00106	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0010a	bb 01 00 00 00	 mov	 ebx, 1
  0010f	89 5d f0	 mov	 DWORD PTR $T6[ebp], ebx
  00112	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 153  :         {}

  00118	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
  0011f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@

; 111  :             }
; 112  :             return _Id;
; 113  :         }
; 114  : 
; 115  :     private:
; 116  :         size_t _Id; // the identifier stamp
; 117  : 
; 118  :         __PURE_APPDOMAIN_GLOBAL static int _Id_cnt;
; 119  :     };
; 120  : 
; 121  :     class _Locimp;
; 122  : 
; 123  :     // CLASS facet
; 124  :     class _CRTIMP2_PURE_IMPORT facet : public _Facet_base, public _Crt_new_delete {
; 125  :         // base class for all locale facets, performs reference counting
; 126  :     private:
; 127  :         friend struct _Facet_guard;
; 128  : 
; 129  :     public:
; 130  :         static size_t __CLRCALL_OR_CDECL _Getcat(const facet** = nullptr, const locale* = nullptr) {
; 131  :             // get category value, or -1 if no corresponding C category
; 132  :             return static_cast<size_t>(-1);
; 133  :         }
; 134  : 
; 135  :         virtual void __CLR_OR_THIS_CALL _Incref() noexcept override { // increment use count
; 136  :             _MT_INCR(_Myrefs);
; 137  :         }
; 138  : 
; 139  :         virtual _Facet_base* __CLR_OR_THIS_CALL _Decref() noexcept override { // decrement use count
; 140  :             if (_MT_DECR(_Myrefs) == 0) {
; 141  :                 return this;
; 142  :             }
; 143  : 
; 144  :             return nullptr;
; 145  :         }
; 146  : 
; 147  :     private:
; 148  :         _Atomic_counter_t _Myrefs; // the reference count
; 149  : 
; 150  :     protected:
; 151  :         explicit __CLR_OR_THIS_CALL facet(size_t _Initrefs = 0)
; 152  :             : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) // non-atomic initialization

  00125	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum

; 1218 :     __CLR_OR_THIS_CALL num_put(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs) {

  0012c	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
  00133	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@

; 1219 :         _Init(_Lobj);
; 1220 :     }

  00139	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 1198 :             *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));

  0013d	eb 02		 jmp	 SHORT $LN26@use_facet
$LN25@use_facet:
  0013f	33 f6		 xor	 esi, esi
$LN26@use_facet:
  00141	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00148	f6 c3 01	 test	 bl, 1
  0014b	74 0e		 je	 SHORT $LN30@use_facet
  0014d	83 e3 fe	 and	 ebx, -2			; fffffffeH
  00150	8d 4d b0	 lea	 ecx, DWORD PTR $T2[ebp]
  00153	89 5d f0	 mov	 DWORD PTR $T6[ebp], ebx
  00156	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN30@use_facet:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1370 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0015b	89 75 08	 mov	 DWORD PTR __Psave_guard$7[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 446  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

  0015e	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7

; 447  : 
; 448  : #if defined(_M_CEE)
; 449  :             _Facet_Register_m(_Pfmod);
; 450  : #else // defined(_M_CEE)
; 451  :             _Facet_Register(_Pfmod);

  00162	56		 push	 esi
  00163	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register

; 452  : #endif // defined(_M_CEE)
; 453  : 
; 454  :             _Pfmod->_Incref();

  00168	8b 06		 mov	 eax, DWORD PTR [esi]
  0016a	83 c4 04	 add	 esp, 4
  0016d	8b ce		 mov	 ecx, esi
  0016f	ff 50 04	 call	 DWORD PTR [eax+4]

; 455  :             _Facetptr<_Facet>::_Psave = _Psave;

  00172	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

  00178	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Psave_guard$7[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 459  :         }

  0017f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
$LN60@use_facet:

; 460  :     }
; 461  : 
; 462  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

  00183	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0018a	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0018d	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00192	8b c6		 mov	 eax, esi

; 463  :     _END_LOCK()
; 464  : } // end of use_facet body

  00194	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00197	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0019e	59		 pop	 ecx
  0019f	5f		 pop	 edi
  001a0	5e		 pop	 esi
  001a1	5b		 pop	 ebx
  001a2	8b e5		 mov	 esp, ebp
  001a4	5d		 pop	 ebp
  001a5	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$2:
  00008	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$3:
  00010	6a 08		 push	 8
  00012	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001b	83 c4 08	 add	 esp, 8
  0001e	c3		 ret	 0
__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$4:
  0001f	8b 45 f0	 mov	 eax, DWORD PTR $T6[ebp]
  00022	83 e0 01	 and	 eax, 1
  00025	0f 84 0c 00 00
	00		 je	 $LN29@use_facet
  0002b	83 65 f0 fe	 and	 DWORD PTR $T6[ebp], -2	; fffffffeH
  0002f	8d 4d b0	 lea	 ecx, DWORD PTR $T2[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN29@use_facet:
  00037	c3		 ret	 0
__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$6:
  00038	8b 4d e8	 mov	 ecx, DWORD PTR $T4[ebp]
  0003b	e9 00 00 00 00	 jmp	 ??1_Facet_base@std@@UAE@XZ ; std::_Facet_base::~_Facet_base
__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$5:
  00040	8b 4d e8	 mov	 ecx, DWORD PTR $T4[ebp]
  00043	e9 00 00 00 00	 jmp	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$1:
  00048	8d 4d 08	 lea	 ecx, DWORD PTR __Psave_guard$7[ebp]
  0004b	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
  00050	cc		 int	 3
  00051	cc		 int	 3
  00052	cc		 int	 3
  00053	cc		 int	 3
  00054	cc		 int	 3
__ehhandler$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z:
  00055	90		 npad	 1
  00056	90		 npad	 1
  00057	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0005b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0005e	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00061	33 c8		 xor	 ecx, eax
  00063	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00068	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
  0006d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 109  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 110  : #if !_HAS_EXCEPTIONS
; 111  :             const bool _Zero_uncaught_exceptions = true;
; 112  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 113  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  00030	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception

; 114  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 115  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 116  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 117  : 
; 118  :             if (_Zero_uncaught_exceptions) {

  00035	84 c0		 test	 al, al
  00037	75 07		 jne	 SHORT $LN2@sentry

; 119  :                 this->_Myostr._Osfx();

  00039	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0003b	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN2@sentry:

; 120  :             }
; 121  :         }

  00040	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

  00047	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00049	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004e	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]

; 80   :             if (_Rdbuf) {

  00052	85 c9		 test	 ecx, ecx
  00054	74 05		 je	 SHORT $LN6@sentry

; 81   :                 _Rdbuf->_Unlock();

  00056	8b 01		 mov	 eax, DWORD PTR [ecx]
  00058	ff 50 08	 call	 DWORD PTR [eax+8]
$LN6@sentry:

; 120  :             }
; 121  :         }

  0005b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00065	59		 pop	 ecx
  00066	5e		 pop	 esi
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
$T2 = -52						; size = 20
$T3 = -32						; size = 8
__Ok$4 = -24						; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Rdbuf$1$ = 8						; size = 4
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 92   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b d9		 mov	 ebx, ecx
  0002a	89 5d f0	 mov	 DWORD PTR _this$[ebp], ebx

; 71   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  0002d	8b 75 08	 mov	 esi, DWORD PTR __Ostr$[ebp]
  00030	89 33		 mov	 DWORD PTR [ebx], esi

; 72   :             const auto _Rdbuf = _Myostr.rdbuf();

  00032	8b 06		 mov	 eax, DWORD PTR [esi]
  00034	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00037	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]

; 73   :             if (_Rdbuf) {

  0003b	85 c9		 test	 ecx, ecx
  0003d	74 05		 je	 SHORT $LN8@sentry

; 74   :                 _Rdbuf->_Lock();

  0003f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00041	ff 50 04	 call	 DWORD PTR [eax+4]
$LN8@sentry:

; 92   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

  00044	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 295  :         return rdstate() == ios_base::goodbit;

  0004b	8b 06		 mov	 eax, DWORD PTR [esi]
  0004d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00050	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  00055	8d 3c 30	 lea	 edi, DWORD PTR [eax+esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 93   :             if (!_Ostr.good()) {

  00058	74 07		 je	 SHORT $LN2@sentry

; 94   :                 _Ok = false;

  0005a	32 c0		 xor	 al, al

; 95   :                 return;

  0005c	e9 9d 00 00 00	 jmp	 $LN1@sentry
$LN2@sentry:

; 96   :             }
; 97   : 
; 98   :             const auto _Tied = _Ostr.tie();

  00061	8b 7f 3c	 mov	 edi, DWORD PTR [edi+60]

; 99   :             if (!_Tied || _Tied == &_Ostr) {

  00064	85 ff		 test	 edi, edi
  00066	0f 84 90 00 00
	00		 je	 $LN4@sentry
  0006c	3b fe		 cmp	 edi, esi
  0006e	0f 84 88 00 00
	00		 je	 $LN4@sentry

; 546  :         const auto _Rdbuf = _Myios::rdbuf();

  00074	8b 07		 mov	 eax, DWORD PTR [edi]
  00076	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00079	8b 44 38 38	 mov	 eax, DWORD PTR [eax+edi+56]
  0007d	89 45 08	 mov	 DWORD PTR __Rdbuf$1$[ebp], eax

; 547  :         if (_Rdbuf) { // buffer exists, flush it

  00080	85 c0		 test	 eax, eax
  00082	74 69		 je	 SHORT $LN39@sentry

; 548  :             const sentry _Ok(*this);

  00084	57		 push	 edi
  00085	8d 4d e8	 lea	 ecx, DWORD PTR __Ok$4[ebp]
  00088	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  0008d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 550  :             if (_Ok && _Rdbuf->pubsync() == -1) {

  00091	80 7d ec 00	 cmp	 BYTE PTR __Ok$4[ebp+4], 0
  00095	74 28		 je	 SHORT $LN24@sentry
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\streambuf

; 123  :         return sync();

  00097	8b 4d 08	 mov	 ecx, DWORD PTR __Rdbuf$1$[ebp]
  0009a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009c	ff 50 34	 call	 DWORD PTR [eax+52]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 550  :             if (_Ok && _Rdbuf->pubsync() == -1) {

  0009f	83 f8 ff	 cmp	 eax, -1
  000a2	75 1b		 jne	 SHORT $LN24@sentry

; 551  :                 _Myios::setstate(ios_base::badbit); // sync failed

  000a4	8b 07		 mov	 eax, DWORD PTR [edi]
  000a6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 244  :         _State &= _Statmask;

  000a9	8b 44 39 0c	 mov	 eax, DWORD PTR [ecx+edi+12]
  000ad	83 e0 13	 and	 eax, 19			; 00000013H
  000b0	83 c8 04	 or	 eax, 4

; 245  :         _Mystate             = _State;

  000b3	89 44 39 0c	 mov	 DWORD PTR [ecx+edi+12], eax

; 246  :         const auto _Filtered = _State & _Except;

  000b7	8b 4c 39 10	 mov	 ecx, DWORD PTR [ecx+edi+16]
  000bb	23 c8		 and	 ecx, eax

; 247  :         if (_Filtered) {

  000bd	75 5f		 jne	 SHORT $LN47@sentry
$LN24@sentry:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 109  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

  000bf	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 110  : #if !_HAS_EXCEPTIONS
; 111  :             const bool _Zero_uncaught_exceptions = true;
; 112  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 113  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  000c3	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception

; 114  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 115  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 116  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 117  : 
; 118  :             if (_Zero_uncaught_exceptions) {

  000c8	84 c0		 test	 al, al
  000ca	75 08		 jne	 SHORT $LN35@sentry

; 119  :                 this->_Myostr._Osfx();

  000cc	8b 4d e8	 mov	 ecx, DWORD PTR __Ok$4[ebp]
  000cf	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN35@sentry:

; 120  :             }
; 121  :         }

  000d4	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

  000d8	8b 4d e8	 mov	 ecx, DWORD PTR __Ok$4[ebp]
  000db	8b 01		 mov	 eax, DWORD PTR [ecx]
  000dd	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000e0	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]

; 80   :             if (_Rdbuf) {

  000e4	85 c9		 test	 ecx, ecx
  000e6	74 05		 je	 SHORT $LN39@sentry

; 81   :                 _Rdbuf->_Unlock();

  000e8	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ea	ff 50 08	 call	 DWORD PTR [eax+8]
$LN39@sentry:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 295  :         return rdstate() == ios_base::goodbit;

  000ed	8b 06		 mov	 eax, DWORD PTR [esi]
  000ef	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f2	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  000f7	0f 94 c0	 sete	 al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 105  :             _Ok = _Ostr.good(); // store test only after flushing tie

  000fa	eb 02		 jmp	 SHORT $LN1@sentry
$LN4@sentry:

; 100  :                 _Ok = true;

  000fc	b0 01		 mov	 al, 1
$LN1@sentry:

; 106  :         }

  000fe	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00105	88 43 04	 mov	 BYTE PTR [ebx+4], al
  00108	8b c3		 mov	 eax, ebx
  0010a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0010d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00114	59		 pop	 ecx
  00115	5f		 pop	 edi
  00116	5e		 pop	 esi
  00117	5b		 pop	 ebx
  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c2 04 00	 ret	 4
$LN47@sentry:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 253  :             if (_Filtered & ios_base::badbit) {

  0011e	f6 c1 04	 test	 cl, 4
  00121	74 07		 je	 SHORT $LN26@sentry

; 254  :                 _Msg = "ios_base::badbit set";

  00123	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  00128	eb 10		 jmp	 SHORT $LN28@sentry
$LN26@sentry:

; 255  :             } else if (_Filtered & ios_base::failbit) {

  0012a	f6 c1 02	 test	 cl, 2
  0012d	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
  00132	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
  00137	0f 44 f0	 cmove	 esi, eax
$LN28@sentry:

; 256  :                 _Msg = "ios_base::failbit set";
; 257  :             } else {
; 258  :                 _Msg = "ios_base::eofbit set";
; 259  :             }
; 260  : 
; 261  :             _THROW(failure(_Msg));

  0013a	8d 45 e0	 lea	 eax, DWORD PTR $T3[ebp]
  0013d	6a 01		 push	 1
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  00145	83 c4 08	 add	 esp, 8
  00148	8d 4d cc	 lea	 ecx, DWORD PTR $T2[ebp]
  0014b	50		 push	 eax
  0014c	56		 push	 esi
  0014d	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  00152	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00157	8d 45 cc	 lea	 eax, DWORD PTR $T2[ebp]
  0015a	50		 push	 eax
  0015b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN45@sentry:
  00160	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$1:
  00008	8d 4d e8	 lea	 ecx, DWORD PTR __Ok$4[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$2:
  00010	8d 4d e8	 lea	 ecx, DWORD PTR __Ok$4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
  0001d	90		 npad	 1
  0001e	90		 npad	 1
  0001f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00023	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00026	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 78   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

  00022	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00024	8b 01		 mov	 eax, DWORD PTR [ecx]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00029	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]

; 80   :             if (_Rdbuf) {

  0002d	85 c9		 test	 ecx, ecx
  0002f	74 05		 je	 SHORT $LN2@Sentry_bas

; 81   :                 _Rdbuf->_Unlock();

  00031	8b 01		 mov	 eax, DWORD PTR [ecx]
  00033	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 82   :             }
; 83   :         }

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
  00045	cc		 int	 3
  00046	cc		 int	 3
  00047	cc		 int	 3
  00048	cc		 int	 3
  00049	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp
;	COMDAT ?RecoverDirectDraw@@YAXXZ
_TEXT	SEGMENT
?RecoverDirectDraw@@YAXXZ PROC				; RecoverDirectDraw, COMDAT

; 571  : 	// DirectDraw ?Óü¥
; 572  : 	ReleaseDirectDraw();

  00000	e8 00 00 00 00	 call	 ?ReleaseDirectDraw@@YAXXZ ; ReleaseDirectDraw

; 573  : 	// ??Óôö???ÓìÜÓòã
; 574  : 	SetResoMode( ResoMode );

  00005	ff 35 00 00 00
	00		 push	 DWORD PTR ?ResoMode@@3HA ; ResoMode
  0000b	e8 00 00 00 00	 call	 ?SetResoMode@@YAXH@Z	; SetResoMode
  00010	83 c4 04	 add	 esp, 4

; 575  : 	// DirectDraw ???
; 576  : 	if( InitDirectDraw() == FALSE ){

  00013	e8 00 00 00 00	 call	 ?InitDirectDraw@@YAHXZ	; InitDirectDraw
  00018	85 c0		 test	 eax, eax
  0001a	75 2a		 jne	 SHORT $LN2@RecoverDir

; 577  : 		MessageBox( hWnd, "Direct ÂàùÂßãÂåñÂ§±Ë¥•ÔºÅ", "ÌôïÏù∏", MB_OK | MB_ICONSTOP );

  0001c	6a 10		 push	 16			; 00000010H
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_04IJNKKJEO@?H?$KO?$MA?N@
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@HCDANIG@Direct?5?t?x?c?$LH?$PL?y?c?w?$DP?$KD?$KB@
  00028	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 578  : 		// ???????? WM_CLOSE ??????????
; 579  : 		PostMessage( hWnd, WM_CLOSE, 0, 0L );

  00034	6a 00		 push	 0
  00036	6a 00		 push	 0
  00038	6a 10		 push	 16			; 00000010H
  0003a	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16
$LN2@RecoverDir:

; 580  : 	}
; 581  : 	// ????????ÓìÅ?Óïú?
; 582  : 	//ChangeWindowMode();
; 583  : 	// ??????????????Óíï 
; 584  : 	InitOffScreenSurface();

  00046	e8 00 00 00 00	 call	 ?InitOffScreenSurface@@YAHXZ ; InitOffScreenSurface

; 585  : 	// ???????
; 586  : 	if( InitPalette() == FALSE ){

  0004b	e8 00 00 00 00	 call	 ?InitPalette@@YAHXZ	; InitPalette
  00050	85 c0		 test	 eax, eax
  00052	75 2a		 jne	 SHORT $LN3@RecoverDir

; 587  : 		MessageBox( hWnd, "Ëâ≤Áõò ÂàùÂßãÂåñÂ§±Ë¥•ÔºÅ", "ÌôïÏù∏", MB_OK | MB_ICONSTOP );

  00054	6a 10		 push	 16			; 00000010H
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_04IJNKKJEO@?H?$KO?$MA?N@
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@LIOBMBPJ@?$NP?d?$DP?5?t?x?c?$LH?$PL?y?c?w?$DP?$KD?$KB@
  00060	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 588  : 		PostMessage( hWnd, WM_CLOSE, 0, 0L );

  0006c	6a 00		 push	 0
  0006e	6a 00		 push	 0
  00070	6a 10		 push	 16			; 00000010H
  00072	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16
$LN3@RecoverDir:

; 589  : 	}
; 590  : 	// ??????Óöá????????????????Óíï
; 591  : 	if( ProcNo == PROC_BATTLE ){ 

  0007e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ProcNo@@3IA ; ProcNo
  00083	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00086	75 51		 jne	 SHORT $LN4@RecoverDir

; 592  : 		// ???????
; 593  : 		DispBuffer.DispCnt = 0;
; 594  : 		FontCnt = 0;
; 595  : 		ReadBattleMap( BattleMapNo );

  00088	ff 35 00 00 00
	00		 push	 DWORD PTR ?BattleMapNo@@3HA ; BattleMapNo
  0008e	33 c0		 xor	 eax, eax
  00090	66 a3 00 c0 01
	00		 mov	 WORD PTR ?DispBuffer@@3UDISP_BUFFER@@A+114688, ax
  00096	a3 00 00 00 00	 mov	 DWORD PTR ?FontCnt@@3HA, eax ; FontCnt
  0009b	e8 00 00 00 00	 call	 ?ReadBattleMap@@YAHH@Z	; ReadBattleMap
  000a0	83 c4 04	 add	 esp, 4

; 596  : 		// ???????????????
; 597  : 		ClearBackSurface();	

  000a3	e8 00 00 00 00	 call	 ?ClearBackSurface@@YAXXZ ; ClearBackSurface

; 598  : 		// ????????????????
; 599  : #ifdef __SKYISLAND
; 600  : 		fastDrawTileFlag = 0;

  000a8	33 c0		 xor	 eax, eax
  000aa	66 a3 00 00 00
	00		 mov	 WORD PTR ?fastDrawTileFlag@@3FA, ax ; fastDrawTileFlag

; 601  : 		PutBmp();

  000b0	e8 00 00 00 00	 call	 ?PutBmp@@YAXXZ		; PutBmp

; 602  : 		fastDrawTileFlag = 1;

  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	66 a3 00 00 00
	00		 mov	 WORD PTR ?fastDrawTileFlag@@3FA, ax ; fastDrawTileFlag

; 603  : #else
; 604  : 		PutBmp();	
; 605  : 		// ??????????????????????
; 606  : 		lpBattleSurface->BltFast( 0, 0, lpDraw->lpBACKBUFFER, NULL, DDBLTFAST_WAIT );
; 607  : #endif
; 608  : 		// ???????
; 609  : 		DispBuffer.DispCnt = 0;

  000c0	33 c0		 xor	 eax, eax
  000c2	66 a3 00 c0 01
	00		 mov	 WORD PTR ?DispBuffer@@3UDISP_BUFFER@@A+114688, ax

; 610  : 		FontCnt = 0;

  000c8	a3 00 00 00 00	 mov	 DWORD PTR ?FontCnt@@3HA, eax ; FontCnt

; 611  : 		// ????????
; 612  : 		NowTime = TimeGetTime();

  000cd	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  000d2	a3 00 00 00 00	 mov	 DWORD PTR ?NowTime@@3KA, eax ; NowTime

; 613  : 	}

  000d7	eb 14		 jmp	 SHORT $LN6@RecoverDir
$LN4@RecoverDir:

; 614  : 	else
; 615  : 	if( fastDrawTile && ProcNo == PROC_GAME )

  000d9	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR ?fastDrawTile@@3FB, 0 ; fastDrawTile
  000e1	74 0a		 je	 SHORT $LN6@RecoverDir
  000e3	83 f8 09	 cmp	 eax, 9
  000e6	75 05		 jne	 SHORT $LN6@RecoverDir

; 616  : 	{
; 617  : 		repairMap();	// ????Ó°°?Óé±?

  000e8	e8 00 00 00 00	 call	 ?repairMap@@YAXXZ	; repairMap
$LN6@RecoverDir:

; 618  : 	}
; 619  : 	// ??????????????
; 620  : 	if( lpDraw->lpPALETTE != NULL ){

  000ed	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  000f2	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  000f8	85 c9		 test	 ecx, ecx
  000fa	74 1d		 je	 SHORT $LN8@RecoverDir

; 621  : 		// ??????????
; 622  : 		if( WindowMode ){

  000fc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?WindowMode@@3HA, 0 ; WindowMode
  00103	74 14		 je	 SHORT $LN8@RecoverDir

; 623  : 			// ?Óíï??????????Óüâ??
; 624  : 			lpDraw->lpPALETTE->SetEntries( 0, 0, 256, Palette );

  00105	8b 01		 mov	 eax, DWORD PTR [ecx]
  00107	68 00 00 00 00	 push	 OFFSET ?Palette@@3PAUtagPALETTEENTRY@@A ; Palette
  0010c	68 00 01 00 00	 push	 256			; 00000100H
  00111	6a 00		 push	 0
  00113	6a 00		 push	 0
  00115	51		 push	 ecx
  00116	ff 50 18	 call	 DWORD PTR [eax+24]
$LN8@RecoverDir:

; 625  : 		}
; 626  : 	}
; 627  : 	// ???????Óöº?????
; 628  : 	mouse.state = MOUSE_NO_CRICK;

  00119	c7 05 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?mouse@@3UMOUSE@@A+40, 0

; 629  : 	mouse.onceState = MOUSE_NO_CRICK;

  00123	c7 05 2c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?mouse@@3UMOUSE@@A+44, 0

; 630  : 	// ???ÓñΩ?Ó†í????
; 631  : 	NowTime = TimeGetTime();

  0012d	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00132	a3 00 00 00 00	 mov	 DWORD PTR ?NowTime@@3KA, eax ; NowTime

; 632  : }

  00137	c3		 ret	 0
?RecoverDirectDraw@@YAXXZ ENDP				; RecoverDirectDraw
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp
;	COMDAT _main
_TEXT	SEGMENT
_main	PROC						; COMDAT

; 220  : 	std::cout << "Output standard\n";

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FMGGALCC@Output?5standard?6@
  00005	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  0000a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 221  : 	std::cerr << "Output error\n";

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NBCMJDEF@Output?5error?6@
  00014	68 00 00 00 00	 push	 OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
  00019	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0001e	83 c4 10	 add	 esp, 16			; 00000010H

; 222  : 
; 223  : 	return WinMain(GetModuleHandle(NULL), NULL, GetCommandLineA(), SW_SHOWNORMAL);

  00021	6a 01		 push	 1
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCommandLineA@0
  00029	50		 push	 eax
  0002a	6a 00		 push	 0
  0002c	6a 00		 push	 0
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _WinMain@16

; 224  : }

  0003a	c3		 ret	 0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
$T2 = -64						; size = 20
__Ok$ = -44						; size = 8
__Pad$ = -36						; size = 8
$T3 = -28						; size = 8
__Count$2$ = -24					; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 734  :     const char* _Val) { // insert NTBS into char stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 34	 sub	 esp, 52			; 00000034H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 735  :     using _Elem = char;
; 736  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 737  : 
; 738  :     ios_base::iostate _State = ios_base::goodbit;

  0002b	33 db		 xor	 ebx, ebx
  0002d	89 5d ec	 mov	 DWORD PTR __State$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00030	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  00033	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
$LL67@operator:
  00036	8a 02		 mov	 al, BYTE PTR [edx]
  00038	42		 inc	 edx
  00039	84 c0		 test	 al, al
  0003b	75 f9		 jne	 SHORT $LL67@operator
  0003d	2b d1		 sub	 edx, ecx
  0003f	89 55 e8	 mov	 DWORD PTR __Count$2$[ebp], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 740  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  00042	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00045	8b 01		 mov	 eax, DWORD PTR [ecx]
  00047	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004a	8b 74 08 20	 mov	 esi, DWORD PTR [eax+ecx+32]
  0004e	8b 7c 08 24	 mov	 edi, DWORD PTR [eax+ecx+36]
  00052	85 ff		 test	 edi, edi
  00054	7c 16		 jl	 SHORT $LN17@operator
  00056	7f 0e		 jg	 SHORT $LN69@operator
  00058	85 f6		 test	 esi, esi
  0005a	74 10		 je	 SHORT $LN17@operator
  0005c	85 ff		 test	 edi, edi
  0005e	7c 0c		 jl	 SHORT $LN17@operator
  00060	7f 04		 jg	 SHORT $LN69@operator
  00062	3b f2		 cmp	 esi, edx
  00064	76 06		 jbe	 SHORT $LN17@operator
$LN69@operator:
  00066	2b f2		 sub	 esi, edx
  00068	1b fb		 sbb	 edi, ebx
  0006a	eb 0e		 jmp	 SHORT $LN18@operator
$LN17@operator:
  0006c	0f 57 c0	 xorps	 xmm0, xmm0
  0006f	66 0f 13 45 dc	 movlpd	 QWORD PTR __Pad$[ebp], xmm0
  00074	8b 7d e0	 mov	 edi, DWORD PTR __Pad$[ebp+4]
  00077	8b 75 dc	 mov	 esi, DWORD PTR __Pad$[ebp]
$LN18@operator:

; 741  :     const typename _Myos::sentry _Ok(_Ostr);

  0007a	51		 push	 ecx
  0007b	8d 4d d4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0007e	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  00083	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 742  : 
; 743  :     if (!_Ok) {

  0008a	80 7d d8 00	 cmp	 BYTE PTR __Ok$[ebp+4], 0
  0008e	75 0a		 jne	 SHORT $LN8@operator

; 744  :         _State |= ios_base::badbit;

  00090	bb 04 00 00 00	 mov	 ebx, 4

; 745  :     } else { // state okay, insert

  00095	e9 f6 00 00 00	 jmp	 $LN79@operator
$LN8@operator:

; 746  :         _TRY_IO_BEGIN

  0009a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 747  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  0009e	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000a1	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a3	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000a6	8b 44 08 14	 mov	 eax, DWORD PTR [eax+ecx+20]
  000aa	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000af	83 f8 40	 cmp	 eax, 64			; 00000040H
  000b2	74 36		 je	 SHORT $LN62@operator
$LL4@operator:

; 748  :             for (; 0 < _Pad; --_Pad) { // pad on left

  000b4	85 ff		 test	 edi, edi
  000b6	7c 30		 jl	 SHORT $LN64@operator
  000b8	7f 04		 jg	 SHORT $LN70@operator
  000ba	85 f6		 test	 esi, esi
  000bc	74 2a		 je	 SHORT $LN64@operator
$LN70@operator:

; 749  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  000be	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c3	03 c8		 add	 ecx, eax
  000c5	0f b6 41 40	 movzx	 eax, BYTE PTR [ecx+64]
  000c9	50		 push	 eax
  000ca	8b 49 38	 mov	 ecx, DWORD PTR [ecx+56]
  000cd	e8 00 00 00 00	 call	 ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 470  :         return _Left == _Right;

  000d2	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 749  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  000d5	74 6d		 je	 SHORT $LN71@operator

; 748  :             for (; 0 < _Pad; --_Pad) { // pad on left

  000d7	83 c6 ff	 add	 esi, -1
  000da	89 75 dc	 mov	 DWORD PTR __Pad$[ebp], esi
  000dd	83 d7 ff	 adc	 edi, -1
  000e0	89 7d e0	 mov	 DWORD PTR __Pad$[ebp+4], edi
  000e3	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000e6	eb cc		 jmp	 SHORT $LL4@operator
$LN64@operator:

; 756  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  000e8	8b 11		 mov	 edx, DWORD PTR [ecx]
$LN62@operator:
  000ea	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ed	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\streambuf

; 173  :         return xsputn(_Ptr, _Count);

  000f1	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f3	6a 00		 push	 0
  000f5	ff 75 e8	 push	 DWORD PTR __Count$2$[ebp]
  000f8	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  000fb	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  000fe	ff d0		 call	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 756  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  00100	3b 45 e8	 cmp	 eax, DWORD PTR __Count$2$[ebp]
  00103	75 3f		 jne	 SHORT $LN71@operator
  00105	85 d2		 test	 edx, edx
  00107	75 3b		 jne	 SHORT $LN71@operator
  00109	0f 1f 80 00 00
	00 00		 npad	 7
$LL73@operator:

; 757  :             _State |= ios_base::badbit;
; 758  :         }
; 759  : 
; 760  :         if (_State == ios_base::goodbit) {
; 761  :             for (; 0 < _Pad; --_Pad) { // pad on right

  00110	85 ff		 test	 edi, edi
  00112	7c 38		 jl	 SHORT $LN6@operator
  00114	7f 04		 jg	 SHORT $LN72@operator
  00116	85 f6		 test	 esi, esi
  00118	74 32		 je	 SHORT $LN6@operator
$LN72@operator:

; 762  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0011a	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0011d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0011f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00122	03 c8		 add	 ecx, eax
  00124	0f b6 41 40	 movzx	 eax, BYTE PTR [ecx+64]
  00128	50		 push	 eax
  00129	8b 49 38	 mov	 ecx, DWORD PTR [ecx+56]
  0012c	e8 00 00 00 00	 call	 ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 470  :         return _Left == _Right;

  00131	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 762  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00134	74 0e		 je	 SHORT $LN71@operator

; 757  :             _State |= ios_base::badbit;
; 758  :         }
; 759  : 
; 760  :         if (_State == ios_base::goodbit) {
; 761  :             for (; 0 < _Pad; --_Pad) { // pad on right

  00136	83 c6 ff	 add	 esi, -1
  00139	89 75 dc	 mov	 DWORD PTR __Pad$[ebp], esi
  0013c	83 d7 ff	 adc	 edi, -1
  0013f	89 7d e0	 mov	 DWORD PTR __Pad$[ebp+4], edi
  00142	eb cc		 jmp	 SHORT $LL73@operator
$LN71@operator:

; 763  :                     _State |= ios_base::badbit; // insertion failed, quit
; 764  :                     break;
; 765  :                 }
; 766  :             }
; 767  :         }
; 768  : 
; 769  :         _Ostr.width(0);

  00144	bb 04 00 00 00	 mov	 ebx, 4
  00149	89 5d ec	 mov	 DWORD PTR __State$[ebp], ebx
$LN6@operator:
  0014c	8b 75 08	 mov	 esi, DWORD PTR __Ostr$[ebp]
  0014f	8b 06		 mov	 eax, DWORD PTR [esi]
  00151	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 368  :         _Wide                      = _Newwidth;

  00154	c7 44 30 20 00
	00 00 00	 mov	 DWORD PTR [eax+esi+32], 0
  0015c	c7 44 30 24 00
	00 00 00	 mov	 DWORD PTR [eax+esi+36], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
  00164	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0016b	eb 26		 jmp	 SHORT $LN22@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 770  :         _CATCH_IO_(ios_base, _Ostr)

  0016d	6a 01		 push	 1
  0016f	6a 04		 push	 4
  00171	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00174	8b 02		 mov	 eax, DWORD PTR [edx]
  00176	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00179	03 ca		 add	 ecx, edx
  0017b	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
  00180	b8 00 00 00 00	 mov	 eax, $LN23@operator
  00185	c3		 ret	 0
$LN23@operator:
  00186	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0018d	8b 5d ec	 mov	 ebx, DWORD PTR __State$[ebp]
$LN79@operator:

; 771  :     }
; 772  : 
; 773  :     _Ostr.setstate(_State);

  00190	8b 75 08	 mov	 esi, DWORD PTR __Ostr$[ebp]
$LN22@operator:
  00193	8b 06		 mov	 eax, DWORD PTR [esi]
  00195	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00198	03 d6		 add	 edx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 53   :         clear(rdstate() | _State, _Reraise);

  0019a	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0019d	0b c3		 or	 eax, ebx

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  0019f	b9 04 00 00 00	 mov	 ecx, 4
  001a4	33 ff		 xor	 edi, edi
  001a6	39 7a 38	 cmp	 DWORD PTR [edx+56], edi
  001a9	0f 45 cf	 cmovne	 ecx, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 244  :         _State &= _Statmask;

  001ac	0b c8		 or	 ecx, eax
  001ae	83 e1 17	 and	 ecx, 23			; 00000017H

; 245  :         _Mystate             = _State;

  001b1	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 246  :         const auto _Filtered = _State & _Except;

  001b4	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  001b7	23 c1		 and	 eax, ecx

; 247  :         if (_Filtered) {

  001b9	75 48		 jne	 SHORT $LN81@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 109  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

  001bb	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3

; 110  : #if !_HAS_EXCEPTIONS
; 111  :             const bool _Zero_uncaught_exceptions = true;
; 112  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 113  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  001c2	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception

; 114  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 115  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 116  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 117  : 
; 118  :             if (_Zero_uncaught_exceptions) {

  001c7	84 c0		 test	 al, al
  001c9	75 08		 jne	 SHORT $LN50@operator

; 119  :                 this->_Myostr._Osfx();

  001cb	8b 4d d4	 mov	 ecx, DWORD PTR __Ok$[ebp]
  001ce	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN50@operator:

; 120  :             }
; 121  :         }

  001d3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

  001da	8b 4d d4	 mov	 ecx, DWORD PTR __Ok$[ebp]
  001dd	8b 01		 mov	 eax, DWORD PTR [ecx]
  001df	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001e2	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]

; 80   :             if (_Rdbuf) {

  001e6	85 c9		 test	 ecx, ecx
  001e8	74 05		 je	 SHORT $LN54@operator

; 81   :                 _Rdbuf->_Unlock();

  001ea	8b 11		 mov	 edx, DWORD PTR [ecx]
  001ec	ff 52 08	 call	 DWORD PTR [edx+8]
$LN54@operator:

; 774  :     return _Ostr;

  001ef	8b c6		 mov	 eax, esi

; 775  : }

  001f1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001f4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001fb	59		 pop	 ecx
  001fc	5f		 pop	 edi
  001fd	5e		 pop	 esi
  001fe	5b		 pop	 ebx
  001ff	8b e5		 mov	 esp, ebp
  00201	5d		 pop	 ebp
  00202	c3		 ret	 0
$LN81@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 253  :             if (_Filtered & ios_base::badbit) {

  00203	a8 04		 test	 al, 4
  00205	74 07		 je	 SHORT $LN41@operator

; 254  :                 _Msg = "ios_base::badbit set";

  00207	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  0020c	eb 0f		 jmp	 SHORT $LN43@operator
$LN41@operator:

; 255  :             } else if (_Filtered & ios_base::failbit) {

  0020e	a8 02		 test	 al, 2
  00210	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
  00215	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
  0021a	0f 44 f0	 cmove	 esi, eax
$LN43@operator:

; 256  :                 _Msg = "ios_base::failbit set";
; 257  :             } else {
; 258  :                 _Msg = "ios_base::eofbit set";
; 259  :             }
; 260  : 
; 261  :             _THROW(failure(_Msg));

  0021d	6a 01		 push	 1
  0021f	8d 45 e4	 lea	 eax, DWORD PTR $T3[ebp]
  00222	50		 push	 eax
  00223	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  00228	83 c4 08	 add	 esp, 8
  0022b	50		 push	 eax
  0022c	56		 push	 esi
  0022d	8d 4d c0	 lea	 ecx, DWORD PTR $T2[ebp]
  00230	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  00235	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  0023a	8d 45 c0	 lea	 eax, DWORD PTR $T2[ebp]
  0023d	50		 push	 eax
  0023e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN76@operator:
  00243	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3:
  00008	8d 4d d4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\iterator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
_TEXT	SEGMENT
$T2 = -68						; size = 20
$T3 = -48						; size = 8
$T4 = -48						; size = 8
$T5 = -48						; size = 8
$T6 = -48						; size = 8
__Ok$ = -40						; size = 8
__Nput_fac$1$ = -32					; size = 4
__State$ = -28						; size = 4
_this$ = -24						; size = 4
$T7 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = ecx

; 386  :     basic_ostream& __CLR_OR_THIS_CALL operator<<(float _Val) { // insert a float

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi
  00030	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T7[ebp], 0

; 387  :         ios_base::iostate _State = ios_base::goodbit;

  00037	33 ff		 xor	 edi, edi
  00039	89 7d e4	 mov	 DWORD PTR __State$[ebp], edi

; 388  :         const sentry _Ok(*this);

  0003c	56		 push	 esi
  0003d	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00040	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  00045	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], edi

; 389  : 
; 390  :         if (_Ok) { // state okay, use facet to insert

  00048	80 7d dc 00	 cmp	 BYTE PTR __Ok$[ebp+4], 0
  0004c	0f 84 d3 00 00
	00		 je	 $LN47@operator

; 391  :             const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

  00052	8b 06		 mov	 eax, DWORD PTR [esi]
  00054	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00057	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 373  :         return *_Ploc;

  0005b	8b 44 30 30	 mov	 eax, DWORD PTR [eax+esi+48]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 267  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  0005f	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  00062	89 5d d4	 mov	 DWORD PTR $T6[ebp+4], ebx

; 268  :         _Ptr->_Incref();

  00065	8b 03		 mov	 eax, DWORD PTR [ebx]
  00067	8b cb		 mov	 ecx, ebx
  00069	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 373  :         return *_Ploc;

  0006c	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR $T7[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 391  :             const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

  00073	8d 45 d0	 lea	 eax, DWORD PTR $T6[ebp]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
  0007c	83 c4 04	 add	 esp, 4
  0007f	89 45 e0	 mov	 DWORD PTR __Nput_fac$1$[ebp], eax
  00082	ba 01 00 00 00	 mov	 edx, 1
  00087	89 55 ec	 mov	 DWORD PTR $T7[ebp], edx
  0008a	83 e2 fe	 and	 edx, -2			; fffffffeH
  0008d	89 55 ec	 mov	 DWORD PTR $T7[ebp], edx
  00090	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  00094	85 db		 test	 ebx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 351  :         if (_Ptr) {

  00096	74 13		 je	 SHORT $LN21@operator

; 352  :             delete _Ptr->_Decref();

  00098	8b 13		 mov	 edx, DWORD PTR [ebx]
  0009a	8b cb		 mov	 ecx, ebx
  0009c	ff 52 08	 call	 DWORD PTR [edx+8]
  0009f	85 c0		 test	 eax, eax
  000a1	74 08		 je	 SHORT $LN21@operator
  000a3	8b 10		 mov	 edx, DWORD PTR [eax]
  000a5	6a 01		 push	 1
  000a7	8b c8		 mov	 ecx, eax
  000a9	ff 12		 call	 DWORD PTR [edx]
$LN21@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 393  :             _TRY_IO_BEGIN

  000ab	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  000af	9b		 fwait

; 394  :             if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), static_cast<double>(_Val)).failed()) {

  000b0	8b 06		 mov	 eax, DWORD PTR [esi]
  000b2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b5	03 ce		 add	 ecx, esi
  000b7	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\iterator

; 552  :     bool _Failed            = false; // true if any stores have failed

  000ba	c6 45 d0 00	 mov	 BYTE PTR $T5[ebp], 0

; 523  :     ostreambuf_iterator(streambuf_type* _Sb) noexcept : _Strbuf(_Sb) {}

  000be	89 55 d4	 mov	 DWORD PTR $T5[ebp+4], edx
  000c1	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __Val$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 394  :             if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), static_cast<double>(_Val)).failed()) {

  000c6	0f 5a c0	 cvtps2pd xmm0, xmm0
  000c9	83 ec 08	 sub	 esp, 8
  000cc	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000d1	0f b6 41 40	 movzx	 eax, BYTE PTR [ecx+64]
  000d5	50		 push	 eax
  000d6	51		 push	 ecx
  000d7	52		 push	 edx
  000d8	ff 75 d0	 push	 DWORD PTR $T5[ebp]
  000db	8d 45 d0	 lea	 eax, DWORD PTR $T4[ebp]
  000de	50		 push	 eax
  000df	8b 4d e0	 mov	 ecx, DWORD PTR __Nput_fac$1$[ebp]
  000e2	e8 00 00 00 00	 call	 ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
  000e7	ba 04 00 00 00	 mov	 edx, 4
  000ec	80 38 00	 cmp	 BYTE PTR [eax], 0
  000ef	0f 45 fa	 cmovne	 edi, edx
  000f2	89 7d e4	 mov	 DWORD PTR __State$[ebp], edi

; 395  :                 _State |= ios_base::badbit;
; 396  :             }
; 397  :             _CATCH_IO_END

  000f5	9b		 fwait
  000f6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000fd	eb 2b		 jmp	 SHORT $LN10@operator
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$0:
  000ff	6a 01		 push	 1
  00101	6a 04		 push	 4
  00103	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00106	8b 02		 mov	 eax, DWORD PTR [edx]
  00108	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0010b	03 ca		 add	 ecx, edx
  0010d	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
  00112	b8 00 00 00 00	 mov	 eax, $LN11@operator
  00117	c3		 ret	 0
$LN11@operator:
  00118	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 389  : 
; 390  :         if (_Ok) { // state okay, use facet to insert

  0011f	8b 75 e8	 mov	 esi, DWORD PTR _this$[ebp]
  00122	8b 7d e4	 mov	 edi, DWORD PTR __State$[ebp]
$LN47@operator:

; 398  :         }
; 399  : 
; 400  :         _Myios::setstate(_State);

  00125	ba 04 00 00 00	 mov	 edx, 4
$LN10@operator:
  0012a	8b 06		 mov	 eax, DWORD PTR [esi]
  0012c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0012f	03 ce		 add	 ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 53   :         clear(rdstate() | _State, _Reraise);

  00131	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00134	0b c7		 or	 eax, edi

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  00136	33 ff		 xor	 edi, edi
  00138	39 79 38	 cmp	 DWORD PTR [ecx+56], edi
  0013b	0f 45 d7	 cmovne	 edx, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 244  :         _State &= _Statmask;

  0013e	0b d0		 or	 edx, eax
  00140	83 e2 17	 and	 edx, 23			; 00000017H

; 245  :         _Mystate             = _State;

  00143	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 246  :         const auto _Filtered = _State & _Except;

  00146	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00149	23 c2		 and	 eax, edx

; 247  :         if (_Filtered) {

  0014b	75 4a		 jne	 SHORT $LN51@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 109  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

  0014d	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4

; 110  : #if !_HAS_EXCEPTIONS
; 111  :             const bool _Zero_uncaught_exceptions = true;
; 112  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 113  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  00154	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception

; 114  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 115  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 116  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 117  : 
; 118  :             if (_Zero_uncaught_exceptions) {

  00159	84 c0		 test	 al, al
  0015b	75 08		 jne	 SHORT $LN41@operator

; 119  :                 this->_Myostr._Osfx();

  0015d	8b 4d d8	 mov	 ecx, DWORD PTR __Ok$[ebp]
  00160	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN41@operator:

; 120  :             }
; 121  :         }

  00165	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

  0016c	8b 4d d8	 mov	 ecx, DWORD PTR __Ok$[ebp]
  0016f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00171	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00174	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]

; 80   :             if (_Rdbuf) {

  00178	85 c9		 test	 ecx, ecx
  0017a	74 05		 je	 SHORT $LN45@operator

; 81   :                 _Rdbuf->_Unlock();

  0017c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0017e	ff 50 08	 call	 DWORD PTR [eax+8]
$LN45@operator:

; 401  :         return *this;

  00181	8b c6		 mov	 eax, esi

; 402  :     }

  00183	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00186	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0018d	59		 pop	 ecx
  0018e	5f		 pop	 edi
  0018f	5e		 pop	 esi
  00190	5b		 pop	 ebx
  00191	8b e5		 mov	 esp, ebp
  00193	5d		 pop	 ebp
  00194	c2 04 00	 ret	 4
$LN51@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 253  :             if (_Filtered & ios_base::badbit) {

  00197	a8 04		 test	 al, 4
  00199	74 07		 je	 SHORT $LN32@operator

; 254  :                 _Msg = "ios_base::badbit set";

  0019b	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  001a0	eb 0f		 jmp	 SHORT $LN34@operator
$LN32@operator:

; 255  :             } else if (_Filtered & ios_base::failbit) {

  001a2	a8 02		 test	 al, 2
  001a4	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
  001a9	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
  001ae	0f 44 f0	 cmove	 esi, eax
$LN34@operator:

; 256  :                 _Msg = "ios_base::failbit set";
; 257  :             } else {
; 258  :                 _Msg = "ios_base::eofbit set";
; 259  :             }
; 260  : 
; 261  :             _THROW(failure(_Msg));

  001b1	6a 01		 push	 1
  001b3	8d 45 d0	 lea	 eax, DWORD PTR $T3[ebp]
  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  001bc	83 c4 08	 add	 esp, 8
  001bf	50		 push	 eax
  001c0	56		 push	 esi
  001c1	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  001c4	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  001c9	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  001ce	8d 45 bc	 lea	 eax, DWORD PTR $T2[ebp]
  001d1	50		 push	 eax
  001d2	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN49@operator:
  001d7	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$2:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$4:
  00008	8b 45 ec	 mov	 eax, DWORD PTR $T7[ebp]
  0000b	83 e0 01	 and	 eax, 1
  0000e	0f 84 0c 00 00
	00		 je	 $LN15@operator
  00014	83 65 ec fe	 and	 DWORD PTR $T7[ebp], -2	; fffffffeH
  00018	8d 4d d0	 lea	 ecx, DWORD PTR $T6[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
$LN15@operator:
  00020	c3		 ret	 0
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$5:
  00021	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00024	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00029	cc		 int	 3
  0002a	cc		 int	 3
  0002b	cc		 int	 3
  0002c	cc		 int	 3
  0002d	cc		 int	 3
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z:
  0002e	90		 npad	 1
  0002f	90		 npad	 1
  00030	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00034	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00037	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0003a	33 c8		 xor	 ecx, eax
  0003c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00041	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
  00046	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Osfx, COMDAT
; _this$ = ecx

; 155  :     void __CLR_OR_THIS_CALL _Osfx() { // perform any wrapup

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00029	8b f1		 mov	 esi, ecx

; 156  :         _TRY_BEGIN

  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 295  :         return rdstate() == ios_base::goodbit;

  00032	8b 06		 mov	 eax, DWORD PTR [esi]
  00034	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00037	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 157  :         if (this->good() && this->flags() & ios_base::unitbuf) {

  0003c	75 25		 jne	 SHORT $LN9@Osfx
  0003e	f6 44 30 14 02	 test	 BYTE PTR [eax+esi+20], 2
  00043	74 1e		 je	 SHORT $LN9@Osfx

; 158  :             if (_Myios::rdbuf()->pubsync() == -1) { // flush stream as needed

  00045	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\streambuf

; 123  :         return sync();

  00049	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004b	ff 50 34	 call	 DWORD PTR [eax+52]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 158  :             if (_Myios::rdbuf()->pubsync() == -1) { // flush stream as needed

  0004e	83 f8 ff	 cmp	 eax, -1
  00051	75 10		 jne	 SHORT $LN9@Osfx

; 159  :                 _Myios::setstate(ios_base::badbit);

  00053	6a 00		 push	 0
  00055	6a 04		 push	 4
  00057	8b 06		 mov	 eax, DWORD PTR [esi]
  00059	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005c	03 ce		 add	 ecx, esi
  0005e	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
$LN9@Osfx:

; 164  :     }

  00063	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0006a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0006d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00074	59		 pop	 ecx
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0:

; 160  :             }
; 161  :         }
; 162  :         _CATCH_ALL
; 163  :         _CATCH_END

  0007c	b8 00 00 00 00	 mov	 eax, $LN9@Osfx
  00081	c3		 ret	 0
  00082	cc		 int	 3
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
  00086	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::setstate, COMDAT
; _this$ = ecx

; 52   :         iostate _State, bool _Reraise = false) { // merge _State into state, possibly reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  00003	ff 75 0c	 push	 DWORD PTR __Reraise$[ebp]
  00006	33 d2		 xor	 edx, edx
  00008	b8 04 00 00 00	 mov	 eax, 4
  0000d	39 51 38	 cmp	 DWORD PTR [ecx+56], edx
  00010	0f 45 c2	 cmovne	 eax, edx
  00013	0b 41 0c	 or	 eax, DWORD PTR [ecx+12]
  00016	0b 45 08	 or	 eax, DWORD PTR __State$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 53   :         clear(rdstate() | _State, _Reraise);
; 54   :     }

  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::setstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\chrono
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\chrono
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\chrono
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\chrono
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp
;	COMDAT ?detectSpeedHack@@YAXXZ
_TEXT	SEGMENT
tv226 = -8						; size = 4
tv172 = -8						; size = 4
_end$4$ = -4						; size = 4
?detectSpeedHack@@YAXXZ PROC				; detectSpeedHack, COMDAT

; 201  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\chrono

; 677  :             return time_point(duration(_Xtime_get_ticks()));

  00009	e8 00 00 00 00	 call	 __Xtime_get_ticks
  0000e	e8 00 00 00 00	 call	 __Xtime_get_ticks

; 230  :             : _MyDur(_Other) {}

  00013	8b f0		 mov	 esi, eax
  00015	8b fa		 mov	 edi, edx

; 677  :             return time_point(duration(_Xtime_get_ticks()));

  00017	e8 00 00 00 00	 call	 __Xtime_get_ticks

; 230  :             : _MyDur(_Other) {}

  0001c	8b d8		 mov	 ebx, eax
  0001e	8b c2		 mov	 eax, edx

; 314  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

  00020	8b cb		 mov	 ecx, ebx

; 230  :             : _MyDur(_Other) {}

  00022	89 45 fc	 mov	 DWORD PTR _end$4$[ebp], eax

; 314  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

  00025	2b ce		 sub	 ecx, esi
  00027	1b d7		 sbb	 edx, edi

; 467  :                 return static_cast<_To>(

  00029	e8 00 00 00 00	 call	 __ltod3
  0002e	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@416312d000000000
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp

; 209  : 		std::cout << float(elapsed_seconds.count()) << "\n";

  00036	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  0003b	51		 push	 ecx
  0003c	b9 00 00 00 00	 mov	 ecx, OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  00041	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00045	f3 0f 11 45 f8	 movss	 DWORD PTR tv172[ebp], xmm0
  0004a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004f	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 210  : 		if (float(elapsed_seconds.count()) > 2) {

  0005a	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv172[ebp]
  0005f	83 c4 08	 add	 esp, 8
  00062	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@40000000
  00069	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__Sleep@4
  0006f	77 5c		 ja	 SHORT $LN80@detectSpee
$LL2@detectSpee:

; 213  : 		}
; 214  : 		Sleep(1000);

  00071	68 e8 03 00 00	 push	 1000			; 000003e8H
  00076	ff d7		 call	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\chrono

; 677  :             return time_point(duration(_Xtime_get_ticks()));

  00078	e8 00 00 00 00	 call	 __Xtime_get_ticks

; 314  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

  0007d	8b c8		 mov	 ecx, eax

; 230  :             : _MyDur(_Other) {}

  0007f	8b f2		 mov	 esi, edx

; 314  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

  00081	2b cb		 sub	 ecx, ebx
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp

; 208  : 		end = new_end;

  00083	8b d8		 mov	 ebx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\chrono

; 314  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

  00085	1b 55 fc	 sbb	 edx, DWORD PTR _end$4$[ebp]
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp

; 208  : 		end = new_end;

  00088	89 75 fc	 mov	 DWORD PTR _end$4$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\chrono

; 467  :                 return static_cast<_To>(

  0008b	e8 00 00 00 00	 call	 __ltod3
  00090	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@416312d000000000
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp

; 209  : 		std::cout << float(elapsed_seconds.count()) << "\n";

  00098	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  0009d	51		 push	 ecx
  0009e	b9 00 00 00 00	 mov	 ecx, OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  000a3	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  000a7	f3 0f 11 45 f8	 movss	 DWORD PTR tv226[ebp], xmm0
  000ac	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b1	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 210  : 		if (float(elapsed_seconds.count()) > 2) {

  000bc	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv226[ebp]
  000c1	83 c4 08	 add	 esp, 8
  000c4	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@40000000
  000cb	76 a4		 jbe	 SHORT $LL2@detectSpee
$LN80@detectSpee:

; 211  : 			Sleep(2000);

  000cd	68 d0 07 00 00	 push	 2000			; 000007d0H
  000d2	ff d7		 call	 edi

; 212  : 			exit(0);

  000d4	6a 00		 push	 0
  000d6	e8 00 00 00 00	 call	 _exit
$LN84@detectSpee:
  000db	cc		 int	 3
?detectSpeedHack@@YAXXZ ENDP				; detectSpeedHack
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp
;	COMDAT ?CreateCompatibleDEVMODE@@YAXPAU_devicemodeA@@KKKK@Z
_TEXT	SEGMENT
_pdm$ = 8						; size = 4
_BitsPerPixel$ = 12					; size = 4
_Width$ = 16						; size = 4
_Height$ = 20						; size = 4
_Frequency$ = 24					; size = 4
?CreateCompatibleDEVMODE@@YAXPAU_devicemodeA@@KKKK@Z PROC ; CreateCompatibleDEVMODE, COMDAT

; 171  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 172  : 	ZeroMemory(pdm, sizeof(DEVMODE));

  00004	8b 75 08	 mov	 esi, DWORD PTR _pdm$[ebp]
  00007	68 9c 00 00 00	 push	 156			; 0000009cH
  0000c	6a 00		 push	 0
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memset

; 173  : 	pdm->dmSize = sizeof(DEVMODE);

  00014	b8 9c 00 00 00	 mov	 eax, 156		; 0000009cH
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001c	66 89 46 24	 mov	 WORD PTR [esi+36], ax

; 174  : 
; 175  : 	if (BitsPerPixel)

  00020	8b 45 0c	 mov	 eax, DWORD PTR _BitsPerPixel$[ebp]
  00023	85 c0		 test	 eax, eax
  00025	74 0a		 je	 SHORT $LN10@CreateComp

; 176  : 	{
; 177  : 		pdm->dmBitsPerPel = BitsPerPixel;
; 178  : 		pdm->dmFields |= DM_BITSPERPEL;

  00027	81 4e 28 00 00
	04 00		 or	 DWORD PTR [esi+40], 262144 ; 00040000H
  0002e	89 46 68	 mov	 DWORD PTR [esi+104], eax
$LN10@CreateComp:

; 179  : 	}
; 180  : 
; 181  : 	if (Width)

  00031	8b 45 10	 mov	 eax, DWORD PTR _Width$[ebp]
  00034	85 c0		 test	 eax, eax
  00036	74 0a		 je	 SHORT $LN11@CreateComp

; 182  : 	{
; 183  : 		pdm->dmPelsWidth = Width;
; 184  : 		pdm->dmFields |= DM_PELSWIDTH;

  00038	81 4e 28 00 00
	08 00		 or	 DWORD PTR [esi+40], 524288 ; 00080000H
  0003f	89 46 6c	 mov	 DWORD PTR [esi+108], eax
$LN11@CreateComp:

; 185  : 	}
; 186  : 
; 187  : 	if (Height)

  00042	8b 45 14	 mov	 eax, DWORD PTR _Height$[ebp]
  00045	85 c0		 test	 eax, eax
  00047	74 0a		 je	 SHORT $LN12@CreateComp

; 188  : 	{
; 189  : 		pdm->dmPelsHeight = Height;
; 190  : 		pdm->dmFields |= DM_PELSHEIGHT;

  00049	81 4e 28 00 00
	10 00		 or	 DWORD PTR [esi+40], 1048576 ; 00100000H
  00050	89 46 70	 mov	 DWORD PTR [esi+112], eax
$LN12@CreateComp:

; 191  : 	}
; 192  : 
; 193  : 	if (Frequency)

  00053	8b 45 18	 mov	 eax, DWORD PTR _Frequency$[ebp]
  00056	85 c0		 test	 eax, eax
  00058	74 0a		 je	 SHORT $LN5@CreateComp

; 194  : 	{
; 195  : 		pdm->dmDisplayFrequency = Frequency;
; 196  : 		pdm->dmFields |= DM_DISPLAYFREQUENCY;

  0005a	81 4e 28 00 00
	40 00		 or	 DWORD PTR [esi+40], 4194304 ; 00400000H
  00061	89 46 78	 mov	 DWORD PTR [esi+120], eax
$LN5@CreateComp:
  00064	5e		 pop	 esi

; 197  : 	}
; 198  : }

  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?CreateCompatibleDEVMODE@@YAXPAU_devicemodeA@@KKKK@Z ENDP ; CreateCompatibleDEVMODE
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp
;	COMDAT ?MessageBoxNew@@YAHPAUHWND__@@PBD1I@Z
_TEXT	SEGMENT
_€Â?$1 = -2052						; size = 1024
_€Â?1$2 = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_hWnd$ = 8						; size = 4
_lpText$ = 12						; size = 4
_lpCaption$ = 16					; size = 4
_uType$ = 20						; size = 4
?MessageBoxNew@@YAHPAUHWND__@@PBD1I@Z PROC		; MessageBoxNew, COMDAT

; 156  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 08 00
	00		 sub	 esp, 2052		; 00000804H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 157  : 	if (ÁºñÁ†Å == 950) {

  00013	81 3d 00 00 00
	00 b6 03 00 00	 cmp	 DWORD PTR ???@@3HA, 950	; ??, 000003b6H
  0001d	53		 push	 ebx
  0001e	8b 5d 08	 mov	 ebx, DWORD PTR _hWnd$[ebp]
  00021	56		 push	 esi
  00022	8b 75 0c	 mov	 esi, DWORD PTR _lpText$[ebp]
  00025	57		 push	 edi
  00026	8b 7d 10	 mov	 edi, DWORD PTR _lpCaption$[ebp]
  00029	0f 85 a9 00 00
	00		 jne	 $LN2@MessageBox

; 158  : 		char ÁπÅ‰Ωì[1024] = { 0 };

  0002f	68 00 04 00 00	 push	 1024			; 00000400H
  00034	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _€Â?$1[ebp]
  0003a	6a 00		 push	 0
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _memset

; 159  : 		char ÁπÅ‰Ωì1[1024] = { 0 };

  00042	68 00 04 00 00	 push	 1024			; 00000400H
  00047	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _€Â?1$2[ebp]
  0004d	6a 00		 push	 0
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _memset

; 160  : 		LCMapString(0x804, 0x4000000, lpText, strlen(lpText), ÁπÅ‰Ωì, 1024);

  00055	8b ce		 mov	 ecx, esi
  00057	83 c4 18	 add	 esp, 24			; 00000018H
  0005a	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0005d	0f 1f 00	 npad	 3
$LL5@MessageBox:
  00060	8a 01		 mov	 al, BYTE PTR [ecx]
  00062	41		 inc	 ecx
  00063	84 c0		 test	 al, al
  00065	75 f9		 jne	 SHORT $LL5@MessageBox
  00067	68 00 04 00 00	 push	 1024			; 00000400H
  0006c	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _€Â?$1[ebp]
  00072	2b ca		 sub	 ecx, edx
  00074	50		 push	 eax
  00075	51		 push	 ecx
  00076	56		 push	 esi
  00077	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__LCMapStringA@24
  0007d	68 00 00 00 04	 push	 67108864		; 04000000H
  00082	68 04 08 00 00	 push	 2052			; 00000804H
  00087	ff d6		 call	 esi

; 161  : 		LCMapString(0x804, 0x4000000, lpCaption, strlen(lpCaption), ÁπÅ‰Ωì1, 1024);

  00089	8b cf		 mov	 ecx, edi
  0008b	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0008e	66 90		 npad	 2
$LL6@MessageBox:
  00090	8a 01		 mov	 al, BYTE PTR [ecx]
  00092	41		 inc	 ecx
  00093	84 c0		 test	 al, al
  00095	75 f9		 jne	 SHORT $LL6@MessageBox
  00097	68 00 04 00 00	 push	 1024			; 00000400H
  0009c	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _€Â?1$2[ebp]
  000a2	2b ca		 sub	 ecx, edx
  000a4	50		 push	 eax
  000a5	51		 push	 ecx
  000a6	57		 push	 edi
  000a7	68 00 00 00 04	 push	 67108864		; 04000000H
  000ac	68 04 08 00 00	 push	 2052			; 00000804H
  000b1	ff d6		 call	 esi

; 162  : 		return MessageBox(hWnd, GB2312ToBIG5((const char *)ÁπÅ‰Ωì), GB2312ToBIG5((const char *)ÁπÅ‰Ωì1), uType);

  000b3	ff 75 14	 push	 DWORD PTR _uType$[ebp]
  000b6	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _€Â?1$2[ebp]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 ?GB2312ToBIG5@@YAPADPBD@Z ; GB2312ToBIG5
  000c2	83 c4 04	 add	 esp, 4
  000c5	50		 push	 eax
  000c6	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _€Â?$1[ebp]
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 ?GB2312ToBIG5@@YAPADPBD@Z ; GB2312ToBIG5
  000d2	83 c4 04	 add	 esp, 4
  000d5	50		 push	 eax
  000d6	eb 05		 jmp	 SHORT $LN7@MessageBox
$LN2@MessageBox:

; 163  : 	}
; 164  : 	else {
; 165  : 		return MessageBox(hWnd, lpText, lpCaption, uType);

  000d8	ff 75 14	 push	 DWORD PTR _uType$[ebp]
  000db	57		 push	 edi
  000dc	56		 push	 esi
$LN7@MessageBox:

; 166  : 	}
; 167  : }

  000dd	53		 push	 ebx
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  000e4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi
  000e9	33 cd		 xor	 ecx, ebp
  000eb	5b		 pop	 ebx
  000ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
?MessageBoxNew@@YAHPAUHWND__@@PBD1I@Z ENDP		; MessageBoxNew
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp
;	COMDAT ?SetResoMode@@YAXH@Z
_TEXT	SEGMENT
_Mode$ = 8						; size = 4
?SetResoMode@@YAXH@Z PROC				; SetResoMode, COMDAT

; 1216 : void SetResoMode( int Mode ){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1217 : 	ResoMode = Mode;

  00004	8b 75 08	 mov	 esi, DWORD PTR _Mode$[ebp]

; 1218 : 	lpDraw = ( DIRECT_DRAW *)HeapAlloc( GetProcessHeap(),HEAP_ZERO_MEMORY, ( DWORD )sizeof( DIRECT_DRAW ) );

  00007	68 8c 00 00 00	 push	 140			; 0000008cH
  0000c	6a 08		 push	 8
  0000e	89 35 00 00 00
	00		 mov	 DWORD PTR ?ResoMode@@3HA, esi ; ResoMode
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapAlloc@12
  00021	a3 00 00 00 00	 mov	 DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A, eax ; lpDraw

; 1219 : 	if( lpDraw == NULL ){

  00026	85 c0		 test	 eax, eax
  00028	75 1b		 jne	 SHORT $LN4@SetResoMod

; 1220 : 		MessageBox( hWnd, "HeapAlloc Error ( DIRECT_DRAW )", "ÌôïÏù∏", MB_OK | MB_ICONSTOP );

  0002a	6a 10		 push	 16			; 00000010H
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_04IJNKKJEO@?H?$KO?$MA?N@
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@DDNACEOP@HeapAlloc?5Error?5?$CI?5DIRECT_DRAW?5?$CJ@
  00036	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  00042	5e		 pop	 esi

; 1255 : 		SurfaceSizeX = 64;
; 1256 : 		SurfaceSizeY = 48;
; 1257 : 		break;
; 1258 : #endif
; 1259 : 	}
; 1260 : }

  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
$LN4@SetResoMod:

; 1221 : 		return;
; 1222 : 	}
; 1223 : 	switch(Mode){

  00045	83 fe 04	 cmp	 esi, 4
  00048	0f 87 9a 00 00
	00		 ja	 $LN2@SetResoMod
  0004e	ff 24 b5 00 00
	00 00		 jmp	 DWORD PTR $LN11@SetResoMod[esi*4]
$LN5@SetResoMod:

; 1255 : 		SurfaceSizeX = 64;
; 1256 : 		SurfaceSizeY = 48;
; 1257 : 		break;
; 1258 : #endif
; 1259 : 	}
; 1260 : }

  00055	c7 80 84 00 00
	00 80 02 00 00	 mov	 DWORD PTR [eax+132], 640 ; 00000280H
  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00064	c7 80 88 00 00
	00 e0 01 00 00	 mov	 DWORD PTR [eax+136], 480 ; 000001e0H
  0006e	eb 64		 jmp	 SHORT $LN12@SetResoMod
$LN6@SetResoMod:

; 1224 : 	case 0:
; 1225 : 		//460*480
; 1226 : 		lpDraw->xSize =640;
; 1227 : 		lpDraw->ySize = 480;
; 1228 : 		SurfaceSizeX = 64;
; 1229 : 		SurfaceSizeY = 48;
; 1230 : 		break;
; 1231 : 	case 1:
; 1232 : 		//320*240
; 1233 : 		lpDraw->xSize = 320;

  00070	c7 80 84 00 00
	00 40 01 00 00	 mov	 DWORD PTR [eax+132], 320 ; 00000140H

; 1234 : 		lpDraw->ySize = 240;

  0007a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0007f	5e		 pop	 esi
  00080	c7 80 88 00 00
	00 f0 00 00 00	 mov	 DWORD PTR [eax+136], 240 ; 000000f0H

; 1235 : 		SurfaceSizeX = 32;

  0008a	c7 05 00 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?SurfaceSizeX@@3HA, 32 ; SurfaceSizeX, 00000020H

; 1236 : 		SurfaceSizeY = 24;

  00094	c7 05 00 00 00
	00 18 00 00 00	 mov	 DWORD PTR ?SurfaceSizeY@@3HA, 24 ; SurfaceSizeY, 00000018H

; 1255 : 		SurfaceSizeX = 64;
; 1256 : 		SurfaceSizeY = 48;
; 1257 : 		break;
; 1258 : #endif
; 1259 : 	}
; 1260 : }

  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
$LN8@SetResoMod:

; 1237 : 		break;
; 1238 : 	case 2:
; 1239 : 		//ÂèØÂèò
; 1240 : 		lpDraw->xSize = 640;
; 1241 : 		lpDraw->ySize = 480;
; 1242 : 		SurfaceSizeX = 64;
; 1243 : 		SurfaceSizeY = 48;
; 1244 : 		break;
; 1245 : #ifdef _NEW_RESOMODE
; 1246 : 	case 3:
; 1247 : 		lpDraw->xSize = 800;

  000a0	c7 80 84 00 00
	00 20 03 00 00	 mov	 DWORD PTR [eax+132], 800 ; 00000320H

; 1248 : 		lpDraw->ySize = 600;

  000aa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  000af	c7 80 88 00 00
	00 58 02 00 00	 mov	 DWORD PTR [eax+136], 600 ; 00000258H

; 1249 : 		SurfaceSizeX = 64;
; 1250 : 		SurfaceSizeY = 48;
; 1251 : 		break;

  000b9	eb 19		 jmp	 SHORT $LN12@SetResoMod
$LN9@SetResoMod:

; 1252 : 	case 4:
; 1253 : 		lpDraw->xSize = 1024;

  000bb	c7 80 84 00 00
	00 00 04 00 00	 mov	 DWORD PTR [eax+132], 1024 ; 00000400H

; 1254 : 		lpDraw->ySize = 768;

  000c5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  000ca	c7 80 88 00 00
	00 00 03 00 00	 mov	 DWORD PTR [eax+136], 768 ; 00000300H
$LN12@SetResoMod:

; 1255 : 		SurfaceSizeX = 64;
; 1256 : 		SurfaceSizeY = 48;
; 1257 : 		break;
; 1258 : #endif
; 1259 : 	}
; 1260 : }

  000d4	c7 05 00 00 00
	00 30 00 00 00	 mov	 DWORD PTR ?SurfaceSizeY@@3HA, 48 ; SurfaceSizeY, 00000030H
  000de	c7 05 00 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?SurfaceSizeX@@3HA, 64 ; SurfaceSizeX, 00000040H
$LN2@SetResoMod:
  000e8	5e		 pop	 esi
  000e9	5d		 pop	 ebp
  000ea	c3		 ret	 0
  000eb	90		 npad	 1
$LN11@SetResoMod:
  000ec	00 00 00 00	 DD	 $LN5@SetResoMod
  000f0	00 00 00 00	 DD	 $LN6@SetResoMod
  000f4	00 00 00 00	 DD	 $LN5@SetResoMod
  000f8	00 00 00 00	 DD	 $LN8@SetResoMod
  000fc	00 00 00 00	 DD	 $LN9@SetResoMod
?SetResoMode@@YAXH@Z ENDP				; SetResoMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp
;	COMDAT ?ChangeWindowMode@@YAXXZ
_TEXT	SEGMENT
_clientRect$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
?ChangeWindowMode@@YAXXZ PROC				; ChangeWindowMode, COMDAT

; 512  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 513  : 	RECT clientRect;		// „ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÅÆË°®Á§∫È†òÂüü
; 514  : 	DWORD windowStyle;		// „Ç¶„Ç£„É≥„Éâ„Ç¶„Çπ„Çø„Ç§„É´
; 515  : 	ChangeMode(WindowMode);

  00011	ff 35 00 00 00
	00		 push	 DWORD PTR ?WindowMode@@3HA ; WindowMode
  00017	e8 00 00 00 00	 call	 ?ChangeMode@@YAXH@Z	; ChangeMode
  0001c	83 c4 04	 add	 esp, 4

; 516  : 	// „Ç¶„Ç£„É≥„Éâ„Ç¶„É¢„Éº„Éâ„ÅÆÊôÇ
; 517  : 	if( WindowMode ){

  0001f	b8 00 00 ca 00	 mov	 eax, 13238272		; 00ca0000H
  00024	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?WindowMode@@3HA, 0 ; WindowMode
  0002b	be 00 00 00 90	 mov	 esi, -1879048192	; 90000000H
  00030	0f 45 f0	 cmovne	 esi, eax

; 518  : 		// „Ç¶„Ç£„É≥„Éâ„Ç¶„Çπ„Çø„Ç§„É´
; 519  : 		windowStyle = WS_MINIMIZEBOX | WS_SYSMENU | 
; 520  : 						//WS_THICKFRAME |
; 521  : 						WS_CAPTION | WS_OVERLAPPED;
; 522  : 	}else{	
; 523  : 		// „Ç¶„Ç£„É≥„Éâ„Ç¶„Çπ„Çø„Ç§„É´
; 524  : 		windowStyle = WS_VISIBLE | WS_POPUP;
; 525  : 	}
; 526  : 	// „ÇØ„É©„Ç§„Ç¢„É≥„ÉàÈ†òÂüü„ÅÆË®≠ÂÆö
; 527  : 	SetRect( &clientRect, 0, 0, lpDraw->xSize, lpDraw->ySize );

  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00038	ff b0 88 00 00
	00		 push	 DWORD PTR [eax+136]
  0003e	ff b0 84 00 00
	00		 push	 DWORD PTR [eax+132]
  00044	8d 45 ec	 lea	 eax, DWORD PTR _clientRect$[ebp]
  00047	6a 00		 push	 0
  00049	6a 00		 push	 0
  0004b	50		 push	 eax
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 528  : 	// „ÇØ„É©„Ç§„Ç¢„É≥„ÉàÈ†òÂüü„ÅÆ„Çµ„Ç§„Ç∫„Åã„Çâ„Ç¶„Ç£„É≥„Éâ„Ç¶„Çµ„Ç§„Ç∫„ÇíË®àÁÆó„Åó clientRect „Å∏ÂÖ•„Çå„Çã
; 529  : 	AdjustWindowRectEx( &clientRect, windowStyle, FALSE, NULL );

  00052	6a 00		 push	 0
  00054	6a 00		 push	 0
  00056	56		 push	 esi
  00057	8d 45 ec	 lea	 eax, DWORD PTR _clientRect$[ebp]
  0005a	50		 push	 eax
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AdjustWindowRectEx@16

; 530  : 	if( hWnd == NULL ){	// DirectDraw„ÅåÂàùÊúüÂåñ„Åï„Çå„Å¶„Å™„ÅÑ„Å®„Åç

  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  00066	85 c0		 test	 eax, eax
  00068	75 35		 jne	 SHORT $LN4@ChangeWind

; 531  : 		hWnd = CreateWindowEx( 	NULL, 

  0006a	50		 push	 eax
  0006b	ff 35 00 00 00
	00		 push	 DWORD PTR ?hInst@@3PAUHINSTANCE__@@A ; hInst
  00071	50		 push	 eax
  00072	50		 push	 eax
  00073	8b 45 f8	 mov	 eax, DWORD PTR _clientRect$[ebp+12]
  00076	2b 45 f0	 sub	 eax, DWORD PTR _clientRect$[ebp+4]
  00079	50		 push	 eax
  0007a	8b 45 f4	 mov	 eax, DWORD PTR _clientRect$[ebp+8]
  0007d	2b 45 ec	 sub	 eax, DWORD PTR _clientRect$[ebp]
  00080	50		 push	 eax
  00081	6a 00		 push	 0
  00083	6a 00		 push	 0
  00085	56		 push	 esi
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@NLNMPB@?$KD?S?$KD?t?$KD?o?$KD?n?$KD?e?$KD?A?$KD?g?$KD?e@
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@NLNMPB@?$KD?S?$KD?t?$KD?o?$KD?n?$KD?e?$KD?A?$KD?g?$KD?e@
  00090	6a 00		 push	 0
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateWindowExA@48
  00098	a3 00 00 00 00	 mov	 DWORD PTR ?hWnd@@3PAUHWND__@@A, eax ; hWnd

; 532  : 								DEF_APPNAME, 
; 533  : 								DEF_APPNAME, 
; 534  : 								windowStyle,
; 535  : 								//CW_USEDEFAULT, 
; 536  : 								//CW_USEDEFAULT, 
; 537  : 								0, 
; 538  : 								0, 
; 539  : 								clientRect.right - clientRect.left, 
; 540  : 								clientRect.bottom - clientRect.top, 
; 541  : 								NULL, 
; 542  : 								NULL, 
; 543  : 								hInst, 
; 544  : 								NULL );
; 545  : 	}else{

  0009d	eb 31		 jmp	 SHORT $LN5@ChangeWind
$LN4@ChangeWind:

; 546  : 		// „Ç¶„Ç£„É≥„Éâ„Ç¶„Çπ„Çø„Ç§„É´„ÅÆÂ§âÊõ¥
; 547  : 		SetWindowLong( hWnd, GWL_STYLE, windowStyle );

  0009f	56		 push	 esi
  000a0	6a f0		 push	 -16			; fffffff0H
  000a2	50		 push	 eax
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowLongA@12

; 548  : 		// ‰ΩúÊàê„Åó„Åü„Ç¶„Ç§„É≥„Éâ„Ç¶„ÇíË°®Á§∫
; 549  : //		ShowWindow( hWnd, CmdShow );
; 550  : 		// „Ç¶„Ç£„É≥„Éâ„Ç¶„ÅÆ‰ΩçÁΩÆ„Å®„Çµ„Ç§„Ç∫„ÅÆÂ§âÊõ¥
; 551  : 		SetWindowPos( 	hWnd, 

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _clientRect$[ebp+12]
  000ac	2b 45 f0	 sub	 eax, DWORD PTR _clientRect$[ebp+4]
  000af	6a 20		 push	 32			; 00000020H
  000b1	50		 push	 eax
  000b2	8b 45 f4	 mov	 eax, DWORD PTR _clientRect$[ebp+8]
  000b5	2b 45 ec	 sub	 eax, DWORD PTR _clientRect$[ebp]
  000b8	50		 push	 eax
  000b9	6a 00		 push	 0
  000bb	6a 00		 push	 0
  000bd	6a fe		 push	 -2			; fffffffeH
  000bf	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28
  000cb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
$LN5@ChangeWind:

; 552  : 						HWND_NOTOPMOST, 
; 553  : 						0, 
; 554  : 						0, 
; 555  : 						clientRect.right - clientRect.left, 
; 556  : 						clientRect.bottom - clientRect.top, 
; 557  : 						//SWP_SHOWWINDOW );
; 558  : 						SWP_FRAMECHANGED );
; 559  : 	}
; 560  : 
; 561  : 	// ‰ΩúÊàê„Åó„Åü„Ç¶„Ç§„É≥„Éâ„Ç¶„ÇíË°®Á§∫
; 562  : 	ShowWindow( hWnd, CmdShow );

  000d0	ff 35 00 00 00
	00		 push	 DWORD PTR ?CmdShow@@3HA	; CmdShow
  000d6	50		 push	 eax
  000d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 563  : 
; 564  : 	// „Ç¶„Ç£„É≥„Éâ„Ç¶„ÇíË°®Á§∫Êõ¥Êñ∞
; 565  : 	UpdateWindow( hWnd );

  000dd	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UpdateWindow@4

; 566  : }

  000e9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ec	33 cd		 xor	 ecx, ebp
  000ee	5e		 pop	 esi
  000ef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
?ChangeWindowMode@@YAXXZ ENDP				; ChangeWindowMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp
;	COMDAT ?AnalyzeCmdLine@@YAXXZ
_TEXT	SEGMENT
?AnalyzeCmdLine@@YAXXZ PROC				; AnalyzeCmdLine, COMDAT
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h

; 520  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_08MPGDICFK@realbin?3@
  00005	ff 35 00 00 00
	00		 push	 DWORD PTR ?CmdLine@@3PADA ; CmdLine
  0000b	e8 00 00 00 00	 call	 _strstr
  00010	83 c4 08	 add	 esp, 8
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp

; 481  : 	if( addr = strstr( CmdLine, "realbin:" ) )

  00013	85 c0		 test	 eax, eax
  00015	74 1c		 je	 SHORT $LN2@AnalyzeCmd

; 482  : 		sprintf( realBinName, "data\\real_%d.bin", atoi(addr+strlen("realbin:")) );

  00017	83 c0 08	 add	 eax, 8
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _atoi
  00020	50		 push	 eax
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@BDNGKHBG@data?2real_?$CFd?4bin@
  00026	68 00 00 00 00	 push	 OFFSET ?realBinName@@3PADA ; realBinName
  0002b	e8 00 00 00 00	 call	 _sprintf
  00030	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@AnalyzeCmd:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h

; 520  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  00033	68 00 00 00 00	 push	 OFFSET ??_C@_08INHKNLCI@adrnbin?3@
  00038	ff 35 00 00 00
	00		 push	 DWORD PTR ?CmdLine@@3PADA ; CmdLine
  0003e	e8 00 00 00 00	 call	 _strstr
  00043	83 c4 08	 add	 esp, 8
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp

; 483  : 	if( addr = strstr( CmdLine, "adrnbin:" ) )

  00046	85 c0		 test	 eax, eax
  00048	74 1c		 je	 SHORT $LN3@AnalyzeCmd

; 484  : 		sprintf( adrnBinName, "data\\adrn_%d.bin", atoi(addr+strlen("adrnbin:")) );

  0004a	83 c0 08	 add	 eax, 8
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 _atoi
  00053	50		 push	 eax
  00054	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@ELLBFFLH@data?2adrn_?$CFd?4bin@
  00059	68 00 00 00 00	 push	 OFFSET ?adrnBinName@@3PADA ; adrnBinName
  0005e	e8 00 00 00 00	 call	 _sprintf
  00063	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@AnalyzeCmd:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h

; 520  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  00066	68 00 00 00 00	 push	 OFFSET ??_C@_07NALMGOPD@sprbin?3@
  0006b	ff 35 00 00 00
	00		 push	 DWORD PTR ?CmdLine@@3PADA ; CmdLine
  00071	e8 00 00 00 00	 call	 _strstr
  00076	83 c4 08	 add	 esp, 8
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp

; 485  : 	if( addr = strstr( CmdLine, "sprbin:" ) )

  00079	85 c0		 test	 eax, eax
  0007b	74 1c		 je	 SHORT $LN4@AnalyzeCmd

; 486  : 		sprintf( sprBinName, "data\\spr_%d.bin", atoi(addr+strlen("sprbin:")) );

  0007d	83 c0 07	 add	 eax, 7
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 _atoi
  00086	50		 push	 eax
  00087	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@ICLKDLOG@data?2spr_?$CFd?4bin@
  0008c	68 00 00 00 00	 push	 OFFSET ?sprBinName@@3PADA ; sprBinName
  00091	e8 00 00 00 00	 call	 _sprintf
  00096	83 c4 10	 add	 esp, 16			; 00000010H
$LN4@AnalyzeCmd:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h

; 520  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  00099	68 00 00 00 00	 push	 OFFSET ??_C@_0M@EPOMFNLL@spradrnbin?3@
  0009e	ff 35 00 00 00
	00		 push	 DWORD PTR ?CmdLine@@3PADA ; CmdLine
  000a4	e8 00 00 00 00	 call	 _strstr
  000a9	83 c4 08	 add	 esp, 8
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp

; 487  : 	if( addr = strstr( CmdLine, "spradrnbin:" ) )

  000ac	85 c0		 test	 eax, eax
  000ae	74 1c		 je	 SHORT $LN5@AnalyzeCmd

; 488  : 		sprintf( sprAdrnBinName, "data\\spradrn_%d.bin", atoi(addr+strlen("spradrnbin:")) );

  000b0	83 c0 0b	 add	 eax, 11			; 0000000bH
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 _atoi
  000b9	50		 push	 eax
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@LHBEADJK@data?2spradrn_?$CFd?4bin@
  000bf	68 00 00 00 00	 push	 OFFSET ?sprAdrnBinName@@3PADA ; sprAdrnBinName
  000c4	e8 00 00 00 00	 call	 _sprintf
  000c9	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@AnalyzeCmd:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h

; 520  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_07CGONDAHB@nodelay@
  000d1	ff 35 00 00 00
	00		 push	 DWORD PTR ?CmdLine@@3PADA ; CmdLine
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp

; 503  : 	WindowMode = TRUE;

  000d7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?WindowMode@@3HA, 1 ; WindowMode
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h

; 520  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  000e1	e8 00 00 00 00	 call	 _strstr
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp

; 504  : 	if( strstr( CmdLine, "nodelay" ) )

  000e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?NoDelay@@3HA ; NoDelay
  000ec	33 d2		 xor	 edx, edx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h

; 520  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  000ee	83 c4 08	 add	 esp, 8
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp

; 507  : 	ProcNo = PROC_ID_PASSWORD;

  000f1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?ProcNo@@3IA, 1 ; ProcNo
  000fb	85 c0		 test	 eax, eax
  000fd	0f 45 ca	 cmovne	 ecx, edx
  00100	89 0d 00 00 00
	00		 mov	 DWORD PTR ?NoDelay@@3HA, ecx ; NoDelay

; 508  : 
; 509  : }

  00106	c3		 ret	 0
?AnalyzeCmdLine@@YAXXZ ENDP				; AnalyzeCmdLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp
;	COMDAT ?SystemTask@@YAHXZ
_TEXT	SEGMENT
_msg$ = -28						; size = 28
?SystemTask@@YAHXZ PROC					; SystemTask, COMDAT

; 638  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 639  : 	MSG msg;
; 640  : 	
; 641  : 	// ‚òÜ‚òÖ‚òÜ‚òÖ‚òÜ „É°„ÉÉ„Çª„Éº„Ç∏„É´„Éº„Éó ‚òÜ‚òÖ‚òÜ‚òÖ‚òÜ
; 642  : 	// „É°„ÉÉ„Çª„Éº„Ç∏„Åå„ÅÇ„ÇãÈñì„É´„Éº„Éó
; 643  : 	while( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE )){

  00006	8d 45 e4	 lea	 eax, DWORD PTR _msg$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__PeekMessageA@20
  00011	57		 push	 edi
  00012	6a 01		 push	 1
  00014	6a 00		 push	 0
  00016	6a 00		 push	 0
  00018	6a 00		 push	 0
  0001a	50		 push	 eax
  0001b	ff d6		 call	 esi
  0001d	85 c0		 test	 eax, eax
  0001f	74 7e		 je	 SHORT $LN3@SystemTask
  00021	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__TranslateMessage@4
  00027	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__DispatchMessageA@4
  0002d	0f 1f 00	 npad	 3
$LL2@SystemTask:

; 644  : 		// „É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂèó„ÅëÂèñ„Çã„ÄÅWM_QUIT „ÇíÂèó„ÅëÂèñ„Çã„Å®FALSE„ÅåËøî„Å£„Å¶„Åç„Å¶ÁµÇ‰∫Ü
; 645  : 		//if( GetMessage( &msg, NULL, 0, 0 ) == FALSE ) return FALSE; 
; 646  : 		// WM_QUIT „ÇíÂèó„ÅëÂèñ„Çã„Å®ÁµÇ‰∫Ü
; 647  : 		if( msg.message == WM_QUIT )

  00030	8b 45 e8	 mov	 eax, DWORD PTR _msg$[ebp+4]
  00033	83 f8 12	 cmp	 eax, 18			; 00000012H
  00036	74 73		 je	 SHORT $LN15@SystemTask

; 648  : 			return FALSE;
; 649  : 		else if (msg.message == WM_USER + 888)

  00038	3d 78 07 00 00	 cmp	 eax, 1912		; 00000778H
  0003d	75 10		 jne	 SHORT $LN6@SystemTask

; 650  : 		{
; 651  : 			JL_SetAddr(msg.wParam, msg.lParam);

  0003f	ff 75 f0	 push	 DWORD PTR _msg$[ebp+12]
  00042	ff 75 ec	 push	 DWORD PTR _msg$[ebp+8]
  00045	e8 00 00 00 00	 call	 ?JL_SetAddr@@YAXHH@Z	; JL_SetAddr
  0004a	83 c4 08	 add	 esp, 8

; 652  : 			continue;

  0004d	eb 3e		 jmp	 SHORT $LN16@SystemTask
$LN6@SystemTask:

; 653  : 		}
; 654  : 		else if (msg.message == WM_USER + 887)

  0004f	3d 77 07 00 00	 cmp	 eax, 1911		; 00000777H
  00054	75 2b		 jne	 SHORT $LN10@SystemTask

; 655  : 		{
; 656  : 			extern int g_WgRecvHwnd, g_playerAddr;
; 657  : 			g_WgRecvHwnd = msg.wParam;
; 658  : 			g_playerAddr = msg.lParam;
; 659  : 
; 660  : 			extern HWND hWnd;
; 661  : 			if (hWnd)

  00056	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  0005c	8b 45 ec	 mov	 eax, DWORD PTR _msg$[ebp+8]
  0005f	8b 4d f0	 mov	 ecx, DWORD PTR _msg$[ebp+12]
  00062	a3 00 00 00 00	 mov	 DWORD PTR ?g_WgRecvHwnd@@3HA, eax ; g_WgRecvHwnd
  00067	89 0d 00 00 00
	00		 mov	 DWORD PTR ?g_playerAddr@@3HA, ecx ; g_playerAddr
  0006d	85 d2		 test	 edx, edx
  0006f	74 43		 je	 SHORT $LN9@SystemTask

; 662  : 			{
; 663  : 				SendMessage((HWND)g_WgRecvHwnd, WM_USER + 1, (WPARAM)hWnd, (LPARAM)g_playerAddr);

  00071	51		 push	 ecx
  00072	52		 push	 edx
  00073	68 01 04 00 00	 push	 1025			; 00000401H
  00078	50		 push	 eax
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 664  : 				continue;

  0007f	eb 0c		 jmp	 SHORT $LN16@SystemTask
$LN10@SystemTask:

; 670  : 			}
; 671  : 	
; 672  : 		}
; 673  : 
; 674  : 		TranslateMessage(&msg);		// Óüâ??Óùß????????Óüâ???

  00081	8d 45 e4	 lea	 eax, DWORD PTR _msg$[ebp]
  00084	50		 push	 eax
  00085	ff d7		 call	 edi

; 675  : 		
; 676  : 		DispatchMessage(&msg);		// ????????????????????

  00087	8d 45 e4	 lea	 eax, DWORD PTR _msg$[ebp]
  0008a	50		 push	 eax
  0008b	ff d3		 call	 ebx
$LN16@SystemTask:

; 639  : 	MSG msg;
; 640  : 	
; 641  : 	// ‚òÜ‚òÖ‚òÜ‚òÖ‚òÜ „É°„ÉÉ„Çª„Éº„Ç∏„É´„Éº„Éó ‚òÜ‚òÖ‚òÜ‚òÖ‚òÜ
; 642  : 	// „É°„ÉÉ„Çª„Éº„Ç∏„Åå„ÅÇ„ÇãÈñì„É´„Éº„Éó
; 643  : 	while( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE )){

  0008d	6a 01		 push	 1
  0008f	6a 00		 push	 0
  00091	6a 00		 push	 0
  00093	6a 00		 push	 0
  00095	8d 45 e4	 lea	 eax, DWORD PTR _msg$[ebp]
  00098	50		 push	 eax
  00099	ff d6		 call	 esi
  0009b	85 c0		 test	 eax, eax
  0009d	75 91		 jne	 SHORT $LL2@SystemTask
$LN3@SystemTask:
  0009f	5f		 pop	 edi

; 677  : 			
; 678  : 	}
; 679  : 	return TRUE;
; 680  : }

  000a0	5e		 pop	 esi
  000a1	b8 01 00 00 00	 mov	 eax, 1
  000a6	5b		 pop	 ebx
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
$LN15@SystemTask:
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	33 c0		 xor	 eax, eax
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
$LN9@SystemTask:

; 665  : 			}
; 666  : 			else
; 667  : 			{
; 668  : 				MessageBox(0, 0, 0, 0);

  000b4	6a 00		 push	 0
  000b6	6a 00		 push	 0
  000b8	6a 00		 push	 0
  000ba	6a 00		 push	 0
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 669  : 				exit(0);

  000c2	6a 00		 push	 0
  000c4	e8 00 00 00 00	 call	 _exit
$LN20@SystemTask:
  000c9	cc		 int	 3
?SystemTask@@YAHXZ ENDP					; SystemTask
_TEXT	ENDS
; Function compile flags: /Odtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp
;	COMDAT ?WindMsgProc@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
tv195 = -28						; size = 4
_para_count$1 = -24					; size = 4
$T2 = -20						; size = 4
_p$3 = -16						; size = 4
tv178 = -12						; size = 4
_i$4 = -8						; size = 4
tv64 = -4						; size = 4
_hWnd$ = 8						; size = 4
_Message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?WindMsgProc@@YGJPAUHWND__@@IIJ@Z PROC			; WindMsgProc, COMDAT

; 693  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 694  : 
; 695  : 	switch( Message ){

  00009	8b 45 0c	 mov	 eax, DWORD PTR _Message$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR tv64[ebp], eax
  0000f	83 7d fc 10	 cmp	 DWORD PTR tv64[ebp], 16	; 00000010H
  00013	77 27		 ja	 SHORT $LN81@WindMsgPro
  00015	83 7d fc 10	 cmp	 DWORD PTR tv64[ebp], 16	; 00000010H
  00019	0f 84 3e 03 00
	00		 je	 $LN33@WindMsgPro
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR tv64[ebp]
  00022	83 e9 01	 sub	 ecx, 1
  00025	89 4d fc	 mov	 DWORD PTR tv64[ebp], ecx
  00028	83 7d fc 05	 cmp	 DWORD PTR tv64[ebp], 5
  0002c	0f 87 eb 07 00
	00		 ja	 $LN76@WindMsgPro
  00032	8b 55 fc	 mov	 edx, DWORD PTR tv64[ebp]
  00035	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN84@WindMsgPro[edx*4]
$LN81@WindMsgPro:
  0003c	81 7d fc 00 02
	00 00		 cmp	 DWORD PTR tv64[ebp], 512 ; 00000200H
  00043	77 34		 ja	 SHORT $LN82@WindMsgPro
  00045	81 7d fc 00 02
	00 00		 cmp	 DWORD PTR tv64[ebp], 512 ; 00000200H
  0004c	0f 84 c7 05 00
	00		 je	 $LN63@WindMsgPro
  00052	8b 45 fc	 mov	 eax, DWORD PTR tv64[ebp]
  00055	83 e8 4a	 sub	 eax, 74			; 0000004aH
  00058	89 45 fc	 mov	 DWORD PTR tv64[ebp], eax
  0005b	81 7d fc c9 00
	00 00		 cmp	 DWORD PTR tv64[ebp], 201 ; 000000c9H
  00062	0f 87 b5 07 00
	00		 ja	 $LN76@WindMsgPro
  00068	8b 4d fc	 mov	 ecx, DWORD PTR tv64[ebp]
  0006b	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN85@WindMsgPro[ecx]
  00072	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN86@WindMsgPro[edx*4]
$LN82@WindMsgPro:
  00079	81 7d fc 09 07
	00 00		 cmp	 DWORD PTR tv64[ebp], 1801 ; 00000709H
  00080	77 2c		 ja	 SHORT $LN83@WindMsgPro
  00082	81 7d fc 09 07
	00 00		 cmp	 DWORD PTR tv64[ebp], 1801 ; 00000709H
  00089	0f 84 b3 00 00
	00		 je	 $LN15@WindMsgPro
  0008f	8b 45 fc	 mov	 eax, DWORD PTR tv64[ebp]
  00092	2d 01 02 00 00	 sub	 eax, 513		; 00000201H
  00097	89 45 fc	 mov	 DWORD PTR tv64[ebp], eax
  0009a	83 7d fc 06	 cmp	 DWORD PTR tv64[ebp], 6
  0009e	0f 87 79 07 00
	00		 ja	 $LN76@WindMsgPro
  000a4	8b 4d fc	 mov	 ecx, DWORD PTR tv64[ebp]
  000a7	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN87@WindMsgPro[ecx*4]
$LN83@WindMsgPro:
  000ae	81 7d fc 78 07
	00 00		 cmp	 DWORD PTR tv64[ebp], 1912 ; 00000778H
  000b5	0f 84 aa 00 00
	00		 je	 $LN16@WindMsgPro
  000bb	e9 5d 07 00 00	 jmp	 $LN76@WindMsgPro
$LN11@WindMsgPro:

; 696  : 
; 697  : 			//JL 2016.8.26 ÊøÄÊ¥ªÁü≥Âô®ÔºåÁ™óÂè£ÂàõÂª∫ÔºåÂèëÈÄÅÊ∏∏ÊàèÁ™óÂè£Âè•ÊüÑÁªôÂ§ñÊåÇ
; 698  : 			//ÊåÇÊé•ÁöÑÊÉÖÂÜµ‰∏çÁî®ËÄÉËôëËøôÁÇπÔºåÂ§ñÊåÇËá™Ë°åËé∑Âèñ
; 699  : 		case WM_CREATE:
; 700  : 			extern int g_WgRecvHwnd, g_playerAddr;
; 701  : 			__asm {
; 702  : 				jmp _Â≠óËäÇÂÆö‰πâÂÆåÊàê;

  000c0	eb 08		 jmp	 SHORT $_ÌÆ?Ô“?Ë«‡˜$90

; 703  : 				_emit 0xAA;

  000c2	aa		 DB	 -86			; ffffffaaH

; 704  : 				_emit 0xAA;

  000c3	aa		 DB	 -86			; ffffffaaH

; 705  : 				_emit 0xAA;

  000c4	aa		 DB	 -86			; ffffffaaH

; 706  : 				_emit 0xAA;

  000c5	aa		 DB	 -86			; ffffffaaH

; 707  : 				_emit 0xBB;

  000c6	bb		 DB	 -69			; ffffffbbH

; 708  : 				_emit 0xBB;

  000c7	bb		 DB	 -69			; ffffffbbH

; 709  : 				_emit 0xBB;

  000c8	bb		 DB	 -69			; ffffffbbH

; 710  : 				_emit 0xBB;

  000c9	bb		 DB	 -69			; ffffffbbH
$_ÌÆ?Ô“?Ë«‡˜$90:

; 711  : 			_Â≠óËäÇÂÆö‰πâÂÆåÊàê:;
; 712  : 				mov eax, _Â≠óËäÇÂÆö‰πâÂÆåÊàê - 8;

  000ca	b8 f8 ff ff ff	 mov	 eax, OFFSET $_ÌÆ?Ô“?Ë«‡˜$90-8

; 713  : 				mov eax, [eax];

  000cf	8b 00		 mov	 eax, DWORD PTR [eax]

; 714  : 				cmp eax, 0xAAAAAAAA;

  000d1	3d aa aa aa aa	 cmp	 eax, -1431655766	; aaaaaaaaH

; 715  : 				jz _temp;

  000d6	74 11		 je	 SHORT $_temp$91

; 716  : 				mov g_WgRecvHwnd, eax;

  000d8	a3 00 00 00 00	 mov	 DWORD PTR ?g_WgRecvHwnd@@3HA, eax ; g_WgRecvHwnd

; 717  : 				mov eax, _Â≠óËäÇÂÆö‰πâÂÆåÊàê - 4;

  000dd	b8 fc ff ff ff	 mov	 eax, OFFSET $_ÌÆ?Ô“?Ë«‡˜$90-4

; 718  : 				mov eax, [eax];

  000e2	8b 00		 mov	 eax, DWORD PTR [eax]

; 719  : 				mov g_playerAddr, eax;

  000e4	a3 00 00 00 00	 mov	 DWORD PTR ?g_playerAddr@@3HA, eax ; g_playerAddr
$_temp$91:

; 720  : 			_temp:;
; 721  : 			}
; 722  : 			if (g_WgRecvHwnd)

  000e9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_WgRecvHwnd@@3HA, 0 ; g_WgRecvHwnd
  000f0	74 2f		 je	 SHORT $LN12@WindMsgPro

; 723  : 			{
; 724  : 				SetTimer(hWnd, 0, 1000 * 20, 0); //20Áßí

  000f2	6a 00		 push	 0
  000f4	68 20 4e 00 00	 push	 20000			; 00004e20H
  000f9	6a 00		 push	 0
  000fb	8b 55 08	 mov	 edx, DWORD PTR _hWnd$[ebp]
  000fe	52		 push	 edx
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16

; 725  : 				SendMessageA((HWND)g_WgRecvHwnd, WM_USER + 1, (WPARAM)hWnd, g_playerAddr);

  00105	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_playerAddr@@3HA ; g_playerAddr
  0010a	50		 push	 eax
  0010b	8b 4d 08	 mov	 ecx, DWORD PTR _hWnd$[ebp]
  0010e	51		 push	 ecx
  0010f	68 01 04 00 00	 push	 1025			; 00000401H
  00114	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_WgRecvHwnd@@3HA ; g_WgRecvHwnd
  0011a	52		 push	 edx
  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
$LN12@WindMsgPro:

; 726  : 			}
; 727  : 
; 728  : 
; 729  : 			break;

  00121	e9 2b 07 00 00	 jmp	 $LN2@WindMsgPro
$LN13@WindMsgPro:

; 730  : 		case WM_TIMER:
; 731  : 			//JL ËÆæÁΩÆtimerÊ£ÄÊµãÂ§ñÊåÇÊòØÂê¶Â≠òÂú®Ôºå‰∏çÂ≠òÂú®ÂàôÈÄÄÂá∫
; 732  : 			if (IsWindow((HWND)g_WgRecvHwnd) == false) exit(0);

  00126	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_WgRecvHwnd@@3HA ; g_WgRecvHwnd
  0012b	50		 push	 eax
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsWindow@4
  00132	85 c0		 test	 eax, eax
  00134	75 07		 jne	 SHORT $LN14@WindMsgPro
  00136	6a 00		 push	 0
  00138	e8 00 00 00 00	 call	 _exit
$LN14@WindMsgPro:

; 733  : 			break;

  0013d	e9 0f 07 00 00	 jmp	 $LN2@WindMsgPro
$LN15@WindMsgPro:

; 734  : 
; 735  : 			//JL
; 736  : 			//wparam - wgÁöÑhwnd, lparam - ÈúÄË¶ÅËé∑ÂæóÁöÑindex
; 737  : 		case WM_USER + 777:
; 738  : 			SendMessage((HWND)wParam, WM_USER + 777, (WPARAM)JL_GetAddress(lParam), 0);

  00142	6a 00		 push	 0
  00144	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  00147	51		 push	 ecx
  00148	e8 00 00 00 00	 call	 ?JL_GetAddress@@YAHH@Z	; JL_GetAddress
  0014d	83 c4 04	 add	 esp, 4
  00150	50		 push	 eax
  00151	68 09 07 00 00	 push	 1801			; 00000709H
  00156	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  00159	52		 push	 edx
  0015a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 739  : 
; 740  : 			break;

  00160	e9 ec 06 00 00	 jmp	 $LN2@WindMsgPro
$LN16@WindMsgPro:

; 741  : 
; 742  : 			//JL wgÂèëÈÄÅÊï∞ÊçÆÁªôgame
; 743  : 		case WM_USER + 888:
; 744  : 			JL_SetAddr(wParam, lParam);

  00165	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00168	50		 push	 eax
  00169	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  0016c	51		 push	 ecx
  0016d	e8 00 00 00 00	 call	 ?JL_SetAddr@@YAXHH@Z	; JL_SetAddr
  00172	83 c4 08	 add	 esp, 8

; 745  : 			break;

  00175	e9 d7 06 00 00	 jmp	 $LN2@WindMsgPro
$LN17@WindMsgPro:

; 746  : 
; 747  : 		case WM_COPYDATA:
; 748  : 			if (wParam)

  0017a	83 7d 10 00	 cmp	 DWORD PTR _wParam$[ebp], 0
  0017e	74 24		 je	 SHORT $LN18@WindMsgPro

; 749  : 			{
; 750  : 				COPYDATASTRUCT* p = (COPYDATASTRUCT*)lParam;

  00180	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  00183	89 55 f0	 mov	 DWORD PTR _p$3[ebp], edx

; 751  : 				memcpy((void*)wParam, p->lpData, p->dwData);

  00186	8b 45 f0	 mov	 eax, DWORD PTR _p$3[ebp]
  00189	8b 08		 mov	 ecx, DWORD PTR [eax]
  0018b	51		 push	 ecx
  0018c	8b 55 f0	 mov	 edx, DWORD PTR _p$3[ebp]
  0018f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00192	50		 push	 eax
  00193	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  00196	51		 push	 ecx
  00197	e8 00 00 00 00	 call	 _memcpy
  0019c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 752  : 				break;

  0019f	e9 ad 06 00 00	 jmp	 $LN2@WindMsgPro
$LN18@WindMsgPro:

; 753  : 			}
; 754  : 
; 755  : 			int para_count;
; 756  : 			__asm{
; 757  : 				mov esi, wParam;

  001a4	8b 75 10	 mov	 esi, DWORD PTR _wParam$[ebp]

; 758  : 				mov edi, lParam;

  001a7	8b 7d 14	 mov	 edi, DWORD PTR _lParam$[ebp]

; 759  : 				mov eax, [edi]; //dwdata

  001aa	8b 07		 mov	 eax, DWORD PTR [edi]

; 760  : 				mov para_count, eax;//‰øùÂ≠òstdcallÂèÇÊï∞‰∏™Êï∞

  001ac	89 45 e8	 mov	 DWORD PTR _para_count$1[ebp], eax

; 761  : 
; 762  : 				mov edi, [edi + 8]; //lpdata

  001af	8b 7f 08	 mov	 edi, DWORD PTR [edi+8]

; 763  : 				mov eax, [edi + 4];//stringpos

  001b2	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 764  : 				cmp eax, 0;//ËøòÈúÄÈ™åËØÅeaxÊòØÂê¶ >10 or <1

  001b5	83 f8 00	 cmp	 eax, 0

; 765  : 				jz ___1;

  001b8	74 07		 je	 SHORT $___1$92

; 766  : 				lea ebx, [edi + 48];

  001ba	8d 5f 30	 lea	 ebx, DWORD PTR [edi+48]

; 767  : 				mov[edi + 4 + 4 * eax], ebx;

  001bd	89 5c 87 04	 mov	 DWORD PTR [edi+eax*4+4], ebx
$___1$92:

; 768  : 			___1:;
; 769  : 				push[edi + 11 * 4];

  001c1	ff 77 2c	 push	 DWORD PTR [edi+44]

; 770  : 				push[edi + 10 * 4];

  001c4	ff 77 28	 push	 DWORD PTR [edi+40]

; 771  : 				push[edi + 9 * 4];

  001c7	ff 77 24	 push	 DWORD PTR [edi+36]

; 772  : 				push[edi + 8 * 4];

  001ca	ff 77 20	 push	 DWORD PTR [edi+32]

; 773  : 				push[edi + 7 * 4];

  001cd	ff 77 1c	 push	 DWORD PTR [edi+28]

; 774  : 				push[edi + 6 * 4];

  001d0	ff 77 18	 push	 DWORD PTR [edi+24]

; 775  : 				push[edi + 5 * 4];

  001d3	ff 77 14	 push	 DWORD PTR [edi+20]

; 776  : 				push[edi + 4 * 4];

  001d6	ff 77 10	 push	 DWORD PTR [edi+16]

; 777  : 				push[edi + 3 * 4];

  001d9	ff 77 0c	 push	 DWORD PTR [edi+12]

; 778  : 				push[edi + 2 * 4];

  001dc	ff 77 08	 push	 DWORD PTR [edi+8]

; 779  : 				call[edi];

  001df	ff 17		 call	 DWORD PTR [edi]

; 780  : 				mov eax, para_count;

  001e1	8b 45 e8	 mov	 eax, DWORD PTR _para_count$1[ebp]

; 781  : 				mov ecx, 10;

  001e4	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH

; 782  : 				sub ecx, eax;

  001e9	2b c8		 sub	 ecx, eax

; 783  : 				shl ecx, 2;

  001eb	c1 e1 02	 shl	 ecx, 2

; 784  : 				add esp, ecx;

  001ee	03 e1		 add	 esp, ecx

; 785  : 			
; 786  : 			}
; 787  : 			break;

  001f0	e9 5c 06 00 00	 jmp	 $LN2@WindMsgPro
$LN19@WindMsgPro:

; 788  : 
; 789  : 
; 790  : 		/** „Ç∑„Çπ„ÉÜ„É†Èñ¢ÈÄ£„É°„ÉÉ„Çª„Éº„Ç∏  Á≥ªÁªüÁõ∏ÂÖ≥‰ø°ÊÅØ *****************************************************/
; 791  : 	case WM_ACTIVATE:	// „Åì„ÅÆ„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„Åå„Ç¢„ÇØ„ÉÜ„Ç£„ÉñÂèà„ÅØÈùû„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å´„Å™„Å£„ÅüÊôÇ  ÂΩìÊ≠§Â∫îÁî®Á®ãÂ∫èÂèò‰∏∫Ê¥ªÂä®ÊàñÈùûÊ¥ªÂä®Êó∂
; 792  : #ifdef SA_25
; 793  : 			static BOOL bInactive = FALSE;
; 794  : 			if( bInactive && (LOWORD(wParam) == WA_ACTIVE || LOWORD(wParam) == WA_CLICKACTIVE)){
; 795  : 				SetWindowPos( hWnd, NULL, 0, -100, 0, 0, NULL);
; 796  : 				ShowWindow( hWnd, SW_MINIMIZE);
; 797  : 				if( lpDraw && lpDraw->lpDD2){
; 798  : 					lpDraw->lpDD2->SetCooperativeLevel( hWnd ,DDSCL_NORMAL);
; 799  : 					ReleaseDirectDraw();
; 800  : 				}
; 801  : 			}
; 802  : 			if( LOWORD(wParam) == WA_INACTIVE){
; 803  : 				bInactive = TRUE;
; 804  : 				cleanupNetwork();
; 805  : 				PostQuitMessage( 0);
; 806  : 			}
; 807  : 			break;
; 808  : #endif
; 809  : 			// ?????????????????
; 810  : 			
; 811  : 			if( ( wParam == WA_ACTIVE || wParam == WA_CLICKACTIVE ) && lpDraw != NULL){

  001f5	83 7d 10 01	 cmp	 DWORD PTR _wParam$[ebp], 1
  001f9	74 06		 je	 SHORT $LN21@WindMsgPro
  001fb	83 7d 10 02	 cmp	 DWORD PTR _wParam$[ebp], 2
  001ff	75 5d		 jne	 SHORT $LN20@WindMsgPro
$LN21@WindMsgPro:
  00201	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A, 0 ; lpDraw
  00208	74 54		 je	 SHORT $LN20@WindMsgPro

; 812  : 				
; 813  : 				// ?????? LOST ?????
; 814  : 				if( CheckSurfaceLost() == TRUE ){

  0020a	e8 00 00 00 00	 call	 ?CheckSurfaceLost@@YAHXZ ; CheckSurfaceLost
  0020f	83 f8 01	 cmp	 eax, 1
  00212	75 05		 jne	 SHORT $LN22@WindMsgPro

; 815  : 					// ??????????????
; 816  : 					RecoverDirectDraw();

  00214	e8 00 00 00 00	 call	 ?RecoverDirectDraw@@YAXXZ ; RecoverDirectDraw
$LN22@WindMsgPro:

; 817  : 				}
; 818  : 				// ??????????????
; 819  : 			// „Éë„É¨„ÉÉ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Åå„Å™„ÅÑÊôÇ
; 820  : 				if( lpDraw->lpPALETTE != NULL ){

  00219	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  0021f	83 ba 80 00 00
	00 00		 cmp	 DWORD PTR [edx+128], 0
  00226	74 36		 je	 SHORT $LN20@WindMsgPro

; 821  : 				// „Ç¶„Ç£„É≥„Éâ„Ç¶„É¢„Éº„Éâ„ÅÆÊôÇ
; 822  : 					if( WindowMode ){

  00228	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?WindowMode@@3HA, 0 ; WindowMode
  0022f	74 2d		 je	 SHORT $LN20@WindMsgPro

; 823  : 					// ‰ΩúÊàê„Åó„Å¶„Åä„ÅÑ„Åü„Éë„É¨„ÉÉ„Éà„Å´Â§â„Åà„Çã
; 824  : 						lpDraw->lpPALETTE->SetEntries( 0, 0, 256, Palette );

  00231	68 00 00 00 00	 push	 OFFSET ?Palette@@3PAUtagPALETTEENTRY@@A ; Palette
  00236	68 00 01 00 00	 push	 256			; 00000100H
  0023b	6a 00		 push	 0
  0023d	6a 00		 push	 0
  0023f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00244	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  0024a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00250	8b 82 80 00 00
	00		 mov	 eax, DWORD PTR [edx+128]
  00256	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00258	50		 push	 eax
  00259	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0025c	ff d2		 call	 edx
$LN20@WindMsgPro:

; 825  : 					}
; 826  : 				}
; 827  : 			}
; 828  : 			//???????????Óé±Óíú
; 829  : 		//„ÉÄ„Ç§„É¨„ÇØ„Éà„Ç§„É≥„Éó„ÉÉ„Éà„ÅÆ‰øÆÊ≠£  ‰øÆÊ≠£Áõ¥Êé•ËæìÂÖ•
; 830  : 		//„Ç≠„Éº„Éú„Éº„ÉâÔºØÔº´„Å™„Çâ  Â¶ÇÊûúÈîÆÁõòÊ≠£Â∏∏
; 831  : 		if(keyboad_flg == TRUE){		//„Ç≠„Éº„Éú„Éº„ÉâÔºØÔº´„Å™„Çâ   Â¶ÇÊûúÈîÆÁõòÊ≠£Â∏∏

  0025e	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR ?keyboad_flg@@3DA ; keyboad_flg
  00265	83 f8 01	 cmp	 eax, 1
  00268	0f 85 8d 00 00
	00		 jne	 $LN25@WindMsgPro

; 832  : 			// „Ç≠„Éº„Éú„Éº„Éâ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Åå„ÅÇ„Çã„Å®„Åç   ÂΩìÊúâÈîÆÁõòÂØπË±°Êó∂
; 833  : 				if(pDInputDevice != NULL){

  0026e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?pDInputDevice@@3PAUIDirectInputDeviceA@@A, 0 ; pDInputDevice
  00275	0f 84 80 00 00
	00		 je	 $LN25@WindMsgPro

; 834  : 				// „Ç¶„Ç£„É≥„Éâ„Ç¶„ÅåÈùû„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å´„Åï„Çå„Çã„Å®„Åç  Á™óÂè£ÂÅúÁî®Êó∂
; 835  : 					if(wParam == WA_INACTIVE){

  0027b	83 7d 10 00	 cmp	 DWORD PTR _wParam$[ebp], 0
  0027f	75 5c		 jne	 SHORT $LN27@WindMsgPro

; 836  : 					// DInput ÂÅúÊ≠¢
; 837  : 						DInputActiveFlag = FALSE;

  00281	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?DInputActiveFlag@@3HA, 0 ; DInputActiveFlag

; 838  : 					// „Ç≠„Éº„Éê„ÉÉ„Éï„Ç°„ÅÆÂàùÊúüÂåñ       ÂØÜÈí•ÁºìÂÜ≤Âå∫ÁöÑÂàùÂßãÂåñ
; 839  : 						for( int i = 0 ; i < 256 ; i++ ) di_key[ i ] = 0;

  0028b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$4[ebp], 0
  00292	eb 09		 jmp	 SHORT $LN6@WindMsgPro
$LN4@WindMsgPro:
  00294	8b 4d f8	 mov	 ecx, DWORD PTR _i$4[ebp]
  00297	83 c1 01	 add	 ecx, 1
  0029a	89 4d f8	 mov	 DWORD PTR _i$4[ebp], ecx
$LN6@WindMsgPro:
  0029d	81 7d f8 00 01
	00 00		 cmp	 DWORD PTR _i$4[ebp], 256 ; 00000100H
  002a4	7d 22		 jge	 SHORT $LN5@WindMsgPro
  002a6	8b 55 f8	 mov	 edx, DWORD PTR _i$4[ebp]
  002a9	89 55 ec	 mov	 DWORD PTR $T2[ebp], edx
  002ac	81 7d ec 00 01
	00 00		 cmp	 DWORD PTR $T2[ebp], 256	; 00000100H
  002b3	73 02		 jae	 SHORT $LN79@WindMsgPro
  002b5	eb 05		 jmp	 SHORT $LN80@WindMsgPro
$LN79@WindMsgPro:
  002b7	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN80@WindMsgPro:
  002bc	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  002bf	c6 80 00 00 00
	00 00		 mov	 BYTE PTR ?di_key@@3PAEA[eax], 0
  002c6	eb cc		 jmp	 SHORT $LN4@WindMsgPro
$LN5@WindMsgPro:

; 840  : 						pDInputDevice->Unacquire();

  002c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pDInputDevice@@3PAUIDirectInputDeviceA@@A ; pDInputDevice
  002ce	8b 11		 mov	 edx, DWORD PTR [ecx]
  002d0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pDInputDevice@@3PAUIDirectInputDeviceA@@A ; pDInputDevice
  002d5	50		 push	 eax
  002d6	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  002d9	ff d1		 call	 ecx

; 841  : 					}

  002db	eb 1e		 jmp	 SHORT $LN25@WindMsgPro
$LN27@WindMsgPro:

; 842  : 					else{
; 843  : 					// DInput Âæ©Ê¥ª
; 844  : 						DInputActiveFlag = TRUE;

  002dd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?DInputActiveFlag@@3HA, 1 ; DInputActiveFlag

; 845  : 						pDInputDevice->Acquire();

  002e7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?pDInputDevice@@3PAUIDirectInputDeviceA@@A ; pDInputDevice
  002ed	8b 02		 mov	 eax, DWORD PTR [edx]
  002ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pDInputDevice@@3PAUIDirectInputDeviceA@@A ; pDInputDevice
  002f5	51		 push	 ecx
  002f6	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  002f9	ff d2		 call	 edx
$LN25@WindMsgPro:

; 846  : 					}
; 847  : 				}
; 848  : 			}
; 849  : 			
; 850  : 		//„Ç∏„Éß„Ç§„Çπ„ÉÜ„Ç£„ÉÉ„ÇØÔºØÔº´„Å™„Çâ  Â¶ÇÊûúÊìçÁ∫µÊùÜÊ≠£Â∏∏
; 851  : 			if(joy_flg == TRUE){		

  002fb	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR ?joy_flg@@3DA ; joy_flg
  00302	83 f8 01	 cmp	 eax, 1
  00305	75 51		 jne	 SHORT $LN29@WindMsgPro

; 852  : 			// „Ç∏„Éß„Ç§„Çπ„ÉÜ„Ç£„ÉÉ„ÇØ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Åå„ÅÇ„Çã„Å®„Åç   ÂΩìÊúâÊìçÁ∫µÊùÜÂØπË±°Êó∂
; 853  : 				if(pDInputDevice2 == NULL)

  00307	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?pDInputDevice2@@3PAUIDirectInputDevice2A@@A, 0 ; pDInputDevice2
  0030e	75 05		 jne	 SHORT $LN30@WindMsgPro

; 854  : 					break;

  00310	e9 3c 05 00 00	 jmp	 $LN2@WindMsgPro
$LN30@WindMsgPro:

; 855  : 				
; 856  : 			// „Ç¶„Ç£„É≥„Éâ„Ç¶„ÅåÈùû„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å´„Åï„Çå„Çã„Å®„Åç   Á™óÂè£ÂÅúÁî®Êó∂
; 857  : 				if(wParam == WA_INACTIVE){

  00315	83 7d 10 00	 cmp	 DWORD PTR _wParam$[ebp], 0
  00319	75 1f		 jne	 SHORT $LN31@WindMsgPro

; 858  : 				// DInput ÂÅúÊ≠¢
; 859  : 					DInputActiveFlag = FALSE;

  0031b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?DInputActiveFlag@@3HA, 0 ; DInputActiveFlag

; 860  : 					pDInputDevice2->Unacquire();

  00325	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pDInputDevice2@@3PAUIDirectInputDevice2A@@A ; pDInputDevice2
  0032b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0032d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pDInputDevice2@@3PAUIDirectInputDevice2A@@A ; pDInputDevice2
  00332	50		 push	 eax
  00333	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  00336	ff d1		 call	 ecx

; 861  : 				}

  00338	eb 1e		 jmp	 SHORT $LN29@WindMsgPro
$LN31@WindMsgPro:

; 862  : 				else{
; 863  : 				// DInput Âæ©Ê¥ª
; 864  : 					DInputActiveFlag = TRUE;

  0033a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?DInputActiveFlag@@3HA, 1 ; DInputActiveFlag

; 865  : 					pDInputDevice2->Acquire();

  00344	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?pDInputDevice2@@3PAUIDirectInputDevice2A@@A ; pDInputDevice2
  0034a	8b 02		 mov	 eax, DWORD PTR [edx]
  0034c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pDInputDevice2@@3PAUIDirectInputDevice2A@@A ; pDInputDevice2
  00352	51		 push	 ecx
  00353	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00356	ff d2		 call	 edx
$LN29@WindMsgPro:

; 866  : 				}
; 867  : 			}
; 868  : 			break;

  00358	e9 f4 04 00 00	 jmp	 $LN2@WindMsgPro
$LN33@WindMsgPro:

; 869  : 	case WM_CLOSE:				// „Ç¶„Ç£„É≥„Éâ„Ç¶Èñâ„Åò„Çã„Å®„Åç
; 870  : 		DestroyWindow( hWnd );	// „Ç¶„Ç£„É≥„Éâ„Ç¶„ÇíÁ†¥Ê£Ñ„Åô„Çã„ÄÅÂêåÊôÇ„Å´

  0035d	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  00360	50		 push	 eax
  00361	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4

; 871  : 		// WM_DESTROY „É°„ÉÉ„Çª„Éº„Ç∏„ÅåÈÄÅ„Çâ„Çå„Çã
; 872  : 			break;

  00367	e9 e5 04 00 00	 jmp	 $LN2@WindMsgPro
$LN34@WindMsgPro:

; 873  : 			
; 874  : 	case WM_DESTROY:			// „Ç¶„Ç£„É≥„Éâ„Ç¶„ÅåÁ†¥Ê£Ñ„Åï„Çå„Åü„Å®„Åç
; 875  : 		PostQuitMessage( 0 );	// WM_QUIT „É°„ÉÉ„Çª„Éº„Ç∏„ÇíÈÄÅ„Çã ( Âá¶ÁêÜ„ÅÆÁµÇ‰∫Ü )

  0036c	6a 00		 push	 0
  0036e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQuitMessage@4

; 876  : 			break;

  00374	e9 d8 04 00 00	 jmp	 $LN2@WindMsgPro
$LN35@WindMsgPro:

; 877  : #ifdef _REMAKE_20		
; 878  : #ifndef _STONDEBUG_			
; 879  : 		case WM_ACTIVATEAPP:
; 880  : 			// Â¶ÇÊûúË¢´ÂàáÂà∞Âà´ÁöÑËßÜÁ™ó,Á¶ªÂºÄÊ∏∏Êàè
; 881  : 			if(!wParam){
; 882  : 				SendMessage(hWnd,WM_CLOSE,0,0);
; 883  : 			}
; 884  : 			break;
; 885  : #endif
; 886  : #endif
; 887  : 			
; 888  : #if 0			
; 889  : 	case WM_PALETTECHANGED:		// „Éë„É¨„ÉÉ„Éà„ÅåÂ§âÊõ¥„Åï„Çå„Åü„Å®„Åç
; 890  : 		// DirectDraw„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Åå„Å™„ÅÑÊôÇ
; 891  : 			if( lpDraw == NULL ) break;
; 892  : 		// „Éë„É¨„ÉÉ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Åå„Å™„ÅÑÊôÇ
; 893  : 			if( lpDraw->lpPALETTE == NULL ) break;
; 894  : 		// „Ç¶„Ç£„É≥„Éâ„Ç¶„É¢„Éº„Éâ„ÅÆÊôÇ
; 895  : 			//if( WindowMode ){
; 896  : 		// ‰ΩúÊàê„Åó„Å¶„Åä„ÅÑ„Åü„Éë„É¨„ÉÉ„Éà„Å´Â§â„Åà„Çã
; 897  : 			lpDraw->lpPALETTE->SetEntries( 0, 0, 256, Palette );
; 898  : 			//}
; 899  : 			break;
; 900  : 			//if( (HWND)wParam == hWnd )  break;
; 901  : 			
; 902  : 	case WM_PALETTEISCHANGING:		// „Éë„É¨„ÉÉ„Éà„ÅåÂ§âÊõ¥„Åï„Çå„Åü„Å®„Åç
; 903  : 		// DirectDraw„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Åå„Å™„ÅÑÊôÇ
; 904  : 			if( lpDraw == NULL ) break;
; 905  : 		// „Éë„É¨„ÉÉ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Åå„Å™„ÅÑÊôÇ
; 906  : 			if( lpDraw->lpPALETTE == NULL ) break;
; 907  : 		// „Ç¶„Ç£„É≥„Éâ„Ç¶„É¢„Éº„Éâ„ÅÆÊôÇ
; 908  : 			//if( WindowMode ){
; 909  : 		// ‰ΩúÊàê„Åó„Å¶„Åä„ÅÑ„Åü„Éë„É¨„ÉÉ„Éà„Å´Â§â„Åà„Çã
; 910  : 			lpDraw->lpPALETTE->SetEntries( 0, 0, 256, Palette );
; 911  : 			//}
; 912  : 			break;
; 913  : 			
; 914  : 	case WM_QUERYNEWPALETTE:	// „Éë„É¨„ÉÉ„ÉàÂ§âÊõ¥„Åß„Åç„Çã„Å®„ÅçÔºà„Ç¶„Ç£„É≥„Éâ„Ç¶„É¢„Éº„Éâ„ÅÆÊôÇ„ÅÆ„ÅøÔºâ
; 915  : 			
; 916  : 		// DirectDraw„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Åå„Å™„ÅÑÊôÇ
; 917  : 			if( lpDraw == NULL ) break;
; 918  : 		// „Éë„É¨„ÉÉ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Åå„Å™„ÅÑÊôÇ
; 919  : 			if( lpDraw->lpPALETTE == NULL ) break;
; 920  : 			
; 921  : 		// „Ç¶„Ç£„É≥„Éâ„Ç¶„É¢„Éº„Éâ„ÅÆÊôÇ
; 922  : 			//if( WindowMode ){
; 923  : 		// ‰ΩúÊàê„Åó„Å¶„Åä„ÅÑ„Åü„Éë„É¨„ÉÉ„Éà„Å´Â§â„Åà„Çã
; 924  : 			lpDraw->lpPALETTE->SetEntries( 0, 0, 256, Palette );
; 925  : 			//}
; 926  : 			
; 927  : 			break;
; 928  : #endif			
; 929  : 
; 930  : 		/** „Ç≠„ÉºÂÖ•Âäõ„É°„ÉÉ„Çª„Éº„Ç∏ *****************************************************/
; 931  : 			
; 932  : 	case WM_KEYDOWN:
; 933  : 			if( SurfaceBusyFlag == TRUE ){

  00379	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?SurfaceBusyFlag@@3HA, 1 ; SurfaceBusyFlag
  00380	75 0f		 jne	 SHORT $LN36@WindMsgPro

; 934  : 				SurfaceBusyFlag = FALSE;

  00382	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?SurfaceBusyFlag@@3HA, 0 ; SurfaceBusyFlag

; 935  : 				RecoverDirectDraw();

  0038c	e8 00 00 00 00	 call	 ?RecoverDirectDraw@@YAXXZ ; RecoverDirectDraw
$LN36@WindMsgPro:

; 936  : 			}
; 937  : 			
; 938  : 			switch( wParam ){

  00391	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  00394	89 4d f4	 mov	 DWORD PTR tv178[ebp], ecx
  00397	8b 55 f4	 mov	 edx, DWORD PTR tv178[ebp]
  0039a	83 ea 08	 sub	 edx, 8
  0039d	89 55 f4	 mov	 DWORD PTR tv178[ebp], edx
  003a0	83 7d f4 26	 cmp	 DWORD PTR tv178[ebp], 38 ; 00000026H
  003a4	0f 87 85 00 00
	00		 ja	 $LN7@WindMsgPro
  003aa	8b 45 f4	 mov	 eax, DWORD PTR tv178[ebp]
  003ad	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN88@WindMsgPro[eax]
  003b4	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN89@WindMsgPro[ecx*4]
$LN37@WindMsgPro:

; 939  : 			case VK_LEFT:
; 940  : 				KeyboardLeft();

  003bb	e8 00 00 00 00	 call	 ?KeyboardLeft@@YAXXZ	; KeyboardLeft

; 941  : 				break;

  003c0	eb 6d		 jmp	 SHORT $LN7@WindMsgPro
$LN38@WindMsgPro:

; 942  : 				
; 943  : 			case VK_RIGHT:
; 944  : 				KeyboardRight();

  003c2	e8 00 00 00 00	 call	 ?KeyboardRight@@YAXXZ	; KeyboardRight

; 945  : 				break;

  003c7	eb 66		 jmp	 SHORT $LN7@WindMsgPro
$LN39@WindMsgPro:

; 946  : 				
; 947  : 		case VK_RETURN:
; 948  : 				KeyboardReturn();

  003c9	e8 00 00 00 00	 call	 ?KeyboardReturn@@YAXXZ	; KeyboardReturn

; 949  : 				break;

  003ce	eb 5f		 jmp	 SHORT $LN7@WindMsgPro
$LN40@WindMsgPro:

; 950  : 		case VK_BACK:	// BS „Åß‰∏ÄÊñáÂ≠óÂâäÈô§
; 951  : 				
; 952  : 				// ????????????
; 953  : 				if( joy_con[ 1 ] & JOY_RSHIFT || joy_con[ 1 ] & JOY_LSHIFT ){

  003d0	ba 04 00 00 00	 mov	 edx, 4
  003d5	c1 e2 00	 shl	 edx, 0
  003d8	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR ?joy_con@@3PAKA[edx]
  003de	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  003e3	75 16		 jne	 SHORT $LN43@WindMsgPro
  003e5	b9 04 00 00 00	 mov	 ecx, 4
  003ea	c1 e1 00	 shl	 ecx, 0
  003ed	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?joy_con@@3PAKA[ecx]
  003f3	81 e2 00 00 00
	08		 and	 edx, 134217728		; 08000000H
  003f9	74 28		 je	 SHORT $LN41@WindMsgPro
$LN43@WindMsgPro:

; 954  : 					// Óöº?????????
; 955  : 					if( pNowStrBuffer != NULL ){

  003fb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?pNowStrBuffer@@3PAUSTR_BUFFER@@A, 0 ; pNowStrBuffer
  00402	74 1d		 je	 SHORT $LN44@WindMsgPro

; 956  : 						// Óöº?????Óû∞?????
; 957  : 						pNowStrBuffer->cnt = 0;

  00404	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pNowStrBuffer@@3PAUSTR_BUFFER@@A ; pNowStrBuffer
  00409	c6 80 07 01 00
	00 00		 mov	 BYTE PTR [eax+263], 0

; 958  : 						pNowStrBuffer->buffer[ 0 ] = NULL;

  00410	b9 01 00 00 00	 mov	 ecx, 1
  00415	6b d1 00	 imul	 edx, ecx, 0
  00418	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pNowStrBuffer@@3PAUSTR_BUFFER@@A ; pNowStrBuffer
  0041d	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0
$LN44@WindMsgPro:

; 959  : 					}
; 960  : 				}else{

  00421	eb 05		 jmp	 SHORT $LN42@WindMsgPro
$LN41@WindMsgPro:

; 961  : 			// Ôº¢Ôº≥„Ç≠„ÉºÂá¶ÁêÜ 
; 962  : 					KeyboardBackSpace();

  00423	e8 00 00 00 00	 call	 ?KeyboardBackSpace@@YAXXZ ; KeyboardBackSpace
$LN42@WindMsgPro:

; 963  : 				}
; 964  : 				
; 965  : 				break;

  00428	eb 05		 jmp	 SHORT $LN7@WindMsgPro
$LN45@WindMsgPro:

; 966  : 				
; 967  : 		case VK_DELETE:	// „ÉÅ„É£„ÉÉ„Éà„Éê„ÉÉ„Éï„Ç°„ÇØ„É™„Ç¢
; 968  : 
; 969  : 			/* „ÉÅ„É£„ÉÉ„ÉàÊñáÂ≠ó„ÇíÂÖ®„Å¶„ÇØ„É™„Ç¢„Åô„Çã */
; 970  : 				ClearChatBuffer();

  0042a	e8 00 00 00 00	 call	 ?ClearChatBuffer@@YAXXZ	; ClearChatBuffer
$LN7@WindMsgPro:

; 971  : #ifdef _TALK_WINDOW
; 972  : 				TalkWindow.ClearChatBuffer();
; 973  : 				TalkWindow.Update();
; 974  : #endif
; 975  : 				break;
; 976  : 				
; 977  : 			case VK_ESCAPE: // ???????????
; 978  : 				// ???????? WM_CLOSE ??????????
; 979  : 				//PostMessage( hWnd, WM_CLOSE, 0, 0L );
; 980  : 				break;
; 981  : 			}
; 982  : #ifdef _TALK_WINDOW
; 983  : 			if(g_bTalkWindow) TalkWindow.Update();
; 984  : #endif
; 985  : 			break;

  0042f	e9 1d 04 00 00	 jmp	 $LN2@WindMsgPro
$LN47@WindMsgPro:

; 986  : #ifdef _REMAKE_20
; 987  : 		case WM_HOTKEY:
; 988  : 				// Â¶ÇÊûúË¢´ÂàáÂà∞Âà´ÁöÑËßÜÁ™ó,Á¶ªÂºÄÊ∏∏Êàè
; 989  : 				SendMessage(hWnd,WM_CLOSE,0,0);	
; 990  : 			break;
; 991  : #endif			
; 992  : 		case WM_SYSKEYDOWN:	// ALT????????
; 993  : 				// ???????????
; 994  : 		// „Çµ„Éº„Éï„Çß„Çπ„É¥„Ç£„Ç∏„Éº„ÅÆÊôÇ
; 995  : 			if( SurfaceBusyFlag == TRUE ){

  00434	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?SurfaceBusyFlag@@3HA, 1 ; SurfaceBusyFlag
  0043b	75 25		 jne	 SHORT $LN48@WindMsgPro

; 996  : 				SurfaceBusyFlag = FALSE;

  0043d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?SurfaceBusyFlag@@3HA, 0 ; SurfaceBusyFlag

; 997  : 				MessageBox( hWnd, "SurfaceBusyFlag error!", "ÌôïÏù∏", MB_OK | MB_ICONSTOP );

  00447	6a 10		 push	 16			; 00000010H
  00449	68 00 00 00 00	 push	 OFFSET ??_C@_04IJNKKJEO@?H?$KO?$MA?N@
  0044e	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@OHJJEBKC@SurfaceBusyFlag?5error?$CB@
  00453	8b 4d 08	 mov	 ecx, DWORD PTR _hWnd$[ebp]
  00456	51		 push	 ecx
  00457	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 998  : 					
; 999  : 				// ??????????????
; 1000 : 				RecoverDirectDraw();

  0045d	e8 00 00 00 00	 call	 ?RecoverDirectDraw@@YAXXZ ; RecoverDirectDraw
$LN48@WindMsgPro:

; 1001 : 			}
; 1002 : 				switch( wParam ){

  00462	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  00465	89 55 e4	 mov	 DWORD PTR tv195[ebp], edx
  00468	83 7d e4 0d	 cmp	 DWORD PTR tv195[ebp], 13 ; 0000000dH
  0046c	74 05		 je	 SHORT $LN49@WindMsgPro
  0046e	e9 6e 01 00 00	 jmp	 $LN60@WindMsgPro
$LN49@WindMsgPro:

; 1003 : 				case VK_RETURN:	// ALT+RETURN ?????????Óüâ?
; 1004 : #ifdef _REMAKE_20
; 1005 : #ifndef _STONDEBUG_
; 1006 : 					// Áº©ÊàêËßÜÁ™óÊ®°ÂºèÁ¶ªÂºÄÊ∏∏Êàè
; 1007 : 					SendMessage(hWnd,WM_CLOSE,0,0);
; 1008 : 					break;
; 1009 : #endif
; 1010 : #else
; 1011 : 			// ÊºîÂá∫‰∏≠„ÅØÊäú„Åë„Çã
; 1012 : 					if( BackBufferDrawType == DRAW_BACK_PRODUCE ) break; 

  00473	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?BackBufferDrawType@@3HA, 2 ; BackBufferDrawType
  0047a	75 05		 jne	 SHORT $LN50@WindMsgPro
  0047c	e9 81 01 00 00	 jmp	 $LN9@WindMsgPro
$LN50@WindMsgPro:

; 1013 : 					
; 1014 : 			// DirectDraw„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Åå„Å™„ÅÑÊôÇ
; 1015 : 					if( lpDraw == NULL ) break;

  00481	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A, 0 ; lpDraw
  00488	75 05		 jne	 SHORT $LN51@WindMsgPro
  0048a	e9 73 01 00 00	 jmp	 $LN9@WindMsgPro
$LN51@WindMsgPro:

; 1016 : 					
; 1017 : 			// „Ç¶„Ç£„É≥„Éâ„Ç¶„É¢„Éº„Éâ„Éï„É©„Ç∞Â§âÊõ¥
; 1018 : 					if( WindowMode == TRUE ) WindowMode = FALSE;

  0048f	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?WindowMode@@3HA, 1 ; WindowMode
  00496	75 0c		 jne	 SHORT $LN52@WindMsgPro
  00498	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?WindowMode@@3HA, 0 ; WindowMode
  004a2	eb 0a		 jmp	 SHORT $LN53@WindMsgPro
$LN52@WindMsgPro:

; 1019 : 					else WindowMode = TRUE;

  004a4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?WindowMode@@3HA, 1 ; WindowMode
$LN53@WindMsgPro:

; 1020 : #ifdef _TALK_WINDOW
; 1021 : 					if(g_bTalkWindow){
; 1022 : 						g_bTalkWindow = FALSE;
; 1023 : 						TalkWindow.Visible(FALSE);
; 1024 : 					}
; 1025 : #endif
; 1026 : 					ChangeMode(WindowMode);

  004ae	a1 00 00 00 00	 mov	 eax, DWORD PTR ?WindowMode@@3HA ; WindowMode
  004b3	50		 push	 eax
  004b4	e8 00 00 00 00	 call	 ?ChangeMode@@YAXH@Z	; ChangeMode
  004b9	83 c4 04	 add	 esp, 4

; 1027 : 					
; 1028 : 			// DirectDraw ÈñãÊîæ
; 1029 : 					ReleaseDirectDraw();

  004bc	e8 00 00 00 00	 call	 ?ReleaseDirectDraw@@YAXXZ ; ReleaseDirectDraw

; 1030 : 					
; 1031 : 			// Ëß£ÂÉèÂ∫¶„É¢„Éº„ÉâË®≠ÂÆö
; 1032 : 					SetResoMode( ResoMode );

  004c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ResoMode@@3HA ; ResoMode
  004c7	51		 push	 ecx
  004c8	e8 00 00 00 00	 call	 ?SetResoMode@@YAXH@Z	; SetResoMode
  004cd	83 c4 04	 add	 esp, 4

; 1033 : 					
; 1034 : 			// DirectDraw ÂàùÊúüÂåñ
; 1035 : 					InitDirectDraw();

  004d0	e8 00 00 00 00	 call	 ?InitDirectDraw@@YAHXZ	; InitDirectDraw

; 1036 : 			// „Ç™„Éï„Çπ„ÇØ„É™„Éº„É≥„Çµ„Éº„Éï„Çß„Çπ„ÅÆ‰ΩúÊàê 
; 1037 : 					InitOffScreenSurface();

  004d5	e8 00 00 00 00	 call	 ?InitOffScreenSurface@@YAHXZ ; InitOffScreenSurface

; 1038 : 			// „Ç¶„Ç£„É≥„Éâ„Ç¶„É¢„Éº„ÉâÂàá„ÇäÊõø„Åà
; 1039 : 					ChangeWindowMode();

  004da	e8 00 00 00 00	 call	 ?ChangeWindowMode@@YAXXZ ; ChangeWindowMode

; 1040 : 			// ÂÖ®„Ç¶„Ç£„É≥„Éâ„Ç¶„Å´ÂÜçÊèèÁîªË¶ÅÊ±Ç
; 1041 : 					//SendMessage( HWND_BROADCAST, WM_PAINT, NULL, NULL );
; 1042 : 					
; 1043 : 			// „Éë„É¨„ÉÉ„ÉàÂàùÊúüÂåñ
; 1044 : 					if( InitPalette() == FALSE ){

  004df	e8 00 00 00 00	 call	 ?InitPalette@@YAHXZ	; InitPalette
  004e4	85 c0		 test	 eax, eax
  004e6	75 13		 jne	 SHORT $LN54@WindMsgPro

; 1045 : 						//PostMessage( hWnd, WM_CLOSE, 0, 0L );
; 1046 : 						PostMessage( hWnd, WM_SYSKEYDOWN, VK_RETURN, 0L );

  004e8	6a 00		 push	 0
  004ea	6a 0d		 push	 13			; 0000000dH
  004ec	68 04 01 00 00	 push	 260			; 00000104H
  004f1	8b 55 08	 mov	 edx, DWORD PTR _hWnd$[ebp]
  004f4	52		 push	 edx
  004f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16
$LN54@WindMsgPro:

; 1047 : 					}
; 1048 : 			// „Éê„Éà„É´„Éû„ÉÉ„ÉóË™≠„ÅøËæº„Åø„Å®„Éê„Éà„É´„Çµ„Éº„Éï„Çß„Çπ„ÅÆÁîªÂÉè‰ΩúÊàê
; 1049 : 					if( ProcNo == PROC_BATTLE ){ 

  004fb	83 3d 00 00 00
	00 0a		 cmp	 DWORD PTR ?ProcNo@@3IA, 10 ; ProcNo, 0000000aH
  00502	75 5e		 jne	 SHORT $LN55@WindMsgPro

; 1050 : 				// „Éê„ÉÉ„Éï„Ç°ÂàùÊúüÂåñ
; 1051 : 						DispBuffer.DispCnt = 0;

  00504	33 c0		 xor	 eax, eax
  00506	66 a3 00 c0 01
	00		 mov	 WORD PTR ?DispBuffer@@3UDISP_BUFFER@@A+114688, ax

; 1052 : 						FontCnt = 0;

  0050c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?FontCnt@@3HA, 0 ; FontCnt

; 1053 : 						ReadBattleMap( BattleMapNo );

  00516	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BattleMapNo@@3HA ; BattleMapNo
  0051c	51		 push	 ecx
  0051d	e8 00 00 00 00	 call	 ?ReadBattleMap@@YAHH@Z	; ReadBattleMap
  00522	83 c4 04	 add	 esp, 4

; 1054 : 				// „Éê„ÉÉ„ÇØ„Çµ„Éº„Éï„Çß„Çπ„ÇíÈªí„Åß„ÇØ„É™„Ç¢„Éº   Áî®ÈªëÂÆåÊàêË°®Èù¢ÁöÑË°®Èù¢ 
; 1055 : 						ClearBackSurface();	

  00525	e8 00 00 00 00	 call	 ?ClearBackSurface@@YAXXZ ; ClearBackSurface

; 1056 : 						// ????????????????
; 1057 : #ifdef __SKYISLAND
; 1058 : 						fastDrawTileFlag = 0;

  0052a	33 d2		 xor	 edx, edx
  0052c	66 89 15 00 00
	00 00		 mov	 WORD PTR ?fastDrawTileFlag@@3FA, dx ; fastDrawTileFlag

; 1059 : 				// Ôº¢Ôº≠Ôº∞„Çí„Éê„ÉÉ„ÇØ„Çµ„Éº„Éï„Çß„Çπ„Å´„Çª„ÉÉ„Éà
; 1060 : 						PutBmp();	

  00533	e8 00 00 00 00	 call	 ?PutBmp@@YAXXZ		; PutBmp

; 1061 : 						fastDrawTileFlag = 1;

  00538	b8 01 00 00 00	 mov	 eax, 1
  0053d	66 a3 00 00 00
	00		 mov	 WORD PTR ?fastDrawTileFlag@@3FA, ax ; fastDrawTileFlag

; 1062 : #else
; 1063 : 						PutBmp();	
; 1064 : 				// „Éê„ÉÉ„ÇØ„Çµ„Éº„Éï„Çß„Çπ„Åã„Çâ„Éê„Éà„É´„Çµ„Éº„Éï„Çß„Çπ„Å∏„Ç≥„Éî„Éº
; 1065 : 						lpBattleSurface->BltFast( 0, 0, lpDraw->lpBACKBUFFER, NULL, DDBLTFAST_WAIT );
; 1066 : #endif
; 1067 : 				// „Éê„ÉÉ„Éï„Ç°ÂàùÊúüÂåñ
; 1068 : 						DispBuffer.DispCnt = 0;

  00543	33 c9		 xor	 ecx, ecx
  00545	66 89 0d 00 c0
	01 00		 mov	 WORD PTR ?DispBuffer@@3UDISP_BUFFER@@A+114688, cx

; 1069 : 						FontCnt = 0;

  0054c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?FontCnt@@3HA, 0 ; FontCnt

; 1070 : 				// ÁèæÂú®„ÅÆÊôÇÈñì„ÇíË®òÊÜ∂
; 1071 : 						NowTime = TimeGetTime();

  00556	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  0055b	a3 00 00 00 00	 mov	 DWORD PTR ?NowTime@@3KA, eax ; NowTime

; 1072 : 					}	

  00560	eb 19		 jmp	 SHORT $LN56@WindMsgPro
$LN55@WindMsgPro:

; 1073 : 					else
; 1074 : 						if( fastDrawTile && ProcNo == PROC_GAME )

  00562	0f bf 15 00 00
	00 00		 movsx	 edx, WORD PTR ?fastDrawTile@@3FB ; fastDrawTile
  00569	85 d2		 test	 edx, edx
  0056b	74 0e		 je	 SHORT $LN56@WindMsgPro
  0056d	83 3d 00 00 00
	00 09		 cmp	 DWORD PTR ?ProcNo@@3IA, 9 ; ProcNo
  00574	75 05		 jne	 SHORT $LN56@WindMsgPro

; 1075 : 						{
; 1076 : 							repairMap();	// ????Ó°°?Óé±?

  00576	e8 00 00 00 00	 call	 ?repairMap@@YAXXZ	; repairMap
$LN56@WindMsgPro:

; 1077 : 						}
; 1078 : 						// ??????????????
; 1079 : 						if( lpDraw->lpPALETTE != NULL ){

  0057b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00580	83 b8 80 00 00
	00 00		 cmp	 DWORD PTR [eax+128], 0
  00587	74 36		 je	 SHORT $LN58@WindMsgPro

; 1080 : 							// ??????????
; 1081 : 							if( WindowMode ){

  00589	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?WindowMode@@3HA, 0 ; WindowMode
  00590	74 2d		 je	 SHORT $LN58@WindMsgPro

; 1082 : 								// ?Óíï??????????Óüâ??
; 1083 : 								lpDraw->lpPALETTE->SetEntries( 0, 0, 256, Palette );

  00592	68 00 00 00 00	 push	 OFFSET ?Palette@@3PAUtagPALETTEENTRY@@A ; Palette
  00597	68 00 01 00 00	 push	 256			; 00000100H
  0059c	6a 00		 push	 0
  0059e	6a 00		 push	 0
  005a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  005a6	8b 91 80 00 00
	00		 mov	 edx, DWORD PTR [ecx+128]
  005ac	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  005b1	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  005b7	8b 12		 mov	 edx, DWORD PTR [edx]
  005b9	51		 push	 ecx
  005ba	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  005bd	ff d0		 call	 eax
$LN58@WindMsgPro:

; 1084 : 							}
; 1085 : 						}
; 1086 : 						// ???????Óöº?????
; 1087 : 						mouse.state = MOUSE_NO_CRICK;

  005bf	c7 05 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?mouse@@3UMOUSE@@A+40, 0

; 1088 : 						mouse.onceState = MOUSE_NO_CRICK;

  005c9	c7 05 2c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?mouse@@3UMOUSE@@A+44, 0

; 1089 : 						// ???ÓñΩ?Ó†í????
; 1090 : 						NowTime = TimeGetTime();

  005d3	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  005d8	a3 00 00 00 00	 mov	 DWORD PTR ?NowTime@@3KA, eax ; NowTime

; 1091 : 						break;

  005dd	eb 23		 jmp	 SHORT $LN9@WindMsgPro

; 1092 : #endif
; 1093 : 				break;

  005df	eb 21		 jmp	 SHORT $LN9@WindMsgPro
$LN60@WindMsgPro:

; 1094 : 				default:
; 1095 : 					if( wParam != VK_F10){

  005e1	83 7d 10 79	 cmp	 DWORD PTR _wParam$[ebp], 121 ; 00000079H
  005e5	74 1b		 je	 SHORT $LN9@WindMsgPro

; 1096 : 			// Êú™Âá¶ÁêÜ„É°„ÉÉ„Çª„Éº„Ç∏„Çí„Éá„Éï„Ç©„É´„ÉàÂá¶ÁêÜÈñ¢Êï∞„Å∏Ê∏°„Åó„Å¶Âá¶ÁêÜ„Åï„Åõ„Çã
; 1097 : 						return DefWindowProc( hWnd, Message, wParam, lParam );

  005e7	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  005ea	51		 push	 ecx
  005eb	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  005ee	52		 push	 edx
  005ef	8b 45 0c	 mov	 eax, DWORD PTR _Message$[ebp]
  005f2	50		 push	 eax
  005f3	8b 4d 08	 mov	 ecx, DWORD PTR _hWnd$[ebp]
  005f6	51		 push	 ecx
  005f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcA@16
  005fd	e9 51 02 00 00	 jmp	 $LN78@WindMsgPro
$LN9@WindMsgPro:

; 1098 : 					}
; 1099 : 					break;
; 1100 : 				}
; 1101 : 				break;

  00602	e9 4a 02 00 00	 jmp	 $LN2@WindMsgPro
$LN62@WindMsgPro:

; 1102 : 	case WM_CHAR:	// ÊñáÂ≠óÂÖ•ÂäõÂá¶ÁêÜ
; 1103 : 
; 1104 : 		// ÊñáÂ≠ó„Éê„ÉÉ„Éï„Ç°„Å´Ê∫ú„ÇÅ„Çã
; 1105 : 					StockStrBufferChar( ( char )wParam );

  00607	0f b6 55 10	 movzx	 edx, BYTE PTR _wParam$[ebp]
  0060b	52		 push	 edx
  0060c	e8 00 00 00 00	 call	 ?StockStrBufferChar@@YAXD@Z ; StockStrBufferChar
  00611	83 c4 04	 add	 esp, 4

; 1106 : 					break;

  00614	e9 38 02 00 00	 jmp	 $LN2@WindMsgPro
$LN63@WindMsgPro:

; 1107 : 		/** „Éû„Ç¶„ÇπÂÖ•Âäõ„É°„ÉÉ„Çª„Éº„Ç∏ *****************************************************/
; 1108 : 	case WM_MOUSEMOVE:		// „Éû„Ç¶„Çπ„ÇíÂãï„Åã„Åó„ÅüÊôÇ
; 1109 : 					//SetCursor( wndclass.hCursor );
; 1110 : 		// ÁèæÂú®„ÅÆ„Éû„Ç¶„Çπ„ÅÆ‰ΩçÁΩÆ„ÇíË®òÊÜ∂„Åô„Çã
; 1111 : 					MouseNowPoint( LOWORD(lParam), HIWORD(lParam) );

  00619	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  0061c	c1 e8 10	 shr	 eax, 16			; 00000010H
  0061f	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00624	0f b7 c8	 movzx	 ecx, ax
  00627	51		 push	 ecx
  00628	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  0062b	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00631	0f b7 c2	 movzx	 eax, dx
  00634	50		 push	 eax
  00635	e8 00 00 00 00	 call	 ?MouseNowPoint@@YAXHH@Z	; MouseNowPoint
  0063a	83 c4 08	 add	 esp, 8

; 1112 : #ifndef _TALK_WINDOW
; 1113 : 					if( mouse.flag == TRUE ){ 

  0063d	83 3d 4c 00 00
	00 01		 cmp	 DWORD PTR ?mouse@@3UMOUSE@@A+76, 1
  00644	75 12		 jne	 SHORT $LN64@WindMsgPro

; 1114 : 			ShowCursor( FALSE ); // „Éû„Ç¶„Çπ„Ç´„Éº„ÇΩ„É´„ÇíÊ∂à„Åô

  00646	6a 00		 push	 0
  00648	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowCursor@4

; 1115 : 						mouse.flag = FALSE;

  0064e	c7 05 4c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?mouse@@3UMOUSE@@A+76, 0
$LN64@WindMsgPro:

; 1116 : 					}
; 1117 : #else
; 1118 : 					if(MouseCursorFlag == FALSE && g_iCursorCount > -1){
; 1119 : 						while(g_iCursorCount > -1) g_iCursorCount = ShowCursor( FALSE );
; 1120 : 						mouse.flag = FALSE;
; 1121 : 					}
; 1122 : 					else if(MouseCursorFlag == TRUE && g_iCursorCount < 0){
; 1123 : 						while(g_iCursorCount < 0) g_iCursorCount = ShowCursor( TRUE );
; 1124 : 					}
; 1125 : #endif
; 1126 : 					// ???????????
; 1127 : 					if( SurfaceBusyFlag == TRUE ){

  00658	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?SurfaceBusyFlag@@3HA, 1 ; SurfaceBusyFlag
  0065f	75 0f		 jne	 SHORT $LN65@WindMsgPro

; 1128 : 						SurfaceBusyFlag = FALSE;

  00661	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?SurfaceBusyFlag@@3HA, 0 ; SurfaceBusyFlag

; 1129 : 						// ??????????????
; 1130 : 						RecoverDirectDraw();

  0066b	e8 00 00 00 00	 call	 ?RecoverDirectDraw@@YAXXZ ; RecoverDirectDraw
$LN65@WindMsgPro:

; 1131 : 					}
; 1132 : 					break;

  00670	e9 dc 01 00 00	 jmp	 $LN2@WindMsgPro
$LN66@WindMsgPro:

; 1133 : 	case WM_NCMOUSEMOVE:	// „Éû„Ç¶„Çπ„Åå„Ç¶„Ç£„É≥„Éâ„Ç¶„Åã„Çâ„ÅØ„ÅøÂá∫„ÅüÊôÇ
; 1134 : 
; 1135 : 		// „Éû„Ç¶„Çπ„ÇØ„É™„ÉÉ„ÇØÂÖ•Âäõ„ÅÆÂàùÊúüÂåñ
; 1136 : 					mouse.state = MOUSE_NO_CRICK;

  00675	c7 05 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?mouse@@3UMOUSE@@A+40, 0

; 1137 : 					mouse.onceState = MOUSE_NO_CRICK;

  0067f	c7 05 2c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?mouse@@3UMOUSE@@A+44, 0

; 1138 : 					if( mouse.flag == FALSE ){ 

  00689	83 3d 4c 00 00
	00 00		 cmp	 DWORD PTR ?mouse@@3UMOUSE@@A+76, 0
  00690	75 12		 jne	 SHORT $LN67@WindMsgPro

; 1139 : #ifdef _TALK_WINDOW
; 1140 : 						g_iCursorCount = ShowCursor( TRUE );
; 1141 : #else
; 1142 : 			ShowCursor( TRUE ); // „Éû„Ç¶„Çπ„Ç´„Éº„ÇΩ„É´„ÇíË°®Á§∫

  00692	6a 01		 push	 1
  00694	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowCursor@4

; 1143 : #endif
; 1144 : 						mouse.flag = TRUE;

  0069a	c7 05 4c 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?mouse@@3UMOUSE@@A+76, 1
$LN67@WindMsgPro:

; 1145 : 					}
; 1146 : 					break;

  006a4	e9 a8 01 00 00	 jmp	 $LN2@WindMsgPro
$LN68@WindMsgPro:

; 1147 : 	case WM_LBUTTONDOWN:	// Â∑¶„ÇØ„É™„ÉÉ„ÇØ(Êäº„Åó„ÅüÊôÇ)
; 1148 : #ifdef _80_LOGIN_PLAY
; 1149 : 					if (ProcNo == PROC_80_LOGIN)
; 1150 : 						break;
; 1151 : #endif
; 1152 : 					
; 1153 : #ifdef _REMAKE_20
; 1154 : 					// Ê£ÄÊü•‰ΩøÁî®ËÄÖÊòØÂê¶ÁúüÁöÑÊåâ‰∏ãÊªëÈº†
; 1155 : 					if(!IsLMouseButtonDown()) mouseCursorMode = 0;
; 1156 : 					else
; 1157 : #endif
; 1158 : 		// Â∑¶„ÇØ„É™„ÉÉ„ÇØ„Åï„Çå„ÅüÊôÇ„ÅÆ„Éû„Ç¶„Çπ„ÅÆ‰ΩçÁΩÆ„ÇíË®òÊÜ∂„Åô„Çã
; 1159 : 						MouseCrickLeftDownPoint( LOWORD(lParam), HIWORD(lParam) );

  006a9	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  006ac	c1 e9 10	 shr	 ecx, 16			; 00000010H
  006af	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  006b5	0f b7 d1	 movzx	 edx, cx
  006b8	52		 push	 edx
  006b9	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  006bc	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  006c1	0f b7 c8	 movzx	 ecx, ax
  006c4	51		 push	 ecx
  006c5	e8 00 00 00 00	 call	 ?MouseCrickLeftDownPoint@@YAXHH@Z ; MouseCrickLeftDownPoint
  006ca	83 c4 08	 add	 esp, 8

; 1160 : 					break;

  006cd	e9 7f 01 00 00	 jmp	 $LN2@WindMsgPro
$LN69@WindMsgPro:

; 1161 : 	case WM_LBUTTONUP:		// Â∑¶„ÇØ„É™„ÉÉ„ÇØ(Èõ¢„Åó„ÅüÊôÇ)
; 1162 : 
; 1163 : 		// Â∑¶„ÇØ„É™„ÉÉ„ÇØ„Åï„Çå„ÅüÊôÇ„ÅÆ„Éû„Ç¶„Çπ„ÅÆ‰ΩçÁΩÆ„ÇíË®òÊÜ∂„Åô„Çã
; 1164 : 					MouseCrickLeftUpPoint( LOWORD(lParam), HIWORD(lParam) );

  006d2	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  006d5	c1 ea 10	 shr	 edx, 16			; 00000010H
  006d8	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  006de	0f b7 c2	 movzx	 eax, dx
  006e1	50		 push	 eax
  006e2	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  006e5	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  006eb	0f b7 d1	 movzx	 edx, cx
  006ee	52		 push	 edx
  006ef	e8 00 00 00 00	 call	 ?MouseCrickLeftUpPoint@@YAXHH@Z ; MouseCrickLeftUpPoint
  006f4	83 c4 08	 add	 esp, 8

; 1165 : 					break;

  006f7	e9 55 01 00 00	 jmp	 $LN2@WindMsgPro
$LN70@WindMsgPro:

; 1166 : 	case WM_LBUTTONDBLCLK:		// Â∑¶„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØ
; 1167 : #ifdef _80_LOGIN_PLAY
; 1168 : 					if (ProcNo == PROC_80_LOGIN)
; 1169 : 						break;
; 1170 : #endif
; 1171 : 		// Â∑¶„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØ„Åï„Çå„ÅüÊôÇ„ÅÆ„Éû„Ç¶„Çπ„ÅÆ‰ΩçÁΩÆ„ÇíË®òÊÜ∂„Åô„Çã
; 1172 : 					MouseDblCrickLeftUpPoint( LOWORD(lParam), HIWORD(lParam) );

  006fc	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  006ff	c1 e8 10	 shr	 eax, 16			; 00000010H
  00702	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00707	0f b7 c8	 movzx	 ecx, ax
  0070a	51		 push	 ecx
  0070b	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  0070e	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00714	0f b7 c2	 movzx	 eax, dx
  00717	50		 push	 eax
  00718	e8 00 00 00 00	 call	 ?MouseDblCrickLeftUpPoint@@YAXHH@Z ; MouseDblCrickLeftUpPoint
  0071d	83 c4 08	 add	 esp, 8

; 1173 : 					break;

  00720	e9 2c 01 00 00	 jmp	 $LN2@WindMsgPro
$LN71@WindMsgPro:

; 1174 : 	case WM_RBUTTONDOWN:	// Âè≥„ÇØ„É™„ÉÉ„ÇØ(Êäº„Åó„ÅüÊôÇ)
; 1175 : #ifdef _REMAKE_20
; 1176 : 					// Ê£ÄÊü•‰ΩøÁî®ËÄÖÊòØÂê¶ÁúüÁöÑÊåâ‰∏ãÊªëÈº†
; 1177 : 					if(!IsRMouseButtonDown()) mouseCursorMode = 0;
; 1178 : 					else 
; 1179 : #endif				
; 1180 : 		// Â∑¶„ÇØ„É™„ÉÉ„ÇØ„Åï„Çå„ÅüÊôÇ„ÅÆ„Éû„Ç¶„Çπ„ÅÆ‰ΩçÁΩÆ„ÇíË®òÊÜ∂„Åô„Çã
; 1181 : 						MouseCrickRightDownPoint( LOWORD(lParam), HIWORD(lParam) );

  00725	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  00728	c1 e9 10	 shr	 ecx, 16			; 00000010H
  0072b	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00731	0f b7 d1	 movzx	 edx, cx
  00734	52		 push	 edx
  00735	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00738	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0073d	0f b7 c8	 movzx	 ecx, ax
  00740	51		 push	 ecx
  00741	e8 00 00 00 00	 call	 ?MouseCrickRightDownPoint@@YAXHH@Z ; MouseCrickRightDownPoint
  00746	83 c4 08	 add	 esp, 8

; 1182 : 					break;

  00749	e9 03 01 00 00	 jmp	 $LN2@WindMsgPro
$LN72@WindMsgPro:

; 1183 : 	case WM_RBUTTONUP:		// Âè≥„ÇØ„É™„ÉÉ„ÇØ(Èõ¢„Åó„ÅüÊôÇ)
; 1184 : 
; 1185 : 		// Â∑¶„ÇØ„É™„ÉÉ„ÇØ„Åï„Çå„ÅüÊôÇ„ÅÆ„Éû„Ç¶„Çπ„ÅÆ‰ΩçÁΩÆ„ÇíË®òÊÜ∂„Åô„Çã
; 1186 : 					MouseCrickRightUpPoint( LOWORD(lParam), HIWORD(lParam) );

  0074e	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  00751	c1 ea 10	 shr	 edx, 16			; 00000010H
  00754	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0075a	0f b7 c2	 movzx	 eax, dx
  0075d	50		 push	 eax
  0075e	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  00761	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00767	0f b7 d1	 movzx	 edx, cx
  0076a	52		 push	 edx
  0076b	e8 00 00 00 00	 call	 ?MouseCrickRightUpPoint@@YAXHH@Z ; MouseCrickRightUpPoint
  00770	83 c4 08	 add	 esp, 8

; 1187 : 					break;

  00773	e9 d9 00 00 00	 jmp	 $LN2@WindMsgPro
$LN73@WindMsgPro:

; 1188 : 	case WM_RBUTTONDBLCLK:		// Âè≥„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØ
; 1189 : 
; 1190 : 		// Âè≥„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØ„Åï„Çå„ÅüÊôÇ„ÅÆ„Éû„Ç¶„Çπ„ÅÆ‰ΩçÁΩÆ„ÇíË®òÊÜ∂„Åô„Çã
; 1191 : 					MouseDblCrickRightUpPoint( LOWORD(lParam), HIWORD(lParam) );

  00778	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  0077b	c1 e8 10	 shr	 eax, 16			; 00000010H
  0077e	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00783	0f b7 c8	 movzx	 ecx, ax
  00786	51		 push	 ecx
  00787	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  0078a	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00790	0f b7 c2	 movzx	 eax, dx
  00793	50		 push	 eax
  00794	e8 00 00 00 00	 call	 ?MouseDblCrickRightUpPoint@@YAXHH@Z ; MouseDblCrickRightUpPoint
  00799	83 c4 08	 add	 esp, 8

; 1192 : 					break;

  0079c	e9 b0 00 00 00	 jmp	 $LN2@WindMsgPro
$LN74@WindMsgPro:

; 1193 : 	case WM_MBUTTONDOWN:	// ‰∏≠„ÇØ„É™„ÉÉ„ÇØ(Êäº„Åó„ÅüÊôÇ)
; 1194 : 					break;

  007a1	e9 ab 00 00 00	 jmp	 $LN2@WindMsgPro
$LN75@WindMsgPro:

; 1195 : 				case WM_MOVE:
; 1196 : 					{
; 1197 : 						g_clientPoint.x = g_clientPoint.y = 0;

  007a6	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_clientPoint@@3UtagPOINT@@A+4, 0
  007b0	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?g_clientPoint@@3UtagPOINT@@A+4
  007b6	89 0d 00 00 00
	00		 mov	 DWORD PTR ?g_clientPoint@@3UtagPOINT@@A, ecx

; 1198 : 						GetClientRect(hWnd,&g_clientRect);

  007bc	68 00 00 00 00	 push	 OFFSET ?g_clientRect@@3UtagRECT@@A ; g_clientRect
  007c1	8b 55 08	 mov	 edx, DWORD PTR _hWnd$[ebp]
  007c4	52		 push	 edx
  007c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8

; 1199 : 						ClientToScreen(hWnd,&g_clientPoint); 

  007cb	68 00 00 00 00	 push	 OFFSET ?g_clientPoint@@3UtagPOINT@@A ; g_clientPoint
  007d0	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  007d3	50		 push	 eax
  007d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ClientToScreen@8

; 1200 : 						OffsetRect(&g_clientRect,g_clientPoint.x,g_clientPoint.y);

  007da	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?g_clientPoint@@3UtagPOINT@@A+4
  007e0	51		 push	 ecx
  007e1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_clientPoint@@3UtagPOINT@@A
  007e7	52		 push	 edx
  007e8	68 00 00 00 00	 push	 OFFSET ?g_clientRect@@3UtagRECT@@A ; g_clientRect
  007ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12

; 1201 : 						SetRect(&g_moveRect,0,0,lpDraw->xSize,lpDraw->ySize);

  007f3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  007f8	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  007fe	51		 push	 ecx
  007ff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?lpDraw@@3PAUDIRECT_DRAW@@A ; lpDraw
  00805	8b 82 84 00 00
	00		 mov	 eax, DWORD PTR [edx+132]
  0080b	50		 push	 eax
  0080c	6a 00		 push	 0
  0080e	6a 00		 push	 0
  00810	68 00 00 00 00	 push	 OFFSET ?g_moveRect@@3UtagRECT@@A ; g_moveRect
  00815	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 1202 : #ifdef _TALK_WINDOW
; 1203 : 						if(g_bTalkWindow) SendMessage(TalkWindow.GetTalkWindowWND(),WM_MOVE,0,0);
; 1204 : #endif
; 1205 : 					}
; 1206 : 					break;

  0081b	eb 34		 jmp	 SHORT $LN2@WindMsgPro
$LN76@WindMsgPro:

; 1207 : 
; 1208 : 				default:
; 1209 : 					if(ImeMessage(Message,wParam,lParam))

  0081d	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  00820	51		 push	 ecx
  00821	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  00824	52		 push	 edx
  00825	8b 45 0c	 mov	 eax, DWORD PTR _Message$[ebp]
  00828	50		 push	 eax
  00829	e8 00 00 00 00	 call	 ?ImeMessage@@YAHIIJ@Z	; ImeMessage
  0082e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00831	85 c0		 test	 eax, eax
  00833	74 04		 je	 SHORT $LN77@WindMsgPro

; 1210 : 						return 0;

  00835	33 c0		 xor	 eax, eax
  00837	eb 1a		 jmp	 SHORT $LN78@WindMsgPro
$LN77@WindMsgPro:

; 1211 : 					return DefWindowProc( hWnd, Message, wParam, lParam );

  00839	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  0083c	51		 push	 ecx
  0083d	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  00840	52		 push	 edx
  00841	8b 45 0c	 mov	 eax, DWORD PTR _Message$[ebp]
  00844	50		 push	 eax
  00845	8b 4d 08	 mov	 ecx, DWORD PTR _hWnd$[ebp]
  00848	51		 push	 ecx
  00849	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcA@16
  0084f	eb 02		 jmp	 SHORT $LN78@WindMsgPro
$LN2@WindMsgPro:

; 1212 : 	}
; 1213 : 	return 0;

  00851	33 c0		 xor	 eax, eax
$LN78@WindMsgPro:

; 1214 : }

  00853	5f		 pop	 edi
  00854	5e		 pop	 esi
  00855	5b		 pop	 ebx
  00856	8b e5		 mov	 esp, ebp
  00858	5d		 pop	 ebp
  00859	c2 10 00	 ret	 16			; 00000010H
$LN84@WindMsgPro:
  0085c	00 00 00 00	 DD	 $LN11@WindMsgPro
  00860	00 00 00 00	 DD	 $LN34@WindMsgPro
  00864	00 00 00 00	 DD	 $LN75@WindMsgPro
  00868	00 00 00 00	 DD	 $LN76@WindMsgPro
  0086c	00 00 00 00	 DD	 $LN76@WindMsgPro
  00870	00 00 00 00	 DD	 $LN19@WindMsgPro
$LN86@WindMsgPro:
  00874	00 00 00 00	 DD	 $LN17@WindMsgPro
  00878	00 00 00 00	 DD	 $LN66@WindMsgPro
  0087c	00 00 00 00	 DD	 $LN35@WindMsgPro
  00880	00 00 00 00	 DD	 $LN62@WindMsgPro
  00884	00 00 00 00	 DD	 $LN47@WindMsgPro
  00888	00 00 00 00	 DD	 $LN13@WindMsgPro
  0088c	00 00 00 00	 DD	 $LN76@WindMsgPro
$LN85@WindMsgPro:
  00890	00		 DB	 0
  00891	06		 DB	 6
  00892	06		 DB	 6
  00893	06		 DB	 6
  00894	06		 DB	 6
  00895	06		 DB	 6
  00896	06		 DB	 6
  00897	06		 DB	 6
  00898	06		 DB	 6
  00899	06		 DB	 6
  0089a	06		 DB	 6
  0089b	06		 DB	 6
  0089c	06		 DB	 6
  0089d	06		 DB	 6
  0089e	06		 DB	 6
  0089f	06		 DB	 6
  008a0	06		 DB	 6
  008a1	06		 DB	 6
  008a2	06		 DB	 6
  008a3	06		 DB	 6
  008a4	06		 DB	 6
  008a5	06		 DB	 6
  008a6	06		 DB	 6
  008a7	06		 DB	 6
  008a8	06		 DB	 6
  008a9	06		 DB	 6
  008aa	06		 DB	 6
  008ab	06		 DB	 6
  008ac	06		 DB	 6
  008ad	06		 DB	 6
  008ae	06		 DB	 6
  008af	06		 DB	 6
  008b0	06		 DB	 6
  008b1	06		 DB	 6
  008b2	06		 DB	 6
  008b3	06		 DB	 6
  008b4	06		 DB	 6
  008b5	06		 DB	 6
  008b6	06		 DB	 6
  008b7	06		 DB	 6
  008b8	06		 DB	 6
  008b9	06		 DB	 6
  008ba	06		 DB	 6
  008bb	06		 DB	 6
  008bc	06		 DB	 6
  008bd	06		 DB	 6
  008be	06		 DB	 6
  008bf	06		 DB	 6
  008c0	06		 DB	 6
  008c1	06		 DB	 6
  008c2	06		 DB	 6
  008c3	06		 DB	 6
  008c4	06		 DB	 6
  008c5	06		 DB	 6
  008c6	06		 DB	 6
  008c7	06		 DB	 6
  008c8	06		 DB	 6
  008c9	06		 DB	 6
  008ca	06		 DB	 6
  008cb	06		 DB	 6
  008cc	06		 DB	 6
  008cd	06		 DB	 6
  008ce	06		 DB	 6
  008cf	06		 DB	 6
  008d0	06		 DB	 6
  008d1	06		 DB	 6
  008d2	06		 DB	 6
  008d3	06		 DB	 6
  008d4	06		 DB	 6
  008d5	06		 DB	 6
  008d6	06		 DB	 6
  008d7	06		 DB	 6
  008d8	06		 DB	 6
  008d9	06		 DB	 6
  008da	06		 DB	 6
  008db	06		 DB	 6
  008dc	06		 DB	 6
  008dd	06		 DB	 6
  008de	06		 DB	 6
  008df	06		 DB	 6
  008e0	06		 DB	 6
  008e1	06		 DB	 6
  008e2	06		 DB	 6
  008e3	06		 DB	 6
  008e4	06		 DB	 6
  008e5	06		 DB	 6
  008e6	01		 DB	 1
  008e7	06		 DB	 6
  008e8	06		 DB	 6
  008e9	06		 DB	 6
  008ea	06		 DB	 6
  008eb	06		 DB	 6
  008ec	06		 DB	 6
  008ed	06		 DB	 6
  008ee	06		 DB	 6
  008ef	06		 DB	 6
  008f0	06		 DB	 6
  008f1	06		 DB	 6
  008f2	06		 DB	 6
  008f3	06		 DB	 6
  008f4	06		 DB	 6
  008f5	06		 DB	 6
  008f6	06		 DB	 6
  008f7	06		 DB	 6
  008f8	06		 DB	 6
  008f9	06		 DB	 6
  008fa	06		 DB	 6
  008fb	06		 DB	 6
  008fc	06		 DB	 6
  008fd	06		 DB	 6
  008fe	06		 DB	 6
  008ff	06		 DB	 6
  00900	06		 DB	 6
  00901	06		 DB	 6
  00902	06		 DB	 6
  00903	06		 DB	 6
  00904	06		 DB	 6
  00905	06		 DB	 6
  00906	06		 DB	 6
  00907	06		 DB	 6
  00908	06		 DB	 6
  00909	06		 DB	 6
  0090a	06		 DB	 6
  0090b	06		 DB	 6
  0090c	06		 DB	 6
  0090d	06		 DB	 6
  0090e	06		 DB	 6
  0090f	06		 DB	 6
  00910	06		 DB	 6
  00911	06		 DB	 6
  00912	06		 DB	 6
  00913	06		 DB	 6
  00914	06		 DB	 6
  00915	06		 DB	 6
  00916	06		 DB	 6
  00917	06		 DB	 6
  00918	06		 DB	 6
  00919	06		 DB	 6
  0091a	06		 DB	 6
  0091b	06		 DB	 6
  0091c	06		 DB	 6
  0091d	06		 DB	 6
  0091e	06		 DB	 6
  0091f	06		 DB	 6
  00920	06		 DB	 6
  00921	06		 DB	 6
  00922	06		 DB	 6
  00923	06		 DB	 6
  00924	06		 DB	 6
  00925	06		 DB	 6
  00926	06		 DB	 6
  00927	06		 DB	 6
  00928	06		 DB	 6
  00929	06		 DB	 6
  0092a	06		 DB	 6
  0092b	06		 DB	 6
  0092c	06		 DB	 6
  0092d	06		 DB	 6
  0092e	06		 DB	 6
  0092f	06		 DB	 6
  00930	06		 DB	 6
  00931	06		 DB	 6
  00932	06		 DB	 6
  00933	06		 DB	 6
  00934	06		 DB	 6
  00935	06		 DB	 6
  00936	06		 DB	 6
  00937	06		 DB	 6
  00938	06		 DB	 6
  00939	06		 DB	 6
  0093a	06		 DB	 6
  0093b	06		 DB	 6
  0093c	06		 DB	 6
  0093d	06		 DB	 6
  0093e	06		 DB	 6
  0093f	06		 DB	 6
  00940	06		 DB	 6
  00941	06		 DB	 6
  00942	06		 DB	 6
  00943	06		 DB	 6
  00944	06		 DB	 6
  00945	06		 DB	 6
  00946	02		 DB	 2
  00947	06		 DB	 6
  00948	03		 DB	 3
  00949	06		 DB	 6
  0094a	04		 DB	 4
  0094b	06		 DB	 6
  0094c	06		 DB	 6
  0094d	06		 DB	 6
  0094e	06		 DB	 6
  0094f	06		 DB	 6
  00950	06		 DB	 6
  00951	06		 DB	 6
  00952	06		 DB	 6
  00953	06		 DB	 6
  00954	06		 DB	 6
  00955	06		 DB	 6
  00956	06		 DB	 6
  00957	06		 DB	 6
  00958	06		 DB	 6
  00959	05		 DB	 5
  0095a	66 90		 npad	 2
$LN87@WindMsgPro:
  0095c	00 00 00 00	 DD	 $LN68@WindMsgPro
  00960	00 00 00 00	 DD	 $LN69@WindMsgPro
  00964	00 00 00 00	 DD	 $LN70@WindMsgPro
  00968	00 00 00 00	 DD	 $LN71@WindMsgPro
  0096c	00 00 00 00	 DD	 $LN72@WindMsgPro
  00970	00 00 00 00	 DD	 $LN73@WindMsgPro
  00974	00 00 00 00	 DD	 $LN74@WindMsgPro
$LN89@WindMsgPro:
  00978	00 00 00 00	 DD	 $LN40@WindMsgPro
  0097c	00 00 00 00	 DD	 $LN39@WindMsgPro
  00980	00 00 00 00	 DD	 $LN37@WindMsgPro
  00984	00 00 00 00	 DD	 $LN38@WindMsgPro
  00988	00 00 00 00	 DD	 $LN45@WindMsgPro
  0098c	00 00 00 00	 DD	 $LN7@WindMsgPro
$LN88@WindMsgPro:
  00990	00		 DB	 0
  00991	05		 DB	 5
  00992	05		 DB	 5
  00993	05		 DB	 5
  00994	05		 DB	 5
  00995	01		 DB	 1
  00996	05		 DB	 5
  00997	05		 DB	 5
  00998	05		 DB	 5
  00999	05		 DB	 5
  0099a	05		 DB	 5
  0099b	05		 DB	 5
  0099c	05		 DB	 5
  0099d	05		 DB	 5
  0099e	05		 DB	 5
  0099f	05		 DB	 5
  009a0	05		 DB	 5
  009a1	05		 DB	 5
  009a2	05		 DB	 5
  009a3	05		 DB	 5
  009a4	05		 DB	 5
  009a5	05		 DB	 5
  009a6	05		 DB	 5
  009a7	05		 DB	 5
  009a8	05		 DB	 5
  009a9	05		 DB	 5
  009aa	05		 DB	 5
  009ab	05		 DB	 5
  009ac	05		 DB	 5
  009ad	02		 DB	 2
  009ae	05		 DB	 5
  009af	03		 DB	 3
  009b0	05		 DB	 5
  009b1	05		 DB	 5
  009b2	05		 DB	 5
  009b3	05		 DB	 5
  009b4	05		 DB	 5
  009b5	05		 DB	 5
  009b6	04		 DB	 4
?WindMsgProc@@YGJPAUHWND__@@IIJ@Z ENDP			; WindMsgProc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\thread
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\thread
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp
;	COMDAT _WinMain@16
_TEXT	SEGMENT
_t1$ = -196						; size = 8
_lpCmdLine$GSCopy$1$ = -188				; size = 4
_hInstance$GSCopy$1$ = -184				; size = 4
__Decay_copied$2 = -180					; size = 4
$T3 = -176						; size = 4
_dm$4 = -172						; size = 156
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_hInstance$ = 8						; size = 4
_hPrevInstance$ = 12					; size = 4
_lpCmdLine$ = 16					; size = 4
_nCmdShow$ = 20						; size = 4
_WinMain@16 PROC					; COMDAT

; 227  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_WinMain@16
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b 45 08	 mov	 eax, DWORD PTR _hInstance$[ebp]
  00030	89 85 48 ff ff
	ff		 mov	 DWORD PTR _hInstance$GSCopy$1$[ebp], eax
  00036	8b 45 10	 mov	 eax, DWORD PTR _lpCmdLine$[ebp]
  00039	89 85 44 ff ff
	ff		 mov	 DWORD PTR _lpCmdLine$GSCopy$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\thread

; 68   :         auto _Decay_copied           = _STD make_unique<_Tuple>(_STD forward<_Fn>(_Fx), _STD forward<_Args>(_Ax)...);

  0003f	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00045	68 00 00 00 00	 push	 OFFSET ?detectSpeedHack@@YAXXZ ; detectSpeedHack
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ??$make_unique@V?$tuple@P6AXXZ@std@@A6AXXZ$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXXZ@std@@U?$default_delete@V?$tuple@P6AXXZ@std@@@2@@0@A6AXXZ@Z ; std::make_unique<std::tuple<void (__cdecl*)(void)>,void (__cdecl&)(void),0>
  00050	83 c4 08	 add	 esp, 8
  00053	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 616  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0005a	8b 30		 mov	 esi, DWORD PTR [eax]

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1375 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00062	89 b5 4c ff ff
	ff		 mov	 DWORD PTR __Decay_copied$2[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\thread

; 68   :         auto _Decay_copied           = _STD make_unique<_Tuple>(_STD forward<_Fn>(_Fx), _STD forward<_Args>(_Ax)...);

  00068	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\memory

; 3229 :         if (_Mypair._Myval2) {

  0006c	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  00072	85 c0		 test	 eax, eax
  00074	74 0b		 je	 SHORT $LN33@WinMain

; 3120 :         delete _Ptr;

  00076	6a 04		 push	 4
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0007e	83 c4 08	 add	 esp, 8
$LN33@WinMain:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\thread

; 75   :         _Thr._Hnd =

  00081	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _t1$[ebp+4]
  00087	50		 push	 eax
  00088	6a 00		 push	 0
  0008a	56		 push	 esi
  0008b	68 00 00 00 00	 push	 OFFSET ??$_Invoke@V?$tuple@P6AXXZ@std@@$0A@@thread@std@@CGIPAX@Z ; std::thread::_Invoke<std::tuple<void (__cdecl*)(void)>,0>
  00090	6a 00		 push	 0
  00092	6a 00		 push	 0
  00094	e8 00 00 00 00	 call	 __beginthreadex
  00099	83 c4 18	 add	 esp, 24			; 00000018H
  0009c	89 85 3c ff ff
	ff		 mov	 DWORD PTR _t1$[ebp], eax

; 76   :             reinterpret_cast<void*>(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id));
; 77   : #pragma warning(pop)
; 78   : 
; 79   :         if (_Thr._Hnd) { // ownership transferred to the thread

  000a2	85 c0		 test	 eax, eax
  000a4	0f 84 2b 03 00
	00		 je	 $LN19@WinMain
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

  000aa	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __Decay_copied$2[ebp], 0
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp

; 228  : 	std::thread t1(detectSpeedHack);

  000b4	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3

; 229  : #ifdef PATCHER_RUN
; 230  : 	if (strcmp(PARAM_ARGS, lpCmdLine) != 0)
; 231  : 	{
; 232  : 		MessageBox(NULL, "RUN PATCHER", "ERROR", MB_OK);
; 233  : 		return 0;
; 234  : 	}
; 235  : #endif
; 236  : 	 //Âä†ËΩΩÂä®ÊÄÅÁöÑÂàóË°®
; 237  : //	 ÂÜôÂÖ•serverMax();
; 238  : 	//LoadStoneAgeLUA(_LUA_PATCH_);
; 239  : #ifdef _NB_CMD_MODE
; 240  : 	extern void InitConsoleWindow(void)  ;
; 241  : 	InitConsoleWindow();
; 242  : #endif
; 243  : #ifndef SWITCH_MODE
; 244  : 	extern int displayBpp;
; 245  : 	HDC hDcDest = GetDC(hWnd);

  000bb	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4

; 246  : 	displayBpp = GetDeviceCaps(hDcDest, BITSPIXEL);

  000c7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDeviceCaps@8
  000cd	8b f0		 mov	 esi, eax
  000cf	6a 0c		 push	 12			; 0000000cH
  000d1	56		 push	 esi
  000d2	ff d7		 call	 edi

; 247  : 	ReleaseDC(hWnd, hDcDest);

  000d4	56		 push	 esi
  000d5	ff 35 00 00 00
	00		 push	 DWORD PTR ?hWnd@@3PAUHWND__@@A ; hWnd
  000db	a3 00 00 00 00	 mov	 DWORD PTR ?displayBpp@@3HA, eax ; displayBpp
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8

; 248  : 	if (displayBpp != 32) {

  000e6	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR ?displayBpp@@3HA, 32 ; displayBpp, 00000020H
  000ed	74 37		 je	 SHORT $LN5@WinMain

; 249  : 		DEVMODE dm;
; 250  : 		CreateCompatibleDEVMODE(&dm, 32, GetDeviceCaps(hDcDest, HORZRES), GetDeviceCaps(hDcDest, VERTRES), GetDeviceCaps(hDcDest, VREFRESH));

  000ef	6a 74		 push	 116			; 00000074H
  000f1	56		 push	 esi
  000f2	ff d7		 call	 edi
  000f4	50		 push	 eax
  000f5	6a 0a		 push	 10			; 0000000aH
  000f7	56		 push	 esi
  000f8	ff d7		 call	 edi
  000fa	50		 push	 eax
  000fb	6a 08		 push	 8
  000fd	56		 push	 esi
  000fe	ff d7		 call	 edi
  00100	50		 push	 eax
  00101	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _dm$4[ebp]
  00107	6a 20		 push	 32			; 00000020H
  00109	50		 push	 eax
  0010a	e8 00 00 00 00	 call	 ?CreateCompatibleDEVMODE@@YAXPAU_devicemodeA@@KKKK@Z ; CreateCompatibleDEVMODE
  0010f	83 c4 14	 add	 esp, 20			; 00000014H

; 251  : 		ChangeDisplaySettings(&dm, 0);

  00112	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _dm$4[ebp]
  00118	6a 00		 push	 0
  0011a	50		 push	 eax
  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ChangeDisplaySettingsA@8
  00121	e9 80 02 00 00	 jmp	 $LN15@WinMain
$LN5@WinMain:

; 252  : 		return FALSE;
; 253  : 	}
; 254  : #endif
; 255  : 
; 256  : 	hInst = hInstance;		// „Éë„É©„É°„Éº„Çø„Éº„Åß„ÇÇ„Çâ„Å£„Åü„Ç§„É≥„Çπ„Çø„É≥„Çπ„Éè„É≥„Éâ„É´„Çí„Ç∞„É≠„Éº„Éê„Éº„É´„Å´‰ª£ÂÖ•
; 257  : 	CmdShow = nCmdShow;		// WinMainÈñ¢Êï∞„ÅÆÂºïÊï∞„Çí„Ç∞„É≠„Éº„Éê„É´„Å´„Åô„Çã

  00126	8b 45 14	 mov	 eax, DWORD PTR _nCmdShow$[ebp]
  00129	8b b5 48 ff ff
	ff		 mov	 esi, DWORD PTR _hInstance$GSCopy$1$[ebp]

; 258  : 	CmdLine = lpCmdLine;	// WinMainÈñ¢Êï∞„ÅÆ„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥ÂºïÊï∞„Çí„Ç∞„É≠„Éº„Éê„É´„Å´„Åô„Çã

  0012f	8b bd 44 ff ff
	ff		 mov	 edi, DWORD PTR _lpCmdLine$GSCopy$1$[ebp]

; 259  : 
; 260  : #ifndef _NB_ÂÆ¢Êà∑Á´ØÁõ¥Êé•ÂêØÂä®
; 261  : 	if( !strstr( CmdLine, "updated" ) ){
; 262  : 		MessageBox( NULL, "Ê≠§ÊâßË°åÊ°£‰∏çËÉΩËµ∑Âä®ÔºÅ\nÔºåËØ∑ÊâßË°å‚ÄúÂêØÂä®Áü≥Âô®Êó∂‰ª£‚Äù\nÊàñÊâßË°å‚ÄúStoneAge.exe‚ÄùÔºÅ", "ÌôïÏù∏", MB_OK | MB_ICONSTOP );
; 263  : 		return FALSE;
; 264  : 	}
; 265  : #endif
; 266  : 
; 267  : 	ÁºñÁ†Å = 949;// GetACP();
; 268  : 
; 269  : 	// Âª∫Á´ã‰∏Ä‰∏™Ê†∏ÂøÉÁâ©‰ª∂,ËÆ©Êõ¥Êñ∞Á®ãÂºèÂèØ‰ª•Âà§Êñ≠ÊòØÂê¶ÊúâÁü≥Âô®Ê≠£Âú®ÊâßË°å
; 270  : 	hCheckMutex = CreateMutex(NULL, FALSE, "CheckForUpdate");

  00135	68 00 00 00 00	 push	 OFFSET ??_C@_0P@FDFFMAOB@CheckForUpdate@
  0013a	6a 00		 push	 0
  0013c	6a 00		 push	 0
  0013e	89 35 00 00 00
	00		 mov	 DWORD PTR ?hInst@@3PAUHINSTANCE__@@A, esi ; hInst
  00144	a3 00 00 00 00	 mov	 DWORD PTR ?CmdShow@@3HA, eax ; CmdShow
  00149	89 3d 00 00 00
	00		 mov	 DWORD PTR ?CmdLine@@3PADA, edi ; CmdLine
  0014f	c7 05 00 00 00
	00 b5 03 00 00	 mov	 DWORD PTR ???@@3HA, 949	; ??, 000003b5H
  00159	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12
  0015f	a3 00 00 00 00	 mov	 DWORD PTR ?hCheckMutex@@3PAXA, eax ; hCheckMutex

; 271  : 
; 272  : #ifdef _STONDEBUG_
; 273  : 	_CrtSetDbgFlag( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
; 274  : #endif
; 275  : 	
; 276  : #ifdef __NEW_CLIENT
; 277  : #ifdef __KOREA
; 278  : 	//ADD jeffrey
; 279  : 	char ip[16];
; 280  : 	int startindex = 0;
; 281  : 
; 282  : 	ZeroMemory( gmsv, sizeof(gameserver)*MAX_GMSV);
; 283  : 	ZeroMemory( gmgroup, sizeof(gamegroup)*MAX_GMGROUP);
; 284  : 	char *temp = strstr(CmdLine , "&");
; 285  : 	strtok(temp , ";");
; 286  : 	char *tmp = strtok(NULL , ";");
; 287  : 	extern int nGroup;
; 288  : 	nGroup = atoi(tmp);                          //Áæ§ÁªÑÊï∞
; 289  : 	for(int z = 0 ; z < nGroup ; z++)
; 290  : 	{
; 291  : 		char *universes = strtok(NULL , ";");        //ÊòüÁ≥ªÂêçÁß∞
; 292  : 		strcpy( gmgroup[z].name, universes);
; 293  : 		char *numtmp = strtok(NULL , ";");           //ÊòüÁêÉÊï∞
; 294  : 		int num = atoi(numtmp);
; 295  : 		gmgroup[z].num = num;
; 296  : 		gmgroup[z].startindex = startindex;
; 297  : 		startindex += num;
; 298  : 		gmgroup[z].used = 1;
; 299  : 		char *szIP = strtok(NULL , ";");             //ÊòüÁ≥ªIP
; 300  : 		for(int v = gmgroup[z].startindex ; v < startindex ; v++)
; 301  : 		{
; 302  : 			char *name = strtok(NULL , ";");         //ÊòüÁêÉÂêçÁß∞
; 303  : 			strcpy( gmsv[v].name, name);
; 304  : 			char *lastip = strtok(NULL , ";");       //ÊòüÁêÉip
; 305  : 			sprintf(ip , "%s.%s" , szIP , lastip);
; 306  : 			strcpy( gmsv[v].ipaddr, ip);
; 307  : 			char *port = strtok(NULL , ";");      //port
; 308  : 			strcpy( gmsv[v].port, port);
; 309  : 			gmsv[v].used = '1';
; 310  : 		}
; 311  : 	}
; 312  : 	//END
; 313  : #endif
; 314  : 	dwPID = GetCurrentProcessId();

  00164	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0

; 315  : 	if( INVALID_HANDLE_VALUE == (hProcessSnap=CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, NULL)))

  0016a	6a 00		 push	 0
  0016c	6a 02		 push	 2
  0016e	a3 00 00 00 00	 mov	 DWORD PTR ?dwPID@@3KA, eax ; dwPID
  00173	e8 00 00 00 00	 call	 _CreateToolhelp32Snapshot@8
  00178	a3 00 00 00 00	 mov	 DWORD PTR ?hProcessSnap@@3PAXA, eax ; hProcessSnap
  0017d	83 f8 ff	 cmp	 eax, -1
  00180	0f 84 20 02 00
	00		 je	 $LN15@WinMain

; 316  : 		return 0;
; 317  : 	{
; 318  : 		pe32.dwSize = sizeof(PROCESSENTRY32);
; 319  : 		if( Process32First( hProcessSnap, &pe32)){ 

  00186	68 00 00 00 00	 push	 OFFSET ?pe32@@3UtagPROCESSENTRY32@@A ; pe32
  0018b	50		 push	 eax
  0018c	c7 05 00 00 00
	00 28 01 00 00	 mov	 DWORD PTR ?pe32@@3UtagPROCESSENTRY32@@A, 296 ; 00000128H
  00196	e8 00 00 00 00	 call	 _Process32First@8
  0019b	85 c0		 test	 eax, eax
  0019d	74 2e		 je	 SHORT $LN3@WinMain
  0019f	90		 npad	 1
$LL4@WinMain:

; 320  : 			do{
; 321  : 				if( pe32.th32ProcessID == dwPID){

  001a0	a1 08 00 00 00	 mov	 eax, DWORD PTR ?pe32@@3UtagPROCESSENTRY32@@A+8
  001a5	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?dwPID@@3KA ; dwPID
  001ab	74 16		 je	 SHORT $LN69@WinMain

; 323  : 					break;
; 324  : 				}
; 325  : 			}while( Process32Next( hProcessSnap, &pe32));

  001ad	68 00 00 00 00	 push	 OFFSET ?pe32@@3UtagPROCESSENTRY32@@A ; pe32
  001b2	ff 35 00 00 00
	00		 push	 DWORD PTR ?hProcessSnap@@3PAXA ; hProcessSnap
  001b8	e8 00 00 00 00	 call	 _Process32Next@8
  001bd	85 c0		 test	 eax, eax
  001bf	75 df		 jne	 SHORT $LL4@WinMain
  001c1	eb 0a		 jmp	 SHORT $LN3@WinMain
$LN69@WinMain:

; 322  : 					dwPID = pe32.th32ParentProcessID;

  001c3	a1 18 00 00 00	 mov	 eax, DWORD PTR ?pe32@@3UtagPROCESSENTRY32@@A+24
  001c8	a3 00 00 00 00	 mov	 DWORD PTR ?dwPID@@3KA, eax ; dwPID
$LN3@WinMain:

; 326  : 		}
; 327  : 	}
; 328  : #endif
; 329  : 
; 330  :     if( !hPrevInstance ){

  001cd	83 7d 0c 00	 cmp	 DWORD PTR _hPrevInstance$[ebp], 0
  001d1	0f 85 94 00 00
	00		 jne	 $LN10@WinMain

; 331  : 		wndclass.style = CS_BYTEALIGNCLIENT | CS_DBLCLKS;	// „ÇØ„É©„Çπ„Çπ„Çø„Ç§„É´
; 332  : 		wndclass.lpfnWndProc = WindMsgProc;		// „Ç¶„Ç§„É≥„Éâ„Ç¶„Éó„É≠„Ç∑„Éº„Ç∏„É£„Éº„Ç¢„Éâ„É¨„ÇπÂÆöÁæ©
; 333  : 		wndclass.cbClsExtra = 0;				// „ÇØ„É©„ÇπÊØé„ÅÆË£úË∂≥ÂÆöÁæ©„Å™„Åó
; 334  : 		wndclass.cbWndExtra = 0;				// „Ç¶„Ç§„É≥„Éâ„Ç¶ÊØé„ÅÆË£úË∂≥„Éá„Éº„ÇøÁÑ°„Åó
; 335  : 		wndclass.hInstance = hInstance;			// „Ç§„É≥„Çπ„Çø„É≥„Çπ„Éè„É≥„Éâ„É´ÂÆöÁæ©
; 336  : 	    wndclass.hIcon = LoadIcon( hInstance, MAKEINTRESOURCE(SA_ICON2));

  001d7	6a 70		 push	 112			; 00000070H
  001d9	56		 push	 esi
  001da	c7 05 00 00 00
	00 08 10 00 00	 mov	 DWORD PTR ?wndclass@@3UtagWNDCLASSA@@A, 4104 ; 00001008H
  001e4	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?wndclass@@3UtagWNDCLASSA@@A+4, OFFSET ?WindMsgProc@@YGJPAUHWND__@@IIJ@Z ; WindMsgProc
  001ee	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?wndclass@@3UtagWNDCLASSA@@A+8, 0
  001f8	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?wndclass@@3UtagWNDCLASSA@@A+12, 0
  00202	89 35 10 00 00
	00		 mov	 DWORD PTR ?wndclass@@3UtagWNDCLASSA@@A+16, esi
  00208	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadIconA@8

; 337  : 		wndclass.hCursor = LoadCursor(hInstance ,MAKEINTRESOURCE(SA_MOUSE));

  0020e	6a 68		 push	 104			; 00000068H
  00210	56		 push	 esi
  00211	a3 14 00 00 00	 mov	 DWORD PTR ?wndclass@@3UtagWNDCLASSA@@A+20, eax
  00216	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadCursorA@8

; 338  : 		wndclass.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);// „Ç¶„Ç£„É≥„Éâ„Ç¶„ÅÆËÉåÊôØËâ≤

  0021c	6a 04		 push	 4
  0021e	a3 18 00 00 00	 mov	 DWORD PTR ?wndclass@@3UtagWNDCLASSA@@A+24, eax
  00223	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStockObject@4

; 339  : 		wndclass.lpszMenuName= NULL;			// „É°„Éã„É•„Éº„Å™„Åó
; 340  : 		wndclass.lpszClassName = DEF_APPNAME;	// „Çø„Ç§„Éà„É´„Éê„ÉºÊñáÂ≠óË®≠ÂÆö
; 341  : 		if( !RegisterClass(&wndclass) ){

  00229	68 00 00 00 00	 push	 OFFSET ?wndclass@@3UtagWNDCLASSA@@A ; wndclass
  0022e	a3 1c 00 00 00	 mov	 DWORD PTR ?wndclass@@3UtagWNDCLASSA@@A+28, eax
  00233	c7 05 20 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?wndclass@@3UtagWNDCLASSA@@A+32, 0
  0023d	c7 05 24 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?wndclass@@3UtagWNDCLASSA@@A+36, OFFSET ??_C@_0BB@NLNMPB@?$KD?S?$KD?t?$KD?o?$KD?n?$KD?e?$KD?A?$KD?g?$KD?e@
  00247	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterClassA@4
  0024d	66 85 c0	 test	 ax, ax
  00250	75 19		 jne	 SHORT $LN10@WinMain

; 342  : 			MessageBox( NULL, "ÂàùÂßãÂåñËßÜÁ™óÂ§±Ë¥•ÔºÅ\nÔºåËØ∑ÊâßË°åÈáçÊñ∞ÂÆâË£ÖÊàñÊ¥ΩËØ¢ÂÆ¢Êúç‰∫∫ÂëòÔºÅ",

  00252	6a 10		 push	 16			; 00000010H
  00254	68 00 00 00 00	 push	 OFFSET ??_C@_04IJNKKJEO@?H?$KO?$MA?N@
  00259	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@MPCLFILL@?t?x?c?$LH?$PL?y?$DP?$DP?c?w?$DP?$KD?$KB?6?$KD?$KM?$DP?$DP?z?$LM?q?l?c?f?d?L?$DP?$PL?d?$PN?g@
  0025e	6a 00		 push	 0
  00260	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  00266	e9 3b 01 00 00	 jmp	 $LN15@WinMain
$LN10@WinMain:

; 343  : 				"ÌôïÏù∏", MB_OK | MB_ICONSTOP );
; 344  : 			return FALSE;						// ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åü„ÇâÁµÇ‰∫Ü„Åô„Çã
; 345  : 		}
; 346  : 	}
; 347  : #ifdef _TIME_GET_TIME
; 348  : 	QueryPerformanceFrequency(&tickCount);
; 349  : 	tickCount.QuadPart = tickCount.QuadPart/1000;
; 350  : #endif
; 351  : 	// Ë™≠„ÅøËæº„Åø„Éï„Ç°„Ç§„É´Âêç„ÅÆË®≠ÂÆö
; 352  : 	strcpy( realBinName, REALBIN_DIR );			// REAL.BIN„ÅÆÂ†¥ÊâÄ

  0026b	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0O@DKGBMFPD@data?2real?4bin@+8
  00270	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0O@DKGBMFPD@data?2real?4bin@
  00278	a3 08 00 00 00	 mov	 DWORD PTR ?realBinName@@3PADA+8, eax
  0027d	0f b7 05 0c 00
	00 00		 movzx	 eax, WORD PTR ??_C@_0O@DKGBMFPD@data?2real?4bin@+12
  00284	66 a3 0c 00 00
	00		 mov	 WORD PTR ?realBinName@@3PADA+12, ax

; 353  : 	strcpy( adrnBinName, ADRNBIN_DIR );			// ADRN.BIN„ÅÆÂ†¥ÊâÄ

  0028a	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0O@HIHIJMIB@data?2adrn?4bin@+8
  0028f	a3 08 00 00 00	 mov	 DWORD PTR ?adrnBinName@@3PADA+8, eax
  00294	0f b7 05 0c 00
	00 00		 movzx	 eax, WORD PTR ??_C@_0O@HIHIJMIB@data?2adrn?4bin@+12
  0029b	66 0f d6 05 00
	00 00 00	 movq	 QWORD PTR ?realBinName@@3PADA, xmm0
  002a3	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0O@HIHIJMIB@data?2adrn?4bin@
  002ab	66 a3 0c 00 00
	00		 mov	 WORD PTR ?adrnBinName@@3PADA+12, ax

; 354  : 	strcpy( sprBinName, SPRBIN_DIR );			// SPR.BIN„ÅÆÂ†¥ÊâÄ

  002b1	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0N@LCHFCHHG@data?2spr?4bin@+8
  002b6	66 0f d6 05 00
	00 00 00	 movq	 QWORD PTR ?adrnBinName@@3PADA, xmm0
  002be	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0N@LCHFCHHG@data?2spr?4bin@
  002c6	a3 08 00 00 00	 mov	 DWORD PTR ?sprBinName@@3PADA+8, eax
  002cb	0f b6 05 0c 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_0N@LCHFCHHG@data?2spr?4bin@+12
  002d2	66 0f d6 05 00
	00 00 00	 movq	 QWORD PTR ?sprBinName@@3PADA, xmm0

; 355  : 	strcpy( sprAdrnBinName, SPRADRNBIN_DIR );	// SPRADRN.BIN„ÅÆÂ†¥ÊâÄ

  002da	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0BB@PFEKOFDI@data?2spradrn?4bin@
  002e1	a2 0c 00 00 00	 mov	 BYTE PTR ?sprBinName@@3PADA+12, al
  002e6	0f b6 05 10 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_0BB@PFEKOFDI@data?2spradrn?4bin@+16
  002ed	0f 11 05 00 00
	00 00		 movups	 XMMWORD PTR ?sprAdrnBinName@@3PADA, xmm0
  002f4	a2 10 00 00 00	 mov	 BYTE PTR ?sprAdrnBinName@@3PADA+16, al

; 356  : #ifdef _READ16BITBMP
; 357  : 	strcpy(realtrueBinName,REALTRUEBIN_DIR);
; 358  : 	strcpy(adrntrueBinName,ADRNTRUEBIN_DIR);
; 359  : #endif
; 360  : 	//„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥Ëß£Êûê 
; 361  : 	AnalyzeCmdLine();

  002f9	e8 00 00 00 00	 call	 ?AnalyzeCmdLine@@YAXXZ	; AnalyzeCmdLine

; 362  : 	memset(lpCmdLine, 0, strlen(lpCmdLine));

  002fe	8b cf		 mov	 ecx, edi
  00300	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL72@WinMain:
  00303	8a 01		 mov	 al, BYTE PTR [ecx]
  00305	41		 inc	 ecx
  00306	84 c0		 test	 al, al
  00308	75 f9		 jne	 SHORT $LL72@WinMain
  0030a	2b ca		 sub	 ecx, edx
  0030c	51		 push	 ecx
  0030d	6a 00		 push	 0
  0030f	57		 push	 edi
  00310	e8 00 00 00 00	 call	 _memset

; 363  : 	// Ëß£ÂÉèÂ∫¶„É¢„Éº„ÉâË®≠ÂÆö
; 364  : 
; 365  : 	SetResoMode( ResoMode );

  00315	ff 35 00 00 00
	00		 push	 DWORD PTR ?ResoMode@@3HA ; ResoMode
  0031b	e8 00 00 00 00	 call	 ?SetResoMode@@YAXH@Z	; SetResoMode

; 366  : 	// „Ç¶„Ç£„É≥„Éâ„Ç¶„ÅÆ‰ΩúÊàê
; 367  : 	ChangeWindowMode();

  00320	e8 00 00 00 00	 call	 ?ChangeWindowMode@@YAXXZ ; ChangeWindowMode

; 368  : #ifdef _TALK_WINDOW
; 369  : 	TalkWindow.Init(hWnd,hInstance);
; 370  : 	if(g_bTalkWindow) TalkWindow.Create();
; 371  : #endif
; 372  : #ifdef _NB_Êñ≠Á∫øËá™Âä®ÈáçËøû
; 373  : 	PcLanded.Â§ßÂå∫ = PcLanded.‰∫∫Áâ© = PcLanded.Â∞èÂå∫ = PcLanded.ÈòüÊ®° = -1;
; 374  : 	PcLanded.ÊòØÂê¶Ëá™Âä®ÂñäËØù = PcLanded.ÊòØÂê¶Ëá™Âä®ÈÅáÊïå = PcLanded.‰∫∫Áâ©ÊñπÂêë = PcLanded.ÁôªÈôÜÂª∂Êó∂Êó∂Èó¥ = FALSE;
; 375  : 	memset(PcLanded.ÁôªÈôÜ‰∫∫Áâ©ÂêçÁß∞, 0, 4 * 32);

  00325	68 80 00 00 00	 push	 128			; 00000080H
  0032a	6a 00		 push	 0
  0032c	68 1c 00 00 00	 push	 OFFSET ?PcLanded@@3ULanded@@A+28
  00331	c7 05 04 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+4, -1
  0033b	c7 05 08 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+8, -1
  00345	c7 05 0c 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+12, -1
  0034f	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A, -1
  00359	c7 05 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, 0
  00363	c7 05 18 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+24, 0
  0036d	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+20, 0
  00377	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+16, 0
  00381	e8 00 00 00 00	 call	 _memset
  00386	83 c4 1c	 add	 esp, 28			; 0000001cH

; 376  : #endif
; 377  : 	void SetTestServer();
; 378  : //	SetTestServer();
; 379  : 	GameMain();

  00389	e8 00 00 00 00	 call	 ?GameMain@@YAHXZ	; GameMain

; 380  : 
; 381  : #ifdef __NEW_CLIENT
; 382  : 	CloseHandle( hProcessSnap);

  0038e	ff 35 00 00 00
	00		 push	 DWORD PTR ?hProcessSnap@@3PAXA ; hProcessSnap
  00394	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 383  : #endif
; 384  : 
; 385  : #ifdef SWITCH_MODE
; 386  : 	extern DEVMODE g_OriginalMode;
; 387  : 	if( g_OriginalMode.dmSize != 0){
; 388  : 		DEVMODE	DevMode;
; 389  : 		DevMode.dmSize = sizeof(DEVMODE);
; 390  : 		EnumDisplaySettings( NULL, ENUM_CURRENT_SETTINGS, &DevMode);
; 391  : 		if( DevMode.dmPelsWidth!=g_OriginalMode.dmPelsWidth || DevMode.dmPelsHeight!=g_OriginalMode.dmPelsHeight || DevMode.dmBitsPerPel!=g_OriginalMode.dmBitsPerPel){
; 392  : 			g_OriginalMode.dmFields = DM_BITSPERPEL|DM_PELSWIDTH|DM_PELSHEIGHT;
; 393  : 			ChangeDisplaySettingsEx( NULL, &g_OriginalMode, NULL, CDS_UPDATEREGISTRY, NULL);
; 394  : 		}
; 395  : 	}
; 396  : #endif
; 397  : #ifdef _REMAKE_20
; 398  : #ifndef _STONDEBUG_
; 399  : 	QuitingInputScript();
; 400  : #endif
; 401  : 	QuitRestore();
; 402  : #endif
; 403  : #ifdef _STONDEBUG_
; 404  : 	if(g_iMallocCount != 0){
; 405  : 		char MSG[256];
; 406  : 		sprintf(MSG,"g_iMallocCount = %d",g_iMallocCount);
; 407  : 		MessageBox( NULL,MSG,"ÌôïÏù∏", MB_OK | MB_ICONSTOP );
; 408  : 	}
; 409  : #endif
; 410  : 	ReleaseMutex(hCheckMutex);

  0039a	ff 35 00 00 00
	00		 push	 DWORD PTR ?hCheckMutex@@3PAXA ; hCheckMutex
  003a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4
$LN15@WinMain:

; 412  : 	return FALSE;

  003a6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\thread

; 118  :         return _Thr._Id != 0;

  003ad	83 bd 40 ff ff
	ff 00		 cmp	 DWORD PTR _t1$[ebp+4], 0

; 94   :         if (joinable()) {

  003b4	75 30		 jne	 SHORT $LN76@WinMain
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\main.cpp

; 412  : 	return FALSE;

  003b6	33 c0		 xor	 eax, eax

; 413  : }

  003b8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003bb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003c2	59		 pop	 ecx
  003c3	5f		 pop	 edi
  003c4	5e		 pop	 esi
  003c5	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003c8	33 cd		 xor	 ecx, ebp
  003ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003cf	8b e5		 mov	 esp, ebp
  003d1	5d		 pop	 ebp
  003d2	c2 10 00	 ret	 16			; 00000010H
$LN19@WinMain:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\thread

; 83   :             _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

  003d5	6a 06		 push	 6
  003d7	c7 85 40 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _t1$[ebp+4], 0
  003e1	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN76@WinMain:

; 95   :             _STD terminate();

  003e6	e8 00 00 00 00	 call	 _terminate
$LN74@WinMain:
  003eb	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_WinMain@16$1:
  00000	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V?$tuple@P6AXXZ@std@@U?$default_delete@V?$tuple@P6AXXZ@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(void)>,std::default_delete<std::tuple<void (__cdecl*)(void)> > >::~unique_ptr<std::tuple<void (__cdecl*)(void)>,std::default_delete<std::tuple<void (__cdecl*)(void)> > >
__unwindfunclet$_WinMain@16$2:
  0000b	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR __Decay_copied$2[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V?$tuple@P6AXXZ@std@@U?$default_delete@V?$tuple@P6AXXZ@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(void)>,std::default_delete<std::tuple<void (__cdecl*)(void)> > >::~unique_ptr<std::tuple<void (__cdecl*)(void)>,std::default_delete<std::tuple<void (__cdecl*)(void)> > >
__unwindfunclet$_WinMain@16$0:
  00016	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _t1$[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1thread@std@@QAE@XZ	; std::thread::~thread
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
  00024	cc		 int	 3
  00025	cc		 int	 3
__ehhandler$_WinMain@16:
  00026	90		 npad	 1
  00027	90		 npad	 1
  00028	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002f	8b 8a 3c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-196]
  00035	33 c8		 xor	 ecx, eax
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0003f	33 c8		 xor	 ecx, eax
  00041	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00046	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_WinMain@16
  0004b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_WinMain@16 ENDP
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
;	COMDAT ?clear@ios_base@std@@QAEXH_N@Z
_TEXT	SEGMENT
$T1 = -28						; size = 20
$T2 = -8						; size = 8
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@ios_base@std@@QAEXH_N@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 243  :     void __CLR_OR_THIS_CALL clear(iostate _State, bool _Reraise) { // set state, possibly reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 244  :         _State &= _Statmask;

  00003	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  00006	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00009	83 e0 17	 and	 eax, 23			; 00000017H

; 245  :         _Mystate             = _State;

  0000c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 246  :         const auto _Filtered = _State & _Except;

  0000f	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00012	56		 push	 esi
  00013	23 c8		 and	 ecx, eax

; 247  :         if (_Filtered) {

  00015	74 08		 je	 SHORT $LN2@clear

; 248  :             if (_Reraise) {

  00017	80 7d 0c 00	 cmp	 BYTE PTR __Reraise$[ebp], 0
  0001b	74 12		 je	 SHORT $LN3@clear
  0001d	eb 07		 jmp	 SHORT $LN11@clear
$LN2@clear:

; 262  :         }
; 263  :     }

  0001f	5e		 pop	 esi
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
$LN11@clear:

; 249  :                 _RERAISE;

  00026	6a 00		 push	 0
  00028	6a 00		 push	 0
  0002a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@clear:

; 250  :             }
; 251  : 
; 252  :             const char* _Msg;
; 253  :             if (_Filtered & ios_base::badbit) {

  0002f	f6 c1 04	 test	 cl, 4
  00032	74 07		 je	 SHORT $LN4@clear

; 254  :                 _Msg = "ios_base::badbit set";

  00034	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  00039	eb 10		 jmp	 SHORT $LN6@clear
$LN4@clear:

; 255  :             } else if (_Filtered & ios_base::failbit) {

  0003b	f6 c1 02	 test	 cl, 2
  0003e	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
  00043	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
  00048	0f 44 f0	 cmove	 esi, eax
$LN6@clear:

; 256  :                 _Msg = "ios_base::failbit set";
; 257  :             } else {
; 258  :                 _Msg = "ios_base::eofbit set";
; 259  :             }
; 260  : 
; 261  :             _THROW(failure(_Msg));

  0004b	8d 45 f8	 lea	 eax, DWORD PTR $T2[ebp]
  0004e	6a 01		 push	 1
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  00056	83 c4 08	 add	 esp, 8
  00059	8d 4d e4	 lea	 ecx, DWORD PTR $T1[ebp]
  0005c	50		 push	 eax
  0005d	56		 push	 esi
  0005e	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  00063	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00068	8d 45 e4	 lea	 eax, DWORD PTR $T1[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN9@clear:
  00071	cc		 int	 3
?clear@ios_base@std@@QAEXH_N@Z ENDP			; std::ios_base::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Gfailure@ios_base@std@@UAEPAXI@Z PROC		; std::ios_base::failure::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_Gfailure@ios_base@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 90   :         __std_exception_destroy(&_Data);

  00030	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00033	50		 push	 eax
  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0003a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0003f	83 c4 04	 add	 esp, 4
  00042	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00046	74 0b		 je	 SHORT $LN18@scalar
  00048	6a 14		 push	 20			; 00000014H
  0004a	56		 push	 esi
  0004b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00050	83 c4 08	 add	 esp, 8
$LN18@scalar:
  00053	8b c6		 mov	 eax, esi
  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	5e		 pop	 esi
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_Gfailure@ios_base@std@@UAEPAXI@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1system_error@std@@UAE@XZ
__unwindfunclet$??_Gfailure@ios_base@std@@UAEPAXI@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1_System_error@std@@UAE@XZ
__unwindfunclet$??_Gfailure@ios_base@std@@UAEPAXI@Z$2:
  00010	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1runtime_error@std@@UAE@XZ
__unwindfunclet$??_Gfailure@ios_base@std@@UAEPAXI@Z$3:
  00018	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00020	cc		 int	 3
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
  00024	cc		 int	 3
__ehhandler$??_Gfailure@ios_base@std@@UAEPAXI@Z:
  00025	90		 npad	 1
  00026	90		 npad	 1
  00027	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002e	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00031	33 c8		 xor	 ecx, eax
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_Gfailure@ios_base@std@@UAEPAXI@Z
  0003d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_Gfailure@ios_base@std@@UAEPAXI@Z ENDP		; std::ios_base::failure::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0failure@ios_base@std@@QAE@ABV012@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0failure@ios_base@std@@QAE@ABV012@@Z PROC		; std::ios_base::failure::failure, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0failure@ios_base@std@@QAE@ABV012@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0002a	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  0002d	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00030	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :     {

  00033	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7exception@std@@6B@

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  00039	50		 push	 eax
  0003a	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0003e	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ___std_exception_copy
  00047	83 c4 08	 add	 esp, 8
  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00051	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7runtime_error@std@@6B@
  00057	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0005e	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
  00064	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00067	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0006a	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  0006d	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  00070	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00077	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7system_error@std@@6B@
  0007d	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  00084	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7failure@ios_base@std@@6B@
  0008a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00091	8b c7		 mov	 eax, edi
  00093	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00096	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009d	59		 pop	 ecx
  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0failure@ios_base@std@@QAE@ABV012@@Z$3:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
__unwindfunclet$??0failure@ios_base@std@@QAE@ABV012@@Z$2:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1runtime_error@std@@UAE@XZ
__unwindfunclet$??0failure@ios_base@std@@QAE@ABV012@@Z$1:
  00010	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1_System_error@std@@UAE@XZ
__unwindfunclet$??0failure@ios_base@std@@QAE@ABV012@@Z$0:
  00018	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1system_error@std@@UAE@XZ
  00020	cc		 int	 3
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
  00024	cc		 int	 3
__ehhandler$??0failure@ios_base@std@@QAE@ABV012@@Z:
  00025	90		 npad	 1
  00026	90		 npad	 1
  00027	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002e	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00031	33 c8		 xor	 ecx, eax
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0failure@ios_base@std@@QAE@ABV012@@Z
  0003d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0failure@ios_base@std@@QAE@ABV012@@Z ENDP		; std::ios_base::failure::failure
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1failure@ios_base@std@@UAE@XZ PROC			; std::ios_base::failure::~failure, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1failure@ios_base@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 90   :         __std_exception_destroy(&_Data);

  0002d	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00030	50		 push	 eax
  00031	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00037	e8 00 00 00 00	 call	 ___std_exception_destroy
  0003c	83 c4 04	 add	 esp, 4
  0003f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00042	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00049	59		 pop	 ecx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1failure@ios_base@std@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1system_error@std@@UAE@XZ
__unwindfunclet$??1failure@ios_base@std@@UAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1_System_error@std@@UAE@XZ
__unwindfunclet$??1failure@ios_base@std@@UAE@XZ$2:
  00010	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1runtime_error@std@@UAE@XZ
__unwindfunclet$??1failure@ios_base@std@@UAE@XZ$3:
  00018	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00020	cc		 int	 3
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
  00024	cc		 int	 3
__ehhandler$??1failure@ios_base@std@@UAE@XZ:
  00025	90		 npad	 1
  00026	90		 npad	 1
  00027	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002e	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00031	33 c8		 xor	 ecx, eax
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1failure@ios_base@std@@UAE@XZ
  0003d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1failure@ios_base@std@@UAE@XZ ENDP			; std::ios_base::failure::~failure
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
;	COMDAT ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
_TEXT	SEGMENT
_this$GSCopy$ = -48					; size = 4
tv317 = -44						; size = 4
_this$ = -44						; size = 4
$T2 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
__Errcode$ = 12						; size = 4
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z PROC	; std::ios_base::failure::failure, COMDAT
; _this$ = ecx

; 204  :         explicit failure(const char* _Message, const error_code& _Errcode = make_error_code(io_errc::stream))

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 d4	 mov	 DWORD PTR _this$[ebp], esi
  00030	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp]
  00033	8b 55 08	 mov	 edx, DWORD PTR __Message$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00036	8b ca		 mov	 ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 204  :         explicit failure(const char* _Message, const error_code& _Errcode = make_error_code(io_errc::stream))

  00038	89 75 d0	 mov	 DWORD PTR _this$GSCopy$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0003b	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 205  :             : system_error(_Errcode, _Message) {} // construct with message

  00042	8b 38		 mov	 edi, DWORD PTR [eax]
  00044	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00047	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 2355 :     size_type _Mysize = 0; // current length of string

  0004a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0

; 2356 :     size_type _Myres  = 0; // current storage reserved for string

  00051	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 0

; 4596 :         _My_data._Mysize = 0;

  00058	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0005f	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00066	c6 45 d8 00	 mov	 BYTE PTR $T2[ebp], 0

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0006a	89 45 d4	 mov	 DWORD PTR tv317[ebp], eax
  0006d	0f 1f 00	 npad	 3
$LL50@failure:
  00070	8a 01		 mov	 al, BYTE PTR [ecx]
  00072	41		 inc	 ecx
  00073	84 c0		 test	 al, al
  00075	75 f9		 jne	 SHORT $LL50@failure
  00077	2b 4d d4	 sub	 ecx, DWORD PTR tv317[ebp]

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0007a	51		 push	 ecx
  0007b	52		 push	 edx
  0007c	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  0007f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error

; 467  :     system_error(error_code _Errcode, const char* _Message) : _Mybase(_Errcode, _Message) {}

  00084	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0008b	8d 45 d8	 lea	 eax, DWORD PTR $T2[ebp]
  0008e	50		 push	 eax
  0008f	53		 push	 ebx
  00090	57		 push	 edi
  00091	8b ce		 mov	 ecx, esi
  00093	e8 00 00 00 00	 call	 ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
  00098	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  0009c	8b 55 ec	 mov	 edx, DWORD PTR $T2[ebp+20]
  0009f	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  000a2	72 28		 jb	 SHORT $LN44@failure
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a4	8b 4d d8	 mov	 ecx, DWORD PTR $T2[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  000a7	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a8	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000aa	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000b0	72 10		 jb	 SHORT $LN43@failure

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000b2	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  000b5	83 c2 23	 add	 edx, 35			; 00000023H
  000b8	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000ba	83 c0 fc	 add	 eax, -4			; fffffffcH
  000bd	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000c0	77 56		 ja	 SHORT $LN54@failure
$LN43@failure:

; 264  :         ::operator delete(_Ptr, _Bytes);

  000c2	52		 push	 edx
  000c3	51		 push	 ecx
  000c4	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000c9	83 c4 08	 add	 esp, 8
$LN44@failure:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  000cc	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  000d3	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  000da	c6 45 d8 00	 mov	 BYTE PTR $T2[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error

; 467  :     system_error(error_code _Errcode, const char* _Message) : _Mybase(_Errcode, _Message) {}

  000de	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7system_error@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 205  :             : system_error(_Errcode, _Message) {} // construct with message

  000e4	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  000eb	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7failure@ios_base@std@@6B@
  000f1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000f8	8b c6		 mov	 eax, esi
  000fa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000fd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00104	59		 pop	 ecx
  00105	5f		 pop	 edi
  00106	5e		 pop	 esi
  00107	5b		 pop	 ebx
  00108	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010b	33 cd		 xor	 ecx, ebp
  0010d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00112	8b e5		 mov	 esp, ebp
  00114	5d		 pop	 ebp
  00115	c2 08 00	 ret	 8
$LN54@failure:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00118	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN52@failure:
  0011d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z$1:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z$2:
  00008	8b 4d d0	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1_System_error@std@@UAE@XZ
__unwindfunclet$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z$0:
  00010	8b 4d d0	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1system_error@std@@UAE@XZ
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
__ehhandler$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z:
  0001d	90		 npad	 1
  0001e	90		 npad	 1
  0001f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00023	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00026	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00033	33 c8		 xor	 ecx, eax
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
  0003f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ENDP	; std::ios_base::failure::failure
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -96						; size = 52
$T3 = -44						; size = 16
__Lock$4 = -28						; size = 4
__Psave$1$ = -24					; size = 4
$T5 = -24						; size = 4
__Lock$6 = -20						; size = 4
$T7 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Psave_guard$8 = 8					; size = 4
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT

; 428  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	33 c0		 xor	 eax, eax

; 429  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

  00029	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  0002c	50		 push	 eax
  0002d	89 45 f0	 mov	 DWORD PTR $T7[ebp], eax
  00030	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 105  :             if (_Id == 0) { // still zero, allocate stamp

  0003c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id

; 430  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
  00047	89 45 e8	 mov	 DWORD PTR __Psave$1$[ebp], eax

; 105  :             if (_Id == 0) { // still zero, allocate stamp

  0004a	85 ff		 test	 edi, edi
  0004c	75 37		 jne	 SHORT $LN11@use_facet

; 106  :                 _BEGIN_LOCK(_LOCK_LOCALE)

  0004e	57		 push	 edi
  0004f	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$6[ebp]
  00052	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00057	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 107  :                 if (_Id == 0) {

  0005b	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, edi ; std::ctype<char>::id
  00061	75 10		 jne	 SHORT $LN12@use_facet

; 108  :                     _Id = static_cast<size_t>(++_Id_cnt);

  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00068	40		 inc	 eax
  00069	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  0006e	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, eax ; std::ctype<char>::id
$LN12@use_facet:

; 109  :                 }
; 110  :                 _END_LOCK()

  00073	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00077	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$6[ebp]
  0007a	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0007f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
$LN11@use_facet:

; 374  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  00085	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00088	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0008b	3b 79 0c	 cmp	 edi, DWORD PTR [ecx+12]
  0008e	73 10		 jae	 SHORT $LN20@use_facet
  00090	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00093	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]

; 375  :         if (_Facptr || !_Ptr->_Xparent) {

  00096	85 f6		 test	 esi, esi
  00098	0f 85 0a 01 00
	00		 jne	 $LN67@use_facet
  0009e	eb 02		 jmp	 SHORT $LN70@use_facet
$LN20@use_facet:

; 371  :     }
; 372  : 
; 373  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object
; 374  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  000a0	33 f6		 xor	 esi, esi
$LN70@use_facet:

; 375  :         if (_Facptr || !_Ptr->_Xparent) {

  000a2	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  000a6	74 10		 je	 SHORT $LN15@use_facet

; 376  :             return _Facptr; // found facet or not transparent
; 377  :         }
; 378  : 
; 379  :         // look in current locale
; 380  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

  000a8	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 381  :         if (_Id < _Ptr0->_Facetcount) {

  000ad	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  000b0	73 0e		 jae	 SHORT $LN71@use_facet

; 382  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

  000b2	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000b5	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
$LN15@use_facet:

; 431  : 
; 432  :     const size_t _Id         = _Facet::id;
; 433  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);
; 434  : 
; 435  :     if (!_Pf) {

  000b8	85 f6		 test	 esi, esi
  000ba	0f 85 e8 00 00
	00		 jne	 $LN67@use_facet
$LN71@use_facet:

; 436  :         if (_Psave) {

  000c0	8b 45 e8	 mov	 eax, DWORD PTR __Psave$1$[ebp]
  000c3	85 c0		 test	 eax, eax
  000c5	74 07		 je	 SHORT $LN3@use_facet

; 437  :             _Pf = _Psave; // lazy facet already allocated

  000c7	8b f0		 mov	 esi, eax

; 438  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

  000c9	e9 da 00 00 00	 jmp	 $LN67@use_facet
$LN3@use_facet:

; 2731 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

  000ce	6a 18		 push	 24			; 00000018H
  000d0	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000d5	8b f0		 mov	 esi, eax
  000d7	83 c4 04	 add	 esp, 4
  000da	89 75 e8	 mov	 DWORD PTR $T5[ebp], esi
  000dd	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000e1	85 f6		 test	 esi, esi
  000e3	74 7d		 je	 SHORT $LN25@use_facet

; 370  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  000e5	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  000e8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000eb	85 c9		 test	 ecx, ecx
  000ed	74 0c		 je	 SHORT $LN33@use_facet
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocinfo

; 109  :         return _Myptr ? _Myptr : &_Nul;

  000ef	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  000f2	85 c0		 test	 eax, eax
  000f4	75 0a		 jne	 SHORT $LN34@use_facet
  000f6	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 370  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  000f9	eb 05		 jmp	 SHORT $LN34@use_facet
$LN33@use_facet:
  000fb	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@@
$LN34@use_facet:

; 2731 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

  00100	50		 push	 eax
  00101	8d 4d a0	 lea	 ecx, DWORD PTR $T2[ebp]
  00104	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00109	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0010d	b8 01 00 00 00	 mov	 eax, 1
  00112	89 45 f0	 mov	 DWORD PTR $T7[ebp], eax
  00115	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@

; 153  :         {}

  0011b	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
  00122	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@

; 111  :             }
; 112  :             return _Id;
; 113  :         }
; 114  : 
; 115  :     private:
; 116  :         size_t _Id; // the identifier stamp
; 117  : 
; 118  :         __PURE_APPDOMAIN_GLOBAL static int _Id_cnt;
; 119  :     };
; 120  : 
; 121  :     class _Locimp;
; 122  : 
; 123  :     // CLASS facet
; 124  :     class _CRTIMP2_PURE_IMPORT facet : public _Facet_base, public _Crt_new_delete {
; 125  :         // base class for all locale facets, performs reference counting
; 126  :     private:
; 127  :         friend struct _Facet_guard;
; 128  : 
; 129  :     public:
; 130  :         static size_t __CLRCALL_OR_CDECL _Getcat(const facet** = nullptr, const locale* = nullptr) {
; 131  :             // get category value, or -1 if no corresponding C category
; 132  :             return static_cast<size_t>(-1);
; 133  :         }
; 134  : 
; 135  :         virtual void __CLR_OR_THIS_CALL _Incref() noexcept override { // increment use count
; 136  :             _MT_INCR(_Myrefs);
; 137  :         }
; 138  : 
; 139  :         virtual _Facet_base* __CLR_OR_THIS_CALL _Decref() noexcept override { // decrement use count
; 140  :             if (_MT_DECR(_Myrefs) == 0) {
; 141  :                 return this;
; 142  :             }
; 143  : 
; 144  :             return nullptr;
; 145  :         }
; 146  : 
; 147  :     private:
; 148  :         _Atomic_counter_t _Myrefs; // the reference count
; 149  : 
; 150  :     protected:
; 151  :         explicit __CLR_OR_THIS_CALL facet(size_t _Initrefs = 0)
; 152  :             : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) // non-atomic initialization

  00128	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2379 :     __CLR_OR_THIS_CALL ctype_base(size_t _Refs = 0) : locale::facet(_Refs) {}

  0012f	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
  00136	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ctype_base@std@@6B@

; 2725 :     __CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {

  0013c	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocinfo

; 199  :         return ::_Getctype();

  00143	8d 45 d4	 lea	 eax, DWORD PTR $T3[ebp]
  00146	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 2725 :     __CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {

  00147	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocinfo

; 199  :         return ::_Getctype();

  0014d	e8 00 00 00 00	 call	 __Getctype
  00152	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 2753 :         _Ctype = _Lobj._Getctype();

  00155	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00158	0f 11 46 08	 movups	 XMMWORD PTR [esi+8], xmm0

; 2727 :     }

  0015c	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 2731 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

  00160	eb 02		 jmp	 SHORT $LN26@use_facet
$LN25@use_facet:
  00162	33 f6		 xor	 esi, esi
$LN26@use_facet:
  00164	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0016b	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  0016e	a8 01		 test	 al, 1
  00170	74 0e		 je	 SHORT $LN30@use_facet
  00172	83 e0 fe	 and	 eax, -2			; fffffffeH
  00175	8d 4d a0	 lea	 ecx, DWORD PTR $T2[ebp]
  00178	89 45 f0	 mov	 DWORD PTR $T7[ebp], eax
  0017b	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN30@use_facet:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1370 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00180	89 75 08	 mov	 DWORD PTR __Psave_guard$8[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 446  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

  00183	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8

; 447  : 
; 448  : #if defined(_M_CEE)
; 449  :             _Facet_Register_m(_Pfmod);
; 450  : #else // defined(_M_CEE)
; 451  :             _Facet_Register(_Pfmod);

  00187	56		 push	 esi
  00188	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register

; 452  : #endif // defined(_M_CEE)
; 453  : 
; 454  :             _Pfmod->_Incref();

  0018d	8b 06		 mov	 eax, DWORD PTR [esi]
  0018f	83 c4 04	 add	 esp, 4
  00192	8b ce		 mov	 ecx, esi
  00194	ff 50 04	 call	 DWORD PTR [eax+4]

; 455  :             _Facetptr<_Facet>::_Psave = _Psave;

  00197	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::ctype<char> >::_Psave
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

  0019d	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Psave_guard$8[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 459  :         }

  001a4	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
$LN67@use_facet:

; 460  :     }
; 461  : 
; 462  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

  001a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001af	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  001b2	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  001b7	8b c6		 mov	 eax, esi

; 463  :     _END_LOCK()
; 464  : } // end of use_facet body

  001b9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001bc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001c3	59		 pop	 ecx
  001c4	5f		 pop	 edi
  001c5	5e		 pop	 esi
  001c6	8b e5		 mov	 esp, ebp
  001c8	5d		 pop	 ebp
  001c9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$2:
  00008	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$6[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$3:
  00010	6a 18		 push	 24			; 00000018H
  00012	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001b	83 c4 08	 add	 esp, 8
  0001e	c3		 ret	 0
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$4:
  0001f	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00022	83 e0 01	 and	 eax, 1
  00025	0f 84 0c 00 00
	00		 je	 $LN29@use_facet
  0002b	83 65 f0 fe	 and	 DWORD PTR $T7[ebp], -2	; fffffffeH
  0002f	8d 4d a0	 lea	 ecx, DWORD PTR $T2[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN29@use_facet:
  00037	c3		 ret	 0
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$7:
  00038	8b 4d e8	 mov	 ecx, DWORD PTR $T5[ebp]
  0003b	e9 00 00 00 00	 jmp	 ??1_Facet_base@std@@UAE@XZ ; std::_Facet_base::~_Facet_base
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$6:
  00040	8b 4d e8	 mov	 ecx, DWORD PTR $T5[ebp]
  00043	e9 00 00 00 00	 jmp	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$5:
  00048	8b 4d e8	 mov	 ecx, DWORD PTR $T5[ebp]
  0004b	e9 00 00 00 00	 jmp	 ??1ctype_base@std@@UAE@XZ ; std::ctype_base::~ctype_base
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$1:
  00050	8d 4d 08	 lea	 ecx, DWORD PTR __Psave_guard$8[ebp]
  00053	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
  00058	cc		 int	 3
  00059	cc		 int	 3
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
  0005d	90		 npad	 1
  0005e	90		 npad	 1
  0005f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00063	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00066	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  00069	33 c8		 xor	 ecx, eax
  0006b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00070	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  00075	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$ctype@D@std@@MAEPAXI@Z PROC			; std::ctype<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$ctype@D@std@@MAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 2748 :     virtual __CLR_OR_THIS_CALL ~ctype() noexcept {

  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2757 :         if (0 < _Ctype._Delfl) {

  00036	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00039	85 c0		 test	 eax, eax
  0003b	7e 0a		 jle	 SHORT $LN20@scalar

; 2758 :             _CSTD free(const_cast<short*>(_Ctype._Table));

  0003d	ff 76 0c	 push	 DWORD PTR [esi+12]
  00040	e8 00 00 00 00	 call	 _free
  00045	eb 0a		 jmp	 SHORT $LN21@scalar
$LN20@scalar:

; 2759 :         } else if (_Ctype._Delfl < 0) {

  00047	79 0b		 jns	 SHORT $LN10@scalar

; 2760 :             delete[] _Ctype._Table;

  00049	ff 76 0c	 push	 DWORD PTR [esi+12]
  0004c	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
$LN21@scalar:

; 2761 :         }
; 2762 : 
; 2763 :         _CSTD free(_Ctype._LocaleName);

  00051	83 c4 04	 add	 esp, 4
$LN10@scalar:
  00054	ff 76 14	 push	 DWORD PTR [esi+20]
  00057	e8 00 00 00 00	 call	 _free
  0005c	83 c4 04	 add	 esp, 4

; 2750 :     }

  0005f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 2381 :     __CLR_OR_THIS_CALL ~ctype_base() noexcept {}

  00066	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ctype_base@std@@6B@
  0006c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 155  :         virtual __CLR_OR_THIS_CALL ~facet() noexcept override {}

  00073	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  00079	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00080	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00084	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0008a	74 0b		 je	 SHORT $LN18@scalar
  0008c	6a 18		 push	 24			; 00000018H
  0008e	56		 push	 esi
  0008f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00094	83 c4 08	 add	 esp, 8
$LN18@scalar:
  00097	8b c6		 mov	 eax, esi
  00099	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a3	59		 pop	 ecx
  000a4	5e		 pop	 esi
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$ctype@D@std@@MAEPAXI@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ctype_base@std@@UAE@XZ ; std::ctype_base::~ctype_base
__unwindfunclet$??_G?$ctype@D@std@@MAEPAXI@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
__unwindfunclet$??_G?$ctype@D@std@@MAEPAXI@Z$2:
  00010	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1_Facet_base@std@@UAE@XZ ; std::_Facet_base::~_Facet_base
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
__ehhandler$??_G?$ctype@D@std@@MAEPAXI@Z:
  0001d	90		 npad	 1
  0001e	90		 npad	 1
  0001f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00023	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00026	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$ctype@D@std@@MAEPAXI@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$ctype@D@std@@MAEPAXI@Z ENDP			; std::ctype<char>::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z PROC		; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2810 :         char* _Dest) const { // narrow elements in [_First, _Last) to chars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2811 :         _Adl_verify_range(_First, _Last);
; 2812 :         _CSTD memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	51		 push	 ecx
  0000c	52		 push	 edx
  0000d	ff 75 14	 push	 DWORD PTR __Dest$[ebp]
  00010	e8 00 00 00 00	 call	 _memcpy

; 2813 :         return _Last;

  00015	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2814 :     }

  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z ENDP		; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
___formal$ = 12						; size = 1
?do_narrow@?$ctype@D@std@@MBEDDD@Z PROC			; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2805 :     virtual _Elem __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char) const { // narrow char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2806 :         return _Ch;

  00003	8a 45 08	 mov	 al, BYTE PTR __Ch$[ebp]

; 2807 :     }

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
?do_narrow@?$ctype@D@std@@MBEDDD@Z ENDP			; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z PROC		; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2799 :         const char* _First, const char* _Last, _Elem* _Dest) const { // widen chars in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2800 :         _Adl_verify_range(_First, _Last);
; 2801 :         _CSTD memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	51		 push	 ecx
  0000c	52		 push	 edx
  0000d	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00010	e8 00 00 00 00	 call	 _memcpy

; 2802 :         return _Last;

  00015	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2803 :     }

  0001b	5d		 pop	 ebp
  0001c	c2 0c 00	 ret	 12			; 0000000cH
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?do_widen@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2794 :     virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const { // widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2795 :         return _Byte;

  00003	8a 45 08	 mov	 al, BYTE PTR __Byte$[ebp]

; 2796 :     }

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?do_widen@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2785 :         const _Elem* _Last) const { // convert [_First, _Last) in place to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2786 :         _Adl_verify_range(_First, _Last);
; 2787 :         for (; _First != _Last; ++_First) {

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 19		 je	 SHORT $LN10@do_toupper
  0000f	53		 push	 ebx
  00010	8d 59 08	 lea	 ebx, DWORD PTR [ecx+8]
$LL4@do_toupper:

; 2788 :             *_First = static_cast<_Elem>(_Toupper(static_cast<unsigned char>(*_First), &_Ctype));

  00013	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00016	53		 push	 ebx
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 __Toupper
  0001d	88 06		 mov	 BYTE PTR [esi], al
  0001f	83 c4 08	 add	 esp, 8
  00022	46		 inc	 esi
  00023	3b f7		 cmp	 esi, edi
  00025	75 ec		 jne	 SHORT $LL4@do_toupper

; 2789 :         }
; 2790 : 
; 2791 :         return _First;

  00027	5b		 pop	 ebx
$LN10@do_toupper:
  00028	5f		 pop	 edi

; 2792 :     }

  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_toupper@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2780 :     virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const { // convert element to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2781 :         return static_cast<_Elem>(_Toupper(static_cast<unsigned char>(_Ch), &_Ctype));

  00003	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00006	50		 push	 eax
  00007	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 __Toupper
  00011	83 c4 08	 add	 esp, 8

; 2782 :     }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?do_toupper@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2771 :         const _Elem* _Last) const { // convert [_First, _Last) in place to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2772 :         _Adl_verify_range(_First, _Last);
; 2773 :         for (; _First != _Last; ++_First) {

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 19		 je	 SHORT $LN10@do_tolower
  0000f	53		 push	 ebx
  00010	8d 59 08	 lea	 ebx, DWORD PTR [ecx+8]
$LL4@do_tolower:

; 2774 :             *_First = static_cast<_Elem>(_Tolower(static_cast<unsigned char>(*_First), &_Ctype));

  00013	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00016	53		 push	 ebx
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 __Tolower
  0001d	88 06		 mov	 BYTE PTR [esi], al
  0001f	83 c4 08	 add	 esp, 8
  00022	46		 inc	 esi
  00023	3b f7		 cmp	 esi, edi
  00025	75 ec		 jne	 SHORT $LL4@do_tolower

; 2775 :         }
; 2776 : 
; 2777 :         return _First;

  00027	5b		 pop	 ebx
$LN10@do_tolower:
  00028	5f		 pop	 edi

; 2778 :     }

  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_tolower@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2766 :     virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const { // convert element to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2767 :         return static_cast<_Elem>(_Tolower(static_cast<unsigned char>(_Ch), &_Ctype));

  00003	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00006	50		 push	 eax
  00007	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 __Tolower
  00011	83 c4 08	 add	 esp, 8

; 2768 :     }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?do_tolower@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$ctype@D@std@@MAE@XZ PROC				; std::ctype<char>::~ctype<char>, COMDAT
; _this$ = ecx

; 2748 :     virtual __CLR_OR_THIS_CALL ~ctype() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$ctype@D@std@@MAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2757 :         if (0 < _Ctype._Delfl) {

  00036	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00039	85 c0		 test	 eax, eax
  0003b	7e 0a		 jle	 SHORT $LN16@ctype

; 2758 :             _CSTD free(const_cast<short*>(_Ctype._Table));

  0003d	ff 76 0c	 push	 DWORD PTR [esi+12]
  00040	e8 00 00 00 00	 call	 _free
  00045	eb 0a		 jmp	 SHORT $LN17@ctype
$LN16@ctype:

; 2759 :         } else if (_Ctype._Delfl < 0) {

  00047	79 0b		 jns	 SHORT $LN7@ctype

; 2760 :             delete[] _Ctype._Table;

  00049	ff 76 0c	 push	 DWORD PTR [esi+12]
  0004c	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
$LN17@ctype:

; 2761 :         }
; 2762 : 
; 2763 :         _CSTD free(_Ctype._LocaleName);

  00051	83 c4 04	 add	 esp, 4
$LN7@ctype:
  00054	ff 76 14	 push	 DWORD PTR [esi+20]
  00057	e8 00 00 00 00	 call	 _free
  0005c	83 c4 04	 add	 esp, 4

; 2749 :         _Tidy();
; 2750 :     }

  0005f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 2381 :     __CLR_OR_THIS_CALL ~ctype_base() noexcept {}

  00066	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ctype_base@std@@6B@
  0006c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 155  :         virtual __CLR_OR_THIS_CALL ~facet() noexcept override {}

  00073	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  00079	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00080	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@

; 2749 :         _Tidy();
; 2750 :     }

  00086	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00089	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00090	59		 pop	 ecx
  00091	5e		 pop	 esi
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$ctype@D@std@@MAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ctype_base@std@@UAE@XZ ; std::ctype_base::~ctype_base
__unwindfunclet$??1?$ctype@D@std@@MAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
__unwindfunclet$??1?$ctype@D@std@@MAE@XZ$2:
  00010	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1_Facet_base@std@@UAE@XZ ; std::_Facet_base::~_Facet_base
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
__ehhandler$??1?$ctype@D@std@@MAE@XZ:
  0001d	90		 npad	 1
  0001e	90		 npad	 1
  0001f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00023	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00026	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$ctype@D@std@@MAE@XZ
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$ctype@D@std@@MAE@XZ ENDP				; std::ctype<char>::~ctype<char>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Gctype_base@std@@UAEPAXI@Z PROC			; std::ctype_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_Gctype_base@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 2381 :     __CLR_OR_THIS_CALL ~ctype_base() noexcept {}

  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ctype_base@std@@6B@
  0002f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 155  :         virtual __CLR_OR_THIS_CALL ~facet() noexcept override {}

  00036	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  0003c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00043	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00047	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0004d	74 0b		 je	 SHORT $LN10@scalar
  0004f	6a 08		 push	 8
  00051	56		 push	 esi
  00052	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00057	83 c4 08	 add	 esp, 8
$LN10@scalar:
  0005a	8b c6		 mov	 eax, esi
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00066	59		 pop	 ecx
  00067	5e		 pop	 esi
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_Gctype_base@std@@UAEPAXI@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
__unwindfunclet$??_Gctype_base@std@@UAEPAXI@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1_Facet_base@std@@UAE@XZ ; std::_Facet_base::~_Facet_base
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??_Gctype_base@std@@UAEPAXI@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_Gctype_base@std@@UAEPAXI@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_Gctype_base@std@@UAEPAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1ctype_base@std@@UAE@XZ PROC				; std::ctype_base::~ctype_base, COMDAT
; _this$ = ecx

; 2381 :     __CLR_OR_THIS_CALL ~ctype_base() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1ctype_base@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ctype_base@std@@6B@
  0002c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 155  :         virtual __CLR_OR_THIS_CALL ~facet() noexcept override {}

  00033	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
  00039	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00040	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@

; 2381 :     __CLR_OR_THIS_CALL ~ctype_base() noexcept {}

  00046	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00049	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00050	59		 pop	 ecx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1ctype_base@std@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
__unwindfunclet$??1ctype_base@std@@UAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1_Facet_base@std@@UAE@XZ ; std::_Facet_base::~_Facet_base
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??1ctype_base@std@@UAE@XZ:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1ctype_base@std@@UAE@XZ
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1ctype_base@std@@UAE@XZ ENDP				; std::ctype_base::~ctype_base
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 351  :         if (_Ptr) {

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	85 c9		 test	 ecx, ecx
  00005	74 11		 je	 SHORT $LN4@locale

; 352  :             delete _Ptr->_Decref();

  00007	8b 01		 mov	 eax, DWORD PTR [ecx]
  00009	ff 50 08	 call	 DWORD PTR [eax+8]
  0000c	85 c0		 test	 eax, eax
  0000e	74 08		 je	 SHORT $LN4@locale
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	6a 01		 push	 1
  00016	ff 12		 call	 DWORD PTR [edx]
$LN4@locale:

; 353  :         }
; 354  :     }

  00018	c3		 ret	 0
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??_Gfacet@locale@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Gfacet@locale@std@@MAEPAXI@Z PROC			; std::locale::facet::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_Gfacet@locale@std@@MAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 155  :         virtual __CLR_OR_THIS_CALL ~facet() noexcept override {}

  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  0002f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00036	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0003a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  00040	74 0b		 je	 SHORT $LN7@scalar
  00042	6a 08		 push	 8
  00044	56		 push	 esi
  00045	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0004a	83 c4 08	 add	 esp, 8
$LN7@scalar:
  0004d	8b c6		 mov	 eax, esi
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00059	59		 pop	 ecx
  0005a	5e		 pop	 esi
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_Gfacet@locale@std@@MAEPAXI@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Facet_base@std@@UAE@XZ ; std::_Facet_base::~_Facet_base
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??_Gfacet@locale@std@@MAEPAXI@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_Gfacet@locale@std@@MAEPAXI@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_Gfacet@locale@std@@MAEPAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??1facet@locale@std@@MAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1facet@locale@std@@MAE@XZ PROC			; std::locale::facet::~facet, COMDAT
; _this$ = ecx

; 155  :         virtual __CLR_OR_THIS_CALL ~facet() noexcept override {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1facet@locale@std@@MAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
  0002c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00033	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
  00039	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00043	59		 pop	 ecx
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1facet@locale@std@@MAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Facet_base@std@@UAE@XZ ; std::_Facet_base::~_Facet_base
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??1facet@locale@std@@MAE@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1facet@locale@std@@MAE@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1facet@locale@std@@MAE@XZ ENDP			; std::locale::facet::~facet
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
_TEXT	SEGMENT
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ PROC	; std::locale::facet::_Decref, COMDAT
; _this$ = ecx

; 140  :             if (_MT_DECR(_Myrefs) == 0) {

  00000	83 c8 ff	 or	 eax, -1
  00003	f0 0f c1 41 04	 lock	  xadd	 DWORD PTR [ecx+4], eax
  00008	b8 00 00 00 00	 mov	 eax, 0
  0000d	0f 44 c1	 cmove	 eax, ecx

; 141  :                 return this;
; 142  :             }
; 143  : 
; 144  :             return nullptr;
; 145  :         }

  00010	c3		 ret	 0
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ENDP	; std::locale::facet::_Decref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ?_Incref@facet@locale@std@@UAEXXZ
_TEXT	SEGMENT
?_Incref@facet@locale@std@@UAEXXZ PROC			; std::locale::facet::_Incref, COMDAT
; _this$ = ecx

; 136  :             _MT_INCR(_Myrefs);

  00000	f0 ff 41 04	 lock	  inc	 DWORD PTR [ecx+4]

; 137  :         }

  00004	c3		 ret	 0
?_Incref@facet@locale@std@@UAEXXZ ENDP			; std::locale::facet::_Incref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocinfo
;	COMDAT ??1?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 100  :     __CLR_OR_THIS_CALL ~_Yarn() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Yarn@_W@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 122  :         if (_Myptr) {

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	85 c0		 test	 eax, eax
  00029	74 09		 je	 SHORT $LN6@Yarn

; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);

  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _free
  00031	83 c4 04	 add	 esp, 4
$LN6@Yarn:

; 101  :         _Tidy();
; 102  :     }

  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0003a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00044	59		 pop	 ecx
  00045	5e		 pop	 esi
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
  0004a	cc		 int	 3
  0004b	cc		 int	 3
  0004c	cc		 int	 3
  0004d	cc		 int	 3
  0004e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Yarn@_W@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Yarn@_W@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocinfo
;	COMDAT ??1?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::~_Yarn<char>, COMDAT
; _this$ = ecx

; 100  :     __CLR_OR_THIS_CALL ~_Yarn() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Yarn@D@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 122  :         if (_Myptr) {

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	85 c0		 test	 eax, eax
  00029	74 09		 je	 SHORT $LN6@Yarn

; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);

  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _free
  00031	83 c4 04	 add	 esp, 4
$LN6@Yarn:

; 101  :         _Tidy();
; 102  :     }

  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0003a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00044	59		 pop	 ecx
  00045	5e		 pop	 esi
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
  0004a	cc		 int	 3
  0004b	cc		 int	 3
  0004c	cc		 int	 3
  0004d	cc		 int	 3
  0004e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Yarn@D@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Yarn@D@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::~_Yarn<char>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocinfo
;	COMDAT ??1_Locinfo@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Locinfo@std@@QAE@XZ PROC				; std::_Locinfo::~_Locinfo, COMDAT
; _this$ = ecx

; 178  :     __CLR_OR_THIS_CALL ~_Locinfo() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Locinfo@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 6

; 179  :         _Locinfo_dtor(this);

  00030	56		 push	 esi
  00031	e8 00 00 00 00	 call	 ?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z ; std::_Locinfo::_Locinfo_dtor
  00036	83 c4 04	 add	 esp, 4

; 180  :     }

  00039	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5

; 122  :         if (_Myptr) {

  0003d	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00040	85 c0		 test	 eax, eax
  00042	74 09		 je	 SHORT $LN13@Locinfo

; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);

  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _free
  0004a	83 c4 04	 add	 esp, 4
$LN13@Locinfo:

; 127  : #endif // _DEBUG
; 128  :         }
; 129  : 
; 130  :         _Myptr = nullptr;

  0004d	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0

; 180  :     }

  00054	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4

; 122  :         if (_Myptr) {

  00058	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0005b	85 c0		 test	 eax, eax
  0005d	74 09		 je	 SHORT $LN18@Locinfo

; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);

  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 _free
  00065	83 c4 04	 add	 esp, 4
$LN18@Locinfo:

; 127  : #endif // _DEBUG
; 128  :         }
; 129  : 
; 130  :         _Myptr = nullptr;

  00068	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0

; 180  :     }

  0006f	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 122  :         if (_Myptr) {

  00073	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00076	85 c0		 test	 eax, eax
  00078	74 09		 je	 SHORT $LN23@Locinfo

; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);

  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _free
  00080	83 c4 04	 add	 esp, 4
$LN23@Locinfo:

; 127  : #endif // _DEBUG
; 128  :         }
; 129  : 
; 130  :         _Myptr = nullptr;

  00083	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 180  :     }

  0008a	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 122  :         if (_Myptr) {

  0008e	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00091	85 c0		 test	 eax, eax
  00093	74 09		 je	 SHORT $LN28@Locinfo

; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);

  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 _free
  0009b	83 c4 04	 add	 esp, 4
$LN28@Locinfo:

; 127  : #endif // _DEBUG
; 128  :         }
; 129  : 
; 130  :         _Myptr = nullptr;

  0009e	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 180  :     }

  000a5	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 122  :         if (_Myptr) {

  000a9	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  000ac	85 c0		 test	 eax, eax
  000ae	74 09		 je	 SHORT $LN33@Locinfo

; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);

  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 _free
  000b6	83 c4 04	 add	 esp, 4
$LN33@Locinfo:

; 127  : #endif // _DEBUG
; 128  :         }
; 129  : 
; 130  :         _Myptr = nullptr;

  000b9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 180  :     }

  000c0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0

; 122  :         if (_Myptr) {

  000c4	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000c7	85 c0		 test	 eax, eax
  000c9	74 09		 je	 SHORT $LN38@Locinfo

; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);

  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 _free
  000d1	83 c4 04	 add	 esp, 4
$LN38@Locinfo:

; 127  : #endif // _DEBUG
; 128  :         }
; 129  : 
; 130  :         _Myptr = nullptr;

  000d4	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 180  :     }

  000db	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000e2	8b ce		 mov	 ecx, esi
  000e4	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  000e9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ec	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f3	59		 pop	 ecx
  000f4	5e		 pop	 esi
  000f5	8b e5		 mov	 esp, ebp
  000f7	5d		 pop	 ebp
  000f8	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00019	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 14	 add	 ecx, 20			; 00000014H
  00024	e9 00 00 00 00	 jmp	 ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$4:
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0002f	e9 00 00 00 00	 jmp	 ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$5:
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 24	 add	 ecx, 36			; 00000024H
  0003a	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$6:
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00045	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
  0004a	cc		 int	 3
  0004b	cc		 int	 3
  0004c	cc		 int	 3
  0004d	cc		 int	 3
  0004e	cc		 int	 3
__ehhandler$??1_Locinfo@std@@QAE@XZ:
  0004f	90		 npad	 1
  00050	90		 npad	 1
  00051	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00055	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00058	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0005b	33 c8		 xor	 ecx, eax
  0005d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00062	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Locinfo@std@@QAE@XZ
  00067	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Locinfo@std@@QAE@XZ ENDP				; std::_Locinfo::~_Locinfo
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocinfo
;	COMDAT ??0_Locinfo@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Pch$ = 8						; size = 4
??0_Locinfo@std@@QAE@PBD@Z PROC				; std::_Locinfo::_Locinfo, COMDAT
; _this$ = ecx

; 155  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0_Locinfo@std@@QAE@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 60   : 
; 61   :     __CLR_OR_THIS_CALL _Yarn(const _Yarn& _Right) noexcept : _Myptr(nullptr), _Nul(0) {
; 62   :         *this = _Right;
; 63   :     }
; 64   : 
; 65   :     __CLR_OR_THIS_CALL _Yarn(const _Elem* _Right) noexcept : _Myptr(nullptr), _Nul(0) {
; 66   :         *this = _Right;
; 67   :     }
; 68   : 
; 69   :     _Yarn& __CLR_OR_THIS_CALL operator=(const _Yarn& _Right) noexcept {
; 70   :         return *this = _Right._Myptr;
; 71   :     }
; 72   : 
; 73   :     _Yarn& __CLR_OR_THIS_CALL operator=(const _Elem* _Right) noexcept {
; 74   :         if (_Myptr != _Right) { // new value, discard old and copy new
; 75   :             _Tidy();
; 76   : 
; 77   :             if (_Right) { // new is not empty, copy it
; 78   :                 const _Elem* _Ptr = _Right;
; 79   :                 while (*_Ptr != _Elem{}) {
; 80   :                     ++_Ptr;
; 81   :                 }
; 82   : 
; 83   :                 const auto _Count = (++_Ptr - _Right) * sizeof(_Elem);
; 84   : 
; 85   : #ifdef _DEBUG
; 86   :                 _Myptr = static_cast<_Elem*>(_malloc_dbg(_Count, _CRT_BLOCK, __FILE__, __LINE__));
; 87   : #else // _DEBUG
; 88   :                 _Myptr = static_cast<_Elem*>(_CSTD malloc(_Count));
; 89   : #endif // _DEBUG
; 90   : 
; 91   :                 if (_Myptr) {
; 92   :                     _CSTD memcpy(_Myptr, _Right, _Count);
; 93   :                 }
; 94   :             }
; 95   :         }
; 96   : 
; 97   :         return *this;
; 98   :     }
; 99   : 
; 100  :     __CLR_OR_THIS_CALL ~_Yarn() noexcept {
; 101  :         _Tidy();
; 102  :     }
; 103  : 
; 104  :     _NODISCARD bool __CLR_OR_THIS_CALL empty() const noexcept {
; 105  :         return _Myptr == nullptr;
; 106  :     }
; 107  : 
; 108  :     _Ret_z_ const _Elem* __CLR_OR_THIS_CALL c_str() const noexcept {
; 109  :         return _Myptr ? _Myptr : &_Nul;
; 110  :     }
; 111  : 
; 112  :     _NODISCARD bool __CLR_OR_THIS_CALL _Empty() const noexcept {
; 113  :         return _Myptr == nullptr;
; 114  :     }
; 115  : 
; 116  :     _Ret_z_ const _Elem* __CLR_OR_THIS_CALL _C_str() const noexcept {
; 117  :         return _Myptr ? _Myptr : &_Nul;
; 118  :     }
; 119  : 
; 120  : private:
; 121  :     void __CLR_OR_THIS_CALL _Tidy() noexcept {
; 122  :         if (_Myptr) {
; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);
; 127  : #endif // _DEBUG
; 128  :         }
; 129  : 
; 130  :         _Myptr = nullptr;
; 131  :     }
; 132  : 
; 133  :     _Elem* _Myptr; // pointer to allocated string
; 134  :     _Elem _Nul; // nul terminator for unallocated string
; 135  : };
; 136  : 
; 137  : // CLASS _Locinfo
; 138  : class _CRTIMP2_PURE_IMPORT _Locinfo { // summary of all stuff specific to a locale used by standard facets
; 139  : public:
; 140  :     using _Collvec  = ::_Collvec;
; 141  :     using _Ctypevec = ::_Ctypevec;
; 142  :     using _Cvtvec   = ::_Cvtvec;
; 143  :     using _Timevec  = _STD _Timevec;
; 144  : 
; 145  :     static void __CLRCALL_PURE_OR_CDECL _Locinfo_ctor(_Locinfo*, const char*);
; 146  :     static void __CLRCALL_PURE_OR_CDECL _Locinfo_ctor(_Locinfo*, int, const char*);
; 147  :     static void __CLRCALL_PURE_OR_CDECL _Locinfo_dtor(_Locinfo*);
; 148  :     static _Locinfo& __CLRCALL_PURE_OR_CDECL _Locinfo_Addcats(_Locinfo*, int, const char*);
; 149  : 
; 150  :     __CLR_OR_THIS_CALL _Locinfo(const char* _Pch = "C")
; 151  : #ifndef _M_CEE
; 152  :         : _Lock(_LOCK_LOCALE)

  00029	6a 00		 push	 0
  0002b	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 59   :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

  00037	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0003e	c6 46 08 00	 mov	 BYTE PTR [esi+8], 0

; 155  :     {

  00042	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 59   :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

  00046	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  0004d	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0

; 155  :     {

  00051	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 59   :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

  00055	33 c0		 xor	 eax, eax
  00057	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0005e	66 89 46 18	 mov	 WORD PTR [esi+24], ax

; 155  :     {

  00062	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 59   :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

  00066	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  00069	66 89 46 20	 mov	 WORD PTR [esi+32], ax

; 155  :     {

  0006d	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4

; 59   :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

  00071	89 46 24	 mov	 DWORD PTR [esi+36], eax
  00074	88 46 28	 mov	 BYTE PTR [esi+40], al

; 155  :     {

  00077	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5

; 59   :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

  0007b	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  0007e	88 46 30	 mov	 BYTE PTR [esi+48], al

; 155  :     {

  00081	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6

; 156  :         if (_Pch) {

  00085	8b 45 08	 mov	 eax, DWORD PTR __Pch$[ebp]
  00088	85 c0		 test	 eax, eax
  0008a	74 25		 je	 SHORT $LN2@Locinfo

; 157  :             _Locinfo_ctor(this, _Pch);

  0008c	50		 push	 eax
  0008d	56		 push	 esi
  0008e	e8 00 00 00 00	 call	 ?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z ; std::_Locinfo::_Locinfo_ctor
  00093	83 c4 08	 add	 esp, 8

; 162  :     }

  00096	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0009d	8b c6		 mov	 eax, esi
  0009f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a9	59		 pop	 ecx
  000aa	5e		 pop	 esi
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c2 04 00	 ret	 4
$LN2@Locinfo:

; 158  :             return;
; 159  :         }
; 160  : 
; 161  :         _Xruntime_error("bad locale name");

  000b1	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@ELKIONDK@bad?5locale?5name@
  000b6	e8 00 00 00 00	 call	 ?_Xruntime_error@std@@YAXPBD@Z ; std::_Xruntime_error
$LN24@Locinfo:
  000bb	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00019	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 14	 add	 ecx, 20			; 00000014H
  00024	e9 00 00 00 00	 jmp	 ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4:
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0002f	e9 00 00 00 00	 jmp	 ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5:
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 24	 add	 ecx, 36			; 00000024H
  0003a	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6:
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00045	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
  0004a	cc		 int	 3
  0004b	cc		 int	 3
  0004c	cc		 int	 3
  0004d	cc		 int	 3
  0004e	cc		 int	 3
__ehhandler$??0_Locinfo@std@@QAE@PBD@Z:
  0004f	90		 npad	 1
  00050	90		 npad	 1
  00051	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00055	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00058	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0005b	33 c8		 xor	 ecx, eax
  0005d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00062	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z
  00067	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0_Locinfo@std@@QAE@PBD@Z ENDP				; std::_Locinfo::_Locinfo
; Function compile flags: /Ogtp
;	COMDAT ??_G_Facet_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Facet_base@std@@UAEPAXI@Z PROC			; std::_Facet_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  00010	74 0b		 je	 SHORT $LN4@scalar
  00012	6a 04		 push	 4
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_G_Facet_base@std@@UAEPAXI@Z ENDP			; std::_Facet_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xfacet
;	COMDAT ??1_Facet_base@std@@UAE@XZ
_TEXT	SEGMENT
??1_Facet_base@std@@UAE@XZ PROC				; std::_Facet_base::~_Facet_base, COMDAT
; _this$ = ecx

; 28   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept {} // ensure that derived classes can be destroyed properly

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
  00006	c3		 ret	 0
??1_Facet_base@std@@UAE@XZ ENDP				; std::_Facet_base::~_Facet_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error
;	COMDAT ??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ
_TEXT	SEGMENT
??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ PROC ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>, COMDAT

; 640  :     static _Constexpr_immortalize_impl<_Ty> _Static;
; 641  :     return _Static._Storage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A ; `std::_Immortalize_memcpy_image<std::_Iostream_error_category2>'::`2'::_Static

; 642  : }

  00005	c3		 ret	 0
??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ ENDP ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G_Iostream_error_category2@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Iostream_error_category2@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category2::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	74 0b		 je	 SHORT $LN4@scalar
  0000c	6a 08		 push	 8
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00014	83 c4 08	 add	 esp, 8
$LN4@scalar:
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??_G_Iostream_error_category2@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category2::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error
;	COMDAT ?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category2::message, COMDAT
; _this$ = ecx

; 532  :     _NODISCARD virtual string message(int _Errcode) const override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 533  :         if (_Errcode == static_cast<int>(io_errc::stream)) {

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp]
  00028	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  0002f	83 f8 01	 cmp	 eax, 1
  00032	75 2a		 jne	 SHORT $LN2@message
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00034	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]

; 2503 :         assign(_Ptr, _Count);

  00037	8b ce		 mov	 ecx, esi
  00039	6a 15		 push	 21			; 00000015H
  0003b	68 00 00 00 00	 push	 OFFSET ?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB ; `std::_Iostream_error_category2::message'::`5'::_Iostream_error

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00040	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 4596 :         _My_data._Mysize = 0;

  00046	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0004d	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00054	c6 06 00	 mov	 BYTE PTR [esi], 0

; 2503 :         assign(_Ptr, _Count);

  00057	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error

; 536  :             return string(_Iostream_error, _Iostream_error_length);

  0005c	eb 3c		 jmp	 SHORT $LN33@message
$LN2@message:

; 538  :             return _Syserror_map(_Errcode);

  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00064	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error

; 538  :             return _Syserror_map(_Errcode);

  00067	8b d0		 mov	 edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00069	8b ca		 mov	 ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error

; 538  :             return _Syserror_map(_Errcode);

  0006b	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0006e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 4596 :         _My_data._Mysize = 0;

  00074	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0007b	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0007e	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00085	c6 06 00	 mov	 BYTE PTR [esi], 0
$LL31@message:

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00088	8a 01		 mov	 al, BYTE PTR [ecx]
  0008a	41		 inc	 ecx
  0008b	84 c0		 test	 al, al
  0008d	75 f9		 jne	 SHORT $LL31@message
  0008f	2b cf		 sub	 ecx, edi

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00091	51		 push	 ecx
  00092	52		 push	 edx
  00093	8b ce		 mov	 ecx, esi
  00095	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN33@message:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error

; 540  :     }

  0009a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000a1	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  000a8	8b c6		 mov	 eax, esi
  000aa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ad	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b4	59		 pop	 ecx
  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN6@message
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN6@message:
  00018	c3		 ret	 0
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
__ehhandler$?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z:
  0001e	90		 npad	 1
  0001f	90		 npad	 1
  00020	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00024	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00027	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category2::message
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error
;	COMDAT ?name@_Iostream_error_category2@std@@UBEPBDXZ
_TEXT	SEGMENT
?name@_Iostream_error_category2@std@@UBEPBDXZ PROC	; std::_Iostream_error_category2::name, COMDAT
; _this$ = ecx

; 529  :         return "iostream";

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08LLGCOLLL@iostream@

; 530  :     }

  00005	c3		 ret	 0
?name@_Iostream_error_category2@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category2::name
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gsystem_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Gsystem_error@std@@UAEPAXI@Z PROC			; std::system_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_Gsystem_error@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 90   :         __std_exception_destroy(&_Data);

  00030	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00033	50		 push	 eax
  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0003a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0003f	83 c4 04	 add	 esp, 4
  00042	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00046	74 0b		 je	 SHORT $LN15@scalar
  00048	6a 14		 push	 20			; 00000014H
  0004a	56		 push	 esi
  0004b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00050	83 c4 08	 add	 esp, 8
$LN15@scalar:
  00053	8b c6		 mov	 eax, esi
  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	5e		 pop	 esi
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_Gsystem_error@std@@UAEPAXI@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_System_error@std@@UAE@XZ
__unwindfunclet$??_Gsystem_error@std@@UAEPAXI@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1runtime_error@std@@UAE@XZ
__unwindfunclet$??_Gsystem_error@std@@UAEPAXI@Z$2:
  00010	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
__ehhandler$??_Gsystem_error@std@@UAEPAXI@Z:
  0001d	90		 npad	 1
  0001e	90		 npad	 1
  0001f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00023	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00026	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_Gsystem_error@std@@UAEPAXI@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_Gsystem_error@std@@UAEPAXI@Z ENDP			; std::system_error::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0system_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0system_error@std@@QAE@ABV01@@Z PROC			; std::system_error::system_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0system_error@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0002a	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  0002d	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00030	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :     {

  00033	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7exception@std@@6B@

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  00039	50		 push	 eax
  0003a	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0003e	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ___std_exception_copy
  00047	83 c4 08	 add	 esp, 8
  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00051	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7runtime_error@std@@6B@
  00057	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0005e	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
  00064	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00067	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0006a	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  0006d	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  00070	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00077	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7system_error@std@@6B@
  0007d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00084	8b c7		 mov	 eax, edi
  00086	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00089	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00090	59		 pop	 ecx
  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0system_error@std@@QAE@ABV01@@Z$2:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
__unwindfunclet$??0system_error@std@@QAE@ABV01@@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1runtime_error@std@@UAE@XZ
__unwindfunclet$??0system_error@std@@QAE@ABV01@@Z$0:
  00010	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1_System_error@std@@UAE@XZ
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
__ehhandler$??0system_error@std@@QAE@ABV01@@Z:
  0001d	90		 npad	 1
  0001e	90		 npad	 1
  0001f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00023	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00026	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0system_error@std@@QAE@ABV01@@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0system_error@std@@QAE@ABV01@@Z ENDP			; std::system_error::system_error
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1system_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1system_error@std@@UAE@XZ PROC			; std::system_error::~system_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1system_error@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 90   :         __std_exception_destroy(&_Data);

  0002d	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00030	50		 push	 eax
  00031	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00037	e8 00 00 00 00	 call	 ___std_exception_destroy
  0003c	83 c4 04	 add	 esp, 4
  0003f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00042	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00049	59		 pop	 ecx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1system_error@std@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_System_error@std@@UAE@XZ
__unwindfunclet$??1system_error@std@@UAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1runtime_error@std@@UAE@XZ
__unwindfunclet$??1system_error@std@@UAE@XZ$2:
  00010	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
__ehhandler$??1system_error@std@@UAE@XZ:
  0001d	90		 npad	 1
  0001e	90		 npad	 1
  0001f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00023	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00026	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1system_error@std@@UAE@XZ
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1system_error@std@@UAE@XZ ENDP			; std::system_error::~system_error
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_G_System_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G_System_error@std@@UAEPAXI@Z PROC			; std::_System_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G_System_error@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 90   :         __std_exception_destroy(&_Data);

  00030	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00033	50		 push	 eax
  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0003a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0003f	83 c4 04	 add	 esp, 4
  00042	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00046	74 0b		 je	 SHORT $LN12@scalar
  00048	6a 14		 push	 20			; 00000014H
  0004a	56		 push	 esi
  0004b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00050	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00053	8b c6		 mov	 eax, esi
  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	5e		 pop	 esi
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G_System_error@std@@UAEPAXI@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1runtime_error@std@@UAE@XZ
__unwindfunclet$??_G_System_error@std@@UAEPAXI@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??_G_System_error@std@@UAEPAXI@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G_System_error@std@@UAEPAXI@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G_System_error@std@@UAEPAXI@Z ENDP			; std::_System_error::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0_System_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0_System_error@std@@QAE@ABV01@@Z PROC			; std::_System_error::_System_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0_System_error@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0002a	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  0002d	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00030	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :     {

  00033	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7exception@std@@6B@

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  00039	50		 push	 eax
  0003a	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0003e	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ___std_exception_copy
  00047	83 c4 08	 add	 esp, 8
  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00051	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7runtime_error@std@@6B@
  00057	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0005e	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
  00064	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00067	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0006a	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  0006d	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  00070	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00077	8b c7		 mov	 eax, edi
  00079	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00083	59		 pop	 ecx
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_System_error@std@@QAE@ABV01@@Z$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
__unwindfunclet$??0_System_error@std@@QAE@ABV01@@Z$0:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1runtime_error@std@@UAE@XZ
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??0_System_error@std@@QAE@ABV01@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0_System_error@std@@QAE@ABV01@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0_System_error@std@@QAE@ABV01@@Z ENDP			; std::_System_error::_System_error
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1_System_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_System_error@std@@UAE@XZ PROC			; std::_System_error::~_System_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_System_error@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 90   :         __std_exception_destroy(&_Data);

  0002d	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00030	50		 push	 eax
  00031	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00037	e8 00 00 00 00	 call	 ___std_exception_destroy
  0003c	83 c4 04	 add	 esp, 4
  0003f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00042	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00049	59		 pop	 ecx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1_System_error@std@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1runtime_error@std@@UAE@XZ
__unwindfunclet$??1_System_error@std@@UAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??1_System_error@std@@UAE@XZ:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_System_error@std@@UAE@XZ
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_System_error@std@@UAE@XZ ENDP			; std::_System_error::~_System_error
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\stdexcept
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error
;	COMDAT ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$GSCopy$ = -108					; size = 4
$T2 = -104						; size = 24
__InitData$3 = -80					; size = 8
__Errcode$2$ = -76					; size = 4
__Result$1$ = -76					; size = 4
$T4 = -72						; size = 4
__Errcode$1$ = -68					; size = 4
__Right_size$1$ = -68					; size = 4
_this$ = -68						; size = 4
$T5 = -64						; size = 24
$T6 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_System_error::_System_error, COMDAT
; _this$ = ecx

; 452  :     _System_error(error_code _Errcode, const string& _Message)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 60	 sub	 esp, 96			; 00000060H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b f9		 mov	 edi, ecx
  0002c	89 7d bc	 mov	 DWORD PTR _this$[ebp], edi
  0002f	8b 45 10	 mov	 eax, DWORD PTR __Message$[ebp]
  00032	89 7d 94	 mov	 DWORD PTR _this$GSCopy$[ebp], edi
  00035	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], 0
  0003c	89 45 b4	 mov	 DWORD PTR __Result$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  0003f	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2921 :         const size_type _Right_size   = _Right_data._Mysize;

  00043	8b 70 10	 mov	 esi, DWORD PTR [eax+16]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00046	c7 45 98 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 2355 :     size_type _Mysize = 0; // current length of string

  0004d	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0

; 2356 :     size_type _Myres  = 0; // current storage reserved for string

  00054	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 0

; 2921 :         const size_type _Right_size   = _Right_data._Mysize;

  0005b	89 75 bc	 mov	 DWORD PTR __Right_size$1$[ebp], esi

; 2306 :         if (_Large_string_engaged()) {

  0005e	72 05		 jb	 SHORT $LN18@System_err

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  00060	8b 00		 mov	 eax, DWORD PTR [eax]
  00062	89 45 b4	 mov	 DWORD PTR __Result$1$[ebp], eax
$LN18@System_err:

; 2933 :         if (_Stay_small) { // stay small, don't allocate

  00065	83 fe 10	 cmp	 esi, 16			; 00000010H
  00068	73 13		 jae	 SHORT $LN15@System_err

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0006a	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]

; 2935 :             _My_data._Mysize = _Right_size;

  0006d	89 75 a8	 mov	 DWORD PTR $T2[ebp+16], esi

; 2936 :             _My_data._Myres  = _BUF_SIZE - 1;

  00070	c7 45 ac 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00077	0f 11 45 98	 movups	 XMMWORD PTR $T2[ebp], xmm0

; 2937 :             return;

  0007b	eb 56		 jmp	 SHORT $LN14@System_err
$LN15@System_err:

; 2938 :         }
; 2939 : 
; 2940 :         auto& _Al                     = _Getal();
; 2941 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  0007d	83 ce 0f	 or	 esi, 15			; 0000000fH
  00080	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00085	3b f0		 cmp	 esi, eax
  00087	0f 47 f0	 cmova	 esi, eax

; 2942 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  0008a	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0008d	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00092	72 0d		 jb	 SHORT $LN29@System_err

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0009a	83 c4 04	 add	 esp, 4
  0009d	8b c8		 mov	 ecx, eax
  0009f	eb 13		 jmp	 SHORT $LN28@System_err
$LN29@System_err:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  000a1	85 c0		 test	 eax, eax
  000a3	74 0d		 je	 SHORT $LN30@System_err

; 85   :         return ::operator new(_Bytes);

  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ab	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000ae	8b c8		 mov	 ecx, eax
  000b0	eb 02		 jmp	 SHORT $LN28@System_err
$LN30@System_err:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000b2	33 c9		 xor	 ecx, ecx
$LN28@System_err:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2950 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  000b4	8b 45 bc	 mov	 eax, DWORD PTR __Right_size$1$[ebp]
  000b7	40		 inc	 eax
  000b8	89 4d 98	 mov	 DWORD PTR $T2[ebp], ecx

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000bb	50		 push	 eax
  000bc	ff 75 b4	 push	 DWORD PTR __Result$1$[ebp]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 _memcpy

; 2951 :         _My_data._Mysize = _Right_size;

  000c5	8b 45 bc	 mov	 eax, DWORD PTR __Right_size$1$[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2952 :         _My_data._Myres  = _New_capacity;

  000cb	89 75 ac	 mov	 DWORD PTR $T2[ebp+20], esi
  000ce	8b f0		 mov	 esi, eax

; 2951 :         _My_data._Mysize = _Right_size;

  000d0	89 45 a8	 mov	 DWORD PTR $T2[ebp+16], eax
$LN14@System_err:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error

; 453  :         : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode) {}

  000d3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000da	8b 45 08	 mov	 eax, DWORD PTR __Errcode$[ebp]
  000dd	8b 4d 0c	 mov	 ecx, DWORD PTR __Errcode$[ebp+4]
  000e0	89 45 bc	 mov	 DWORD PTR __Errcode$1$[ebp], eax
  000e3	89 4d b4	 mov	 DWORD PTR __Errcode$2$[ebp], ecx

; 442  :     static string _Makestr(error_code _Errcode, string _Message) { // compose error message

  000e6	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  000ed	85 f6		 test	 esi, esi

; 443  :         if (!_Message.empty()) {

  000ef	74 12		 je	 SHORT $LN37@System_err
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3175 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000f1	6a 02		 push	 2
  000f3	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5@
  000f8	8d 4d 98	 lea	 ecx, DWORD PTR $T2[ebp]
  000fb	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00100	8b 4d b4	 mov	 ecx, DWORD PTR __Errcode$2$[ebp]
$LN37@System_err:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error

; 447  :         _Message.append(_Errcode.message());

  00103	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 173  :         return category().message(value());

  00107	8d 55 c0	 lea	 edx, DWORD PTR $T5[ebp]
  0010a	ff 75 bc	 push	 DWORD PTR __Errcode$1$[ebp]
  0010d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0010f	52		 push	 edx
  00110	ff 50 08	 call	 DWORD PTR [eax+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00113	83 7d d4 10	 cmp	 DWORD PTR $T5[ebp+20], 16 ; 00000010H

; 2305 :         const value_type* _Result = _Bx._Buf;

  00117	8d 45 c0	 lea	 eax, DWORD PTR $T5[ebp]

; 3124 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0011a	ff 75 d0	 push	 DWORD PTR $T5[ebp+16]

; 2306 :         if (_Large_string_engaged()) {

  0011d	0f 43 45 c0	 cmovae	 eax, DWORD PTR $T5[ebp]

; 3124 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00121	8d 4d 98	 lea	 ecx, DWORD PTR $T2[ebp]
  00124	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error

; 173  :         return category().message(value());

  00125	c7 45 b8 02 00
	00 00		 mov	 DWORD PTR $T4[ebp], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3124 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0012c	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error

; 447  :         _Message.append(_Errcode.message());

  00131	be 02 00 00 00	 mov	 esi, 2
  00136	89 75 b8	 mov	 DWORD PTR $T4[ebp], esi
  00139	83 e6 fd	 and	 esi, -3			; fffffffdH
  0013c	89 75 b8	 mov	 DWORD PTR $T4[ebp], esi
  0013f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3003 :         _Tidy_deallocate();

  00143	8d 4d c0	 lea	 ecx, DWORD PTR $T5[ebp]
  00146	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0014b	0f 10 45 98	 movups	 xmm0, XMMWORD PTR $T2[ebp]

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0014f	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T6[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error

; 448  :         return _Message;

  00156	83 ce 01	 or	 esi, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2355 :     size_type _Mysize = 0; // current length of string

  00159	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T6[ebp+16], 0

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00160	0f 11 45 d8	 movups	 XMMWORD PTR $T6[ebp], xmm0

; 2356 :     size_type _Myres  = 0; // current storage reserved for string

  00164	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T6[ebp+20], 0

; 2869 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0016b	f3 0f 7e 45 a8	 movq	 xmm0, QWORD PTR $T2[ebp+16]
  00170	66 0f d6 45 e8	 movq	 QWORD PTR $T6[ebp+16], xmm0

; 4596 :         _My_data._Mysize = 0;

  00175	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0017c	c7 45 ac 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00183	c6 45 98 00	 mov	 BYTE PTR $T2[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error

; 448  :         return _Message;

  00187	89 75 b8	 mov	 DWORD PTR $T4[ebp], esi
  0018a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h

; 58   :         : _Data()

  0018e	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  00191	83 7d ec 10	 cmp	 DWORD PTR $T6[ebp+20], 16 ; 00000010H

; 2305 :         const value_type* _Result = _Bx._Buf;

  00195	8d 4d d8	 lea	 ecx, DWORD PTR $T6[ebp]
  00198	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h

; 59   :     {

  0019b	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7exception@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2306 :         if (_Large_string_engaged()) {

  001a1	0f 43 4d d8	 cmovae	 ecx, DWORD PTR $T6[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h

; 61   :         __std_exception_copy(&_InitData, &_Data);

  001a5	50		 push	 eax
  001a6	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  001aa	8d 45 b0	 lea	 eax, DWORD PTR __InitData$3[ebp]
  001ad	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  001ae	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  001b5	c7 45 ac 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  001bc	c6 45 98 00	 mov	 BYTE PTR $T2[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h

; 60   :         __std_exception_data _InitData = { _Message, true };

  001c0	89 4d b0	 mov	 DWORD PTR __InitData$3[ebp], ecx
  001c3	c6 45 b4 01	 mov	 BYTE PTR __InitData$3[ebp+4], 1

; 61   :         __std_exception_copy(&_InitData, &_Data);

  001c7	e8 00 00 00 00	 call	 ___std_exception_copy
  001cc	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\stdexcept

; 111  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) {}

  001cf	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  001d3	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7runtime_error@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error

; 453  :         : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode) {}

  001d9	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  001dd	83 e6 fe	 and	 esi, -2			; fffffffeH
  001e0	89 75 b8	 mov	 DWORD PTR $T4[ebp], esi
  001e3	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  001e7	8b 55 ec	 mov	 edx, DWORD PTR $T6[ebp+20]
  001ea	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  001ed	72 28		 jb	 SHORT $LN146@System_err
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001ef	8b 4d d8	 mov	 ecx, DWORD PTR $T6[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  001f2	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001f3	8b c1		 mov	 eax, ecx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  001f5	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001fb	72 10		 jb	 SHORT $LN145@System_err

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001fd	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00200	83 c2 23	 add	 edx, 35			; 00000023H
  00203	2b c1		 sub	 eax, ecx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00205	83 c0 fc	 add	 eax, -4			; fffffffcH
  00208	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0020b	77 54		 ja	 SHORT $LN153@System_err
$LN145@System_err:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0020d	52		 push	 edx
  0020e	51		 push	 ecx
  0020f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00214	83 c4 08	 add	 esp, 8
$LN146@System_err:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error

; 453  :         : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode) {}

  00217	8b 4d 08	 mov	 ecx, DWORD PTR __Errcode$[ebp]
  0021a	8b 55 0c	 mov	 edx, DWORD PTR __Errcode$[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  0021d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T6[ebp+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00224	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T6[ebp+20], 15 ; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0022b	c6 45 d8 00	 mov	 BYTE PTR $T6[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error

; 453  :         : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode) {}

  0022f	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
  00235	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  00238	89 57 10	 mov	 DWORD PTR [edi+16], edx
  0023b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00242	8b c7		 mov	 eax, edi
  00244	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00247	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0024e	59		 pop	 ecx
  0024f	5f		 pop	 edi
  00250	5e		 pop	 esi
  00251	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00254	33 cd		 xor	 ecx, ebp
  00256	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0025b	8b e5		 mov	 esp, ebp
  0025d	5d		 pop	 ebp
  0025e	c2 0c 00	 ret	 12			; 0000000cH
$LN153@System_err:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00261	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN151@System_err:
  00266	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
  00000	8d 4d 98	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$5:
  00008	8b 45 b8	 mov	 eax, DWORD PTR $T4[ebp]
  0000b	83 e0 01	 and	 eax, 1
  0000e	0f 84 0c 00 00
	00		 je	 $LN42@System_err
  00014	83 65 b8 fe	 and	 DWORD PTR $T4[ebp], -2	; fffffffeH
  00018	8d 4d d8	 lea	 ecx, DWORD PTR $T6[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN42@System_err:
  00020	c3		 ret	 0
__unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$3:
  00021	8d 4d 98	 lea	 ecx, DWORD PTR $T2[ebp]
  00024	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$6:
  00029	8b 45 b8	 mov	 eax, DWORD PTR $T4[ebp]
  0002c	83 e0 02	 and	 eax, 2
  0002f	0f 84 0c 00 00
	00		 je	 $LN52@System_err
  00035	83 65 b8 fd	 and	 DWORD PTR $T4[ebp], -3	; fffffffdH
  00039	8d 4d c0	 lea	 ecx, DWORD PTR $T5[ebp]
  0003c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN52@System_err:
  00041	c3		 ret	 0
__unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$7:
  00042	8b 4d 94	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00045	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
__unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$2:
  0004a	8b 4d 94	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0004d	e9 00 00 00 00	 jmp	 ??1runtime_error@std@@UAE@XZ
  00052	cc		 int	 3
  00053	cc		 int	 3
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
__ehhandler$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  00057	90		 npad	 1
  00058	90		 npad	 1
  00059	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0005d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00060	8b 4a 94	 mov	 ecx, DWORD PTR [edx-108]
  00063	33 c8		 xor	 ecx, eax
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0006d	33 c8		 xor	 ecx, eax
  0006f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00074	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  00079	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_System_error::_System_error
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 390  : _NODISCARD inline bool error_category::equivalent(const error_code& _Code, int _Errval) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 94   :         return _Addr == _Right._Addr;

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 390  : _NODISCARD inline bool error_category::equivalent(const error_code& _Code, int _Errval) const noexcept {

  00006	56		 push	 esi

; 94   :         return _Addr == _Right._Addr;

  00007	8b 75 08	 mov	 esi, DWORD PTR __Code$[ebp]
  0000a	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0000d	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]

; 391  :     return *this == _Code.category() && _Code.value() == _Errval;

  00010	75 0e		 jne	 SHORT $LN3@equivalent
  00012	8b 06		 mov	 eax, DWORD PTR [esi]
  00014	3b 45 0c	 cmp	 eax, DWORD PTR __Errval$[ebp]
  00017	75 07		 jne	 SHORT $LN3@equivalent
  00019	b0 01		 mov	 al, 1
  0001b	5e		 pop	 esi

; 392  : }

  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
$LN3@equivalent:

; 391  :     return *this == _Code.category() && _Code.value() == _Errval;

  00020	32 c0		 xor	 al, al
  00022	5e		 pop	 esi

; 392  : }

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 386  : _NODISCARD inline bool error_category::equivalent(int _Errval, const error_condition& _Cond) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 387  :     return default_error_condition(_Errval) == _Cond;

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8d 55 f8	 lea	 edx, DWORD PTR $T1[ebp]
  00008	83 ec 08	 sub	 esp, 8
  0000b	56		 push	 esi
  0000c	ff 75 08	 push	 DWORD PTR __Errval$[ebp]
  0000f	52		 push	 edx
  00010	ff 50 0c	 call	 DWORD PTR [eax+12]

; 94   :         return _Addr == _Right._Addr;

  00013	8b 75 0c	 mov	 esi, DWORD PTR __Cond$[ebp]
  00016	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00019	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0001c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001f	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]

; 273  :         return _Left.category() == _Right.category() && _Left.value() == _Right.value();

  00022	75 0f		 jne	 SHORT $LN5@equivalent
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	3b 06		 cmp	 eax, DWORD PTR [esi]
  00028	75 09		 jne	 SHORT $LN5@equivalent
  0002a	b0 01		 mov	 al, 1
  0002c	5e		 pop	 esi

; 388  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
$LN5@equivalent:

; 273  :         return _Left.category() == _Right.category() && _Left.value() == _Right.value();

  00033	32 c0		 xor	 al, al
  00035	5e		 pop	 esi

; 388  : }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 381  : _NODISCARD inline error_condition error_category::default_error_condition(int _Errval) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 232  :     error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Errval$[ebp]
  00009	89 10		 mov	 DWORD PTR [eax], edx
  0000b	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 382  :     // make error_condition for error code
; 383  :     return error_condition(_Errval, *this);
; 384  : }

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 81   :         virtual ~error_category() noexcept = default;

  00000	c2 00 00	 ret	 0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\system_error
;	COMDAT ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errno$ = 12						; size = 4
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z PROC ; std::make_error_code, COMDAT

; 405  : _NODISCARD inline error_code make_error_code(io_errc _Errno) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 139  :     error_code(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Errno$[ebp]

; 405  : _NODISCARD inline error_code make_error_code(io_errc _Errno) noexcept {

  00006	56		 push	 esi

; 139  :     error_code(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

  00007	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 0e		 mov	 DWORD PTR [esi], ecx

; 669  :     return _Immortalize_memcpy_image<_Iostream_error_category2>();

  0000c	e8 00 00 00 00	 call	 ??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>

; 139  :     error_code(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

  00011	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 406  :     return error_code(static_cast<int>(_Errno), _STD iostream_category());

  00014	8b c6		 mov	 eax, esi
  00016	5e		 pop	 esi

; 407  : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ENDP ; std::make_error_code
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_Gruntime_error@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 90   :         __std_exception_destroy(&_Data);

  00030	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00033	50		 push	 eax
  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0003a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0003f	83 c4 04	 add	 esp, 4
  00042	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00046	74 0b		 je	 SHORT $LN9@scalar
  00048	6a 0c		 push	 12			; 0000000cH
  0004a	56		 push	 esi
  0004b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00050	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00053	8b c6		 mov	 eax, esi
  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	5e		 pop	 esi
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_Gruntime_error@std@@UAEPAXI@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??_Gruntime_error@std@@UAEPAXI@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_Gruntime_error@std@@UAEPAXI@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 71   :         : _Data()

  00029	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 72   :     {

  0002c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00032	0f 57 c0	 xorps	 xmm0, xmm0

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  00035	50		 push	 eax
  00036	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0003a	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0003d	83 c0 04	 add	 eax, 4
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ___std_exception_copy
  00046	83 c4 08	 add	 esp, 8
  00049	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00050	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
  00056	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0005d	8b c6		 mov	 eax, esi
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5e		 pop	 esi
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0runtime_error@std@@QAE@ABV01@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1runtime_error@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 90   :         __std_exception_destroy(&_Data);

  0002d	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00030	50		 push	 eax
  00031	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00037	e8 00 00 00 00	 call	 ___std_exception_destroy
  0003c	83 c4 04	 add	 esp, 4
  0003f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00042	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00049	59		 pop	 ecx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1runtime_error@std@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??1runtime_error@std@@UAE@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1runtime_error@std@@UAE@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4616 :     _CONSTEXPR20_CONTAINER void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 2319 :         return _BUF_SIZE <= _Myres;

  00025	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00028	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4617 :         _Mypair._Myval2._Orphan_all();
; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0002b	72 27		 jb	 SHORT $LN21@Tidy_deall
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002d	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0002f	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00030	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00036	72 12		 jb	 SHORT $LN20@Tidy_deall

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00038	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0003b	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0003e	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00040	83 c0 fc	 add	 eax, -4			; fffffffcH
  00043	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00046	77 2d		 ja	 SHORT $LN17@Tidy_deall

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00048	8b c2		 mov	 eax, edx
$LN20@Tidy_deall:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0004a	51		 push	 ecx
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00051	83 c4 08	 add	 esp, 8
$LN21@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  00054	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0005b	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00062	c6 06 00	 mov	 BYTE PTR [esi], 0

; 4638 :     }

  00065	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00068	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006f	59		 pop	 ecx
  00070	5e		 pop	 esi
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
$LN17@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00075	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@Tidy_deall:
  0007a	cc		 int	 3
  0007b	cc		 int	 3
  0007c	cc		 int	 3
  0007d	cc		 int	 3
  0007e	cc		 int	 3
  0007f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
$T1 = 12						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3244 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 3245 :         // assign [_Ptr, _Ptr + _Count)
; 3246 :         if (_Count <= _Mypair._Myval2._Myres) {

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	57		 push	 edi
  0000c	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0000f	89 4d fc	 mov	 DWORD PTR __Old$1$[ebp], ecx
  00012	3b d9		 cmp	 ebx, ecx
  00014	77 28		 ja	 SHORT $LN2@assign

; 2296 :         value_type* _Result = _Bx._Buf;

  00016	8b fe		 mov	 edi, esi

; 2319 :         return _BUF_SIZE <= _Myres;

  00018	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 2297 :         if (_Large_string_engaged()) {

  0001b	72 02		 jb	 SHORT $LN5@assign

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  0001d	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN5@assign:

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0001f	53		 push	 ebx
  00020	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 3247 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3248 :             _Mypair._Myval2._Mysize = _Count;

  00023	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 _memmove
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3249 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0002f	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 3259 :             },
; 3260 :             _Ptr);
; 3261 :     }

  00033	8b c6		 mov	 eax, esi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
$LN2@assign:

; 4508 :         if (_New_size > max_size()) {

  0003e	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  00044	0f 87 d4 00 00
	00		 ja	 $LN60@assign

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0004a	8b fb		 mov	 edi, ebx
  0004c	83 cf 0f	 or	 edi, 15			; 0000000fH
  0004f	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00055	76 15		 jbe	 SHORT $LN19@assign

; 4490 :             return _Max;

  00057	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0005c	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00067	83 c4 04	 add	 esp, 4
  0006a	eb 52		 jmp	 SHORT $LN58@assign
$LN19@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4493 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0006c	8b d1		 mov	 edx, ecx
  0006e	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00073	d1 ea		 shr	 edx, 1
  00075	2b c2		 sub	 eax, edx
  00077	3b c8		 cmp	 ecx, eax
  00079	76 15		 jbe	 SHORT $LN20@assign

; 4494 :             return _Max;

  0007b	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00080	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0008b	83 c4 04	 add	 esp, 4
  0008e	eb 2e		 jmp	 SHORT $LN58@assign
$LN20@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4497 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00090	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00093	3b f8		 cmp	 edi, eax
  00095	0f 42 f8	 cmovb	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4515 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00098	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0009b	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000a0	72 0b		 jb	 SHORT $LN27@assign

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a8	83 c4 04	 add	 esp, 4
  000ab	eb 11		 jmp	 SHORT $LN58@assign
$LN27@assign:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  000ad	85 c0		 test	 eax, eax
  000af	74 0b		 je	 SHORT $LN28@assign

; 85   :         return ::operator new(_Bytes);

  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b7	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000ba	eb 02		 jmp	 SHORT $LN58@assign
$LN28@assign:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000bc	33 c0		 xor	 eax, eax
$LN58@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000be	53		 push	 ebx
  000bf	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 4523 :         _Mypair._Myval2._Mysize = _New_size;

  000c2	89 45 0c	 mov	 DWORD PTR $T1[ebp], eax

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c5	50		 push	 eax

; 4523 :         _Mypair._Myval2._Mysize = _New_size;

  000c6	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 4524 :         _Mypair._Myval2._Myres  = _New_capacity;

  000c9	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000cc	e8 00 00 00 00	 call	 _memcpy

; 3258 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000d1	8b 7d 0c	 mov	 edi, DWORD PTR $T1[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4526 :         if (_BUF_SIZE <= _Old_capacity) {

  000d7	8b 45 fc	 mov	 eax, DWORD PTR __Old$1$[ebp]

; 3258 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000da	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 4526 :         if (_BUF_SIZE <= _Old_capacity) {

  000de	83 f8 10	 cmp	 eax, 16			; 00000010H
  000e1	72 29		 jb	 SHORT $LN13@assign

; 4527 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  000e3	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e6	8b 06		 mov	 eax, DWORD PTR [esi]

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000e8	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000ee	72 12		 jb	 SHORT $LN50@assign

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f0	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000f3	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000f6	2b c2		 sub	 eax, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000f8	83 c0 fc	 add	 eax, -4			; fffffffcH
  000fb	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000fe	77 19		 ja	 SHORT $LN47@assign

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00100	8b c2		 mov	 eax, edx
$LN50@assign:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00102	51		 push	 ecx
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00109	83 c4 08	 add	 esp, 8
$LN13@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3254 :         return _Reallocate_for(

  0010c	89 3e		 mov	 DWORD PTR [esi], edi

; 3259 :             },
; 3260 :             _Ptr);
; 3261 :     }

  0010e	8b c6		 mov	 eax, esi
  00110	5f		 pop	 edi
  00111	5e		 pop	 esi
  00112	5b		 pop	 ebx
  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c2 08 00	 ret	 8
$LN47@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00119	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN60@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4509 :             _Xlen_string(); // result too long

  0011e	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN56@assign:
  00123	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
tv540 = -12						; size = 4
__Old$1$ = -8						; size = 4
tv541 = -4						; size = 4
__Old_size$1$ = -4					; size = 4
tv544 = 8						; size = 4
$T1 = 8							; size = 4
__Count$ = 8						; size = 4
tv546 = 12						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 3178 :     _CONSTEXPR20_CONTAINER basic_string& append(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 3179 :         // append _Count * _Ch
; 3180 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3181 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00011	8b c2		 mov	 eax, edx
  00013	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00016	2b c1		 sub	 eax, ecx
  00018	89 4d fc	 mov	 DWORD PTR __Old_size$1$[ebp], ecx
  0001b	89 55 f8	 mov	 DWORD PTR __Old$1$[ebp], edx
  0001e	3b d8		 cmp	 ebx, eax
  00020	77 30		 ja	 SHORT $LN2@append

; 3182 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00022	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00025	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 2296 :         value_type* _Result = _Bx._Buf;

  00028	8b c7		 mov	 eax, edi

; 2319 :         return _BUF_SIZE <= _Myres;

  0002a	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2297 :         if (_Large_string_engaged()) {

  0002d	72 02		 jb	 SHORT $LN5@append

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  0002f	8b 07		 mov	 eax, DWORD PTR [edi]
$LN5@append:

; 3183 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3184 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

  00031	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]

; 446  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  00034	0f be 45 0c	 movsx	 eax, BYTE PTR __Ch$[ebp]
  00038	53		 push	 ebx
  00039	50		 push	 eax
  0003a	56		 push	 esi
  0003b	e8 00 00 00 00	 call	 _memset
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3185 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00043	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0

; 3198 :     }

  00047	8b c7		 mov	 eax, edi
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8
$LN2@append:

; 4543 :         if (max_size() - _Old_size < _Size_increase) {

  00052	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00057	2b c1		 sub	 eax, ecx
  00059	3b c3		 cmp	 eax, ebx
  0005b	0f 82 2d 01 00
	00		 jb	 $LN68@append

; 4545 :         }
; 4546 : 
; 4547 :         const size_type _New_size     = _Old_size + _Size_increase;

  00061	8d 34 19	 lea	 esi, DWORD PTR [ecx+ebx]

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00064	83 ce 0f	 or	 esi, 15			; 0000000fH
  00067	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0006d	76 18		 jbe	 SHORT $LN19@append

; 4490 :             return _Max;

  0006f	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00074	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0007f	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  00082	83 c4 04	 add	 esp, 4
  00085	eb 61		 jmp	 SHORT $LN66@append
$LN19@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4493 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00087	8b c2		 mov	 eax, edx
  00089	d1 e8		 shr	 eax, 1
  0008b	89 45 08	 mov	 DWORD PTR tv544[ebp], eax
  0008e	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00093	2b 45 08	 sub	 eax, DWORD PTR tv544[ebp]
  00096	3b d0		 cmp	 edx, eax
  00098	76 18		 jbe	 SHORT $LN20@append

; 4494 :             return _Max;

  0009a	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0009f	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000aa	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  000ad	83 c4 04	 add	 esp, 4
  000b0	eb 36		 jmp	 SHORT $LN66@append
$LN20@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4497 :         return (_STD max)(_Masked, _Old + _Old / 2);

  000b2	8b 45 08	 mov	 eax, DWORD PTR tv544[ebp]
  000b5	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  000b7	3b f0		 cmp	 esi, eax
  000b9	0f 42 f0	 cmovb	 esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4551 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  000bc	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000bf	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000c4	72 0e		 jb	 SHORT $LN27@append

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000cc	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  000cf	83 c4 04	 add	 esp, 4
  000d2	eb 14		 jmp	 SHORT $LN66@append
$LN27@append:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  000d4	85 c0		 test	 eax, eax
  000d6	74 0e		 je	 SHORT $LN28@append

; 85   :         return ::operator new(_Bytes);

  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 244  :         return _Traits::_Allocate(_Bytes);

  000de	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]

; 85   :         return ::operator new(_Bytes);

  000e1	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000e4	eb 02		 jmp	 SHORT $LN66@append
$LN28@append:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000e6	33 c0		 xor	 eax, eax
$LN66@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4562 :         if (_BUF_SIZE <= _Old_capacity) {

  000e8	83 7d f8 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
  000ec	8d 14 19	 lea	 edx, DWORD PTR [ecx+ebx]
  000ef	89 77 14	 mov	 DWORD PTR [edi+20], esi
  000f2	0f be 75 0c	 movsx	 esi, BYTE PTR __Ch$[ebp]
  000f6	89 75 0c	 mov	 DWORD PTR tv546[ebp], esi
  000f9	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  000fc	89 57 10	 mov	 DWORD PTR [edi+16], edx
  000ff	8d 14 1e	 lea	 edx, DWORD PTR [esi+ebx]
  00102	89 45 08	 mov	 DWORD PTR $T1[ebp], eax
  00105	89 75 fc	 mov	 DWORD PTR tv541[ebp], esi
  00108	89 55 f4	 mov	 DWORD PTR tv540[ebp], edx
  0010b	51		 push	 ecx
  0010c	72 56		 jb	 SHORT $LN13@append

; 4563 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0010e	8b 37		 mov	 esi, DWORD PTR [edi]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00110	56		 push	 esi
  00111	50		 push	 eax
  00112	e8 00 00 00 00	 call	 _memcpy

; 446  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  00117	53		 push	 ebx
  00118	ff 75 0c	 push	 DWORD PTR tv546[ebp]
  0011b	ff 75 fc	 push	 DWORD PTR tv541[ebp]
  0011e	e8 00 00 00 00	 call	 _memset

; 3195 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00123	8b 45 f4	 mov	 eax, DWORD PTR tv540[ebp]

; 446  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  00126	83 c4 18	 add	 esp, 24			; 00000018H

; 4565 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  00129	8b 4d f8	 mov	 ecx, DWORD PTR __Old$1$[ebp]
  0012c	41		 inc	 ecx

; 3195 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0012d	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00130	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00136	72 12		 jb	 SHORT $LN52@append

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00138	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  0013b	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0013e	2b f2		 sub	 esi, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00140	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  00143	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00146	77 4b		 ja	 SHORT $LN49@append

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00148	8b f2		 mov	 esi, edx
$LN52@append:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0014a	51		 push	 ecx
  0014b	56		 push	 esi
  0014c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3189 :         return _Reallocate_grow_by(

  00151	8b 45 08	 mov	 eax, DWORD PTR $T1[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00154	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3189 :         return _Reallocate_grow_by(

  00157	89 07		 mov	 DWORD PTR [edi], eax

; 3198 :     }

  00159	8b c7		 mov	 eax, edi
  0015b	5f		 pop	 edi
  0015c	5e		 pop	 esi
  0015d	5b		 pop	 ebx
  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c2 08 00	 ret	 8
$LN13@append:

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00164	57		 push	 edi
  00165	50		 push	 eax
  00166	e8 00 00 00 00	 call	 _memcpy

; 446  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  0016b	53		 push	 ebx
  0016c	ff 75 0c	 push	 DWORD PTR tv546[ebp]
  0016f	56		 push	 esi
  00170	e8 00 00 00 00	 call	 _memset

; 3195 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00175	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]

; 446  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  00178	83 c4 18	 add	 esp, 24			; 00000018H

; 3195 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0017b	c6 00 00	 mov	 BYTE PTR [eax], 0

; 3189 :         return _Reallocate_grow_by(

  0017e	8b 45 08	 mov	 eax, DWORD PTR $T1[ebp]
  00181	89 07		 mov	 DWORD PTR [edi], eax

; 3198 :     }

  00183	8b c7		 mov	 eax, edi
  00185	5f		 pop	 edi
  00186	5e		 pop	 esi
  00187	5b		 pop	 ebx
  00188	8b e5		 mov	 esp, ebp
  0018a	5d		 pop	 ebp
  0018b	c2 08 00	 ret	 8
$LN68@append:

; 4544 :             _Xlen_string(); // result too long

  0018e	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN49@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00193	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN64@append:
  00198	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
tv533 = -12						; size = 4
__Old$1$ = -8						; size = 4
tv534 = -4						; size = 4
__Old_size$1$ = -4					; size = 4
__Ptr$ = 8						; size = 4
tv537 = 12						; size = 4
$T1 = 12						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 3152 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 3153 :         // append [_Ptr, _Ptr + _Count)
; 3154 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3155 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00011	8b c2		 mov	 eax, edx
  00013	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00016	2b c1		 sub	 eax, ecx
  00018	89 4d fc	 mov	 DWORD PTR __Old_size$1$[ebp], ecx
  0001b	89 55 f8	 mov	 DWORD PTR __Old$1$[ebp], edx
  0001e	3b d8		 cmp	 ebx, eax
  00020	77 2e		 ja	 SHORT $LN2@append

; 3156 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00022	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00025	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 2296 :         value_type* _Result = _Bx._Buf;

  00028	8b c7		 mov	 eax, edi

; 2319 :         return _BUF_SIZE <= _Myres;

  0002a	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2297 :         if (_Large_string_engaged()) {

  0002d	72 02		 jb	 SHORT $LN5@append

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  0002f	8b 07		 mov	 eax, DWORD PTR [edi]
$LN5@append:

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00031	53		 push	 ebx
  00032	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 3157 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3158 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00035	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 _memmove
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3159 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00041	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0

; 3172 :     }

  00045	8b c7		 mov	 eax, edi
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
$LN2@append:

; 4543 :         if (max_size() - _Old_size < _Size_increase) {

  00050	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00055	2b c1		 sub	 eax, ecx
  00057	3b c3		 cmp	 eax, ebx
  00059	0f 82 26 01 00
	00		 jb	 $LN68@append

; 4545 :         }
; 4546 : 
; 4547 :         const size_type _New_size     = _Old_size + _Size_increase;

  0005f	8d 34 19	 lea	 esi, DWORD PTR [ecx+ebx]

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00062	83 ce 0f	 or	 esi, 15			; 0000000fH
  00065	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0006b	76 18		 jbe	 SHORT $LN19@append

; 4490 :             return _Max;

  0006d	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00072	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  00080	83 c4 04	 add	 esp, 4
  00083	eb 61		 jmp	 SHORT $LN66@append
$LN19@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4493 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00085	8b c2		 mov	 eax, edx
  00087	d1 e8		 shr	 eax, 1
  00089	89 45 0c	 mov	 DWORD PTR tv537[ebp], eax
  0008c	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00091	2b 45 0c	 sub	 eax, DWORD PTR tv537[ebp]
  00094	3b d0		 cmp	 edx, eax
  00096	76 18		 jbe	 SHORT $LN20@append

; 4494 :             return _Max;

  00098	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0009d	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  000ab	83 c4 04	 add	 esp, 4
  000ae	eb 36		 jmp	 SHORT $LN66@append
$LN20@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4497 :         return (_STD max)(_Masked, _Old + _Old / 2);

  000b0	8b 45 0c	 mov	 eax, DWORD PTR tv537[ebp]
  000b3	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  000b5	3b f0		 cmp	 esi, eax
  000b7	0f 42 f0	 cmovb	 esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4551 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  000ba	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000bd	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000c2	72 0e		 jb	 SHORT $LN27@append

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000ca	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  000cd	83 c4 04	 add	 esp, 4
  000d0	eb 14		 jmp	 SHORT $LN66@append
$LN27@append:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  000d2	85 c0		 test	 eax, eax
  000d4	74 0e		 je	 SHORT $LN28@append

; 85   :         return ::operator new(_Bytes);

  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 244  :         return _Traits::_Allocate(_Bytes);

  000dc	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]

; 85   :         return ::operator new(_Bytes);

  000df	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000e2	eb 02		 jmp	 SHORT $LN66@append
$LN28@append:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000e4	33 c0		 xor	 eax, eax
$LN66@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4562 :         if (_BUF_SIZE <= _Old_capacity) {

  000e6	83 7d f8 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
  000ea	8d 14 19	 lea	 edx, DWORD PTR [ecx+ebx]
  000ed	89 77 14	 mov	 DWORD PTR [edi+20], esi
  000f0	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  000f3	89 57 10	 mov	 DWORD PTR [edi+16], edx
  000f6	8d 14 1e	 lea	 edx, DWORD PTR [esi+ebx]
  000f9	89 45 0c	 mov	 DWORD PTR $T1[ebp], eax
  000fc	89 75 fc	 mov	 DWORD PTR tv534[ebp], esi
  000ff	89 55 f4	 mov	 DWORD PTR tv533[ebp], edx
  00102	51		 push	 ecx
  00103	72 56		 jb	 SHORT $LN13@append

; 4563 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  00105	8b 37		 mov	 esi, DWORD PTR [edi]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00107	56		 push	 esi
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 _memcpy
  0010e	53		 push	 ebx
  0010f	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00112	ff 75 fc	 push	 DWORD PTR tv534[ebp]
  00115	e8 00 00 00 00	 call	 _memcpy

; 3169 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0011a	8b 45 f4	 mov	 eax, DWORD PTR tv533[ebp]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0011d	83 c4 18	 add	 esp, 24			; 00000018H

; 4565 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  00120	8b 4d f8	 mov	 ecx, DWORD PTR __Old$1$[ebp]
  00123	41		 inc	 ecx

; 3169 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00124	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00127	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0012d	72 12		 jb	 SHORT $LN52@append

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0012f	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  00132	83 c1 23	 add	 ecx, 35			; 00000023H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00135	2b f2		 sub	 esi, edx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00137	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  0013a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0013d	77 4b		 ja	 SHORT $LN49@append

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0013f	8b f2		 mov	 esi, edx
$LN52@append:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00141	51		 push	 ecx
  00142	56		 push	 esi
  00143	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3163 :         return _Reallocate_grow_by(

  00148	8b 45 0c	 mov	 eax, DWORD PTR $T1[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  0014b	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3163 :         return _Reallocate_grow_by(

  0014e	89 07		 mov	 DWORD PTR [edi], eax

; 3172 :     }

  00150	8b c7		 mov	 eax, edi
  00152	5f		 pop	 edi
  00153	5e		 pop	 esi
  00154	5b		 pop	 ebx
  00155	8b e5		 mov	 esp, ebp
  00157	5d		 pop	 ebp
  00158	c2 08 00	 ret	 8
$LN13@append:

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0015b	57		 push	 edi
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 _memcpy
  00162	53		 push	 ebx
  00163	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00166	56		 push	 esi
  00167	e8 00 00 00 00	 call	 _memcpy

; 3169 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0016c	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0016f	83 c4 18	 add	 esp, 24			; 00000018H

; 3169 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00172	c6 00 00	 mov	 BYTE PTR [eax], 0

; 3163 :         return _Reallocate_grow_by(

  00175	8b 45 0c	 mov	 eax, DWORD PTR $T1[ebp]
  00178	89 07		 mov	 DWORD PTR [edi], eax

; 3172 :     }

  0017a	8b c7		 mov	 eax, edi
  0017c	5f		 pop	 edi
  0017d	5e		 pop	 esi
  0017e	5b		 pop	 ebx
  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c2 08 00	 ret	 8
$LN68@append:

; 4544 :             _Xlen_string(); // result too long

  00185	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN49@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0018a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN64@append:
  0018f	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 3003 :         _Tidy_deallocate();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2538 :         : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 3269 :         if (_Count <= _Mypair._Myval2._Myres) {

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]

; 2538 :         : _Mypair(_Zero_then_variadic_args_t{}) {

  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 4596 :         _My_data._Mysize = 0;

  00010	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {
; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4601 :             auto& _Al              = _Getal();
; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4603 :             _My_data._Bx._Ptr      = _New_ptr;
; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4607 :         } else
; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00017	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 3269 :         if (_Count <= _Mypair._Myval2._Myres) {

  0001e	83 fb 0f	 cmp	 ebx, 15			; 0000000fH
  00021	77 1e		 ja	 SHORT $LN12@basic_stri

; 446  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  00023	0f be 45 0c	 movsx	 eax, BYTE PTR __Ch$[ebp]
  00027	53		 push	 ebx
  00028	50		 push	 eax
  00029	56		 push	 esi

; 3271 :             _Mypair._Myval2._Mysize = _Count;

  0002a	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 446  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  0002d	e8 00 00 00 00	 call	 _memset
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3273 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00035	c6 04 33 00	 mov	 BYTE PTR [ebx+esi], 0

; 2539 :         // construct from _Count * _Ch
; 2540 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2541 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2542 :         _Tidy_init();
; 2543 :         assign(_Count, _Ch);
; 2544 :         _Proxy._Release();
; 2545 :     }

  00039	8b c6		 mov	 eax, esi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN12@basic_stri:

; 4508 :         if (_New_size > max_size()) {

  00041	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  00047	0f 87 86 00 00
	00		 ja	 $LN70@basic_stri
  0004d	57		 push	 edi

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0004e	8b fb		 mov	 edi, ebx
  00050	83 cf 0f	 or	 edi, 15			; 0000000fH
  00053	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00059	76 17		 jbe	 SHORT $LN29@basic_stri

; 4490 :             return _Max;

  0005b	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00060	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0006b	83 c4 04	 add	 esp, 4
  0006e	8b c8		 mov	 ecx, eax
  00070	eb 37		 jmp	 SHORT $LN68@basic_stri
$LN29@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00072	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  00077	3b f8		 cmp	 edi, eax
  00079	0f 42 f8	 cmovb	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4515 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0007c	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0007f	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00084	72 0d		 jb	 SHORT $LN37@basic_stri

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0008c	83 c4 04	 add	 esp, 4
  0008f	8b c8		 mov	 ecx, eax
  00091	eb 16		 jmp	 SHORT $LN68@basic_stri
$LN37@basic_stri:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  00093	85 c0		 test	 eax, eax
  00095	74 10		 je	 SHORT $LN38@basic_stri

; 85   :         return ::operator new(_Bytes);

  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0009d	83 c4 04	 add	 esp, 4

; 244  :         return _Traits::_Allocate(_Bytes);

  000a0	89 45 08	 mov	 DWORD PTR $T1[ebp], eax
  000a3	8b c8		 mov	 ecx, eax
  000a5	eb 05		 jmp	 SHORT $LN36@basic_stri
$LN38@basic_stri:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000a7	33 c9		 xor	 ecx, ecx
$LN68@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4523 :         _Mypair._Myval2._Mysize = _New_size;

  000a9	89 4d 08	 mov	 DWORD PTR $T1[ebp], ecx
$LN36@basic_stri:

; 446  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  000ac	0f be 45 0c	 movsx	 eax, BYTE PTR __Ch$[ebp]
  000b0	53		 push	 ebx
  000b1	50		 push	 eax
  000b2	51		 push	 ecx

; 4523 :         _Mypair._Myval2._Mysize = _New_size;

  000b3	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 4524 :         _Mypair._Myval2._Myres  = _New_capacity;

  000b6	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 446  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  000b9	e8 00 00 00 00	 call	 _memset

; 3281 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000be	8b 45 08	 mov	 eax, DWORD PTR $T1[ebp]

; 446  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3281 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000c4	c6 04 18 00	 mov	 BYTE PTR [eax+ebx], 0

; 4530 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000c8	89 06		 mov	 DWORD PTR [esi], eax

; 2539 :         // construct from _Count * _Ch
; 2540 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2541 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2542 :         _Tidy_init();
; 2543 :         assign(_Count, _Ch);
; 2544 :         _Proxy._Release();
; 2545 :     }

  000ca	8b c6		 mov	 eax, esi

; 4530 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000cc	5f		 pop	 edi

; 2539 :         // construct from _Count * _Ch
; 2540 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2541 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2542 :         _Tidy_init();
; 2543 :         assign(_Count, _Ch);
; 2544 :         _Proxy._Release();
; 2545 :     }

  000cd	5e		 pop	 esi
  000ce	5b		 pop	 ebx
  000cf	5d		 pop	 ebp
  000d0	c2 08 00	 ret	 8
$LN70@basic_stri:

; 4509 :             _Xlen_string(); // result too long

  000d3	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN67@basic_stri:
  000d8	cc		 int	 3
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 2337 :         _Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2374 :     _Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen_strin:
  0000a	cc		 int	 3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\thread
;	COMDAT ??1thread@std@@QAE@XZ
_TEXT	SEGMENT
??1thread@std@@QAE@XZ PROC				; std::thread::~thread, COMDAT
; _this$ = ecx

; 118  :         return _Thr._Id != 0;

  00000	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0

; 94   :         if (joinable()) {

  00004	0f 85 00 00 00
	00		 jne	 _terminate

; 95   :             _STD terminate();
; 96   :         }
; 97   :     }

  0000a	c3		 ret	 0
??1thread@std@@QAE@XZ ENDP				; std::thread::~thread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\typeinfo
;	COMDAT ?_Throw_bad_cast@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_cast@std@@YAXXZ PROC			; std::_Throw_bad_cast, COMDAT

; 64   : [[noreturn]] inline void _Throw_bad_cast() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 65   :     _THROW(bad_cast{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_cast@std@@QAE@XZ	; std::bad_cast::bad_cast
  0000e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_cast@std@@YAXXZ ENDP			; std::_Throw_bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gbad_cast@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Gbad_cast@std@@UAEPAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_Gbad_cast@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 90   :         __std_exception_destroy(&_Data);

  00030	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00033	50		 push	 eax
  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0003a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0003f	83 c4 04	 add	 esp, 4
  00042	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00046	74 0b		 je	 SHORT $LN9@scalar
  00048	6a 0c		 push	 12			; 0000000cH
  0004a	56		 push	 esi
  0004b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00050	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00053	8b c6		 mov	 eax, esi
  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	5e		 pop	 esi
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_Gbad_cast@std@@UAEPAXI@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??_Gbad_cast@std@@UAEPAXI@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_Gbad_cast@std@@UAEPAXI@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_Gbad_cast@std@@UAEPAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_cast@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0bad_cast@std@@QAE@ABV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0bad_cast@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 71   :         : _Data()

  00029	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 72   :     {

  0002c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00032	0f 57 c0	 xorps	 xmm0, xmm0

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  00035	50		 push	 eax
  00036	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0003a	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0003d	83 c0 04	 add	 eax, 4
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ___std_exception_copy
  00046	83 c4 08	 add	 esp, 8
  00049	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00050	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_cast@std@@6B@
  00056	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0005d	8b c6		 mov	 eax, esi
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5e		 pop	 esi
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_cast@std@@QAE@ABV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0bad_cast@std@@QAE@ABV01@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0bad_cast@std@@QAE@ABV01@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0bad_cast@std@@QAE@ABV01@@Z ENDP			; std::bad_cast::bad_cast
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1bad_cast@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1bad_cast@std@@UAE@XZ PROC				; std::bad_cast::~bad_cast, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1bad_cast@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 90   :         __std_exception_destroy(&_Data);

  0002d	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00030	50		 push	 eax
  00031	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00037	e8 00 00 00 00	 call	 ___std_exception_destroy
  0003c	83 c4 04	 add	 esp, 4
  0003f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00042	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00049	59		 pop	 ecx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1bad_cast@std@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??1bad_cast@std@@UAE@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1bad_cast@std@@UAE@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1bad_cast@std@@UAE@XZ ENDP				; std::bad_cast::~bad_cast
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_typeinfo.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0bad_cast@std@@QAE@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx

; 137  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0bad_cast@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h

; 66   :     {

  00029	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  0002f	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 67   :         _Data._What = _Message;

  00034	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_typeinfo.h

; 136  :         : exception("bad cast", 1)

  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 137  :     {

  00042	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_cast@std@@6B@

; 138  :     }

  00048	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004f	8b c1		 mov	 eax, ecx
  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_cast@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0bad_cast@std@@QAE@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0bad_cast@std@@QAE@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0bad_cast@std@@QAE@XZ ENDP				; std::bad_cast::bad_cast
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_Gbad_array_new_length@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 90   :         __std_exception_destroy(&_Data);

  00030	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00033	50		 push	 eax
  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0003a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0003f	83 c4 04	 add	 esp, 4
  00042	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00046	74 0b		 je	 SHORT $LN12@scalar
  00048	6a 0c		 push	 12			; 0000000cH
  0004a	56		 push	 esi
  0004b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00050	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00053	8b c6		 mov	 eax, esi
  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	5e		 pop	 esi
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_Gbad_array_new_length@std@@UAEPAXI@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1bad_alloc@std@@UAE@XZ
__unwindfunclet$??_Gbad_array_new_length@std@@UAEPAXI@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??_Gbad_array_new_length@std@@UAEPAXI@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_Gbad_array_new_length@std@@UAEPAXI@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0bad_array_new_length@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 71   :         : _Data()

  00029	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 72   :     {

  0002c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00032	0f 57 c0	 xorps	 xmm0, xmm0

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  00035	50		 push	 eax
  00036	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0003a	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0003d	83 c0 04	 add	 eax, 4
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ___std_exception_copy
  00046	83 c4 08	 add	 esp, 8
  00049	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00050	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00056	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0005d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  00063	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0006a	8b c6		 mov	 eax, esi
  0006c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00076	59		 pop	 ecx
  00077	5e		 pop	 esi
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_array_new_length@std@@QAE@ABV01@@Z$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
__unwindfunclet$??0bad_array_new_length@std@@QAE@ABV01@@Z$0:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1bad_alloc@std@@UAE@XZ
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??0bad_array_new_length@std@@QAE@ABV01@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0bad_array_new_length@std@@QAE@ABV01@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1bad_array_new_length@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 90   :         __std_exception_destroy(&_Data);

  0002d	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00030	50		 push	 eax
  00031	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00037	e8 00 00 00 00	 call	 ___std_exception_destroy
  0003c	83 c4 04	 add	 esp, 4
  0003f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00042	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00049	59		 pop	 ecx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1bad_array_new_length@std@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1bad_alloc@std@@UAE@XZ
__unwindfunclet$??1bad_array_new_length@std@@UAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??1bad_array_new_length@std@@UAE@XZ:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1bad_array_new_length@std@@UAE@XZ
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0bad_array_new_length@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	0f 57 c0	 xorps	 xmm0, xmm0

; 66   :     {

  00029	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  0002f	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 67   :         _Data._What = _Message;

  00034	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 129  :         : exception(_Message, 1)

  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 130  :     {

  00042	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 131  :     }
; 132  : };
; 133  : 
; 134  : class bad_array_new_length
; 135  :     : public bad_alloc
; 136  : {
; 137  : public:
; 138  : 
; 139  :     bad_array_new_length() noexcept
; 140  :         : bad_alloc("bad array new length")

  00048	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 141  :     {

  0004f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00055	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0005c	8b c1		 mov	 eax, ecx
  0005e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00061	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00068	59		 pop	 ecx
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_array_new_length@std@@QAE@XZ$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
__unwindfunclet$??0bad_array_new_length@std@@QAE@XZ$0:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1bad_alloc@std@@UAE@XZ
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??0bad_array_new_length@std@@QAE@XZ:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0bad_array_new_length@std@@QAE@XZ
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_Gbad_alloc@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 90   :         __std_exception_destroy(&_Data);

  00030	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00033	50		 push	 eax
  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0003a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0003f	83 c4 04	 add	 esp, 4
  00042	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00046	74 0b		 je	 SHORT $LN9@scalar
  00048	6a 0c		 push	 12			; 0000000cH
  0004a	56		 push	 esi
  0004b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00050	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00053	8b c6		 mov	 eax, esi
  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	5e		 pop	 esi
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_Gbad_alloc@std@@UAEPAXI@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??_Gbad_alloc@std@@UAEPAXI@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_Gbad_alloc@std@@UAEPAXI@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 71   :         : _Data()

  00029	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 72   :     {

  0002c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00032	0f 57 c0	 xorps	 xmm0, xmm0

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  00035	50		 push	 eax
  00036	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0003a	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0003d	83 c0 04	 add	 eax, 4
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ___std_exception_copy
  00046	83 c4 08	 add	 esp, 8
  00049	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00050	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00056	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0005d	8b c6		 mov	 eax, esi
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5e		 pop	 esi
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1bad_alloc@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 90   :         __std_exception_destroy(&_Data);

  0002d	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00030	50		 push	 eax
  00031	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00037	e8 00 00 00 00	 call	 ___std_exception_destroy
  0003c	83 c4 04	 add	 esp, 4
  0003f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00042	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00049	59		 pop	 ecx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??1bad_alloc@std@@UAE@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1bad_alloc@std@@UAE@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_Gexception@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00025	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ___std_exception_destroy
  00034	83 c4 04	 add	 esp, 4
  00037	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0003b	74 0b		 je	 SHORT $LN6@scalar
  0003d	6a 0c		 push	 12			; 0000000cH
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00048	8b c6		 mov	 eax, esi
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00054	59		 pop	 ecx
  00055	5e		 pop	 esi
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
  0005f	cc		 int	 3
  00060	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_Gexception@std@@UAEPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_Gexception@std@@UAEPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 96   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 89   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1exception@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 90   :         __std_exception_destroy(&_Data);

  00022	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00025	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ___std_exception_destroy
  00031	83 c4 04	 add	 esp, 4

; 91   :     }

  00034	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00037	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003e	59		 pop	 ecx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
  00043	cc		 int	 3
  00044	cc		 int	 3
  00045	cc		 int	 3
  00046	cc		 int	 3
  00047	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1exception@std@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1exception@std@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0exception@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 71   :         : _Data()

  00025	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 72   :     {

  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0002e	0f 57 c0	 xorps	 xmm0, xmm0

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  00031	50		 push	 eax
  00032	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00036	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00039	83 c0 04	 add	 eax, 4
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ___std_exception_copy
  00042	83 c4 08	 add	 esp, 8

; 74   :     }

  00045	8b c6		 mov	 eax, esi
  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	5e		 pop	 esi
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
  00059	cc		 int	 3
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0exception@std@@QAE@ABV01@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0exception@std@@QAE@ABV01@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _sprintf_s
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_sprintf_s PROC						; COMDAT

; 1823 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1491 :         int const _Result = __stdio_common_vsprintf_s(

  00003	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	ff 30		 push	 DWORD PTR [eax]
  0001c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf_s

; 1492 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1493 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1494 : 
; 1495 :         return _Result < 0 ? -1 : _Result;

  00021	83 c9 ff	 or	 ecx, -1
  00024	83 c4 1c	 add	 esp, 28			; 0000001cH
  00027	85 c0		 test	 eax, eax
  00029	0f 48 c1	 cmovs	 eax, ecx

; 1824 :             int _Result;
; 1825 :             va_list _ArgList;
; 1826 :             __crt_va_start(_ArgList, _Format);
; 1827 :             _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1828 :             __crt_va_end(_ArgList);
; 1829 :             return _Result;
; 1830 :         }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_sprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);
; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1777 : 
; 1778 :         __crt_va_end(_ArgList);
; 1779 :         return _Result;
; 1780 :     }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
