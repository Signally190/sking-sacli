; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29336.0 

	TITLE	C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\tool.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?TimeGetTime@@YAIXZ				; TimeGetTime
PUBLIC	?wordchk@@YAHPAPAD@Z				; wordchk
PUBLIC	?strstr2@@YAHPAPADPAD@Z				; strstr2
PUBLIC	?getword@@YAHPAPADPAD@Z				; getword
PUBLIC	?strint2@@YAHPAPAD@Z				; strint2
PUBLIC	?strlong2@@YAJPAPAD@Z				; strlong2
PUBLIC	?getStringToken@@YAHPADDHH0@Z			; getStringToken
PUBLIC	?getIntegerToken@@YAHPADDH@Z			; getIntegerToken
PUBLIC	?getDoubleToken@@YANPADDH@Z			; getDoubleToken
PUBLIC	?chop@@YAXPAD@Z					; chop
PUBLIC	?shiftIntArray@@YAXPAHHH@Z			; shiftIntArray
PUBLIC	?a62toi@@YAHPAD@Z				; a62toi
PUBLIC	?getInteger62Token@@YAHPADDH@Z			; getInteger62Token
PUBLIC	?jEncode@@YAXPADHH0PAHH@Z			; jEncode
PUBLIC	?jDecode@@YAXPADHH0PAH@Z			; jDecode
PUBLIC	?strncmpi@@YAHPAD0H@Z				; strncmpi
PUBLIC	?intToRect@@YA?AUtagRECT@@HHHH@Z		; intToRect
PUBLIC	?insertString@@YAXPAD0H@Z			; insertString
PUBLIC	?insertChar@@YAXPADDH@Z				; insertChar
PUBLIC	?isOnlySpaceChars@@YAHPAD@Z			; isOnlySpaceChars
PUBLIC	?makeCharFromEscaped@@YADD@Z			; makeCharFromEscaped
PUBLIC	?makeStringFromEscaped@@YAPADPAD@Z		; makeStringFromEscaped
PUBLIC	?makeEscapeString@@YAPADPAD0H@Z			; makeEscapeString
EXTRN	_atoi:PROC
EXTRN	_atol:PROC
EXTRN	_strtod:PROC
EXTRN	_tolower:PROC
EXTRN	__imp__IsDBCSLeadByte@4:PROC
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
?escapeChar@@3PAUtagEscapeChar@@A DB 0aH		; escapeChar
	DB	06eH
	DB	02cH
	DB	063H
	DB	07cH
	DB	07aH
	DB	05cH
	DB	079H
_DATA	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\tool.cpp
;	COMDAT ?copyStringUntilDelim@@YAHPAEDH0@Z
_TEXT	SEGMENT
_src$ = 8						; size = 4
_delim$ = 12						; size = 1
_maxlen$ = 16						; size = 4
_out$ = 20						; size = 4
?copyStringUntilDelim@@YAHPAEDH0@Z PROC			; copyStringUntilDelim, COMDAT

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 257  : 	int i;
; 258  : 
; 259  : 	for( i = 0; i < maxlen; i++ )

  00006	8b 7d 10	 mov	 edi, DWORD PTR _maxlen$[ebp]
  00009	33 c0		 xor	 eax, eax
  0000b	85 ff		 test	 edi, edi
  0000d	7e 3f		 jle	 SHORT $LN3@copyString
  0000f	8a 7d 0c	 mov	 bh, BYTE PTR _delim$[ebp]
  00012	8b 55 14	 mov	 edx, DWORD PTR _out$[ebp]
$LL4@copyString:

; 260  : 	{
; 261  : 		if( src[i] < 0x80 )

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  00018	8d 34 10	 lea	 esi, DWORD PTR [eax+edx]
  0001b	8a 1c 08	 mov	 bl, BYTE PTR [eax+ecx]
  0001e	80 fb 80	 cmp	 bl, 128			; 00000080H
  00021	73 15		 jae	 SHORT $LN5@copyString

; 262  : 		{
; 263  : 			// 1byteîž°????
; 264  : 
; 265  : 			if( src[i] == delim )

  00023	0f b6 d3	 movzx	 edx, bl
  00026	0f be cf	 movsx	 ecx, bh
  00029	3b d1		 cmp	 edx, ecx
  0002b	74 32		 je	 SHORT $LN13@copyString

; 270  : 			}
; 271  : 
; 272  : 			// ???îž°?????
; 273  : 			out[i] = src[i];

  0002d	88 1e		 mov	 BYTE PTR [esi], bl

; 274  : 
; 275  : 			// îŽ·î– îž°???îŽ·??
; 276  : 			if( out[i] == '\0' )

  0002f	84 db		 test	 bl, bl
  00031	74 22		 je	 SHORT $LN16@copyString

; 277  : 				return 1;
; 278  : 		}

  00033	8b 55 14	 mov	 edx, DWORD PTR _out$[ebp]
  00036	eb 11		 jmp	 SHORT $LN2@copyString
$LN5@copyString:

; 279  : 		else
; 280  : 		{
; 281  : 			// 2byteîž°????
; 282  : 
; 283  : 			// ???îž°?????
; 284  : 			out[i] = src[i];
; 285  : 
; 286  : 			i++;

  00038	40		 inc	 eax
  00039	88 1e		 mov	 BYTE PTR [esi], bl

; 287  : 			if( i >= maxlen )	// ??????î›³???îŽ·??

  0003b	3b c7		 cmp	 eax, edi
  0003d	7d 0f		 jge	 SHORT $LN3@copyString

; 288  : 				break;
; 289  : 
; 290  : 			// ???îž°?????
; 291  : 			out[i] = src[i];

  0003f	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]
  00042	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 292  : 
; 293  : 			// îŽ·î– îž°???îŽ·????????????????
; 294  : 			if( out[i] == '\0' )

  00045	84 c9		 test	 cl, cl
  00047	74 0c		 je	 SHORT $LN16@copyString
$LN2@copyString:

; 257  : 	int i;
; 258  : 
; 259  : 	for( i = 0; i < maxlen; i++ )

  00049	40		 inc	 eax
  0004a	3b c7		 cmp	 eax, edi
  0004c	7c c7		 jl	 SHORT $LL4@copyString
$LN3@copyString:

; 295  : 				return 1;
; 296  : 		}
; 297  : 	}
; 298  : 
; 299  : 	out[i] = '\0';

  0004e	8b 4d 14	 mov	 ecx, DWORD PTR _out$[ebp]
  00051	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
$LN16@copyString:

; 300  : 
; 301  : 	return 1;
; 302  : }

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	b8 01 00 00 00	 mov	 eax, 1
  0005c	5b		 pop	 ebx
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
$LN13@copyString:
  0005f	5f		 pop	 edi

; 266  : 			{
; 267  : 				// ?î“?îž°????îŽ·??
; 268  : 				out[i] = '\0';

  00060	c6 06 00	 mov	 BYTE PTR [esi], 0

; 269  : 				return 0;

  00063	33 c0		 xor	 eax, eax

; 300  : 
; 301  : 	return 1;
; 302  : }

  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
?copyStringUntilDelim@@YAHPAEDH0@Z ENDP			; copyStringUntilDelim
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\tool.cpp
;	COMDAT ?makeEscapeString@@YAPADPAD0H@Z
_TEXT	SEGMENT
_srclen$1$ = -16					; size = 4
tv311 = -12						; size = 4
tv308 = -8						; size = 4
_i$1$ = -4						; size = 4
_src$ = 8						; size = 4
_dest$ = 12						; size = 4
_sizeofdest$ = 16					; size = 4
?makeEscapeString@@YAPADPAD0H@Z PROC			; makeEscapeString, COMDAT

; 648  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 649  : 	int		srclen=strlen(src);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _src$[ebp]
  0000a	56		 push	 esi
  0000b	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  0000e	66 90		 npad	 2
$LL30@makeEscape:
  00010	8a 03		 mov	 al, BYTE PTR [ebx]
  00012	43		 inc	 ebx
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL30@makeEscape
  00017	2b d9		 sub	 ebx, ecx

; 650  : 	int		destindex=0;
; 651  : 	for(int i=0;i<srclen;i++){

  00019	33 d2		 xor	 edx, edx
  0001b	33 f6		 xor	 esi, esi
  0001d	89 5d f0	 mov	 DWORD PTR _srclen$1$[ebp], ebx
  00020	89 55 fc	 mov	 DWORD PTR _i$1$[ebp], edx
  00023	85 db		 test	 ebx, ebx
  00025	0f 8e b1 00 00
	00		 jle	 $LN31@makeEscape

; 649  : 	int		srclen=strlen(src);

  0002b	b9 01 00 00 00	 mov	 ecx, 1
  00030	57		 push	 edi
  00031	8d 7e 02	 lea	 edi, DWORD PTR [esi+2]
  00034	89 4d f8	 mov	 DWORD PTR tv308[ebp], ecx
$LL4@makeEscape:

; 652  : 		if(destindex+1 >= sizeofdest)

  00037	3b 4d 10	 cmp	 ecx, DWORD PTR _sizeofdest$[ebp]
  0003a	0f 8d 9b 00 00
	00		 jge	 $LN32@makeEscape

; 653  : 			break;
; 654  : 		if(IsDBCSLeadByte(src[i])){

  00040	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00043	03 c2		 add	 eax, edx
  00045	89 45 f4	 mov	 DWORD PTR tv311[ebp], eax
  00048	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0004b	50		 push	 eax
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsDBCSLeadByte@4
  00052	85 c0		 test	 eax, eax
  00054	74 31		 je	 SHORT $LN9@makeEscape

; 655  : 			if(destindex+2 < sizeofdest){

  00056	3b 7d 10	 cmp	 edi, DWORD PTR _sizeofdest$[ebp]
  00059	0f 8d 7c 00 00
	00		 jge	 $LN32@makeEscape

; 656  : 				dest[destindex++]=src[i++];

  0005f	8b 4d f4	 mov	 ecx, DWORD PTR tv311[ebp]
  00062	47		 inc	 edi
  00063	8b 55 fc	 mov	 edx, DWORD PTR _i$1$[ebp]

; 657  : 				dest[destindex++]=src[i];

  00066	8b 5d 0c	 mov	 ebx, DWORD PTR _dest$[ebp]
  00069	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  0006c	8b 4d 0c	 mov	 ecx, DWORD PTR _dest$[ebp]
  0006f	88 04 0e	 mov	 BYTE PTR [esi+ecx], al
  00072	46		 inc	 esi
  00073	8b 4d f8	 mov	 ecx, DWORD PTR tv308[ebp]
  00076	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00079	41		 inc	 ecx
  0007a	42		 inc	 edx
  0007b	0f b6 04 02	 movzx	 eax, BYTE PTR [edx+eax]
  0007f	88 04 1e	 mov	 BYTE PTR [esi+ebx], al

; 658  : 			}else
; 659  : 				break;
; 660  : 		}else{

  00082	8b 5d f0	 mov	 ebx, DWORD PTR _srclen$1$[ebp]
  00085	eb 42		 jmp	 SHORT $LN2@makeEscape
$LN9@makeEscape:

; 664  : 				if(src[i]==escapeChar[j].escapechar){

  00087	8b 4d f4	 mov	 ecx, DWORD PTR tv311[ebp]
  0008a	33 c0		 xor	 eax, eax
  0008c	8a 09		 mov	 cl, BYTE PTR [ecx]
  0008e	66 90		 npad	 2
$LL7@makeEscape:
  00090	3a 0c 45 00 00
	00 00		 cmp	 cl, BYTE PTR ?escapeChar@@3PAUtagEscapeChar@@A[eax*2]
  00097	74 11		 je	 SHORT $LN21@makeEscape

; 661  : 			BOOL dirty=FALSE;
; 662  : 			char escapechar='\0';
; 663  : 			for(int j=0;j<sizeof(escapeChar)/sizeof(escapeChar[0]);j++)

  00099	40		 inc	 eax
  0009a	83 f8 04	 cmp	 eax, 4
  0009d	72 f1		 jb	 SHORT $LL7@makeEscape

; 673  : 				}else
; 674  : 					break;
; 675  : 			}else
; 676  : 				dest[destindex++]=src[i];

  0009f	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  000a2	88 0c 06	 mov	 BYTE PTR [esi+eax], cl
  000a5	8b 4d f8	 mov	 ecx, DWORD PTR tv308[ebp]
  000a8	eb 1c		 jmp	 SHORT $LN33@makeEscape
$LN21@makeEscape:

; 665  : 					dirty=TRUE;
; 666  : 					escapechar=escapeChar[j].escapedchar;

  000aa	8a 14 45 01 00
	00 00		 mov	 dl, BYTE PTR ?escapeChar@@3PAUtagEscapeChar@@A[eax*2+1]

; 667  : 					break;
; 668  : 				}
; 669  : 			if(dirty==TRUE){
; 670  : 				if( destindex + 2 < sizeofdest ){

  000b1	3b 7d 10	 cmp	 edi, DWORD PTR _sizeofdest$[ebp]
  000b4	7d 25		 jge	 SHORT $LN32@makeEscape

; 671  : 					dest[destindex++]='\\';

  000b6	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  000b9	8b 4d f8	 mov	 ecx, DWORD PTR tv308[ebp]
  000bc	41		 inc	 ecx
  000bd	c6 04 06 5c	 mov	 BYTE PTR [esi+eax], 92	; 0000005cH
  000c1	46		 inc	 esi
  000c2	47		 inc	 edi

; 672  : 					dest[destindex++]=escapechar;

  000c3	88 14 06	 mov	 BYTE PTR [esi+eax], dl
$LN33@makeEscape:

; 650  : 	int		destindex=0;
; 651  : 	for(int i=0;i<srclen;i++){

  000c6	8b 55 fc	 mov	 edx, DWORD PTR _i$1$[ebp]
$LN2@makeEscape:
  000c9	42		 inc	 edx
  000ca	41		 inc	 ecx
  000cb	46		 inc	 esi
  000cc	89 55 fc	 mov	 DWORD PTR _i$1$[ebp], edx
  000cf	47		 inc	 edi
  000d0	89 4d f8	 mov	 DWORD PTR tv308[ebp], ecx
  000d3	3b d3		 cmp	 edx, ebx
  000d5	0f 8c 5c ff ff
	ff		 jl	 $LL4@makeEscape
$LN32@makeEscape:
  000db	5f		 pop	 edi
$LN31@makeEscape:

; 677  : 		}
; 678  :     }
; 679  :     dest[destindex] = '\0';

  000dc	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  000df	c6 04 06 00	 mov	 BYTE PTR [esi+eax], 0

; 680  :     return dest;

  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx

; 681  : }

  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
?makeEscapeString@@YAPADPAD0H@Z ENDP			; makeEscapeString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\tool.cpp
;	COMDAT ?makeStringFromEscaped@@YAPADPAD@Z
_TEXT	SEGMENT
_srclen$1$ = -4						; size = 4
tv303 = 8						; size = 4
_src$ = 8						; size = 4
?makeStringFromEscaped@@YAPADPAD@Z PROC			; makeStringFromEscaped, COMDAT

; 610  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 611  : 	int		srclen=strlen(src);

  00007	8b 7d 08	 mov	 edi, DWORD PTR _src$[ebp]
  0000a	8b cf		 mov	 ecx, edi
  0000c	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0000f	90		 npad	 1
$LL24@makeString:
  00010	8a 01		 mov	 al, BYTE PTR [ecx]
  00012	41		 inc	 ecx
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL24@makeString
  00017	2b ca		 sub	 ecx, edx

; 612  : 	int		searchindex=0;

  00019	33 f6		 xor	 esi, esi

; 613  : 	for(int i=0;i<srclen;i++){

  0001b	33 db		 xor	 ebx, ebx
  0001d	89 4d fc	 mov	 DWORD PTR _srclen$1$[ebp], ecx
  00020	85 c9		 test	 ecx, ecx
  00022	7e 64		 jle	 SHORT $LN25@makeString
$LL4@makeString:

; 614  : 		if(IsDBCSLeadByte(src[i])){

  00024	8d 04 3b	 lea	 eax, DWORD PTR [ebx+edi]
  00027	89 45 08	 mov	 DWORD PTR tv303[ebp], eax
  0002a	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0002d	50		 push	 eax
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsDBCSLeadByte@4
  00034	8b 55 08	 mov	 edx, DWORD PTR tv303[ebp]
  00037	8a 0a		 mov	 cl, BYTE PTR [edx]
  00039	85 c0		 test	 eax, eax
  0003b	74 0e		 je	 SHORT $LN8@makeString

; 615  : 			src[searchindex++]=src[i++];

  0003d	88 0c 3e	 mov	 BYTE PTR [esi+edi], cl
  00040	46		 inc	 esi

; 616  : 			src[searchindex++]=src[i];

  00041	8a 44 3b 01	 mov	 al, BYTE PTR [ebx+edi+1]
  00045	43		 inc	 ebx
  00046	88 04 3e	 mov	 BYTE PTR [esi+edi], al

; 617  : 		}else{

  00049	eb 1d		 jmp	 SHORT $NEXT$28
$LN8@makeString:

; 618  : 			if(src[i]=='\\'){

  0004b	80 f9 5c	 cmp	 cl, 92			; 0000005cH
  0004e	75 15		 jne	 SHORT $LN10@makeString

; 622  : 					if(escapeChar[j].escapedchar==src[i]){

  00050	8a 4a 01	 mov	 cl, BYTE PTR [edx+1]
  00053	43		 inc	 ebx
  00054	33 c0		 xor	 eax, eax
$LL7@makeString:
  00056	38 0c 45 01 00
	00 00		 cmp	 BYTE PTR ?escapeChar@@3PAUtagEscapeChar@@A[eax*2+1], cl
  0005d	74 1d		 je	 SHORT $LN17@makeString

; 619  : 				int j;
; 620  : 				i++;
; 621  : 				for(j=0;j<sizeof(escapeChar)/sizeof(escapeChar[0]);j++)

  0005f	40		 inc	 eax
  00060	83 f8 04	 cmp	 eax, 4
  00063	72 f1		 jb	 SHORT $LL7@makeString
$LN10@makeString:

; 613  : 	for(int i=0;i<srclen;i++){

  00065	88 0c 3e	 mov	 BYTE PTR [esi+edi], cl
$NEXT$28:
  00068	43		 inc	 ebx
  00069	46		 inc	 esi
  0006a	3b 5d fc	 cmp	 ebx, DWORD PTR _srclen$1$[ebp]
  0006d	7c b5		 jl	 SHORT $LL4@makeString

; 625  : 					}
; 626  : 				src[searchindex++]=src[i];
; 627  : 			}else
; 628  : 				src[searchindex++]=src[i];
; 629  : 		}
; 630  : NEXT:
; 631  : 		;
; 632  : 	}
; 633  : 	src[searchindex]='\0';

  0006f	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0

; 634  : 	return src;
; 635  : }

  00073	8b c7		 mov	 eax, edi
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
$LN17@makeString:

; 623  : 						src[searchindex++]=escapeChar[j].escapechar;

  0007c	8a 04 45 00 00
	00 00		 mov	 al, BYTE PTR ?escapeChar@@3PAUtagEscapeChar@@A[eax*2]
  00083	88 04 3e	 mov	 BYTE PTR [esi+edi], al

; 624  : 						goto NEXT;

  00086	eb e0		 jmp	 SHORT $NEXT$28
$LN25@makeString:

; 625  : 					}
; 626  : 				src[searchindex++]=src[i];
; 627  : 			}else
; 628  : 				src[searchindex++]=src[i];
; 629  : 		}
; 630  : NEXT:
; 631  : 		;
; 632  : 	}
; 633  : 	src[searchindex]='\0';

  00088	88 1c 3e	 mov	 BYTE PTR [esi+edi], bl

; 634  : 	return src;
; 635  : }

  0008b	8b c7		 mov	 eax, edi
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
?makeStringFromEscaped@@YAPADPAD@Z ENDP			; makeStringFromEscaped
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\tool.cpp
;	COMDAT ?makeCharFromEscaped@@YADD@Z
_TEXT	SEGMENT
_c$ = 8							; size = 1
?makeCharFromEscaped@@YADD@Z PROC			; makeCharFromEscaped, COMDAT

; 585  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 586  : 	int i;
; 587  : 
; 588  : 	for( i = 0; i < sizeof( escapeChar )/sizeof( escapeChar[0] ); i++ )

  00003	8a 45 08	 mov	 al, BYTE PTR _c$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@makeCharFr:

; 589  : 	{
; 590  : 		if( escapeChar[i].escapedchar == c )

  00010	38 04 4d 01 00
	00 00		 cmp	 BYTE PTR ?escapeChar@@3PAUtagEscapeChar@@A[ecx*2+1], al
  00017	74 08		 je	 SHORT $LN8@makeCharFr

; 586  : 	int i;
; 587  : 
; 588  : 	for( i = 0; i < sizeof( escapeChar )/sizeof( escapeChar[0] ); i++ )

  00019	41		 inc	 ecx
  0001a	83 f9 04	 cmp	 ecx, 4
  0001d	72 f1		 jb	 SHORT $LL4@makeCharFr

; 593  : 			break;
; 594  : 		}
; 595  : 	}
; 596  : 
; 597  : 	return c;
; 598  : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
$LN8@makeCharFr:

; 591  : 		{
; 592  : 			c = escapeChar[i].escapechar;

  00021	8a 04 4d 00 00
	00 00		 mov	 al, BYTE PTR ?escapeChar@@3PAUtagEscapeChar@@A[ecx*2]

; 593  : 			break;
; 594  : 		}
; 595  : 	}
; 596  : 
; 597  : 	return c;
; 598  : }

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?makeCharFromEscaped@@YADD@Z ENDP			; makeCharFromEscaped
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\tool.cpp
;	COMDAT ?isOnlySpaceChars@@YAHPAD@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
?isOnlySpaceChars@@YAHPAD@Z PROC			; isOnlySpaceChars, COMDAT

; 490  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 491  : 	int i = 0;
; 492  : 	int returnflag = 0;
; 493  : 
; 494  : 	while( data[i] != '\0' )

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _data$[ebp]
  00007	56		 push	 esi
  00008	33 f6		 xor	 esi, esi
  0000a	57		 push	 edi
  0000b	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  0000e	74 49		 je	 SHORT $LN16@isOnlySpac
  00010	b9 01 00 00 00	 mov	 ecx, 1
$LL2@isOnlySpac:

; 495  : 	{
; 496  : 		returnflag = 0;
; 497  : 		if( (unsigned char)data[i] == ' ' )

  00015	8a 04 1e	 mov	 al, BYTE PTR [esi+ebx]
  00018	33 ff		 xor	 edi, edi
  0001a	3c 20		 cmp	 al, 32			; 00000020H

; 498  : 			returnflag = 1;
; 499  : 		if( IsDBCSLeadByte( data[i] ) )

  0001c	50		 push	 eax
  0001d	0f 44 f9	 cmove	 edi, ecx
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsDBCSLeadByte@4
  00026	85 c0		 test	 eax, eax
  00028	74 14		 je	 SHORT $LN17@isOnlySpac

; 500  : 		{
; 501  : 			if( (unsigned char)data[i] == 0x81
; 502  : 			 && (unsigned char)data[i+1] == 0x40 )

  0002a	80 3c 1e 81	 cmp	 BYTE PTR [esi+ebx], 129	; 00000081H
  0002e	75 0d		 jne	 SHORT $LN6@isOnlySpac
  00030	80 7c 1e 01 40	 cmp	 BYTE PTR [esi+ebx+1], 64 ; 00000040H
  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	0f 44 f8	 cmove	 edi, eax
$LN6@isOnlySpac:

; 503  : 			{
; 504  : 				returnflag = 1;
; 505  : 			}
; 506  : 			i++;

  0003d	46		 inc	 esi
$LN17@isOnlySpac:

; 507  : 		}
; 508  : 		if( returnflag == 0 )

  0003e	85 ff		 test	 edi, edi
  00040	74 17		 je	 SHORT $LN16@isOnlySpac

; 509  : 			return 0;
; 510  : 		i++;

  00042	46		 inc	 esi
  00043	b9 01 00 00 00	 mov	 ecx, 1
  00048	80 3c 1e 00	 cmp	 BYTE PTR [esi+ebx], 0
  0004c	75 c7		 jne	 SHORT $LL2@isOnlySpac

; 511  : 	}
; 512  : 
; 513  : 	if( i == 0 )

  0004e	85 f6		 test	 esi, esi
  00050	74 07		 je	 SHORT $LN16@isOnlySpac

; 514  : 		return 0;
; 515  : 
; 516  : 	return returnflag;

  00052	8b c7		 mov	 eax, edi
  00054	5f		 pop	 edi

; 517  : }

  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN16@isOnlySpac:
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	33 c0		 xor	 eax, eax
  0005d	5b		 pop	 ebx
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?isOnlySpaceChars@@YAHPAD@Z ENDP			; isOnlySpaceChars
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\tool.cpp
;	COMDAT ?insertChar@@YAXPADDH@Z
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_character$ = 12					; size = 1
_whereToInsert$ = 16					; size = 4
?insertChar@@YAXPADDH@Z PROC				; insertChar, COMDAT

; 551  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 552  : 	int bufferLength, i;
; 553  : 
; 554  : 	bufferLength = strlen( buffer );

  00004	8b 75 08	 mov	 esi, DWORD PTR _buffer$[ebp]
  00007	8b ce		 mov	 ecx, esi
  00009	57		 push	 edi
  0000a	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0000d	0f 1f 00	 npad	 3
$LL10@insertChar:
  00010	8a 01		 mov	 al, BYTE PTR [ecx]
  00012	41		 inc	 ecx
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL10@insertChar

; 555  : 
; 556  : 	for( i = 0; i <= bufferLength - whereToInsert; i++ )

  00017	8b 7d 10	 mov	 edi, DWORD PTR _whereToInsert$[ebp]
  0001a	2b ca		 sub	 ecx, edx
  0001c	8b d1		 mov	 edx, ecx
  0001e	2b d7		 sub	 edx, edi
  00020	78 11		 js	 SHORT $LN11@insertChar

; 552  : 	int bufferLength, i;
; 553  : 
; 554  : 	bufferLength = strlen( buffer );

  00022	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
  00025	42		 inc	 edx
$LL4@insertChar:

; 557  : 	{
; 558  : 		buffer[bufferLength+1-i] = buffer[bufferLength-i];

  00026	8a 08		 mov	 cl, BYTE PTR [eax]
  00028	8d 40 ff	 lea	 eax, DWORD PTR [eax-1]
  0002b	88 48 02	 mov	 BYTE PTR [eax+2], cl
  0002e	83 ea 01	 sub	 edx, 1
  00031	75 f3		 jne	 SHORT $LL4@insertChar
$LN11@insertChar:

; 559  : 	}
; 560  : 	buffer[whereToInsert] = character;
; 561  : }

  00033	8a 45 0c	 mov	 al, BYTE PTR _character$[ebp]
  00036	88 04 3e	 mov	 BYTE PTR [esi+edi], al
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?insertChar@@YAXPADDH@Z ENDP				; insertChar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\tool.cpp
;	COMDAT ?insertString@@YAXPAD0H@Z
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_string$ = 12						; size = 4
_whereToInsert$ = 16					; size = 4
?insertString@@YAXPAD0H@Z PROC				; insertString, COMDAT

; 527  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 528  : 	int stringLength, bufferLength, i;
; 529  : 
; 530  : 	stringLength = strlen( string );

  00006	8b 7d 0c	 mov	 edi, DWORD PTR _string$[ebp]
  00009	8b d7		 mov	 edx, edi
  0000b	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
  0000e	66 90		 npad	 2
$LL19@insertStri:
  00010	8a 02		 mov	 al, BYTE PTR [edx]
  00012	42		 inc	 edx
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL19@insertStri
  00017	2b d1		 sub	 edx, ecx

; 531  : 	bufferLength = strlen( buffer );

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0001c	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  0001f	90		 npad	 1
$LL20@insertStri:
  00020	8a 01		 mov	 al, BYTE PTR [ecx]
  00022	41		 inc	 ecx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL20@insertStri

; 532  : 
; 533  : 	for( i = 0; i <= bufferLength - whereToInsert; i++ )

  00027	8b 5d 10	 mov	 ebx, DWORD PTR _whereToInsert$[ebp]
  0002a	2b ce		 sub	 ecx, esi
  0002c	8b f1		 mov	 esi, ecx
  0002e	2b f3		 sub	 esi, ebx
  00030	78 12		 js	 SHORT $LN3@insertStri

; 528  : 	int stringLength, bufferLength, i;
; 529  : 
; 530  : 	stringLength = strlen( string );

  00032	03 4d 08	 add	 ecx, DWORD PTR _buffer$[ebp]
  00035	46		 inc	 esi
$LL4@insertStri:

; 534  : 	{
; 535  : 		buffer[bufferLength+stringLength-i] = buffer[bufferLength-i];

  00036	8a 01		 mov	 al, BYTE PTR [ecx]
  00038	8d 49 ff	 lea	 ecx, DWORD PTR [ecx-1]
  0003b	88 44 11 01	 mov	 BYTE PTR [ecx+edx+1], al
  0003f	83 ee 01	 sub	 esi, 1
  00042	75 f2		 jne	 SHORT $LL4@insertStri
$LN3@insertStri:

; 536  : 	}
; 537  : 	for( i = 0; i < stringLength; i++ )

  00044	33 c0		 xor	 eax, eax
  00046	85 d2		 test	 edx, edx
  00048	7e 11		 jle	 SHORT $LN6@insertStri
  0004a	8b 75 08	 mov	 esi, DWORD PTR _buffer$[ebp]
  0004d	03 f3		 add	 esi, ebx
  0004f	90		 npad	 1
$LL13@insertStri:

; 538  : 	{
; 539  : 		buffer[whereToInsert+i] = string[i];

  00050	8a 0c 38	 mov	 cl, BYTE PTR [eax+edi]
  00053	88 0c 06	 mov	 BYTE PTR [esi+eax], cl
  00056	40		 inc	 eax
  00057	3b c2		 cmp	 eax, edx
  00059	7c f5		 jl	 SHORT $LL13@insertStri
$LN6@insertStri:
  0005b	5f		 pop	 edi

; 540  : 	}
; 541  : }

  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?insertString@@YAXPAD0H@Z ENDP				; insertString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\tool.cpp
;	COMDAT ?intToRect@@YA?AUtagRECT@@HHHH@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
_left$ = 12						; size = 4
_top$ = 16						; size = 4
_right$ = 20						; size = 4
_bottom$ = 24						; size = 4
?intToRect@@YA?AUtagRECT@@HHHH@Z PROC			; intToRect, COMDAT

; 476  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 477  : 	RECT rc = { left, top, right, bottom };

  00003	8b 45 08	 mov	 eax, DWORD PTR $T1[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _left$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR _top$[ebp]
  0000e	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00011	8b 4d 14	 mov	 ecx, DWORD PTR _right$[ebp]
  00014	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00017	8b 4d 18	 mov	 ecx, DWORD PTR _bottom$[ebp]
  0001a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 478  : 
; 479  : 	return rc;
; 480  : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?intToRect@@YA?AUtagRECT@@HHHH@Z ENDP			; intToRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\tool.cpp
;	COMDAT ?strncmpi@@YAHPAD0H@Z
_TEXT	SEGMENT
_s1$ = 8						; size = 4
_s2$ = 12						; size = 4
_len$ = 16						; size = 4
?strncmpi@@YAHPAD0H@Z PROC				; strncmpi, COMDAT

; 453  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 454  : 	int i;
; 455  : 	int c1, c2;
; 456  : 
; 457  : 	for( i = 0; i < len; i++ )

  00004	33 db		 xor	 ebx, ebx
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	39 5d 10	 cmp	 DWORD PTR _len$[ebp], ebx
  0000b	7e 3c		 jle	 SHORT $LN3@strncmpi
  0000d	8b 45 08	 mov	 eax, DWORD PTR _s1$[ebp]
  00010	8b 75 0c	 mov	 esi, DWORD PTR _s2$[ebp]
  00013	2b c6		 sub	 eax, esi
  00015	89 45 08	 mov	 DWORD PTR _s1$[ebp], eax
$LL4@strncmpi:

; 458  : 	{
; 459  : 		if( s1[i] == '\0' || s2[i] == '\0' )

  00018	8a 04 30	 mov	 al, BYTE PTR [eax+esi]
  0001b	84 c0		 test	 al, al
  0001d	74 2a		 je	 SHORT $LN3@strncmpi
  0001f	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00022	74 25		 je	 SHORT $LN3@strncmpi

; 460  : 			return 0;
; 461  : 
; 462  : 		c1 = tolower( s1[i] );

  00024	0f be c0	 movsx	 eax, al
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _tolower

; 463  : 		c2 = tolower( s2[i] );

  0002d	0f be 0e	 movsx	 ecx, BYTE PTR [esi]
  00030	8b f8		 mov	 edi, eax
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 _tolower
  00038	83 c4 08	 add	 esp, 8

; 464  : 
; 465  : 		if( c1 != c2 )

  0003b	3b f8		 cmp	 edi, eax
  0003d	75 11		 jne	 SHORT $LN11@strncmpi

; 454  : 	int i;
; 455  : 	int c1, c2;
; 456  : 
; 457  : 	for( i = 0; i < len; i++ )

  0003f	8b 45 08	 mov	 eax, DWORD PTR _s1$[ebp]
  00042	43		 inc	 ebx
  00043	46		 inc	 esi
  00044	3b 5d 10	 cmp	 ebx, DWORD PTR _len$[ebp]
  00047	7c cf		 jl	 SHORT $LL4@strncmpi
$LN3@strncmpi:
  00049	5f		 pop	 edi

; 466  : 			return 1;
; 467  : 	}
; 468  : 
; 469  : 	return 0;
; 470  : }

  0004a	5e		 pop	 esi
  0004b	33 c0		 xor	 eax, eax
  0004d	5b		 pop	 ebx
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
$LN11@strncmpi:
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	b8 01 00 00 00	 mov	 eax, 1
  00057	5b		 pop	 ebx
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?strncmpi@@YAHPAD0H@Z ENDP				; strncmpi
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\tool.cpp
;	COMDAT ?jDecode@@YAXPADHH0PAH@Z
_TEXT	SEGMENT
tv347 = -8						; size = 4
$T1 = -4						; size = 4
_src$ = 8						; size = 4
_srclen$ = 12						; size = 4
_key$ = 16						; size = 4
_decoded$ = 20						; size = 4
_decodedlen$ = 24					; size = 4
_sum$1$ = 27						; size = 1
?jDecode@@YAXPADHH0PAH@Z PROC				; jDecode, COMDAT

; 755  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 760  : 	sum = src[abs( key%(*decodedlen) )];

  00006	8b 4d 10	 mov	 ecx, DWORD PTR _key$[ebp]
  00009	8b c1		 mov	 eax, ecx
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	8b 75 0c	 mov	 esi, DWORD PTR _srclen$[ebp]
  00010	99		 cdq
  00011	4e		 dec	 esi
  00012	f7 fe		 idiv	 esi
  00014	8b 5d 18	 mov	 ebx, DWORD PTR _decodedlen$[ebp]
  00017	8b c2		 mov	 eax, edx
  00019	99		 cdq
  0001a	33 c2		 xor	 eax, edx
  0001c	2b c2		 sub	 eax, edx
  0001e	89 33		 mov	 DWORD PTR [ebx], esi
  00020	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  00023	57		 push	 edi
  00024	33 ff		 xor	 edi, edi
  00026	8a 04 10	 mov	 al, BYTE PTR [eax+edx]
  00029	88 45 1b	 mov	 BYTE PTR _sum$1$[ebp], al

; 761  : 
; 762  : 	for( i=0; i < srclen; i++ )

  0002c	39 7d 0c	 cmp	 DWORD PTR _srclen$[ebp], edi
  0002f	0f 8e 9d 00 00
	00		 jle	 $LN3@jDecode

; 756  : 	char sum;
; 757  : 	int i;
; 758  : 
; 759  : 	*decodedlen = srclen - 1;

  00035	8b 75 14	 mov	 esi, DWORD PTR _decoded$[ebp]
  00038	2b d6		 sub	 edx, esi
  0003a	89 55 08	 mov	 DWORD PTR _src$[ebp], edx

; 761  : 
; 762  : 	for( i=0; i < srclen; i++ )

  0003d	eb 04		 jmp	 SHORT $LN4@jDecode
  0003f	90		 npad	 1
$LL23@jDecode:
  00040	8b 75 14	 mov	 esi, DWORD PTR _decoded$[ebp]
$LN4@jDecode:

; 763  : 	{
; 764  : 		if( abs( (key%(*decodedlen)) ) > i )

  00043	8b 03		 mov	 eax, DWORD PTR [ebx]
  00045	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00048	8b c7		 mov	 eax, edi
  0004a	0f af c7	 imul	 eax, edi
  0004d	89 45 f8	 mov	 DWORD PTR tv347[ebp], eax
  00050	8b c1		 mov	 eax, ecx
  00052	99		 cdq
  00053	f7 3b		 idiv	 DWORD PTR [ebx]
  00055	8b c2		 mov	 eax, edx
  00057	99		 cdq
  00058	33 c2		 xor	 eax, edx
  0005a	2b c2		 sub	 eax, edx
  0005c	3b c7		 cmp	 eax, edi
  0005e	7e 2b		 jle	 SHORT $LN20@jDecode

; 765  : 		{
; 766  : 			decoded[i] = src[i] - sum*((i*i)%3);

  00060	8b 45 f8	 mov	 eax, DWORD PTR tv347[ebp]
  00063	b9 03 00 00 00	 mov	 ecx, 3
  00068	99		 cdq
  00069	03 f7		 add	 esi, edi
  0006b	f7 f9		 idiv	 ecx
  0006d	0f be 45 1b	 movsx	 eax, BYTE PTR _sum$1$[ebp]
  00071	0f be ca	 movsx	 ecx, dl
  00074	0f af c8	 imul	 ecx, eax
  00077	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0007a	8a 04 30	 mov	 al, BYTE PTR [eax+esi]
  0007d	2a c1		 sub	 al, cl
  0007f	8b 4d 10	 mov	 ecx, DWORD PTR _key$[ebp]
  00082	88 06		 mov	 BYTE PTR [esi], al
  00084	8b 33		 mov	 esi, DWORD PTR [ebx]
  00086	89 75 fc	 mov	 DWORD PTR $T1[ebp], esi
  00089	eb 02		 jmp	 SHORT $LN8@jDecode
$LN20@jDecode:
  0008b	8b 33		 mov	 esi, DWORD PTR [ebx]
$LN8@jDecode:

; 767  : 		}
; 768  : 
; 769  : 		if( abs( (key%(*decodedlen)) ) < i )

  0008d	8b c1		 mov	 eax, ecx
  0008f	99		 cdq
  00090	f7 7d fc	 idiv	 DWORD PTR $T1[ebp]
  00093	8b c2		 mov	 eax, edx
  00095	99		 cdq
  00096	33 c2		 xor	 eax, edx
  00098	2b c2		 sub	 eax, edx
  0009a	3b c7		 cmp	 eax, edi
  0009c	7d 2a		 jge	 SHORT $LN2@jDecode

; 770  : 		{
; 771  : 			decoded[i-1] = src[i] - sum*((i*i)%7);

  0009e	8b 45 f8	 mov	 eax, DWORD PTR tv347[ebp]
  000a1	b9 07 00 00 00	 mov	 ecx, 7
  000a6	99		 cdq
  000a7	f7 f9		 idiv	 ecx
  000a9	0f be 45 1b	 movsx	 eax, BYTE PTR _sum$1$[ebp]
  000ad	8b 75 14	 mov	 esi, DWORD PTR _decoded$[ebp]
  000b0	03 f7		 add	 esi, edi
  000b2	0f be ca	 movsx	 ecx, dl
  000b5	0f af c8	 imul	 ecx, eax
  000b8	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  000bb	8a 04 30	 mov	 al, BYTE PTR [eax+esi]
  000be	2a c1		 sub	 al, cl
  000c0	8b 4d 10	 mov	 ecx, DWORD PTR _key$[ebp]
  000c3	88 46 ff	 mov	 BYTE PTR [esi-1], al
  000c6	8b 33		 mov	 esi, DWORD PTR [ebx]
$LN2@jDecode:

; 761  : 
; 762  : 	for( i=0; i < srclen; i++ )

  000c8	47		 inc	 edi
  000c9	3b 7d 0c	 cmp	 edi, DWORD PTR _srclen$[ebp]
  000cc	0f 8c 6e ff ff
	ff		 jl	 $LL23@jDecode
$LN3@jDecode:

; 772  : 		}
; 773  : 	}
; 774  : 	for( i = 0; i < (*decodedlen); i++ )

  000d2	33 c9		 xor	 ecx, ecx
  000d4	85 f6		 test	 esi, esi
  000d6	7e 6f		 jle	 SHORT $LN6@jDecode
  000d8	8b 7d 10	 mov	 edi, DWORD PTR _key$[ebp]
  000db	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  000e0	f7 ef		 imul	 edi
  000e2	03 d7		 add	 edx, edi
  000e4	c1 fa 02	 sar	 edx, 2
  000e7	8b f2		 mov	 esi, edx
  000e9	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  000ec	03 f2		 add	 esi, edx
  000ee	8d 04 f5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*8]
  000f5	2b c6		 sub	 eax, esi
  000f7	8b f7		 mov	 esi, edi
  000f9	2b f0		 sub	 esi, eax
  000fb	0f 1f 44 00 00	 npad	 5
$LL7@jDecode:

; 775  : 	{
; 776  : 		if( ((key%7) == (i%5)) || ((key%2) == (i%2)) )

  00100	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00105	f7 e9		 imul	 ecx
  00107	d1 fa		 sar	 edx, 1
  00109	8b c2		 mov	 eax, edx
  0010b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0010e	03 c2		 add	 eax, edx
  00110	8b d1		 mov	 edx, ecx
  00112	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00115	2b d0		 sub	 edx, eax
  00117	3b f2		 cmp	 esi, edx
  00119	74 21		 je	 SHORT $LN11@jDecode
  0011b	8b d1		 mov	 edx, ecx
  0011d	81 e2 01 00 00
	80		 and	 edx, -2147483647	; 80000001H
  00123	79 05		 jns	 SHORT $LN24@jDecode
  00125	4a		 dec	 edx
  00126	83 ca fe	 or	 edx, -2			; fffffffeH
  00129	42		 inc	 edx
$LN24@jDecode:
  0012a	8b c7		 mov	 eax, edi
  0012c	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00131	79 05		 jns	 SHORT $LN25@jDecode
  00133	48		 dec	 eax
  00134	83 c8 fe	 or	 eax, -2			; fffffffeH
  00137	40		 inc	 eax
$LN25@jDecode:
  00138	3b c2		 cmp	 eax, edx
  0013a	75 06		 jne	 SHORT $LN5@jDecode
$LN11@jDecode:

; 777  : 		{
; 778  : 			decoded[i] = ~decoded[i];

  0013c	8b 55 14	 mov	 edx, DWORD PTR _decoded$[ebp]
  0013f	f6 14 11	 not	 BYTE PTR [ecx+edx]
$LN5@jDecode:

; 772  : 		}
; 773  : 	}
; 774  : 	for( i = 0; i < (*decodedlen); i++ )

  00142	41		 inc	 ecx
  00143	3b 0b		 cmp	 ecx, DWORD PTR [ebx]
  00145	7c b9		 jl	 SHORT $LL7@jDecode
$LN6@jDecode:
  00147	5f		 pop	 edi

; 779  : 		}
; 780  : 	}
; 781  : }

  00148	5e		 pop	 esi
  00149	5b		 pop	 ebx
  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c3		 ret	 0
?jDecode@@YAXPADHH0PAH@Z ENDP				; jDecode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\tool.cpp
;	COMDAT ?jEncode@@YAXPADHH0PAHH@Z
_TEXT	SEGMENT
tv388 = -4						; size = 4
_src$ = 8						; size = 4
tv404 = 12						; size = 4
_src$1$ = 12						; size = 4
_srclen$ = 12						; size = 4
_key$ = 16						; size = 4
_encoded$ = 20						; size = 4
_encodedlen$ = 24					; size = 4
tv379 = 28						; size = 4
_maxencodedlen$ = 28					; size = 4
?jEncode@@YAXPADHH0PAHH@Z PROC				; jEncode, COMDAT

; 697  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 698  : 	char sum = 0;
; 699  : 	int i;
; 700  : 
; 701  : 	if( srclen+1 > maxencodedlen )

  00004	8b 4d 1c	 mov	 ecx, DWORD PTR _maxencodedlen$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 7d 0c	 mov	 edi, DWORD PTR _srclen$[ebp]
  0000d	32 ff		 xor	 bh, bh
  0000f	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00012	3b c1		 cmp	 eax, ecx
  00014	7e 2f		 jle	 SHORT $LN38@jEncode

; 702  : 	{
; 703  : 		// ???????î—š?? 1 ????
; 704  : 		// ????????????????î–•????????
; 705  : 		*encodedlen = maxencodedlen;

  00016	8b 7d 18	 mov	 edi, DWORD PTR _encodedlen$[ebp]

; 706  : 		for( i = 0; i < (*encodedlen); i++ )

  00019	33 d2		 xor	 edx, edx
  0001b	89 0f		 mov	 DWORD PTR [edi], ecx
  0001d	85 c9		 test	 ecx, ecx
  0001f	0f 8e 2e 01 00
	00		 jle	 $LN9@jEncode
  00025	8b 75 08	 mov	 esi, DWORD PTR _src$[ebp]
  00028	8b 4d 14	 mov	 ecx, DWORD PTR _encoded$[ebp]
  0002b	2b f1		 sub	 esi, ecx
  0002d	0f 1f 00	 npad	 3
$LL4@jEncode:

; 707  : 		{
; 708  : 			encoded[i] = src[i];

  00030	8a 04 0e	 mov	 al, BYTE PTR [esi+ecx]
  00033	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00036	88 41 ff	 mov	 BYTE PTR [ecx-1], al
  00039	42		 inc	 edx
  0003a	3b 17		 cmp	 edx, DWORD PTR [edi]
  0003c	7c f2		 jl	 SHORT $LL4@jEncode

; 741  : 			}
; 742  : 		}
; 743  : 	}
; 744  : }

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
$LN38@jEncode:

; 709  : 		}
; 710  : 	}
; 711  : 
; 712  : 	if( srclen+1 <= maxencodedlen )
; 713  : 	{
; 714  : 		// ??????????
; 715  : 		*encodedlen = srclen + 1;

  00045	8b 4d 18	 mov	 ecx, DWORD PTR _encodedlen$[ebp]
  00048	33 f6		 xor	 esi, esi
  0004a	89 01		 mov	 DWORD PTR [ecx], eax

; 716  : 		for( i = 0; i < srclen; i++ )

  0004c	8b 4d 10	 mov	 ecx, DWORD PTR _key$[ebp]
  0004f	85 ff		 test	 edi, edi
  00051	7e 77		 jle	 SHORT $LN6@jEncode
  00053	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00058	f7 e9		 imul	 ecx
  0005a	03 d1		 add	 edx, ecx
  0005c	c1 fa 02	 sar	 edx, 2
  0005f	8b ca		 mov	 ecx, edx
  00061	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00064	03 ca		 add	 ecx, edx
  00066	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0006d	2b c1		 sub	 eax, ecx
  0006f	8b 4d 10	 mov	 ecx, DWORD PTR _key$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00077	89 4d 0c	 mov	 DWORD PTR tv404[ebp], ecx
  0007a	66 0f 1f 44 00
	00		 npad	 6
$LL27@jEncode:

; 717  : 		{
; 718  : 			sum = sum + src[i];

  00080	8a 1c 06	 mov	 bl, BYTE PTR [esi+eax]

; 719  : 			// î“î™ª??7?î›º????2?î›º???????????îœšî˜¿
; 720  : 			if( ((key%7) == (i%5)) || ((key%2) == (i%2)) )

  00083	8b ce		 mov	 ecx, esi
  00085	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  0008a	02 fb		 add	 bh, bl
  0008c	f7 e6		 mul	 esi
  0008e	c1 ea 02	 shr	 edx, 2
  00091	8d 04 92	 lea	 eax, DWORD PTR [edx+edx*4]
  00094	2b c8		 sub	 ecx, eax
  00096	39 4d 0c	 cmp	 DWORD PTR tv404[ebp], ecx
  00099	74 18		 je	 SHORT $LN28@jEncode
  0009b	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  0009e	8b ce		 mov	 ecx, esi
  000a0	83 e1 01	 and	 ecx, 1
  000a3	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  000a8	79 05		 jns	 SHORT $LN41@jEncode
  000aa	48		 dec	 eax
  000ab	83 c8 fe	 or	 eax, -2			; fffffffeH
  000ae	40		 inc	 eax
$LN41@jEncode:
  000af	3b c1		 cmp	 eax, ecx
  000b1	75 0a		 jne	 SHORT $LN40@jEncode
$LN28@jEncode:

; 721  : 			{
; 722  : 				src[i] = ~src[i];

  000b3	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  000b6	f6 d3		 not	 bl
  000b8	88 1c 06	 mov	 BYTE PTR [esi+eax], bl
  000bb	eb 03		 jmp	 SHORT $LN39@jEncode
$LN40@jEncode:

; 719  : 			// î“î™ª??7?î›º????2?î›º???????????îœšî˜¿
; 720  : 			if( ((key%7) == (i%5)) || ((key%2) == (i%2)) )

  000bd	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
$LN39@jEncode:

; 716  : 		for( i = 0; i < srclen; i++ )

  000c0	46		 inc	 esi
  000c1	3b f7		 cmp	 esi, edi
  000c3	7c bb		 jl	 SHORT $LL27@jEncode

; 721  : 			{
; 722  : 				src[i] = ~src[i];

  000c5	8b 45 18	 mov	 eax, DWORD PTR _encodedlen$[ebp]
  000c8	8b 00		 mov	 eax, DWORD PTR [eax]
$LN6@jEncode:

; 723  : 			}
; 724  : 		}
; 725  : 		for( i = 0; i < (*encodedlen); i++ )

  000ca	33 c9		 xor	 ecx, ecx
  000cc	85 c0		 test	 eax, eax
  000ce	0f 8e 7f 00 00
	00		 jle	 $LN9@jEncode
  000d4	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  000d7	99		 cdq
  000d8	f7 ff		 idiv	 edi
  000da	c7 45 1c 03 00
	00 00		 mov	 DWORD PTR tv379[ebp], 3

; 726  : 		{
; 727  : 			if( abs( (key%srclen) ) > i )

  000e1	8b c2		 mov	 eax, edx
  000e3	c7 45 fc 07 00
	00 00		 mov	 DWORD PTR tv388[ebp], 7
  000ea	99		 cdq
  000eb	8b f8		 mov	 edi, eax
  000ed	8b 45 14	 mov	 eax, DWORD PTR _encoded$[ebp]
  000f0	33 fa		 xor	 edi, edx
  000f2	2b fa		 sub	 edi, edx
  000f4	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  000f7	2b d0		 sub	 edx, eax
  000f9	89 55 0c	 mov	 DWORD PTR _src$1$[ebp], edx
  000fc	8b 55 18	 mov	 edx, DWORD PTR _encodedlen$[ebp]
  000ff	90		 npad	 1
$LL10@jEncode:
  00100	3b f9		 cmp	 edi, ecx
  00102	7e 1d		 jle	 SHORT $LN15@jEncode

; 728  : 			{
; 729  : 				encoded[i] = src[i] + sum*((i*i)%3);	// ?????????

  00104	8d 34 01	 lea	 esi, DWORD PTR [ecx+eax]
  00107	8b c1		 mov	 eax, ecx
  00109	0f af c1	 imul	 eax, ecx
  0010c	99		 cdq
  0010d	f7 7d 1c	 idiv	 DWORD PTR tv379[ebp]
  00110	0f be c7	 movsx	 eax, bh
  00113	0f be d2	 movsx	 edx, dl
  00116	0f af d0	 imul	 edx, eax
  00119	8b 45 0c	 mov	 eax, DWORD PTR _src$1$[ebp]
  0011c	02 14 30	 add	 dl, BYTE PTR [eax+esi]

; 730  : 			}

  0011f	eb 25		 jmp	 SHORT $LN42@jEncode
$LN15@jEncode:

; 731  : 			else
; 732  : 			// key%srclen??î–º?î“»??????????î–º?
; 733  : 			if( abs( (key%srclen) ) == i )

  00121	75 05		 jne	 SHORT $LN17@jEncode

; 734  : 			{
; 735  : 				encoded[i] = sum;

  00123	88 3c 01	 mov	 BYTE PTR [ecx+eax], bh

; 736  : 			}

  00126	eb 26		 jmp	 SHORT $LN8@jEncode
$LN17@jEncode:

; 737  : 			else
; 738  : 			if( abs( (key%srclen) ) < i )

  00128	7d 24		 jge	 SHORT $LN8@jEncode

; 739  : 			{
; 740  : 				encoded[i] = src[i-1] + sum*((i*i)%7);	// ?????????

  0012a	8d 34 01	 lea	 esi, DWORD PTR [ecx+eax]
  0012d	8b c1		 mov	 eax, ecx
  0012f	0f af c1	 imul	 eax, ecx
  00132	99		 cdq
  00133	f7 7d fc	 idiv	 DWORD PTR tv388[ebp]
  00136	0f be c7	 movsx	 eax, bh
  00139	0f be d2	 movsx	 edx, dl
  0013c	0f af d0	 imul	 edx, eax
  0013f	8b 45 0c	 mov	 eax, DWORD PTR _src$1$[ebp]
  00142	02 54 30 ff	 add	 dl, BYTE PTR [eax+esi-1]
$LN42@jEncode:

; 723  : 			}
; 724  : 		}
; 725  : 		for( i = 0; i < (*encodedlen); i++ )

  00146	8b 45 14	 mov	 eax, DWORD PTR _encoded$[ebp]
  00149	88 16		 mov	 BYTE PTR [esi], dl
  0014b	8b 55 18	 mov	 edx, DWORD PTR _encodedlen$[ebp]
$LN8@jEncode:
  0014e	41		 inc	 ecx
  0014f	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00151	7c ad		 jl	 SHORT $LL10@jEncode
$LN9@jEncode:
  00153	5f		 pop	 edi

; 741  : 			}
; 742  : 		}
; 743  : 	}
; 744  : }

  00154	5e		 pop	 esi
  00155	5b		 pop	 ebx
  00156	8b e5		 mov	 esp, ebp
  00158	5d		 pop	 ebp
  00159	c3		 ret	 0
?jEncode@@YAXPADHH0PAHH@Z ENDP				; jEncode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\tool.cpp
;	COMDAT ?getInteger62Token@@YAHPADDH@Z
_TEXT	SEGMENT
_s$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_src$ = 8						; size = 4
_delim$ = 12						; size = 1
_count$ = 16						; size = 4
?getInteger62Token@@YAHPADDH@Z PROC			; getInteger62Token, COMDAT

; 432  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]

; 433  : 	char  s[128];
; 434  : 
; 435  : 	getStringToken( src, delim, count, sizeof( s )-1, s );

  00016	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  0001c	51		 push	 ecx
  0001d	6a 7f		 push	 127			; 0000007fH
  0001f	ff 75 10	 push	 DWORD PTR _count$[ebp]
  00022	ff 75 0c	 push	 DWORD PTR _delim$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0002b	83 c4 14	 add	 esp, 20			; 00000014H

; 436  : 	if( s[0] == '\0' )

  0002e	80 bd 7c ff ff
	ff 00		 cmp	 BYTE PTR _s$[ebp], 0
  00035	75 11		 jne	 SHORT $LN2@getInteger

; 437  : 		return -1;

  00037	83 c8 ff	 or	 eax, -1

; 440  : }

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003d	33 cd		 xor	 ecx, ebp
  0003f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
$LN2@getInteger:

; 438  : 
; 439  :     return a62toi( s );

  00048	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ?a62toi@@YAHPAD@Z	; a62toi

; 440  : }

  00054	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00057	83 c4 04	 add	 esp, 4
  0005a	33 cd		 xor	 ecx, ebp
  0005c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?getInteger62Token@@YAHPADDH@Z ENDP			; getInteger62Token
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\tool.cpp
;	COMDAT ?a62toi@@YAHPAD@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?a62toi@@YAHPAD@Z PROC					; a62toi, COMDAT

; 395  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 396  : 	int ret = 0;
; 397  : 	int fugo = 1;
; 398  : 
; 399  : 	while( *a != NULL )

  00004	8b 75 08	 mov	 esi, DWORD PTR _a$[ebp]
  00007	33 c0		 xor	 eax, eax
  00009	57		 push	 edi
  0000a	8a 16		 mov	 dl, BYTE PTR [esi]
  0000c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000f	84 d2		 test	 dl, dl
  00011	74 4f		 je	 SHORT $LN3@a62toi
$LL2@a62toi:

; 400  : 	{
; 401  : 		ret *= 62;

  00013	8b c8		 mov	 ecx, eax
  00015	c1 e0 05	 shl	 eax, 5
  00018	2b c1		 sub	 eax, ecx

; 402  : 		if( '0' <= (*a) && (*a) <= '9' )

  0001a	8d 4a d0	 lea	 ecx, DWORD PTR [edx-48]
  0001d	03 c0		 add	 eax, eax
  0001f	80 f9 09	 cmp	 cl, 9
  00022	77 0a		 ja	 SHORT $LN4@a62toi

; 403  : 			ret += (*a)-'0';

  00024	0f be ca	 movsx	 ecx, dl
  00027	83 c0 d0	 add	 eax, -48		; ffffffd0H
  0002a	03 c1		 add	 eax, ecx
  0002c	eb 2c		 jmp	 SHORT $LN11@a62toi
$LN4@a62toi:

; 404  : 		else
; 405  : 		if( 'a' <= (*a) && (*a) <= 'z' )

  0002e	8d 4a 9f	 lea	 ecx, DWORD PTR [edx-97]
  00031	80 f9 19	 cmp	 cl, 25			; 00000019H
  00034	77 0a		 ja	 SHORT $LN6@a62toi

; 406  : 			ret += (*a)-'a'+10;

  00036	0f be ca	 movsx	 ecx, dl
  00039	83 c0 a9	 add	 eax, -87		; ffffffa9H
  0003c	03 c1		 add	 eax, ecx
  0003e	eb 1a		 jmp	 SHORT $LN11@a62toi
$LN6@a62toi:

; 407  : 		else
; 408  : 		if( 'A' <= (*a) && (*a) <= 'Z' )

  00040	8d 4a bf	 lea	 ecx, DWORD PTR [edx-65]
  00043	80 f9 19	 cmp	 cl, 25			; 00000019H
  00046	77 0a		 ja	 SHORT $LN8@a62toi

; 409  : 			ret += (*a)-'A'+36;

  00048	0f be ca	 movsx	 ecx, dl
  0004b	83 c0 e3	 add	 eax, -29		; ffffffe3H
  0004e	03 c1		 add	 eax, ecx
  00050	eb 08		 jmp	 SHORT $LN11@a62toi
$LN8@a62toi:

; 410  : 		else
; 411  : 		if( *a == '-' )

  00052	80 fa 2d	 cmp	 dl, 45			; 0000002dH
  00055	75 12		 jne	 SHORT $LN10@a62toi

; 412  : 			fugo = -1;

  00057	83 cf ff	 or	 edi, -1
$LN11@a62toi:

; 396  : 	int ret = 0;
; 397  : 	int fugo = 1;
; 398  : 
; 399  : 	while( *a != NULL )

  0005a	8a 56 01	 mov	 dl, BYTE PTR [esi+1]

; 415  : 		a++;

  0005d	46		 inc	 esi
  0005e	84 d2		 test	 dl, dl
  00060	75 b1		 jne	 SHORT $LL2@a62toi
$LN3@a62toi:

; 416  : 	}
; 417  : 	return ret*fugo;

  00062	0f af c7	 imul	 eax, edi
  00065	5f		 pop	 edi

; 418  : }

  00066	5e		 pop	 esi
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
$LN10@a62toi:
  00069	5f		 pop	 edi

; 413  : 		else
; 414  : 			return 0;

  0006a	33 c0		 xor	 eax, eax

; 418  : }

  0006c	5e		 pop	 esi
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?a62toi@@YAHPAD@Z ENDP					; a62toi
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\tool.cpp
;	COMDAT ?shiftIntArray@@YAXPAHHH@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_siz$ = 12						; size = 4
_count$ = 16						; size = 4
?shiftIntArray@@YAXPAHHH@Z PROC				; shiftIntArray, COMDAT

; 378  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 379  : 	int i;
; 380  : 
; 381  : 	for( i = 0; i < siz - count; i++ )

  00003	8b 45 0c	 mov	 eax, DWORD PTR _siz$[ebp]
  00006	33 d2		 xor	 edx, edx
  00008	8b 4d 10	 mov	 ecx, DWORD PTR _count$[ebp]
  0000b	53		 push	 ebx
  0000c	8b 5d 08	 mov	 ebx, DWORD PTR _a$[ebp]
  0000f	57		 push	 edi
  00010	8b f8		 mov	 edi, eax
  00012	2b f9		 sub	 edi, ecx
  00014	85 ff		 test	 edi, edi
  00016	7e 19		 jle	 SHORT $LN3@shiftIntAr
  00018	56		 push	 esi
  00019	8d 34 8b	 lea	 esi, DWORD PTR [ebx+ecx*4]
  0001c	0f 1f 40 00	 npad	 4
$LL13@shiftIntAr:

; 382  : 	{
; 383  : 		a[i] = a[i+count];

  00020	8b 06		 mov	 eax, DWORD PTR [esi]
  00022	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00025	89 04 93	 mov	 DWORD PTR [ebx+edx*4], eax
  00028	42		 inc	 edx
  00029	3b d7		 cmp	 edx, edi
  0002b	7c f3		 jl	 SHORT $LL13@shiftIntAr
  0002d	8b 45 0c	 mov	 eax, DWORD PTR _siz$[ebp]
  00030	5e		 pop	 esi
$LN3@shiftIntAr:

; 384  : 	}
; 385  : 	for( i = siz - count; i <siz; i++ )

  00031	3b f8		 cmp	 edi, eax
  00033	7d 07		 jge	 SHORT $LN6@shiftIntAr
  00035	33 c0		 xor	 eax, eax

; 386  : 	{
; 387  : 		a[i] = 0;

  00037	8d 3c bb	 lea	 edi, DWORD PTR [ebx+edi*4]
  0003a	f3 ab		 rep stosd
$LN6@shiftIntAr:

; 388  : 	}
; 389  : }

  0003c	5f		 pop	 edi
  0003d	5b		 pop	 ebx
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?shiftIntArray@@YAXPAHHH@Z ENDP				; shiftIntArray
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\tool.cpp
;	COMDAT ?chop@@YAXPAD@Z
_TEXT	SEGMENT
_src$ = 8						; size = 4
?chop@@YAXPAD@Z PROC					; chop, COMDAT

; 353  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 357  : 	{
; 358  : 		if( src[i] == 0 )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	38 01		 cmp	 BYTE PTR [ecx], al
  0000a	74 1e		 je	 SHORT $LN15@chop
  0000c	0f 1f 40 00	 npad	 4
$LL4@chop:

; 359  : 			break;
; 360  : 		if( src[i] == '\n' && src[i+1] == '\0' )

  00010	80 3c 08 0a	 cmp	 BYTE PTR [eax+ecx], 10	; 0000000aH
  00014	75 07		 jne	 SHORT $LN2@chop
  00016	80 7c 08 01 00	 cmp	 BYTE PTR [eax+ecx+1], 0
  0001b	74 09		 je	 SHORT $LN11@chop
$LN2@chop:

; 354  : 	int i;
; 355  : 
; 356  : 	for( i = 0; ; i++ )

  0001d	40		 inc	 eax

; 357  : 	{
; 358  : 		if( src[i] == 0 )

  0001e	80 3c 08 00	 cmp	 BYTE PTR [eax+ecx], 0
  00022	75 ec		 jne	 SHORT $LL4@chop

; 363  : 			break;
; 364  : 		}
; 365  : 	}
; 366  : }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
$LN11@chop:

; 361  : 		{
; 362  : 			src[i] = '\0';

  00026	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
$LN15@chop:

; 363  : 			break;
; 364  : 		}
; 365  : 	}
; 366  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?chop@@YAXPAD@Z ENDP					; chop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\tool.cpp
;	COMDAT ?getDoubleToken@@YANPADDH@Z
_TEXT	SEGMENT
_s$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_src$ = 8						; size = 4
_delim$ = 12						; size = 1
_count$ = 16						; size = 4
?getDoubleToken@@YANPADDH@Z PROC			; getDoubleToken, COMDAT

; 337  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]

; 338  : 	char s[128];
; 339  : 
; 340  : 	getStringToken( src, delim, count, sizeof( s )-1, s );

  00016	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  0001c	51		 push	 ecx
  0001d	6a 7f		 push	 127			; 0000007fH
  0001f	ff 75 10	 push	 DWORD PTR _count$[ebp]
  00022	ff 75 0c	 push	 DWORD PTR _delim$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 341  : 
; 342  : 	return strtod( s , NULL );

  0002b	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00031	6a 00		 push	 0
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _strtod

; 343  : }

  00039	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0003f	33 cd		 xor	 ecx, ebp
  00041	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
?getDoubleToken@@YANPADDH@Z ENDP			; getDoubleToken
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\tool.cpp
;	COMDAT ?getIntegerToken@@YAHPADDH@Z
_TEXT	SEGMENT
_s$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_src$ = 8						; size = 4
_delim$ = 12						; size = 1
_count$ = 16						; size = 4
?getIntegerToken@@YAHPADDH@Z PROC			; getIntegerToken, COMDAT

; 316  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]

; 317  : 	char s[128];
; 318  : 
; 319  : 	getStringToken( src, delim, count, sizeof( s )-1, s );

  00016	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  0001c	51		 push	 ecx
  0001d	6a 7f		 push	 127			; 0000007fH
  0001f	ff 75 10	 push	 DWORD PTR _count$[ebp]
  00022	ff 75 0c	 push	 DWORD PTR _delim$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0002b	83 c4 14	 add	 esp, 20			; 00000014H

; 320  : 
; 321  : 	if( s[0] == '\0' )

  0002e	80 bd 7c ff ff
	ff 00		 cmp	 BYTE PTR _s$[ebp], 0
  00035	75 11		 jne	 SHORT $LN2@getInteger

; 322  : 		return -1;

  00037	83 c8 ff	 or	 eax, -1

; 325  : }

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003d	33 cd		 xor	 ecx, ebp
  0003f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
$LN2@getInteger:

; 323  : 
; 324  : 	return atoi( s );

  00048	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _atoi

; 325  : }

  00054	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00057	83 c4 04	 add	 esp, 4
  0005a	33 cd		 xor	 ecx, ebp
  0005c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?getIntegerToken@@YAHPADDH@Z ENDP			; getIntegerToken
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\tool.cpp
;	COMDAT ?getStringToken@@YAHPADDHH0@Z
_TEXT	SEGMENT
_src$ = 8						; size = 4
_delim$ = 12						; size = 1
_count$ = 16						; size = 4
_maxlen$ = 20						; size = 4
_out$ = 24						; size = 4
?getStringToken@@YAHPADDHH0@Z PROC			; getStringToken, COMDAT

; 219  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 220  : 	int c = 1;
; 221  : 	int i;
; 222  : 	unsigned char *pt;
; 223  : 
; 224  : 	pt = (unsigned char *)src;

  00003	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]

; 225  : 	for( i = 0; i < count-1; i++ )

  00006	8b 55 0c	 mov	 edx, DWORD PTR _delim$[ebp]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b 7d 10	 mov	 edi, DWORD PTR _count$[ebp]
  0000e	33 f6		 xor	 esi, esi
  00010	4f		 dec	 edi
  00011	85 ff		 test	 edi, edi
  00013	7e 2a		 jle	 SHORT $LN23@getStringT
$LL4@getStringT:

; 226  : 	{
; 227  : 		if( pt == (unsigned char *)0 )

  00015	85 c0		 test	 eax, eax
  00017	74 2a		 je	 SHORT $LN28@getStringT

; 178  : 		if( *pt == '\0' )

  00019	8a 08		 mov	 cl, BYTE PTR [eax]
  0001b	84 c9		 test	 cl, cl
  0001d	74 19		 je	 SHORT $LN20@getStringT
  0001f	90		 npad	 1
$LL9@getStringT:

; 179  : 			return (unsigned char *)0;
; 180  : 
; 181  : 		if( *pt < 0x80 )

  00020	40		 inc	 eax
  00021	80 f9 80	 cmp	 cl, 128			; 00000080H
  00024	73 06		 jae	 SHORT $LN12@getStringT

; 182  : 		{
; 183  : 			// 1bayteîž°????
; 184  : 			if( *pt == delim )

  00026	3a ca		 cmp	 cl, dl
  00028	74 10		 je	 SHORT $LN2@getStringT

; 185  : 			{
; 186  : 				// ?î“?îž°???????????????îŸŽ?
; 187  : 				pt++;
; 188  : 				return pt;
; 189  : 			}
; 190  : 			pt++;
; 191  : 		}

  0002a	eb 06		 jmp	 SHORT $LN13@getStringT
$LN12@getStringT:

; 192  : 		else
; 193  : 		{
; 194  : 			// 2byteîž°????
; 195  : 			pt++;
; 196  : 			if( *pt == '\0' )

  0002c	80 38 00	 cmp	 BYTE PTR [eax], 0
  0002f	74 07		 je	 SHORT $LN20@getStringT

; 197  : 				return (unsigned char *)0;
; 198  : 			pt++;

  00031	40		 inc	 eax
$LN13@getStringT:

; 178  : 		if( *pt == '\0' )

  00032	8a 08		 mov	 cl, BYTE PTR [eax]
  00034	84 c9		 test	 cl, cl
  00036	75 e8		 jne	 SHORT $LL9@getStringT
$LN20@getStringT:

; 225  : 	for( i = 0; i < count-1; i++ )

  00038	33 c0		 xor	 eax, eax
$LN2@getStringT:
  0003a	46		 inc	 esi
  0003b	3b f7		 cmp	 esi, edi
  0003d	7c d6		 jl	 SHORT $LL4@getStringT
$LN23@getStringT:

; 228  : 			break;
; 229  : 
; 230  : 		pt = searchDelimPoint( pt, delim );
; 231  : 	}
; 232  : 
; 233  : 	if( pt == (unsigned char *)0 )

  0003f	85 c0		 test	 eax, eax
  00041	75 0f		 jne	 SHORT $LN6@getStringT
$LN28@getStringT:

; 234  : 	{
; 235  : 		out[0] = '\0';

  00043	8b 45 18	 mov	 eax, DWORD PTR _out$[ebp]
  00046	5f		 pop	 edi

; 240  : }

  00047	5e		 pop	 esi
  00048	c6 00 00	 mov	 BYTE PTR [eax], 0
  0004b	b8 01 00 00 00	 mov	 eax, 1
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
$LN6@getStringT:

; 236  : 		return 1;
; 237  : 	}
; 238  : 
; 239  : 	return copyStringUntilDelim( pt, delim, maxlen, (unsigned char *)out );

  00052	ff 75 18	 push	 DWORD PTR _out$[ebp]
  00055	ff 75 14	 push	 DWORD PTR _maxlen$[ebp]
  00058	52		 push	 edx
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ?copyStringUntilDelim@@YAHPAEDH0@Z ; copyStringUntilDelim
  0005f	83 c4 10	 add	 esp, 16			; 00000010H
  00062	5f		 pop	 edi

; 240  : }

  00063	5e		 pop	 esi
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
?getStringToken@@YAHPADDHH0@Z ENDP			; getStringToken
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\tool.cpp
;	COMDAT ?strlong2@@YAJPAPAD@Z
_TEXT	SEGMENT
_p$ = -1032						; size = 4
_moji$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_pp$ = 8						; size = 4
?strlong2@@YAJPAPAD@Z PROC				; strlong2, COMDAT

; 159  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 04 00
	00		 sub	 esp, 1032		; 00000408H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _pp$[ebp]

; 160  : 	char moji[1024] = "";

  00017	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _moji$[ebp]
  0001d	68 00 04 00 00	 push	 1024			; 00000400H
  00022	6a 00		 push	 0
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _memset

; 161  : 	char *p = *pp;

  0002a	8b 06		 mov	 eax, DWORD PTR [esi]
  0002c	89 85 f8 fb ff
	ff		 mov	 DWORD PTR _p$[ebp], eax

; 162  : 
; 163  : 	getword( &p , moji );

  00032	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _moji$[ebp]
  00038	50		 push	 eax
  00039	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _p$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?getword@@YAHPAPADPAD@Z	; getword

; 164  : 	*pp = p;

  00045	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _p$[ebp]
  0004b	89 06		 mov	 DWORD PTR [esi], eax

; 165  : 
; 166  : 	return atol(moji);

  0004d	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _moji$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 _atol

; 167  : }

  00059	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005c	83 c4 18	 add	 esp, 24			; 00000018H
  0005f	33 cd		 xor	 ecx, ebp
  00061	5e		 pop	 esi
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
?strlong2@@YAJPAPAD@Z ENDP				; strlong2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\tool.cpp
;	COMDAT ?strint2@@YAHPAPAD@Z
_TEXT	SEGMENT
_p$ = -1032						; size = 4
_moji$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_pp$ = 8						; size = 4
?strint2@@YAHPAPAD@Z PROC				; strint2, COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 04 00
	00		 sub	 esp, 1032		; 00000408H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _pp$[ebp]

; 147  : 	char moji[1024] = "";

  00017	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _moji$[ebp]
  0001d	68 00 04 00 00	 push	 1024			; 00000400H
  00022	6a 00		 push	 0
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _memset

; 148  : 	char *p = *pp;

  0002a	8b 06		 mov	 eax, DWORD PTR [esi]
  0002c	89 85 f8 fb ff
	ff		 mov	 DWORD PTR _p$[ebp], eax

; 149  : 
; 150  : 	getword( &p , moji );

  00032	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _moji$[ebp]
  00038	50		 push	 eax
  00039	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _p$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?getword@@YAHPAPADPAD@Z	; getword

; 151  : 	*pp = p;

  00045	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _p$[ebp]
  0004b	89 06		 mov	 DWORD PTR [esi], eax

; 152  : 
; 153  : 	return atoi(moji);

  0004d	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _moji$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 _atoi

; 154  : }

  00059	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005c	83 c4 18	 add	 esp, 24			; 00000018H
  0005f	33 cd		 xor	 ecx, ebp
  00061	5e		 pop	 esi
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
?strint2@@YAHPAPAD@Z ENDP				; strint2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\tool.cpp
;	COMDAT ?getword@@YAHPAPADPAD@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_pp$ = 8						; size = 4
_q$ = 12						; size = 4
?getword@@YAHPAPADPAD@Z PROC				; getword, COMDAT

; 65   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 66   : 	int i=0;
; 67   : 	char *p = *pp;

  00005	8b 7d 08	 mov	 edi, DWORD PTR _pp$[ebp]
  00008	8b 07		 mov	 eax, DWORD PTR [edi]
  0000a	89 45 08	 mov	 DWORD PTR _p$[ebp], eax

; 68   : 
; 69   : 	wordchk( &p );

  0000d	8d 45 08	 lea	 eax, DWORD PTR _p$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?wordchk@@YAHPAPAD@Z	; wordchk

; 70   : 
; 71   : 	for( i = 0; *p != ' ' && *p != '\t' && *p != '\0'; p++ , q++ , i++ )

  00016	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00019	83 c4 04	 add	 esp, 4
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _q$[ebp]
  0001f	33 f6		 xor	 esi, esi
  00021	8a 02		 mov	 al, BYTE PTR [edx]
  00023	3c 20		 cmp	 al, 32			; 00000020H
  00025	74 13		 je	 SHORT $LN3@getword
$LL4@getword:
  00027	3c 09		 cmp	 al, 9
  00029	74 0f		 je	 SHORT $LN3@getword
  0002b	84 c0		 test	 al, al
  0002d	74 0b		 je	 SHORT $LN3@getword
  0002f	42		 inc	 edx

; 72   : 	{
; 73   : 		*q = *p;

  00030	88 01		 mov	 BYTE PTR [ecx], al
  00032	41		 inc	 ecx
  00033	46		 inc	 esi
  00034	8a 02		 mov	 al, BYTE PTR [edx]
  00036	3c 20		 cmp	 al, 32			; 00000020H
  00038	75 ed		 jne	 SHORT $LL4@getword
$LN3@getword:

; 74   : 	}
; 75   : 
; 76   : 	*q = '\0';

  0003a	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 77   : 	*pp = p;
; 78   : 
; 79   : 	return i;

  0003d	8b c6		 mov	 eax, esi
  0003f	89 17		 mov	 DWORD PTR [edi], edx
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi

; 80   : }

  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?getword@@YAHPAPADPAD@Z ENDP				; getword
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\tool.cpp
;	COMDAT ?strstr2@@YAHPAPADPAD@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_pp$ = 8						; size = 4
_q$ = 12						; size = 4
?strstr2@@YAHPAPADPAD@Z PROC				; strstr2, COMDAT

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 126  : 	char *p = *pp;

  00005	8b 7d 08	 mov	 edi, DWORD PTR _pp$[ebp]
  00008	8b 07		 mov	 eax, DWORD PTR [edi]
  0000a	89 45 08	 mov	 DWORD PTR _p$[ebp], eax

; 127  : 	int i;
; 128  : 
; 129  : 	wordchk( &p );

  0000d	8d 45 08	 lea	 eax, DWORD PTR _p$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?wordchk@@YAHPAPAD@Z	; wordchk

; 130  : 
; 131  : 	for( i = 1; *p++ == *q++; i++ )

  00016	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00019	83 c4 04	 add	 esp, 4
  0001c	8b 75 0c	 mov	 esi, DWORD PTR _q$[ebp]
  0001f	ba 01 00 00 00	 mov	 edx, 1
  00024	8a 01		 mov	 al, BYTE PTR [ecx]
  00026	3a 06		 cmp	 al, BYTE PTR [esi]
  00028	75 14		 jne	 SHORT $LN9@strstr2
  0002a	2b f1		 sub	 esi, ecx
  0002c	0f 1f 40 00	 npad	 4
$LL4@strstr2:

; 132  : 	{
; 133  : 		if( *q == 0 )

  00030	8a 44 0e 01	 mov	 al, BYTE PTR [esi+ecx+1]
  00034	41		 inc	 ecx
  00035	84 c0		 test	 al, al
  00037	74 0b		 je	 SHORT $LN8@strstr2

; 130  : 
; 131  : 	for( i = 1; *p++ == *q++; i++ )

  00039	42		 inc	 edx
  0003a	38 01		 cmp	 BYTE PTR [ecx], al
  0003c	74 f2		 je	 SHORT $LL4@strstr2
$LN9@strstr2:
  0003e	5f		 pop	 edi

; 137  : 		}
; 138  : 	}
; 139  : 
; 140  : 	return 0;

  0003f	33 c0		 xor	 eax, eax

; 141  : }

  00041	5e		 pop	 esi
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
$LN8@strstr2:

; 134  : 		{
; 135  : 			*pp = p;

  00044	89 0f		 mov	 DWORD PTR [edi], ecx

; 136  : 			return i;

  00046	8b c2		 mov	 eax, edx
  00048	5f		 pop	 edi

; 141  : }

  00049	5e		 pop	 esi
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?strstr2@@YAHPAPADPAD@Z ENDP				; strstr2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\tool.cpp
;	COMDAT ?wordchk@@YAHPAPAD@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
?wordchk@@YAHPAPAD@Z PROC				; wordchk, COMDAT

; 38   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 39   : 	char *p = *pp;

  00003	8b 55 08	 mov	 edx, DWORD PTR _pp$[ebp]
  00006	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 40   : 
; 41   : 	while( *p != 0 )

  00008	8a 01		 mov	 al, BYTE PTR [ecx]
  0000a	84 c0		 test	 al, al
  0000c	74 12		 je	 SHORT $LN14@wordchk
  0000e	66 90		 npad	 2
$LL2@wordchk:

; 42   : 	{
; 43   : 		switch( *p )

  00010	3c 09		 cmp	 al, 9
  00012	74 04		 je	 SHORT $LN6@wordchk
  00014	3c 20		 cmp	 al, 32			; 00000020H
  00016	75 0c		 jne	 SHORT $LN11@wordchk
$LN6@wordchk:

; 40   : 
; 41   : 	while( *p != 0 )

  00018	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  0001b	41		 inc	 ecx
  0001c	84 c0		 test	 al, al
  0001e	75 f0		 jne	 SHORT $LL2@wordchk
$LN14@wordchk:

; 56   : 		}
; 57   : 	}
; 58   : 
; 59   : 	return 0;

  00020	33 c0		 xor	 eax, eax

; 60   : }

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
$LN11@wordchk:

; 44   : 		{
; 45   : 			case '\t':
; 46   : 				p++;
; 47   : 				break;
; 48   : 
; 49   : 			case ' ':
; 50   : 				p++;
; 51   : 				break;
; 52   : 
; 53   : 			default:
; 54   : 				*pp = p;

  00024	89 0a		 mov	 DWORD PTR [edx], ecx

; 55   : 				return 1;

  00026	b8 01 00 00 00	 mov	 eax, 1

; 60   : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?wordchk@@YAHPAPAD@Z ENDP				; wordchk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\tool.cpp
;	COMDAT ?TimeGetTime@@YAIXZ
_TEXT	SEGMENT
?TimeGetTime@@YAIXZ PROC				; TimeGetTime, COMDAT

; 23   : #ifdef _TIME_GET_TIME
; 24   : 	static __int64 time;
; 25   : 
; 26   : 	QueryPerformanceCounter(&CurrentTick);
; 27   : 	return (unsigned int)(time = CurrentTick.QuadPart/tickCount.QuadPart);
; 28   : #else
; 29   : 	return timeGetTime();

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__timeGetTime@0
?TimeGetTime@@YAIXZ ENDP				; TimeGetTime
_TEXT	ENDS
END
