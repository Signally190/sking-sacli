; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29336.0 

	TITLE	C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\unpack.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?encoder@@YAPAEPAEPAPAEIIPAIH@Z			; encoder
PUBLIC	?decoder@@YAPAEPAEPAPAEPAI22@Z			; decoder
EXTRN	_malloc:PROC
EXTRN	_uncompress:PROC
EXTRN	_memset:PROC
EXTRN	?NewColor16Flg@@3HA:DWORD			; NewColor16Flg
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\unpack.cpp
;	COMDAT ?decoder@@YAPAEPAEPAPAEPAI22@Z
_TEXT	SEGMENT
_eBuf$1$ = -12						; size = 4
_wBuf$1$ = -8						; size = 4
_width$1$ = -4						; size = 4
_buf$ = 8						; size = 4
_height$1$ = 12						; size = 4
_disBuf$ = 12						; size = 4
_width1$ = 16						; size = 4
_height1$ = 20						; size = 4
_len$ = 24						; size = 4
?decoder@@YAPAEPAEPAPAEPAI22@Z PROC			; decoder, COMDAT

; 257  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 258  : 	RD_HEADER *header;
; 259  : 	unsigned char *wBuf, *ewBuf, *eBuf;
; 260  : 	unsigned char *wBuf1, *buf1;
; 261  : 	unsigned int width, height;
; 262  : 	unsigned int cnt;
; 263  : 	unsigned int l, el;
; 264  : 	unsigned char repData;
; 265  : 	unsigned char idx;
; 266  : 	if (*disBuf == NULL)

  00006	8b 55 0c	 mov	 edx, DWORD PTR _disBuf$[ebp]
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8b 1a		 mov	 ebx, DWORD PTR [edx]
  0000d	89 5d f8	 mov	 DWORD PTR _wBuf$1$[ebp], ebx
  00010	85 db		 test	 ebx, ebx
  00012	0f 84 82 01 00
	00		 je	 $LN12@decoder

; 267  : 		return NULL;
; 268  : 	wBuf = *disBuf;
; 269  : 	header = (RD_HEADER *)buf;
; 270  : 	if (header->id[0] != 'R' || header->id[1] != 'D') {

  00018	8b 7d 08	 mov	 edi, DWORD PTR _buf$[ebp]
  0001b	80 3f 52	 cmp	 BYTE PTR [edi], 82	; 00000052H
  0001e	0f 85 76 01 00
	00		 jne	 $LN12@decoder
  00024	80 7f 01 44	 cmp	 BYTE PTR [edi+1], 68	; 00000044H
  00028	0f 85 6c 01 00
	00		 jne	 $LN12@decoder

; 272  : 	}
; 273  : 	width = header->width;
; 274  : 	height = header->height;

  0002e	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00031	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00034	89 45 0c	 mov	 DWORD PTR _height$1$[ebp], eax

; 275  : 	if (header->compressFlag == 0) {//æ²¡åŠ å¯†

  00037	8a 47 02	 mov	 al, BYTE PTR [edi+2]
  0003a	89 4d fc	 mov	 DWORD PTR _width$1$[ebp], ecx
  0003d	56		 push	 esi
  0003e	8d 77 10	 lea	 esi, DWORD PTR [edi+16]
  00041	84 c0		 test	 al, al
  00043	75 3e		 jne	 SHORT $LN13@decoder

; 277  : 		buf1 = buf + sizeof(RD_HEADER);
; 278  : 		el = width * height;

  00045	8b 55 0c	 mov	 edx, DWORD PTR _height$1$[ebp]

; 279  : 		for (l = 0; l < el; l++)

  00048	33 ff		 xor	 edi, edi
  0004a	0f af d1	 imul	 edx, ecx
  0004d	85 d2		 test	 edx, edx
  0004f	74 14		 je	 SHORT $LN3@decoder

; 276  : 		wBuf1 = wBuf;

  00051	8b cb		 mov	 ecx, ebx
  00053	2b f3		 sub	 esi, ebx
  00055	8b fa		 mov	 edi, edx
$LL37@decoder:

; 280  : 			*wBuf1++ = *buf1++;

  00057	8a 04 0e	 mov	 al, BYTE PTR [esi+ecx]
  0005a	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  0005d	88 41 ff	 mov	 BYTE PTR [ecx-1], al
  00060	83 ea 01	 sub	 edx, 1
  00063	75 f2		 jne	 SHORT $LL37@decoder
$LN3@decoder:

; 281  : 
; 282  : 		*len = l;

  00065	8b 4d 18	 mov	 ecx, DWORD PTR _len$[ebp]

; 283  : 		*width1 = width;

  00068	8b 45 fc	 mov	 eax, DWORD PTR _width$1$[ebp]
  0006b	5e		 pop	 esi
  0006c	89 39		 mov	 DWORD PTR [ecx], edi
  0006e	8b 4d 10	 mov	 ecx, DWORD PTR _width1$[ebp]
  00071	5f		 pop	 edi
  00072	89 01		 mov	 DWORD PTR [ecx], eax

; 284  : 		*height1 = height;

  00074	8b 4d 14	 mov	 ecx, DWORD PTR _height1$[ebp]
  00077	8b 45 0c	 mov	 eax, DWORD PTR _height$1$[ebp]
  0007a	89 01		 mov	 DWORD PTR [ecx], eax

; 285  : 		return wBuf;

  0007c	8b c3		 mov	 eax, ebx

; 350  : 		return wBuf;
; 351  : 	}
; 352  : }

  0007e	5b		 pop	 ebx
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
$LN13@decoder:

; 286  : #ifdef _NEW_COLOR_
; 287  : 	}
; 288  : 	else if (header->compressFlag >= 16) {

  00083	3c 10		 cmp	 al, 16			; 00000010H
  00085	72 4a		 jb	 SHORT $LN15@decoder

; 289  : 		*len = width * height * 4;

  00087	8b 45 0c	 mov	 eax, DWORD PTR _height$1$[ebp]

; 290  : 		*width1 = width;

  0008a	8b 5d fc	 mov	 ebx, DWORD PTR _width$1$[ebp]
  0008d	0f af c1	 imul	 eax, ecx
  00090	8b 4d 18	 mov	 ecx, DWORD PTR _len$[ebp]
  00093	c1 e0 02	 shl	 eax, 2
  00096	89 01		 mov	 DWORD PTR [ecx], eax
  00098	8b 45 10	 mov	 eax, DWORD PTR _width1$[ebp]
  0009b	89 18		 mov	 DWORD PTR [eax], ebx

; 291  : 		*height1 = height;

  0009d	8b 45 14	 mov	 eax, DWORD PTR _height1$[ebp]
  000a0	8b 5d 0c	 mov	 ebx, DWORD PTR _height$1$[ebp]
  000a3	89 18		 mov	 DWORD PTR [eax], ebx

; 292  : 		uncompress(*disBuf, (unsigned long *)len, buf + sizeof(RD_HEADER), header->size - sizeof(RD_HEADER));

  000a5	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000a8	83 e8 10	 sub	 eax, 16			; 00000010H
  000ab	50		 push	 eax
  000ac	56		 push	 esi
  000ad	51		 push	 ecx
  000ae	ff 32		 push	 DWORD PTR [edx]
  000b0	e8 00 00 00 00	 call	 _uncompress
  000b5	83 c4 10	 add	 esp, 16			; 00000010H

; 293  : 		if (header->compressFlag == 16)
; 294  : 			NewColor16Flg = 1;
; 295  : 		else {
; 296  : 			NewColor16Flg = 2;
; 297  : 		}
; 298  : 		return wBuf;

  000b8	33 c0		 xor	 eax, eax
  000ba	80 7f 02 10	 cmp	 BYTE PTR [edi+2], 16	; 00000010H
  000be	0f 95 c0	 setne	 al
  000c1	5e		 pop	 esi
  000c2	40		 inc	 eax
  000c3	5f		 pop	 edi
  000c4	a3 00 00 00 00	 mov	 DWORD PTR ?NewColor16Flg@@3HA, eax ; NewColor16Flg
  000c9	8b 45 f8	 mov	 eax, DWORD PTR _wBuf$1$[ebp]

; 350  : 		return wBuf;
; 351  : 	}
; 352  : }

  000cc	5b		 pop	 ebx
  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c3		 ret	 0
$LN15@decoder:

; 299  : #endif
; 300  : 	}
; 301  : 	else {//åŠ å¯†
; 302  : 		eBuf = buf + header->size;

  000d1	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000d4	03 c7		 add	 eax, edi

; 303  : 		ewBuf = wBuf + width * height;
; 304  : 		wBuf1 = wBuf;

  000d6	8b fb		 mov	 edi, ebx
  000d8	89 45 f4	 mov	 DWORD PTR _eBuf$1$[ebp], eax

; 305  : 		buf1 = buf + sizeof(RD_HEADER);
; 306  : 		while (buf1 < eBuf) {

  000db	3b f0		 cmp	 esi, eax
  000dd	0f 83 94 00 00
	00		 jae	 $LN6@decoder
$LL5@decoder:

; 307  : 			idx = *buf1++;

  000e3	8a 06		 mov	 al, BYTE PTR [esi]
  000e5	8b d6		 mov	 edx, esi
  000e7	46		 inc	 esi

; 308  : 			if ((idx & BIT_CMP) != 0) {

  000e8	84 c0		 test	 al, al
  000ea	79 56		 jns	 SHORT $LN19@decoder

; 309  : 				if ((idx & BIT_ZERO) != 0) {

  000ec	8a c8		 mov	 cl, al
  000ee	80 e1 40	 and	 cl, 64			; 00000040H
  000f1	74 04		 je	 SHORT $LN21@decoder

; 310  : 					repData = 0;

  000f3	32 ed		 xor	 ch, ch

; 311  : 				}

  000f5	eb 02		 jmp	 SHORT $LN22@decoder
$LN21@decoder:

; 312  : 				else {
; 313  : 					repData = *buf1++;

  000f7	8a 2e		 mov	 ch, BYTE PTR [esi]
$LN22@decoder:

; 314  : 				}
; 315  : 				if ((idx & BIT_REP_LARG2) != 0) {

  000f9	84 c9		 test	 cl, cl
  000fb	0f b6 d8	 movzx	 ebx, al
  000fe	0f 44 d6	 cmove	 edx, esi
  00101	83 e3 0f	 and	 ebx, 15			; 0000000fH
  00104	8d 72 01	 lea	 esi, DWORD PTR [edx+1]
  00107	8b d6		 mov	 edx, esi
  00109	a8 20		 test	 al, 32			; 00000020H
  0010b	74 16		 je	 SHORT $LN23@decoder

; 316  : 					cnt = ((idx & 0x0f) << 16);
; 317  : 					cnt |= ((*buf1) << 8);

  0010d	0f b6 02	 movzx	 eax, BYTE PTR [edx]

; 318  : 					buf1++;
; 319  : 					cnt |= *buf1++;

  00110	c1 e3 08	 shl	 ebx, 8
  00113	0b d8		 or	 ebx, eax
  00115	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  00119	c1 e3 08	 shl	 ebx, 8
  0011c	0b d8		 or	 ebx, eax
  0011e	83 c6 02	 add	 esi, 2

; 320  : 				}

  00121	eb 0d		 jmp	 SHORT $LN25@decoder
$LN23@decoder:

; 321  : 				else
; 322  : 					if ((idx & BIT_REP_LARG) != 0) {

  00123	a8 10		 test	 al, 16			; 00000010H
  00125	74 09		 je	 SHORT $LN25@decoder

; 323  : 						cnt = ((idx & 0x0f) << 8);
; 324  : 						cnt |= *buf1++;

  00127	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0012a	c1 e3 08	 shl	 ebx, 8
  0012d	0b d8		 or	 ebx, eax
  0012f	46		 inc	 esi
$LN25@decoder:

; 325  : 					}
; 326  : 					else {
; 327  : 						cnt = (idx & 0x0f);
; 328  : 					}
; 329  : 					memset(wBuf1, repData, cnt);

  00130	53		 push	 ebx
  00131	0f b6 c5	 movzx	 eax, ch
  00134	50		 push	 eax
  00135	57		 push	 edi
  00136	e8 00 00 00 00	 call	 _memset
  0013b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 330  : 					wBuf1 += cnt;

  0013e	03 fb		 add	 edi, ebx

; 331  : 			}

  00140	eb 29		 jmp	 SHORT $LN8@decoder
$LN19@decoder:

; 332  : 			else {
; 333  : 				if ((idx & BIT_REP_LARG) != 0) {

  00142	0f b6 c8	 movzx	 ecx, al
  00145	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00148	a8 10		 test	 al, 16			; 00000010H
  0014a	74 0b		 je	 SHORT $LN27@decoder

; 334  : 					cnt = ((idx & 0x0f) << 8);
; 335  : 					cnt |= *buf1++;

  0014c	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0014f	8d 72 02	 lea	 esi, DWORD PTR [edx+2]
  00152	c1 e1 08	 shl	 ecx, 8
  00155	0b c8		 or	 ecx, eax
$LN27@decoder:

; 336  : 				}
; 337  : 				else {
; 338  : 					cnt = (idx & 0x0f);
; 339  : 				}
; 340  : 				if (cnt >= 0xfffff) {
; 341  : 					return NULL;
; 342  : 				}
; 343  : 				for (l = 0; l < cnt; l++)

  00157	85 c9		 test	 ecx, ecx
  00159	74 10		 je	 SHORT $LN8@decoder
  0015b	0f 1f 44 00 00	 npad	 5
$LL39@decoder:

; 344  : 					*wBuf1++ = *buf1++;

  00160	8a 06		 mov	 al, BYTE PTR [esi]
  00162	46		 inc	 esi
  00163	88 07		 mov	 BYTE PTR [edi], al
  00165	47		 inc	 edi
  00166	83 e9 01	 sub	 ecx, 1
  00169	75 f5		 jne	 SHORT $LL39@decoder
$LN8@decoder:

; 305  : 		buf1 = buf + sizeof(RD_HEADER);
; 306  : 		while (buf1 < eBuf) {

  0016b	3b 75 f4	 cmp	 esi, DWORD PTR _eBuf$1$[ebp]
  0016e	0f 82 6f ff ff
	ff		 jb	 $LL5@decoder
  00174	8b 5d f8	 mov	 ebx, DWORD PTR _wBuf$1$[ebp]
$LN6@decoder:

; 345  : 			}
; 346  : 		}
; 347  : 		*len = width * height;

  00177	8b 75 0c	 mov	 esi, DWORD PTR _height$1$[ebp]
  0017a	8b ce		 mov	 ecx, esi
  0017c	8b 55 fc	 mov	 edx, DWORD PTR _width$1$[ebp]
  0017f	8b 45 18	 mov	 eax, DWORD PTR _len$[ebp]
  00182	0f af ca	 imul	 ecx, edx
  00185	89 08		 mov	 DWORD PTR [eax], ecx

; 348  : 		*width1 = width;

  00187	8b 45 10	 mov	 eax, DWORD PTR _width1$[ebp]
  0018a	89 10		 mov	 DWORD PTR [eax], edx

; 349  : 		*height1 = height;

  0018c	8b 45 14	 mov	 eax, DWORD PTR _height1$[ebp]
  0018f	89 30		 mov	 DWORD PTR [eax], esi
  00191	8b c3		 mov	 eax, ebx
  00193	5e		 pop	 esi
  00194	5f		 pop	 edi

; 350  : 		return wBuf;
; 351  : 	}
; 352  : }

  00195	5b		 pop	 ebx
  00196	8b e5		 mov	 esp, ebp
  00198	5d		 pop	 ebp
  00199	c3		 ret	 0
$LN12@decoder:
  0019a	5f		 pop	 edi

; 271  : 		return NULL;

  0019b	33 c0		 xor	 eax, eax

; 350  : 		return wBuf;
; 351  : 	}
; 352  : }

  0019d	5b		 pop	 ebx
  0019e	8b e5		 mov	 esp, ebp
  001a0	5d		 pop	 ebp
  001a1	c3		 ret	 0
?decoder@@YAPAEPAEPAPAEPAI22@Z ENDP			; decoder
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\gg862\OneDrive\¹ÙÅÁ È­¸é\¸¾Äí¿Ï·á\Client Source Code1.31ÀÏº»\system\unpack.cpp
;	COMDAT ?encoder@@YAPAEPAEPAPAEIIPAIH@Z
_TEXT	SEGMENT
_el$1$ = -20						; size = 4
tv1256 = -16						; size = 4
_wBuf$1$ = -12						; size = 4
_eBuf$1$ = -8						; size = 4
_ewBuf$1$ = -4						; size = 4
_buf$ = 8						; size = 4
tv1268 = 12						; size = 4
tv1245 = 12						; size = 4
_disBuf$ = 12						; size = 4
_repData$1$ = 15					; size = 1
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_len$ = 24						; size = 4
_cmpFlag$ = 28						; size = 4
?encoder@@YAPAEPAEPAPAEIIPAIH@Z PROC			; encoder, COMDAT

; 18   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx

; 19   : 	unsigned char *wBuf, *ewBuf, *eBuf;
; 20   : 	unsigned char *wBuf1, *buf1;
; 21   : 	unsigned char *wBuf2, *buf2;
; 22   : 	unsigned char idx;
; 23   : 	int flag = 1;
; 24   : 	RD_HEADER *header;
; 25   : 	unsigned int cnt, cnt2;
; 26   : 	unsigned char repData;
; 27   : 	int mode;
; 28   : 	unsigned int l, el;
; 29   : 	int addWBuf;
; 30   : 
; 31   : 	if (*disBuf == NULL) {

  00007	8b 5d 10	 mov	 ebx, DWORD PTR _width$[ebp]
  0000a	56		 push	 esi
  0000b	8b 75 0c	 mov	 esi, DWORD PTR _disBuf$[ebp]
  0000e	57		 push	 edi
  0000f	8b 7d 14	 mov	 edi, DWORD PTR _height$[ebp]
  00012	8b 06		 mov	 eax, DWORD PTR [esi]
  00014	89 45 f4	 mov	 DWORD PTR _wBuf$1$[ebp], eax
  00017	85 c0		 test	 eax, eax
  00019	75 21		 jne	 SHORT $LN17@encoder

; 32   : 		if ((wBuf = (unsigned char *)MALLOC(width * height + sizeof(RD_HEADER))) == NULL)

  0001b	8b c3		 mov	 eax, ebx
  0001d	0f af c7	 imul	 eax, edi
  00020	83 c0 10	 add	 eax, 16			; 00000010H
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 _malloc
  00029	83 c4 04	 add	 esp, 4
  0002c	89 45 f4	 mov	 DWORD PTR _wBuf$1$[ebp], eax
  0002f	85 c0		 test	 eax, eax
  00031	75 07		 jne	 SHORT $LN18@encoder

; 251  : }

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN18@encoder:

; 33   : 		{
; 34   : 			return NULL;
; 35   : 		}
; 36   : #ifdef _STONDEBUG_
; 37   : 		g_iMallocCount++;
; 38   : #endif
; 39   : 		*disBuf = wBuf;

  0003a	89 06		 mov	 DWORD PTR [esi], eax
$LN17@encoder:

; 40   : 	}
; 41   : 	else {
; 42   : 		wBuf = *disBuf;
; 43   : 	}
; 44   : 
; 45   : 	if (cmpFlag) {
; 46   : 		flag = 1;
; 47   : 	}
; 48   : 	else {
; 49   : 		flag = 0;
; 50   : 	}
; 51   : 	eBuf = buf + width * height;

  0003c	8b cb		 mov	 ecx, ebx

; 52   : 	ewBuf = wBuf + width * height + sizeof(RD_HEADER);
; 53   : 	wBuf1 = wBuf + sizeof(RD_HEADER);

  0003e	8d 50 10	 lea	 edx, DWORD PTR [eax+16]
  00041	8b 5d 08	 mov	 ebx, DWORD PTR _buf$[ebp]
  00044	0f af cf	 imul	 ecx, edi
  00047	89 4d ec	 mov	 DWORD PTR _el$1$[ebp], ecx
  0004a	8d 79 10	 lea	 edi, DWORD PTR [ecx+16]
  0004d	03 f8		 add	 edi, eax
  0004f	8d 34 19	 lea	 esi, DWORD PTR [ecx+ebx]
  00052	8b 4d 1c	 mov	 ecx, DWORD PTR _cmpFlag$[ebp]

; 54   : 	buf1 = buf;

  00055	8b c3		 mov	 eax, ebx
  00057	33 db		 xor	 ebx, ebx
  00059	89 75 f8	 mov	 DWORD PTR _eBuf$1$[ebp], esi
  0005c	85 c9		 test	 ecx, ecx
  0005e	89 7d fc	 mov	 DWORD PTR _ewBuf$1$[ebp], edi
  00061	0f 95 c3	 setne	 bl

; 55   : 	while (cmpFlag) {

  00064	85 c9		 test	 ecx, ecx
  00066	0f 84 5b 02 00
	00		 je	 $LN3@encoder
  0006c	0f 1f 40 00	 npad	 4
$LL2@encoder:

; 56   : 		if (buf1 >= eBuf) {

  00070	3b c6		 cmp	 eax, esi
  00072	0f 83 4a 02 00
	00		 jae	 $LN82@encoder

; 58   : 			break;
; 59   : 		}
; 60   : 		if (wBuf1 >= ewBuf) {

  00078	3b d7		 cmp	 edx, edi
  0007a	0f 83 3e 02 00
	00		 jae	 $LN86@encoder

; 61   : 			flag = 0;
; 62   : 			break;
; 63   : 		}
; 64   : 
; 65   : 		if (*buf1 == 0 && *(buf1 + 1) == 0) {

  00080	8a 08		 mov	 cl, BYTE PTR [eax]
  00082	88 4d 0f	 mov	 BYTE PTR _repData$1$[ebp], cl
  00085	84 c9		 test	 cl, cl
  00087	0f 85 9d 00 00
	00		 jne	 $LN111@encoder
  0008d	38 48 01	 cmp	 BYTE PTR [eax+1], cl
  00090	0f 85 94 00 00
	00		 jne	 $LN111@encoder

; 66   : 			idx = BIT_CMP | BIT_ZERO;
; 67   : 			cnt = 2;

  00096	bb 02 00 00 00	 mov	 ebx, 2

; 68   : 			buf1 += 2;

  0009b	03 c3		 add	 eax, ebx

; 69   : 			while (buf1 < eBuf && cnt < 0xfffff) {

  0009d	3b c6		 cmp	 eax, esi
  0009f	73 26		 jae	 SHORT $LN109@encoder
$LL4@encoder:
  000a1	81 fb ff ff 0f
	00		 cmp	 ebx, 1048575		; 000fffffH
  000a7	73 0b		 jae	 SHORT $LN76@encoder

; 70   : 				if (*buf1 != 0) {

  000a9	80 38 00	 cmp	 BYTE PTR [eax], 0
  000ac	75 06		 jne	 SHORT $LN76@encoder

; 71   : 					break;
; 72   : 				}
; 73   : 				buf1++;

  000ae	40		 inc	 eax

; 74   : 				cnt++;

  000af	43		 inc	 ebx
  000b0	3b c6		 cmp	 eax, esi
  000b2	72 ed		 jb	 SHORT $LL4@encoder
$LN76@encoder:

; 75   : 			}
; 76   : 			if (cnt <= 0xf) {

  000b4	83 fb 0f	 cmp	 ebx, 15			; 0000000fH
  000b7	76 0e		 jbe	 SHORT $LN109@encoder

; 78   : 			}
; 79   : 			else
; 80   : 				if (cnt <= 0xfff) {

  000b9	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  000be	3b cb		 cmp	 ecx, ebx
  000c0	1b f6		 sbb	 esi, esi
  000c2	f7 de		 neg	 esi
  000c4	46		 inc	 esi

; 81   : 					addWBuf = 1;
; 82   : 				}
; 83   : 				else {
; 84   : 					addWBuf = 2;

  000c5	eb 02		 jmp	 SHORT $LN28@encoder
$LN109@encoder:

; 77   : 				addWBuf = 0;

  000c7	33 f6		 xor	 esi, esi
$LN28@encoder:

; 85   : 				}
; 86   : 				if (wBuf1 + addWBuf >= ewBuf) {

  000c9	8d 0c 16	 lea	 ecx, DWORD PTR [esi+edx]
  000cc	3b cf		 cmp	 ecx, edi
  000ce	0f 83 ea 01 00
	00		 jae	 $LN86@encoder

; 87   : 					flag = 0;
; 88   : 					break;
; 89   : 				}
; 90   : 				if (addWBuf == 0) {

  000d4	8b 7d fc	 mov	 edi, DWORD PTR _ewBuf$1$[ebp]
  000d7	85 f6		 test	 esi, esi
  000d9	75 0e		 jne	 SHORT $LN30@encoder

; 91   : 					idx |= (cnt & 0x0f);
; 92   : 					*wBuf1++ = idx;
; 93   : 					continue;

  000db	8b 75 f8	 mov	 esi, DWORD PTR _eBuf$1$[ebp]
  000de	80 e3 0f	 and	 bl, 15			; 0000000fH
  000e1	80 cb c0	 or	 bl, 192			; 000000c0H
  000e4	88 1a		 mov	 BYTE PTR [edx], bl
  000e6	42		 inc	 edx
  000e7	eb 87		 jmp	 SHORT $LL2@encoder
$LN30@encoder:

; 94   : 				}
; 95   : 				else
; 96   : 					if (addWBuf == 1) {

  000e9	8b cb		 mov	 ecx, ebx
  000eb	c1 e9 08	 shr	 ecx, 8
  000ee	83 fe 01	 cmp	 esi, 1
  000f1	8b 75 f8	 mov	 esi, DWORD PTR _eBuf$1$[ebp]
  000f4	89 4d 0c	 mov	 DWORD PTR tv1245[ebp], ecx
  000f7	75 13		 jne	 SHORT $LN32@encoder

; 97   : 						idx |= (BIT_REP_LARG | ((cnt >> 8) & 0xf));

  000f9	80 e1 0f	 and	 cl, 15			; 0000000fH
  000fc	80 c9 d0	 or	 cl, 208			; 000000d0H

; 98   : 						*wBuf1++ = idx;

  000ff	88 0a		 mov	 BYTE PTR [edx], cl

; 99   : 						*wBuf1++ = (unsigned char)(cnt & 0xff);

  00101	88 5a 01	 mov	 BYTE PTR [edx+1], bl
  00104	83 c2 02	 add	 edx, 2

; 100  : 						continue;

  00107	e9 64 ff ff ff	 jmp	 $LL2@encoder
$LN32@encoder:

; 101  : 					}
; 102  : 					else {
; 103  : 						idx |= (BIT_REP_LARG2 | ((cnt >> 16) & 0xf));

  0010c	8b cb		 mov	 ecx, ebx
  0010e	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00111	80 e1 0f	 and	 cl, 15			; 0000000fH
  00114	80 c9 e0	 or	 cl, 224			; 000000e0H

; 104  : 						*wBuf1++ = idx;

  00117	88 0a		 mov	 BYTE PTR [edx], cl

; 105  : 						*wBuf1++ = (unsigned char)((cnt >> 8) & 0xff);

  00119	8b 4d 0c	 mov	 ecx, DWORD PTR tv1245[ebp]
  0011c	88 4a 01	 mov	 BYTE PTR [edx+1], cl

; 106  : 						*wBuf1++ = (unsigned char)(cnt & 0xff);

  0011f	88 5a 02	 mov	 BYTE PTR [edx+2], bl
  00122	83 c2 03	 add	 edx, 3

; 107  : 						continue;

  00125	e9 46 ff ff ff	 jmp	 $LL2@encoder
$LN111@encoder:

; 108  : 					}
; 109  : 		}
; 110  : 		if (*buf1 == *(buf1 + 1) && *buf1 == *(buf1 + 2)) {

  0012a	3a 48 01	 cmp	 cl, BYTE PTR [eax+1]
  0012d	0f 85 b9 00 00
	00		 jne	 $LN44@encoder
  00133	3a 48 02	 cmp	 cl, BYTE PTR [eax+2]
  00136	0f 85 b0 00 00
	00		 jne	 $LN44@encoder

; 111  : 			repData = *buf1;
; 112  : 			idx = BIT_CMP;
; 113  : 			cnt = 3;

  0013c	bb 03 00 00 00	 mov	 ebx, 3

; 114  : 			buf1 += 3;

  00141	03 c3		 add	 eax, ebx

; 115  : 			while (buf1 < eBuf && cnt < 0xfffff) {

  00143	3b c6		 cmp	 eax, esi
  00145	73 27		 jae	 SHORT $LN110@encoder
$LL6@encoder:
  00147	81 fb ff ff 0f
	00		 cmp	 ebx, 1048575		; 000fffffH
  0014d	73 0a		 jae	 SHORT $LN77@encoder

; 116  : 				if (*buf1 != repData) {

  0014f	38 08		 cmp	 BYTE PTR [eax], cl
  00151	75 06		 jne	 SHORT $LN77@encoder

; 117  : 					break;
; 118  : 				}
; 119  : 				buf1++;

  00153	40		 inc	 eax

; 120  : 				cnt++;

  00154	43		 inc	 ebx
  00155	3b c6		 cmp	 eax, esi
  00157	72 ee		 jb	 SHORT $LL6@encoder
$LN77@encoder:

; 121  : 			}
; 122  : 			if (cnt <= 0xf) {

  00159	83 fb 0f	 cmp	 ebx, 15			; 0000000fH
  0015c	76 10		 jbe	 SHORT $LN110@encoder

; 124  : 			}
; 125  : 			else
; 126  : 				if (cnt <= 0xfff) {

  0015e	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  00163	3b cb		 cmp	 ecx, ebx
  00165	1b f6		 sbb	 esi, esi
  00167	f7 de		 neg	 esi
  00169	83 c6 02	 add	 esi, 2

; 127  : 					addWBuf = 2;
; 128  : 				}
; 129  : 				else {
; 130  : 					addWBuf = 3;

  0016c	eb 05		 jmp	 SHORT $LN39@encoder
$LN110@encoder:

; 123  : 				addWBuf = 1;

  0016e	be 01 00 00 00	 mov	 esi, 1
$LN39@encoder:

; 131  : 				}
; 132  : 				if (wBuf1 + addWBuf >= ewBuf) {

  00173	8d 0c 16	 lea	 ecx, DWORD PTR [esi+edx]
  00176	3b cf		 cmp	 ecx, edi
  00178	0f 83 40 01 00
	00		 jae	 $LN86@encoder

; 133  : 					flag = 0;
; 134  : 					break;
; 135  : 				}
; 136  : 				if (addWBuf == 1) {

  0017e	8b 7d fc	 mov	 edi, DWORD PTR _ewBuf$1$[ebp]
  00181	83 fe 01	 cmp	 esi, 1
  00184	75 19		 jne	 SHORT $LN41@encoder

; 137  : 					idx |= (cnt & 0x0f);
; 138  : 					*wBuf1++ = idx;
; 139  : 					*wBuf1++ = repData;

  00186	8a 4d 0f	 mov	 cl, BYTE PTR _repData$1$[ebp]
  00189	80 e3 0f	 and	 bl, 15			; 0000000fH

; 140  : 					continue;

  0018c	8b 75 f8	 mov	 esi, DWORD PTR _eBuf$1$[ebp]
  0018f	80 cb 80	 or	 bl, 128			; 00000080H
  00192	88 1a		 mov	 BYTE PTR [edx], bl
  00194	88 4a 01	 mov	 BYTE PTR [edx+1], cl
  00197	83 c2 02	 add	 edx, 2
  0019a	e9 d1 fe ff ff	 jmp	 $LL2@encoder
$LN41@encoder:

; 141  : 				}
; 142  : 				else
; 143  : 					if (addWBuf == 2) {

  0019f	8b cb		 mov	 ecx, ebx
  001a1	c1 e9 08	 shr	 ecx, 8
  001a4	83 fe 02	 cmp	 esi, 2
  001a7	8b 75 f8	 mov	 esi, DWORD PTR _eBuf$1$[ebp]
  001aa	89 4d f0	 mov	 DWORD PTR tv1256[ebp], ecx
  001ad	75 19		 jne	 SHORT $LN43@encoder

; 144  : 						idx |= (BIT_REP_LARG | ((cnt >> 8) & 0xf));

  001af	80 e1 0f	 and	 cl, 15			; 0000000fH
  001b2	80 c9 90	 or	 cl, 144			; 00000090H

; 145  : 						*wBuf1++ = idx;

  001b5	88 0a		 mov	 BYTE PTR [edx], cl

; 146  : 						*wBuf1++ = repData;

  001b7	8a 4d 0f	 mov	 cl, BYTE PTR _repData$1$[ebp]
  001ba	88 4a 01	 mov	 BYTE PTR [edx+1], cl

; 147  : 						*wBuf1++ = (unsigned char)(cnt & 0xff);

  001bd	88 5a 02	 mov	 BYTE PTR [edx+2], bl
  001c0	83 c2 03	 add	 edx, 3

; 148  : 						continue;

  001c3	e9 a8 fe ff ff	 jmp	 $LL2@encoder
$LN43@encoder:

; 149  : 					}
; 150  : 					else {
; 151  : 						idx |= (BIT_REP_LARG2 | ((cnt >> 16) & 0xf));

  001c8	8b cb		 mov	 ecx, ebx
  001ca	c1 e9 10	 shr	 ecx, 16			; 00000010H
  001cd	80 e1 0f	 and	 cl, 15			; 0000000fH
  001d0	80 c9 a0	 or	 cl, 160			; 000000a0H

; 152  : 						*wBuf1++ = idx;

  001d3	88 0a		 mov	 BYTE PTR [edx], cl

; 153  : 						*wBuf1++ = repData;

  001d5	8a 4d 0f	 mov	 cl, BYTE PTR _repData$1$[ebp]
  001d8	88 4a 01	 mov	 BYTE PTR [edx+1], cl

; 154  : 						*wBuf1++ = (unsigned char)((cnt >> 8) & 0xff);

  001db	8b 4d f0	 mov	 ecx, DWORD PTR tv1256[ebp]
  001de	88 4a 02	 mov	 BYTE PTR [edx+2], cl

; 155  : 						*wBuf1++ = (unsigned char)(cnt & 0xff);

  001e1	88 5a 03	 mov	 BYTE PTR [edx+3], bl
  001e4	83 c2 04	 add	 edx, 4

; 156  : 						continue;

  001e7	e9 84 fe ff ff	 jmp	 $LL2@encoder
$LN44@encoder:

; 157  : 					}
; 158  : 		}
; 159  : 		idx = 0;
; 160  : 		cnt2 = 0;

  001ec	33 db		 xor	 ebx, ebx
  001ee	8d 70 02	 lea	 esi, DWORD PTR [eax+2]

; 161  : 		buf2 = buf1;
; 162  : 		wBuf2 = wBuf1;

  001f1	8b fa		 mov	 edi, edx
$LL8@encoder:

; 163  : 		while (1) {
; 164  : 			if (buf2 >= eBuf || cnt2 >= 0xfff) {

  001f3	81 fb ff 0f 00
	00		 cmp	 ebx, 4095		; 00000fffH
  001f9	73 2b		 jae	 SHORT $LN46@encoder

; 165  : 				mode = 0;
; 166  : 				break;
; 167  : 			}
; 168  : 			if (wBuf2 >= ewBuf) {

  001fb	3b 7d fc	 cmp	 edi, DWORD PTR _ewBuf$1$[ebp]
  001fe	73 31		 jae	 SHORT $LN79@encoder

; 171  : 			}
; 172  : 			if (buf2 + 2 < eBuf) {

  00200	3b 75 f8	 cmp	 esi, DWORD PTR _eBuf$1$[ebp]
  00203	73 16		 jae	 SHORT $LN50@encoder

; 173  : 				if (*buf2 == 0 && *(buf2 + 1) == 0) {

  00205	8a 6e fe	 mov	 ch, BYTE PTR [esi-2]
  00208	8a 4e ff	 mov	 cl, BYTE PTR [esi-1]
  0020b	84 ed		 test	 ch, ch
  0020d	75 04		 jne	 SHORT $LN108@encoder
  0020f	84 c9		 test	 cl, cl

; 174  : 					mode = 0;
; 175  : 					break;
; 176  : 				}
; 177  : 				if (*buf2 != 0 && *buf2 == *(buf2 + 1) && *(buf2 + 1) == *(buf2 + 2)) {

  00211	eb 06		 jmp	 SHORT $LN114@encoder
$LN108@encoder:
  00213	3a e9		 cmp	 ch, cl
  00215	75 04		 jne	 SHORT $LN50@encoder
  00217	3a 0e		 cmp	 cl, BYTE PTR [esi]
$LN114@encoder:

; 178  : 					mode = 0;
; 179  : 					break;
; 180  : 				}
; 181  : 
; 182  : 			}
; 183  : 			buf2++;
; 184  : 			wBuf2++;

  00219	74 0b		 je	 SHORT $LN46@encoder
$LN50@encoder:
  0021b	46		 inc	 esi
  0021c	47		 inc	 edi

; 185  : 			cnt2++;

  0021d	43		 inc	 ebx
  0021e	8d 4e fe	 lea	 ecx, DWORD PTR [esi-2]
  00221	3b 4d f8	 cmp	 ecx, DWORD PTR _eBuf$1$[ebp]
  00224	72 cd		 jb	 SHORT $LL8@encoder
$LN46@encoder:

; 186  : 		}
; 187  : 		if (cnt2 <= 0xf) {

  00226	33 c9		 xor	 ecx, ecx
$LN9@encoder:
  00228	83 fb 0f	 cmp	 ebx, 15			; 0000000fH
  0022b	77 0b		 ja	 SHORT $LN51@encoder

; 188  : 			addWBuf = 0;

  0022d	33 f6		 xor	 esi, esi

; 189  : 		}

  0022f	eb 13		 jmp	 SHORT $LN53@encoder
$LN79@encoder:

; 169  : 				mode = 1;

  00231	b9 01 00 00 00	 mov	 ecx, 1

; 170  : 				break;

  00236	eb f0		 jmp	 SHORT $LN9@encoder
$LN51@encoder:

; 190  : 		else
; 191  : 			if (cnt2 <= 0xfff) {

  00238	be ff 0f 00 00	 mov	 esi, 4095		; 00000fffH
  0023d	3b f3		 cmp	 esi, ebx
  0023f	1b f6		 sbb	 esi, esi
  00241	f7 de		 neg	 esi
  00243	46		 inc	 esi
$LN53@encoder:

; 192  : 				addWBuf = 1;
; 193  : 			}
; 194  : 			else {
; 195  : 				addWBuf = 2;
; 196  : 			}
; 197  : 
; 198  : 			if (mode == 1 || wBuf2 + addWBuf >= ewBuf) {

  00244	83 f9 01	 cmp	 ecx, 1
  00247	74 72		 je	 SHORT $LN113@encoder
  00249	8d 0c 37	 lea	 ecx, DWORD PTR [edi+esi]
  0024c	8b 7d fc	 mov	 edi, DWORD PTR _ewBuf$1$[ebp]
  0024f	3b cf		 cmp	 ecx, edi
  00251	73 6b		 jae	 SHORT $LN86@encoder

; 199  : 				flag = 0;
; 200  : 				break;
; 201  : 			}
; 202  : 			if (addWBuf == 0) {

  00253	85 f6		 test	 esi, esi
  00255	75 0a		 jne	 SHORT $LN57@encoder

; 203  : 				idx = (cnt2 & 0xf);

  00257	8a cb		 mov	 cl, bl
  00259	80 e1 0f	 and	 cl, 15			; 0000000fH

; 204  : 				*wBuf1++ = idx;

  0025c	88 0a		 mov	 BYTE PTR [edx], cl
  0025e	42		 inc	 edx

; 205  : 			}

  0025f	eb 36		 jmp	 SHORT $LN60@encoder
$LN57@encoder:

; 206  : 			else
; 207  : 				if (addWBuf == 1) {

  00261	8b cb		 mov	 ecx, ebx
  00263	c1 e9 08	 shr	 ecx, 8
  00266	89 4d 0c	 mov	 DWORD PTR tv1268[ebp], ecx
  00269	83 fe 01	 cmp	 esi, 1
  0026c	75 10		 jne	 SHORT $LN59@encoder

; 208  : 					idx = BIT_REP_LARG | ((cnt2 >> 8) & 0xf);

  0026e	80 e1 0f	 and	 cl, 15			; 0000000fH
  00271	80 c9 10	 or	 cl, 16			; 00000010H

; 209  : 					*wBuf1++ = idx;

  00274	88 0a		 mov	 BYTE PTR [edx], cl

; 210  : 					*wBuf1++ = (unsigned char)(cnt2 & 0xff);

  00276	88 5a 01	 mov	 BYTE PTR [edx+1], bl
  00279	83 c2 02	 add	 edx, 2

; 211  : 				}

  0027c	eb 19		 jmp	 SHORT $LN60@encoder
$LN59@encoder:

; 212  : 				else {
; 213  : 					idx = BIT_REP_LARG2 | ((cnt2 >> 16) & 0xf);

  0027e	8b cb		 mov	 ecx, ebx
  00280	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00283	80 e1 0f	 and	 cl, 15			; 0000000fH
  00286	80 c9 20	 or	 cl, 32			; 00000020H

; 214  : 					*wBuf1++ = idx;

  00289	88 0a		 mov	 BYTE PTR [edx], cl

; 215  : 					*wBuf1++ = (unsigned char)((cnt2 >> 8) & 0xff);

  0028b	8b 4d 0c	 mov	 ecx, DWORD PTR tv1268[ebp]
  0028e	88 4a 01	 mov	 BYTE PTR [edx+1], cl

; 216  : 					*wBuf1++ = (unsigned char)(cnt2 & 0xff);

  00291	88 5a 02	 mov	 BYTE PTR [edx+2], bl
  00294	83 c2 03	 add	 edx, 3
$LN60@encoder:

; 217  : 				}
; 218  : 				for (cnt = 0; cnt < cnt2; cnt++) {

  00297	8b 75 f8	 mov	 esi, DWORD PTR _eBuf$1$[ebp]
  0029a	8b 7d fc	 mov	 edi, DWORD PTR _ewBuf$1$[ebp]
  0029d	85 db		 test	 ebx, ebx
  0029f	0f 84 cb fd ff
	ff		 je	 $LL2@encoder
$LL12@encoder:

; 219  : 					*wBuf1++ = *buf1++;

  002a5	8a 08		 mov	 cl, BYTE PTR [eax]
  002a7	40		 inc	 eax
  002a8	88 0a		 mov	 BYTE PTR [edx], cl
  002aa	42		 inc	 edx
  002ab	83 eb 01	 sub	 ebx, 1
  002ae	75 f5		 jne	 SHORT $LL12@encoder

; 55   : 	while (cmpFlag) {

  002b0	8b 75 f8	 mov	 esi, DWORD PTR _eBuf$1$[ebp]
  002b3	8b 7d fc	 mov	 edi, DWORD PTR _ewBuf$1$[ebp]
  002b6	e9 b5 fd ff ff	 jmp	 $LL2@encoder
$LN113@encoder:

; 192  : 				addWBuf = 1;
; 193  : 			}
; 194  : 			else {
; 195  : 				addWBuf = 2;
; 196  : 			}
; 197  : 
; 198  : 			if (mode == 1 || wBuf2 + addWBuf >= ewBuf) {

  002bb	8b 7d fc	 mov	 edi, DWORD PTR _ewBuf$1$[ebp]
$LN86@encoder:

; 220  : 				}
; 221  : 	}
; 222  : 
; 223  : 
; 224  : 	header = (RD_HEADER *)wBuf;
; 225  : 	header->id[0] = 'R';

  002be	33 db		 xor	 ebx, ebx
  002c0	eb 05		 jmp	 SHORT $LN3@encoder
$LN82@encoder:

; 57   : 			flag = 1;

  002c2	bb 01 00 00 00	 mov	 ebx, 1
$LN3@encoder:

; 220  : 				}
; 221  : 	}
; 222  : 
; 223  : 
; 224  : 	header = (RD_HEADER *)wBuf;
; 225  : 	header->id[0] = 'R';

  002c7	8b 75 f4	 mov	 esi, DWORD PTR _wBuf$1$[ebp]

; 226  : 	header->id[1] = 'D';
; 227  : 	header->width = width;

  002ca	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  002cd	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 228  : 	header->height = height;

  002d0	8b 45 14	 mov	 eax, DWORD PTR _height$[ebp]
  002d3	66 c7 06 52 44	 mov	 WORD PTR [esi], 17490	; 00004452H
  002d8	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 229  : 
; 230  : 	if (flag == 1)

  002db	83 fb 01	 cmp	 ebx, 1
  002de	75 16		 jne	 SHORT $LN61@encoder

; 246  : 		l += sizeof(RD_HEADER);
; 247  : 	}
; 248  : 
; 249  : 	*len = l;

  002e0	8b 45 18	 mov	 eax, DWORD PTR _len$[ebp]
  002e3	2b d6		 sub	 edx, esi
  002e5	88 5e 02	 mov	 BYTE PTR [esi+2], bl
  002e8	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  002eb	5f		 pop	 edi
  002ec	89 10		 mov	 DWORD PTR [eax], edx

; 250  : 	return wBuf;

  002ee	8b c6		 mov	 eax, esi

; 251  : }

  002f0	5e		 pop	 esi
  002f1	5b		 pop	 ebx
  002f2	8b e5		 mov	 esp, ebp
  002f4	5d		 pop	 ebp
  002f5	c3		 ret	 0
$LN61@encoder:

; 240  : 		header->size = (int)wBuf + width * height + sizeof(RD_HEADER);
; 241  : 		wBuf1 = wBuf + sizeof(RD_HEADER);
; 242  : 		buf1 = buf;
; 243  : 		el = width * height;
; 244  : 		for (l = 0; l < el; l++)

  002f6	8b 5d ec	 mov	 ebx, DWORD PTR _el$1$[ebp]
  002f9	33 d2		 xor	 edx, edx
  002fb	c6 46 02 00	 mov	 BYTE PTR [esi+2], 0
  002ff	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  00302	85 db		 test	 ebx, ebx
  00304	74 1c		 je	 SHORT $LN14@encoder

; 231  : 	{
; 232  : 		header->compressFlag = 1;
; 233  : 		header->size = wBuf1 - wBuf;
; 234  : 		l = header->size;
; 235  : 	}
; 236  : 	else
; 237  : 		// ?î™??????
; 238  : 	{
; 239  : 		header->compressFlag = 0;

  00306	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
  00309	8b d3		 mov	 edx, ebx
  0030b	29 4d 08	 sub	 DWORD PTR _buf$[ebp], ecx
  0030e	8b 75 08	 mov	 esi, DWORD PTR _buf$[ebp]
$LL92@encoder:

; 245  : 			*wBuf1++ = *buf1++;

  00311	8a 04 0e	 mov	 al, BYTE PTR [esi+ecx]
  00314	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00317	88 41 ff	 mov	 BYTE PTR [ecx-1], al
  0031a	83 eb 01	 sub	 ebx, 1
  0031d	75 f2		 jne	 SHORT $LL92@encoder
  0031f	8b 75 f4	 mov	 esi, DWORD PTR _wBuf$1$[ebp]
$LN14@encoder:

; 246  : 		l += sizeof(RD_HEADER);
; 247  : 	}
; 248  : 
; 249  : 	*len = l;

  00322	8b 45 18	 mov	 eax, DWORD PTR _len$[ebp]
  00325	83 c2 10	 add	 edx, 16			; 00000010H
  00328	5f		 pop	 edi
  00329	89 10		 mov	 DWORD PTR [eax], edx

; 250  : 	return wBuf;

  0032b	8b c6		 mov	 eax, esi

; 251  : }

  0032d	5e		 pop	 esi
  0032e	5b		 pop	 ebx
  0032f	8b e5		 mov	 esp, ebp
  00331	5d		 pop	 ebp
  00332	c3		 ret	 0
?encoder@@YAPAEPAEPAPAEIIPAIH@Z ENDP			; encoder
_TEXT	ENDS
END
