; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30133.0 

	TITLE	\\VBOXSVR\_stoneage\repos\ssm-sacli\Release\netproc.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?selectServerIndex@@3FA				; selectServerIndex
PUBLIC	?clientLoginStatus@@3FA				; clientLoginStatus
PUBLIC	?charListStatus@@3FA				; charListStatus
PUBLIC	?charDelStatus@@3FA				; charDelStatus
PUBLIC	?gamestate_chooseserver_name@@3PADA		; gamestate_chooseserver_name
PUBLIC	?gamestate_login_charname@@3PADA		; gamestate_login_charname
PUBLIC	?gamestate_deletechar_charname@@3PADA		; gamestate_deletechar_charname
PUBLIC	?netprocErrmsg@@3PADA				; netprocErrmsg
PUBLIC	?bNewServer@@3HA				; bNewServer
PUBLIC	?newCharStatus@@3FA				; newCharStatus
PUBLIC	?charLoginStatus@@3FA				; charLoginStatus
PUBLIC	?charLogoutStatus@@3FA				; charLogoutStatus
PUBLIC	?ERROR_MESSAGE@@3HA				; ERROR_MESSAGE
PUBLIC	?netproc_sending@@3HA				; netproc_sending
PUBLIC	?start_time@@3KA				; start_time
PUBLIC	?c_temp@@3PADA					; c_temp
PUBLIC	?connectServerCounter@@3HA			; connectServerCounter
PUBLIC	?AdvanceSkill@@3PAHA				; AdvanceSkill
PUBLIC	?AssitSkill@@3PAHA				; AssitSkill
PUBLIC	?BattleSkill@@3PAHA				; BattleSkill
PUBLIC	?Ôô???ð«ãÆ@@3PADA				; Ôô???ð«ãÆ
PUBLIC	?sin_server@@3Usockaddr_in@@A			; sin_server
PUBLIC	?hPing@@3PAXA					; hPing
PUBLIC	?dwPingID@@3KA					; dwPingID
PUBLIC	?pCommand@@3PADA				; pCommand
PUBLIC	?dwDiceTimer@@3KA				; dwDiceTimer
PUBLIC	?gStrÎÃ?@@3PADA					; gStrÎÃ?
PUBLIC	?dwPingTime@@3KA				; dwPingTime
PUBLIC	?dwPingState@@3KA				; dwPingState
PUBLIC	?iWrote@@3HA					; iWrote
PUBLIC	?iRead@@3HA					; iRead
PUBLIC	?sockRaw@@3IA					; sockRaw
_BSS	SEGMENT
?clientLoginStatus@@3FA DW 01H DUP (?)			; clientLoginStatus
	ALIGN	4

?charListStatus@@3FA DW 01H DUP (?)			; charListStatus
	ALIGN	4

?charDelStatus@@3FA DW 01H DUP (?)			; charDelStatus
	ALIGN	4

?gamestate_chooseserver_name@@3PADA DB 080H DUP (?)	; gamestate_chooseserver_name
?gamestate_login_charname@@3PADA DB 080H DUP (?)	; gamestate_login_charname
?gamestate_deletechar_charname@@3PADA DB 080H DUP (?)	; gamestate_deletechar_charname
?netprocErrmsg@@3PADA DB 0400H DUP (?)			; netprocErrmsg
?bNewServer@@3HA DD 01H DUP (?)				; bNewServer
?newCharStatus@@3FA DW 01H DUP (?)			; newCharStatus
	ALIGN	4

?charLoginStatus@@3FA DW 01H DUP (?)			; charLoginStatus
	ALIGN	4

?charLogoutStatus@@3FA DW 01H DUP (?)			; charLogoutStatus
	ALIGN	4

?ERROR_MESSAGE@@3HA DD 01H DUP (?)			; ERROR_MESSAGE
?netproc_sending@@3HA DD 01H DUP (?)			; netproc_sending
?start_time@@3KA DD 01H DUP (?)				; start_time
?c_temp@@3PADA DB 0400H DUP (?)				; c_temp
?connectServerCounter@@3HA DD 01H DUP (?)		; connectServerCounter
?Ôô???ð«ãÆ@@3PADA DB 0200H DUP (?)			; Ôô???ð«ãÆ
?sin_server@@3Usockaddr_in@@A DB 010H DUP (?)		; sin_server
?hPing@@3PAXA DD 01H DUP (?)				; hPing
?dwPingID@@3KA DD 01H DUP (?)				; dwPingID
?pCommand@@3PADA DD 01H DUP (?)				; pCommand
?dwDiceTimer@@3KA DD 01H DUP (?)			; dwDiceTimer
?gStrÎÃ?@@3PADA DB 064H DUP (?)				; gStrÎÃ?
?dwPingTime@@3KA DD 01H DUP (?)				; dwPingTime
?dwPingState@@3KA DD 01H DUP (?)			; dwPingState
?iWrote@@3HA DD	01H DUP (?)				; iWrote
?iRead@@3HA DD	01H DUP (?)				; iRead
_BSS	ENDS
_DATA	SEGMENT
?selectServerIndex@@3FA DW 0ffffH			; selectServerIndex
	ORG $+6
?AdvanceSkill@@3PAHA DD 0ffffffffH			; AdvanceSkill
	ORG $+76
?AssitSkill@@3PAHA DD 0ffffffffH			; AssitSkill
	ORG $+76
?BattleSkill@@3PAHA DD 0ffffffffH			; BattleSkill
	ORG $+76
?sockRaw@@3IA DD 0ffffffffH				; sockRaw
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	___local_stdio_scanf_options
PUBLIC	_fprintf
PUBLIC	_printf
PUBLIC	_sprintf
PUBLIC	_sscanf
PUBLIC	?initConnectServer@@YAXXZ			; initConnectServer
PUBLIC	?ConnectWGS@@YAHXZ				; ConnectWGS
PUBLIC	?connectServer@@YAHXZ				; connectServer
PUBLIC	?charListStart@@YAXXZ				; charListStart
PUBLIC	?charListProc@@YAHXZ				; charListProc
PUBLIC	?charLoginStart@@YAXXZ				; charLoginStart
PUBLIC	?charLoginProc@@YAHXZ				; charLoginProc
PUBLIC	?createNewCharStart@@YAXXZ			; createNewCharStart
PUBLIC	?createNewCharProc@@YAHXZ			; createNewCharProc
PUBLIC	?charLogoutStart@@YAXXZ				; charLogoutStart
PUBLIC	?charLogoutProc@@YAHXZ				; charLogoutProc
PUBLIC	?walkSendForServer@@YAXHHPAD@Z			; walkSendForServer
PUBLIC	?noChecksumWalkSendForServer@@YAXHHPAD@Z	; noChecksumWalkSendForServer
PUBLIC	?chatStrSendForServer@@YAXPADH@Z		; chatStrSendForServer
PUBLIC	?delCharStart@@YAXXZ				; delCharStart
PUBLIC	?delCharProc@@YAHXZ				; delCharProc
PUBLIC	?lssproto_DENGON_recv@@YAXPADHH@Z		; lssproto_DENGON_recv
PUBLIC	?lssproto_XYD_recv@@YAXHHHH@Z			; lssproto_XYD_recv
PUBLIC	?lssproto_EV_recv@@YAXHHH@Z			; lssproto_EV_recv
PUBLIC	?lssproto_EN_recv@@YAXHHH@Z			; lssproto_EN_recv
PUBLIC	?lssproto_RS_recv@@YAXHPAD@Z			; lssproto_RS_recv
PUBLIC	?lssproto_RD_recv@@YAXHPAD@Z			; lssproto_RD_recv
PUBLIC	?lssproto_B_recv@@YAXHPAD@Z			; lssproto_B_recv
PUBLIC	?lssproto_I_recv@@YAXHPAD@Z			; lssproto_I_recv
PUBLIC	?lssproto_SI_recv@@YAXHHH@Z			; lssproto_SI_recv
PUBLIC	?lssproto_MSG_recv@@YAXHHPADH@Z			; lssproto_MSG_recv
PUBLIC	?lssproto_PME_recv@@YAXHHHHHHHHPAD@Z		; lssproto_PME_recv
PUBLIC	?lssproto_AB_recv@@YAXHPAD@Z			; lssproto_AB_recv
PUBLIC	?lssproto_ABI_recv@@YAXHHPAD@Z			; lssproto_ABI_recv
PUBLIC	?lssproto_TK_recv@@YAXHHPADH@Z			; lssproto_TK_recv
PUBLIC	?lssproto_MC_recv@@YAXHHHHHHHHHPAD@Z		; lssproto_MC_recv
PUBLIC	?lssproto_M_recv@@YAXHHHHHHPAD@Z		; lssproto_M_recv
PUBLIC	?lssproto_C_recv@@YAXHPAD@Z			; lssproto_C_recv
PUBLIC	?lssproto_CA_recv@@YAXHPAD@Z			; lssproto_CA_recv
PUBLIC	?lssproto_CD_recv@@YAXHPAD@Z			; lssproto_CD_recv
PUBLIC	?lssproto_R_recv@@YAXHPAD@Z			; lssproto_R_recv
PUBLIC	?lssproto_S_recv@@YAXHPAD@Z			; lssproto_S_recv
PUBLIC	?lssproto_D_recv@@YAXHHHHPAD@Z			; lssproto_D_recv
PUBLIC	?lssproto_FS_recv@@YAXHH@Z			; lssproto_FS_recv
PUBLIC	?lssproto_HL_recv@@YAXHH@Z			; lssproto_HL_recv
PUBLIC	?lssproto_PR_recv@@YAXHHH@Z			; lssproto_PR_recv
PUBLIC	?lssproto_KS_recv@@YAXHHH@Z			; lssproto_KS_recv
PUBLIC	?lssproto_SPET_recv@@YAXHHH@Z			; lssproto_SPET_recv
PUBLIC	?lssproto_PS_recv@@YAXHHHHH@Z			; lssproto_PS_recv
PUBLIC	?lssproto_SKUP_recv@@YAXHH@Z			; lssproto_SKUP_recv
PUBLIC	?lssproto_WN_recv@@YAXHHHHHPAD@Z		; lssproto_WN_recv
PUBLIC	?lssproto_EF_recv@@YAXHHHPAD@Z			; lssproto_EF_recv
PUBLIC	?lssproto_SE_recv@@YAXHHHHH@Z			; lssproto_SE_recv
PUBLIC	?lssproto_ClientLogin_recv@@YAXHPAD@Z		; lssproto_ClientLogin_recv
PUBLIC	?lssproto_CreateNewChar_recv@@YAXHPAD0@Z	; lssproto_CreateNewChar_recv
PUBLIC	?lssproto_CharDelete_recv@@YAXHPAD0@Z		; lssproto_CharDelete_recv
PUBLIC	?lssproto_CharLogin_recv@@YAXHPAD0@Z		; lssproto_CharLogin_recv
PUBLIC	?lssproto_CharList_recv@@YAXHPAD0@Z		; lssproto_CharList_recv
PUBLIC	?lssproto_CharLogout_recv@@YAXHPAD0@Z		; lssproto_CharLogout_recv
PUBLIC	?lssproto_ProcGet_recv@@YAXHPAD@Z		; lssproto_ProcGet_recv
PUBLIC	?lssproto_PlayerNumGet_recv@@YAXHHH@Z		; lssproto_PlayerNumGet_recv
PUBLIC	?lssproto_Echo_recv@@YAXHPAD@Z			; lssproto_Echo_recv
PUBLIC	?lssproto_NU_recv@@YAXHH@Z			; lssproto_NU_recv
PUBLIC	?lssproto_FM_recv@@YAXHPAD@Z			; lssproto_FM_recv
PUBLIC	?lssproto_WO_recv@@YAXHH@Z			; lssproto_WO_recv
PUBLIC	?lssproto_IC_recv@@YAXHHH@Z			; lssproto_IC_recv
PUBLIC	?lssproto_NC_recv@@YAXHH@Z			; lssproto_NC_recv
PUBLIC	?lssproto_PETST_recv@@YAXHHH@Z			; lssproto_PETST_recv
PUBLIC	?lssproto_STREET_VENDOR_recv@@YAXHPAD@Z		; lssproto_STREET_VENDOR_recv
PUBLIC	?lssproto_JOBDAILY_recv@@YAXHPAD@Z		; lssproto_JOBDAILY_recv
PUBLIC	?lssproto_TEACHER_SYSTEM_recv@@YAXHPAD@Z	; lssproto_TEACHER_SYSTEM_recv
PUBLIC	?lssproto_S2_recv@@YAXHPAD@Z			; lssproto_S2_recv
PUBLIC	?lssproto_Firework_recv@@YAXHHHH@Z		; lssproto_Firework_recv
PUBLIC	?lssproto_MAMMOTH_OPEN_recv@@YAXPAD@Z		; lssproto_MAMMOTH_OPEN_recv
PUBLIC	?SortSkill@@YAXXZ				; SortSkill
PUBLIC	?SaveChatData@@YAXPADD_N@Z			; SaveChatData
PUBLIC	?LogToRecvdata2@@YAXPAD@Z			; LogToRecvdata2
PUBLIC	?PingFunc@@YGKPAX@Z				; PingFunc
PUBLIC	?lssproto_W_recv@@YAXHHHH@Z			; lssproto_W_recv
PUBLIC	?lssproto_IS_recv@@YAXHPAD@Z			; lssproto_IS_recv
PUBLIC	?lssproto_ACI_recv@@YAXHPAD@Z			; lssproto_ACI_recv
PUBLIC	?checksum@@YAGPAGH@Z				; checksum
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0N@OFOPBFLC@recvdata?4txt@		; `string'
PUBLIC	??_C@_02DPNLHKJD@a?$CL@				; `string'
PUBLIC	??_C@_0L@INAHAGEI@?b?$KF?S?p?$KD?$LK?7?$CFs?6@	; `string'
PUBLIC	??_C@_0BF@JAKPHLLB@?Y?i?$NL?v?$DP?z?$LMsocket?n?$NMTCP?$KB?$KD@ ; `string'
PUBLIC	??_C@_03GMCCICCK@WGS@				; `string'
PUBLIC	??_C@_0BO@BHPEJLIB@?Y?i?$NL?v?$DP?T?p?$NO?C?$NM?W?P?o?n?$NM?$KD?I?$KD?P?j?H?v?G?$KB?$KD?$CI?$CFs?$CJ@ ; `string'
PUBLIC	??_C@_0BI@CKHMFIAG@?Y?i?$NL?v?$DP?c?$LH?$DP?z?$LM?$NO?C?$NM?W?P?o?n?$NM?$DP?o?H?$KB?$KD@ ; `string'
PUBLIC	??_C@_0O@KDOBPHMN@?$DP?V?X?$DP?Z?$LB?q?W?$DP?$PL?$LP?$KB?$KD@ ; `string'
PUBLIC	??_C@_0CM@NBOLBDPM@?$LN?$LK?E?f?$LP?$KB?$MA?L?A?v?5?D?$KL?$LP?$MA?$LN?$LK?$LM?$KN?$LJ?v?$LE?B?5?G?v?$MA?g?5?A?$KB@ ; `string'
PUBLIC	??_C@_02ODPEBLOD@CS@				; `string'
PUBLIC	??_C@_0BC@PMNBOGBM@?$NO?C?$NM?W?P?o?$DP?o?H?$DP?$DP?l?$KL?S?p?$KB?$KD@ ; `string'
PUBLIC	??_C@_0N@LCBBLLOI@www?493sa?4com@		; `string'
PUBLIC	??_C@_0BB@KFDLBKA@?$NO?C?$NM?W?P?o?Y?$KD?$DP?$NM?t?o?a?$DP?$KB?$KD@ ; `string'
PUBLIC	??_C@_0BA@NDJIOBBC@?$OA?$LE?P?o?$DP?S?$NL?w?z?$NM?b?$NM?t?T?R@ ; `string'
PUBLIC	??_C@_05DAOAAINN@login@				; `string'
PUBLIC	??_C@_09BACHGGGK@f?$DLencor1c@			; `string'
PUBLIC	??_C@_08DDDJOECK@19761101@			; `string'
PUBLIC	??_C@_02MFDMBIJM@ok@				; `string'
PUBLIC	??_C@_06ENLDJGGB@cancle@			; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0BC@OCCGLCLB@?$DP?v?$KC?l?Q?Z?$KK?x?z?$DP?$DP?l?$KL?S?p?$KB?$KD@ ; `string'
PUBLIC	??_C@_06ODACHPEO@failed@			; `string'
PUBLIC	??_C@_0L@LHCHIOPJ@successful@			; `string'
PUBLIC	??_C@_0N@OGLBPKPL@OUTOFSERVICE@			; `string'
PUBLIC	??_C@_0O@ENFKOFGC@CHANGE_GALAXY@		; `string'
PUBLIC	??_C@_03NOBDJFIO@301@				; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BA@JFEMHLAM@?T?t?l?$PN?$DP?W?b?$DP?$DP?l?$KL?S?p?$KB?$KD@ ; `string'
PUBLIC	??_C@_0BA@KHEOLEJA@?T?t?u?s?$DP?W?b?$DP?$DP?l?$KL?S?p?$KB?$KD@ ; `string'
PUBLIC	??_C@_01NBENCBCI@?$CK@				; `string'
PUBLIC	??_C@_0M@OMPDAMON@data?$FL1?$FN?3?$CFs?6@	; `string'
PUBLIC	??_C@_0N@GGCIJCKF@?$DP?$DP?$DP?5name?5?$DP?$DP?$DP@ ; `string'
PUBLIC	??_C@_0N@HKHEIDPM@?$DP?$DP?$DP?5memo?5?$DP?$DP?$DP@ ; `string'
PUBLIC	??_C@_08PFECBJKL@?$CFd?5Stone@			; `string'
PUBLIC	??_C@_04BKLDHGDD@P?$HM?$CFs@			; `string'
PUBLIC	??_C@_0BE@BFJFDKGC@?r?$KG?V?$LF?$NO?E?i?D?L?$KL?c?R?$NM?t?o?a?$DP?$KD?$KB@ ; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_03IKGEINEE@?$CFs?5@			; `string'
PUBLIC	??_C@_0L@BFDNBDBG@P?$HM?1tell?5?$CFs@		; `string'
PUBLIC	??_C@_07JGJAFNNL@P?$HM?1FM?$CFs@		; `string'
PUBLIC	??_C@_0N@INHGBDFL@P?$HM?1OCC?$CFs?$KD?$LK?$CFs@	; `string'
PUBLIC	??_C@_08KCFIPDCG@T?$HM?$CFs?$KD?$LK?$CFs@	; `string'
PUBLIC	??_C@_08IPPAKAEL@P?$HM?1WD?5?$CFs@		; `string'
PUBLIC	??_C@_08NGKGAKGM@P?$HM?1XQ?5?$CFs@		; `string'
PUBLIC	??_C@_02HIIGDGEP@TK@				; `string'
PUBLIC	??_C@_02OGAFBLMB@TE@				; `string'
PUBLIC	??_C@_0BH@DFPJGLLL@?$OA?w?X?$KB?V?$PN?t?$LI?c?x?$DP?p?$LG?$KD?$LC?$KD?$LA?$KD?$LA?$OA?$LE?$DP@ ; `string'
PUBLIC	??_C@_0BB@JFAECEMN@?l?Q?Z?$KK?p?$KE?m?B?$DP?$DP?l?$KL?S?p?$KB?$KD@ ; `string'
PUBLIC	??_C@_0BB@ILDAKNL@?l?Q?Z?$KK?$NO?$PL?p?$LG?$DP?$DP?l?$KL?S?p?$KB?$KD@ ; `string'
PUBLIC	??_C@_0BK@NFKFNKL@?$NM?z?$DP?J?$KL?p?i?n?$KE?v?R?t?$LI?q?$PN?$PN?$KI?$DP?a?$LM?c?w?$DP?$KD?$KB@ ; `string'
PUBLIC	??_C@_08EOJECCGN@?$CFX?$HM?$CFX?$HM?$CFX@	; `string'
PUBLIC	??_C@_05HMDCACKA@?$CFX?$HM?$CFX@		; `string'
PUBLIC	??_C@_03ILJCGOLJ@?6?$CFs@			; `string'
PUBLIC	??_C@_0BE@MGOKMGBK@?b?$KF?S?p?$CFs?a?j?$DP?n?$NM?$DP?Z?$KK?$DP?K?l?$KD?$KB@ ; `string'
PUBLIC	??_C@_0BB@JIMIMFE@?b?$KF?S?p?$CFs?a?j?$DP?n?$NM?$DP?K?l?$KD?$KB@ ; `string'
PUBLIC	??_C@_05OAJDDNFL@?c?w?$DP?$KD?$KB@		; `string'
PUBLIC	??_C@_01CPLAODJH@S@				; `string'
PUBLIC	??_C@_01BIAFAFID@F@				; `string'
PUBLIC	??_C@_01CKDDGHAB@D@				; `string'
PUBLIC	??_C@_01GFHCPBMG@C@				; `string'
PUBLIC	??_C@_01LELAEKIP@J@				; `string'
PUBLIC	??_C@_01OCOKONAJ@L@				; `string'
PUBLIC	??_C@_01HMGJMAIH@B@				; `string'
PUBLIC	??_C@_01BBODEMC@G@				; `string'
PUBLIC	??_C@_01GAPBHFFA@T@				; `string'
PUBLIC	??_C@_01DGKLNCNG@R@				; `string'
PUBLIC	??_C@_01EJNLAFE@P@				; `string'
PUBLIC	??_C@_06BCPILJJG@CHANGE@			; `string'
PUBLIC	??_C@_0BG@JGFFJBEF@chat?2?$CF02d?$CF02d?$CF02d?4TXT@ ; `string'
PUBLIC	??_C@_01MCMALHOG@a@				; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0O@PEDECIPG@?X?$NP?$DP?$DP?V?y?$DP?$DP?$DP?j?s?$DP?$DP@ ; `string'
PUBLIC	??_C@_04DIIKDPIA@FAME@				; `string'
PUBLIC	__xmm@45454545454545454545454545454545
PUBLIC	__xmm@ffffffffffffffffffffffffffffffff
EXTRN	___acrt_iob_func:PROC
EXTRN	_fclose:PROC
EXTRN	_fflush:PROC
EXTRN	_fopen:PROC
EXTRN	_fwrite:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___stdio_common_vsscanf:PROC
EXTRN	_strstr:PROC
EXTRN	_strncpy:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__GetCurrentProcessId@0:PROC
EXTRN	__imp__CreateThread@24:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__lstrcpyA@8:PROC
EXTRN	__imp__lstrcatA@8:PROC
EXTRN	__imp__lstrlenA@4:PROC
EXTRN	_atoi:PROC
EXTRN	___WSAFDIsSet@8:PROC
EXTRN	_closesocket@4:PROC
EXTRN	_connect@12:PROC
EXTRN	_ioctlsocket@12:PROC
EXTRN	_htons@4:PROC
EXTRN	_inet_addr@4:PROC
EXTRN	_recv@16:PROC
EXTRN	_recvfrom@24:PROC
EXTRN	_select@20:PROC
EXTRN	_sendto@24:PROC
EXTRN	_setsockopt@20:PROC
EXTRN	_socket@12:PROC
EXTRN	_gethostbyname@4:PROC
EXTRN	_WSAGetLastError@0:PROC
EXTRN	__localtime64:PROC
EXTRN	__time64:PROC
EXTRN	?TimeGetTime@@YAIXZ:PROC			; TimeGetTime
EXTRN	?PaletteChange@@YAXHH@Z:PROC			; PaletteChange
EXTRN	?ChangeProc@@YAXH@Z:PROC			; ChangeProc
EXTRN	?warpEffectProc@@YAXXZ:PROC			; warpEffectProc
EXTRN	?JL_SetFastFightFlag@@YAX_N@Z:PROC		; JL_SetFastFightFlag
EXTRN	?JL_?ïÒìÑÚª@@YAX_N@Z:PROC			; JL_?ïÒìÑÚª
EXTRN	?JL_??÷åüù_üÞ??ïÃ@@YAXXZ:PROC			; JL_??÷åüù_üÞ??ïÃ
EXTRN	?sunday@@YAPADPAD0@Z:PROC			; sunday
EXTRN	?DeathAction@@YAXPAUaction@@@Z:PROC		; DeathAction
EXTRN	?DeathAllAction@@YAXXZ:PROC			; DeathAllAction
EXTRN	?StockChatBufferLine@@YAXPADEH@Z:PROC		; StockChatBufferLine
EXTRN	?StockChatBufferLineExt@@YAXPADEHH@Z:PROC	; StockChatBufferLineExt
EXTRN	?getServerInfo@@YAHHPADPAF@Z:PROC		; getServerInfo
EXTRN	?initNet@@YAHXZ:PROC				; initNet
EXTRN	?cleanupNetwork@@YAXXZ:PROC			; cleanupNetwork
EXTRN	?lssproto_W2_send@@YAXHHHPAD@Z:PROC		; lssproto_W2_send
EXTRN	?lssproto_TK_send@@YAXHHHPADHH@Z:PROC		; lssproto_TK_send
EXTRN	?lssproto_AC_send@@YAXHHHH@Z:PROC		; lssproto_AC_send
EXTRN	?lssproto_SP_send@@YAXHHHH@Z:PROC		; lssproto_SP_send
EXTRN	?lssproto_ClientLogin_send@@YAXHPAD0@Z:PROC	; lssproto_ClientLogin_send
EXTRN	?lssproto_CreateNewChar_send@@YAXHHPADHHHHHHHHHHH@Z:PROC ; lssproto_CreateNewChar_send
EXTRN	?lssproto_CharDelete_send@@YAXHPAD@Z:PROC	; lssproto_CharDelete_send
EXTRN	?lssproto_CharLogin_send@@YAXHPAD@Z:PROC	; lssproto_CharLogin_send
EXTRN	?lssproto_CharList_send@@YAXH@Z:PROC		; lssproto_CharList_send
EXTRN	?lssproto_CharLogout_send@@YAXHH@Z:PROC		; lssproto_CharLogout_send
EXTRN	?lssproto_MA_send@@YAXHHHH@Z:PROC		; lssproto_MA_send
EXTRN	?lssproto_CHATROOM_send@@YAXHPAD@Z:PROC		; lssproto_CHATROOM_send
EXTRN	?old_lssproto_W_send@@YAXHHHPAD@Z:PROC		; old_lssproto_W_send
EXTRN	?old_lssproto_w_send@@YAXHHHPAD@Z:PROC		; old_lssproto_w_send
EXTRN	?old_lssproto_TK_send@@YAXHHHPADHH@Z:PROC	; old_lssproto_TK_send
EXTRN	?old_lssproto_AC_send@@YAXHHHH@Z:PROC		; old_lssproto_AC_send
EXTRN	?old_lssproto_SP_send@@YAXHHHH@Z:PROC		; old_lssproto_SP_send
EXTRN	?old_lssproto_ClientLogin_send@@YAXHPAD0@Z:PROC	; old_lssproto_ClientLogin_send
EXTRN	?old_lssproto_CreateNewChar_send@@YAXHHPADHHHHHHHHHHH@Z:PROC ; old_lssproto_CreateNewChar_send
EXTRN	?old_lssproto_CharDelete_send@@YAXHPAD@Z:PROC	; old_lssproto_CharDelete_send
EXTRN	?old_lssproto_CharLogin_send@@YAXHPAD@Z:PROC	; old_lssproto_CharLogin_send
EXTRN	?old_lssproto_CharList_send@@YAXH@Z:PROC	; old_lssproto_CharList_send
EXTRN	?old_lssproto_CharLogout_send@@YAXH@Z:PROC	; old_lssproto_CharLogout_send
EXTRN	?saveUserSetting@@YAHXZ:PROC			; saveUserSetting
EXTRN	?createPc@@YAXHHHH@Z:PROC			; createPc
EXTRN	?resetPc@@YAXXZ:PROC				; resetPc
EXTRN	?setPcWarpPoint@@YAXHH@Z:PROC			; setPcWarpPoint
EXTRN	?setPcPoint@@YAXXZ:PROC				; setPcPoint
EXTRN	?setPcGraNo@@YAXHH@Z:PROC			; setPcGraNo
EXTRN	?setPcId@@YAXH@Z:PROC				; setPcId
EXTRN	?setPcDir@@YAXH@Z:PROC				; setPcDir
EXTRN	?setPcAction@@YAXH@Z:PROC			; setPcAction
EXTRN	?setPcParam@@YAXPAD0H0HHHHHHHH@Z:PROC		; setPcParam
EXTRN	?updataPcAct@@YAXXZ:PROC			; updataPcAct
EXTRN	?setPcLeader@@YAXXZ:PROC			; setPcLeader
EXTRN	?setPcParty@@YAXXZ:PROC				; setPcParty
EXTRN	?changePcAct@@YAXHHHHHHH@Z:PROC			; changePcAct
EXTRN	?setPcFukidashi@@YAXI@Z:PROC			; setPcFukidashi
EXTRN	?setPcNameColor@@YAXH@Z:PROC			; setPcNameColor
EXTRN	?clearPartyParam@@YAXXZ:PROC			; clearPartyParam
EXTRN	?clearPtActPartyParam@@YAXXZ:PROC		; clearPtActPartyParam
EXTRN	?setCharacterList@@YAHPAD0@Z:PROC		; setCharacterList
EXTRN	?resetCharacterList@@YAHH@Z:PROC		; resetCharacterList
EXTRN	?swapItem@@YAXHH@Z:PROC				; swapItem
EXTRN	?getStringToken@@YAHPADDHH0@Z:PROC		; getStringToken
EXTRN	?getIntegerToken@@YAHPADDH@Z:PROC		; getIntegerToken
EXTRN	?a62toi@@YAHPAD@Z:PROC				; a62toi
EXTRN	?getInteger62Token@@YAHPADDH@Z:PROC		; getInteger62Token
EXTRN	?makeStringFromEscaped@@YAPADPAD@Z:PROC		; makeStringFromEscaped
EXTRN	?makeEscapeString@@YAPADPAD0H@Z:PROC		; makeEscapeString
EXTRN	?resetMap@@YAXXZ:PROC				; resetMap
EXTRN	?createMap@@YAXHHH@Z:PROC			; createMap
EXTRN	?writeMap@@YAHHHHHHPAG00@Z:PROC			; writeMap
EXTRN	?setMap@@YAXHHH@Z:PROC				; setMap
EXTRN	?mapCheckSum@@YAHHHHHHHHH@Z:PROC		; mapCheckSum
EXTRN	?redrawMap@@YAXXZ:PROC				; redrawMap
EXTRN	?updateMapArea@@YAXXZ:PROC			; updateMapArea
EXTRN	?goFrontPartyCharacter@@YAXHHH@Z:PROC		; goFrontPartyCharacter
EXTRN	?initMapEffect@@YAXH@Z:PROC			; initMapEffect
EXTRN	?setNpcNotice@@YAXPAUaction@@H@Z:PROC		; setNpcNotice
EXTRN	?changeCharAct@@YAXPAUaction@@HHHHHHH@Z:PROC	; changeCharAct
EXTRN	?setCharLeader@@YAXPAUaction@@@Z:PROC		; setCharLeader
EXTRN	?setCharParty@@YAXPAUaction@@@Z:PROC		; setCharParty
EXTRN	?delCharParty@@YAXPAUaction@@@Z:PROC		; delCharParty
EXTRN	?setCharMind@@YAXPAUaction@@H@Z:PROC		; setCharMind
EXTRN	?setCharFukidashi@@YAXPAUaction@@I@Z:PROC	; setCharFukidashi
EXTRN	?setCharNameColor@@YAXPAUaction@@H@Z:PROC	; setCharNameColor
EXTRN	?setNpcCharObj@@YAXHHHHHPAD00H0HHHHHHHH@Z:PROC	; setNpcCharObj
EXTRN	?setReturnPetObj@@YAHHHHHHPAD0HHHHH@Z:PROC	; setReturnPetObj
EXTRN	?setItemCharObj@@YAXHHHHHHPAD@Z:PROC		; setItemCharObj
EXTRN	?setMoneyCharObj@@YAXHHHHHHPAD@Z:PROC		; setMoneyCharObj
EXTRN	?delCharObj@@YAXH@Z:PROC			; delCharObj
EXTRN	?resetCharObj@@YAXXZ:PROC			; resetCharObj
EXTRN	?getCharObjAct@@YAPAUaction@@H@Z:PROC		; getCharObjAct
EXTRN	?createPetAction@@YAPAUaction@@HHHHHHH@Z:PROC	; createPetAction
EXTRN	?TradeTalk@@YAXPAD@Z:PROC			; TradeTalk
EXTRN	?SaveMailHistory@@YAHH@Z:PROC			; SaveMailHistory
EXTRN	?CheckMailNoReadFlag@@YAHXZ:PROC		; CheckMailNoReadFlag
EXTRN	?DeathLetterAction@@YAXXZ:PROC			; DeathLetterAction
EXTRN	?BankmanInit@@YAXPAD@Z:PROC			; BankmanInit
EXTRN	?InitSelectChar@@YAXPADH@Z:PROC			; InitSelectChar
EXTRN	?Get@Mammoth@@SAAAV1@XZ:PROC			; Mammoth::Get
EXTRN	?Open@Mammoth@@QAEXPAD@Z:PROC			; Mammoth::Open
EXTRN	?openServerWindow@@YAXHHHHPAD@Z:PROC		; openServerWindow
EXTRN	?RealTimeToSATime@@YAXPAUtagLSTIME@@@Z:PROC	; RealTimeToSATime
EXTRN	?getLSTime@@YA?AW4LSTIME_SECTION@@PAUtagLSTIME@@@Z:PROC ; getLSTime
EXTRN	?play_se@@YAHHHH@Z:PROC				; play_se
EXTRN	?DoHellow@@YAXXZ:PROC				; DoHellow
EXTRN	?DoSKey@@YAXXZ:PROC				; DoSKey
EXTRN	?ecb_crypt@@YAHPAD0II@Z:PROC			; ecb_crypt
EXTRN	__imp__VMProtectBegin@4:PROC
EXTRN	__imp__VMProtectEnd@0:PROC
EXTRN	?initFamilyList@@YAXPAD@Z:PROC			; initFamilyList
EXTRN	?initFamilyDetail@@YAXPAD@Z:PROC		; initFamilyDetail
EXTRN	?initJoinChannel2WN@@YAXPAD@Z:PROC		; initJoinChannel2WN
EXTRN	?initFamilyTaxWN@@YAXPAD@Z:PROC			; initFamilyTaxWN
EXTRN	?initFamilyLeaderChange@@YAXPAD@Z:PROC		; initFamilyLeaderChange
EXTRN	?StreetVendorWndfunc@@YAX_NPAD@Z:PROC		; StreetVendorWndfunc
EXTRN	?StreetVendorBuyWndfunc@@YAXPAD@Z:PROC		; StreetVendorBuyWndfunc
EXTRN	?TeacherSystemWndfunc@@YAXHPAD@Z:PROC		; TeacherSystemWndfunc
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
EXTRN	?ProcNo@@3IA:DWORD				; ProcNo
EXTRN	?SubProcNo@@3IA:DWORD				; SubProcNo
EXTRN	?palNo@@3HA:DWORD				; palNo
EXTRN	?palTime@@3HA:DWORD				; palTime
EXTRN	?PersonalKey@@3PADA:BYTE			; PersonalKey
EXTRN	?NowMaxVoice@@3HA:DWORD				; NowMaxVoice
EXTRN	?sockfd@@3IA:DWORD				; sockfd
EXTRN	?server_choosed@@3HA:DWORD			; server_choosed
EXTRN	?init_net@@3HA:DWORD				; init_net
EXTRN	?disconnectServerFlag@@3HA:DWORD		; disconnectServerFlag
EXTRN	?oldDisconnectServerFlag@@3HA:DWORD		; oldDisconnectServerFlag
EXTRN	?SendCount@@3HA:DWORD				; SendCount
EXTRN	?sPetStatFlag@@3HA:DWORD			; sPetStatFlag
EXTRN	?pc@@3UPC@@A:BYTE				; pc
EXTRN	?selectPcNo@@3FA:WORD				; selectPcNo
EXTRN	?prSendFlag@@3FA:WORD				; prSendFlag
EXTRN	?jbSendFlag@@3FA:WORD				; jbSendFlag
EXTRN	?duelSendFlag@@3FA:WORD				; duelSendFlag
EXTRN	?helpFlag@@3FA:WORD				; helpFlag
EXTRN	?tradeStatus@@3FA:WORD				; tradeStatus
EXTRN	?magic@@3PAUMAGIC@@A:BYTE			; magic
EXTRN	?pet@@3PAUPET@@A:BYTE				; pet
EXTRN	?party@@3PAUPARTY@@A:BYTE			; party
EXTRN	?partyModeFlag@@3FA:WORD			; partyModeFlag
EXTRN	?addressBook@@3PAUADDRESS_BOOK@@A:BYTE		; addressBook
EXTRN	?battleResultMsg@@3UBATTLE_RESULT_MSG@@A:BYTE	; battleResultMsg
EXTRN	?petSkill@@3PAY06UPET_SKILL@@A:BYTE		; petSkill
EXTRN	?newCharacterName@@3PADA:BYTE			; newCharacterName
EXTRN	?newCharacterGraNo@@3HA:DWORD			; newCharacterGraNo
EXTRN	?newCharacterFaceGraNo@@3HA:DWORD		; newCharacterFaceGraNo
EXTRN	?newCharacterVit@@3HA:DWORD			; newCharacterVit
EXTRN	?newCharacterStr@@3HA:DWORD			; newCharacterStr
EXTRN	?newCharacterTgh@@3HA:DWORD			; newCharacterTgh
EXTRN	?newCharacterDex@@3HA:DWORD			; newCharacterDex
EXTRN	?newCharacterEarth@@3HA:DWORD			; newCharacterEarth
EXTRN	?newCharacterWater@@3HA:DWORD			; newCharacterWater
EXTRN	?newCharacterFire@@3HA:DWORD			; newCharacterFire
EXTRN	?newCharacterWind@@3HA:DWORD			; newCharacterWind
EXTRN	?newCharacterHomeTown@@3HA:DWORD		; newCharacterHomeTown
EXTRN	?profession_skill@@3PAUPROFESSION_SKILL@@A:BYTE	; profession_skill
EXTRN	?nowFloorName@@3PADA:BYTE			; nowFloorName
EXTRN	?nowFloor@@3HA:DWORD				; nowFloor
EXTRN	?nowFloorGxSize@@3HA:DWORD			; nowFloorGxSize
EXTRN	?nowFloorGySize@@3HA:DWORD			; nowFloorGySize
EXTRN	?nowGx@@3HA:DWORD				; nowGx
EXTRN	?nowGy@@3HA:DWORD				; nowGy
EXTRN	?nextGx@@3HA:DWORD				; nextGx
EXTRN	?nextGy@@3HA:DWORD				; nextGy
EXTRN	?mapEmptyFlag@@3HA:DWORD			; mapEmptyFlag
EXTRN	?nowEncountPercentage@@3FA:WORD			; nowEncountPercentage
EXTRN	?nowEncountExtra@@3FA:WORD			; nowEncountExtra
EXTRN	?minEncountPercentage@@3FA:WORD			; minEncountPercentage
EXTRN	?maxEncountPercentage@@3FA:WORD			; maxEncountPercentage
EXTRN	?sendEnFlag@@3FA:WORD				; sendEnFlag
EXTRN	?encountNowFlag@@3FA:WORD			; encountNowFlag
EXTRN	?eventWarpSendFlag@@3FA:WORD			; eventWarpSendFlag
EXTRN	?eventWarpSendId@@3FA:WORD			; eventWarpSendId
EXTRN	?eventEnemySendFlag@@3FA:WORD			; eventEnemySendFlag
EXTRN	?eventEnemySendId@@3FA:WORD			; eventEnemySendId
EXTRN	?eventEnemyFlag@@3FA:WORD			; eventEnemyFlag
EXTRN	?loginFlag@@3HA:DWORD				; loginFlag
EXTRN	?vsLookFlag@@3FA:WORD				; vsLookFlag
EXTRN	?floorChangeFlag@@3HA:DWORD			; floorChangeFlag
EXTRN	?warpEffectFlag@@3HA:DWORD			; warpEffectFlag
EXTRN	?warpEffectStart@@3HA:DWORD			; warpEffectStart
EXTRN	?warpEffectOk@@3HA:DWORD			; warpEffectOk
EXTRN	?transmigrationEffectFlag@@3HA:DWORD		; transmigrationEffectFlag
EXTRN	?mapEffectRainLevel@@3FA:WORD			; mapEffectRainLevel
EXTRN	?mapEffectSnowLevel@@3FA:WORD			; mapEffectSnowLevel
EXTRN	?mapEffectKamiFubukiLevel@@3FA:WORD		; mapEffectKamiFubukiLevel
EXTRN	?mapEffectHalloween@@3HA:DWORD			; mapEffectHalloween
EXTRN	?BattleCmdBak@@3PAY0BAAA@DA:BYTE		; BattleCmdBak
EXTRN	?BattleCmdReadPointer@@3HA:DWORD		; BattleCmdReadPointer
EXTRN	?BattleCmdWritePointer@@3HA:DWORD		; BattleCmdWritePointer
EXTRN	?BattleStatusBak@@3PAY0BAAA@DA:BYTE		; BattleStatusBak
EXTRN	?BattleStatusReadPointer@@3HA:DWORD		; BattleStatusReadPointer
EXTRN	?BattleStatusWritePointer@@3HA:DWORD		; BattleStatusWritePointer
EXTRN	?BattleMyNo@@3HA:DWORD				; BattleMyNo
EXTRN	?BattleMyMp@@3HA:DWORD				; BattleMyMp
EXTRN	?BattleEscFlag@@3HA:DWORD			; BattleEscFlag
EXTRN	?BattlePetStMenCnt@@3HA:DWORD			; BattlePetStMenCnt
EXTRN	?battlePetNoBak@@3HA:DWORD			; battlePetNoBak
EXTRN	?BattleBpFlag@@3HA:DWORD			; BattleBpFlag
EXTRN	?BattleAnimFlag@@3HA:DWORD			; BattleAnimFlag
EXTRN	?BattleTurnReceiveFlag@@3HA:DWORD		; BattleTurnReceiveFlag
EXTRN	?BattleCliTurnNo@@3HA:DWORD			; BattleCliTurnNo
EXTRN	?BattleSvTurnNo@@3HA:DWORD			; BattleSvTurnNo
EXTRN	?EncountFlag@@3HA:DWORD				; EncountFlag
EXTRN	?NoCastFlag@@3HA:DWORD				; NoCastFlag
EXTRN	?DuelFlag@@3HA:DWORD				; DuelFlag
EXTRN	?BattleMapNo@@3HA:DWORD				; BattleMapNo
EXTRN	?MenuToggleFlag@@3IA:DWORD			; MenuToggleFlag
EXTRN	?StatusUpPoint@@3HA:DWORD			; StatusUpPoint
EXTRN	?BattlePetReceiveFlag@@3HA:DWORD		; BattlePetReceiveFlag
EXTRN	?StandbyPetSendFlag@@3HA:DWORD			; StandbyPetSendFlag
EXTRN	?BattlePetReceivePetNo@@3HA:DWORD		; BattlePetReceivePetNo
EXTRN	?MailHistory@@3PAUMAIL_HISTORY@@A:BYTE		; MailHistory
EXTRN	?mailHistoryWndPageNo@@3HA:DWORD		; mailHistoryWndPageNo
EXTRN	?mailHistoryWndSelectNo@@3HA:DWORD		; mailHistoryWndSelectNo
EXTRN	?MapWmdFlagBak@@3HA:DWORD			; MapWmdFlagBak
EXTRN	?ItemMixRecvFlag@@3HA:DWORD			; ItemMixRecvFlag
EXTRN	?TalkMode@@3HA:DWORD				; TalkMode
EXTRN	?secretName@@3PADA:BYTE				; secretName
EXTRN	?logOutFlag@@3HA:DWORD				; logOutFlag
EXTRN	?MsgCooltime@@3IA:DWORD				; MsgCooltime
EXTRN	?SaTime@@3UtagLSTIME@@A:BYTE			; SaTime
EXTRN	?serverTime@@3JA:DWORD				; serverTime
EXTRN	?FirstTime@@3JA:DWORD				; FirstTime
EXTRN	?SaTimeZoneNo@@3HA:DWORD			; SaTimeZoneNo
EXTRN	?TimeZonePalChangeFlag@@3HA:DWORD		; TimeZonePalChangeFlag
EXTRN	?angelFlag@@3HA:DWORD				; angelFlag
EXTRN	?angelMsg@@3PADA:BYTE				; angelMsg
EXTRN	?drawTimeAnimeFlag@@3FA:WORD			; drawTimeAnimeFlag
EXTRN	?mailLamp@@3FA:WORD				; mailLamp
EXTRN	?serverAliveTime@@3PAUtm@@A:DWORD		; serverAliveTime
EXTRN	?serverAliveLongTime@@3_JA:QWORD		; serverAliveLongTime
EXTRN	?dwServer@@3KA:DWORD				; dwServer
EXTRN	?iWGS@@3HA:DWORD				; iWGS
EXTRN	?szWGS@@3PADA:BYTE				; szWGS
EXTRN	?wWGS@@3GA:WORD					; wWGS
EXTRN	?szCSIP@@3PADA:BYTE				; szCSIP
EXTRN	?wCS@@3GA:WORD					; wCS
EXTRN	?PcLanded@@3ULanded@@A:BYTE			; PcLanded
EXTRN	?szUser@@3PADA:BYTE				; szUser
EXTRN	?szPassword@@3PADA:BYTE				; szPassword
EXTRN	?iEncrypt@@3HA:DWORD				; iEncrypt
EXTRN	?NoDelay@@3HA:DWORD				; NoDelay
EXTRN	?g_Ü×?Ðï@@3HA:DWORD				; g_Ü×?Ðï
EXTRN	?itemWndMaxBag@@3HA:DWORD			; itemWndMaxBag
EXTRN	?g_bFastFight@@3HA:DWORD			; g_bFastFight
EXTRN	?g_flag_FastFight@@3HA:DWORD			; g_flag_FastFight
EXTRN	?g_bFastFight@@3HA:DWORD			; g_bFastFight
EXTRN	?m_bt@@3_NA:BYTE				; m_bt
EXTRN	?sStreetVendorBtn@@3FA:WORD			; sStreetVendorBtn
EXTRN	?sStreetVendorBuyBtn@@3FA:WORD			; sStreetVendorBuyBtn
EXTRN	?jobdaily@@3PAUJOBDAILY@@A:BYTE			; jobdaily
EXTRN	?JobdailyGetFlag@@3HA:DWORD			; JobdailyGetFlag
EXTRN	?JobdailyGetMax@@3HA:DWORD			; JobdailyGetMax
EXTRN	?sTeacherSystemBtn@@3FA:WORD			; sTeacherSystemBtn
EXTRN	?ÍëÍ±?Õá@@3HA:DWORD				; ÍëÍ±?Õá
EXTRN	?ÍëÍ±?é»@@3PADA:BYTE				; ÍëÍ±?é»
EXTRN	?ÍëÍ±?ßä@@3HA:DWORD				; ÍëÍ±?ßä
EXTRN	?ÍëÍ±??@@3HA:DWORD				; ÍëÍ±??
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?count@?1??connectServer@@YAHXZ@4HA
_BSS	SEGMENT
?count@?1??connectServer@@YAHXZ@4HA DD 01H DUP (?)	; `connectServer'::`2'::count
_BSS	ENDS
;	COMDAT ?pFile@?1??SaveChatData@@YAXPADD_N@Z@4PAPAU_iobuf@@A
_BSS	SEGMENT
?pFile@?1??SaveChatData@@YAXPADD_N@Z@4PAPAU_iobuf@@A DD 05H DUP (?) ; `SaveChatData'::`2'::pFile
_BSS	ENDS
;	COMDAT ?szFileName@?1??SaveChatData@@YAXPADD_N@Z@4PADA
_BSS	SEGMENT
?szFileName@?1??SaveChatData@@YAXPADD_N@Z@4PADA DB 0100H DUP (?) ; `SaveChatData'::`2'::szFileName
_BSS	ENDS
;	COMDAT ?nowTime@?1??SaveChatData@@YAXPADD_N@Z@4PAUtm@@A
_BSS	SEGMENT
?nowTime@?1??SaveChatData@@YAXPADD_N@Z@4PAUtm@@A DD 01H DUP (?) ; `SaveChatData'::`2'::nowTime
_BSS	ENDS
;	COMDAT ?longTime@?1??SaveChatData@@YAXPADD_N@Z@4_JA
_BSS	SEGMENT
?longTime@?1??SaveChatData@@YAXPADD_N@Z@4_JA DQ 01H DUP (?) ; `SaveChatData'::`2'::longTime
_BSS	ENDS
;	COMDAT __xmm@ffffffffffffffffffffffffffffffff
CONST	SEGMENT
__xmm@ffffffffffffffffffffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
CONST	ENDS
;	COMDAT __xmm@45454545454545454545454545454545
CONST	SEGMENT
__xmm@45454545454545454545454545454545 DB 'EEEEEEEEEEEEEEEE'
CONST	ENDS
;	COMDAT ??_C@_04DIIKDPIA@FAME@
CONST	SEGMENT
??_C@_04DIIKDPIA@FAME@ DB 'FAME', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PEDECIPG@?X?$NP?$DP?$DP?V?y?$DP?$DP?$DP?j?s?$DP?$DP@
CONST	SEGMENT
??_C@_0O@PEDECIPG@?X?$NP?$DP?$DP?V?y?$DP?$DP?$DP?j?s?$DP?$DP@ DB 0d8H, 0dfH
	DB	'??', 0d6H, 0f9H, '???', 0eaH, 0f3H, '??', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01MCMALHOG@a@
CONST	SEGMENT
??_C@_01MCMALHOG@a@ DB 'a', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JGFFJBEF@chat?2?$CF02d?$CF02d?$CF02d?4TXT@
CONST	SEGMENT
??_C@_0BG@JGFFJBEF@chat?2?$CF02d?$CF02d?$CF02d?4TXT@ DB 'chat\%02d%02d%02'
	DB	'd.TXT', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06BCPILJJG@CHANGE@
CONST	SEGMENT
??_C@_06BCPILJJG@CHANGE@ DB 'CHANGE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01EJNLAFE@P@
CONST	SEGMENT
??_C@_01EJNLAFE@P@ DB 'P', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01DGKLNCNG@R@
CONST	SEGMENT
??_C@_01DGKLNCNG@R@ DB 'R', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01GAPBHFFA@T@
CONST	SEGMENT
??_C@_01GAPBHFFA@T@ DB 'T', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01BBODEMC@G@
CONST	SEGMENT
??_C@_01BBODEMC@G@ DB 'G', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01HMGJMAIH@B@
CONST	SEGMENT
??_C@_01HMGJMAIH@B@ DB 'B', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01OCOKONAJ@L@
CONST	SEGMENT
??_C@_01OCOKONAJ@L@ DB 'L', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01LELAEKIP@J@
CONST	SEGMENT
??_C@_01LELAEKIP@J@ DB 'J', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C@
CONST	SEGMENT
??_C@_01GFHCPBMG@C@ DB 'C', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01CKDDGHAB@D@
CONST	SEGMENT
??_C@_01CKDDGHAB@D@ DB 'D', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01BIAFAFID@F@
CONST	SEGMENT
??_C@_01BIAFAFID@F@ DB 'F', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01CPLAODJH@S@
CONST	SEGMENT
??_C@_01CPLAODJH@S@ DB 'S', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05OAJDDNFL@?c?w?$DP?$KD?$KB@
CONST	SEGMENT
??_C@_05OAJDDNFL@?c?w?$DP?$KD?$KB@ DB 0e3H, 0f7H, '?', 0a3H, 0a1H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JIMIMFE@?b?$KF?S?p?$CFs?a?j?$DP?n?$NM?$DP?K?l?$KD?$KB@
CONST	SEGMENT
??_C@_0BB@JIMIMFE@?b?$KF?S?p?$CFs?a?j?$DP?n?$NM?$DP?K?l?$KD?$KB@ DB 0e2H, 0a5H
	DB	0d3H, 0f0H, '%s', 0e1H, 0eaH, '?', 0eeH, 0dcH, '?', 0cbH, 0ecH
	DB	0a3H, 0a1H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MGOKMGBK@?b?$KF?S?p?$CFs?a?j?$DP?n?$NM?$DP?Z?$KK?$DP?K?l?$KD?$KB@
CONST	SEGMENT
??_C@_0BE@MGOKMGBK@?b?$KF?S?p?$CFs?a?j?$DP?n?$NM?$DP?Z?$KK?$DP?K?l?$KD?$KB@ DB 0e2H
	DB	0a5H, 0d3H, 0f0H, '%s', 0e1H, 0eaH, '?', 0eeH, 0dcH, '?', 0daH
	DB	0aaH, '?', 0cbH, 0ecH, 0a3H, 0a1H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03ILJCGOLJ@?6?$CFs@
CONST	SEGMENT
??_C@_03ILJCGOLJ@?6?$CFs@ DB 0aH, '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HMDCACKA@?$CFX?$HM?$CFX@
CONST	SEGMENT
??_C@_05HMDCACKA@?$CFX?$HM?$CFX@ DB '%X|%X', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EOJECCGN@?$CFX?$HM?$CFX?$HM?$CFX@
CONST	SEGMENT
??_C@_08EOJECCGN@?$CFX?$HM?$CFX?$HM?$CFX@ DB '%X|%X|%X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NFKFNKL@?$NM?z?$DP?J?$KL?p?i?n?$KE?v?R?t?$LI?q?$PN?$PN?$KI?$DP?a?$LM?c?w?$DP?$KD?$KB@
CONST	SEGMENT
??_C@_0BK@NFKFNKL@?$NM?z?$DP?J?$KL?p?i?n?$KE?v?R?t?$LI?q?$PN?$PN?$KI?$DP?a?$LM?c?w?$DP?$KD?$KB@ DB 0dcH
	DB	0faH, '?', 0caH, 0abH, 0f0H, 0e9H, 0eeH, 0a4H, 0f6H, 0d2H, 0f4H
	DB	0b8H, 0f1H, 0fdH, 0fdH, 0a8H, '?', 0e1H, 0bcH, 0e3H, 0f7H, '?', 0a3H
	DB	0a1H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ILDAKNL@?l?Q?Z?$KK?$NO?$PL?p?$LG?$DP?$DP?l?$KL?S?p?$KB?$KD@
CONST	SEGMENT
??_C@_0BB@ILDAKNL@?l?Q?Z?$KK?$NO?$PL?p?$LG?$DP?$DP?l?$KL?S?p?$KB?$KD@ DB 0ecH
	DB	0d1H, 0daH, 0aaH, 0deH, 0fbH, 0f0H, 0b6H, '??', 0ecH, 0abH, 0d3H
	DB	0f0H, 0a1H, 0a3H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JFAECEMN@?l?Q?Z?$KK?p?$KE?m?B?$DP?$DP?l?$KL?S?p?$KB?$KD@
CONST	SEGMENT
??_C@_0BB@JFAECEMN@?l?Q?Z?$KK?p?$KE?m?B?$DP?$DP?l?$KL?S?p?$KB?$KD@ DB 0ecH
	DB	0d1H, 0daH, 0aaH, 0f0H, 0a4H, 0edH, 0c2H, '??', 0ecH, 0abH, 0d3H
	DB	0f0H, 0a1H, 0a3H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DFPJGLLL@?$OA?w?X?$KB?V?$PN?t?$LI?c?x?$DP?p?$LG?$KD?$LC?$KD?$LA?$KD?$LA?$OA?$LE?$DP@
CONST	SEGMENT
??_C@_0BH@DFPJGLLL@?$OA?w?X?$KB?V?$PN?t?$LI?c?x?$DP?p?$LG?$KD?$LC?$KD?$LA?$KD?$LA?$OA?$LE?$DP@ DB 0e0H
	DB	0f7H, 0d8H, 0a1H, 0d6H, 0fdH, 0f4H, 0b8H, 0e3H, 0f8H, '?', 0f0H
	DB	0b6H, 0a3H, 0b2H, 0a3H, 0b0H, 0a3H, 0b0H, 0e0H, 0b4H, '?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02OGAFBLMB@TE@
CONST	SEGMENT
??_C@_02OGAFBLMB@TE@ DB 'TE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIIGDGEP@TK@
CONST	SEGMENT
??_C@_02HIIGDGEP@TK@ DB 'TK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08NGKGAKGM@P?$HM?1XQ?5?$CFs@
CONST	SEGMENT
??_C@_08NGKGAKGM@P?$HM?1XQ?5?$CFs@ DB 'P|/XQ %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IPPAKAEL@P?$HM?1WD?5?$CFs@
CONST	SEGMENT
??_C@_08IPPAKAEL@P?$HM?1WD?5?$CFs@ DB 'P|/WD %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KCFIPDCG@T?$HM?$CFs?$KD?$LK?$CFs@
CONST	SEGMENT
??_C@_08KCFIPDCG@T?$HM?$CFs?$KD?$LK?$CFs@ DB 'T|%s', 0a3H, 0baH, '%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@INHGBDFL@P?$HM?1OCC?$CFs?$KD?$LK?$CFs@
CONST	SEGMENT
??_C@_0N@INHGBDFL@P?$HM?1OCC?$CFs?$KD?$LK?$CFs@ DB 'P|/OCC%s', 0a3H, 0baH
	DB	'%s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07JGJAFNNL@P?$HM?1FM?$CFs@
CONST	SEGMENT
??_C@_07JGJAFNNL@P?$HM?1FM?$CFs@ DB 'P|/FM%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BFDNBDBG@P?$HM?1tell?5?$CFs@
CONST	SEGMENT
??_C@_0L@BFDNBDBG@P?$HM?1tell?5?$CFs@ DB 'P|/tell %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03IKGEINEE@?$CFs?5@
CONST	SEGMENT
??_C@_03IKGEINEE@?$CFs?5@ DB '%s ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BFJFDKGC@?r?$KG?V?$LF?$NO?E?i?D?L?$KL?c?R?$NM?t?o?a?$DP?$KD?$KB@
CONST	SEGMENT
??_C@_0BE@BFJFDKGC@?r?$KG?V?$LF?$NO?E?i?D?L?$KL?c?R?$NM?t?o?a?$DP?$KD?$KB@ DB 0f2H
	DB	0a6H, 0d6H, 0b5H, 0deH, 0c5H, 0e9H, 0c4H, 0ccH, 0abH, 0e3H, 0d2H
	DB	0dcH, 0f4H, 0efH, 0e1H, '?', 0a3H, 0a1H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04BKLDHGDD@P?$HM?$CFs@
CONST	SEGMENT
??_C@_04BKLDHGDD@P?$HM?$CFs@ DB 'P|%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PFECBJKL@?$CFd?5Stone@
CONST	SEGMENT
??_C@_08PFECBJKL@?$CFd?5Stone@ DB '%d Stone', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HKHEIDPM@?$DP?$DP?$DP?5memo?5?$DP?$DP?$DP@
CONST	SEGMENT
??_C@_0N@HKHEIDPM@?$DP?$DP?$DP?5memo?5?$DP?$DP?$DP@ DB '??? memo ???', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GGCIJCKF@?$DP?$DP?$DP?5name?5?$DP?$DP?$DP@
CONST	SEGMENT
??_C@_0N@GGCIJCKF@?$DP?$DP?$DP?5name?5?$DP?$DP?$DP@ DB '??? name ???', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OMPDAMON@data?$FL1?$FN?3?$CFs?6@
CONST	SEGMENT
??_C@_0M@OMPDAMON@data?$FL1?$FN?3?$CFs?6@ DB 'data[1]:%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01NBENCBCI@?$CK@
CONST	SEGMENT
??_C@_01NBENCBCI@?$CK@ DB '*', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KHEOLEJA@?T?t?u?s?$DP?W?b?$DP?$DP?l?$KL?S?p?$KB?$KD@
CONST	SEGMENT
??_C@_0BA@KHEOLEJA@?T?t?u?s?$DP?W?b?$DP?$DP?l?$KL?S?p?$KB?$KD@ DB 0d4H, 0f4H
	DB	0f5H, 0f3H, '?', 0d7H, 0e2H, '??', 0ecH, 0abH, 0d3H, 0f0H, 0a1H
	DB	0a3H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFEMHLAM@?T?t?l?$PN?$DP?W?b?$DP?$DP?l?$KL?S?p?$KB?$KD@
CONST	SEGMENT
??_C@_0BA@JFEMHLAM@?T?t?l?$PN?$DP?W?b?$DP?$DP?l?$KL?S?p?$KB?$KD@ DB 0d4H, 0f4H
	DB	0ecH, 0fdH, '?', 0d7H, 0e2H, '??', 0ecH, 0abH, 0d3H, 0f0H, 0a1H
	DB	0a3H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03NOBDJFIO@301@
CONST	SEGMENT
??_C@_03NOBDJFIO@301@ DB '301', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ENFKOFGC@CHANGE_GALAXY@
CONST	SEGMENT
??_C@_0O@ENFKOFGC@CHANGE_GALAXY@ DB 'CHANGE_GALAXY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OGLBPKPL@OUTOFSERVICE@
CONST	SEGMENT
??_C@_0N@OGLBPKPL@OUTOFSERVICE@ DB 'OUTOFSERVICE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LHCHIOPJ@successful@
CONST	SEGMENT
??_C@_0L@LHCHIOPJ@successful@ DB 'successful', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06ODACHPEO@failed@
CONST	SEGMENT
??_C@_06ODACHPEO@failed@ DB 'failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OCCGLCLB@?$DP?v?$KC?l?Q?Z?$KK?x?z?$DP?$DP?l?$KL?S?p?$KB?$KD@
CONST	SEGMENT
??_C@_0BC@OCCGLCLB@?$DP?v?$KC?l?Q?Z?$KK?x?z?$DP?$DP?l?$KL?S?p?$KB?$KD@ DB '?'
	DB	0f6H, 0a2H, 0ecH, 0d1H, 0daH, 0aaH, 0f8H, 0faH, '??', 0ecH, 0abH
	DB	0d3H, 0f0H, 0a1H, 0a3H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06ENLDJGGB@cancle@
CONST	SEGMENT
??_C@_06ENLDJGGB@cancle@ DB 'cancle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02MFDMBIJM@ok@
CONST	SEGMENT
??_C@_02MFDMBIJM@ok@ DB 'ok', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08DDDJOECK@19761101@
CONST	SEGMENT
??_C@_08DDDJOECK@19761101@ DB '19761101', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BACHGGGK@f?$DLencor1c@
CONST	SEGMENT
??_C@_09BACHGGGK@f?$DLencor1c@ DB 'f;encor1c', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DAOAAINN@login@
CONST	SEGMENT
??_C@_05DAOAAINN@login@ DB 'login', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NDJIOBBC@?$OA?$LE?P?o?$DP?S?$NL?w?z?$NM?b?$NM?t?T?R@
CONST	SEGMENT
??_C@_0BA@NDJIOBBC@?$OA?$LE?P?o?$DP?S?$NL?w?z?$NM?b?$NM?t?T?R@ DB 0e0H, 0b4H
	DB	0d0H, 0efH, '?', 0d3H, 0dbH, 0f7H, 0faH, 0dcH, 0e2H, 0dcH, 0f4H
	DB	0d4H, 0d2H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KFDLBKA@?$NO?C?$NM?W?P?o?Y?$KD?$DP?$NM?t?o?a?$DP?$KB?$KD@
CONST	SEGMENT
??_C@_0BB@KFDLBKA@?$NO?C?$NM?W?P?o?Y?$KD?$DP?$NM?t?o?a?$DP?$KB?$KD@ DB 0deH
	DB	0c3H, 0dcH, 0d7H, 0d0H, 0efH, 0d9H, 0a3H, '?', 0dcH, 0f4H, 0efH
	DB	0e1H, '?', 0a1H, 0a3H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LCBBLLOI@www?493sa?4com@
CONST	SEGMENT
??_C@_0N@LCBBLLOI@www?493sa?4com@ DB 'www.93sa.com', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PMNBOGBM@?$NO?C?$NM?W?P?o?$DP?o?H?$DP?$DP?l?$KL?S?p?$KB?$KD@
CONST	SEGMENT
??_C@_0BC@PMNBOGBM@?$NO?C?$NM?W?P?o?$DP?o?H?$DP?$DP?l?$KL?S?p?$KB?$KD@ DB 0deH
	DB	0c3H, 0dcH, 0d7H, 0d0H, 0efH, '?', 0efH, 0c8H, '??', 0ecH, 0abH
	DB	0d3H, 0f0H, 0a1H, 0a3H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02ODPEBLOD@CS@
CONST	SEGMENT
??_C@_02ODPEBLOD@CS@ DB 'CS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@NBOLBDPM@?$LN?$LK?E?f?$LP?$KB?$MA?L?A?v?5?D?$KL?$LP?$MA?$LN?$LK?$LM?$KN?$LJ?v?$LE?B?5?G?v?$MA?g?5?A?$KB@
CONST	SEGMENT
??_C@_0CM@NBOLBDPM@?$LN?$LK?E?f?$LP?$KB?$MA?L?A?v?5?D?$KL?$LP?$MA?$LN?$LK?$LM?$KN?$LJ?v?$LE?B?5?G?v?$MA?g?5?A?$KB@ DB 0bdH
	DB	0baH, 0c5H, 0e6H, 0bfH, 0a1H, 0c0H, 0ccH, 0c1H, 0f6H, ' ', 0c4H
	DB	0abH, 0bfH, 0c0H, 0bdH, 0baH, 0bcH, 0adH, 0b9H, 0f6H, 0b4H, 0c2H
	DB	' ', 0c7H, 0f6H, 0c0H, 0e7H, ' ', 0c1H, 0a1H, 0b0H, 0cbH, ' ', 0c1H
	DB	0dfH, 0c0H, 0d4H, 0b4H, 0cfH, 0b4H, 0d9H, '.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KDOBPHMN@?$DP?V?X?$DP?Z?$LB?q?W?$DP?$PL?$LP?$KB?$KD@
CONST	SEGMENT
??_C@_0O@KDOBPHMN@?$DP?V?X?$DP?Z?$LB?q?W?$DP?$PL?$LP?$KB?$KD@ DB '?', 0d6H
	DB	0d8H, '?', 0daH, 0b1H, 0f1H, 0d7H, '?', 0fbH, 0bfH, 0a1H, 0a3H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CKHMFIAG@?Y?i?$NL?v?$DP?c?$LH?$DP?z?$LM?$NO?C?$NM?W?P?o?n?$NM?$DP?o?H?$KB?$KD@
CONST	SEGMENT
??_C@_0BI@CKHMFIAG@?Y?i?$NL?v?$DP?c?$LH?$DP?z?$LM?$NO?C?$NM?W?P?o?n?$NM?$DP?o?H?$KB?$KD@ DB 0d9H
	DB	0e9H, 0dbH, 0f6H, '?', 0e3H, 0b7H, '?', 0faH, 0bcH, 0deH, 0c3H
	DB	0dcH, 0d7H, 0d0H, 0efH, 0eeH, 0dcH, '?', 0efH, 0c8H, 0a1H, 0a3H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BHPEJLIB@?Y?i?$NL?v?$DP?T?p?$NO?C?$NM?W?P?o?n?$NM?$KD?I?$KD?P?j?H?v?G?$KB?$KD?$CI?$CFs?$CJ@
CONST	SEGMENT
??_C@_0BO@BHPEJLIB@?Y?i?$NL?v?$DP?T?p?$NO?C?$NM?W?P?o?n?$NM?$KD?I?$KD?P?j?H?v?G?$KB?$KD?$CI?$CFs?$CJ@ DB 0d9H
	DB	0e9H, 0dbH, 0f6H, '?', 0d4H, 0f0H, 0deH, 0c3H, 0dcH, 0d7H, 0d0H
	DB	0efH, 0eeH, 0dcH, 0a3H, 0c9H, 0a3H, 0d0H, 0eaH, 0c8H, 0f6H, 0c7H
	DB	0a1H, 0a3H, '(%s)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GMCCICCK@WGS@
CONST	SEGMENT
??_C@_03GMCCICCK@WGS@ DB 'WGS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JAKPHLLB@?Y?i?$NL?v?$DP?z?$LMsocket?n?$NMTCP?$KB?$KD@
CONST	SEGMENT
??_C@_0BF@JAKPHLLB@?Y?i?$NL?v?$DP?z?$LMsocket?n?$NMTCP?$KB?$KD@ DB 0d9H, 0e9H
	DB	0dbH, 0f6H, '?', 0faH, 0bcH, 'socket', 0eeH, 0dcH, 'TCP', 0a1H
	DB	0a3H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@INAHAGEI@?b?$KF?S?p?$KD?$LK?7?$CFs?6@
CONST	SEGMENT
??_C@_0L@INAHAGEI@?b?$KF?S?p?$KD?$LK?7?$CFs?6@ DB 0e2H, 0a5H, 0d3H, 0f0H, 0a3H
	DB	0baH, 09H, '%s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPNLHKJD@a?$CL@
CONST	SEGMENT
??_C@_02DPNLHKJD@a?$CL@ DB 'a+', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OFOPBFLC@recvdata?4txt@
CONST	SEGMENT
??_C@_0N@OFOPBFLC@recvdata?4txt@ DB 'recvdata.txt', 00H	; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?checksum@@YAGPAGH@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
?checksum@@YAGPAGH@Z PROC				; checksum, COMDAT

; 4328 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 4329 : 	unsigned long cksum=0;
; 4330 : 	while( size > 1){

  00004	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00007	33 c0		 xor	 eax, eax
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b 7d 0c	 mov	 edi, DWORD PTR _size$[ebp]
  0000f	33 db		 xor	 ebx, ebx
  00011	33 f6		 xor	 esi, esi
  00013	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00016	83 ff 04	 cmp	 edi, 4
  00019	7c 2c		 jl	 SHORT $LC10@checksum

; 4328 : {

  0001b	8d 57 fc	 lea	 edx, DWORD PTR [edi-4]
  0001e	c1 ea 02	 shr	 edx, 2
  00021	42		 inc	 edx
  00022	8b c2		 mov	 eax, edx
  00024	f7 d8		 neg	 eax
  00026	8d 3c 87	 lea	 edi, DWORD PTR [edi+eax*4]
  00029	0f 1f 80 00 00
	00 00		 npad	 7

; 4329 : 	unsigned long cksum=0;
; 4330 : 	while( size > 1){

$LL11@checksum:

; 4331 : 		cksum += *buffer++;

  00030	0f b7 01	 movzx	 eax, WORD PTR [ecx]
  00033	03 d8		 add	 ebx, eax
  00035	0f b7 41 02	 movzx	 eax, WORD PTR [ecx+2]
  00039	01 45 fc	 add	 DWORD PTR $T1[ebp], eax
  0003c	83 c1 04	 add	 ecx, 4
  0003f	83 ea 01	 sub	 edx, 1
  00042	75 ec		 jne	 SHORT $LL11@checksum

; 4329 : 	unsigned long cksum=0;
; 4330 : 	while( size > 1){

  00044	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
$LC10@checksum:
  00047	83 ff 01	 cmp	 edi, 1
  0004a	7e 09		 jle	 SHORT $LN9@checksum

; 4331 : 		cksum += *buffer++;

  0004c	0f b7 31	 movzx	 esi, WORD PTR [ecx]
  0004f	83 c1 02	 add	 ecx, 2

; 4332 : 		size -=sizeof(USHORT);

  00052	83 ef 02	 sub	 edi, 2
$LN9@checksum:

; 4333 : 	}
; 4334 : 	if ( size)

  00055	03 c3		 add	 eax, ebx
  00057	03 f0		 add	 esi, eax
  00059	85 ff		 test	 edi, edi
  0005b	74 05		 je	 SHORT $LN4@checksum

; 4335 : 		cksum += *(UCHAR*)buffer;

  0005d	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00060	03 f0		 add	 esi, eax
$LN4@checksum:

; 4336 : 	cksum = (cksum >> 16) + (cksum & 0xffff);

  00062	8b ce		 mov	 ecx, esi
  00064	0f b7 c6	 movzx	 eax, si
  00067	c1 e9 10	 shr	 ecx, 16			; 00000010H
  0006a	03 c8		 add	 ecx, eax

; 4337 : 	cksum += (cksum >>16);

  0006c	8b c1		 mov	 eax, ecx
  0006e	c1 e8 10	 shr	 eax, 16			; 00000010H

; 4338 : 	return (USHORT)(~cksum);

  00071	5f		 pop	 edi
  00072	03 c1		 add	 eax, ecx
  00074	5e		 pop	 esi
  00075	f7 d0		 not	 eax
  00077	5b		 pop	 ebx

; 4339 : }

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
?checksum@@YAGPAGH@Z ENDP				; checksum
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_ACI_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_ACI_recv@@YAXHPAD@Z PROC			; lssproto_ACI_recv, COMDAT

; 4193 : 
; 4194 : }

  00000	c2 00 00	 ret	 0
?lssproto_ACI_recv@@YAXHPAD@Z ENDP			; lssproto_ACI_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_IS_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_cdata$ = 12						; size = 4
?lssproto_IS_recv@@YAXHPAD@Z PROC			; lssproto_IS_recv, COMDAT

; 3794 : }

  00000	c2 00 00	 ret	 0
?lssproto_IS_recv@@YAXHPAD@Z ENDP			; lssproto_IS_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_W_recv@@YAXHHHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_id$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
?lssproto_W_recv@@YAXHHHH@Z PROC			; lssproto_W_recv, COMDAT

; 2597 : 	// ??????îœ˜î˜‹???????????
; 2598 : 	// ??????????????????????
; 2599 : }

  00000	c2 00 00	 ret	 0
?lssproto_W_recv@@YAXHHHH@Z ENDP			; lssproto_W_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?PingFunc@@YGKPAX@Z
_TEXT	SEGMENT
_fromlen$ = -2092					; size = 4
_timeout$ = -2088					; size = 4
_from$ = -2084						; size = 16
_dest$ = -2068						; size = 16
_recvbuf$ = -2052					; size = 1024
_icmp_data$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_param$ = 8						; size = 4
?PingFunc@@YGKPAX@Z PROC				; PingFunc, COMDAT

; 4344 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 08 00
	00		 sub	 esp, 2092		; 0000082cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _param$[ebp]
  00016	0f 57 c0	 xorps	 xmm0, xmm0
  00019	53		 push	 ebx

; 4345 : 	struct sockaddr_in from;
; 4346 : 	struct sockaddr_in dest;
; 4347 : 	int datasize;
; 4348 : 	int fromlen = sizeof(from);
; 4349 : 	int timeout = 1000;
; 4350 : 	IcmpHeader *icmp_hdr;
; 4351 : 
; 4352 : 	char icmp_data[MAX_PACKET];
; 4353 : 	char recvbuf[MAX_PACKET];
; 4354 : 	USHORT seq_no = 0;
; 4355 : 
; 4356 : 	ZeroMemory( &dest, sizeof(dest));

  0001a	0f 11 85 ec f7
	ff ff		 movups	 XMMWORD PTR _dest$[ebp], xmm0
  00021	56		 push	 esi

; 4357 : 	memcpy( &(dest.sin_addr), (void*)param, 4);

  00022	8b 00		 mov	 eax, DWORD PTR [eax]
  00024	89 85 f0 f7 ff
	ff		 mov	 DWORD PTR _dest$[ebp+4], eax

; 4358 : 	dest.sin_family = AF_INET;

  0002a	b8 02 00 00 00	 mov	 eax, 2
  0002f	57		 push	 edi
  00030	66 89 85 ec f7
	ff ff		 mov	 WORD PTR _dest$[ebp], ax
  00037	33 ff		 xor	 edi, edi

; 4359 : 	if ( sockRaw != INVALID_SOCKET){

  00039	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockRaw@@3IA ; sockRaw
  0003e	c7 85 d4 f7 ff
	ff 10 00 00 00	 mov	 DWORD PTR _fromlen$[ebp], 16 ; 00000010H
  00048	c7 85 d8 f7 ff
	ff e8 03 00 00	 mov	 DWORD PTR _timeout$[ebp], 1000 ; 000003e8H
  00052	83 f8 ff	 cmp	 eax, -1
  00055	74 10		 je	 SHORT $LN6@PingFunc

; 4360 : 		closesocket( sockRaw);

  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _closesocket@4

; 4361 : 		sockRaw = INVALID_SOCKET;

  0005d	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?sockRaw@@3IA, -1 ; sockRaw
$LN6@PingFunc:

; 4362 : 	}
; 4363 : 	sockRaw = socket( AF_INET, SOCK_RAW, IPPROTO_ICMP);

  00067	6a 01		 push	 1
  00069	6a 03		 push	 3
  0006b	6a 02		 push	 2
  0006d	e8 00 00 00 00	 call	 _socket@12
  00072	a3 00 00 00 00	 mov	 DWORD PTR ?sockRaw@@3IA, eax ; sockRaw

; 4364 : 	if ( sockRaw != INVALID_SOCKET){

  00077	83 f8 ff	 cmp	 eax, -1
  0007a	0f 84 18 02 00
	00		 je	 $LN38@PingFunc

; 4365 : 		iRead = setsockopt( sockRaw, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout, sizeof(timeout));

  00080	6a 04		 push	 4
  00082	8d 8d d8 f7 ff
	ff		 lea	 ecx, DWORD PTR _timeout$[ebp]
  00088	51		 push	 ecx
  00089	68 06 10 00 00	 push	 4102			; 00001006H
  0008e	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 _setsockopt@20
  00099	a3 00 00 00 00	 mov	 DWORD PTR ?iRead@@3HA, eax ; iRead

; 4366 : 		if ( iRead != SOCKET_ERROR){

  0009e	83 f8 ff	 cmp	 eax, -1
  000a1	0f 84 f1 01 00
	00		 je	 $LN38@PingFunc

; 4367 : 			timeout = 1000;
; 4368 : 			iRead = setsockopt( sockRaw, SOL_SOCKET, SO_SNDTIMEO, (char*)&timeout, sizeof(timeout));

  000a7	6a 04		 push	 4
  000a9	8d 85 d8 f7 ff
	ff		 lea	 eax, DWORD PTR _timeout$[ebp]
  000af	c7 85 d8 f7 ff
	ff e8 03 00 00	 mov	 DWORD PTR _timeout$[ebp], 1000 ; 000003e8H
  000b9	50		 push	 eax
  000ba	68 05 10 00 00	 push	 4101			; 00001005H
  000bf	68 ff ff 00 00	 push	 65535			; 0000ffffH
  000c4	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockRaw@@3IA	; sockRaw
  000ca	e8 00 00 00 00	 call	 _setsockopt@20
  000cf	a3 00 00 00 00	 mov	 DWORD PTR ?iRead@@3HA, eax ; iRead

; 4369 : 			if ( iRead != SOCKET_ERROR){

  000d4	83 f8 ff	 cmp	 eax, -1
  000d7	0f 84 bb 01 00
	00		 je	 $LN38@PingFunc

; 4370 : 				datasize = DEF_PACKET_SIZE + sizeof(IcmpHeader);  
; 4371 : 
; 4372 : 				icmp_hdr = (IcmpHeader*)icmp_data;
; 4373 : 				icmp_hdr->i_type = ICMP_ECHO;
; 4374 : 				icmp_hdr->i_code = 0;
; 4375 : 				icmp_hdr->i_id = (USHORT)GetCurrentProcessId();

  000dd	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetCurrentProcessId@0
  000e3	66 c7 85 fc fb
	ff ff 08 00	 mov	 WORD PTR _icmp_data$[ebp], 8
  000ec	ff d3		 call	 ebx

; 4376 : 				icmp_hdr->i_cksum = 0;
; 4377 : 				icmp_hdr->i_seq = 0;
; 4378 : 				memset( icmp_data+sizeof(IcmpHeader), 'E', datasize - sizeof(IcmpHeader));

  000ee	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@45454545454545454545454545454545
  000f5	66 89 85 00 fc
	ff ff		 mov	 WORD PTR _icmp_data$[ebp+4], ax
  000fc	0f 11 85 08 fc
	ff ff		 movups	 XMMWORD PTR _icmp_data$[ebp+12], xmm0
  00103	0f 11 85 18 fc
	ff ff		 movups	 XMMWORD PTR _icmp_data$[ebp+28], xmm0
$LN40@PingFunc:

; 4379 : 				while( 1){
; 4380 : 			//		dwPingState = 0;
; 4381 : 					((IcmpHeader*)icmp_data)->i_cksum = 0;

  0010a	be 00 00 00 04	 mov	 esi, 67108864		; 04000000H
  0010f	90		 npad	 1
$LL2@PingFunc:
  00110	33 c0		 xor	 eax, eax
  00112	66 89 85 fe fb
	ff ff		 mov	 WORD PTR _icmp_data$[ebp+2], ax

; 4382 : 					((IcmpHeader*)icmp_data)->timestamp = GetTickCount();

  00119	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0011f	89 85 04 fc ff
	ff		 mov	 DWORD PTR _icmp_data$[ebp+8], eax

; 4383 : 					
; 4384 : 					((IcmpHeader*)icmp_data)->i_seq = seq_no;
; 4385 : 					((IcmpHeader*)icmp_data)->i_cksum = checksum( (USHORT*)icmp_data, datasize);

  00125	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _icmp_data$[ebp]
  0012b	6a 2c		 push	 44			; 0000002cH
  0012d	50		 push	 eax
  0012e	66 89 bd 02 fc
	ff ff		 mov	 WORD PTR _icmp_data$[ebp+6], di
  00135	e8 00 00 00 00	 call	 ?checksum@@YAGPAGH@Z	; checksum
  0013a	83 c4 08	 add	 esp, 8
  0013d	66 89 85 fe fb
	ff ff		 mov	 WORD PTR _icmp_data$[ebp+2], ax

; 4386 : 					
; 4387 : 					iWrote = sendto( sockRaw, icmp_data, datasize, 0, (struct sockaddr*)&dest, sizeof(struct sockaddr));

  00144	8d 85 ec f7 ff
	ff		 lea	 eax, DWORD PTR _dest$[ebp]
  0014a	6a 10		 push	 16			; 00000010H
  0014c	50		 push	 eax
  0014d	6a 00		 push	 0
  0014f	6a 2c		 push	 44			; 0000002cH
  00151	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _icmp_data$[ebp]
  00157	50		 push	 eax
  00158	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockRaw@@3IA	; sockRaw
  0015e	e8 00 00 00 00	 call	 _sendto@24
  00163	8b c8		 mov	 ecx, eax
  00165	89 0d 00 00 00
	00		 mov	 DWORD PTR ?iWrote@@3HA, ecx ; iWrote

; 4388 : 					if ( iWrote == SOCKET_ERROR){

  0016b	83 f9 ff	 cmp	 ecx, -1
  0016e	75 2c		 jne	 SHORT $LN10@PingFunc

; 4389 : 						if ( WSAGetLastError() == WSAETIMEDOUT){

  00170	e8 00 00 00 00	 call	 _WSAGetLastError@0
  00175	3d 4c 27 00 00	 cmp	 eax, 10060		; 0000274cH
  0017a	75 0c		 jne	 SHORT $LN11@PingFunc

; 4390 : 							dwPingTime = -1;

  0017c	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?dwPingTime@@3KA, -1 ; dwPingTime

; 4391 : 							continue;

  00186	eb 88		 jmp	 SHORT $LL2@PingFunc
$LN11@PingFunc:

; 4392 : 						}
; 4393 : 						dwPingState = 0x40000000 | WSAGetLastError();

  00188	e8 00 00 00 00	 call	 _WSAGetLastError@0
  0018d	0d 00 00 00 40	 or	 eax, 1073741824		; 40000000H
  00192	a3 00 00 00 00	 mov	 DWORD PTR ?dwPingState@@3KA, eax ; dwPingState

; 4394 : 						continue;

  00197	e9 74 ff ff ff	 jmp	 $LL2@PingFunc
$LN10@PingFunc:

; 4395 : 					}
; 4396 : 					if ( iWrote < datasize)

  0019c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dwPingState@@3KA ; dwPingState
  001a1	83 f9 2c	 cmp	 ecx, 44			; 0000002cH
  001a4	0f 4c c6	 cmovl	 eax, esi
$LN39@PingFunc:

; 4397 : 						dwPingState = 0x04000000;//len error
; 4398 : 					while( 1){
; 4399 : 						iRead = recvfrom( sockRaw, recvbuf, MAX_PACKET, 0, (struct sockaddr*)&from, &fromlen);

  001a7	a3 00 00 00 00	 mov	 DWORD PTR ?dwPingState@@3KA, eax ; dwPingState
  001ac	0f 1f 40 00	 npad	 4
$LL4@PingFunc:
  001b0	8d 85 d4 f7 ff
	ff		 lea	 eax, DWORD PTR _fromlen$[ebp]
  001b6	50		 push	 eax
  001b7	8d 85 dc f7 ff
	ff		 lea	 eax, DWORD PTR _from$[ebp]
  001bd	50		 push	 eax
  001be	6a 00		 push	 0
  001c0	68 00 04 00 00	 push	 1024			; 00000400H
  001c5	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _recvbuf$[ebp]
  001cb	50		 push	 eax
  001cc	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockRaw@@3IA	; sockRaw
  001d2	e8 00 00 00 00	 call	 _recvfrom@24
  001d7	8b d0		 mov	 edx, eax
  001d9	89 15 00 00 00
	00		 mov	 DWORD PTR ?iRead@@3HA, edx ; iRead

; 4400 : 						if ( iRead == SOCKET_ERROR){

  001df	83 fa ff	 cmp	 edx, -1
  001e2	75 18		 jne	 SHORT $LN13@PingFunc

; 4401 : 							if ( WSAGetLastError() == WSAETIMEDOUT){

  001e4	e8 00 00 00 00	 call	 _WSAGetLastError@0
  001e9	3d 4c 27 00 00	 cmp	 eax, 10060		; 0000274cH
  001ee	74 76		 je	 SHORT $LN28@PingFunc

; 4404 : 							}
; 4405 : 							dwPingState = 0x40000000 | WSAGetLastError();

  001f0	e8 00 00 00 00	 call	 _WSAGetLastError@0
  001f5	0d 00 00 00 40	 or	 eax, 1073741824		; 40000000H

; 4406 : 							continue;

  001fa	eb ab		 jmp	 SHORT $LN39@PingFunc
$LN13@PingFunc:

; 4407 : 						}
; 4408 : 						IpHeader *iphdr;
; 4409 : 						unsigned short iphdrlen;
; 4410 : 						iphdr = (IpHeader *)recvbuf;
; 4411 : 						iphdrlen = iphdr->h_len * 4 ; // number of 32-bit words *4 = bytes

  001fc	8b 85 fc f7 ff
	ff		 mov	 eax, DWORD PTR _recvbuf$[ebp]

; 4412 : 						if ( iRead < iphdrlen + ICMP_MIN)

  00202	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?dwPingState@@3KA ; dwPingState
  00208	83 e0 0f	 and	 eax, 15			; 0000000fH
  0020b	c1 e0 02	 shl	 eax, 2
  0020e	0f b7 f0	 movzx	 esi, ax
  00211	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00214	3b d0		 cmp	 edx, eax
  00216	b8 00 00 00 08	 mov	 eax, 134217728		; 08000000H
  0021b	0f 4c c8	 cmovl	 ecx, eax

; 4413 : 							dwPingState = 0x08000000;//len error
; 4414 : 						icmp_hdr = (IcmpHeader*)(recvbuf + iphdrlen);
; 4415 : 						if ( icmp_hdr->i_type != ICMP_ECHOREPLY){

  0021e	80 bc 35 fc f7
	ff ff 00	 cmp	 BYTE PTR _recvbuf$[ebp+esi], 0
  00226	89 0d 00 00 00
	00		 mov	 DWORD PTR ?dwPingState@@3KA, ecx ; dwPingState
  0022c	74 0f		 je	 SHORT $LN16@PingFunc

; 4416 : 							dwPingState = 0x10000000;//non-echo type recvd

  0022e	c7 05 00 00 00
	00 00 00 00 10	 mov	 DWORD PTR ?dwPingState@@3KA, 268435456 ; dwPingState, 10000000H

; 4417 : 							continue;

  00238	e9 73 ff ff ff	 jmp	 $LL4@PingFunc
$LN16@PingFunc:

; 4418 : 						}
; 4419 : 						if ( icmp_hdr->i_seq != seq_no)

  0023d	66 39 bc 35 02
	f8 ff ff	 cmp	 WORD PTR _recvbuf$[ebp+esi+6], di
  00245	0f 85 65 ff ff
	ff		 jne	 $LL4@PingFunc

; 4420 : 							continue;
; 4421 : 						if ( icmp_hdr->i_id != (USHORT)GetCurrentProcessId()){

  0024b	ff d3		 call	 ebx
  0024d	66 39 84 35 00
	f8 ff ff	 cmp	 WORD PTR _recvbuf$[ebp+esi+4], ax
  00255	74 14		 je	 SHORT $LN18@PingFunc

; 4422 : 							dwPingState = 0x20000000;//someone else's packet!

  00257	c7 05 00 00 00
	00 00 00 00 20	 mov	 DWORD PTR ?dwPingState@@3KA, 536870912 ; dwPingState, 20000000H

; 4423 : 							continue;

  00261	e9 4a ff ff ff	 jmp	 $LL4@PingFunc
$LN28@PingFunc:

; 4402 : 								dwPingTime = -1;

  00266	83 c8 ff	 or	 eax, -1

; 4403 : 								break;

  00269	eb 0d		 jmp	 SHORT $LN5@PingFunc
$LN18@PingFunc:

; 4424 : 						}
; 4425 : 						dwPingTime = GetTickCount()-icmp_hdr->timestamp;

  0026b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00271	2b 84 35 04 f8
	ff ff		 sub	 eax, DWORD PTR _recvbuf$[ebp+esi+8]
$LN5@PingFunc:

; 4426 : 						break;
; 4427 : 					}
; 4428 : 					seq_no++;
; 4429 : 					dwPingState = 0x80000000;
; 4430 : 					Sleep( 3000);

  00278	68 b8 0b 00 00	 push	 3000			; 00000bb8H
  0027d	a3 00 00 00 00	 mov	 DWORD PTR ?dwPingTime@@3KA, eax ; dwPingTime
  00282	47		 inc	 edi
  00283	c7 05 00 00 00
	00 00 00 00 80	 mov	 DWORD PTR ?dwPingState@@3KA, -2147483648 ; dwPingState, 80000000H
  0028d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 4431 : 				}

  00293	e9 72 fe ff ff	 jmp	 $LN40@PingFunc
$LN38@PingFunc:

; 4432 : 			}
; 4433 : 		}
; 4434 : 	}
; 4435 : 	return 0;
; 4436 : }

  00298	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0029b	33 c0		 xor	 eax, eax
  0029d	5f		 pop	 edi
  0029e	5e		 pop	 esi
  0029f	33 cd		 xor	 ecx, ebp
  002a1	5b		 pop	 ebx
  002a2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a7	8b e5		 mov	 esp, ebp
  002a9	5d		 pop	 ebp
  002aa	c2 04 00	 ret	 4
?PingFunc@@YGKPAX@Z ENDP				; PingFunc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?LogToRecvdata2@@YAXPAD@Z
_TEXT	SEGMENT
_lssproto_readlogfilename$ = -260			; size = 256
__$ArrayPad$ = -4					; size = 4
_data$ = 8						; size = 4
?LogToRecvdata2@@YAXPAD@Z PROC				; LogToRecvdata2, COMDAT

; 156  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 157  : 	//printf("æ”¶åˆ°ï¼š\t%s\n", data);
; 158  : 	char lssproto_readlogfilename[256] = "recvdata.txt";

  00013	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0N@OFOPBFLC@recvdata?4txt@+8
  00018	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0N@OFOPBFLC@recvdata?4txt@
  00020	57		 push	 edi
  00021	8b 7d 08	 mov	 edi, DWORD PTR _data$[ebp]
  00024	89 85 04 ff ff
	ff		 mov	 DWORD PTR _lssproto_readlogfilename$[ebp+8], eax
  0002a	a0 0c 00 00 00	 mov	 al, BYTE PTR ??_C@_0N@OFOPBFLC@recvdata?4txt@+12
  0002f	68 f3 00 00 00	 push	 243			; 000000f3H
  00034	88 85 08 ff ff
	ff		 mov	 BYTE PTR _lssproto_readlogfilename$[ebp+12], al
  0003a	8d 85 09 ff ff
	ff		 lea	 eax, DWORD PTR _lssproto_readlogfilename$[ebp+13]
  00040	6a 00		 push	 0
  00042	50		 push	 eax
  00043	66 0f d6 85 fc
	fe ff ff	 movq	 QWORD PTR _lssproto_readlogfilename$[ebp], xmm0
  0004b	e8 00 00 00 00	 call	 _memset
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH

; 159  : 
; 160  : 	if (lssproto_readlogfilename[0] != '\0')

  00053	80 bd fc fe ff
	ff 00		 cmp	 BYTE PTR _lssproto_readlogfilename$[ebp], 0
  0005a	74 31		 je	 SHORT $LN3@LogToRecvd

; 161  : 	{
; 162  : 		FILE *rfp;
; 163  : 		rfp = fopen(lssproto_readlogfilename, "a+");

  0005c	56		 push	 esi
  0005d	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _lssproto_readlogfilename$[ebp]
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_02DPNLHKJD@a?$CL@
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 _fopen
  0006e	8b f0		 mov	 esi, eax
  00070	83 c4 08	 add	 esp, 8

; 164  : 		if (rfp)

  00073	85 f6		 test	 esi, esi
  00075	74 15		 je	 SHORT $LN5@LogToRecvd

; 165  : 		{
; 166  : 			fprintf(rfp, "æ”¶åˆ°ï¼š\t%s\n", data);

  00077	57		 push	 edi
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_0L@INAHAGEI@?b?$KF?S?p?$KD?$LK?7?$CFs?6@
  0007d	56		 push	 esi
  0007e	e8 00 00 00 00	 call	 _fprintf

; 167  : 			fclose(rfp);

  00083	56		 push	 esi
  00084	e8 00 00 00 00	 call	 _fclose
  00089	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@LogToRecvd:
  0008c	5e		 pop	 esi
$LN3@LogToRecvd:

; 168  : 		}
; 169  : 	}
; 170  : }

  0008d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00090	33 cd		 xor	 ecx, ebp
  00092	5f		 pop	 edi
  00093	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
?LogToRecvdata2@@YAXPAD@Z ENDP				; LogToRecvdata2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\time.h
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?SaveChatData@@YAXPADD_N@Z
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_KindOfChannel$ = 12					; size = 1
_bCloseFile$ = 16					; size = 1
?SaveChatData@@YAXPADD_N@Z PROC				; SaveChatData, COMDAT

; 4476 : void SaveChatData(char *msg,char KindOfChannel,bool bCloseFile){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4477 : 	static FILE *pFile[5];
; 4478 : 	static char szFileName[256];
; 4479 : 	static struct tm *nowTime;
; 4480 : 	static time_t longTime;
; 4481 : 	static unsigned short Channel[] = {
; 4482 : 		PC_ETCFLAG_CHAT_MODE, //é˜Ÿä¼é¢‘é“å¼€å…³
; 4483 : 		PC_ETCFLAG_CHAT_TELL,	//å¯†è¯­é¢‘é“å¼€å…³
; 4484 : 		PC_ETCFLAG_CHAT_FM,		//å®¶æ—é¢‘é“å¼€å…³
; 4485 : 		PC_ETCFLAG_CHAT_OCC,	//èŒä¸šé¢‘é“å¼€å…³
; 4486 : 		PC_ETCFLAG_CHAT_CHAT	//èŠå¤©å®¤å¼€å…³
; 4487 : 	};
; 4488 : 	char ChannelType[] = {'T','M','F','O','R'};
; 4489 : 
; 4490 : 	//JL é‡å†™ä¿å­˜chatèŠå¤©è®°å½•
; 4491 : 	if ((pc.etcFlag & PC_ETCFLAG_CHAT_SAVE) && !bCloseFile) 

  00003	f7 05 a8 00 00
	00 00 02 00 00	 test	 DWORD PTR ?pc@@3UPC@@A+168, 512 ; 00000200H
  0000d	0f 84 e8 00 00
	00		 je	 $LN2@SaveChatDa
  00013	80 7d 10 00	 cmp	 BYTE PTR _bCloseFile$[ebp], 0
  00017	0f 85 de 00 00
	00		 jne	 $LN2@SaveChatDa
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\time.h

; 522  :             return _time64(_Time);

  0001d	56		 push	 esi
  0001e	68 00 00 00 00	 push	 OFFSET ?longTime@?1??SaveChatData@@YAXPADD_N@Z@4_JA
  00023	e8 00 00 00 00	 call	 __time64

; 499  :             return _localtime64(_Time);

  00028	68 00 00 00 00	 push	 OFFSET ?longTime@?1??SaveChatData@@YAXPADD_N@Z@4_JA
  0002d	e8 00 00 00 00	 call	 __localtime64
  00032	83 c4 08	 add	 esp, 8
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp

; 4494 : 		nowTime = localtime(&longTime);

  00035	a3 00 00 00 00	 mov	 DWORD PTR ?nowTime@?1??SaveChatData@@YAXPADD_N@Z@4PAUtm@@A, eax

; 4495 : 
; 4496 : 		if (pFile[0] == NULL) 

  0003a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?pFile@?1??SaveChatData@@YAXPADD_N@Z@4PAPAU_iobuf@@A, 0
  00041	75 79		 jne	 SHORT $LN4@SaveChatDa

; 4497 : 		{
; 4498 : 			sprintf(szFileName, "chat\\%02d%02d%02d.TXT", (nowTime->tm_year % 100), nowTime->tm_mon + 1, nowTime->tm_mday);

  00043	ff 70 0c	 push	 DWORD PTR [eax+12]
  00046	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00049	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0004c	41		 inc	 ecx
  0004d	51		 push	 ecx
  0004e	99		 cdq
  0004f	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00054	f7 f9		 idiv	 ecx
  00056	52		 push	 edx
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@JGFFJBEF@chat?2?$CF02d?$CF02d?$CF02d?4TXT@
  0005c	68 00 00 00 00	 push	 OFFSET ?szFileName@?1??SaveChatData@@YAXPADD_N@Z@4PADA
  00061	e8 00 00 00 00	 call	 _sprintf

; 4499 : 			pFile[0] = fopen(szFileName, "a");

  00066	68 00 00 00 00	 push	 OFFSET ??_C@_01MCMALHOG@a@
  0006b	68 00 00 00 00	 push	 OFFSET ?szFileName@?1??SaveChatData@@YAXPADD_N@Z@4PADA
  00070	e8 00 00 00 00	 call	 _fopen

; 4500 : 			int len = lstrlen(msg);

  00075	8b 75 08	 mov	 esi, DWORD PTR _msg$[ebp]
  00078	83 c4 1c	 add	 esp, 28			; 0000001cH
  0007b	a3 00 00 00 00	 mov	 DWORD PTR ?pFile@?1??SaveChatData@@YAXPADD_N@Z@4PAPAU_iobuf@@A, eax
  00080	56		 push	 esi
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4

; 4501 : 			fwrite(msg, 1, len, pFile[0]);

  00087	ff 35 00 00 00
	00		 push	 DWORD PTR ?pFile@?1??SaveChatData@@YAXPADD_N@Z@4PAPAU_iobuf@@A
  0008d	50		 push	 eax
  0008e	6a 01		 push	 1
  00090	56		 push	 esi
  00091	e8 00 00 00 00	 call	 _fwrite

; 4502 : 			fwrite("\n", 1, 1, pFile[0]);

  00096	ff 35 00 00 00
	00		 push	 DWORD PTR ?pFile@?1??SaveChatData@@YAXPADD_N@Z@4PAPAU_iobuf@@A
  0009c	6a 01		 push	 1
  0009e	6a 01		 push	 1
  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  000a5	e8 00 00 00 00	 call	 _fwrite

; 4503 : 			fflush(pFile[0]);

  000aa	ff 35 00 00 00
	00		 push	 DWORD PTR ?pFile@?1??SaveChatData@@YAXPADD_N@Z@4PAPAU_iobuf@@A
  000b0	e8 00 00 00 00	 call	 _fflush
  000b5	83 c4 24	 add	 esp, 36			; 00000024H

; 4504 : 			__asm nop;

  000b8	90		 npad	 1
  000b9	5e		 pop	 esi
$LN7@SaveChatDa:

; 4523 : 		}
; 4524 : 	}
; 4525 : 
; 4526 : 	// å‚¨å­˜å¯¹è¯å†…å®¹é€‰é¡¹å¼€å¯
; 4527 : 	//if ((pc.etcFlag & PC_ETCFLAG_CHAT_SAVE) && !bCloseFile){
; 4528 : 	//	time(&longTime);
; 4529 : 	//	nowTime = localtime(&longTime);
; 4530 : 	//	for (int i=0;i<5;i++){
; 4531 : 	//		if (pc.etcFlag & Channel[i]){
; 4532 : 	//			if (pFile[i] == NULL){
; 4533 : 	//				sprintf(szFileName,"chat\\%c%02d%02d%02d.TXT",ChannelType[i],(nowTime->tm_year % 100),nowTime->tm_mon+1,nowTime->tm_mday);
; 4534 : 	//				if ((pFile[i] = fopen(szFileName,"a")) == NULL) continue;
; 4535 : 	//				int n =fwrite(msg, lstrlen(msg), lstrlen(msg), pFile[i]);
; 4536 : 	//				__asm nop;
; 4537 : 	//			}
; 4538 : 	//		}
; 4539 : 	//		else{
; 4540 : 	//			if (pFile[i] != NULL) fclose(pFile[i]);
; 4541 : 	//		}
; 4542 : 	//	}
; 4543 : 	//	for (int i=0;i<5;i++){
; 4544 : 	//		if (KindOfChannel == ChannelType[i]){
; 4545 : 	//			if (pFile[i] != NULL) fprintf(pFile[i],"[%02d:%02d:%02d]%s\n",nowTime->tm_hour,nowTime->tm_min,nowTime->tm_sec,msg);
; 4546 : 	//		}
; 4547 : 	//	}
; 4548 : 	//}
; 4549 : 	//else bCloseFile = 1;
; 4550 : 
; 4551 : 	//if (bCloseFile){
; 4552 : 	//	for (int i=0;i<5;i++)
; 4553 : 	//		if (pFile[i] != NULL) fclose(pFile[i]);
; 4554 : 	//}
; 4555 : }

  000ba	5d		 pop	 ebp
  000bb	c3		 ret	 0
$LN4@SaveChatDa:

; 4505 : 		}
; 4506 : 		else 
; 4507 : 		{
; 4508 : 			int len = lstrlen(msg);

  000bc	8b 75 08	 mov	 esi, DWORD PTR _msg$[ebp]
  000bf	56		 push	 esi
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4

; 4509 : 			fwrite(msg, 1, len, pFile[0]);

  000c6	ff 35 00 00 00
	00		 push	 DWORD PTR ?pFile@?1??SaveChatData@@YAXPADD_N@Z@4PAPAU_iobuf@@A
  000cc	50		 push	 eax
  000cd	6a 01		 push	 1
  000cf	56		 push	 esi
  000d0	e8 00 00 00 00	 call	 _fwrite

; 4510 : 			fwrite("\n", 1, 1, pFile[0]);

  000d5	ff 35 00 00 00
	00		 push	 DWORD PTR ?pFile@?1??SaveChatData@@YAXPADD_N@Z@4PAPAU_iobuf@@A
  000db	6a 01		 push	 1
  000dd	6a 01		 push	 1
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  000e4	e8 00 00 00 00	 call	 _fwrite

; 4511 : 			fflush(pFile[0]);

  000e9	ff 35 00 00 00
	00		 push	 DWORD PTR ?pFile@?1??SaveChatData@@YAXPADD_N@Z@4PAPAU_iobuf@@A
  000ef	e8 00 00 00 00	 call	 _fflush
  000f4	83 c4 24	 add	 esp, 36			; 00000024H

; 4512 : 			__asm nop;

  000f7	90		 npad	 1
  000f8	5e		 pop	 esi

; 4523 : 		}
; 4524 : 	}
; 4525 : 
; 4526 : 	// å‚¨å­˜å¯¹è¯å†…å®¹é€‰é¡¹å¼€å¯
; 4527 : 	//if ((pc.etcFlag & PC_ETCFLAG_CHAT_SAVE) && !bCloseFile){
; 4528 : 	//	time(&longTime);
; 4529 : 	//	nowTime = localtime(&longTime);
; 4530 : 	//	for (int i=0;i<5;i++){
; 4531 : 	//		if (pc.etcFlag & Channel[i]){
; 4532 : 	//			if (pFile[i] == NULL){
; 4533 : 	//				sprintf(szFileName,"chat\\%c%02d%02d%02d.TXT",ChannelType[i],(nowTime->tm_year % 100),nowTime->tm_mon+1,nowTime->tm_mday);
; 4534 : 	//				if ((pFile[i] = fopen(szFileName,"a")) == NULL) continue;
; 4535 : 	//				int n =fwrite(msg, lstrlen(msg), lstrlen(msg), pFile[i]);
; 4536 : 	//				__asm nop;
; 4537 : 	//			}
; 4538 : 	//		}
; 4539 : 	//		else{
; 4540 : 	//			if (pFile[i] != NULL) fclose(pFile[i]);
; 4541 : 	//		}
; 4542 : 	//	}
; 4543 : 	//	for (int i=0;i<5;i++){
; 4544 : 	//		if (KindOfChannel == ChannelType[i]){
; 4545 : 	//			if (pFile[i] != NULL) fprintf(pFile[i],"[%02d:%02d:%02d]%s\n",nowTime->tm_hour,nowTime->tm_min,nowTime->tm_sec,msg);
; 4546 : 	//		}
; 4547 : 	//	}
; 4548 : 	//}
; 4549 : 	//else bCloseFile = 1;
; 4550 : 
; 4551 : 	//if (bCloseFile){
; 4552 : 	//	for (int i=0;i<5;i++)
; 4553 : 	//		if (pFile[i] != NULL) fclose(pFile[i]);
; 4554 : 	//}
; 4555 : }

  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
$LN2@SaveChatDa:

; 4513 : 		}
; 4514 : 
; 4515 : 	}
; 4516 : 	else bCloseFile = 1;
; 4517 : 
; 4518 : 	if (bCloseFile) {
; 4519 : 		if (pFile[0] != NULL)

  000fb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pFile@?1??SaveChatData@@YAXPADD_N@Z@4PAPAU_iobuf@@A
  00100	85 c0		 test	 eax, eax
  00102	74 b6		 je	 SHORT $LN7@SaveChatDa

; 4520 : 		{
; 4521 : 			fclose(pFile[0]);

  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 _fclose
  0010a	83 c4 04	 add	 esp, 4

; 4522 : 			pFile[0] = 0;

  0010d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pFile@?1??SaveChatData@@YAXPADD_N@Z@4PAPAU_iobuf@@A, 0

; 4523 : 		}
; 4524 : 	}
; 4525 : 
; 4526 : 	// å‚¨å­˜å¯¹è¯å†…å®¹é€‰é¡¹å¼€å¯
; 4527 : 	//if ((pc.etcFlag & PC_ETCFLAG_CHAT_SAVE) && !bCloseFile){
; 4528 : 	//	time(&longTime);
; 4529 : 	//	nowTime = localtime(&longTime);
; 4530 : 	//	for (int i=0;i<5;i++){
; 4531 : 	//		if (pc.etcFlag & Channel[i]){
; 4532 : 	//			if (pFile[i] == NULL){
; 4533 : 	//				sprintf(szFileName,"chat\\%c%02d%02d%02d.TXT",ChannelType[i],(nowTime->tm_year % 100),nowTime->tm_mon+1,nowTime->tm_mday);
; 4534 : 	//				if ((pFile[i] = fopen(szFileName,"a")) == NULL) continue;
; 4535 : 	//				int n =fwrite(msg, lstrlen(msg), lstrlen(msg), pFile[i]);
; 4536 : 	//				__asm nop;
; 4537 : 	//			}
; 4538 : 	//		}
; 4539 : 	//		else{
; 4540 : 	//			if (pFile[i] != NULL) fclose(pFile[i]);
; 4541 : 	//		}
; 4542 : 	//	}
; 4543 : 	//	for (int i=0;i<5;i++){
; 4544 : 	//		if (KindOfChannel == ChannelType[i]){
; 4545 : 	//			if (pFile[i] != NULL) fprintf(pFile[i],"[%02d:%02d:%02d]%s\n",nowTime->tm_hour,nowTime->tm_min,nowTime->tm_sec,msg);
; 4546 : 	//		}
; 4547 : 	//	}
; 4548 : 	//}
; 4549 : 	//else bCloseFile = 1;
; 4550 : 
; 4551 : 	//if (bCloseFile){
; 4552 : 	//	for (int i=0;i<5;i++)
; 4553 : 	//		if (pFile[i] != NULL) fclose(pFile[i]);
; 4554 : 	//}
; 4555 : }

  00117	5d		 pop	 ebp
  00118	c3		 ret	 0
?SaveChatData@@YAXPADD_N@Z ENDP				; SaveChatData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?SortSkill@@YAXXZ
_TEXT	SEGMENT
?SortSkill@@YAXXZ PROC					; SortSkill, COMDAT

; 117  : 	int count1 = 0, count2 = 0, count3 = 0;
; 118  : 
; 119  : 	for (int i = 0; i < 20; i++)
; 120  : 	{
; 121  : 		AdvanceSkill[i] = -1;

  00000	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff

; 122  : 		AssitSkill[i] = -1;		
; 123  : 		BattleSkill[i] = -1;
; 124  : 	}
; 125  : 	for (int i = 0; i < 26; i++)

  00007	33 c9		 xor	 ecx, ecx
  00009	53		 push	 ebx
  0000a	0f 11 05 00 00
	00 00		 movups	 XMMWORD PTR ?AdvanceSkill@@3PAHA, xmm0
  00011	56		 push	 esi
  00012	0f 11 05 10 00
	00 00		 movups	 XMMWORD PTR ?AdvanceSkill@@3PAHA+16, xmm0
  00019	57		 push	 edi
  0001a	0f 11 05 20 00
	00 00		 movups	 XMMWORD PTR ?AdvanceSkill@@3PAHA+32, xmm0
  00021	be 00 00 00 00	 mov	 esi, OFFSET ?BattleSkill@@3PAHA ; BattleSkill
  00026	bf 00 00 00 00	 mov	 edi, OFFSET ?AssitSkill@@3PAHA ; AssitSkill
  0002b	0f 11 05 30 00
	00 00		 movups	 XMMWORD PTR ?AdvanceSkill@@3PAHA+48, xmm0
  00032	bb 00 00 00 00	 mov	 ebx, OFFSET ?AdvanceSkill@@3PAHA ; AdvanceSkill
  00037	ba 06 00 00 00	 mov	 edx, OFFSET ?profession_skill@@3PAUPROFESSION_SKILL@@A+6
  0003c	0f 11 05 40 00
	00 00		 movups	 XMMWORD PTR ?AdvanceSkill@@3PAHA+64, xmm0
  00043	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
  0004a	0f 11 05 00 00
	00 00		 movups	 XMMWORD PTR ?AssitSkill@@3PAHA, xmm0
  00051	0f 11 05 10 00
	00 00		 movups	 XMMWORD PTR ?AssitSkill@@3PAHA+16, xmm0
  00058	0f 11 05 20 00
	00 00		 movups	 XMMWORD PTR ?AssitSkill@@3PAHA+32, xmm0
  0005f	0f 11 05 30 00
	00 00		 movups	 XMMWORD PTR ?AssitSkill@@3PAHA+48, xmm0
  00066	0f 11 05 40 00
	00 00		 movups	 XMMWORD PTR ?AssitSkill@@3PAHA+64, xmm0
  0006d	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
  00074	0f 11 05 00 00
	00 00		 movups	 XMMWORD PTR ?BattleSkill@@3PAHA, xmm0
  0007b	0f 11 05 10 00
	00 00		 movups	 XMMWORD PTR ?BattleSkill@@3PAHA+16, xmm0
  00082	0f 11 05 20 00
	00 00		 movups	 XMMWORD PTR ?BattleSkill@@3PAHA+32, xmm0
  00089	0f 11 05 30 00
	00 00		 movups	 XMMWORD PTR ?BattleSkill@@3PAHA+48, xmm0
  00090	0f 11 05 40 00
	00 00		 movups	 XMMWORD PTR ?BattleSkill@@3PAHA+64, xmm0
$LL7@SortSkill:

; 126  : 	{
; 127  : 		switch (profession_skill[i].kind)

  00097	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0009a	83 e8 01	 sub	 eax, 1
  0009d	74 18		 je	 SHORT $LN10@SortSkill
  0009f	83 e8 01	 sub	 eax, 1
  000a2	74 0c		 je	 SHORT $LN11@SortSkill
  000a4	83 e8 01	 sub	 eax, 1
  000a7	75 13		 jne	 SHORT $LN5@SortSkill

; 137  : 		case 3: // è¿›é˜¶
; 138  : 			AdvanceSkill[count3] = i;

  000a9	89 0b		 mov	 DWORD PTR [ebx], ecx

; 139  : 			count3++;

  000ab	83 c3 04	 add	 ebx, 4
  000ae	eb 0c		 jmp	 SHORT $LN5@SortSkill
$LN11@SortSkill:

; 132  : 			break;
; 133  : 		case 2: // è¾…åŠ©
; 134  : 			AssitSkill[count2] = i;

  000b0	89 0f		 mov	 DWORD PTR [edi], ecx

; 135  : 			count2++;

  000b2	83 c7 04	 add	 edi, 4

; 136  : 			break;

  000b5	eb 05		 jmp	 SHORT $LN5@SortSkill
$LN10@SortSkill:

; 128  : 		{
; 129  : 		case 1: // æˆ˜æ–—æŠ€èƒ½
; 130  : 			BattleSkill[count1] = i;

  000b7	89 0e		 mov	 DWORD PTR [esi], ecx

; 131  : 			count1++;

  000b9	83 c6 04	 add	 esi, 4
$LN5@SortSkill:

; 122  : 		AssitSkill[i] = -1;		
; 123  : 		BattleSkill[i] = -1;
; 124  : 	}
; 125  : 	for (int i = 0; i < 26; i++)

  000bc	81 c2 c0 00 00
	00		 add	 edx, 192		; 000000c0H
  000c2	41		 inc	 ecx
  000c3	81 fa 86 13 00
	00		 cmp	 edx, OFFSET ?profession_skill@@3PAUPROFESSION_SKILL@@A+4998
  000c9	7c cc		 jl	 SHORT $LL7@SortSkill

; 140  : 			break;
; 141  : 		}
; 142  : 	}
; 143  : }

  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	c3		 ret	 0
?SortSkill@@YAXXZ ENDP					; SortSkill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_MAMMOTH_OPEN_recv@@YAXPAD@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
?lssproto_MAMMOTH_OPEN_recv@@YAXPAD@Z PROC		; lssproto_MAMMOTH_OPEN_recv, COMDAT

; 4719 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4720 : 	Mammoth::Get().Open(data);

  00003	ff 75 08	 push	 DWORD PTR _data$[ebp]
  00006	e8 00 00 00 00	 call	 ?Get@Mammoth@@SAAAV1@XZ	; Mammoth::Get
  0000b	8b c8		 mov	 ecx, eax
  0000d	e8 00 00 00 00	 call	 ?Open@Mammoth@@QAEXPAD@Z ; Mammoth::Open

; 4721 : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?lssproto_MAMMOTH_OPEN_recv@@YAXPAD@Z ENDP		; lssproto_MAMMOTH_OPEN_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_Firework_recv@@YAXHHHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_nCharaindex$ = 12					; size = 4
_nType$ = 16						; size = 4
_nActionNum$ = 20					; size = 4
?lssproto_Firework_recv@@YAXHHHH@Z PROC			; lssproto_Firework_recv, COMDAT

; 4690 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4691 : 	ACTION	*pAct;
; 4692 : 
; 4693 : 	if (pc.id == nCharaindex)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _nCharaindex$[ebp]
  00006	39 05 08 00 00
	00		 cmp	 DWORD PTR ?pc@@3UPC@@A+8, eax
  0000c	75 1a		 jne	 SHORT $LN2@lssproto_F

; 4694 : 		changePcAct(0, 0, 0, 51, nType, nActionNum, 0);

  0000e	6a 00		 push	 0
  00010	ff 75 14	 push	 DWORD PTR _nActionNum$[ebp]
  00013	ff 75 10	 push	 DWORD PTR _nType$[ebp]
  00016	6a 33		 push	 51			; 00000033H
  00018	6a 00		 push	 0
  0001a	6a 00		 push	 0
  0001c	6a 00		 push	 0
  0001e	e8 00 00 00 00	 call	 ?changePcAct@@YAXHHHHHHH@Z ; changePcAct
  00023	83 c4 1c	 add	 esp, 28			; 0000001cH

; 4699 : 	
; 4700 : 	}
; 4701 : }

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
$LN2@lssproto_F:

; 4695 : 	else
; 4696 : 	{
; 4697 : 		pAct = getCharObjAct(nCharaindex);

  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?getCharObjAct@@YAPAUaction@@H@Z ; getCharObjAct

; 4698 : 		changeCharAct(pAct, 0, 0, 0, 51, nType, nActionNum, 0);

  0002e	6a 00		 push	 0
  00030	ff 75 14	 push	 DWORD PTR _nActionNum$[ebp]
  00033	ff 75 10	 push	 DWORD PTR _nType$[ebp]
  00036	6a 33		 push	 51			; 00000033H
  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	6a 00		 push	 0
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?changeCharAct@@YAXPAUaction@@HHHHHHH@Z ; changeCharAct
  00044	83 c4 24	 add	 esp, 36			; 00000024H

; 4699 : 	
; 4700 : 	}
; 4701 : }

  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?lssproto_Firework_recv@@YAXHHHH@Z ENDP			; lssproto_Firework_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_S2_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_szMessage$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_S2_recv@@YAXHPAD@Z PROC			; lssproto_S2_recv, COMDAT

; 4672 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _data$[ebp]

; 4673 : 	char szMessage[16];
; 4674 : 
; 4675 : 	getStringToken(data,'|',1,sizeof(szMessage) - 1,szMessage);

  00014	8d 45 ec	 lea	 eax, DWORD PTR _szMessage$[ebp]
  00017	50		 push	 eax
  00018	6a 0f		 push	 15			; 0000000fH
  0001a	6a 01		 push	 1
  0001c	6a 7c		 push	 124			; 0000007cH
  0001e	56		 push	 esi
  0001f	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00024	83 c4 14	 add	 esp, 20			; 00000014H

; 4676 : 
; 4677 : #ifdef _NEW_MANOR_LAW
; 4678 : 	if (strcmp(szMessage,"FAME") == 0){

  00027	8d 4d ec	 lea	 ecx, DWORD PTR _szMessage$[ebp]
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04DIIKDPIA@FAME@
  0002f	90		 npad	 1
$LL4@lssproto_S:
  00030	8a 11		 mov	 dl, BYTE PTR [ecx]
  00032	3a 10		 cmp	 dl, BYTE PTR [eax]
  00034	75 1a		 jne	 SHORT $LN5@lssproto_S
  00036	84 d2		 test	 dl, dl
  00038	74 12		 je	 SHORT $LN6@lssproto_S
  0003a	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0003d	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  00040	75 0e		 jne	 SHORT $LN5@lssproto_S
  00042	83 c1 02	 add	 ecx, 2
  00045	83 c0 02	 add	 eax, 2
  00048	84 d2		 test	 dl, dl
  0004a	75 e4		 jne	 SHORT $LL4@lssproto_S
$LN6@lssproto_S:
  0004c	33 c0		 xor	 eax, eax
  0004e	eb 05		 jmp	 SHORT $LN7@lssproto_S
$LN5@lssproto_S:
  00050	1b c0		 sbb	 eax, eax
  00052	83 c8 01	 or	 eax, 1
$LN7@lssproto_S:
  00055	85 c0		 test	 eax, eax
  00057	75 21		 jne	 SHORT $LN2@lssproto_S

; 4679 : 		getStringToken(data,'|',2,sizeof(szMessage) - 1,szMessage);

  00059	8d 45 ec	 lea	 eax, DWORD PTR _szMessage$[ebp]
  0005c	50		 push	 eax
  0005d	6a 0f		 push	 15			; 0000000fH
  0005f	6a 02		 push	 2
  00061	6a 7c		 push	 124			; 0000007cH
  00063	56		 push	 esi
  00064	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 4680 : 		pc.fame = atoi(szMessage);

  00069	8d 45 ec	 lea	 eax, DWORD PTR _szMessage$[ebp]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 _atoi
  00072	83 c4 18	 add	 esp, 24			; 00000018H
  00075	a3 64 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+100, eax
$LN2@lssproto_S:

; 4681 : 	}
; 4682 : #endif
; 4683 : 
; 4684 : 
; 4685 : }

  0007a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007d	33 cd		 xor	 ecx, ebp
  0007f	5e		 pop	 esi
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?lssproto_S2_recv@@YAXHPAD@Z ENDP			; lssproto_S2_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_TEACHER_SYSTEM_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_szMessage$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_TEACHER_SYSTEM_recv@@YAXHPAD@Z PROC		; lssproto_TEACHER_SYSTEM_recv, COMDAT

; 4643 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _data$[ebp]

; 4644 : 	char szMessage[16];
; 4645 : 
; 4646 : 	getStringToken(data,'|',1,sizeof(szMessage) - 1,szMessage);

  00014	8d 45 ec	 lea	 eax, DWORD PTR _szMessage$[ebp]
  00017	50		 push	 eax
  00018	6a 0f		 push	 15			; 0000000fH
  0001a	6a 01		 push	 1
  0001c	6a 7c		 push	 124			; 0000007cH
  0001e	56		 push	 esi
  0001f	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 4647 : 	switch (szMessage[0]){

  00024	0f be 45 ec	 movsx	 eax, BYTE PTR _szMessage$[ebp]
  00028	83 c4 14	 add	 esp, 20			; 00000014H
  0002b	83 c0 bf	 add	 eax, -65		; ffffffbfH
  0002e	83 f8 15	 cmp	 eax, 21			; 00000015H
  00031	77 52		 ja	 SHORT $LN2@lssproto_T
  00033	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN9@lssproto_T[eax]
  0003a	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN10@lssproto_T[eax*4]
$LN4@lssproto_T:

; 4648 : 		// æ˜¾ç¤ºè¯´æ˜Ž
; 4649 : 		case 'M':sTeacherSystemBtn = 1;break;

  00041	b8 01 00 00 00	 mov	 eax, 1
  00046	66 a3 00 00 00
	00		 mov	 WORD PTR ?sTeacherSystemBtn@@3FA, ax ; sTeacherSystemBtn
  0004c	5e		 pop	 esi

; 4664 : 			break;
; 4665 : 
; 4666 : 	}	
; 4667 : }

  0004d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00050	33 cd		 xor	 ecx, ebp
  00052	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
$LN5@lssproto_T:

; 4650 : 		// è¯¢é—®æ˜¯å¦è¦å¯¹æ–¹å½“ä½ çš„å¯¼å¸ˆ
; 4651 : 		case 'C':
; 4652 : 			sTeacherSystemBtn = 2;
; 4653 : 			TeacherSystemWndfunc(0,data);

  0005b	56		 push	 esi
  0005c	b8 02 00 00 00	 mov	 eax, 2
  00061	6a 00		 push	 0

; 4654 : 			break;

  00063	eb 12		 jmp	 SHORT $LN11@lssproto_T
$LN6@lssproto_T:

; 4655 : 		// è¶…è¿‡ä¸€äºº,è¯¢é—®è¦æ‰¾è°å½“å¯¼å¸ˆ
; 4656 : 		case 'A':
; 4657 : 			sTeacherSystemBtn = 3;
; 4658 : 			TeacherSystemWndfunc(1,data);

  00065	56		 push	 esi
  00066	b8 03 00 00 00	 mov	 eax, 3
  0006b	6a 01		 push	 1

; 4659 : 			break;

  0006d	eb 08		 jmp	 SHORT $LN11@lssproto_T
$LN7@lssproto_T:

; 4660 : 		// æ˜¾ç¤ºå¯¼å¸ˆèµ„æ–™
; 4661 : 		case 'V':
; 4662 : 			sTeacherSystemBtn = 4;
; 4663 : 			TeacherSystemWndfunc(2,data);

  0006f	56		 push	 esi
  00070	b8 04 00 00 00	 mov	 eax, 4
  00075	6a 02		 push	 2
$LN11@lssproto_T:

; 4664 : 			break;
; 4665 : 
; 4666 : 	}	
; 4667 : }

  00077	66 a3 00 00 00
	00		 mov	 WORD PTR ?sTeacherSystemBtn@@3FA, ax ; sTeacherSystemBtn
  0007d	e8 00 00 00 00	 call	 ?TeacherSystemWndfunc@@YAXHPAD@Z ; TeacherSystemWndfunc
  00082	83 c4 08	 add	 esp, 8
$LN2@lssproto_T:
  00085	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00088	33 cd		 xor	 ecx, ebp
  0008a	5e		 pop	 esi
  0008b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
$LN10@lssproto_T:
  00094	00 00 00 00	 DD	 $LN6@lssproto_T
  00098	00 00 00 00	 DD	 $LN5@lssproto_T
  0009c	00 00 00 00	 DD	 $LN4@lssproto_T
  000a0	00 00 00 00	 DD	 $LN7@lssproto_T
  000a4	00 00 00 00	 DD	 $LN2@lssproto_T
$LN9@lssproto_T:
  000a8	00		 DB	 0
  000a9	04		 DB	 4
  000aa	01		 DB	 1
  000ab	04		 DB	 4
  000ac	04		 DB	 4
  000ad	04		 DB	 4
  000ae	04		 DB	 4
  000af	04		 DB	 4
  000b0	04		 DB	 4
  000b1	04		 DB	 4
  000b2	04		 DB	 4
  000b3	04		 DB	 4
  000b4	02		 DB	 2
  000b5	04		 DB	 4
  000b6	04		 DB	 4
  000b7	04		 DB	 4
  000b8	04		 DB	 4
  000b9	04		 DB	 4
  000ba	04		 DB	 4
  000bb	04		 DB	 4
  000bc	04		 DB	 4
  000bd	03		 DB	 3
?lssproto_TEACHER_SYSTEM_recv@@YAXHPAD@Z ENDP		; lssproto_TEACHER_SYSTEM_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_JOBDAILY_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_data$GSCopy$1$ = -460					; size = 4
_getdata$ = -456					; size = 250
_perdata$ = -204					; size = 200
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_JOBDAILY_recv@@YAXHPAD@Z PROC			; lssproto_JOBDAILY_recv, COMDAT

; 4602 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 01 00
	00		 sub	 esp, 460		; 000001ccH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR _data$[ebp]

; 4603 : 	//è§£è¯»èµ„æ–™
; 4604 : 	int  i=1,j=1;

  00018	bb 01 00 00 00	 mov	 ebx, 1

; 4605 : 	char getdata[250];
; 4606 : 	char perdata[200];
; 4607 : 
; 4608 : 	//StockChatBufferLine(data,FONT_PAL_RED); 
; 4609 : 
; 4610 : 	memset(jobdaily,0,sizeof(jobdaily));

  0001d	68 20 fd 00 00	 push	 64800			; 0000fd20H
  00022	6a 00		 push	 0
  00024	68 00 00 00 00	 push	 OFFSET ?jobdaily@@3PAUJOBDAILY@@A ; jobdaily
  00029	89 b5 34 fe ff
	ff		 mov	 DWORD PTR _data$GSCopy$1$[ebp], esi
  0002f	e8 00 00 00 00	 call	 _memset

; 4611 : 	getdata[0] = '\0';
; 4612 : 	perdata[0] = '\0';
; 4613 : 	while(getStringToken(data,'#',i,sizeof(getdata) - 1,getdata)!=1){

  00034	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR _getdata$[ebp]
  0003a	c6 85 38 fe ff
	ff 00		 mov	 BYTE PTR _getdata$[ebp], 0
  00041	50		 push	 eax
  00042	68 f9 00 00 00	 push	 249			; 000000f9H
  00047	53		 push	 ebx
  00048	6a 23		 push	 35			; 00000023H
  0004a	56		 push	 esi
  0004b	c6 85 34 ff ff
	ff 00		 mov	 BYTE PTR _perdata$[ebp], 0
  00052	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00057	83 c4 20	 add	 esp, 32			; 00000020H
  0005a	3b c3		 cmp	 eax, ebx
  0005c	0f 84 3d 01 00
	00		 je	 $LN12@lssproto_J

; 4602 : {

  00062	be 04 00 00 00	 mov	 esi, OFFSET ?jobdaily@@3PAUJOBDAILY@@A+4
  00067	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _perdata$[ebp]
  0006d	2b f0		 sub	 esi, eax
  0006f	57		 push	 edi
$LL2@lssproto_J:

; 4614 : 		while(getStringToken(getdata,'|',j,sizeof(perdata) - 1,perdata)!=1){

  00070	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _perdata$[ebp]
  00076	50		 push	 eax
  00077	68 c7 00 00 00	 push	 199			; 000000c7H
  0007c	6a 01		 push	 1
  0007e	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR _getdata$[ebp]
  00084	6a 7c		 push	 124			; 0000007cH
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0008c	83 c4 14	 add	 esp, 20			; 00000014H
  0008f	83 f8 01	 cmp	 eax, 1
  00092	0f 84 ac 00 00
	00		 je	 $LN5@lssproto_J
  00098	bf 01 00 00 00	 mov	 edi, 1
  0009d	0f 1f 00	 npad	 3
$LL4@lssproto_J:

; 4615 : 			switch (j){

  000a0	8b c7		 mov	 eax, edi
  000a2	83 e8 01	 sub	 eax, 1
  000a5	74 58		 je	 SHORT $LN8@lssproto_J
  000a7	83 e8 01	 sub	 eax, 1
  000aa	74 36		 je	 SHORT $LN9@lssproto_J
  000ac	83 e8 01	 sub	 eax, 1
  000af	74 13		 je	 SHORT $LN10@lssproto_J

; 4619 : 			default: StockChatBufferLine("æ¯ç¬”èµ„æ–™å†…å‚æ•°æœ‰é”™è¯¯",FONT_PAL_RED); break;

  000b1	6a 00		 push	 0
  000b3	6a 06		 push	 6
  000b5	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PEDECIPG@?X?$NP?$DP?$DP?V?y?$DP?$DP?$DP?j?s?$DP?$DP@
  000ba	e8 00 00 00 00	 call	 ?StockChatBufferLine@@YAXPADEH@Z ; StockChatBufferLine
  000bf	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c2	eb 51		 jmp	 SHORT $LN6@lssproto_J
$LN10@lssproto_J:

; 4618 : 			case 3: strcpy(jobdaily[i-1].state,perdata); break;

  000c4	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR _perdata$[ebp]
  000ca	66 0f 1f 44 00
	00		 npad	 6
$LL20@lssproto_J:
  000d0	8a 01		 mov	 al, BYTE PTR [ecx]
  000d2	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  000d5	88 84 0e c7 00
	00 00		 mov	 BYTE PTR [esi+ecx+199], al
  000dc	84 c0		 test	 al, al
  000de	75 f0		 jne	 SHORT $LL20@lssproto_J
  000e0	eb 33		 jmp	 SHORT $LN6@lssproto_J
$LN9@lssproto_J:

; 4617 : 			case 2: strcpy(jobdaily[i-1].explain,perdata); break;

  000e2	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _perdata$[ebp]
  000e8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL19@lssproto_J:
  000f0	8a 08		 mov	 cl, BYTE PTR [eax]
  000f2	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  000f5	88 4c 06 ff	 mov	 BYTE PTR [esi+eax-1], cl
  000f9	84 c9		 test	 cl, cl
  000fb	75 f3		 jne	 SHORT $LL19@lssproto_J
  000fd	eb 16		 jmp	 SHORT $LN6@lssproto_J
$LN8@lssproto_J:

; 4616 : 			case 1: jobdaily[i-1].JobId = atoi(perdata);break;

  000ff	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _perdata$[ebp]
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 _atoi
  0010b	83 c4 04	 add	 esp, 4
  0010e	89 84 35 30 ff
	ff ff		 mov	 DWORD PTR _perdata$[ebp+esi-4], eax
$LN6@lssproto_J:

; 4620 : 			}
; 4621 : 			perdata[0] = '\0';

  00115	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _perdata$[ebp]
  0011b	c6 85 34 ff ff
	ff 00		 mov	 BYTE PTR _perdata$[ebp], 0
  00122	50		 push	 eax
  00123	68 c7 00 00 00	 push	 199			; 000000c7H

; 4622 : 			j++;

  00128	47		 inc	 edi
  00129	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR _getdata$[ebp]
  0012f	57		 push	 edi
  00130	6a 7c		 push	 124			; 0000007cH
  00132	50		 push	 eax
  00133	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00138	83 c4 14	 add	 esp, 20			; 00000014H
  0013b	83 f8 01	 cmp	 eax, 1
  0013e	0f 85 5c ff ff
	ff		 jne	 $LL4@lssproto_J
$LN5@lssproto_J:

; 4611 : 	getdata[0] = '\0';
; 4612 : 	perdata[0] = '\0';
; 4613 : 	while(getStringToken(data,'#',i,sizeof(getdata) - 1,getdata)!=1){

  00144	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR _getdata$[ebp]

; 4623 : 		}
; 4624 : 		getdata[0] = '\0';

  0014a	c6 85 38 fe ff
	ff 00		 mov	 BYTE PTR _getdata$[ebp], 0
  00151	50		 push	 eax
  00152	68 f9 00 00 00	 push	 249			; 000000f9H

; 4625 : 		j=1;
; 4626 : 		i++;

  00157	43		 inc	 ebx
  00158	81 c6 d8 00 00
	00		 add	 esi, 216		; 000000d8H
  0015e	53		 push	 ebx
  0015f	6a 23		 push	 35			; 00000023H
  00161	ff b5 34 fe ff
	ff		 push	 DWORD PTR _data$GSCopy$1$[ebp]
  00167	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0016c	83 c4 14	 add	 esp, 20			; 00000014H
  0016f	83 f8 01	 cmp	 eax, 1
  00172	0f 85 f8 fe ff
	ff		 jne	 $LL2@lssproto_J

; 4627 : 	}
; 4628 : 	if (i>1){ 

  00178	5f		 pop	 edi
  00179	3b d8		 cmp	 ebx, eax
  0017b	7e 22		 jle	 SHORT $LN12@lssproto_J

; 4629 : 		JobdailyGetFlag = TRUE;
; 4630 : 		JobdailyGetMax= i-2;

  0017d	8d 43 fe	 lea	 eax, DWORD PTR [ebx-2]

; 4631 : 	}else{
; 4632 : 		JobdailyGetFlag = FALSE;
; 4633 : 		JobdailyGetMax = -1;
; 4634 : 	}
; 4635 : }

  00180	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?JobdailyGetFlag@@3HA, 1 ; JobdailyGetFlag
  0018a	5e		 pop	 esi
  0018b	a3 00 00 00 00	 mov	 DWORD PTR ?JobdailyGetMax@@3HA, eax ; JobdailyGetMax
  00190	5b		 pop	 ebx
  00191	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00194	33 cd		 xor	 ecx, ebp
  00196	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0019b	8b e5		 mov	 esp, ebp
  0019d	5d		 pop	 ebp
  0019e	c3		 ret	 0
$LN12@lssproto_J:
  0019f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a2	5e		 pop	 esi
  001a3	33 cd		 xor	 ecx, ebp
  001a5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?JobdailyGetFlag@@3HA, 0 ; JobdailyGetFlag
  001af	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?JobdailyGetMax@@3HA, -1 ; JobdailyGetMax
  001b9	5b		 pop	 ebx
  001ba	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001bf	8b e5		 mov	 esp, ebp
  001c1	5d		 pop	 ebp
  001c2	c3		 ret	 0
?lssproto_JOBDAILY_recv@@YAXHPAD@Z ENDP			; lssproto_JOBDAILY_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_STREET_VENDOR_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_szMessage$ = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_STREET_VENDOR_recv@@YAXHPAD@Z PROC		; lssproto_STREET_VENDOR_recv, COMDAT

; 4565 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _data$[ebp]

; 4566 : 	char szMessage[32];
; 4567 : 
; 4568 : 	getStringToken(data,'|',1,sizeof(szMessage) - 1,szMessage);

  00014	8d 45 dc	 lea	 eax, DWORD PTR _szMessage$[ebp]
  00017	50		 push	 eax
  00018	6a 1f		 push	 31			; 0000001fH
  0001a	6a 01		 push	 1
  0001c	6a 7c		 push	 124			; 0000007cH
  0001e	56		 push	 esi
  0001f	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 4569 : 	switch (szMessage[0]){

  00024	0f be 45 dc	 movsx	 eax, BYTE PTR _szMessage$[ebp]
  00028	83 c4 14	 add	 esp, 20			; 00000014H
  0002b	83 c0 be	 add	 eax, -66		; ffffffbeH
  0002e	83 f8 11	 cmp	 eax, 17			; 00000011H
  00031	77 66		 ja	 SHORT $LN2@lssproto_S
  00033	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN10@lssproto_S[eax]
  0003a	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN11@lssproto_S[eax*4]
$LN4@lssproto_S:

; 4570 : 		// å¼€æ–°æ‘†æ‘Šä»‹é¢
; 4571 : 		case 'O':
; 4572 : 			sStreetVendorBtn = 1;

  00041	b8 01 00 00 00	 mov	 eax, 1
  00046	66 a3 00 00 00
	00		 mov	 WORD PTR ?sStreetVendorBtn@@3FA, ax ; sStreetVendorBtn

; 4573 : 			pc.iOnStreetVendor = 1;

  0004c	a3 b8 a1 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+41400, eax
  00051	5e		 pop	 esi

; 4583 : 			StreetVendorBuyWndfunc(data);
; 4584 : 			break;
; 4585 : 		// server é€æ¥å…³é—­è§†çª—
; 4586 : 		case 'C':
; 4587 : 			sStreetVendorBuyBtn = 0;
; 4588 : 			break;
; 4589 : 		// server é€æ¥çš„å•ç¬”è´©å–ç‰©è¯¦ç»†èµ„æ–™
; 4590 : 		case 'D':
; 4591 : 			StreetVendorBuyWndfunc(data);
; 4592 : 			break;
; 4593 : 	}
; 4594 : }

  00052	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00055	33 cd		 xor	 ecx, ebp
  00057	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
$LN5@lssproto_S:

; 4574 : 			break;
; 4575 : 		// è®¾å®šæ‘†æ‘Šå†…å®¹
; 4576 : 		case 'S':
; 4577 : 			sStreetVendorBtn = 3;

  00060	b8 03 00 00 00	 mov	 eax, 3

; 4578 : 			StreetVendorWndfunc(false,data);

  00065	56		 push	 esi
  00066	6a 00		 push	 0
  00068	66 a3 00 00 00
	00		 mov	 WORD PTR ?sStreetVendorBtn@@3FA, ax ; sStreetVendorBtn
  0006e	e8 00 00 00 00	 call	 ?StreetVendorWndfunc@@YAX_NPAD@Z ; StreetVendorWndfunc
  00073	83 c4 08	 add	 esp, 8
  00076	5e		 pop	 esi

; 4583 : 			StreetVendorBuyWndfunc(data);
; 4584 : 			break;
; 4585 : 		// server é€æ¥å…³é—­è§†çª—
; 4586 : 		case 'C':
; 4587 : 			sStreetVendorBuyBtn = 0;
; 4588 : 			break;
; 4589 : 		// server é€æ¥çš„å•ç¬”è´©å–ç‰©è¯¦ç»†èµ„æ–™
; 4590 : 		case 'D':
; 4591 : 			StreetVendorBuyWndfunc(data);
; 4592 : 			break;
; 4593 : 	}
; 4594 : }

  00077	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007a	33 cd		 xor	 ecx, ebp
  0007c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
$LN6@lssproto_S:

; 4579 : 			break;
; 4580 : 		// serveré€æ¥çš„å–æ–¹è´©å–å†…å®¹
; 4581 : 		case 'B':
; 4582 : 			sStreetVendorBuyBtn = 1;

  00085	b8 01 00 00 00	 mov	 eax, 1
  0008a	66 a3 00 00 00
	00		 mov	 WORD PTR ?sStreetVendorBuyBtn@@3FA, ax ; sStreetVendorBuyBtn
$LN8@lssproto_S:

; 4583 : 			StreetVendorBuyWndfunc(data);
; 4584 : 			break;
; 4585 : 		// server é€æ¥å…³é—­è§†çª—
; 4586 : 		case 'C':
; 4587 : 			sStreetVendorBuyBtn = 0;
; 4588 : 			break;
; 4589 : 		// server é€æ¥çš„å•ç¬”è´©å–ç‰©è¯¦ç»†èµ„æ–™
; 4590 : 		case 'D':
; 4591 : 			StreetVendorBuyWndfunc(data);
; 4592 : 			break;
; 4593 : 	}
; 4594 : }

  00090	56		 push	 esi
  00091	e8 00 00 00 00	 call	 ?StreetVendorBuyWndfunc@@YAXPAD@Z ; StreetVendorBuyWndfunc
  00096	83 c4 04	 add	 esp, 4
$LN2@lssproto_S:
  00099	5e		 pop	 esi
  0009a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009d	33 cd		 xor	 ecx, ebp
  0009f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
$LN7@lssproto_S:
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ab	33 c0		 xor	 eax, eax
  000ad	33 cd		 xor	 ecx, ebp
  000af	66 a3 00 00 00
	00		 mov	 WORD PTR ?sStreetVendorBuyBtn@@3FA, ax ; sStreetVendorBuyBtn
  000b5	5e		 pop	 esi
  000b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
  000bf	90		 npad	 1
$LN11@lssproto_S:
  000c0	00 00 00 00	 DD	 $LN6@lssproto_S
  000c4	00 00 00 00	 DD	 $LN7@lssproto_S
  000c8	00 00 00 00	 DD	 $LN8@lssproto_S
  000cc	00 00 00 00	 DD	 $LN4@lssproto_S
  000d0	00 00 00 00	 DD	 $LN5@lssproto_S
  000d4	00 00 00 00	 DD	 $LN2@lssproto_S
$LN10@lssproto_S:
  000d8	00		 DB	 0
  000d9	01		 DB	 1
  000da	02		 DB	 2
  000db	05		 DB	 5
  000dc	05		 DB	 5
  000dd	05		 DB	 5
  000de	05		 DB	 5
  000df	05		 DB	 5
  000e0	05		 DB	 5
  000e1	05		 DB	 5
  000e2	05		 DB	 5
  000e3	05		 DB	 5
  000e4	05		 DB	 5
  000e5	03		 DB	 3
  000e6	05		 DB	 5
  000e7	05		 DB	 5
  000e8	05		 DB	 5
  000e9	04		 DB	 4
?lssproto_STREET_VENDOR_recv@@YAXHPAD@Z ENDP		; lssproto_STREET_VENDOR_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_PETST_recv@@YAXHHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_petarray$ = 12						; size = 4
_result$ = 16						; size = 4
?lssproto_PETST_recv@@YAXHHH@Z PROC			; lssproto_PETST_recv, COMDAT

; 3917 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3918 : 	if ( petarray < 0 || petarray >= 5 ) return;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _petarray$[ebp]
  00006	83 f9 04	 cmp	 ecx, 4
  00009	77 45		 ja	 SHORT $LN3@lssproto_P

; 3919 : 	pc.selectPetNo[ petarray] = result;

  0000b	66 8b 45 10	 mov	 ax, WORD PTR _result$[ebp]
  0000f	66 89 04 4d ac
	00 00 00	 mov	 WORD PTR ?pc@@3UPC@@A[ecx*2+172], ax

; 3920 : 	BattlePetStMenCnt--;

  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BattlePetStMenCnt@@3HA ; BattlePetStMenCnt
  0001c	83 e8 01	 sub	 eax, 1

; 3921 : 	if ( BattlePetStMenCnt < 0 ) BattlePetStMenCnt = 0;

  0001f	79 0c		 jns	 SHORT $LN4@lssproto_P
  00021	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BattlePetStMenCnt@@3HA, 0 ; BattlePetStMenCnt

; 3922 : 	if ( BattlePetStMenCnt > ç­‰å¾…å® æ•°é‡) BattlePetStMenCnt = ç­‰å¾…å® æ•°é‡;

  0002b	eb 0f		 jmp	 SHORT $LN5@lssproto_P
$LN4@lssproto_P:
  0002d	ba 05 00 00 00	 mov	 edx, 5
  00032	3b c2		 cmp	 eax, edx
  00034	0f 4f c2	 cmovg	 eax, edx
  00037	a3 00 00 00 00	 mov	 DWORD PTR ?BattlePetStMenCnt@@3HA, eax ; BattlePetStMenCnt
$LN5@lssproto_P:

; 3923 : 	if ( pc.battlePetNo == petarray )

  0003c	0f bf 05 aa 00
	00 00		 movsx	 eax, WORD PTR ?pc@@3UPC@@A+170
  00043	3b c1		 cmp	 eax, ecx
  00045	75 09		 jne	 SHORT $LN3@lssproto_P

; 3924 : 		pc.battlePetNo = -1;

  00047	83 c8 ff	 or	 eax, -1
  0004a	66 a3 aa 00 00
	00		 mov	 WORD PTR ?pc@@3UPC@@A+170, ax
$LN3@lssproto_P:

; 3925 : }

  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?lssproto_PETST_recv@@YAXHHH@Z ENDP			; lssproto_PETST_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_NC_recv@@YAXHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_flg$ = 12						; size = 4
?lssproto_NC_recv@@YAXHH@Z PROC				; lssproto_NC_recv, COMDAT

; 4467 : {  

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4468 : 	if (flg==1 )
; 4469 : 		NoCastFlag=TRUE;
; 4470 :     else 
; 4471 : 		NoCastFlag=FALSE;
; 4472 : }

  00003	33 c0		 xor	 eax, eax
  00005	83 7d 0c 01	 cmp	 DWORD PTR _flg$[ebp], 1
  00009	0f 94 c0	 sete	 al
  0000c	a3 00 00 00 00	 mov	 DWORD PTR ?NoCastFlag@@3HA, eax ; NoCastFlag
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?lssproto_NC_recv@@YAXHH@Z ENDP				; lssproto_NC_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_IC_recv@@YAXHHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
?lssproto_IC_recv@@YAXHHH@Z PROC			; lssproto_IC_recv, COMDAT

; 4443 : 	m_bt = true; setCharMind( pc.ptAct, SPR_cracker);	

  00000	68 19 8c 01 00	 push	 101401			; 00018c19H
  00005	ff 35 ec 50 00
	00		 push	 DWORD PTR ?pc@@3UPC@@A+20716
  0000b	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?m_bt@@3_NA, 1	; m_bt
  00012	e8 00 00 00 00	 call	 ?setCharMind@@YAXPAUaction@@H@Z ; setCharMind
  00017	83 c4 08	 add	 esp, 8

; 4444 : 	m_bt = false;

  0001a	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?m_bt@@3_NA, 0	; m_bt

; 4445 : }

  00021	c3		 ret	 0
?lssproto_IC_recv@@YAXHHH@Z ENDP			; lssproto_IC_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_WO_recv@@YAXHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_effect$ = 12						; size = 4
?lssproto_WO_recv@@YAXHH@Z PROC				; lssproto_WO_recv, COMDAT

; 4119 : 	return;
; 4120 : 	// ???????
; 4121 : 	if ( effect == 0 )
; 4122 : 	{
; 4123 : 		// î˜¿î’Ÿ????????
; 4124 : 		transmigrationEffectFlag = 1;
; 4125 : 		// î˜¿î’Ÿ?????????îŸ‰????
; 4126 : 		transEffectPaletteStatus = 1;
; 4127 : 		// ????????
; 4128 : 		palNo = 15;
; 4129 : 		palTime = 300;
; 4130 : 	}
; 4131 : }

  00000	c2 00 00	 ret	 0
?lssproto_WO_recv@@YAXHH@Z ENDP				; lssproto_WO_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_FM_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_FMType3$ = -1540					; size = 512
_FMType1$ = -1028					; size = 512
_FMType2$ = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_FM_recv@@YAXHPAD@Z PROC			; lssproto_FM_recv, COMDAT

; 4204 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 06 00
	00		 sub	 esp, 1540		; 00000604H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 0c	 mov	 esi, DWORD PTR _data$[ebp]

; 4205 : 	char FMType1[512];
; 4206 : 	char FMType2[512];
; 4207 : 	char FMType3[512];
; 4208 : 	
; 4209 : 	getStringToken(data, '|', 1, sizeof( FMType1 ) - 1, FMType1 );

  00017	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _FMType1$[ebp]
  0001d	50		 push	 eax
  0001e	68 ff 01 00 00	 push	 511			; 000001ffH
  00023	6a 01		 push	 1
  00025	6a 7c		 push	 124			; 0000007cH
  00027	56		 push	 esi
  00028	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 4210 : 	//makeStringFromEscaped( FMType1 );
; 4211 : 	getStringToken(data, '|', 2, sizeof( FMType2 ) - 1, FMType2 );

  0002d	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _FMType2$[ebp]
  00033	50		 push	 eax
  00034	68 ff 01 00 00	 push	 511			; 000001ffH
  00039	6a 02		 push	 2
  0003b	6a 7c		 push	 124			; 0000007cH
  0003d	56		 push	 esi
  0003e	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00043	83 c4 28	 add	 esp, 40			; 00000028H

; 4212 : 	//makeStringFromEscaped( FMType2 );
; 4213 : 
; 4214 : 	if ( strcmp(FMType1,"S") ==0 )

  00046	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _FMType1$[ebp]
  0004c	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01CPLAODJH@S@
$LL22@lssproto_F:
  00051	8a 10		 mov	 dl, BYTE PTR [eax]
  00053	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00055	75 1a		 jne	 SHORT $LN23@lssproto_F
  00057	84 d2		 test	 dl, dl
  00059	74 12		 je	 SHORT $LN24@lssproto_F
  0005b	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0005e	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00061	75 0e		 jne	 SHORT $LN23@lssproto_F
  00063	83 c0 02	 add	 eax, 2
  00066	83 c1 02	 add	 ecx, 2
  00069	84 d2		 test	 dl, dl
  0006b	75 e4		 jne	 SHORT $LL22@lssproto_F
$LN24@lssproto_F:
  0006d	33 c0		 xor	 eax, eax
  0006f	eb 05		 jmp	 SHORT $LN25@lssproto_F
$LN23@lssproto_F:
  00071	1b c0		 sbb	 eax, eax
  00073	83 c8 01	 or	 eax, 1
$LN25@lssproto_F:
  00076	85 c0		 test	 eax, eax
  00078	0f 85 97 00 00
	00		 jne	 $LN2@lssproto_F

; 4215 : 	{
; 4216 : 		if ( strcmp(FMType2,"F") ==0) // å®¶æ—åˆ—è¡¨

  0007e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01BIAFAFID@F@
  00083	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _FMType2$[ebp]
  00089	0f 1f 80 00 00
	00 00		 npad	 7
$LL26@lssproto_F:
  00090	8a 10		 mov	 dl, BYTE PTR [eax]
  00092	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00094	75 1a		 jne	 SHORT $LN27@lssproto_F
  00096	84 d2		 test	 dl, dl
  00098	74 12		 je	 SHORT $LN28@lssproto_F
  0009a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0009d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000a0	75 0e		 jne	 SHORT $LN27@lssproto_F
  000a2	83 c0 02	 add	 eax, 2
  000a5	83 c1 02	 add	 ecx, 2
  000a8	84 d2		 test	 dl, dl
  000aa	75 e4		 jne	 SHORT $LL26@lssproto_F
$LN28@lssproto_F:
  000ac	33 c0		 xor	 eax, eax
  000ae	eb 05		 jmp	 SHORT $LN29@lssproto_F
$LN27@lssproto_F:
  000b0	1b c0		 sbb	 eax, eax
  000b2	83 c8 01	 or	 eax, 1
$LN29@lssproto_F:
  000b5	85 c0		 test	 eax, eax
  000b7	75 09		 jne	 SHORT $LN4@lssproto_F

; 4217 : 		{
; 4218 : 			initFamilyList(data );

  000b9	56		 push	 esi
  000ba	e8 00 00 00 00	 call	 ?initFamilyList@@YAXPAD@Z ; initFamilyList
  000bf	83 c4 04	 add	 esp, 4
$LN4@lssproto_F:

; 4219 : 
; 4220 : 		}
; 4221 : 		if ( strcmp(FMType2,"D") ==0) // å®¶æ—è¯¦ç»†

  000c2	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01CKDDGHAB@D@
  000c7	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _FMType2$[ebp]
  000cd	0f 1f 00	 npad	 3
$LL30@lssproto_F:
  000d0	8a 10		 mov	 dl, BYTE PTR [eax]
  000d2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000d4	75 1a		 jne	 SHORT $LN31@lssproto_F
  000d6	84 d2		 test	 dl, dl
  000d8	74 12		 je	 SHORT $LN32@lssproto_F
  000da	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000dd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000e0	75 0e		 jne	 SHORT $LN31@lssproto_F
  000e2	83 c0 02	 add	 eax, 2
  000e5	83 c1 02	 add	 ecx, 2
  000e8	84 d2		 test	 dl, dl
  000ea	75 e4		 jne	 SHORT $LL30@lssproto_F
$LN32@lssproto_F:
  000ec	33 c0		 xor	 eax, eax
  000ee	eb 05		 jmp	 SHORT $LN33@lssproto_F
$LN31@lssproto_F:
  000f0	1b c0		 sbb	 eax, eax
  000f2	83 c8 01	 or	 eax, 1
$LN33@lssproto_F:
  000f5	85 c0		 test	 eax, eax
  000f7	0f 85 f5 02 00
	00		 jne	 $LN20@lssproto_F

; 4222 : 		{
; 4223 : 			initFamilyDetail(data );

  000fd	56		 push	 esi
  000fe	e8 00 00 00 00	 call	 ?initFamilyDetail@@YAXPAD@Z ; initFamilyDetail

; 4281 : 		}
; 4282 : 	}
; 4283 : 
; 4284 : }

  00103	83 c4 04	 add	 esp, 4
  00106	5e		 pop	 esi
  00107	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010a	33 cd		 xor	 ecx, ebp
  0010c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00111	8b e5		 mov	 esp, ebp
  00113	5d		 pop	 ebp
  00114	c3		 ret	 0
$LN2@lssproto_F:

; 4224 : 
; 4225 : 		}
; 4226 : 
; 4227 : 	}
; 4228 : 	else if ( strcmp(FMType1,"C") ==0 )

  00115	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01GFHCPBMG@C@
  0011a	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _FMType1$[ebp]
$LL34@lssproto_F:
  00120	8a 10		 mov	 dl, BYTE PTR [eax]
  00122	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00124	75 1a		 jne	 SHORT $LN35@lssproto_F
  00126	84 d2		 test	 dl, dl
  00128	74 12		 je	 SHORT $LN36@lssproto_F
  0012a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0012d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00130	75 0e		 jne	 SHORT $LN35@lssproto_F
  00132	83 c0 02	 add	 eax, 2
  00135	83 c1 02	 add	 ecx, 2
  00138	84 d2		 test	 dl, dl
  0013a	75 e4		 jne	 SHORT $LL34@lssproto_F
$LN36@lssproto_F:
  0013c	33 c0		 xor	 eax, eax
  0013e	eb 05		 jmp	 SHORT $LN37@lssproto_F
$LN35@lssproto_F:
  00140	1b c0		 sbb	 eax, eax
  00142	83 c8 01	 or	 eax, 1
$LN37@lssproto_F:
  00145	85 c0		 test	 eax, eax
  00147	0f 85 c0 00 00
	00		 jne	 $LN6@lssproto_F

; 4229 : 	{
; 4230 : 		if ( strcmp(FMType2,"J") ==0) // åŠ å…¥é¢‘é“

  0014d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01LELAEKIP@J@
  00152	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _FMType2$[ebp]
$LL38@lssproto_F:
  00158	8a 10		 mov	 dl, BYTE PTR [eax]
  0015a	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0015c	75 1a		 jne	 SHORT $LN39@lssproto_F
  0015e	84 d2		 test	 dl, dl
  00160	74 12		 je	 SHORT $LN40@lssproto_F
  00162	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00165	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00168	75 0e		 jne	 SHORT $LN39@lssproto_F
  0016a	83 c0 02	 add	 eax, 2
  0016d	83 c1 02	 add	 ecx, 2
  00170	84 d2		 test	 dl, dl
  00172	75 e4		 jne	 SHORT $LL38@lssproto_F
$LN40@lssproto_F:
  00174	33 c0		 xor	 eax, eax
  00176	eb 05		 jmp	 SHORT $LN41@lssproto_F
$LN39@lssproto_F:
  00178	1b c0		 sbb	 eax, eax
  0017a	83 c8 01	 or	 eax, 1
$LN41@lssproto_F:
  0017d	85 c0		 test	 eax, eax
  0017f	75 3c		 jne	 SHORT $LN9@lssproto_F

; 4231 : 		{
; 4232 : 			getStringToken(data, '|', 3, sizeof( FMType3 ) - 1, FMType3 );

  00181	8d 85 fc f9 ff
	ff		 lea	 eax, DWORD PTR _FMType3$[ebp]
  00187	50		 push	 eax
  00188	68 ff 01 00 00	 push	 511			; 000001ffH
  0018d	6a 03		 push	 3
  0018f	6a 7c		 push	 124			; 0000007cH
  00191	56		 push	 esi
  00192	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 4233 : 			pc.channel = atoi( FMType3 );

  00197	8d 85 fc f9 ff
	ff		 lea	 eax, DWORD PTR _FMType3$[ebp]
  0019d	50		 push	 eax
  0019e	e8 00 00 00 00	 call	 _atoi

; 4234 : 			if ( pc.channel != -1 )

  001a3	8b 0d 10 51 00
	00		 mov	 ecx, DWORD PTR ?pc@@3UPC@@A+20752
  001a9	83 c4 18	 add	 esp, 24			; 00000018H
  001ac	83 f8 ff	 cmp	 eax, -1
  001af	a3 0c 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20748, eax
  001b4	0f 45 c8	 cmovne	 ecx, eax
  001b7	89 0d 10 51 00
	00		 mov	 DWORD PTR ?pc@@3UPC@@A+20752, ecx
$LN9@lssproto_F:

; 4235 : 				pc.quickChannel = pc.channel;
; 4236 : 		}
; 4237 : 		if ( strcmp(FMType2,"L") ==0) // é¢‘é“åˆ—è¡¨

  001bd	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01OCOKONAJ@L@
  001c2	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _FMType2$[ebp]
$LL42@lssproto_F:
  001c8	8a 10		 mov	 dl, BYTE PTR [eax]
  001ca	3a 11		 cmp	 dl, BYTE PTR [ecx]
  001cc	75 1a		 jne	 SHORT $LN43@lssproto_F
  001ce	84 d2		 test	 dl, dl
  001d0	74 12		 je	 SHORT $LN44@lssproto_F
  001d2	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  001d5	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  001d8	75 0e		 jne	 SHORT $LN43@lssproto_F
  001da	83 c0 02	 add	 eax, 2
  001dd	83 c1 02	 add	 ecx, 2
  001e0	84 d2		 test	 dl, dl
  001e2	75 e4		 jne	 SHORT $LL42@lssproto_F
$LN44@lssproto_F:
  001e4	33 c0		 xor	 eax, eax
  001e6	eb 05		 jmp	 SHORT $LN45@lssproto_F
$LN43@lssproto_F:
  001e8	1b c0		 sbb	 eax, eax
  001ea	83 c8 01	 or	 eax, 1
$LN45@lssproto_F:
  001ed	85 c0		 test	 eax, eax
  001ef	0f 85 fd 01 00
	00		 jne	 $LN20@lssproto_F

; 4238 : 		{
; 4239 : 			initJoinChannel2WN(data );

  001f5	56		 push	 esi
  001f6	e8 00 00 00 00	 call	 ?initJoinChannel2WN@@YAXPAD@Z ; initJoinChannel2WN

; 4281 : 		}
; 4282 : 	}
; 4283 : 
; 4284 : }

  001fb	83 c4 04	 add	 esp, 4
  001fe	5e		 pop	 esi
  001ff	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00202	33 cd		 xor	 ecx, ebp
  00204	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00209	8b e5		 mov	 esp, ebp
  0020b	5d		 pop	 ebp
  0020c	c3		 ret	 0
$LN6@lssproto_F:

; 4240 : 
; 4241 : 		}
; 4242 : 	}
; 4243 : 	else if ( strcmp(FMType1,"B") ==0 )

  0020d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01HMGJMAIH@B@
  00212	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _FMType1$[ebp]
$LL46@lssproto_F:
  00218	8a 10		 mov	 dl, BYTE PTR [eax]
  0021a	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0021c	75 1a		 jne	 SHORT $LN47@lssproto_F
  0021e	84 d2		 test	 dl, dl
  00220	74 12		 je	 SHORT $LN48@lssproto_F
  00222	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00225	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00228	75 0e		 jne	 SHORT $LN47@lssproto_F
  0022a	83 c0 02	 add	 eax, 2
  0022d	83 c1 02	 add	 ecx, 2
  00230	84 d2		 test	 dl, dl
  00232	75 e4		 jne	 SHORT $LL46@lssproto_F
$LN48@lssproto_F:
  00234	33 c0		 xor	 eax, eax
  00236	eb 05		 jmp	 SHORT $LN49@lssproto_F
$LN47@lssproto_F:
  00238	1b c0		 sbb	 eax, eax
  0023a	83 c8 01	 or	 eax, 1
$LN49@lssproto_F:
  0023d	85 c0		 test	 eax, eax
  0023f	0f 85 90 00 00
	00		 jne	 $LN11@lssproto_F

; 4244 : 	{
; 4245 : 
; 4246 : 		//MenuToggleFlag = JOY_CTRL_B;
; 4247 : 		if ( strcmp(FMType2,"G") ==0)

  00245	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01BBODEMC@G@
  0024a	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _FMType2$[ebp]
$LL50@lssproto_F:
  00250	8a 10		 mov	 dl, BYTE PTR [eax]
  00252	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00254	75 1a		 jne	 SHORT $LN51@lssproto_F
  00256	84 d2		 test	 dl, dl
  00258	74 12		 je	 SHORT $LN52@lssproto_F
  0025a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0025d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00260	75 0e		 jne	 SHORT $LN51@lssproto_F
  00262	83 c0 02	 add	 eax, 2
  00265	83 c1 02	 add	 ecx, 2
  00268	84 d2		 test	 dl, dl
  0026a	75 e4		 jne	 SHORT $LL50@lssproto_F
$LN52@lssproto_F:
  0026c	33 c0		 xor	 eax, eax
  0026e	eb 05		 jmp	 SHORT $LN53@lssproto_F
$LN51@lssproto_F:
  00270	1b c0		 sbb	 eax, eax
  00272	83 c8 01	 or	 eax, 1
$LN53@lssproto_F:
  00275	85 c0		 test	 eax, eax
  00277	75 09		 jne	 SHORT $LN13@lssproto_F

; 4248 : 		{
; 4249 : 			//getStringToken(data, '|', 3, sizeof( FMType3 ) - 1, FMType3 );
; 4250 : 			BankmanInit(data );

  00279	56		 push	 esi
  0027a	e8 00 00 00 00	 call	 ?BankmanInit@@YAXPAD@Z	; BankmanInit
  0027f	83 c4 04	 add	 esp, 4
$LN13@lssproto_F:

; 4251 : 		}
; 4252 : 		if ( strcmp(FMType2,"I") ==0)
; 4253 : 		{
; 4254 : 			//getStringToken(data, '|', 3, sizeof( FMType3 ) - 1, FMType3 );
; 4255 : 			//ItemmanInit(data );
; 4256 : 			//initItemman(data );
; 4257 : 		}
; 4258 : 		if ( strcmp(FMType2,"T") ==0)

  00282	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01GAPBHFFA@T@
  00287	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _FMType2$[ebp]
  0028d	0f 1f 00	 npad	 3
$LL54@lssproto_F:
  00290	8a 10		 mov	 dl, BYTE PTR [eax]
  00292	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00294	75 1a		 jne	 SHORT $LN55@lssproto_F
  00296	84 d2		 test	 dl, dl
  00298	74 12		 je	 SHORT $LN56@lssproto_F
  0029a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0029d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  002a0	75 0e		 jne	 SHORT $LN55@lssproto_F
  002a2	83 c0 02	 add	 eax, 2
  002a5	83 c1 02	 add	 ecx, 2
  002a8	84 d2		 test	 dl, dl
  002aa	75 e4		 jne	 SHORT $LL54@lssproto_F
$LN56@lssproto_F:
  002ac	33 c0		 xor	 eax, eax
  002ae	eb 05		 jmp	 SHORT $LN57@lssproto_F
$LN55@lssproto_F:
  002b0	1b c0		 sbb	 eax, eax
  002b2	83 c8 01	 or	 eax, 1
$LN57@lssproto_F:
  002b5	85 c0		 test	 eax, eax
  002b7	0f 85 35 01 00
	00		 jne	 $LN20@lssproto_F

; 4259 : 		{
; 4260 : 			initFamilyTaxWN(data );

  002bd	56		 push	 esi
  002be	e8 00 00 00 00	 call	 ?initFamilyTaxWN@@YAXPAD@Z ; initFamilyTaxWN

; 4281 : 		}
; 4282 : 	}
; 4283 : 
; 4284 : }

  002c3	83 c4 04	 add	 esp, 4
  002c6	5e		 pop	 esi
  002c7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ca	33 cd		 xor	 ecx, ebp
  002cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d1	8b e5		 mov	 esp, ebp
  002d3	5d		 pop	 ebp
  002d4	c3		 ret	 0
$LN11@lssproto_F:

; 4261 : 		}
; 4262 : 
; 4263 : 
; 4264 : 	}
; 4265 : 	else if ( strcmp(FMType1,"R") ==0 )

  002d5	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01DGKLNCNG@R@
  002da	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _FMType1$[ebp]
$LL58@lssproto_F:
  002e0	8a 10		 mov	 dl, BYTE PTR [eax]
  002e2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  002e4	75 1a		 jne	 SHORT $LN59@lssproto_F
  002e6	84 d2		 test	 dl, dl
  002e8	74 12		 je	 SHORT $LN60@lssproto_F
  002ea	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  002ed	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  002f0	75 0e		 jne	 SHORT $LN59@lssproto_F
  002f2	83 c0 02	 add	 eax, 2
  002f5	83 c1 02	 add	 ecx, 2
  002f8	84 d2		 test	 dl, dl
  002fa	75 e4		 jne	 SHORT $LL58@lssproto_F
$LN60@lssproto_F:
  002fc	33 c0		 xor	 eax, eax
  002fe	eb 05		 jmp	 SHORT $LN61@lssproto_F
$LN59@lssproto_F:
  00300	1b c0		 sbb	 eax, eax
  00302	83 c8 01	 or	 eax, 1
$LN61@lssproto_F:
  00305	85 c0		 test	 eax, eax
  00307	75 71		 jne	 SHORT $LN16@lssproto_F

; 4266 : 	{
; 4267 : 		if ( strcmp(FMType2,"P") ==0) // ride Pet

  00309	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01EJNLAFE@P@
  0030e	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _FMType2$[ebp]
$LL62@lssproto_F:
  00314	8a 10		 mov	 dl, BYTE PTR [eax]
  00316	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00318	75 1a		 jne	 SHORT $LN63@lssproto_F
  0031a	84 d2		 test	 dl, dl
  0031c	74 12		 je	 SHORT $LN64@lssproto_F
  0031e	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00321	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00324	75 0e		 jne	 SHORT $LN63@lssproto_F
  00326	83 c0 02	 add	 eax, 2
  00329	83 c1 02	 add	 ecx, 2
  0032c	84 d2		 test	 dl, dl
  0032e	75 e4		 jne	 SHORT $LL62@lssproto_F
$LN64@lssproto_F:
  00330	33 c0		 xor	 eax, eax
  00332	eb 05		 jmp	 SHORT $LN65@lssproto_F
$LN63@lssproto_F:
  00334	1b c0		 sbb	 eax, eax
  00336	83 c8 01	 or	 eax, 1
$LN65@lssproto_F:
  00339	85 c0		 test	 eax, eax
  0033b	0f 85 b1 00 00
	00		 jne	 $LN20@lssproto_F

; 4268 : 		{
; 4269 : 			//initFamilyList(data );
; 4270 : 			getStringToken(data, '|', 3, sizeof( FMType3 ) - 1, FMType3 );

  00341	8d 85 fc f9 ff
	ff		 lea	 eax, DWORD PTR _FMType3$[ebp]
  00347	50		 push	 eax
  00348	68 ff 01 00 00	 push	 511			; 000001ffH
  0034d	6a 03		 push	 3
  0034f	6a 7c		 push	 124			; 0000007cH
  00351	56		 push	 esi
  00352	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 4271 : 			pc.ridePetNo = atoi( FMType3 );

  00357	8d 85 fc f9 ff
	ff		 lea	 eax, DWORD PTR _FMType3$[ebp]
  0035d	50		 push	 eax
  0035e	e8 00 00 00 00	 call	 _atoi
  00363	83 c4 18	 add	 esp, 24			; 00000018H
  00366	a3 18 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20760, eax
  0036b	5e		 pop	 esi

; 4281 : 		}
; 4282 : 	}
; 4283 : 
; 4284 : }

  0036c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0036f	33 cd		 xor	 ecx, ebp
  00371	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00376	8b e5		 mov	 esp, ebp
  00378	5d		 pop	 ebp
  00379	c3		 ret	 0
$LN16@lssproto_F:

; 4272 : 
; 4273 : 		}
; 4274 : 
; 4275 : 	}
; 4276 : 	else if ( strcmp(FMType1,"L") ==0 )	// æ—é•¿åŠŸèƒ½

  0037a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01OCOKONAJ@L@
  0037f	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _FMType1$[ebp]
$LL66@lssproto_F:
  00385	8a 10		 mov	 dl, BYTE PTR [eax]
  00387	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00389	75 1a		 jne	 SHORT $LN67@lssproto_F
  0038b	84 d2		 test	 dl, dl
  0038d	74 12		 je	 SHORT $LN68@lssproto_F
  0038f	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00392	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00395	75 0e		 jne	 SHORT $LN67@lssproto_F
  00397	83 c0 02	 add	 eax, 2
  0039a	83 c1 02	 add	 ecx, 2
  0039d	84 d2		 test	 dl, dl
  0039f	75 e4		 jne	 SHORT $LL66@lssproto_F
$LN68@lssproto_F:
  003a1	33 c0		 xor	 eax, eax
  003a3	eb 05		 jmp	 SHORT $LN69@lssproto_F
$LN67@lssproto_F:
  003a5	1b c0		 sbb	 eax, eax
  003a7	83 c8 01	 or	 eax, 1
$LN69@lssproto_F:
  003aa	85 c0		 test	 eax, eax
  003ac	75 44		 jne	 SHORT $LN20@lssproto_F

; 4277 : 	{
; 4278 : 		if ( strcmp(FMType2,"CHANGE") ==0)

  003ae	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_06BCPILJJG@CHANGE@
  003b3	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _FMType2$[ebp]
  003b9	0f 1f 80 00 00
	00 00		 npad	 7
$LL70@lssproto_F:
  003c0	8a 10		 mov	 dl, BYTE PTR [eax]
  003c2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  003c4	75 1a		 jne	 SHORT $LN71@lssproto_F
  003c6	84 d2		 test	 dl, dl
  003c8	74 12		 je	 SHORT $LN72@lssproto_F
  003ca	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  003cd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  003d0	75 0e		 jne	 SHORT $LN71@lssproto_F
  003d2	83 c0 02	 add	 eax, 2
  003d5	83 c1 02	 add	 ecx, 2
  003d8	84 d2		 test	 dl, dl
  003da	75 e4		 jne	 SHORT $LL70@lssproto_F
$LN72@lssproto_F:
  003dc	33 c0		 xor	 eax, eax
  003de	eb 05		 jmp	 SHORT $LN73@lssproto_F
$LN71@lssproto_F:
  003e0	1b c0		 sbb	 eax, eax
  003e2	83 c8 01	 or	 eax, 1
$LN73@lssproto_F:
  003e5	85 c0		 test	 eax, eax
  003e7	75 09		 jne	 SHORT $LN20@lssproto_F

; 4279 : 		{
; 4280 : 			initFamilyLeaderChange(data );

  003e9	56		 push	 esi
  003ea	e8 00 00 00 00	 call	 ?initFamilyLeaderChange@@YAXPAD@Z ; initFamilyLeaderChange

; 4281 : 		}
; 4282 : 	}
; 4283 : 
; 4284 : }

  003ef	83 c4 04	 add	 esp, 4
$LN20@lssproto_F:
  003f2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003f5	33 cd		 xor	 ecx, ebp
  003f7	5e		 pop	 esi
  003f8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003fd	8b e5		 mov	 esp, ebp
  003ff	5d		 pop	 ebp
  00400	c3		 ret	 0
?lssproto_FM_recv@@YAXHPAD@Z ENDP			; lssproto_FM_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_NU_recv@@YAXHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_AddCount$ = 12						; size = 4
?lssproto_NU_recv@@YAXHH@Z PROC				; lssproto_NU_recv, COMDAT

; 4151 : 	//JL 2016.11.13  90å·åŒ…ï¼Œèµ°è·¯æ­¥æ•°
; 4152 : 	return;
; 4153 : 
; 4154 : 
; 4155 : 	if ( AddCount < 0 )
; 4156 : 		SendCount += AddCount;
; 4157 : 	else
; 4158 : 		SendCount += AddCount;
; 4159 : }

  00000	c2 00 00	 ret	 0
?lssproto_NU_recv@@YAXHH@Z ENDP				; lssproto_NU_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_Echo_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_test$ = 12						; size = 4
?lssproto_Echo_recv@@YAXHPAD@Z PROC			; lssproto_Echo_recv, COMDAT

; 4136 : #if 1
; 4137 : #ifdef  _STONDEBUG__MSG
; 4138 : 
; 4139 : 	// ???îšº??îŽ•î™¾
; 4140 : 	time( &serverAliveLongTime );
; 4141 : 	serverAliveTime = localtime( &serverAliveLongTime );
; 4142 : 
; 4143 : #endif
; 4144 : #endif
; 4145 : }

  00000	c2 00 00	 ret	 0
?lssproto_Echo_recv@@YAXHPAD@Z ENDP			; lssproto_Echo_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_PlayerNumGet_recv@@YAXHHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_logincount$ = 12					; size = 4
_player$ = 16						; size = 4
?lssproto_PlayerNumGet_recv@@YAXHHH@Z PROC		; lssproto_PlayerNumGet_recv, COMDAT

; 4165 : }

  00000	c2 00 00	 ret	 0
?lssproto_PlayerNumGet_recv@@YAXHHH@Z ENDP		; lssproto_PlayerNumGet_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_ProcGet_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_ProcGet_recv@@YAXHPAD@Z PROC			; lssproto_ProcGet_recv, COMDAT

; 4170 : }

  00000	c2 00 00	 ret	 0
?lssproto_ProcGet_recv@@YAXHPAD@Z ENDP			; lssproto_ProcGet_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_CharLogout_recv@@YAXHPAD0@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_result$ = 12						; size = 4
_data$ = 16						; size = 4
?lssproto_CharLogout_recv@@YAXHPAD0@Z PROC		; lssproto_CharLogout_recv, COMDAT

; 853  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 854  : 	if (netproc_sending == NETPROC_SENDING)

  00003	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?netproc_sending@@3HA, 1 ; netproc_sending
  0000a	75 48		 jne	 SHORT $LN3@lssproto_C

; 855  : 	{
; 856  : 		netproc_sending = NETPROC_RECEIVED;
; 857  : 		if (strcmp(result, SUCCESSFULSTR) == 0)

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _result$[ebp]
  0000f	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0L@LHCHIOPJ@successful@
  00014	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 2 ; netproc_sending
  0001e	66 90		 npad	 2
$LL5@lssproto_C:
  00020	8a 11		 mov	 dl, BYTE PTR [ecx]
  00022	3a 10		 cmp	 dl, BYTE PTR [eax]
  00024	75 1a		 jne	 SHORT $LN6@lssproto_C
  00026	84 d2		 test	 dl, dl
  00028	74 12		 je	 SHORT $LN7@lssproto_C
  0002a	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0002d	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  00030	75 0e		 jne	 SHORT $LN6@lssproto_C
  00032	83 c1 02	 add	 ecx, 2
  00035	83 c0 02	 add	 eax, 2
  00038	84 d2		 test	 dl, dl
  0003a	75 e4		 jne	 SHORT $LL5@lssproto_C
$LN7@lssproto_C:
  0003c	33 c0		 xor	 eax, eax
  0003e	eb 05		 jmp	 SHORT $LN8@lssproto_C
$LN6@lssproto_C:
  00040	1b c0		 sbb	 eax, eax
  00042	83 c8 01	 or	 eax, 1
$LN8@lssproto_C:
  00045	85 c0		 test	 eax, eax
  00047	75 0b		 jne	 SHORT $LN3@lssproto_C

; 858  : 			charLogoutStatus = 1;

  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	66 a3 00 00 00
	00		 mov	 WORD PTR ?charLogoutStatus@@3FA, ax ; charLogoutStatus
$LN3@lssproto_C:

; 859  : 	}
; 860  : }

  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?lssproto_CharLogout_recv@@YAXHPAD0@Z ENDP		; lssproto_CharLogout_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_CharList_recv@@YAXHPAD0@Z
_TEXT	SEGMENT
_nm$1 = -2052						; size = 1024
_opt$2 = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_result$ = 12						; size = 4
_data$ = 16						; size = 4
?lssproto_CharList_recv@@YAXHPAD0@Z PROC		; lssproto_CharList_recv, COMDAT

; 696  : void lssproto_CharList_recv(int fd, char *result, char *data){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 08 00
	00		 sub	 esp, 2052		; 00000804H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 10	 mov	 esi, DWORD PTR _data$[ebp]

; 697  : 
; 698  : 	if(strcmp(result,"failed")==0) {

  00017	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_06ODACHPEO@failed@
  0001c	57		 push	 edi
  0001d	8b 7d 0c	 mov	 edi, DWORD PTR _result$[ebp]
  00020	8b c7		 mov	 eax, edi
$LL16@lssproto_C:
  00022	8a 10		 mov	 dl, BYTE PTR [eax]
  00024	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00026	75 1a		 jne	 SHORT $LN17@lssproto_C
  00028	84 d2		 test	 dl, dl
  0002a	74 12		 je	 SHORT $LN18@lssproto_C
  0002c	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002f	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00032	75 0e		 jne	 SHORT $LN17@lssproto_C
  00034	83 c0 02	 add	 eax, 2
  00037	83 c1 02	 add	 ecx, 2
  0003a	84 d2		 test	 dl, dl
  0003c	75 e4		 jne	 SHORT $LL16@lssproto_C
$LN18@lssproto_C:
  0003e	33 c0		 xor	 eax, eax
  00040	eb 05		 jmp	 SHORT $LN19@lssproto_C
$LN17@lssproto_C:
  00042	1b c0		 sbb	 eax, eax
  00044	83 c8 01	 or	 eax, 1
$LN19@lssproto_C:
  00047	85 c0		 test	 eax, eax
  00049	75 0f		 jne	 SHORT $LN5@lssproto_C

; 699  : #ifdef _NB_æ–­çº¿è‡ªåŠ¨é‡è¿ž
; 700  : 		PcLanded.ç™»é™†å»¶æ—¶æ—¶é—´ = TimeGetTime()+2000;

  0004b	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00050	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  00055	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax
$LN5@lssproto_C:

; 701  : #endif
; 702  : 	}
; 703  : 	if (netproc_sending == NETPROC_SENDING){

  0005a	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?netproc_sending@@3HA, 1 ; netproc_sending
  00061	0f 85 82 01 00
	00		 jne	 $LN3@lssproto_C

; 704  : 		char nm[1024], opt[1024];
; 705  : 		int i;
; 706  : 		netproc_sending = NETPROC_RECEIVED;

  00067	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 2 ; netproc_sending

; 707  : 		if (strcmp(result, SUCCESSFULSTR) != 0){

  00071	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0L@LHCHIOPJ@successful@
$LL20@lssproto_C:
  00076	8a 0f		 mov	 cl, BYTE PTR [edi]
  00078	3a 08		 cmp	 cl, BYTE PTR [eax]
  0007a	75 1a		 jne	 SHORT $LN21@lssproto_C
  0007c	84 c9		 test	 cl, cl
  0007e	74 12		 je	 SHORT $LN22@lssproto_C
  00080	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00083	3a 48 01	 cmp	 cl, BYTE PTR [eax+1]
  00086	75 0e		 jne	 SHORT $LN21@lssproto_C
  00088	83 c7 02	 add	 edi, 2
  0008b	83 c0 02	 add	 eax, 2
  0008e	84 c9		 test	 cl, cl
  00090	75 e4		 jne	 SHORT $LL20@lssproto_C
$LN22@lssproto_C:
  00092	33 c0		 xor	 eax, eax
  00094	eb 05		 jmp	 SHORT $LN23@lssproto_C
$LN21@lssproto_C:
  00096	1b c0		 sbb	 eax, eax
  00098	83 c8 01	 or	 eax, 1
$LN23@lssproto_C:
  0009b	85 c0		 test	 eax, eax
  0009d	0f 84 d5 00 00
	00		 je	 $LN7@lssproto_C

; 708  : 			if (strcmp(data, "OUTOFSERVICE") == 0)

  000a3	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0N@OGLBPKPL@OUTOFSERVICE@
  000a8	8b c6		 mov	 eax, esi
  000aa	66 0f 1f 44 00
	00		 npad	 6
$LL24@lssproto_C:
  000b0	8a 10		 mov	 dl, BYTE PTR [eax]
  000b2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000b4	75 1a		 jne	 SHORT $LN25@lssproto_C
  000b6	84 d2		 test	 dl, dl
  000b8	74 12		 je	 SHORT $LN26@lssproto_C
  000ba	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000bd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000c0	75 0e		 jne	 SHORT $LN25@lssproto_C
  000c2	83 c0 02	 add	 eax, 2
  000c5	83 c1 02	 add	 ecx, 2
  000c8	84 d2		 test	 dl, dl
  000ca	75 e4		 jne	 SHORT $LL24@lssproto_C
$LN26@lssproto_C:
  000cc	33 c0		 xor	 eax, eax
  000ce	eb 05		 jmp	 SHORT $LN27@lssproto_C
$LN25@lssproto_C:
  000d0	1b c0		 sbb	 eax, eax
  000d2	83 c8 01	 or	 eax, 1
$LN27@lssproto_C:
  000d5	85 c0		 test	 eax, eax
  000d7	75 0b		 jne	 SHORT $LN8@lssproto_C

; 709  : 				charListStatus = 2;

  000d9	b8 02 00 00 00	 mov	 eax, 2
  000de	66 a3 00 00 00
	00		 mov	 WORD PTR ?charListStatus@@3FA, ax ; charListStatus
$LN8@lssproto_C:

; 710  : #ifdef _CHANGEGALAXY
; 711  : 			if (strcmp(data, "CHANGE_GALAXY") == 0)

  000e4	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0O@ENFKOFGC@CHANGE_GALAXY@
  000e9	8b c6		 mov	 eax, esi
  000eb	0f 1f 44 00 00	 npad	 5
$LL28@lssproto_C:
  000f0	8a 10		 mov	 dl, BYTE PTR [eax]
  000f2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000f4	75 1a		 jne	 SHORT $LN29@lssproto_C
  000f6	84 d2		 test	 dl, dl
  000f8	74 12		 je	 SHORT $LN30@lssproto_C
  000fa	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000fd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00100	75 0e		 jne	 SHORT $LN29@lssproto_C
  00102	83 c0 02	 add	 eax, 2
  00105	83 c1 02	 add	 ecx, 2
  00108	84 d2		 test	 dl, dl
  0010a	75 e4		 jne	 SHORT $LL28@lssproto_C
$LN30@lssproto_C:
  0010c	33 c0		 xor	 eax, eax
  0010e	eb 05		 jmp	 SHORT $LN31@lssproto_C
$LN29@lssproto_C:
  00110	1b c0		 sbb	 eax, eax
  00112	83 c8 01	 or	 eax, 1
$LN31@lssproto_C:
  00115	85 c0		 test	 eax, eax
  00117	75 0b		 jne	 SHORT $LN9@lssproto_C

; 712  : 				charListStatus = 3;

  00119	b8 03 00 00 00	 mov	 eax, 3
  0011e	66 a3 00 00 00
	00		 mov	 WORD PTR ?charListStatus@@3FA, ax ; charListStatus
$LN9@lssproto_C:

; 713  : #endif
; 714  : #ifdef _ERROR301
; 715  : 			if (strcmp(data, "301") == 0)

  00124	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03NOBDJFIO@301@
  00129	0f 1f 80 00 00
	00 00		 npad	 7
$LL32@lssproto_C:
  00130	8a 0e		 mov	 cl, BYTE PTR [esi]
  00132	3a 08		 cmp	 cl, BYTE PTR [eax]
  00134	75 1a		 jne	 SHORT $LN33@lssproto_C
  00136	84 c9		 test	 cl, cl
  00138	74 12		 je	 SHORT $LN34@lssproto_C
  0013a	8a 4e 01	 mov	 cl, BYTE PTR [esi+1]
  0013d	3a 48 01	 cmp	 cl, BYTE PTR [eax+1]
  00140	75 0e		 jne	 SHORT $LN33@lssproto_C
  00142	83 c6 02	 add	 esi, 2
  00145	83 c0 02	 add	 eax, 2
  00148	84 c9		 test	 cl, cl
  0014a	75 e4		 jne	 SHORT $LL32@lssproto_C
$LN34@lssproto_C:
  0014c	33 c0		 xor	 eax, eax
  0014e	eb 05		 jmp	 SHORT $LN35@lssproto_C
$LN33@lssproto_C:
  00150	1b c0		 sbb	 eax, eax
  00152	83 c8 01	 or	 eax, 1
$LN35@lssproto_C:
  00155	85 c0		 test	 eax, eax
  00157	0f 85 8c 00 00
	00		 jne	 $LN3@lssproto_C

; 716  : 				charListStatus = 4;

  0015d	b8 04 00 00 00	 mov	 eax, 4
  00162	5f		 pop	 edi
  00163	66 a3 00 00 00
	00		 mov	 WORD PTR ?charListStatus@@3FA, ax ; charListStatus

; 727  : 		}
; 728  : 	}
; 729  : }

  00169	5e		 pop	 esi
  0016a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016d	33 cd		 xor	 ecx, ebp
  0016f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00174	8b e5		 mov	 esp, ebp
  00176	5d		 pop	 ebp
  00177	c3		 ret	 0
$LN7@lssproto_C:

; 717  : #endif
; 718  : 			return;
; 719  : 		}
; 720  : 		charListStatus = 1;

  00178	b8 01 00 00 00	 mov	 eax, 1
  0017d	66 a3 00 00 00
	00		 mov	 WORD PTR ?charListStatus@@3FA, ax ; charListStatus
  00183	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  00186	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@lssproto_C:

; 721  : 		for (i = 0; i < MAXCHARACTER; i++){
; 722  : 			strcpy(nm, "");
; 723  : 			strcpy(opt, "");
; 724  : 			getStringToken(data, '|', i * 2 + 1, sizeof(nm) - 1 , nm);

  00190	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _nm$1[ebp]
  00196	c6 85 fc f7 ff
	ff 00		 mov	 BYTE PTR _nm$1[ebp], 0
  0019d	50		 push	 eax
  0019e	68 ff 03 00 00	 push	 1023			; 000003ffH
  001a3	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  001a6	c6 85 fc fb ff
	ff 00		 mov	 BYTE PTR _opt$2[ebp], 0
  001ad	50		 push	 eax
  001ae	6a 7c		 push	 124			; 0000007cH
  001b0	56		 push	 esi
  001b1	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 725  : 			getStringToken(data, '|', i * 2 + 2, sizeof(opt) - 1, opt);

  001b6	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _opt$2[ebp]
  001bc	50		 push	 eax
  001bd	68 ff 03 00 00	 push	 1023			; 000003ffH
  001c2	57		 push	 edi
  001c3	6a 7c		 push	 124			; 0000007cH
  001c5	56		 push	 esi
  001c6	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 726  : 			setCharacterList(nm, opt);

  001cb	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _opt$2[ebp]
  001d1	50		 push	 eax
  001d2	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _nm$1[ebp]
  001d8	50		 push	 eax
  001d9	e8 00 00 00 00	 call	 ?setCharacterList@@YAHPAD0@Z ; setCharacterList
  001de	83 c7 02	 add	 edi, 2
  001e1	83 c4 30	 add	 esp, 48			; 00000030H
  001e4	83 ff 06	 cmp	 edi, 6
  001e7	7c a7		 jl	 SHORT $LL4@lssproto_C
$LN3@lssproto_C:

; 727  : 		}
; 728  : 	}
; 729  : }

  001e9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ec	5f		 pop	 edi
  001ed	33 cd		 xor	 ecx, ebp
  001ef	5e		 pop	 esi
  001f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f5	8b e5		 mov	 esp, ebp
  001f7	5d		 pop	 ebp
  001f8	c3		 ret	 0
?lssproto_CharList_recv@@YAXHPAD0@Z ENDP		; lssproto_CharList_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_CharLogin_recv@@YAXHPAD0@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_result$ = 12						; size = 4
_data$ = 16						; size = 4
?lssproto_CharLogin_recv@@YAXHPAD0@Z PROC		; lssproto_CharLogin_recv, COMDAT

; 801  : void lssproto_CharLogin_recv(int fd, char* result, char* data){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 	if (netproc_sending == NETPROC_SENDING){

  00003	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?netproc_sending@@3HA, 1 ; netproc_sending
  0000a	0f 85 c7 00 00
	00		 jne	 $LN2@lssproto_C

; 803  : 		netproc_sending = NETPROC_RECEIVED;

  00010	56		 push	 esi

; 804  : #ifdef __NEW_CLIENT
; 805  : 		if (strcmp(result, SUCCESSFULSTR) == 0 && !hPing)

  00011	8b 75 0c	 mov	 esi, DWORD PTR _result$[ebp]
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@LHCHIOPJ@successful@
  00019	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 2 ; netproc_sending
  00023	8b c6		 mov	 eax, esi
$LL6@lssproto_C:
  00025	8a 10		 mov	 dl, BYTE PTR [eax]
  00027	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00029	75 1a		 jne	 SHORT $LN7@lssproto_C
  0002b	84 d2		 test	 dl, dl
  0002d	74 12		 je	 SHORT $LN8@lssproto_C
  0002f	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00032	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00035	75 0e		 jne	 SHORT $LN7@lssproto_C
  00037	83 c0 02	 add	 eax, 2
  0003a	83 c1 02	 add	 ecx, 2
  0003d	84 d2		 test	 dl, dl
  0003f	75 e4		 jne	 SHORT $LL6@lssproto_C
$LN8@lssproto_C:
  00041	33 c0		 xor	 eax, eax
  00043	eb 05		 jmp	 SHORT $LN9@lssproto_C
$LN7@lssproto_C:
  00045	1b c0		 sbb	 eax, eax
  00047	83 c8 01	 or	 eax, 1
$LN9@lssproto_C:
  0004a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hPing@@3PAXA ; hPing
  00050	85 c0		 test	 eax, eax
  00052	75 2f		 jne	 SHORT $LN3@lssproto_C
  00054	85 d2		 test	 edx, edx
  00056	75 2b		 jne	 SHORT $LN3@lssproto_C

; 806  : #else
; 807  : 		if (strcmp(result, SUCCESSFULSTR) == 0)
; 808  : #endif
; 809  : 		{
; 810  : 			charLoginStatus = 1;
; 811  : #ifdef __NEW_CLIENT
; 812  : 			hPing = CreateThread(NULL, 0, PingFunc, &sin_server.sin_addr, 0, &dwPingID);

  00058	68 00 00 00 00	 push	 OFFSET ?dwPingID@@3KA	; dwPingID
  0005d	52		 push	 edx
  0005e	68 04 00 00 00	 push	 OFFSET ?sin_server@@3Usockaddr_in@@A+4
  00063	68 00 00 00 00	 push	 OFFSET ?PingFunc@@YGKPAX@Z ; PingFunc
  00068	52		 push	 edx
  00069	b8 01 00 00 00	 mov	 eax, 1
  0006e	52		 push	 edx
  0006f	66 a3 00 00 00
	00		 mov	 WORD PTR ?charLoginStatus@@3FA, ax ; charLoginStatus
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateThread@24
  0007b	8b d0		 mov	 edx, eax
  0007d	89 15 00 00 00
	00		 mov	 DWORD PTR ?hPing@@3PAXA, edx ; hPing
$LN3@lssproto_C:

; 813  : #endif
; 814  : 		}
; 815  : 
; 816  : #ifdef _NEW_WGS_MSG				// WON ADD WGSçš„æ–°è§†çª—
; 817  : 		if (strcmp(result, "failed" ) == 0 && !hPing)

  00083	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06ODACHPEO@failed@
$LL10@lssproto_C:
  00088	8a 0e		 mov	 cl, BYTE PTR [esi]
  0008a	3a 08		 cmp	 cl, BYTE PTR [eax]
  0008c	75 1a		 jne	 SHORT $LN11@lssproto_C
  0008e	84 c9		 test	 cl, cl
  00090	74 12		 je	 SHORT $LN12@lssproto_C
  00092	8a 4e 01	 mov	 cl, BYTE PTR [esi+1]
  00095	3a 48 01	 cmp	 cl, BYTE PTR [eax+1]
  00098	75 0e		 jne	 SHORT $LN11@lssproto_C
  0009a	83 c6 02	 add	 esi, 2
  0009d	83 c0 02	 add	 eax, 2
  000a0	84 c9		 test	 cl, cl
  000a2	75 e4		 jne	 SHORT $LL10@lssproto_C
$LN12@lssproto_C:
  000a4	33 c0		 xor	 eax, eax
  000a6	eb 05		 jmp	 SHORT $LN13@lssproto_C
$LN11@lssproto_C:
  000a8	1b c0		 sbb	 eax, eax
  000aa	83 c8 01	 or	 eax, 1
$LN13@lssproto_C:
  000ad	5e		 pop	 esi
  000ae	85 c0		 test	 eax, eax
  000b0	75 14		 jne	 SHORT $LN4@lssproto_C
  000b2	85 d2		 test	 edx, edx
  000b4	75 10		 jne	 SHORT $LN4@lssproto_C

; 818  : 			ERROR_MESSAGE = atoi(data);

  000b6	ff 75 10	 push	 DWORD PTR _data$[ebp]
  000b9	e8 00 00 00 00	 call	 _atoi
  000be	83 c4 04	 add	 esp, 4
  000c1	a3 00 00 00 00	 mov	 DWORD PTR ?ERROR_MESSAGE@@3HA, eax ; ERROR_MESSAGE
$LN4@lssproto_C:

; 819  : #endif
; 820  : 
; 821  : #ifdef _ANGEL_SUMMON
; 822  : 		angelFlag = FALSE;

  000c6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?angelFlag@@3HA, 0 ; angelFlag

; 823  : 		angelMsg[0] = NULL;

  000d0	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?angelMsg@@3PADA, 0
$LN2@lssproto_C:

; 824  : #endif
; 825  : 	}
; 826  : }

  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
?lssproto_CharLogin_recv@@YAXHPAD0@Z ENDP		; lssproto_CharLogin_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_CharDelete_recv@@YAXHPAD0@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_result$ = 12						; size = 4
_data$ = 16						; size = 4
?lssproto_CharDelete_recv@@YAXHPAD0@Z PROC		; lssproto_CharDelete_recv, COMDAT

; 3178 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3179 : 	if ( netproc_sending == NETPROC_SENDING )

  00003	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?netproc_sending@@3HA, 1 ; netproc_sending
  0000a	75 48		 jne	 SHORT $LN3@lssproto_C

; 3180 : 	{
; 3181 : 		netproc_sending = NETPROC_RECEIVED;
; 3182 : 		if ( strcmp( result, SUCCESSFULSTR ) == 0 )

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _result$[ebp]
  0000f	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0L@LHCHIOPJ@successful@
  00014	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 2 ; netproc_sending
  0001e	66 90		 npad	 2
$LL5@lssproto_C:
  00020	8a 11		 mov	 dl, BYTE PTR [ecx]
  00022	3a 10		 cmp	 dl, BYTE PTR [eax]
  00024	75 1a		 jne	 SHORT $LN6@lssproto_C
  00026	84 d2		 test	 dl, dl
  00028	74 12		 je	 SHORT $LN7@lssproto_C
  0002a	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0002d	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  00030	75 0e		 jne	 SHORT $LN6@lssproto_C
  00032	83 c1 02	 add	 ecx, 2
  00035	83 c0 02	 add	 eax, 2
  00038	84 d2		 test	 dl, dl
  0003a	75 e4		 jne	 SHORT $LL5@lssproto_C
$LN7@lssproto_C:
  0003c	33 c0		 xor	 eax, eax
  0003e	eb 05		 jmp	 SHORT $LN8@lssproto_C
$LN6@lssproto_C:
  00040	1b c0		 sbb	 eax, eax
  00042	83 c8 01	 or	 eax, 1
$LN8@lssproto_C:
  00045	85 c0		 test	 eax, eax
  00047	75 0b		 jne	 SHORT $LN3@lssproto_C

; 3183 : 		{
; 3184 : 			charDelStatus = 1;

  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	66 a3 00 00 00
	00		 mov	 WORD PTR ?charDelStatus@@3FA, ax ; charDelStatus
$LN3@lssproto_C:

; 3185 :     	}
; 3186 :     }
; 3187 : }

  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?lssproto_CharDelete_recv@@YAXHPAD0@Z ENDP		; lssproto_CharDelete_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_CreateNewChar_recv@@YAXHPAD0@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_result$ = 12						; size = 4
_data$ = 16						; size = 4
?lssproto_CreateNewChar_recv@@YAXHPAD0@Z PROC		; lssproto_CreateNewChar_recv, COMDAT

; 3119 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3120 : 	if ( netproc_sending == NETPROC_SENDING )

  00003	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?netproc_sending@@3HA, 1 ; netproc_sending
  0000a	75 48		 jne	 SHORT $LN3@lssproto_C

; 3121 : 	{
; 3122 : 		netproc_sending = NETPROC_RECEIVED;
; 3123 : 
; 3124 : 		if ( strcmp( result, SUCCESSFULSTR ) == 0 )

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _result$[ebp]
  0000f	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0L@LHCHIOPJ@successful@
  00014	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 2 ; netproc_sending
  0001e	66 90		 npad	 2
$LL5@lssproto_C:
  00020	8a 11		 mov	 dl, BYTE PTR [ecx]
  00022	3a 10		 cmp	 dl, BYTE PTR [eax]
  00024	75 1a		 jne	 SHORT $LN6@lssproto_C
  00026	84 d2		 test	 dl, dl
  00028	74 12		 je	 SHORT $LN7@lssproto_C
  0002a	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0002d	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  00030	75 0e		 jne	 SHORT $LN6@lssproto_C
  00032	83 c1 02	 add	 ecx, 2
  00035	83 c0 02	 add	 eax, 2
  00038	84 d2		 test	 dl, dl
  0003a	75 e4		 jne	 SHORT $LL5@lssproto_C
$LN7@lssproto_C:
  0003c	33 c0		 xor	 eax, eax
  0003e	eb 05		 jmp	 SHORT $LN8@lssproto_C
$LN6@lssproto_C:
  00040	1b c0		 sbb	 eax, eax
  00042	83 c8 01	 or	 eax, 1
$LN8@lssproto_C:
  00045	85 c0		 test	 eax, eax
  00047	75 0b		 jne	 SHORT $LN3@lssproto_C

; 3125 : 		{
; 3126 : 			newCharStatus = 1;

  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	66 a3 00 00 00
	00		 mov	 WORD PTR ?newCharStatus@@3FA, ax ; newCharStatus
$LN3@lssproto_C:

; 3127 : 		}
; 3128 :     }
; 3129 : }

  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?lssproto_CreateNewChar_recv@@YAXHPAD0@Z ENDP		; lssproto_CreateNewChar_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\time.h
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\time.h
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_ClientLogin_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_result$ = 12						; size = 4
?lssproto_ClientLogin_recv@@YAXHPAD@Z PROC		; lssproto_ClientLogin_recv, COMDAT

; 638  : void lssproto_ClientLogin_recv(int fd, char *result){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 639  : 	if (netproc_sending == NETPROC_SENDING){

  00003	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?netproc_sending@@3HA, 1 ; netproc_sending
  0000a	0f 85 d6 00 00
	00		 jne	 $LN6@lssproto_C

; 640  : 		netproc_sending = NETPROC_RECEIVED;	

  00010	56		 push	 esi

; 641  : 		if (strcmp(result, OKSTR) == 0){

  00011	8b 75 0c	 mov	 esi, DWORD PTR _result$[ebp]
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_02MFDMBIJM@ok@
  00019	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 2 ; netproc_sending
  00023	8b c6		 mov	 eax, esi
$LL12@lssproto_C:
  00025	8a 10		 mov	 dl, BYTE PTR [eax]
  00027	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00029	75 1a		 jne	 SHORT $LN13@lssproto_C
  0002b	84 d2		 test	 dl, dl
  0002d	74 12		 je	 SHORT $LN14@lssproto_C
  0002f	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00032	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00035	75 0e		 jne	 SHORT $LN13@lssproto_C
  00037	83 c0 02	 add	 eax, 2
  0003a	83 c1 02	 add	 ecx, 2
  0003d	84 d2		 test	 dl, dl
  0003f	75 e4		 jne	 SHORT $LL12@lssproto_C
$LN14@lssproto_C:
  00041	33 c0		 xor	 eax, eax
  00043	eb 05		 jmp	 SHORT $LN15@lssproto_C
$LN13@lssproto_C:
  00045	1b c0		 sbb	 eax, eax
  00047	83 c8 01	 or	 eax, 1
$LN15@lssproto_C:
  0004a	85 c0		 test	 eax, eax
  0004c	75 2a		 jne	 SHORT $LN3@lssproto_C

; 642  : 			clientLoginStatus = 1;

  0004e	b8 01 00 00 00	 mov	 eax, 1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\time.h

; 522  :             return _time64(_Time);

  00053	68 00 00 00 00	 push	 OFFSET ?serverAliveLongTime@@3_JA ; serverAliveLongTime
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp

; 642  : 			clientLoginStatus = 1;

  00058	66 a3 00 00 00
	00		 mov	 WORD PTR ?clientLoginStatus@@3FA, ax ; clientLoginStatus
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\time.h

; 522  :             return _time64(_Time);

  0005e	e8 00 00 00 00	 call	 __time64

; 499  :             return _localtime64(_Time);

  00063	68 00 00 00 00	 push	 OFFSET ?serverAliveLongTime@@3_JA ; serverAliveLongTime
  00068	e8 00 00 00 00	 call	 __localtime64
  0006d	83 c4 08	 add	 esp, 8
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp

; 644  : 			serverAliveTime = localtime(&serverAliveLongTime);

  00070	a3 00 00 00 00	 mov	 DWORD PTR ?serverAliveTime@@3PAUtm@@A, eax ; serverAliveTime
  00075	5e		 pop	 esi

; 655  : #endif
; 656  : 		}
; 657  : 	}
; 658  : }

  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
$LN3@lssproto_C:

; 645  : 
; 646  : 		}else if(strcmp (result, CANCLE) == 0){

  00078	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06ENLDJGGB@cancle@
  0007d	8b ce		 mov	 ecx, esi
  0007f	90		 npad	 1
$LL16@lssproto_C:
  00080	8a 11		 mov	 dl, BYTE PTR [ecx]
  00082	3a 10		 cmp	 dl, BYTE PTR [eax]
  00084	75 1a		 jne	 SHORT $LN17@lssproto_C
  00086	84 d2		 test	 dl, dl
  00088	74 12		 je	 SHORT $LN18@lssproto_C
  0008a	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0008d	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  00090	75 0e		 jne	 SHORT $LN17@lssproto_C
  00092	83 c1 02	 add	 ecx, 2
  00095	83 c0 02	 add	 eax, 2
  00098	84 d2		 test	 dl, dl
  0009a	75 e4		 jne	 SHORT $LL16@lssproto_C
$LN18@lssproto_C:
  0009c	33 c0		 xor	 eax, eax
  0009e	eb 05		 jmp	 SHORT $LN19@lssproto_C
$LN17@lssproto_C:
  000a0	1b c0		 sbb	 eax, eax
  000a2	83 c8 01	 or	 eax, 1
$LN19@lssproto_C:
  000a5	85 c0		 test	 eax, eax
  000a7	75 29		 jne	 SHORT $LN5@lssproto_C

; 647  : 			cleanupNetwork();

  000a9	e8 00 00 00 00	 call	 ?cleanupNetwork@@YAXXZ	; cleanupNetwork

; 648  : 			PaletteChange(DEF_PAL, 0);

  000ae	6a 00		 push	 0
  000b0	6a 00		 push	 0
  000b2	e8 00 00 00 00	 call	 ?PaletteChange@@YAXHH@Z	; PaletteChange

; 649  : 			ChangeProc( PROC_ID_PASSWORD );

  000b7	6a 01		 push	 1
  000b9	e8 00 00 00 00	 call	 ?ChangeProc@@YAXH@Z	; ChangeProc
  000be	83 c4 0c	 add	 esp, 12			; 0000000cH

; 650  : 			SubProcNo = 5;

  000c1	c7 05 00 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?SubProcNo@@3IA, 5 ; SubProcNo
  000cb	5e		 pop	 esi

; 655  : #endif
; 656  : 		}
; 657  : 	}
; 658  : }

  000cc	5d		 pop	 ebp

; 651  : 			DeathAllAction();

  000cd	e9 00 00 00 00	 jmp	 ?DeathAllAction@@YAXXZ	; DeathAllAction
$LN5@lssproto_C:

; 652  : 		}else{
; 653  : #ifdef _NB_ç™»å½•é”™è¯¯ä¿¡æ¯æç¤º
; 654  : 			sprintf(ç™»å½•é”™è¯¯æç¤º, "%s", result);

  000d2	56		 push	 esi
  000d3	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000d8	68 00 00 00 00	 push	 OFFSET ?Ôô???ð«ãÆ@@3PADA ; Ôô???ð«ãÆ
  000dd	e8 00 00 00 00	 call	 _sprintf
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e5	5e		 pop	 esi
$LN6@lssproto_C:

; 655  : #endif
; 656  : 		}
; 657  : 	}
; 658  : }

  000e6	5d		 pop	 ebp
  000e7	c3		 ret	 0
?lssproto_ClientLogin_recv@@YAXHPAD@Z ENDP		; lssproto_ClientLogin_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_SE_recv@@YAXHHHHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_senumber$ = 20						; size = 4
_sw$ = 24						; size = 4
?lssproto_SE_recv@@YAXHHHHH@Z PROC			; lssproto_SE_recv, COMDAT

; 4078 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4079 : 	// ????????????????îºîŸ«?î¡Š???
; 4080 : 	if ( logOutFlag )

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  0000a	75 17		 jne	 SHORT $LN3@lssproto_S

; 4081 : 		return;
; 4082 : 
; 4083 : 	if ( sw )

  0000c	83 7d 18 00	 cmp	 DWORD PTR _sw$[ebp], 0
  00010	74 11		 je	 SHORT $LN3@lssproto_S

; 4084 : 	{
; 4085 : 		play_se( senumber, x, y );

  00012	ff 75 10	 push	 DWORD PTR _y$[ebp]
  00015	ff 75 0c	 push	 DWORD PTR _x$[ebp]
  00018	ff 75 14	 push	 DWORD PTR _senumber$[ebp]
  0001b	e8 00 00 00 00	 call	 ?play_se@@YAHHHH@Z	; play_se
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@lssproto_S:

; 4086 : 	}
; 4087 : 	else
; 4088 : 	{
; 4089 : 		// ??î??î§????î–Ÿ????
; 4090 : 	}
; 4091 : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?lssproto_SE_recv@@YAXHHHHH@Z ENDP			; lssproto_SE_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_EF_recv@@YAXHHHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_effect$ = 12						; size = 4
_level$ = 16						; size = 4
_option$ = 20						; size = 4
?lssproto_EF_recv@@YAXHHHPAD@Z PROC			; lssproto_EF_recv, COMDAT

; 3739 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3740 : 	// î“»????????î??
; 3741 : 	if ( effect == 0 )

  00003	8b 55 0c	 mov	 edx, DWORD PTR _effect$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	75 24		 jne	 SHORT $LN2@lssproto_E

; 3742 : 	{
; 3743 : 		mapEffectRainLevel = 0;

  0000a	33 c0		 xor	 eax, eax

; 3744 : 		mapEffectSnowLevel = 0;
; 3745 : 		mapEffectKamiFubukiLevel = 0;
; 3746 : #ifdef _HALLOWEEN_EFFECT
; 3747 : 		mapEffectHalloween = 0;
; 3748 : 		initMapEffect(FALSE);

  0000c	50		 push	 eax
  0000d	66 a3 00 00 00
	00		 mov	 WORD PTR ?mapEffectRainLevel@@3FA, ax ; mapEffectRainLevel
  00013	66 a3 00 00 00
	00		 mov	 WORD PTR ?mapEffectSnowLevel@@3FA, ax ; mapEffectSnowLevel
  00019	66 a3 00 00 00
	00		 mov	 WORD PTR ?mapEffectKamiFubukiLevel@@3FA, ax ; mapEffectKamiFubukiLevel
  0001f	a3 00 00 00 00	 mov	 DWORD PTR ?mapEffectHalloween@@3HA, eax ; mapEffectHalloween
  00024	e8 00 00 00 00	 call	 ?initMapEffect@@YAXH@Z	; initMapEffect
  00029	83 c4 04	 add	 esp, 4

; 3769 : #endif
; 3770 : // Terry add 2002/01/14
; 3771 : #ifdef __EDEN_DICE
; 3772 : 	// éª°å­
; 3773 : 	if (effect == 10) 
; 3774 : 	{
; 3775 : 		pCommand = (char*)MALLOC(strlen(option)+1);
; 3776 : #ifdef  _STONDEBUG_
; 3777 : 		g_iMallocCount++;
; 3778 : #endif
; 3779 : 		if (pCommand != NULL) 
; 3780 : 		{
; 3781 : 			strcpy(pCommand,option);
; 3782 : 			bMapEffectDice = TRUE;
; 3783 : 			dwDiceTimer = TimeGetTime();
; 3784 : 		}
; 3785 : 	}
; 3786 : #endif
; 3787 : // Terry end
; 3788 : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
$LN2@lssproto_E:
  0002e	56		 push	 esi

; 3749 : #endif
; 3750 : 		return;
; 3751 : 	}
; 3752 : 	// ???????
; 3753 : 	if ( effect & 1 )

  0002f	8b 75 10	 mov	 esi, DWORD PTR _level$[ebp]
  00032	57		 push	 edi
  00033	f6 c2 01	 test	 dl, 1
  00036	74 0d		 je	 SHORT $LN8@lssproto_E

; 3754 : 	{
; 3755 : 		mapEffectRainLevel = level;

  00038	0f b7 c6	 movzx	 eax, si
  0003b	66 a3 00 00 00
	00		 mov	 WORD PTR ?mapEffectRainLevel@@3FA, ax ; mapEffectRainLevel
  00041	8b f8		 mov	 edi, eax
  00043	eb 03		 jmp	 SHORT $LN3@lssproto_E
$LN8@lssproto_E:
  00045	0f b7 fe	 movzx	 edi, si
$LN3@lssproto_E:

; 3756 : 	}
; 3757 : 	// î“Š??????
; 3758 : 	if ( effect & 2 )

  00048	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?mapEffectSnowLevel@@3FA ; mapEffectSnowLevel
  0004f	f6 c2 02	 test	 dl, 2
  00052	0f b7 c7	 movzx	 eax, di
  00055	0f 45 c8	 cmovne	 ecx, eax

; 3759 : 	{
; 3760 : 		mapEffectSnowLevel = level;
; 3761 : 	}
; 3762 : 	// ????
; 3763 : 	if ( effect & 4 )

  00058	f6 c2 04	 test	 dl, 4
  0005b	66 89 0d 00 00
	00 00		 mov	 WORD PTR ?mapEffectSnowLevel@@3FA, cx ; mapEffectSnowLevel
  00062	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?mapEffectKamiFubukiLevel@@3FA ; mapEffectKamiFubukiLevel
  00069	0f b7 c7	 movzx	 eax, di
  0006c	0f 45 c8	 cmovne	 ecx, eax

; 3764 : 	{
; 3765 : 		mapEffectKamiFubukiLevel = level;
; 3766 : 	}
; 3767 : #ifdef _HALLOWEEN_EFFECT
; 3768 : 	if (effect & 8) mapEffectHalloween = level;

  0006f	f6 c2 08	 test	 dl, 8
  00072	a1 00 00 00 00	 mov	 eax, DWORD PTR ?mapEffectHalloween@@3HA ; mapEffectHalloween
  00077	0f 45 c6	 cmovne	 eax, esi
  0007a	66 89 0d 00 00
	00 00		 mov	 WORD PTR ?mapEffectKamiFubukiLevel@@3FA, cx ; mapEffectKamiFubukiLevel
  00081	5f		 pop	 edi
  00082	a3 00 00 00 00	 mov	 DWORD PTR ?mapEffectHalloween@@3HA, eax ; mapEffectHalloween
  00087	5e		 pop	 esi

; 3769 : #endif
; 3770 : // Terry add 2002/01/14
; 3771 : #ifdef __EDEN_DICE
; 3772 : 	// éª°å­
; 3773 : 	if (effect == 10) 
; 3774 : 	{
; 3775 : 		pCommand = (char*)MALLOC(strlen(option)+1);
; 3776 : #ifdef  _STONDEBUG_
; 3777 : 		g_iMallocCount++;
; 3778 : #endif
; 3779 : 		if (pCommand != NULL) 
; 3780 : 		{
; 3781 : 			strcpy(pCommand,option);
; 3782 : 			bMapEffectDice = TRUE;
; 3783 : 			dwDiceTimer = TimeGetTime();
; 3784 : 		}
; 3785 : 	}
; 3786 : #endif
; 3787 : // Terry end
; 3788 : }

  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
?lssproto_EF_recv@@YAXHHHPAD@Z ENDP			; lssproto_EF_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_WN_recv@@YAXHHHHHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_windowtype$ = 12					; size = 4
_buttontype$ = 16					; size = 4
_seqno$ = 20						; size = 4
_objindex$ = 24						; size = 4
_data$ = 28						; size = 4
?lssproto_WN_recv@@YAXHHHHHPAD@Z PROC			; lssproto_WN_recv, COMDAT

; 3632 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3633 : 	// ????????????????îºîŸ«?î¡Š???
; 3634 : 	if ( logOutFlag )

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  0000a	75 47		 jne	 SHORT $LN1@lssproto_W
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h

; 520  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@NFKFNKL@?$NM?z?$DP?J?$KL?p?i?n?$KE?v?R?t?$LI?q?$PN?$PN?$KI?$DP?a?$LM?c?w?$DP?$KD?$KB@
  00011	ff 75 1c	 push	 DWORD PTR _data$[ebp]
  00014	e8 00 00 00 00	 call	 _strstr
  00019	83 c4 08	 add	 esp, 8
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp

; 3637 : 	if( strstr(data,"å¦åˆ™å®¶æ—åœ¨ä¸ƒå¤©ä¹‹åŽä¼šæ¶ˆå¤±å”·ï¼") ){	

  0001c	85 c0		 test	 eax, eax
  0001e	74 1c		 je	 SHORT $LN5@lssproto_W

; 3638 : 		if( TimeGetTime() - MsgCooltime > 300000 )

  00020	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00025	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?MsgCooltime@@3IA ; MsgCooltime
  0002b	3d e0 93 04 00	 cmp	 eax, 300000		; 000493e0H
  00030	76 21		 jbe	 SHORT $LN1@lssproto_W

; 3639 : 			MsgCooltime = TimeGetTime();  

  00032	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00037	a3 00 00 00 00	 mov	 DWORD PTR ?MsgCooltime@@3IA, eax ; MsgCooltime
$LN5@lssproto_W:

; 3640 : 		else
; 3641 : 			return;
; 3642 : 	}
; 3643 : 	openServerWindow( windowtype, buttontype, seqno, objindex, data );

  0003c	ff 75 1c	 push	 DWORD PTR _data$[ebp]
  0003f	ff 75 18	 push	 DWORD PTR _objindex$[ebp]
  00042	ff 75 14	 push	 DWORD PTR _seqno$[ebp]
  00045	ff 75 10	 push	 DWORD PTR _buttontype$[ebp]
  00048	ff 75 0c	 push	 DWORD PTR _windowtype$[ebp]
  0004b	e8 00 00 00 00	 call	 ?openServerWindow@@YAXHHHHPAD@Z ; openServerWindow
  00050	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@lssproto_W:

; 3644 : }

  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?lssproto_WN_recv@@YAXHHHHHPAD@Z ENDP			; lssproto_WN_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_SKUP_recv@@YAXHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_point$ = 12						; size = 4
?lssproto_SKUP_recv@@YAXHH@Z PROC			; lssproto_SKUP_recv, COMDAT

; 3985 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3986 : 	// ????????????îŽ¢î‘˜
; 3987 : 	StatusUpPoint = point;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _point$[ebp]
  00006	a3 00 00 00 00	 mov	 DWORD PTR ?StatusUpPoint@@3HA, eax ; StatusUpPoint

; 3988 : }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?lssproto_SKUP_recv@@YAXHH@Z ENDP			; lssproto_SKUP_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_PS_recv@@YAXHHHHH@Z
_TEXT	SEGMENT
_moji$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_result$ = 12						; size = 4
_havepetindex$ = 16					; size = 4
_havepetskill$ = 20					; size = 4
_toindex$ = 24						; size = 4
?lssproto_PS_recv@@YAXHHHHH@Z PROC			; lssproto_PS_recv, COMDAT

; 4059 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4060 : 	char moji[ 256 ];
; 4061 : 	
; 4062 : 	// ???????
; 4063 : 	ItemMixRecvFlag = FALSE;
; 4064 : 	
; 4065 : 	// î§î›²???
; 4066 : 	if ( result == 0 ){

  00013	83 7d 0c 00	 cmp	 DWORD PTR _result$[ebp], 0
  00017	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ItemMixRecvFlag@@3HA, 0 ; ItemMixRecvFlag
  00021	75 24		 jne	 SHORT $LN2@lssproto_P

; 4067 : 		//???????î¸î•
; 4068 : 		sprintf( moji,"å¤±è´¥ï¼");

  00023	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _moji$[ebp]
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_05OAJDDNFL@?c?w?$DP?$KD?$KB@
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _sprintf

; 4069 : 		// ????îž°??????????????
; 4070 : 		StockChatBufferLine( moji, FONT_PAL_WHITE );

  00034	6a 00		 push	 0
  00036	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _moji$[ebp]
  0003c	6a 00		 push	 0
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?StockChatBufferLine@@YAXPADEH@Z ; StockChatBufferLine
  00044	83 c4 14	 add	 esp, 20			; 00000014H
$LN2@lssproto_P:

; 4071 : 	}
; 4072 : 	
; 4073 : }

  00047	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004a	33 cd		 xor	 ecx, ebp
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?lssproto_PS_recv@@YAXHHHHH@Z ENDP			; lssproto_PS_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_SPET_recv@@YAXHHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_standbypet$ = 12					; size = 4
_result$ = 16						; size = 4
?lssproto_SPET_recv@@YAXHHH@Z PROC			; lssproto_SPET_recv, COMDAT

; 3964 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3965 : 	int cnt = 0;
; 3966 : 	int i;
; 3967 : 
; 3968 : 	StandbyPetSendFlag = FALSE;
; 3969 : 
; 3970 : 	if ( result == TRUE ) { 

  00003	83 7d 10 01	 cmp	 DWORD PTR _result$[ebp], 1
  00007	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?StandbyPetSendFlag@@3HA, 0 ; StandbyPetSendFlag
  00011	75 30		 jne	 SHORT $LN3@lssproto_S

; 3971 : 		pc.standbyPet = standbypet;

  00013	56		 push	 esi
  00014	8b 75 0c	 mov	 esi, DWORD PTR _standbypet$[ebp]
  00017	b8 01 00 00 00	 mov	 eax, 1
  0001c	66 89 35 b8 00
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A+184, si
  00023	ba ac 00 00 00	 mov	 edx, OFFSET ?pc@@3UPC@@A+172
$LL4@lssproto_S:

; 3972 : 		for ( i =0; i <MAX_PET; i++) {
; 3973 : 			if ( standbypet & ( 1 << i) )

  00028	8b c8		 mov	 ecx, eax
  0002a	23 ce		 and	 ecx, esi
  0002c	f7 d9		 neg	 ecx
  0002e	1b c9		 sbb	 ecx, ecx
  00030	d1 c0		 rol	 eax, 1
  00032	f7 d9		 neg	 ecx
  00034	66 89 0a	 mov	 WORD PTR [edx], cx
  00037	83 c2 02	 add	 edx, 2
  0003a	81 fa b6 00 00
	00		 cmp	 edx, OFFSET ?pc@@3UPC@@A+182
  00040	7c e6		 jl	 SHORT $LL4@lssproto_S
  00042	5e		 pop	 esi
$LN3@lssproto_S:

; 3974 : 				pc.selectPetNo[ i ] = TRUE;
; 3975 : 			else
; 3976 : 				pc.selectPetNo[ i ] = FALSE;
; 3977 : 		}
; 3978 : 	}
; 3979 : 
; 3980 : }

  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?lssproto_SPET_recv@@YAXHHH@Z ENDP			; lssproto_SPET_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_KS_recv@@YAXHHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_petarray$ = 12						; size = 4
_result$ = 16						; size = 4
?lssproto_KS_recv@@YAXHHH@Z PROC			; lssproto_KS_recv, COMDAT

; 3930 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3931 : 	int cnt = 0;

  00003	33 c9		 xor	 ecx, ecx

; 3932 : 	int i;
; 3933 : 
; 3934 : 	BattlePetReceiveFlag = FALSE;
; 3935 : 	BattlePetReceivePetNo = -1;

  00005	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?BattlePetReceivePetNo@@3HA, -1 ; BattlePetReceivePetNo

; 3936 : 	if ( result == TRUE ){ 

  0000f	83 7d 10 01	 cmp	 DWORD PTR _result$[ebp], 1
  00013	89 0d 00 00 00
	00		 mov	 DWORD PTR ?BattlePetReceiveFlag@@3HA, ecx ; BattlePetReceiveFlag
  00019	75 66		 jne	 SHORT $LN5@lssproto_K

; 3937 : 		battlePetNoBak = -2;
; 3938 : 		if ( petarray != -1 ){ 

  0001b	8b 55 0c	 mov	 edx, DWORD PTR _petarray$[ebp]
  0001e	c7 05 00 00 00
	00 fe ff ff ff	 mov	 DWORD PTR ?battlePetNoBak@@3HA, -2 ; battlePetNoBak, fffffffeH
  00028	83 fa ff	 cmp	 edx, -1
  0002b	74 4b		 je	 SHORT $LN3@lssproto_K

; 3939 : 			pc.selectPetNo[ petarray ] = TRUE;

  0002d	b8 01 00 00 00	 mov	 eax, 1
  00032	66 89 04 55 ac
	00 00 00	 mov	 WORD PTR ?pc@@3UPC@@A[edx*2+172], ax

; 3940 : 			if ( pc.mailPetNo == petarray ) pc.mailPetNo = -1;

  0003a	0f bf 05 b6 00
	00 00		 movsx	 eax, WORD PTR ?pc@@3UPC@@A+182
  00041	3b c2		 cmp	 eax, edx
  00043	75 09		 jne	 SHORT $LN8@lssproto_K
  00045	83 c8 ff	 or	 eax, -1
  00048	66 a3 b6 00 00
	00		 mov	 WORD PTR ?pc@@3UPC@@A+182, ax
$LN8@lssproto_K:

; 3941 : 			for ( i = 0 ; i < 5 ; i++ ){

  0004e	33 c0		 xor	 eax, eax
  00050	56		 push	 esi
$LL4@lssproto_K:

; 3942 : 				if ( pc.selectPetNo[ i ] == TRUE && i != petarray ) cnt++;

  00051	66 83 3c 45 ac
	00 00 00 01	 cmp	 WORD PTR ?pc@@3UPC@@A[eax*2+172], 1
  0005a	75 05		 jne	 SHORT $LN9@lssproto_K
  0005c	3b c2		 cmp	 eax, edx
  0005e	74 01		 je	 SHORT $LN9@lssproto_K
  00060	41		 inc	 ecx
$LN9@lssproto_K:

; 3943 : 				if ( cnt >= ç­‰å¾…å® æ•°é‡){

  00061	83 f9 05	 cmp	 ecx, 5
  00064	7c 0b		 jl	 SHORT $LN2@lssproto_K

; 3944 : 					pc.selectPetNo[ i ] = FALSE;

  00066	33 f6		 xor	 esi, esi

; 3945 : 					cnt--;

  00068	49		 dec	 ecx
  00069	66 89 34 45 ac
	00 00 00	 mov	 WORD PTR ?pc@@3UPC@@A[eax*2+172], si
$LN2@lssproto_K:

; 3941 : 			for ( i = 0 ; i < 5 ; i++ ){

  00071	40		 inc	 eax
  00072	83 f8 05	 cmp	 eax, 5
  00075	7c da		 jl	 SHORT $LL4@lssproto_K
  00077	5e		 pop	 esi
$LN3@lssproto_K:

; 3946 : 				}
; 3947 : 			}
; 3948 : 		}
; 3949 : 		pc.battlePetNo = petarray;

  00078	66 89 15 aa 00
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A+170, dx

; 3957 : 		}		
; 3958 : 	}
; 3959 : #endif
; 3960 : }

  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
$LN5@lssproto_K:

; 3950 : 	}
; 3951 : #ifdef _AFTER_TRADE_PETWAIT_
; 3952 : 	else{
; 3953 : 		if (tradeStatus==2){

  00081	66 83 3d 00 00
	00 00 02	 cmp	 WORD PTR ?tradeStatus@@3FA, 2 ; tradeStatus
  00089	75 21		 jne	 SHORT $LN12@lssproto_K

; 3954 : 			pc.selectPetNo[petarray] = 0;

  0008b	8b 4d 0c	 mov	 ecx, DWORD PTR _petarray$[ebp]
  0008e	33 c0		 xor	 eax, eax
  00090	66 89 04 4d ac
	00 00 00	 mov	 WORD PTR ?pc@@3UPC@@A[ecx*2+172], ax

; 3955 : 			if (petarray==pc.battlePetNo)

  00098	0f bf 05 aa 00
	00 00		 movsx	 eax, WORD PTR ?pc@@3UPC@@A+170
  0009f	3b c8		 cmp	 ecx, eax
  000a1	75 09		 jne	 SHORT $LN12@lssproto_K

; 3956 : 				pc.battlePetNo = -1;

  000a3	83 c8 ff	 or	 eax, -1
  000a6	66 a3 aa 00 00
	00		 mov	 WORD PTR ?pc@@3UPC@@A+170, ax
$LN12@lssproto_K:

; 3957 : 		}		
; 3958 : 	}
; 3959 : #endif
; 3960 : }

  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
?lssproto_KS_recv@@YAXHHH@Z ENDP			; lssproto_KS_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_PR_recv@@YAXHHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_request$ = 12						; size = 4
_result$ = 16						; size = 4
?lssproto_PR_recv@@YAXHHH@Z PROC			; lssproto_PR_recv, COMDAT

; 3191 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3192 : 	// ????????????????îºîŸ«?î¡Š???
; 3193 : 	if ( logOutFlag )

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  0000a	0f 85 a7 00 00
	00		 jne	 $LN1@lssproto_P

; 3194 : 		return;
; 3195 : 
; 3196 : 	if ( request == 1 && result == 1 )

  00010	8b 45 0c	 mov	 eax, DWORD PTR _request$[ebp]
  00013	83 f8 01	 cmp	 eax, 1
  00016	75 18		 jne	 SHORT $LN3@lssproto_P
  00018	39 45 10	 cmp	 DWORD PTR _result$[ebp], eax
  0001b	0f 85 8e 00 00
	00		 jne	 $LN8@lssproto_P

; 3197 : 	{
; 3198 : 		// î–“????????îš¼????î—­??
; 3199 : 		setPcParty();

  00021	e8 00 00 00 00	 call	 ?setPcParty@@YAXXZ	; setPcParty

; 3219 : 	}
; 3220 : 	prSendFlag = 0;

  00026	33 c0		 xor	 eax, eax
  00028	66 a3 00 00 00
	00		 mov	 WORD PTR ?prSendFlag@@3FA, ax ; prSendFlag

; 3221 : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
$LN3@lssproto_P:

; 3200 : 	}
; 3201 : 	else
; 3202 : 	if ( request == 0 && result == 1 )

  00030	85 c0		 test	 eax, eax
  00032	75 7b		 jne	 SHORT $LN8@lssproto_P
  00034	83 7d 10 01	 cmp	 DWORD PTR _result$[ebp], 1
  00038	75 75		 jne	 SHORT $LN8@lssproto_P

; 3203 : 	{
; 3204 : 		// ????????î•¦??
; 3205 : 		//delPcParty();
; 3206 : 		//delPcLeader();
; 3207 : 		partyModeFlag = 0;

  0003a	66 a3 00 00 00
	00		 mov	 WORD PTR ?partyModeFlag@@3FA, ax ; partyModeFlag

; 3208 : 		clearPartyParam();

  00040	e8 00 00 00 00	 call	 ?clearPartyParam@@YAXXZ	; clearPartyParam

; 3209 : #ifdef _CHANNEL_MODIFY
; 3210 : 		pc.etcFlag &= ~PC_ETCFLAG_CHAT_MODE;

  00045	b8 f7 ff 00 00	 mov	 eax, 65527		; 0000fff7H

; 3211 : 		if (TalkMode == 2) TalkMode = 0;

  0004a	33 c9		 xor	 ecx, ecx
  0004c	66 21 05 a8 00
	00 00		 and	 WORD PTR ?pc@@3UPC@@A+168, ax
  00053	a1 00 00 00 00	 mov	 eax, DWORD PTR ?TalkMode@@3HA ; TalkMode
  00058	83 f8 02	 cmp	 eax, 2
  0005b	0f 44 c1	 cmove	 eax, ecx
  0005e	a3 00 00 00 00	 mov	 DWORD PTR ?TalkMode@@3HA, eax ; TalkMode

; 3212 : #endif
; 3213 : 
; 3214 : 		char dir = (pc.dir+5) % 8;

  00063	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+12
  00068	83 c0 05	 add	 eax, 5
  0006b	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00070	79 05		 jns	 SHORT $LN10@lssproto_P
  00072	48		 dec	 eax
  00073	83 c8 f8	 or	 eax, -8			; fffffff8H
  00076	40		 inc	 eax
$LN10@lssproto_P:
  00077	0f be c0	 movsx	 eax, al

; 3215 : 		if (bNewServer)

  0007a	50		 push	 eax
  0007b	ff 35 00 00 00
	00		 push	 DWORD PTR ?nextGy@@3HA	; nextGy
  00081	ff 35 00 00 00
	00		 push	 DWORD PTR ?nextGx@@3HA	; nextGx
  00087	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  0008d	39 0d 00 00 00
	00		 cmp	 DWORD PTR ?bNewServer@@3HA, ecx ; bNewServer
  00093	74 12		 je	 SHORT $LN7@lssproto_P

; 3216 : 			lssproto_SP_send(sockfd, nextGx, nextGy, dir );

  00095	e8 00 00 00 00	 call	 ?lssproto_SP_send@@YAXHHHH@Z ; lssproto_SP_send

; 3219 : 	}
; 3220 : 	prSendFlag = 0;

  0009a	83 c4 10	 add	 esp, 16			; 00000010H
  0009d	33 c0		 xor	 eax, eax
  0009f	66 a3 00 00 00
	00		 mov	 WORD PTR ?prSendFlag@@3FA, ax ; prSendFlag

; 3221 : }

  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
$LN7@lssproto_P:

; 3217 : 		else
; 3218 : 			old_lssproto_SP_send(sockfd, nextGx, nextGy, dir );

  000a7	e8 00 00 00 00	 call	 ?old_lssproto_SP_send@@YAXHHHH@Z ; old_lssproto_SP_send

; 3219 : 	}
; 3220 : 	prSendFlag = 0;

  000ac	83 c4 10	 add	 esp, 16			; 00000010H
$LN8@lssproto_P:
  000af	33 c0		 xor	 eax, eax
  000b1	66 a3 00 00 00
	00		 mov	 WORD PTR ?prSendFlag@@3FA, ax ; prSendFlag
$LN1@lssproto_P:

; 3221 : }

  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
?lssproto_PR_recv@@YAXHHH@Z ENDP			; lssproto_PR_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_HL_recv@@YAXHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_flg$ = 12						; size = 4
?lssproto_HL_recv@@YAXHH@Z PROC				; lssproto_HL_recv, COMDAT

; 3857 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3858 : 	helpFlag = flg;

  00003	66 8b 45 0c	 mov	 ax, WORD PTR _flg$[ebp]
  00007	66 a3 00 00 00
	00		 mov	 WORD PTR ?helpFlag@@3FA, ax ; helpFlag

; 3859 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?lssproto_HL_recv@@YAXHH@Z ENDP				; lssproto_HL_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_FS_recv@@YAXHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_flg$ = 12						; size = 4
?lssproto_FS_recv@@YAXHH@Z PROC				; lssproto_FS_recv, COMDAT

; 3264 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3265 : 	// ????????????????îºîŸ«?î¡Š???
; 3266 : 	if ( logOutFlag )

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  0000a	75 0e		 jne	 SHORT $LN1@lssproto_F

; 3267 : 		return;
; 3268 : 
; 3269 : 	pc.etcFlag = (unsigned short)flg;
; 3270 : 	pc.etcFlag &= ~PC_ETCFLAG_JOINT_BTL;	// ??????î—­î¹???

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _flg$[ebp]
  0000f	25 fd ff 00 00	 and	 eax, 65533		; 0000fffdH
  00014	66 a3 a8 00 00
	00		 mov	 WORD PTR ?pc@@3UPC@@A+168, ax
$LN1@lssproto_F:

; 3271 : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?lssproto_FS_recv@@YAXHH@Z ENDP				; lssproto_FS_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_D_recv@@YAXHHHHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_category$ = 12						; size = 4
_dx$ = 16						; size = 4
_dy$ = 20						; size = 4
_data$ = 24						; size = 4
?lssproto_D_recv@@YAXHHHHPAD@Z PROC			; lssproto_D_recv, COMDAT

; 4186 : }

  00000	c2 00 00	 ret	 0
?lssproto_D_recv@@YAXHHHHPAD@Z ENDP			; lssproto_D_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_S_recv@@YAXHPAD@Z
_TEXT	SEGMENT
tv7604 = -904						; size = 4
tv7845 = -900						; size = 4
tv7742 = -900						; size = 4
_i$1$ = -896						; size = 4
tv7785 = -896						; size = 4
_no$1$ = -892						; size = 4
tv7744 = -892						; size = 4
tv7671 = -892						; size = 4
_no$1$ = -892						; size = 4
_fl$1$ = -892						; size = 4
_i$1$ = -888						; size = 4
_mask$1$ = -888						; size = 4
tv7756 = -888						; size = 4
tv7740 = -888						; size = 4
_kubun$1$ = -888					; size = 4
_data$GSCopy$1$ = -884					; size = 4
tv7837 = -884						; size = 4
_kubun$1$ = -884					; size = 4
_kubun$1$ = -884					; size = 4
_?ïÒ?ò¤$1 = -884					; size = 2
_familyName$2 = -880					; size = 256
_memo$3 = -624						; size = 85
_temp$4 = -536						; size = 256
_name$5 = -536						; size = 256
_name$6 = -536						; size = 256
_freeName$7 = -536					; size = 256
_name$8 = -536						; size = 256
_szData$9 = -280					; size = 256
_temp$10 = -280						; size = 256
_memo$11 = -280						; size = 256
_name$12 = -280						; size = 256
_freeName$13 = -280					; size = 256
_name$14 = -24						; size = 17
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_S_recv@@YAXHPAD@Z PROC			; lssproto_S_recv, COMDAT

; 880  : void lssproto_S_recv(int fd, char *data){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 03 00
	00		 sub	 esp, 904		; 00000388H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 881  : 	if (logOutFlag)

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  0001a	57		 push	 edi
  0001b	8b 7d 0c	 mov	 edi, DWORD PTR _data$[ebp]
  0001e	0f 85 64 22 00
	00		 jne	 $LN2@lssproto_S

; 882  : 		return;
; 883  : 	switch (data[0]){

  00024	0f be 07	 movsx	 eax, BYTE PTR [edi]
  00027	83 c0 be	 add	 eax, -66		; ffffffbeH
  0002a	83 f8 16	 cmp	 eax, 22			; 00000016H
  0002d	0f 87 55 22 00
	00		 ja	 $LN2@lssproto_S
  00033	53		 push	 ebx
  00034	56		 push	 esi
  00035	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN413@lssproto_S[eax*4]
$LN35@lssproto_S:

; 884  : 		case 'C':
; 885  : 		{
; 886  : 			int fl, maxx, maxy, gx, gy;
; 887  : 
; 888  : 			floorChangeFlag = TRUE;
; 889  : 			if (!loginFlag && ProcNo == PROC_GAME){

  0003c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?loginFlag@@3HA, 0 ; loginFlag
  00043	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?floorChangeFlag@@3HA, 1 ; floorChangeFlag
  0004d	75 5b		 jne	 SHORT $LN36@lssproto_S
  0004f	83 3d 00 00 00
	00 09		 cmp	 DWORD PTR ?ProcNo@@3IA, 9 ; ProcNo
  00056	75 52		 jne	 SHORT $LN36@lssproto_S

; 890  : 				if (!warpEffectFlag){				

  00058	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?warpEffectFlag@@3HA, 0 ; warpEffectFlag
  0005f	75 30		 jne	 SHORT $LN38@lssproto_S

; 891  : 					SubProcNo = 200;

  00061	c7 05 00 00 00
	00 c8 00 00 00	 mov	 DWORD PTR ?SubProcNo@@3IA, 200 ; SubProcNo, 000000c8H

; 892  : 					//JLWG å›žè®°å½•ç‚¹ç‰¹æ•ˆåŽ»é™¤
; 893  : 					JL_å…³é—­ç‰¹æ•ˆ_å›žè®°å½•ç‚¹();

  0006b	e8 00 00 00 00	 call	 ?JL_??÷åüù_üÞ??ïÃ@@YAXXZ ; JL_??÷åüù_üÞ??ïÃ

; 894  : 					warpEffectProc();

  00070	e8 00 00 00 00	 call	 ?warpEffectProc@@YAXXZ	; warpEffectProc

; 895  : 					if (MenuToggleFlag & JOY_CTRL_M)

  00075	f7 05 00 00 00
	00 00 00 00 40	 test	 DWORD PTR ?MenuToggleFlag@@3IA, 1073741824 ; MenuToggleFlag, 40000000H
  0007f	b9 01 00 00 00	 mov	 ecx, 1
  00084	a1 00 00 00 00	 mov	 eax, DWORD PTR ?MapWmdFlagBak@@3HA ; MapWmdFlagBak
  00089	0f 45 c1	 cmovne	 eax, ecx
  0008c	a3 00 00 00 00	 mov	 DWORD PTR ?MapWmdFlagBak@@3HA, eax ; MapWmdFlagBak
$LN38@lssproto_S:

; 896  : 						MapWmdFlagBak = TRUE;
; 897  : 				}
; 898  : 				resetPc();

  00091	e8 00 00 00 00	 call	 ?resetPc@@YAXXZ		; resetPc

; 899  : 				warpEffectFlag = FALSE;

  00096	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?warpEffectFlag@@3HA, 0 ; warpEffectFlag

; 900  : 				warpEffectStart = TRUE;

  000a0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?warpEffectStart@@3HA, 1 ; warpEffectStart
$LN36@lssproto_S:

; 901  : 
; 902  : 			}
; 903  : 			data++;
; 904  : 			fl   = getIntegerToken(data, S_DELIM, 1);

  000aa	6a 01		 push	 1
  000ac	47		 inc	 edi
  000ad	6a 7c		 push	 124			; 0000007cH
  000af	57		 push	 edi
  000b0	89 bd 8c fc ff
	ff		 mov	 DWORD PTR _data$GSCopy$1$[ebp], edi
  000b6	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 905  : 			maxx = getIntegerToken(data, S_DELIM, 2);

  000bb	6a 02		 push	 2
  000bd	6a 7c		 push	 124			; 0000007cH
  000bf	57		 push	 edi
  000c0	89 85 84 fc ff
	ff		 mov	 DWORD PTR _fl$1$[ebp], eax
  000c6	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 906  : 			maxy = getIntegerToken(data, S_DELIM, 3);

  000cb	6a 03		 push	 3
  000cd	6a 7c		 push	 124			; 0000007cH
  000cf	57		 push	 edi
  000d0	8b d8		 mov	 ebx, eax
  000d2	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 907  : 			gx   = getIntegerToken(data, S_DELIM, 4);

  000d7	6a 04		 push	 4
  000d9	6a 7c		 push	 124			; 0000007cH
  000db	ff b5 8c fc ff
	ff		 push	 DWORD PTR _data$GSCopy$1$[ebp]
  000e1	8b f8		 mov	 edi, eax
  000e3	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 908  : 			gy   = getIntegerToken(data, S_DELIM, 5);

  000e8	6a 05		 push	 5
  000ea	6a 7c		 push	 124			; 0000007cH
  000ec	ff b5 8c fc ff
	ff		 push	 DWORD PTR _data$GSCopy$1$[ebp]
  000f2	8b f0		 mov	 esi, eax
  000f4	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 909  : 			setMap(fl, gx, gy);

  000f9	50		 push	 eax
  000fa	56		 push	 esi
  000fb	8b b5 84 fc ff
	ff		 mov	 esi, DWORD PTR _fl$1$[ebp]
  00101	56		 push	 esi
  00102	e8 00 00 00 00	 call	 ?setMap@@YAXHHH@Z	; setMap
  00107	83 c4 48	 add	 esp, 72			; 00000048H

; 910  : 			createMap(fl, maxx, maxy);

  0010a	57		 push	 edi
  0010b	53		 push	 ebx
  0010c	56		 push	 esi
  0010d	e8 00 00 00 00	 call	 ?createMap@@YAXHHH@Z	; createMap
  00112	83 c4 0c	 add	 esp, 12			; 0000000cH

; 911  : 			nowFloorGxSize = maxx;

  00115	89 1d 00 00 00
	00		 mov	 DWORD PTR ?nowFloorGxSize@@3HA, ebx ; nowFloorGxSize

; 912  : 			nowFloorGySize = maxy;

  0011b	89 3d 00 00 00
	00		 mov	 DWORD PTR ?nowFloorGySize@@3HA, edi ; nowFloorGySize

; 913  : 			resetCharObj();

  00121	e8 00 00 00 00	 call	 ?resetCharObj@@YAXXZ	; resetCharObj

; 914  : 			mapEmptyFlag = FALSE;
; 915  : 			nowEncountPercentage = minEncountPercentage;

  00126	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?minEncountPercentage@@3FA ; minEncountPercentage
  0012c	66 a3 00 00 00
	00		 mov	 WORD PTR ?nowEncountPercentage@@3FA, ax ; nowEncountPercentage

; 916  : 			nowEncountExtra = 0;

  00132	33 c0		 xor	 eax, eax
  00134	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?mapEmptyFlag@@3HA, 0 ; mapEmptyFlag
  0013e	66 a3 00 00 00
	00		 mov	 WORD PTR ?nowEncountExtra@@3FA, ax ; nowEncountExtra

; 917  : 			resetMap();

  00144	e8 00 00 00 00	 call	 ?resetMap@@YAXXZ	; resetMap

; 918  : 			transmigrationEffectFlag = 0;

  00149	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?transmigrationEffectFlag@@3HA, 0 ; transmigrationEffectFlag

; 919  : 			//JL fix 2017.9.22 åˆ‡åœ°å›¾æ—¶,å°†ç»„é˜Ÿçš„actéƒ½æ¸…0,è¿™æ ·æ‰“ç²¾çµçŽ‹ä»¥åŠè¿‡åœ°å›¾å°±ä¸å´©äº†
; 920  : 			clearPtActPartyParam();

  00153	e8 00 00 00 00	 call	 ?clearPtActPartyParam@@YAXXZ ; clearPtActPartyParam
  00158	5e		 pop	 esi
  00159	5b		 pop	 ebx
  0015a	5f		 pop	 edi

; 1803 : 			}
; 1804 : 			break;
; 1805 :     }
; 1806 : } 

  0015b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015e	33 cd		 xor	 ecx, ebp
  00160	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00165	8b e5		 mov	 esp, ebp
  00167	5d		 pop	 ebp
  00168	c3		 ret	 0
$LN39@lssproto_S:

; 921  :             break;
; 922  : 		}
; 923  : 		case 'D':
; 924  : 			data++;
; 925  : 			setPcId(getIntegerToken(data, S_DELIM, 1));

  00169	6a 01		 push	 1
  0016b	47		 inc	 edi
  0016c	6a 7c		 push	 124			; 0000007cH
  0016e	57		 push	 edi
  0016f	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 ?setPcId@@YAXH@Z	; setPcId

; 926  : 			serverTime = getIntegerToken(data, S_DELIM, 2);

  0017a	6a 02		 push	 2
  0017c	6a 7c		 push	 124			; 0000007cH
  0017e	57		 push	 edi
  0017f	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00184	a3 00 00 00 00	 mov	 DWORD PTR ?serverTime@@3JA, eax ; serverTime

; 927  : 			FirstTime = TimeGetTime();

  00189	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime

; 928  : 			RealTimeToSATime(&SaTime);

  0018e	68 00 00 00 00	 push	 OFFSET ?SaTime@@3UtagLSTIME@@A ; SaTime
  00193	a3 00 00 00 00	 mov	 DWORD PTR ?FirstTime@@3JA, eax ; FirstTime
  00198	e8 00 00 00 00	 call	 ?RealTimeToSATime@@YAXPAUtagLSTIME@@@Z ; RealTimeToSATime

; 929  : 			SaTimeZoneNo = getLSTime(&SaTime);

  0019d	68 00 00 00 00	 push	 OFFSET ?SaTime@@3UtagLSTIME@@A ; SaTime
  001a2	e8 00 00 00 00	 call	 ?getLSTime@@YA?AW4LSTIME_SECTION@@PAUtagLSTIME@@@Z ; getLSTime

; 930  : 			PaletteChange(SaTimeZoneNo, 0);

  001a7	6a 00		 push	 0
  001a9	50		 push	 eax
  001aa	a3 00 00 00 00	 mov	 DWORD PTR ?SaTimeZoneNo@@3HA, eax ; SaTimeZoneNo
  001af	e8 00 00 00 00	 call	 ?PaletteChange@@YAXHH@Z	; PaletteChange
  001b4	83 c4 2c	 add	 esp, 44			; 0000002cH
  001b7	5e		 pop	 esi
  001b8	5b		 pop	 ebx
  001b9	5f		 pop	 edi

; 1803 : 			}
; 1804 : 			break;
; 1805 :     }
; 1806 : } 

  001ba	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bd	33 cd		 xor	 ecx, ebp
  001bf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c4	8b e5		 mov	 esp, ebp
  001c6	5d		 pop	 ebp
  001c7	c3		 ret	 0
$LN40@lssproto_S:

; 931  : 			break;
; 932  : 		//andy_add
; 933  : 		case 'X':
; 934  : 			pc.lowsride = getIntegerToken(data, S_DELIM, 2);

  001c8	6a 02		 push	 2
  001ca	6a 7c		 push	 124			; 0000007cH
  001cc	57		 push	 edi
  001cd	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1791 : 					//å¯æ‹¿ç»™å® ç‰©è£…å¤‡çš„é“å…·,å°±ä¸ä¼šæ˜¯æ‹¼å›¾äº†,ä»¥ä¸‹å°±å…äº†
; 1792 : 					//if( i == JigsawIdx )
; 1793 : 					//	SetJigsaw( pc.item[i].graNo, pc.item[i].jigsaw );
; 1794 : 				}
; 1795 : 			}
; 1796 : 			break;
; 1797 : #endif
; 1798 : 			case 'V':
; 1799 : 			{
; 1800 : 				extern int itemWndMaxBag;
; 1801 : 				//V|1
; 1802 : 				itemWndMaxBag = getIntegerToken(data, '|', 2);

  001d2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d5	a3 20 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20768, eax
  001da	5e		 pop	 esi
  001db	5b		 pop	 ebx
  001dc	5f		 pop	 edi

; 1803 : 			}
; 1804 : 			break;
; 1805 :     }
; 1806 : } 

  001dd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e0	33 cd		 xor	 ecx, ebp
  001e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e7	8b e5		 mov	 esp, ebp
  001e9	5d		 pop	 ebp
  001ea	c3		 ret	 0
$LN41@lssproto_S:

; 935  : 			break;
; 936  : 		case 'P':
; 937  : 			{
; 938  : 				char name[256], freeName[256];
; 939  : 				int i, kubun;
; 940  : 				unsigned int mask;
; 941  : 
; 942  : 				data++;
; 943  : 				kubun = getInteger62Token(data, S_DELIM, 1);

  001eb	6a 01		 push	 1
  001ed	47		 inc	 edi
  001ee	6a 7c		 push	 124			; 0000007cH
  001f0	57		 push	 edi
  001f1	e8 00 00 00 00	 call	 ?getInteger62Token@@YAHPADDH@Z ; getInteger62Token

; 944  : 				if (!bNewServer)

  001f6	8b 0d 18 51 00
	00		 mov	 ecx, DWORD PTR ?pc@@3UPC@@A+20760
  001fc	83 cb ff	 or	 ebx, -1
  001ff	83 c4 0c	 add	 esp, 12			; 0000000cH
  00202	89 85 8c fc ff
	ff		 mov	 DWORD PTR _kubun$1$[ebp], eax
  00208	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bNewServer@@3HA, 0 ; bNewServer
  0020f	0f 44 cb	 cmove	 ecx, ebx
  00212	89 0d 18 51 00
	00		 mov	 DWORD PTR ?pc@@3UPC@@A+20760, ecx

; 945  : 					pc.ridePetNo = -1;
; 946  : 				if (kubun == 1)

  00218	83 f8 01	 cmp	 eax, 1
  0021b	0f 85 78 02 00
	00		 jne	 $LN43@lssproto_S

; 947  : 				{
; 948  : 					pc.hp		= getIntegerToken(data, S_DELIM, 2);		// 0x00000002

  00221	6a 02		 push	 2
  00223	6a 7c		 push	 124			; 0000007cH
  00225	57		 push	 edi
  00226	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 949  : 					pc.maxHp	= getIntegerToken(data, S_DELIM, 3);		// 0x00000004

  0022b	6a 03		 push	 3
  0022d	6a 7c		 push	 124			; 0000007cH
  0022f	57		 push	 edi
  00230	a3 10 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+16, eax
  00235	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 950  : 					pc.mp		= getIntegerToken(data, S_DELIM, 4);		// 0x00000008

  0023a	6a 04		 push	 4
  0023c	6a 7c		 push	 124			; 0000007cH
  0023e	57		 push	 edi
  0023f	a3 14 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20, eax
  00244	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 951  : 					pc.maxMp	= getIntegerToken(data, S_DELIM, 5);		// 0x00000010

  00249	6a 05		 push	 5
  0024b	6a 7c		 push	 124			; 0000007cH
  0024d	57		 push	 edi
  0024e	a3 18 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+24, eax
  00253	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 952  : 					pc.vital	= getIntegerToken(data, S_DELIM, 6);		// 0x00000020

  00258	6a 06		 push	 6
  0025a	6a 7c		 push	 124			; 0000007cH
  0025c	57		 push	 edi
  0025d	a3 1c 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+28, eax
  00262	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 953  : 					pc.str		= getIntegerToken(data, S_DELIM, 7);		// 0x00000040

  00267	6a 07		 push	 7
  00269	6a 7c		 push	 124			; 0000007cH
  0026b	57		 push	 edi
  0026c	a3 20 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+32, eax
  00271	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00276	83 c4 48	 add	 esp, 72			; 00000048H
  00279	a3 24 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+36, eax

; 954  : 					pc.tgh		= getIntegerToken(data, S_DELIM, 8);		// 0x00000080

  0027e	6a 08		 push	 8
  00280	6a 7c		 push	 124			; 0000007cH
  00282	57		 push	 edi
  00283	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 955  : 					pc.dex		= getIntegerToken(data, S_DELIM, 9);		// 0x00000100

  00288	6a 09		 push	 9
  0028a	6a 7c		 push	 124			; 0000007cH
  0028c	57		 push	 edi
  0028d	a3 28 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+40, eax
  00292	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 956  : 					pc.exp		= getIntegerToken(data, S_DELIM, 10);		// 0x00000200

  00297	6a 0a		 push	 10			; 0000000aH
  00299	6a 7c		 push	 124			; 0000007cH
  0029b	57		 push	 edi
  0029c	a3 2c 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+44, eax
  002a1	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 957  : 					pc.maxExp	= getIntegerToken(data, S_DELIM, 11);		// 0x00000400

  002a6	6a 0b		 push	 11			; 0000000bH
  002a8	6a 7c		 push	 124			; 0000007cH
  002aa	57		 push	 edi
  002ab	a3 30 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+48, eax
  002b0	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 958  : 					pc.level	= getIntegerToken(data, S_DELIM, 12);		// 0x00000800

  002b5	6a 0c		 push	 12			; 0000000cH
  002b7	6a 7c		 push	 124			; 0000007cH
  002b9	57		 push	 edi
  002ba	a3 34 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+52, eax
  002bf	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 959  : 					pc.atk		= getIntegerToken(data, S_DELIM, 13);		// 0x00001000

  002c4	6a 0d		 push	 13			; 0000000dH
  002c6	6a 7c		 push	 124			; 0000007cH
  002c8	57		 push	 edi
  002c9	a3 38 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+56, eax
  002ce	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  002d3	83 c4 48	 add	 esp, 72			; 00000048H
  002d6	a3 3c 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+60, eax

; 960  : 					pc.def		= getIntegerToken(data, S_DELIM, 14);		// 0x00002000

  002db	6a 0e		 push	 14			; 0000000eH
  002dd	6a 7c		 push	 124			; 0000007cH
  002df	57		 push	 edi
  002e0	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 961  : 					pc.quick	= getIntegerToken(data, S_DELIM, 15);		// 0x00004000

  002e5	6a 0f		 push	 15			; 0000000fH
  002e7	6a 7c		 push	 124			; 0000007cH
  002e9	57		 push	 edi
  002ea	a3 40 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+64, eax
  002ef	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 962  : 					pc.charm	= getIntegerToken(data, S_DELIM, 16);		// 0x00008000

  002f4	6a 10		 push	 16			; 00000010H
  002f6	6a 7c		 push	 124			; 0000007cH
  002f8	57		 push	 edi
  002f9	a3 44 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+68, eax
  002fe	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 963  : 					pc.luck		= getIntegerToken(data, S_DELIM, 17);		// 0x00010000

  00303	6a 11		 push	 17			; 00000011H
  00305	6a 7c		 push	 124			; 0000007cH
  00307	57		 push	 edi
  00308	a3 48 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+72, eax
  0030d	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 964  : 					pc.earth	= getIntegerToken(data, S_DELIM, 18);		// 0x00020000

  00312	6a 12		 push	 18			; 00000012H
  00314	6a 7c		 push	 124			; 0000007cH
  00316	57		 push	 edi
  00317	a3 4c 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+76, eax
  0031c	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 965  : 					pc.water	= getIntegerToken(data, S_DELIM, 19);		// 0x00040000

  00321	6a 13		 push	 19			; 00000013H
  00323	6a 7c		 push	 124			; 0000007cH
  00325	57		 push	 edi
  00326	a3 50 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+80, eax
  0032b	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00330	83 c4 48	 add	 esp, 72			; 00000048H
  00333	a3 54 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+84, eax

; 966  : 					pc.fire		= getIntegerToken(data, S_DELIM, 20);		// 0x00080000

  00338	6a 14		 push	 20			; 00000014H
  0033a	6a 7c		 push	 124			; 0000007cH
  0033c	57		 push	 edi
  0033d	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 967  : 					pc.wind		= getIntegerToken(data, S_DELIM, 21);		// 0x00100000

  00342	6a 15		 push	 21			; 00000015H
  00344	6a 7c		 push	 124			; 0000007cH
  00346	57		 push	 edi
  00347	a3 58 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+88, eax
  0034c	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 968  : 					pc.gold		= getIntegerToken(data, S_DELIM, 22);		// 0x00200000

  00351	6a 16		 push	 22			; 00000016H
  00353	6a 7c		 push	 124			; 0000007cH
  00355	57		 push	 edi
  00356	a3 5c 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+92, eax
  0035b	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 969  : 					pc.titleNo	= getIntegerToken(data, S_DELIM, 23);		// 0x00400000

  00360	6a 17		 push	 23			; 00000017H
  00362	6a 7c		 push	 124			; 0000007cH
  00364	57		 push	 edi
  00365	a3 60 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+96, eax
  0036a	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 970  : 					pc.dp		= getIntegerToken(data, S_DELIM, 24);		// 0x00800000

  0036f	6a 18		 push	 24			; 00000018H
  00371	6a 7c		 push	 124			; 0000007cH
  00373	57		 push	 edi
  00374	a3 68 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+104, eax
  00379	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 971  : 					pc.transmigration = getIntegerToken(data, S_DELIM, 25);// 0x01000000

  0037e	6a 19		 push	 25			; 00000019H
  00380	6a 7c		 push	 124			; 0000007cH
  00382	57		 push	 edi
  00383	a3 6c 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+108, eax
  00388	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0038d	83 c4 48	 add	 esp, 72			; 00000048H
  00390	66 a3 f4 50 00
	00		 mov	 WORD PTR ?pc@@3UPC@@A+20724, ax

; 972  : 					pc.ridePetNo = getIntegerToken(data, S_DELIM, 26);	// 0x02000000

  00396	6a 1a		 push	 26			; 0000001aH
  00398	6a 7c		 push	 124			; 0000007cH
  0039a	57		 push	 edi
  0039b	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 973  : 					pc.learnride = getIntegerToken(data, S_DELIM, 27);	// 0x04000000

  003a0	6a 1b		 push	 27			; 0000001bH
  003a2	6a 7c		 push	 124			; 0000007cH
  003a4	57		 push	 edi
  003a5	a3 18 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20760, eax
  003aa	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 974  : 					pc.baseGraNo = getIntegerToken(data, S_DELIM, 28);	// 0x08000000

  003af	6a 1c		 push	 28			; 0000001cH
  003b1	6a 7c		 push	 124			; 0000007cH
  003b3	57		 push	 edi
  003b4	a3 1c 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20764, eax
  003b9	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 975  : #ifdef _NEW_RIDEPETS
; 976  : 					pc.lowsride = getIntegerToken(data, S_DELIM, 29);		// 0x08000000

  003be	6a 1d		 push	 29			; 0000001dH
  003c0	6a 7c		 push	 124			; 0000007cH
  003c2	57		 push	 edi
  003c3	a3 50 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20816, eax
  003c8	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  003cd	a3 20 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20768, eax

; 977  : #endif
; 978  : 					getStringToken(data, S_DELIM, 30, sizeof(name) - 1, name);

  003d2	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _name$8[ebp]
  003d8	50		 push	 eax
  003d9	68 ff 00 00 00	 push	 255			; 000000ffH
  003de	6a 1e		 push	 30			; 0000001eH
  003e0	6a 7c		 push	 124			; 0000007cH
  003e2	57		 push	 edi
  003e3	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  003e8	83 c4 44	 add	 esp, 68			; 00000044H

; 979  : 					makeStringFromEscaped(name);

  003eb	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _name$8[ebp]
  003f1	50		 push	 eax
  003f2	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 980  : 					if (strlen(name) <= CHAR_NAME_LEN)

  003f7	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _name$8[ebp]
  003fd	83 c4 04	 add	 esp, 4
  00400	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL414@lssproto_S:
  00403	8a 01		 mov	 al, BYTE PTR [ecx]
  00405	41		 inc	 ecx
  00406	84 c0		 test	 al, al
  00408	75 f9		 jne	 SHORT $LL414@lssproto_S
  0040a	2b ca		 sub	 ecx, edx
  0040c	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0040f	77 23		 ja	 SHORT $LN45@lssproto_S

; 981  : 						strcpy(pc.name, name);

  00411	33 c9		 xor	 ecx, ecx
  00413	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL244@lssproto_S:
  00420	8a 84 0d e8 fd
	ff ff		 mov	 al, BYTE PTR _name$8[ebp+ecx]
  00427	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  0042a	88 81 6f 00 00
	00		 mov	 BYTE PTR ?pc@@3UPC@@A[ecx+111], al
  00430	84 c0		 test	 al, al
  00432	75 ec		 jne	 SHORT $LL244@lssproto_S
$LN45@lssproto_S:

; 982  : 					getStringToken(data, S_DELIM, 31, sizeof(freeName) - 1, freeName);

  00434	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _freeName$13[ebp]
  0043a	50		 push	 eax
  0043b	68 ff 00 00 00	 push	 255			; 000000ffH
  00440	6a 1f		 push	 31			; 0000001fH
  00442	6a 7c		 push	 124			; 0000007cH
  00444	57		 push	 edi
  00445	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 983  : 					makeStringFromEscaped(freeName);

  0044a	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _freeName$13[ebp]
  00450	50		 push	 eax
  00451	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 984  : 					if (strlen(freeName) <= CHAR_FREENAME_LEN)

  00456	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _freeName$13[ebp]
  0045c	83 c4 18	 add	 esp, 24			; 00000018H
  0045f	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL415@lssproto_S:
  00462	8a 01		 mov	 al, BYTE PTR [ecx]
  00464	41		 inc	 ecx
  00465	84 c0		 test	 al, al
  00467	75 f9		 jne	 SHORT $LL415@lssproto_S
  00469	2b ca		 sub	 ecx, edx
  0046b	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0046e	0f 87 e5 03 00
	00		 ja	 $LN5@lssproto_S

; 985  : 						strcpy(pc.freeName, freeName);

  00474	33 c9		 xor	 ecx, ecx
  00476	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL245@lssproto_S:
  00480	8a 84 0d e8 fe
	ff ff		 mov	 al, BYTE PTR _freeName$13[ebp+ecx]
  00487	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  0048a	88 81 80 00 00
	00		 mov	 BYTE PTR ?pc@@3UPC@@A[ecx+128], al
  00490	84 c0		 test	 al, al
  00492	75 ec		 jne	 SHORT $LL245@lssproto_S

; 986  : 				}

  00494	e9 c0 03 00 00	 jmp	 $LN5@lssproto_S
$LN43@lssproto_S:

; 987  : 				else
; 988  : 				{
; 989  : 					mask = 2;

  00499	bb 02 00 00 00	 mov	 ebx, 2

; 990  : 					i = 2;

  0049e	8b f3		 mov	 esi, ebx
$LL6@lssproto_S:

; 992  : 					{
; 993  : 						if (kubun & mask)

  004a0	85 d8		 test	 ebx, eax
  004a2	0f 84 a6 03 00
	00		 je	 $LN4@lssproto_S

; 994  : 						{
; 995  : 							if (mask == 0x00000002) // ( 1 << 1 )

  004a8	83 fb 02	 cmp	 ebx, 2
  004ab	75 13		 jne	 SHORT $LN48@lssproto_S

; 996  : 							{
; 997  : 								pc.hp = getIntegerToken(data, S_DELIM, i);// 0x00000002

  004ad	56		 push	 esi
  004ae	6a 7c		 push	 124			; 0000007cH
  004b0	57		 push	 edi
  004b1	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  004b6	a3 10 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+16, eax

; 998  : 								i++;
; 999  : 							}

  004bb	e9 84 03 00 00	 jmp	 $LN442@lssproto_S
$LN48@lssproto_S:

; 1000 : 							else if (mask == 0x00000004) // ( 1 << 2 )

  004c0	83 fb 04	 cmp	 ebx, 4
  004c3	75 13		 jne	 SHORT $LN50@lssproto_S

; 1001 : 							{
; 1002 : 								pc.maxHp = getIntegerToken(data, S_DELIM, i);// 0x00000004

  004c5	56		 push	 esi
  004c6	6a 7c		 push	 124			; 0000007cH
  004c8	57		 push	 edi
  004c9	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  004ce	a3 14 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20, eax

; 1003 : 								i++;
; 1004 : 							}

  004d3	e9 6c 03 00 00	 jmp	 $LN442@lssproto_S
$LN50@lssproto_S:

; 1005 : 							else if (mask == 0x00000008)

  004d8	83 fb 08	 cmp	 ebx, 8
  004db	75 13		 jne	 SHORT $LN52@lssproto_S

; 1006 : 							{
; 1007 : 								pc.mp = getIntegerToken(data, S_DELIM, i);// 0x00000008

  004dd	56		 push	 esi
  004de	6a 7c		 push	 124			; 0000007cH
  004e0	57		 push	 edi
  004e1	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  004e6	a3 18 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+24, eax

; 1008 : 								i++;
; 1009 : 							}

  004eb	e9 54 03 00 00	 jmp	 $LN442@lssproto_S
$LN52@lssproto_S:

; 1010 : 							else if (mask == 0x00000010)

  004f0	83 fb 10	 cmp	 ebx, 16			; 00000010H
  004f3	75 13		 jne	 SHORT $LN54@lssproto_S

; 1011 : 							{
; 1012 : 								pc.maxMp = getIntegerToken(data, S_DELIM, i);// 0x00000010

  004f5	56		 push	 esi
  004f6	6a 7c		 push	 124			; 0000007cH
  004f8	57		 push	 edi
  004f9	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  004fe	a3 1c 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+28, eax

; 1013 : 								i++;
; 1014 : 							}

  00503	e9 3c 03 00 00	 jmp	 $LN442@lssproto_S
$LN54@lssproto_S:

; 1015 : 							else if (mask == 0x00000020)

  00508	83 fb 20	 cmp	 ebx, 32			; 00000020H
  0050b	75 13		 jne	 SHORT $LN56@lssproto_S

; 1016 : 							{
; 1017 : 								pc.vital = getIntegerToken(data, S_DELIM, i);// 0x00000020

  0050d	56		 push	 esi
  0050e	6a 7c		 push	 124			; 0000007cH
  00510	57		 push	 edi
  00511	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00516	a3 20 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+32, eax

; 1018 : 								i++;
; 1019 : 							}

  0051b	e9 24 03 00 00	 jmp	 $LN442@lssproto_S
$LN56@lssproto_S:

; 1020 : 							else if (mask == 0x00000040)

  00520	83 fb 40	 cmp	 ebx, 64			; 00000040H
  00523	75 13		 jne	 SHORT $LN58@lssproto_S

; 1021 : 							{
; 1022 : 								pc.str = getIntegerToken(data, S_DELIM, i);// 0x00000040

  00525	56		 push	 esi
  00526	6a 7c		 push	 124			; 0000007cH
  00528	57		 push	 edi
  00529	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0052e	a3 24 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+36, eax

; 1023 : 								i++;
; 1024 : 							}

  00533	e9 0c 03 00 00	 jmp	 $LN442@lssproto_S
$LN58@lssproto_S:

; 1025 : 							else if (mask == 0x00000080)

  00538	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  0053e	75 13		 jne	 SHORT $LN60@lssproto_S

; 1026 : 							{
; 1027 : 								pc.tgh = getIntegerToken(data, S_DELIM, i);// 0x00000080

  00540	56		 push	 esi
  00541	6a 7c		 push	 124			; 0000007cH
  00543	57		 push	 edi
  00544	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00549	a3 28 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+40, eax

; 1028 : 								i++;
; 1029 : 							}

  0054e	e9 f1 02 00 00	 jmp	 $LN442@lssproto_S
$LN60@lssproto_S:

; 1030 : 							else if (mask == 0x00000100)

  00553	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  00559	75 13		 jne	 SHORT $LN62@lssproto_S

; 1031 : 							{
; 1032 : 								pc.dex = getIntegerToken(data, S_DELIM, i);// 0x00000100

  0055b	56		 push	 esi
  0055c	6a 7c		 push	 124			; 0000007cH
  0055e	57		 push	 edi
  0055f	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00564	a3 2c 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+44, eax

; 1033 : 								i++;
; 1034 : 							}

  00569	e9 d6 02 00 00	 jmp	 $LN442@lssproto_S
$LN62@lssproto_S:

; 1035 : 							else if (mask == 0x00000200)

  0056e	81 fb 00 02 00
	00		 cmp	 ebx, 512		; 00000200H
  00574	75 13		 jne	 SHORT $LN64@lssproto_S

; 1036 : 							{
; 1037 : 								pc.exp = getIntegerToken(data, S_DELIM, i);// 0x00000200

  00576	56		 push	 esi
  00577	6a 7c		 push	 124			; 0000007cH
  00579	57		 push	 edi
  0057a	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0057f	a3 30 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+48, eax

; 1038 : 								i++;
; 1039 : 							}

  00584	e9 bb 02 00 00	 jmp	 $LN442@lssproto_S
$LN64@lssproto_S:

; 1040 : 							else if (mask == 0x00000400)

  00589	81 fb 00 04 00
	00		 cmp	 ebx, 1024		; 00000400H
  0058f	75 13		 jne	 SHORT $LN66@lssproto_S

; 1041 : 							{
; 1042 : 								pc.maxExp = getIntegerToken(data, S_DELIM, i);// 0x00000400

  00591	56		 push	 esi
  00592	6a 7c		 push	 124			; 0000007cH
  00594	57		 push	 edi
  00595	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0059a	a3 34 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+52, eax

; 1043 : 								i++;
; 1044 : 							}

  0059f	e9 a0 02 00 00	 jmp	 $LN442@lssproto_S
$LN66@lssproto_S:

; 1045 : 							else if (mask == 0x00000800)

  005a4	81 fb 00 08 00
	00		 cmp	 ebx, 2048		; 00000800H
  005aa	75 13		 jne	 SHORT $LN68@lssproto_S

; 1046 : 							{
; 1047 : 								pc.level = getIntegerToken(data, S_DELIM, i);// 0x00000800

  005ac	56		 push	 esi
  005ad	6a 7c		 push	 124			; 0000007cH
  005af	57		 push	 edi
  005b0	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  005b5	a3 38 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+56, eax

; 1048 : 								i++;
; 1049 : 							}

  005ba	e9 85 02 00 00	 jmp	 $LN442@lssproto_S
$LN68@lssproto_S:

; 1050 : 							else if (mask == 0x00001000)

  005bf	81 fb 00 10 00
	00		 cmp	 ebx, 4096		; 00001000H
  005c5	75 13		 jne	 SHORT $LN70@lssproto_S

; 1051 : 							{
; 1052 : 								pc.atk = getIntegerToken(data, S_DELIM, i);// 0x00001000

  005c7	56		 push	 esi
  005c8	6a 7c		 push	 124			; 0000007cH
  005ca	57		 push	 edi
  005cb	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  005d0	a3 3c 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+60, eax

; 1053 : 								i++;
; 1054 : 							}

  005d5	e9 6a 02 00 00	 jmp	 $LN442@lssproto_S
$LN70@lssproto_S:

; 1055 : 							else if (mask == 0x00002000)

  005da	81 fb 00 20 00
	00		 cmp	 ebx, 8192		; 00002000H
  005e0	75 13		 jne	 SHORT $LN72@lssproto_S

; 1056 : 							{
; 1057 : 								pc.def = getIntegerToken(data, S_DELIM, i);// 0x00002000

  005e2	56		 push	 esi
  005e3	6a 7c		 push	 124			; 0000007cH
  005e5	57		 push	 edi
  005e6	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  005eb	a3 40 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+64, eax

; 1058 : 								i++;
; 1059 : 							}

  005f0	e9 4f 02 00 00	 jmp	 $LN442@lssproto_S
$LN72@lssproto_S:

; 1060 : 							else if (mask == 0x00004000)

  005f5	81 fb 00 40 00
	00		 cmp	 ebx, 16384		; 00004000H
  005fb	75 13		 jne	 SHORT $LN74@lssproto_S

; 1061 : 							{
; 1062 : 								pc.quick = getIntegerToken(data, S_DELIM, i);// 0x00004000

  005fd	56		 push	 esi
  005fe	6a 7c		 push	 124			; 0000007cH
  00600	57		 push	 edi
  00601	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00606	a3 44 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+68, eax

; 1063 : 								i++;
; 1064 : 							}

  0060b	e9 34 02 00 00	 jmp	 $LN442@lssproto_S
$LN74@lssproto_S:

; 1065 : 							else if (mask == 0x00008000)

  00610	81 fb 00 80 00
	00		 cmp	 ebx, 32768		; 00008000H
  00616	75 13		 jne	 SHORT $LN76@lssproto_S

; 1066 : 							{
; 1067 : 								pc.charm = getIntegerToken(data, S_DELIM, i);// 0x00008000

  00618	56		 push	 esi
  00619	6a 7c		 push	 124			; 0000007cH
  0061b	57		 push	 edi
  0061c	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00621	a3 48 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+72, eax

; 1068 : 								i++;
; 1069 : 							}

  00626	e9 19 02 00 00	 jmp	 $LN442@lssproto_S
$LN76@lssproto_S:

; 1070 : 							else if (mask == 0x00010000)

  0062b	81 fb 00 00 01
	00		 cmp	 ebx, 65536		; 00010000H
  00631	75 13		 jne	 SHORT $LN78@lssproto_S

; 1071 : 							{
; 1072 : 								pc.luck = getIntegerToken(data, S_DELIM, i);// 0x00010000

  00633	56		 push	 esi
  00634	6a 7c		 push	 124			; 0000007cH
  00636	57		 push	 edi
  00637	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0063c	a3 4c 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+76, eax

; 1073 : 								i++;
; 1074 : 							}

  00641	e9 fe 01 00 00	 jmp	 $LN442@lssproto_S
$LN78@lssproto_S:

; 1075 : 							else if (mask == 0x00020000)

  00646	81 fb 00 00 02
	00		 cmp	 ebx, 131072		; 00020000H
  0064c	75 13		 jne	 SHORT $LN80@lssproto_S

; 1076 : 							{
; 1077 : 								pc.earth = getIntegerToken(data, S_DELIM, i);// 0x00020000

  0064e	56		 push	 esi
  0064f	6a 7c		 push	 124			; 0000007cH
  00651	57		 push	 edi
  00652	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00657	a3 50 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+80, eax

; 1078 : 								i++;
; 1079 : 							}

  0065c	e9 e3 01 00 00	 jmp	 $LN442@lssproto_S
$LN80@lssproto_S:

; 1080 : 							else if (mask == 0x00040000)

  00661	81 fb 00 00 04
	00		 cmp	 ebx, 262144		; 00040000H
  00667	75 13		 jne	 SHORT $LN82@lssproto_S

; 1081 : 							{
; 1082 : 								pc.water = getIntegerToken(data, S_DELIM, i);// 0x00040000

  00669	56		 push	 esi
  0066a	6a 7c		 push	 124			; 0000007cH
  0066c	57		 push	 edi
  0066d	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00672	a3 54 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+84, eax

; 1083 : 								i++;
; 1084 : 							}

  00677	e9 c8 01 00 00	 jmp	 $LN442@lssproto_S
$LN82@lssproto_S:

; 1085 : 							else if (mask == 0x00080000)

  0067c	81 fb 00 00 08
	00		 cmp	 ebx, 524288		; 00080000H
  00682	75 13		 jne	 SHORT $LN84@lssproto_S

; 1086 : 							{
; 1087 : 								pc.fire = getIntegerToken(data, S_DELIM, i);// 0x00080000

  00684	56		 push	 esi
  00685	6a 7c		 push	 124			; 0000007cH
  00687	57		 push	 edi
  00688	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0068d	a3 58 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+88, eax

; 1088 : 								i++;
; 1089 : 							}

  00692	e9 ad 01 00 00	 jmp	 $LN442@lssproto_S
$LN84@lssproto_S:

; 1090 : 							else if (mask == 0x00100000)

  00697	81 fb 00 00 10
	00		 cmp	 ebx, 1048576		; 00100000H
  0069d	75 13		 jne	 SHORT $LN86@lssproto_S

; 1091 : 							{
; 1092 : 								pc.wind = getIntegerToken(data, S_DELIM, i);// 0x00100000

  0069f	56		 push	 esi
  006a0	6a 7c		 push	 124			; 0000007cH
  006a2	57		 push	 edi
  006a3	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  006a8	a3 5c 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+92, eax

; 1093 : 								i++;
; 1094 : 							}

  006ad	e9 92 01 00 00	 jmp	 $LN442@lssproto_S
$LN86@lssproto_S:

; 1095 : 							else if (mask == 0x00200000)

  006b2	81 fb 00 00 20
	00		 cmp	 ebx, 2097152		; 00200000H
  006b8	75 13		 jne	 SHORT $LN88@lssproto_S

; 1096 : 							{
; 1097 : 								pc.gold = getIntegerToken(data, S_DELIM, i);// 0x00200000

  006ba	56		 push	 esi
  006bb	6a 7c		 push	 124			; 0000007cH
  006bd	57		 push	 edi
  006be	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  006c3	a3 60 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+96, eax

; 1098 : 								i++;
; 1099 : 							}

  006c8	e9 77 01 00 00	 jmp	 $LN442@lssproto_S
$LN88@lssproto_S:

; 1100 : 							else if (mask == 0x00400000)

  006cd	81 fb 00 00 40
	00		 cmp	 ebx, 4194304		; 00400000H
  006d3	75 13		 jne	 SHORT $LN90@lssproto_S

; 1101 : 							{
; 1102 : 								pc.titleNo = getIntegerToken(data, S_DELIM, i);// 0x00400000

  006d5	56		 push	 esi
  006d6	6a 7c		 push	 124			; 0000007cH
  006d8	57		 push	 edi
  006d9	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  006de	a3 68 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+104, eax

; 1103 : 								i++;
; 1104 : 							}

  006e3	e9 5c 01 00 00	 jmp	 $LN442@lssproto_S
$LN90@lssproto_S:

; 1105 : 							else if (mask == 0x00800000)

  006e8	81 fb 00 00 80
	00		 cmp	 ebx, 8388608		; 00800000H
  006ee	75 13		 jne	 SHORT $LN92@lssproto_S

; 1106 : 							{
; 1107 : 								pc.dp = getIntegerToken(data, S_DELIM, i);// 0x00800000

  006f0	56		 push	 esi
  006f1	6a 7c		 push	 124			; 0000007cH
  006f3	57		 push	 edi
  006f4	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  006f9	a3 6c 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+108, eax

; 1108 : 								i++;
; 1109 : 							}

  006fe	e9 41 01 00 00	 jmp	 $LN442@lssproto_S
$LN92@lssproto_S:

; 1110 : 							else if (mask == 0x01000000)

  00703	81 fb 00 00 00
	01		 cmp	 ebx, 16777216		; 01000000H
  00709	75 14		 jne	 SHORT $LN94@lssproto_S

; 1111 : 							{
; 1112 : 								pc.transmigration = getIntegerToken(data, S_DELIM, i);// 0x01000000

  0070b	56		 push	 esi
  0070c	6a 7c		 push	 124			; 0000007cH
  0070e	57		 push	 edi
  0070f	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00714	66 a3 f4 50 00
	00		 mov	 WORD PTR ?pc@@3UPC@@A+20724, ax

; 1113 : 								i++;
; 1114 : 							}

  0071a	e9 25 01 00 00	 jmp	 $LN442@lssproto_S
$LN94@lssproto_S:

; 1115 : 							else if (mask == 0x02000000)

  0071f	81 fb 00 00 00
	02		 cmp	 ebx, 33554432		; 02000000H
  00725	75 62		 jne	 SHORT $LN96@lssproto_S

; 1116 : 							{
; 1117 : 								getStringToken(data, S_DELIM, i, sizeof(name) - 1, name);// 0x01000000

  00727	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _name$8[ebp]
  0072d	50		 push	 eax
  0072e	68 ff 00 00 00	 push	 255			; 000000ffH
  00733	56		 push	 esi
  00734	6a 7c		 push	 124			; 0000007cH
  00736	57		 push	 edi
  00737	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1118 : 								makeStringFromEscaped(name);

  0073c	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _name$8[ebp]
  00742	50		 push	 eax
  00743	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1119 : 								if (strlen(name) <= CHAR_NAME_LEN)

  00748	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _name$8[ebp]
  0074e	83 c4 18	 add	 esp, 24			; 00000018H
  00751	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL416@lssproto_S:
  00754	8a 01		 mov	 al, BYTE PTR [ecx]
  00756	41		 inc	 ecx
  00757	84 c0		 test	 al, al
  00759	75 f9		 jne	 SHORT $LL416@lssproto_S
  0075b	2b ca		 sub	 ecx, edx
  0075d	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00760	0f 87 e1 00 00
	00		 ja	 $LN98@lssproto_S

; 1120 : 									strcpy(pc.name, name);

  00766	33 c9		 xor	 ecx, ecx
  00768	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL246@lssproto_S:
  00770	8a 84 0d e8 fd
	ff ff		 mov	 al, BYTE PTR _name$8[ebp+ecx]
  00777	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  0077a	88 81 6f 00 00
	00		 mov	 BYTE PTR ?pc@@3UPC@@A[ecx+111], al
  00780	84 c0		 test	 al, al
  00782	75 ec		 jne	 SHORT $LL246@lssproto_S

; 1121 : 								i++;
; 1122 : 							}

  00784	e9 be 00 00 00	 jmp	 $LN98@lssproto_S
$LN96@lssproto_S:

; 1123 : 							else if (mask == 0x04000000)

  00789	81 fb 00 00 00
	04		 cmp	 ebx, 67108864		; 04000000H
  0078f	75 55		 jne	 SHORT $LN99@lssproto_S

; 1124 : 							{
; 1125 : 								getStringToken(data, S_DELIM, i, sizeof(freeName) - 1, freeName);// 0x02000000

  00791	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _freeName$13[ebp]
  00797	50		 push	 eax
  00798	68 ff 00 00 00	 push	 255			; 000000ffH
  0079d	56		 push	 esi
  0079e	6a 7c		 push	 124			; 0000007cH
  007a0	57		 push	 edi
  007a1	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1126 : 								makeStringFromEscaped(freeName);

  007a6	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _freeName$13[ebp]
  007ac	50		 push	 eax
  007ad	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1127 : 								if (strlen(freeName) <= CHAR_FREENAME_LEN)

  007b2	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _freeName$13[ebp]
  007b8	83 c4 18	 add	 esp, 24			; 00000018H
  007bb	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  007be	66 90		 npad	 2
$LL417@lssproto_S:
  007c0	8a 01		 mov	 al, BYTE PTR [ecx]
  007c2	41		 inc	 ecx
  007c3	84 c0		 test	 al, al
  007c5	75 f9		 jne	 SHORT $LL417@lssproto_S
  007c7	2b ca		 sub	 ecx, edx
  007c9	83 f9 20	 cmp	 ecx, 32			; 00000020H
  007cc	77 79		 ja	 SHORT $LN98@lssproto_S

; 1128 : 									strcpy(pc.freeName, freeName);

  007ce	33 c9		 xor	 ecx, ecx
$LL247@lssproto_S:
  007d0	8a 84 0d e8 fe
	ff ff		 mov	 al, BYTE PTR _freeName$13[ebp+ecx]
  007d7	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  007da	88 81 80 00 00
	00		 mov	 BYTE PTR ?pc@@3UPC@@A[ecx+128], al
  007e0	84 c0		 test	 al, al
  007e2	75 ec		 jne	 SHORT $LL247@lssproto_S

; 1129 : 								i++;
; 1130 : 							}

  007e4	eb 61		 jmp	 SHORT $LN98@lssproto_S
$LN99@lssproto_S:

; 1131 : 							else if (mask == 0x08000000) // ( 1 << 27 )

  007e6	81 fb 00 00 00
	08		 cmp	 ebx, 134217728		; 08000000H
  007ec	75 10		 jne	 SHORT $LN102@lssproto_S

; 1132 : 							{
; 1133 : 								pc.ridePetNo = getIntegerToken(data, S_DELIM, i);// 0x08000000

  007ee	56		 push	 esi
  007ef	6a 7c		 push	 124			; 0000007cH
  007f1	57		 push	 edi
  007f2	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  007f7	a3 18 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20760, eax

; 1134 : 								i++;
; 1135 : 							}

  007fc	eb 46		 jmp	 SHORT $LN442@lssproto_S
$LN102@lssproto_S:

; 1136 : 							else if (mask == 0x10000000) // ( 1 << 28 )

  007fe	81 fb 00 00 00
	10		 cmp	 ebx, 268435456		; 10000000H
  00804	75 10		 jne	 SHORT $LN104@lssproto_S

; 1137 : 							{
; 1138 : 								pc.learnride = getIntegerToken(data, S_DELIM, i);// 0x10000000

  00806	56		 push	 esi
  00807	6a 7c		 push	 124			; 0000007cH
  00809	57		 push	 edi
  0080a	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0080f	a3 1c 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20764, eax

; 1139 : 								i++;
; 1140 : 							}

  00814	eb 2e		 jmp	 SHORT $LN442@lssproto_S
$LN104@lssproto_S:

; 1141 : 							else if (mask == 0x20000000) // ( 1 << 29 )

  00816	81 fb 00 00 00
	20		 cmp	 ebx, 536870912		; 20000000H
  0081c	75 10		 jne	 SHORT $LN106@lssproto_S

; 1142 : 							{
; 1143 : 								pc.baseGraNo = getIntegerToken(data, S_DELIM, i);// 0x20000000

  0081e	56		 push	 esi
  0081f	6a 7c		 push	 124			; 0000007cH
  00821	57		 push	 edi
  00822	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00827	a3 50 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20816, eax

; 1144 : 								i++;
; 1145 : 							}

  0082c	eb 16		 jmp	 SHORT $LN442@lssproto_S
$LN106@lssproto_S:

; 1146 : 							else if (mask == 0x40000000) // ( 1 << 30 )

  0082e	81 fb 00 00 00
	40		 cmp	 ebx, 1073741824		; 40000000H
  00834	75 18		 jne	 SHORT $LN4@lssproto_S

; 1147 : 							{
; 1148 : 								pc.skywalker = getIntegerToken(data, S_DELIM, i);// 0x40000000

  00836	56		 push	 esi
  00837	6a 7c		 push	 124			; 0000007cH
  00839	57		 push	 edi
  0083a	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0083f	a3 bc a1 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+41404, eax
$LN442@lssproto_S:

; 991  : 					for (; mask > 0; mask <<= 1)

  00844	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN98@lssproto_S:
  00847	8b 85 8c fc ff
	ff		 mov	 eax, DWORD PTR _kubun$1$[ebp]
  0084d	46		 inc	 esi
$LN4@lssproto_S:
  0084e	03 db		 add	 ebx, ebx
  00850	0f 85 4a fc ff
	ff		 jne	 $LL6@lssproto_S
  00856	83 cb ff	 or	 ebx, -1
$LN5@lssproto_S:

; 1149 : 								i++;
; 1150 : 							}
; 1151 : 							//else if (mask == 0x80000000 ){ // ( 1 << 31 )
; 1152 : 								//	pc.debugmode = getIntegerToken(data, S_DELIM, i);// 0x80000000
; 1153 : 								//	i++;
; 1154 : 							//}
; 1155 : 						}
; 1156 : 					}
; 1157 : 				}
; 1158 : 				updataPcAct();

  00859	e8 00 00 00 00	 call	 ?updataPcAct@@YAXXZ	; updataPcAct

; 1159 : 				if ((pc.status & CHR_STATUS_LEADER) != 0 && party[0].useFlag != 0)

  0085e	f7 05 a4 00 00
	00 00 01 00 00	 test	 DWORD PTR ?pc@@3UPC@@A+164, 256 ; 00000100H
  00868	74 49		 je	 SHORT $LN109@lssproto_S
  0086a	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR ?party@@3PAUPARTY@@A, 0
  00872	74 3f		 je	 SHORT $LN109@lssproto_S

; 1160 : 				{
; 1161 : 					party[0].level = pc.level;

  00874	a1 38 00 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+56

; 1162 : 					party[0].maxHp = pc.maxHp;

  00879	33 c9		 xor	 ecx, ecx
  0087b	a3 08 00 00 00	 mov	 DWORD PTR ?party@@3PAUPARTY@@A+8, eax
  00880	a1 14 00 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+20
  00885	a3 0c 00 00 00	 mov	 DWORD PTR ?party@@3PAUPARTY@@A+12, eax

; 1163 : 					party[0].hp = pc.hp;

  0088a	a1 10 00 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+16
  0088f	a3 10 00 00 00	 mov	 DWORD PTR ?party@@3PAUPARTY@@A+16, eax
  00894	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL248@lssproto_S:

; 1164 : 					strcpy(party[0].name, pc.name);

  008a0	8a 81 70 00 00
	00		 mov	 al, BYTE PTR ?pc@@3UPC@@A[ecx+112]
  008a6	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  008a9	88 81 17 00 00
	00		 mov	 BYTE PTR ?party@@3PAUPARTY@@A[ecx+23], al
  008af	84 c0		 test	 al, al
  008b1	75 ed		 jne	 SHORT $LL248@lssproto_S
$LN109@lssproto_S:

; 1165 : 				}
; 1166 : 			}
; 1167 : 			if (!bNewServer)

  008b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?bNewServer@@3HA ; bNewServer
  008b9	85 c9		 test	 ecx, ecx
  008bb	a1 18 51 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+20760
  008c0	0f 44 c3	 cmove	 eax, ebx

; 1168 : 				pc.ridePetNo = -1;
; 1169 : 			if ((bNewServer & 0xf000000) == 0xf000000 && sPetStatFlag == 1)

  008c3	81 e1 00 00 00
	0f		 and	 ecx, 251658240		; 0f000000H
  008c9	a3 18 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20760, eax
  008ce	81 f9 00 00 00
	0f		 cmp	 ecx, 251658240		; 0f000000H
  008d4	0f 85 ac 19 00
	00		 jne	 $LN439@lssproto_S
  008da	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?sPetStatFlag@@3HA, 1 ; sPetStatFlag
  008e1	0f 85 9f 19 00
	00		 jne	 $LN439@lssproto_S

; 1170 : 				saveUserSetting();

  008e7	e8 00 00 00 00	 call	 ?saveUserSetting@@YAHXZ	; saveUserSetting
  008ec	5e		 pop	 esi
  008ed	5b		 pop	 ebx
  008ee	5f		 pop	 edi

; 1803 : 			}
; 1804 : 			break;
; 1805 :     }
; 1806 : } 

  008ef	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  008f2	33 cd		 xor	 ecx, ebp
  008f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  008f9	8b e5		 mov	 esp, ebp
  008fb	5d		 pop	 ebp
  008fc	c3		 ret	 0
$LN112@lssproto_S:

; 1171 : 			break;
; 1172 : 		case 'F':
; 1173 : 			char familyName[256];
; 1174 : 
; 1175 : 			data++;
; 1176 : 			getStringToken(data, S_DELIM, 1, sizeof(familyName) - 1, familyName);

  008fd	8d 85 90 fc ff
	ff		 lea	 eax, DWORD PTR _familyName$2[ebp]
  00903	47		 inc	 edi
  00904	50		 push	 eax
  00905	68 ff 00 00 00	 push	 255			; 000000ffH
  0090a	6a 01		 push	 1
  0090c	6a 7c		 push	 124			; 0000007cH
  0090e	57		 push	 edi
  0090f	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1177 : 			makeStringFromEscaped(familyName);

  00914	8d 85 90 fc ff
	ff		 lea	 eax, DWORD PTR _familyName$2[ebp]
  0091a	50		 push	 eax
  0091b	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1178 : 			if (strlen(familyName) <= CHAR_NAME_LEN)

  00920	8d 8d 90 fc ff
	ff		 lea	 ecx, DWORD PTR _familyName$2[ebp]
  00926	83 c4 18	 add	 esp, 24			; 00000018H
  00929	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0092c	0f 1f 40 00	 npad	 4
$LL418@lssproto_S:
  00930	8a 01		 mov	 al, BYTE PTR [ecx]
  00932	41		 inc	 ecx
  00933	84 c0		 test	 al, al
  00935	75 f9		 jne	 SHORT $LL418@lssproto_S
  00937	2b ca		 sub	 ecx, edx
  00939	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0093c	77 16		 ja	 SHORT $LN113@lssproto_S

; 1179 : 				strcpy(pc.familyName, familyName);

  0093e	33 c9		 xor	 ecx, ecx
$LL249@lssproto_S:
  00940	8a 84 0d 90 fc
	ff ff		 mov	 al, BYTE PTR _familyName$2[ebp+ecx]
  00947	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  0094a	88 81 f5 50 00
	00		 mov	 BYTE PTR ?pc@@3UPC@@A[ecx+20725], al
  00950	84 c0		 test	 al, al
  00952	75 ec		 jne	 SHORT $LL249@lssproto_S
$LN113@lssproto_S:

; 1180 : 			pc.familyleader = getIntegerToken(data, S_DELIM, 2);

  00954	6a 02		 push	 2
  00956	6a 7c		 push	 124			; 0000007cH
  00958	57		 push	 edi
  00959	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1181 : 			pc.channel = getIntegerToken(data, S_DELIM, 3);

  0095e	6a 03		 push	 3
  00960	6a 7c		 push	 124			; 0000007cH
  00962	57		 push	 edi
  00963	a3 08 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20744, eax
  00968	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1182 : 			pc.familySprite = getIntegerToken(data, S_DELIM, 4);

  0096d	6a 04		 push	 4
  0096f	6a 7c		 push	 124			; 0000007cH
  00971	57		 push	 edi
  00972	a3 0c 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20748, eax
  00977	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1183 : 			pc.big4fm =	getIntegerToken(data, S_DELIM, 5);

  0097c	6a 05		 push	 5
  0097e	6a 7c		 push	 124			; 0000007cH
  00980	57		 push	 edi
  00981	a3 4c 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20812, eax
  00986	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0098b	83 c4 30	 add	 esp, 48			; 00000030H
  0098e	a3 7c a1 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+41340, eax

; 1184 : #ifdef _CHANNEL_MODIFY
; 1185 : 			if (pc.familyleader == FMMEMBER_NONE)

  00993	83 3d 08 51 00
	00 ff		 cmp	 DWORD PTR ?pc@@3UPC@@A+20744, -1
  0099a	0f 85 e6 18 00
	00		 jne	 $LN439@lssproto_S

; 1186 : 			{
; 1187 : 				pc.etcFlag &= ~PC_ETCFLAG_CHAT_FM;

  009a0	5e		 pop	 esi
  009a1	b8 7f ff 00 00	 mov	 eax, 65407		; 0000ff7fH

; 1188 : 				TalkMode = 0;

  009a6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?TalkMode@@3HA, 0 ; TalkMode
  009b0	66 21 05 a8 00
	00 00		 and	 WORD PTR ?pc@@3UPC@@A+168, ax
  009b7	5b		 pop	 ebx
  009b8	5f		 pop	 edi

; 1803 : 			}
; 1804 : 			break;
; 1805 :     }
; 1806 : } 

  009b9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  009bc	33 cd		 xor	 ecx, ebp
  009be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009c3	8b e5		 mov	 esp, ebp
  009c5	5d		 pop	 ebp
  009c6	c3		 ret	 0
$LN115@lssproto_S:

; 1189 : 			}
; 1190 : #endif
; 1191 : 			break;
; 1192 : 		// HP,MP,EXP
; 1193 : 		case 'M':
; 1194 : 			data++;
; 1195 : 			pc.hp  = getIntegerToken(data, '|', 1);

  009c7	6a 01		 push	 1
  009c9	47		 inc	 edi
  009ca	6a 7c		 push	 124			; 0000007cH
  009cc	57		 push	 edi
  009cd	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1196 : 			pc.mp  = getIntegerToken(data, '|', 2);

  009d2	6a 02		 push	 2
  009d4	6a 7c		 push	 124			; 0000007cH
  009d6	57		 push	 edi
  009d7	a3 10 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+16, eax
  009dc	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1197 : 			pc.exp = getIntegerToken(data, '|', 3);

  009e1	6a 03		 push	 3
  009e3	6a 7c		 push	 124			; 0000007cH
  009e5	57		 push	 edi
  009e6	a3 18 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+24, eax
  009eb	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  009f0	83 c4 24	 add	 esp, 36			; 00000024H
  009f3	a3 30 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+48, eax

; 1198 : 			updataPcAct();

  009f8	e8 00 00 00 00	 call	 ?updataPcAct@@YAXXZ	; updataPcAct

; 1199 : 			if ((pc.status & CHR_STATUS_LEADER) != 0 && party[0].useFlag != 0)

  009fd	f7 05 a4 00 00
	00 00 01 00 00	 test	 DWORD PTR ?pc@@3UPC@@A+164, 256 ; 00000100H
  00a07	0f 84 79 18 00
	00		 je	 $LN439@lssproto_S
  00a0d	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR ?party@@3PAUPARTY@@A, 0
  00a15	0f 84 6b 18 00
	00		 je	 $LN439@lssproto_S

; 1200 : 				party[0].hp = pc.hp;

  00a1b	a1 10 00 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+16
  00a20	5e		 pop	 esi
  00a21	5b		 pop	 ebx
  00a22	a3 10 00 00 00	 mov	 DWORD PTR ?party@@3PAUPARTY@@A+16, eax
  00a27	5f		 pop	 edi

; 1803 : 			}
; 1804 : 			break;
; 1805 :     }
; 1806 : } 

  00a28	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a2b	33 cd		 xor	 ecx, ebp
  00a2d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a32	8b e5		 mov	 esp, ebp
  00a34	5d		 pop	 ebp
  00a35	c3		 ret	 0
$LN117@lssproto_S:

; 1201 : 			break;
; 1202 : 		case 'K':
; 1203 : 			{
; 1204 : 				char name[256], freeName[256];
; 1205 : 				int no, kubun, i;
; 1206 : 				unsigned int mask;
; 1207 : 
; 1208 : 				no = data[1] - '0';

  00a36	0f be 77 01	 movsx	 esi, BYTE PTR [edi+1]

; 1209 : 				data += 3;

  00a3a	83 c7 03	 add	 edi, 3

; 1210 : 				kubun = getInteger62Token(data, S_DELIM, 1);

  00a3d	6a 01		 push	 1
  00a3f	6a 7c		 push	 124			; 0000007cH
  00a41	57		 push	 edi
  00a42	83 ee 30	 sub	 esi, 48			; 00000030H
  00a45	e8 00 00 00 00	 call	 ?getInteger62Token@@YAHPADDH@Z ; getInteger62Token
  00a4a	69 de 78 0b 00
	00		 imul	 ebx, esi, 2936
  00a50	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a53	89 85 88 fc ff
	ff		 mov	 DWORD PTR _kubun$1$[ebp], eax
  00a59	89 9d 8c fc ff
	ff		 mov	 DWORD PTR tv7837[ebp], ebx

; 1211 : 				if (kubun == 0){

  00a5f	85 c0		 test	 eax, eax
  00a61	75 54		 jne	 SHORT $LN118@lssproto_S

; 1212 : 					if (pet[no].useFlag){

  00a63	66 39 83 76 00
	00 00		 cmp	 WORD PTR ?pet@@3PAUPET@@A[ebx+118], ax
  00a6a	74 31		 je	 SHORT $LN119@lssproto_S

; 1213 : 						if (no == pc.battlePetNo)

  00a6c	0f bf 05 aa 00
	00 00		 movsx	 eax, WORD PTR ?pc@@3UPC@@A+170
  00a73	83 c9 ff	 or	 ecx, -1
  00a76	3b f0		 cmp	 esi, eax
  00a78	75 07		 jne	 SHORT $LN120@lssproto_S

; 1214 : 							pc.battlePetNo = -1;

  00a7a	66 89 0d aa 00
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A+170, cx
$LN120@lssproto_S:

; 1215 : 						if (no == pc.mailPetNo)

  00a81	0f bf 05 b6 00
	00 00		 movsx	 eax, WORD PTR ?pc@@3UPC@@A+182
  00a88	3b f0		 cmp	 esi, eax
  00a8a	75 07		 jne	 SHORT $LN121@lssproto_S

; 1216 : 							pc.mailPetNo = -1;

  00a8c	66 89 0d b6 00
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A+182, cx
$LN121@lssproto_S:

; 1217 : 						pc.selectPetNo[no] = FALSE;

  00a93	33 c0		 xor	 eax, eax
  00a95	66 89 04 75 ac
	00 00 00	 mov	 WORD PTR ?pc@@3UPC@@A[esi*2+172], ax
$LN119@lssproto_S:

; 1218 : 					}
; 1219 : 					pet[no].useFlag = 0;

  00a9d	33 c0		 xor	 eax, eax
  00a9f	5e		 pop	 esi
  00aa0	66 89 83 76 00
	00 00		 mov	 WORD PTR ?pet@@3PAUPET@@A[ebx+118], ax
  00aa7	5b		 pop	 ebx
  00aa8	5f		 pop	 edi

; 1803 : 			}
; 1804 : 			break;
; 1805 :     }
; 1806 : } 

  00aa9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00aac	33 cd		 xor	 ecx, ebp
  00aae	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ab3	8b e5		 mov	 esp, ebp
  00ab5	5d		 pop	 ebp
  00ab6	c3		 ret	 0
$LN118@lssproto_S:

; 1220 : 					break;
; 1221 : 				}
; 1222 : 				pet[no].useFlag = 1;

  00ab7	b9 01 00 00 00	 mov	 ecx, 1
  00abc	66 89 8b 76 00
	00 00		 mov	 WORD PTR ?pet@@3PAUPET@@A[ebx+118], cx

; 1223 : 				if (kubun == 1){

  00ac3	3b c1		 cmp	 eax, ecx
  00ac5	0f 85 fe 03 00
	00		 jne	 $LN122@lssproto_S

; 1224 : 					pet[no].graNo	= getIntegerToken(data, S_DELIM, 2);		// 0x00000002

  00acb	6a 02		 push	 2
  00acd	6a 7c		 push	 124			; 0000007cH
  00acf	57		 push	 edi
  00ad0	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1225 : 					pet[no].hp		= getIntegerToken(data, S_DELIM, 3);		// 0x00000004

  00ad5	6a 03		 push	 3
  00ad7	6a 7c		 push	 124			; 0000007cH
  00ad9	57		 push	 edi
  00ada	89 83 04 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+4], eax
  00ae0	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1226 : 					pet[no].maxHp	= getIntegerToken(data, S_DELIM, 4);		// 0x00000008

  00ae5	6a 04		 push	 4
  00ae7	6a 7c		 push	 124			; 0000007cH
  00ae9	57		 push	 edi
  00aea	89 83 08 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+8], eax
  00af0	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1227 : 					pet[no].mp		= getIntegerToken(data, S_DELIM, 5);		// 0x00000010

  00af5	6a 05		 push	 5
  00af7	6a 7c		 push	 124			; 0000007cH
  00af9	57		 push	 edi
  00afa	89 83 0c 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+12], eax
  00b00	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1228 : 					pet[no].maxMp	= getIntegerToken(data, S_DELIM, 6);		// 0x00000020

  00b05	6a 06		 push	 6
  00b07	6a 7c		 push	 124			; 0000007cH
  00b09	57		 push	 edi
  00b0a	89 83 10 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+16], eax
  00b10	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1229 : 					pet[no].exp		= getIntegerToken(data, S_DELIM, 7);		// 0x00000040

  00b15	6a 07		 push	 7
  00b17	6a 7c		 push	 124			; 0000007cH
  00b19	57		 push	 edi
  00b1a	89 83 14 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+20], eax
  00b20	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00b25	83 c4 48	 add	 esp, 72			; 00000048H
  00b28	89 83 18 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+24], eax

; 1230 : 					pet[no].maxExp	= getIntegerToken(data, S_DELIM, 8);		// 0x00000080

  00b2e	6a 08		 push	 8
  00b30	6a 7c		 push	 124			; 0000007cH
  00b32	57		 push	 edi
  00b33	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1231 : 					pet[no].level	= getIntegerToken(data, S_DELIM, 9);		// 0x00000100

  00b38	6a 09		 push	 9
  00b3a	6a 7c		 push	 124			; 0000007cH
  00b3c	57		 push	 edi
  00b3d	89 83 1c 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+28], eax
  00b43	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1232 : 					pet[no].atk		= getIntegerToken(data, S_DELIM, 10);		// 0x00000200

  00b48	6a 0a		 push	 10			; 0000000aH
  00b4a	6a 7c		 push	 124			; 0000007cH
  00b4c	57		 push	 edi
  00b4d	89 83 20 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+32], eax
  00b53	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1233 : 					pet[no].def		= getIntegerToken(data, S_DELIM, 11);		// 0x00000400

  00b58	6a 0b		 push	 11			; 0000000bH
  00b5a	6a 7c		 push	 124			; 0000007cH
  00b5c	57		 push	 edi
  00b5d	89 83 24 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+36], eax
  00b63	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1234 : 					pet[no].quick	= getIntegerToken(data, S_DELIM, 12);		// 0x00000800

  00b68	6a 0c		 push	 12			; 0000000cH
  00b6a	6a 7c		 push	 124			; 0000007cH
  00b6c	57		 push	 edi
  00b6d	89 83 28 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+40], eax
  00b73	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1235 : 					pet[no].ai		= getIntegerToken(data, S_DELIM, 13);		// 0x00001000

  00b78	6a 0d		 push	 13			; 0000000dH
  00b7a	6a 7c		 push	 124			; 0000007cH
  00b7c	57		 push	 edi
  00b7d	89 83 2c 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+44], eax
  00b83	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00b88	83 c4 48	 add	 esp, 72			; 00000048H
  00b8b	89 83 30 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+48], eax

; 1236 : 					pet[no].earth	= getIntegerToken(data, S_DELIM, 14);		// 0x00002000

  00b91	6a 0e		 push	 14			; 0000000eH
  00b93	6a 7c		 push	 124			; 0000007cH
  00b95	57		 push	 edi
  00b96	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1237 : 					pet[no].water	= getIntegerToken(data, S_DELIM, 15);		// 0x00004000

  00b9b	6a 0f		 push	 15			; 0000000fH
  00b9d	6a 7c		 push	 124			; 0000007cH
  00b9f	57		 push	 edi
  00ba0	89 83 34 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+52], eax
  00ba6	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1238 : 					pet[no].fire	= getIntegerToken(data, S_DELIM, 16);		// 0x00008000

  00bab	6a 10		 push	 16			; 00000010H
  00bad	6a 7c		 push	 124			; 0000007cH
  00baf	57		 push	 edi
  00bb0	89 83 38 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+56], eax
  00bb6	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1239 : 					pet[no].wind	= getIntegerToken(data, S_DELIM, 17);		// 0x00010000

  00bbb	6a 11		 push	 17			; 00000011H
  00bbd	6a 7c		 push	 124			; 0000007cH
  00bbf	57		 push	 edi
  00bc0	89 83 3c 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+60], eax
  00bc6	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1240 : 					pet[no].maxSkill= getIntegerToken(data, S_DELIM, 18);		// 0x00020000

  00bcb	6a 12		 push	 18			; 00000012H
  00bcd	6a 7c		 push	 124			; 0000007cH
  00bcf	57		 push	 edi
  00bd0	89 83 40 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+64], eax
  00bd6	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1241 : 					pet[no].changeNameFlag = getIntegerToken(data, S_DELIM, 19);// 0x00040000

  00bdb	6a 13		 push	 19			; 00000013H
  00bdd	6a 7c		 push	 124			; 0000007cH
  00bdf	57		 push	 edi
  00be0	89 83 44 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+68], eax
  00be6	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00beb	83 c4 48	 add	 esp, 72			; 00000048H
  00bee	66 89 83 78 00
	00 00		 mov	 WORD PTR ?pet@@3PAUPET@@A[ebx+120], ax

; 1242 : 					pet[no].trn = getIntegerToken(data , S_DELIM, 20);

  00bf5	6a 14		 push	 20			; 00000014H
  00bf7	6a 7c		 push	 124			; 0000007cH
  00bf9	57		 push	 edi
  00bfa	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1243 : #ifdef _SHOW_FUSION
; 1244 : 					pet[no].fusion = getIntegerToken(data , S_DELIM, 21);

  00bff	6a 15		 push	 21			; 00000015H
  00c01	6a 7c		 push	 124			; 0000007cH
  00c03	57		 push	 edi
  00c04	89 83 48 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+72], eax
  00c0a	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00c0f	89 83 4c 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+76], eax

; 1245 : 					getStringToken(data, S_DELIM, 22, sizeof(name) - 1, name);// 0x00080000

  00c15	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _name$12[ebp]
  00c1b	50		 push	 eax
  00c1c	68 ff 00 00 00	 push	 255			; 000000ffH
  00c21	6a 16		 push	 22			; 00000016H
  00c23	6a 7c		 push	 124			; 0000007cH
  00c25	57		 push	 edi
  00c26	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1246 : 					makeStringFromEscaped(name);

  00c2b	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _name$12[ebp]
  00c31	50		 push	 eax
  00c32	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1247 : 					if (strlen(name) <= PET_NAME_LEN)

  00c37	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _name$12[ebp]
  00c3d	83 c4 30	 add	 esp, 48			; 00000030H
  00c40	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL419@lssproto_S:
  00c43	8a 01		 mov	 al, BYTE PTR [ecx]
  00c45	41		 inc	 ecx
  00c46	84 c0		 test	 al, al
  00c48	75 f9		 jne	 SHORT $LL419@lssproto_S
  00c4a	2b ca		 sub	 ecx, edx
  00c4c	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00c4f	77 1f		 ja	 SHORT $LN124@lssproto_S

; 1248 : 						strcpy(pet[no].name, name);

  00c51	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _name$12[ebp]
  00c57	8b d3		 mov	 edx, ebx
  00c59	8b c1		 mov	 eax, ecx
  00c5b	2b d0		 sub	 edx, eax
  00c5d	0f 1f 00	 npad	 3
$LL250@lssproto_S:
  00c60	8a 01		 mov	 al, BYTE PTR [ecx]
  00c62	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00c65	88 84 11 53 00
	00 00		 mov	 BYTE PTR ?pet@@3PAUPET@@A[ecx+edx+83], al
  00c6c	84 c0		 test	 al, al
  00c6e	75 f0		 jne	 SHORT $LL250@lssproto_S
$LN124@lssproto_S:

; 1249 : 					getStringToken(data, S_DELIM, 23, sizeof(freeName) - 1, freeName);// 0x00100000

  00c70	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _freeName$7[ebp]
  00c76	50		 push	 eax
  00c77	68 ff 00 00 00	 push	 255			; 000000ffH
  00c7c	6a 17		 push	 23			; 00000017H
  00c7e	6a 7c		 push	 124			; 0000007cH
  00c80	57		 push	 edi
  00c81	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1250 : 					makeStringFromEscaped(freeName);

  00c86	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _freeName$7[ebp]
  00c8c	50		 push	 eax
  00c8d	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1251 : 					if (strlen(freeName) <= PET_NAME_LEN)

  00c92	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _freeName$7[ebp]
  00c98	83 c4 18	 add	 esp, 24			; 00000018H
  00c9b	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00c9e	66 90		 npad	 2
$LL420@lssproto_S:
  00ca0	8a 01		 mov	 al, BYTE PTR [ecx]
  00ca2	41		 inc	 ecx
  00ca3	84 c0		 test	 al, al
  00ca5	75 f9		 jne	 SHORT $LL420@lssproto_S
  00ca7	2b ca		 sub	 ecx, edx
  00ca9	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00cac	77 22		 ja	 SHORT $LN125@lssproto_S

; 1252 : 						strcpy(pet[no].freeName, freeName);

  00cae	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _freeName$7[ebp]
  00cb4	8b d3		 mov	 edx, ebx
  00cb6	8b c1		 mov	 eax, ecx
  00cb8	2b d0		 sub	 edx, eax
  00cba	66 0f 1f 44 00
	00		 npad	 6
$LL251@lssproto_S:
  00cc0	8a 01		 mov	 al, BYTE PTR [ecx]
  00cc2	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00cc5	88 84 11 64 00
	00 00		 mov	 BYTE PTR ?pet@@3PAUPET@@A[ecx+edx+100], al
  00ccc	84 c0		 test	 al, al
  00cce	75 f0		 jne	 SHORT $LL251@lssproto_S
$LN125@lssproto_S:

; 1253 : #else
; 1254 : 					getStringToken(data, S_DELIM, 21, sizeof(name) - 1, name);// 0x00080000
; 1255 : 					makeStringFromEscaped(name);
; 1256 : 					if (strlen(name) <= PET_NAME_LEN)
; 1257 : 						strcpy(pet[no].name, name);
; 1258 : 					getStringToken(data, S_DELIM, 22, sizeof(freeName) - 1, freeName);// 0x00100000
; 1259 : 					makeStringFromEscaped(freeName);
; 1260 : 					if (strlen(freeName) <= PET_NAME_LEN)
; 1261 : 						strcpy(pet[no].freeName, freeName);
; 1262 : #endif
; 1263 : #ifdef _NB_å® ç‰©ç»‘å®šå€¼
; 1264 : 					char ç»‘å®šæ ‡å¿—[2];
; 1265 : 					getStringToken(data, S_DELIM, 24, sizeof(ç»‘å®šæ ‡å¿—) - 1, ç»‘å®šæ ‡å¿—);// 0x00100000

  00cd0	8d 85 8c fc ff
	ff		 lea	 eax, DWORD PTR _?ïÒ?ò¤$1[ebp]
  00cd6	50		 push	 eax
  00cd7	6a 01		 push	 1
  00cd9	6a 18		 push	 24			; 00000018H
  00cdb	6a 7c		 push	 124			; 0000007cH
  00cdd	57		 push	 edi
  00cde	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1266 : 					makeStringFromEscaped(ç»‘å®šæ ‡å¿—);

  00ce3	8d 85 8c fc ff
	ff		 lea	 eax, DWORD PTR _?ïÒ?ò¤$1[ebp]
  00ce9	50		 push	 eax
  00cea	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1267 : 					char *temp2 = sunday(ç»‘å®šæ ‡å¿—, "*");

  00cef	8d 85 8c fc ff
	ff		 lea	 eax, DWORD PTR _?ïÒ?ò¤$1[ebp]
  00cf5	68 00 00 00 00	 push	 OFFSET ??_C@_01NBENCBCI@?$CK@
  00cfa	50		 push	 eax
  00cfb	e8 00 00 00 00	 call	 ?sunday@@YAPADPAD0@Z	; sunday

; 1268 : 					if (temp2){

  00d00	f7 d8		 neg	 eax

; 1269 : 						pet[no].petlock = 1;
; 1270 : 					}else{
; 1271 : 						pet[no].petlock = 0;
; 1272 : 					}
; 1273 : 
; 1274 : #endif
; 1275 : 					pet[no].petindex = getIntegerToken(data , S_DELIM, 25);//ç´¢å¼•

  00d02	6a 19		 push	 25			; 00000019H
  00d04	1b c0		 sbb	 eax, eax
  00d06	f7 d8		 neg	 eax
  00d08	6a 7c		 push	 124			; 0000007cH
  00d0a	57		 push	 edi
  00d0b	89 83 e0 0a 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+2784], eax
  00d11	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1276 : 					//printf("data[1]:%s\n",data);
; 1277 : #ifdef _NB_å® ç‰©åˆå§‹å€¼
; 1278 : 					pet[no].initlevel = getIntegerToken(data , S_DELIM, 26);//

  00d16	6a 1a		 push	 26			; 0000001aH
  00d18	6a 7c		 push	 124			; 0000007cH
  00d1a	57		 push	 edi
  00d1b	89 83 e4 0a 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+2788], eax
  00d21	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1279 : 					pet[no].inithp = getIntegerToken(data , S_DELIM, 27);

  00d26	6a 1b		 push	 27			; 0000001bH
  00d28	6a 7c		 push	 124			; 0000007cH
  00d2a	57		 push	 edi
  00d2b	89 83 e8 0a 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+2792], eax
  00d31	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00d36	83 c4 44	 add	 esp, 68			; 00000044H
  00d39	89 83 ec 0a 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+2796], eax

; 1280 : 					pet[no].initatk = getIntegerToken(data , S_DELIM, 28);

  00d3f	6a 1c		 push	 28			; 0000001cH
  00d41	6a 7c		 push	 124			; 0000007cH
  00d43	57		 push	 edi
  00d44	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1281 : 					pet[no].initdef = getIntegerToken(data , S_DELIM, 29);

  00d49	6a 1d		 push	 29			; 0000001dH
  00d4b	6a 7c		 push	 124			; 0000007cH
  00d4d	57		 push	 edi
  00d4e	89 83 f0 0a 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+2800], eax
  00d54	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1282 : 					pet[no].initquick = getIntegerToken(data , S_DELIM, 30);

  00d59	6a 1e		 push	 30			; 0000001eH
  00d5b	6a 7c		 push	 124			; 0000007cH
  00d5d	57		 push	 edi
  00d5e	89 83 f4 0a 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+2804], eax
  00d64	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1283 : 					pet[no].repetnum = getIntegerToken(data , S_DELIM, 39);

  00d69	6a 27		 push	 39			; 00000027H
  00d6b	6a 7c		 push	 124			; 0000007cH
  00d6d	57		 push	 edi
  00d6e	89 83 f8 0a 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+2808], eax
  00d74	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1284 : 					//printf("data[%d]:%d %d %d %d\n",no,pet[no].inithp,pet[no].initatk,pet[no].initdef,pet[no].initquick);
; 1285 : #endif
; 1286 : 					pet[no].hit_rate = getIntegerToken(data, S_DELIM, 40);

  00d79	6a 28		 push	 40			; 00000028H
  00d7b	6a 7c		 push	 124			; 0000007cH
  00d7d	57		 push	 edi
  00d7e	89 83 fc 0a 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+2812], eax
  00d84	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1287 : 					pet[no].crit_rate = getIntegerToken(data, S_DELIM, 41);

  00d89	6a 29		 push	 41			; 00000029H
  00d8b	6a 7c		 push	 124			; 0000007cH
  00d8d	57		 push	 edi
  00d8e	89 83 20 0b 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+2848], eax
  00d94	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00d99	83 c4 48	 add	 esp, 72			; 00000048H
  00d9c	89 83 24 0b 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+2852], eax

; 1288 : 					pet[no].avoid_rate = getIntegerToken(data, S_DELIM, 42);

  00da2	6a 2a		 push	 42			; 0000002aH
  00da4	6a 7c		 push	 124			; 0000007cH
  00da6	57		 push	 edi
  00da7	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1289 : 
; 1290 : 					pet[no].DATAHP   = getIntegerToken(data, S_DELIM, 43);

  00dac	6a 2b		 push	 43			; 0000002bH
  00dae	6a 7c		 push	 124			; 0000007cH
  00db0	57		 push	 edi
  00db1	89 83 28 0b 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+2856], eax
  00db7	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1291 : 					pet[no].DATASTR  = getIntegerToken(data, S_DELIM, 44);

  00dbc	6a 2c		 push	 44			; 0000002cH
  00dbe	6a 7c		 push	 124			; 0000007cH
  00dc0	57		 push	 edi
  00dc1	89 83 2c 0b 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+2860], eax
  00dc7	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00dcc	89 83 30 0b 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+2864], eax

; 1292 : 					pet[no].DATATGH  = getIntegerToken(data, S_DELIM, 45);

  00dd2	6a 2d		 push	 45			; 0000002dH
  00dd4	6a 7c		 push	 124			; 0000007cH
  00dd6	57		 push	 edi
  00dd7	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1293 : 					pet[no].DATADEX  = getIntegerToken(data, S_DELIM, 46);

  00ddc	6a 2e		 push	 46			; 0000002eH
  00dde	6a 7c		 push	 124			; 0000007cH
  00de0	57		 push	 edi
  00de1	89 83 34 0b 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+2868], eax
  00de7	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1294 : 					pet[no].SDATAVIT = getIntegerToken(data, S_DELIM, 47);

  00dec	6a 2f		 push	 47			; 0000002fH
  00dee	6a 7c		 push	 124			; 0000007cH
  00df0	57		 push	 edi
  00df1	89 83 38 0b 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+2872], eax
  00df7	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00dfc	83 c4 48	 add	 esp, 72			; 00000048H
  00dff	66 0f 6e c0	 movd	 xmm0, eax
  00e03	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0

; 1295 : 					pet[no].SDATASTR = getIntegerToken(data, S_DELIM, 48);

  00e07	6a 30		 push	 48			; 00000030H
  00e09	6a 7c		 push	 124			; 0000007cH
  00e0b	57		 push	 edi
  00e0c	f2 0f 11 83 40
	0b 00 00	 movsd	 QWORD PTR ?pet@@3PAUPET@@A[ebx+2880], xmm0
  00e14	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1296 : 					pet[no].SDATATGH = getIntegerToken(data, S_DELIM, 49);

  00e19	6a 31		 push	 49			; 00000031H
  00e1b	6a 7c		 push	 124			; 0000007cH
  00e1d	57		 push	 edi
  00e1e	66 0f 6e c0	 movd	 xmm0, eax
  00e22	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00e26	f2 0f 11 83 48
	0b 00 00	 movsd	 QWORD PTR ?pet@@3PAUPET@@A[ebx+2888], xmm0
  00e2e	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1297 : 					pet[no].SDATADEX = getIntegerToken(data, S_DELIM, 50);

  00e33	6a 32		 push	 50			; 00000032H
  00e35	6a 7c		 push	 124			; 0000007cH
  00e37	57		 push	 edi
  00e38	66 0f 6e c0	 movd	 xmm0, eax
  00e3c	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00e40	f2 0f 11 83 50
	0b 00 00	 movsd	 QWORD PTR ?pet@@3PAUPET@@A[ebx+2896], xmm0
  00e48	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1298 : 					pet[no].SDATAALL = getIntegerToken(data, S_DELIM, 51);

  00e4d	6a 33		 push	 51			; 00000033H
  00e4f	6a 7c		 push	 124			; 0000007cH
  00e51	57		 push	 edi
  00e52	66 0f 6e c0	 movd	 xmm0, eax
  00e56	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00e5a	f2 0f 11 83 58
	0b 00 00	 movsd	 QWORD PTR ?pet@@3PAUPET@@A[ebx+2904], xmm0
  00e62	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1299 : 					pet[no].DATARARE = getIntegerToken(data, S_DELIM, 52);

  00e67	6a 34		 push	 52			; 00000034H
  00e69	6a 7c		 push	 124			; 0000007cH
  00e6b	57		 push	 edi
  00e6c	66 0f 6e c0	 movd	 xmm0, eax
  00e70	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00e74	f2 0f 11 83 60
	0b 00 00	 movsd	 QWORD PTR ?pet@@3PAUPET@@A[ebx+2912], xmm0
  00e7c	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1300 : 					pet[no].DATARANK = getIntegerToken(data, S_DELIM, 53);

  00e81	6a 35		 push	 53			; 00000035H
  00e83	6a 7c		 push	 124			; 0000007cH
  00e85	57		 push	 edi
  00e86	89 83 68 0b 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+2920], eax
  00e8c	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00e91	83 c4 48	 add	 esp, 72			; 00000048H
  00e94	89 83 6c 0b 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+2924], eax

; 1301 : 
; 1302 : 					pet[no].reset = getIntegerToken(data, S_DELIM, 54);

  00e9a	6a 36		 push	 54			; 00000036H
  00e9c	6a 7c		 push	 124			; 0000007cH
  00e9e	57		 push	 edi
  00e9f	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1303 : 
; 1304 : 					printf("data[1]:%s\n",data);

  00ea4	57		 push	 edi
  00ea5	68 00 00 00 00	 push	 OFFSET ??_C@_0M@OMPDAMON@data?$FL1?$FN?3?$CFs?6@
  00eaa	89 83 70 0b 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ebx+2928], eax
  00eb0	e8 00 00 00 00	 call	 _printf
  00eb5	83 c4 14	 add	 esp, 20			; 00000014H
  00eb8	5e		 pop	 esi
  00eb9	5b		 pop	 ebx
  00eba	5f		 pop	 edi

; 1803 : 			}
; 1804 : 			break;
; 1805 :     }
; 1806 : } 

  00ebb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ebe	33 cd		 xor	 ecx, ebp
  00ec0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ec5	8b e5		 mov	 esp, ebp
  00ec7	5d		 pop	 ebp
  00ec8	c3		 ret	 0
$LN122@lssproto_S:

; 1305 : 				}else{
; 1306 : 					mask = 2;

  00ec9	bb 02 00 00 00	 mov	 ebx, 2

; 1307 : 					i = 2;

  00ece	8b f3		 mov	 esi, ebx
$LL9@lssproto_S:

; 1309 : 						if (kubun & mask){

  00ed0	85 d8		 test	 ebx, eax
  00ed2	0f 84 6f 03 00
	00		 je	 $LN7@lssproto_S

; 1310 : 							if (mask == 0x00000002){

  00ed8	83 fb 02	 cmp	 ebx, 2
  00edb	75 1d		 jne	 SHORT $LN129@lssproto_S

; 1311 : 								pet[no].graNo = getIntegerToken(data, S_DELIM, i);// 0x00000002

  00edd	56		 push	 esi
  00ede	6a 7c		 push	 124			; 0000007cH
  00ee0	57		 push	 edi
  00ee1	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00ee6	8b 8d 8c fc ff
	ff		 mov	 ecx, DWORD PTR tv7837[ebp]
  00eec	83 c4 0c	 add	 esp, 12			; 0000000cH
  00eef	89 81 04 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+4], eax

; 1312 : 								i++;

  00ef5	e9 46 03 00 00	 jmp	 $LN169@lssproto_S
$LN129@lssproto_S:

; 1313 : 							}else if (mask == 0x00000004){

  00efa	83 fb 04	 cmp	 ebx, 4
  00efd	75 1d		 jne	 SHORT $LN131@lssproto_S

; 1314 : 								pet[no].hp = getIntegerToken(data, S_DELIM, i);// 0x00000004

  00eff	56		 push	 esi
  00f00	6a 7c		 push	 124			; 0000007cH
  00f02	57		 push	 edi
  00f03	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00f08	8b 8d 8c fc ff
	ff		 mov	 ecx, DWORD PTR tv7837[ebp]
  00f0e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f11	89 81 08 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+8], eax

; 1315 : 								i++;

  00f17	e9 24 03 00 00	 jmp	 $LN169@lssproto_S
$LN131@lssproto_S:

; 1316 : 							}else if (mask == 0x00000008){

  00f1c	83 fb 08	 cmp	 ebx, 8
  00f1f	75 1d		 jne	 SHORT $LN133@lssproto_S

; 1317 : 								pet[no].maxHp = getIntegerToken(data, S_DELIM, i);// 0x00000008

  00f21	56		 push	 esi
  00f22	6a 7c		 push	 124			; 0000007cH
  00f24	57		 push	 edi
  00f25	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00f2a	8b 8d 8c fc ff
	ff		 mov	 ecx, DWORD PTR tv7837[ebp]
  00f30	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f33	89 81 0c 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+12], eax

; 1318 : 								i++;

  00f39	e9 02 03 00 00	 jmp	 $LN169@lssproto_S
$LN133@lssproto_S:

; 1319 : 							}else if (mask == 0x00000010){

  00f3e	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00f41	75 1d		 jne	 SHORT $LN135@lssproto_S

; 1320 : 								pet[no].mp = getIntegerToken(data, S_DELIM, i);// 0x00000010

  00f43	56		 push	 esi
  00f44	6a 7c		 push	 124			; 0000007cH
  00f46	57		 push	 edi
  00f47	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00f4c	8b 8d 8c fc ff
	ff		 mov	 ecx, DWORD PTR tv7837[ebp]
  00f52	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f55	89 81 10 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+16], eax

; 1321 : 								i++;

  00f5b	e9 e0 02 00 00	 jmp	 $LN169@lssproto_S
$LN135@lssproto_S:

; 1322 : 							}else if (mask == 0x00000020){

  00f60	83 fb 20	 cmp	 ebx, 32			; 00000020H
  00f63	75 1d		 jne	 SHORT $LN137@lssproto_S

; 1323 : 								pet[no].maxMp = getIntegerToken(data, S_DELIM, i);// 0x00000020

  00f65	56		 push	 esi
  00f66	6a 7c		 push	 124			; 0000007cH
  00f68	57		 push	 edi
  00f69	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00f6e	8b 8d 8c fc ff
	ff		 mov	 ecx, DWORD PTR tv7837[ebp]
  00f74	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f77	89 81 14 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+20], eax

; 1324 : 								i++;

  00f7d	e9 be 02 00 00	 jmp	 $LN169@lssproto_S
$LN137@lssproto_S:

; 1325 : 							}else if (mask == 0x00000040){

  00f82	83 fb 40	 cmp	 ebx, 64			; 00000040H
  00f85	75 1d		 jne	 SHORT $LN139@lssproto_S

; 1326 : 								pet[no].exp = getIntegerToken(data, S_DELIM, i);// 0x00000040

  00f87	56		 push	 esi
  00f88	6a 7c		 push	 124			; 0000007cH
  00f8a	57		 push	 edi
  00f8b	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00f90	8b 8d 8c fc ff
	ff		 mov	 ecx, DWORD PTR tv7837[ebp]
  00f96	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f99	89 81 18 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+24], eax

; 1327 : 								i++;

  00f9f	e9 9c 02 00 00	 jmp	 $LN169@lssproto_S
$LN139@lssproto_S:

; 1328 : 							}else if (mask == 0x00000080){

  00fa4	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  00faa	75 1d		 jne	 SHORT $LN141@lssproto_S

; 1329 : 								pet[no].maxExp = getIntegerToken(data, S_DELIM, i);// 0x00000080

  00fac	56		 push	 esi
  00fad	6a 7c		 push	 124			; 0000007cH
  00faf	57		 push	 edi
  00fb0	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00fb5	8b 8d 8c fc ff
	ff		 mov	 ecx, DWORD PTR tv7837[ebp]
  00fbb	83 c4 0c	 add	 esp, 12			; 0000000cH
  00fbe	89 81 1c 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+28], eax

; 1330 : 								i++;

  00fc4	e9 77 02 00 00	 jmp	 $LN169@lssproto_S
$LN141@lssproto_S:

; 1331 : 							}else if (mask == 0x00000100){

  00fc9	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  00fcf	75 1d		 jne	 SHORT $LN143@lssproto_S

; 1332 : 								pet[no].level = getIntegerToken(data, S_DELIM, i);// 0x00000100

  00fd1	56		 push	 esi
  00fd2	6a 7c		 push	 124			; 0000007cH
  00fd4	57		 push	 edi
  00fd5	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00fda	8b 8d 8c fc ff
	ff		 mov	 ecx, DWORD PTR tv7837[ebp]
  00fe0	83 c4 0c	 add	 esp, 12			; 0000000cH
  00fe3	89 81 20 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+32], eax

; 1333 : 								i++;

  00fe9	e9 52 02 00 00	 jmp	 $LN169@lssproto_S
$LN143@lssproto_S:

; 1334 : 							}else if (mask == 0x00000200){

  00fee	81 fb 00 02 00
	00		 cmp	 ebx, 512		; 00000200H
  00ff4	75 1d		 jne	 SHORT $LN145@lssproto_S

; 1335 : 								pet[no].atk = getIntegerToken(data, S_DELIM, i);// 0x00000200

  00ff6	56		 push	 esi
  00ff7	6a 7c		 push	 124			; 0000007cH
  00ff9	57		 push	 edi
  00ffa	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00fff	8b 8d 8c fc ff
	ff		 mov	 ecx, DWORD PTR tv7837[ebp]
  01005	83 c4 0c	 add	 esp, 12			; 0000000cH
  01008	89 81 24 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+36], eax

; 1336 : 								i++;

  0100e	e9 2d 02 00 00	 jmp	 $LN169@lssproto_S
$LN145@lssproto_S:

; 1337 : 							}else if (mask == 0x00000400){

  01013	81 fb 00 04 00
	00		 cmp	 ebx, 1024		; 00000400H
  01019	75 1d		 jne	 SHORT $LN147@lssproto_S

; 1338 : 								pet[no].def = getIntegerToken(data, S_DELIM, i);// 0x00000400

  0101b	56		 push	 esi
  0101c	6a 7c		 push	 124			; 0000007cH
  0101e	57		 push	 edi
  0101f	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01024	8b 8d 8c fc ff
	ff		 mov	 ecx, DWORD PTR tv7837[ebp]
  0102a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0102d	89 81 28 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+40], eax

; 1339 : 								i++;

  01033	e9 08 02 00 00	 jmp	 $LN169@lssproto_S
$LN147@lssproto_S:

; 1340 : 							}else if (mask == 0x00000800){

  01038	81 fb 00 08 00
	00		 cmp	 ebx, 2048		; 00000800H
  0103e	75 1d		 jne	 SHORT $LN149@lssproto_S

; 1341 : 								pet[no].quick = getIntegerToken(data, S_DELIM, i);// 0x00000800

  01040	56		 push	 esi
  01041	6a 7c		 push	 124			; 0000007cH
  01043	57		 push	 edi
  01044	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01049	8b 8d 8c fc ff
	ff		 mov	 ecx, DWORD PTR tv7837[ebp]
  0104f	83 c4 0c	 add	 esp, 12			; 0000000cH
  01052	89 81 2c 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+44], eax

; 1342 : 								i++;

  01058	e9 e3 01 00 00	 jmp	 $LN169@lssproto_S
$LN149@lssproto_S:

; 1343 : 							}else if (mask == 0x00001000 ){

  0105d	81 fb 00 10 00
	00		 cmp	 ebx, 4096		; 00001000H
  01063	75 1d		 jne	 SHORT $LN151@lssproto_S

; 1344 : 								pet[no].ai = getIntegerToken(data, S_DELIM, i);// 0x00001000

  01065	56		 push	 esi
  01066	6a 7c		 push	 124			; 0000007cH
  01068	57		 push	 edi
  01069	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0106e	8b 8d 8c fc ff
	ff		 mov	 ecx, DWORD PTR tv7837[ebp]
  01074	83 c4 0c	 add	 esp, 12			; 0000000cH
  01077	89 81 30 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+48], eax

; 1345 : 								i++;

  0107d	e9 be 01 00 00	 jmp	 $LN169@lssproto_S
$LN151@lssproto_S:

; 1346 : 							}else if (mask == 0x00002000){

  01082	81 fb 00 20 00
	00		 cmp	 ebx, 8192		; 00002000H
  01088	75 1d		 jne	 SHORT $LN153@lssproto_S

; 1347 : 								pet[no].earth = getIntegerToken(data, S_DELIM, i);// 0x00002000

  0108a	56		 push	 esi
  0108b	6a 7c		 push	 124			; 0000007cH
  0108d	57		 push	 edi
  0108e	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01093	8b 8d 8c fc ff
	ff		 mov	 ecx, DWORD PTR tv7837[ebp]
  01099	83 c4 0c	 add	 esp, 12			; 0000000cH
  0109c	89 81 34 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+52], eax

; 1348 : 								i++;

  010a2	e9 99 01 00 00	 jmp	 $LN169@lssproto_S
$LN153@lssproto_S:

; 1349 : 							}else if (mask == 0x00004000 ){

  010a7	81 fb 00 40 00
	00		 cmp	 ebx, 16384		; 00004000H
  010ad	75 1d		 jne	 SHORT $LN155@lssproto_S

; 1350 : 								pet[no].water = getIntegerToken(data, S_DELIM, i);// 0x00004000

  010af	56		 push	 esi
  010b0	6a 7c		 push	 124			; 0000007cH
  010b2	57		 push	 edi
  010b3	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  010b8	8b 8d 8c fc ff
	ff		 mov	 ecx, DWORD PTR tv7837[ebp]
  010be	83 c4 0c	 add	 esp, 12			; 0000000cH
  010c1	89 81 38 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+56], eax

; 1351 : 								i++;

  010c7	e9 74 01 00 00	 jmp	 $LN169@lssproto_S
$LN155@lssproto_S:

; 1352 : 							}else if (mask == 0x00008000){

  010cc	81 fb 00 80 00
	00		 cmp	 ebx, 32768		; 00008000H
  010d2	75 1d		 jne	 SHORT $LN157@lssproto_S

; 1353 : 								pet[no].fire = getIntegerToken(data, S_DELIM, i);// 0x00008000

  010d4	56		 push	 esi
  010d5	6a 7c		 push	 124			; 0000007cH
  010d7	57		 push	 edi
  010d8	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  010dd	8b 8d 8c fc ff
	ff		 mov	 ecx, DWORD PTR tv7837[ebp]
  010e3	83 c4 0c	 add	 esp, 12			; 0000000cH
  010e6	89 81 3c 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+60], eax

; 1354 : 								i++;

  010ec	e9 4f 01 00 00	 jmp	 $LN169@lssproto_S
$LN157@lssproto_S:

; 1355 : 							}else if (mask == 0x00010000){

  010f1	81 fb 00 00 01
	00		 cmp	 ebx, 65536		; 00010000H
  010f7	75 1d		 jne	 SHORT $LN159@lssproto_S

; 1356 : 								pet[no].wind = getIntegerToken(data, S_DELIM, i);// 0x00010000

  010f9	56		 push	 esi
  010fa	6a 7c		 push	 124			; 0000007cH
  010fc	57		 push	 edi
  010fd	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01102	8b 8d 8c fc ff
	ff		 mov	 ecx, DWORD PTR tv7837[ebp]
  01108	83 c4 0c	 add	 esp, 12			; 0000000cH
  0110b	89 81 40 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+64], eax

; 1357 : 								i++;

  01111	e9 2a 01 00 00	 jmp	 $LN169@lssproto_S
$LN159@lssproto_S:

; 1358 : 							}else if (mask == 0x00020000){

  01116	81 fb 00 00 02
	00		 cmp	 ebx, 131072		; 00020000H
  0111c	75 1d		 jne	 SHORT $LN161@lssproto_S

; 1359 : 								pet[no].maxSkill = getIntegerToken(data, S_DELIM, i);// 0x00020000

  0111e	56		 push	 esi
  0111f	6a 7c		 push	 124			; 0000007cH
  01121	57		 push	 edi
  01122	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01127	8b 8d 8c fc ff
	ff		 mov	 ecx, DWORD PTR tv7837[ebp]
  0112d	83 c4 0c	 add	 esp, 12			; 0000000cH
  01130	89 81 44 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+68], eax

; 1360 : 								i++;

  01136	e9 05 01 00 00	 jmp	 $LN169@lssproto_S
$LN161@lssproto_S:

; 1361 : 							}else if (mask == 0x00040000){

  0113b	81 fb 00 00 04
	00		 cmp	 ebx, 262144		; 00040000H
  01141	75 1e		 jne	 SHORT $LN163@lssproto_S

; 1362 : 								pet[no].changeNameFlag = getIntegerToken(data, S_DELIM, i);// 0x00040000

  01143	56		 push	 esi
  01144	6a 7c		 push	 124			; 0000007cH
  01146	57		 push	 edi
  01147	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0114c	8b 8d 8c fc ff
	ff		 mov	 ecx, DWORD PTR tv7837[ebp]
  01152	83 c4 0c	 add	 esp, 12			; 0000000cH
  01155	66 89 81 78 00
	00 00		 mov	 WORD PTR ?pet@@3PAUPET@@A[ecx+120], ax

; 1363 : 								i++;

  0115c	e9 df 00 00 00	 jmp	 $LN169@lssproto_S
$LN163@lssproto_S:

; 1364 : 							}else if (mask == 0x00080000){

  01161	81 fb 00 00 08
	00		 cmp	 ebx, 524288		; 00080000H
  01167	75 69		 jne	 SHORT $LN165@lssproto_S

; 1365 : 								getStringToken(data, S_DELIM, i, sizeof(name) - 1, name);// 0x00080000

  01169	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _name$12[ebp]
  0116f	50		 push	 eax
  01170	68 ff 00 00 00	 push	 255			; 000000ffH
  01175	56		 push	 esi
  01176	6a 7c		 push	 124			; 0000007cH
  01178	57		 push	 edi
  01179	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1366 : 								makeStringFromEscaped(name);

  0117e	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _name$12[ebp]
  01184	50		 push	 eax
  01185	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1367 : 								if (strlen(name) <= PET_NAME_LEN)

  0118a	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _name$12[ebp]
  01190	83 c4 18	 add	 esp, 24			; 00000018H
  01193	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL421@lssproto_S:
  01196	8a 01		 mov	 al, BYTE PTR [ecx]
  01198	41		 inc	 ecx
  01199	84 c0		 test	 al, al
  0119b	75 f9		 jne	 SHORT $LL421@lssproto_S
  0119d	2b ca		 sub	 ecx, edx
  0119f	83 f9 10	 cmp	 ecx, 16			; 00000010H
  011a2	0f 87 98 00 00
	00		 ja	 $LN169@lssproto_S

; 1368 : 									strcpy(pet[no].name, name);

  011a8	8b 95 8c fc ff
	ff		 mov	 edx, DWORD PTR tv7837[ebp]
  011ae	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _name$12[ebp]
  011b4	8b c1		 mov	 eax, ecx
  011b6	2b d0		 sub	 edx, eax
  011b8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL252@lssproto_S:
  011c0	8a 01		 mov	 al, BYTE PTR [ecx]
  011c2	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  011c5	88 84 11 53 00
	00 00		 mov	 BYTE PTR ?pet@@3PAUPET@@A[ecx+edx+83], al
  011cc	84 c0		 test	 al, al
  011ce	75 f0		 jne	 SHORT $LL252@lssproto_S

; 1369 : 								i++;

  011d0	eb 6e		 jmp	 SHORT $LN169@lssproto_S
$LN165@lssproto_S:

; 1370 : 							}else if (mask == 0x00100000){

  011d2	81 fb 00 00 10
	00		 cmp	 ebx, 1048576		; 00100000H
  011d8	75 6d		 jne	 SHORT $LN7@lssproto_S

; 1371 : 								getStringToken(data, S_DELIM, i, sizeof(freeName) - 1, freeName);// 0x00100000

  011da	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _freeName$7[ebp]
  011e0	50		 push	 eax
  011e1	68 ff 00 00 00	 push	 255			; 000000ffH
  011e6	56		 push	 esi
  011e7	6a 7c		 push	 124			; 0000007cH
  011e9	57		 push	 edi
  011ea	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1372 : 								makeStringFromEscaped(freeName);

  011ef	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _freeName$7[ebp]
  011f5	50		 push	 eax
  011f6	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1373 : 								if (strlen(freeName) <= PET_NAME_LEN)

  011fb	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _freeName$7[ebp]
  01201	83 c4 18	 add	 esp, 24			; 00000018H
  01204	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL422@lssproto_S:
  01207	8a 01		 mov	 al, BYTE PTR [ecx]
  01209	41		 inc	 ecx
  0120a	84 c0		 test	 al, al
  0120c	75 f9		 jne	 SHORT $LL422@lssproto_S
  0120e	2b ca		 sub	 ecx, edx
  01210	83 f9 10	 cmp	 ecx, 16			; 00000010H
  01213	77 2b		 ja	 SHORT $LN169@lssproto_S

; 1374 : 									strcpy(pet[no].freeName, freeName);

  01215	8b 95 8c fc ff
	ff		 mov	 edx, DWORD PTR tv7837[ebp]
  0121b	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _freeName$7[ebp]
  01221	8b c1		 mov	 eax, ecx
  01223	2b d0		 sub	 edx, eax
  01225	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL253@lssproto_S:
  01230	8a 01		 mov	 al, BYTE PTR [ecx]
  01232	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  01235	88 84 11 64 00
	00 00		 mov	 BYTE PTR ?pet@@3PAUPET@@A[ecx+edx+100], al
  0123c	84 c0		 test	 al, al
  0123e	75 f0		 jne	 SHORT $LL253@lssproto_S
$LN169@lssproto_S:

; 1308 : 					for (; mask > 0; mask <<= 1){

  01240	8b 85 88 fc ff
	ff		 mov	 eax, DWORD PTR _kubun$1$[ebp]
  01246	46		 inc	 esi
$LN7@lssproto_S:
  01247	03 db		 add	 ebx, ebx
  01249	0f 85 81 fc ff
	ff		 jne	 $LL9@lssproto_S
  0124f	5e		 pop	 esi
  01250	5b		 pop	 ebx
  01251	5f		 pop	 edi

; 1803 : 			}
; 1804 : 			break;
; 1805 :     }
; 1806 : } 

  01252	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01255	33 cd		 xor	 ecx, ebp
  01257	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0125c	8b e5		 mov	 esp, ebp
  0125e	5d		 pop	 ebp
  0125f	c3		 ret	 0
$LN170@lssproto_S:

; 1375 : 								i++;
; 1376 : 							}
; 1377 : 							//printf("petdata[2]:%s\n",data);
; 1378 : 						}
; 1379 : 					}
; 1380 : 				}
; 1381 : 
; 1382 : 			}
; 1383 : 			break; 
; 1384 : 		case 'E':
; 1385 : 			{
; 1386 : 				data++;
; 1387 : 				minEncountPercentage = getIntegerToken(data, S_DELIM, 1);

  01260	6a 01		 push	 1
  01262	47		 inc	 edi
  01263	6a 7c		 push	 124			; 0000007cH
  01265	57		 push	 edi
  01266	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1388 : 				maxEncountPercentage = getIntegerToken(data, S_DELIM, 2);

  0126b	6a 02		 push	 2
  0126d	6a 7c		 push	 124			; 0000007cH
  0126f	57		 push	 edi
  01270	66 a3 00 00 00
	00		 mov	 WORD PTR ?minEncountPercentage@@3FA, ax ; minEncountPercentage
  01276	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0127b	83 c4 18	 add	 esp, 24			; 00000018H
  0127e	66 a3 00 00 00
	00		 mov	 WORD PTR ?maxEncountPercentage@@3FA, ax ; maxEncountPercentage

; 1389 : 				nowEncountPercentage = minEncountPercentage;

  01284	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?minEncountPercentage@@3FA ; minEncountPercentage
  0128a	66 a3 00 00 00
	00		 mov	 WORD PTR ?nowEncountPercentage@@3FA, ax ; nowEncountPercentage
  01290	5e		 pop	 esi
  01291	5b		 pop	 ebx
  01292	5f		 pop	 edi

; 1803 : 			}
; 1804 : 			break;
; 1805 :     }
; 1806 : } 

  01293	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01296	33 cd		 xor	 ecx, ebp
  01298	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0129d	8b e5		 mov	 esp, ebp
  0129f	5d		 pop	 ebp
  012a0	c3		 ret	 0
$LN171@lssproto_S:

; 1390 : 			}
; 1391 : 			break;
; 1392 : 		case 'J':
; 1393 : 			{
; 1394 : 				char name[256], memo[256];
; 1395 : 				int no;
; 1396 : 
; 1397 : 				no = data[1] - '0';

  012a1	0f be 77 01	 movsx	 esi, BYTE PTR [edi+1]

; 1398 : 				data += 3;

  012a5	83 c7 03	 add	 edi, 3

; 1399 : 				magic[no].useFlag = getIntegerToken(data, S_DELIM, 1);

  012a8	6a 01		 push	 1
  012aa	6a 7c		 push	 124			; 0000007cH
  012ac	57		 push	 edi
  012ad	83 ee 30	 sub	 esi, 48			; 00000030H
  012b0	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  012b5	6b f6 70	 imul	 esi, esi, 112
  012b8	83 c4 0c	 add	 esp, 12			; 0000000cH
  012bb	0f b7 c0	 movzx	 eax, ax
  012be	66 89 86 00 00
	00 00		 mov	 WORD PTR ?magic@@3PAUMAGIC@@A[esi], ax

; 1400 : 				if (magic[no].useFlag == 0)

  012c5	66 85 c0	 test	 ax, ax
  012c8	0f 84 b8 0f 00
	00		 je	 $LN439@lssproto_S

; 1401 : 					break;
; 1402 : 				magic[no].mp		= getIntegerToken(data, S_DELIM, 2);

  012ce	6a 02		 push	 2
  012d0	6a 7c		 push	 124			; 0000007cH
  012d2	57		 push	 edi
  012d3	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1403 : 				magic[no].field		= getIntegerToken(data, S_DELIM, 3);

  012d8	6a 03		 push	 3
  012da	6a 7c		 push	 124			; 0000007cH
  012dc	57		 push	 edi
  012dd	89 86 04 00 00
	00		 mov	 DWORD PTR ?magic@@3PAUMAGIC@@A[esi+4], eax
  012e3	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1404 : 				magic[no].target	= getIntegerToken(data, S_DELIM, 4);

  012e8	6a 04		 push	 4
  012ea	6a 7c		 push	 124			; 0000007cH
  012ec	57		 push	 edi
  012ed	66 89 86 08 00
	00 00		 mov	 WORD PTR ?magic@@3PAUMAGIC@@A[esi+8], ax
  012f4	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  012f9	0f b7 c0	 movzx	 eax, ax
  012fc	83 c4 24	 add	 esp, 36			; 00000024H
  012ff	66 89 86 0a 00
	00 00		 mov	 WORD PTR ?magic@@3PAUMAGIC@@A[esi+10], ax

; 1405 : 				if (magic[no].target >= 100)

  01306	66 83 f8 64	 cmp	 ax, 100			; 00000064H
  0130a	7c 15		 jl	 SHORT $LN173@lssproto_S

; 1406 : 				{
; 1407 : 					magic[no].target %= 100;

  0130c	98		 cwde
  0130d	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  01312	99		 cdq
  01313	f7 f9		 idiv	 ecx

; 1408 : 					magic[no].deadTargetFlag = 1;

  01315	8d 41 9d	 lea	 eax, DWORD PTR [ecx-99]
  01318	66 89 96 0a 00
	00 00		 mov	 WORD PTR ?magic@@3PAUMAGIC@@A[esi+10], dx

; 1409 : 				}

  0131f	eb 02		 jmp	 SHORT $LN174@lssproto_S
$LN173@lssproto_S:

; 1410 : 				else
; 1411 : 					magic[no].deadTargetFlag = 0;

  01321	33 c0		 xor	 eax, eax
$LN174@lssproto_S:

; 1412 : 				getStringToken(data, S_DELIM, 5, sizeof(name) - 1, name);

  01323	66 89 86 0c 00
	00 00		 mov	 WORD PTR ?magic@@3PAUMAGIC@@A[esi+12], ax
  0132a	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _name$6[ebp]
  01330	50		 push	 eax
  01331	68 ff 00 00 00	 push	 255			; 000000ffH
  01336	6a 05		 push	 5
  01338	6a 7c		 push	 124			; 0000007cH
  0133a	57		 push	 edi
  0133b	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1413 : 				makeStringFromEscaped(name);

  01340	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _name$6[ebp]
  01346	50		 push	 eax
  01347	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1414 : 				if (strlen(name) <= sizeof(magic[no].name) - 1)

  0134c	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _name$6[ebp]
  01352	83 c4 18	 add	 esp, 24			; 00000018H
  01355	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL423@lssproto_S:
  01358	8a 01		 mov	 al, BYTE PTR [ecx]
  0135a	41		 inc	 ecx
  0135b	84 c0		 test	 al, al
  0135d	75 f9		 jne	 SHORT $LL423@lssproto_S
  0135f	2b ca		 sub	 ecx, edx
  01361	83 f9 18	 cmp	 ecx, 24			; 00000018H
  01364	77 27		 ja	 SHORT $LN175@lssproto_S

; 1415 : 					strcpy(magic[no].name, name);

  01366	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _name$6[ebp]
  0136c	b8 0e 00 00 00	 mov	 eax, OFFSET ?magic@@3PAUMAGIC@@A+14
  01371	8b d1		 mov	 edx, ecx
  01373	2b c2		 sub	 eax, edx
  01375	8d 14 30	 lea	 edx, DWORD PTR [eax+esi]
  01378	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL254@lssproto_S:
  01380	8a 01		 mov	 al, BYTE PTR [ecx]
  01382	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  01385	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  01389	84 c0		 test	 al, al
  0138b	75 f3		 jne	 SHORT $LL254@lssproto_S
$LN175@lssproto_S:

; 1416 : 				getStringToken(data, S_DELIM, 6, sizeof(memo) - 1, memo);

  0138d	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _memo$11[ebp]
  01393	50		 push	 eax
  01394	68 ff 00 00 00	 push	 255			; 000000ffH
  01399	6a 06		 push	 6
  0139b	6a 7c		 push	 124			; 0000007cH
  0139d	57		 push	 edi
  0139e	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1417 : 				makeStringFromEscaped(memo);

  013a3	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _memo$11[ebp]
  013a9	50		 push	 eax
  013aa	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1418 : 				if (strlen(memo) <= sizeof(magic[no].memo) - 1)

  013af	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _memo$11[ebp]
  013b5	83 c4 18	 add	 esp, 24			; 00000018H
  013b8	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  013bb	0f 1f 44 00 00	 npad	 5
$LL424@lssproto_S:
  013c0	8a 01		 mov	 al, BYTE PTR [ecx]
  013c2	41		 inc	 ecx
  013c3	84 c0		 test	 al, al
  013c5	75 f9		 jne	 SHORT $LL424@lssproto_S
  013c7	2b ca		 sub	 ecx, edx
  013c9	83 f9 48	 cmp	 ecx, 72			; 00000048H
  013cc	0f 87 b4 0e 00
	00		 ja	 $LN439@lssproto_S

; 1419 : 					strcpy(magic[no].memo, memo);

  013d2	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _memo$11[ebp]
  013d8	b8 27 00 00 00	 mov	 eax, OFFSET ?magic@@3PAUMAGIC@@A+39
  013dd	8b d1		 mov	 edx, ecx
  013df	2b c2		 sub	 eax, edx
  013e1	8d 14 30	 lea	 edx, DWORD PTR [eax+esi]
$LL255@lssproto_S:
  013e4	8a 01		 mov	 al, BYTE PTR [ecx]
  013e6	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  013e9	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  013ed	84 c0		 test	 al, al
  013ef	75 f3		 jne	 SHORT $LL255@lssproto_S
  013f1	5e		 pop	 esi
  013f2	5b		 pop	 ebx
  013f3	5f		 pop	 edi

; 1803 : 			}
; 1804 : 			break;
; 1805 :     }
; 1806 : } 

  013f4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  013f7	33 cd		 xor	 ecx, ebp
  013f9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  013fe	8b e5		 mov	 esp, ebp
  01400	5d		 pop	 ebp
  01401	c3		 ret	 0
$LN177@lssproto_S:

; 1420 : 			}
; 1421 : 			break;
; 1422 : 		case 'N':
; 1423 : 			{
; 1424 : 				ACTION *ptAct;
; 1425 : 				char name[256];
; 1426 : 				int no, kubun, i, checkPartyCount, gx, gy, no2;
; 1427 : 				unsigned int mask;
; 1428 : 				
; 1429 : 				no = data[1] - '0';

  01402	0f be 77 01	 movsx	 esi, BYTE PTR [edi+1]

; 1430 : 				data += 3;

  01406	83 c7 03	 add	 edi, 3

; 1431 : 				kubun = getInteger62Token(data, S_DELIM, 1);

  01409	6a 01		 push	 1
  0140b	6a 7c		 push	 124			; 0000007cH
  0140d	83 ee 30	 sub	 esi, 48			; 00000030H
  01410	57		 push	 edi
  01411	89 b5 84 fc ff
	ff		 mov	 DWORD PTR _no$1$[ebp], esi
  01417	e8 00 00 00 00	 call	 ?getInteger62Token@@YAHPADDH@Z ; getInteger62Token
  0141c	8b c8		 mov	 ecx, eax
  0141e	8d 1c 76	 lea	 ebx, DWORD PTR [esi+esi*2]
  01421	83 c4 0c	 add	 esp, 12			; 0000000cH
  01424	c1 e3 04	 shl	 ebx, 4
  01427	89 8d 8c fc ff
	ff		 mov	 DWORD PTR _kubun$1$[ebp], ecx

; 1432 : 				if (kubun == 0)

  0142d	85 c9		 test	 ecx, ecx
  0142f	0f 85 49 01 00
	00		 jne	 $LN178@lssproto_S

; 1433 : 				{
; 1434 : 					if (party[no].useFlag != 0 && party[no].id != pc.id)

  01435	66 39 83 00 00
	00 00		 cmp	 WORD PTR ?party@@3PAUPARTY@@A[ebx], ax
  0143c	74 24		 je	 SHORT $LN180@lssproto_S
  0143e	8b 83 04 00 00
	00		 mov	 eax, DWORD PTR ?party@@3PAUPARTY@@A[ebx+4]
  01444	3b 05 08 00 00
	00		 cmp	 eax, DWORD PTR ?pc@@3UPC@@A+8
  0144a	74 16		 je	 SHORT $LN180@lssproto_S

; 1435 : 					{
; 1436 : 						ptAct = getCharObjAct(party[no].id);

  0144c	50		 push	 eax
  0144d	e8 00 00 00 00	 call	 ?getCharObjAct@@YAPAUaction@@H@Z ; getCharObjAct
  01452	83 c4 04	 add	 esp, 4

; 1437 : 						if (ptAct != NULL)

  01455	85 c0		 test	 eax, eax
  01457	74 09		 je	 SHORT $LN180@lssproto_S

; 1438 : 							delCharParty(ptAct);

  01459	50		 push	 eax
  0145a	e8 00 00 00 00	 call	 ?delCharParty@@YAXPAUaction@@@Z ; delCharParty
  0145f	83 c4 04	 add	 esp, 4
$LN180@lssproto_S:

; 1439 : 					}
; 1440 : 					gx = -1;
; 1441 : 					gy = -1;
; 1442 : 					if (party[no].ptAct != NULL)

  01462	8b 83 2c 00 00
	00		 mov	 eax, DWORD PTR ?party@@3PAUPARTY@@A[ebx+44]
  01468	83 ca ff	 or	 edx, -1
  0146b	0b fa		 or	 edi, edx
  0146d	85 c0		 test	 eax, eax
  0146f	74 0c		 je	 SHORT $LN181@lssproto_S

; 1443 : 					{
; 1444 : 						gx = party[no].ptAct->nextGx;

  01471	8b 90 bc 00 00
	00		 mov	 edx, DWORD PTR [eax+188]

; 1445 : 						gy = party[no].ptAct->nextGy;

  01477	8b b8 c0 00 00
	00		 mov	 edi, DWORD PTR [eax+192]
$LN181@lssproto_S:

; 1446 : 					}
; 1447 : 					party[no].useFlag = 0;

  0147d	33 c0		 xor	 eax, eax

; 1448 : 					party[no].ptAct	= NULL;
; 1449 : 					checkPartyCount = 0;

  0147f	33 c9		 xor	 ecx, ecx
  01481	66 89 83 00 00
	00 00		 mov	 WORD PTR ?party@@3PAUPARTY@@A[ebx], ax
  01488	89 83 2c 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[ebx+44], eax

; 1450 : 					no2 = -1;

  0148e	83 c8 ff	 or	 eax, -1

; 1451 : 					for (i = 0; i < MAX_PARTY; i++)
; 1452 : 					{
; 1453 : 						if (party[i].useFlag != 0)

  01491	66 39 0d 00 00
	00 00		 cmp	 WORD PTR ?party@@3PAUPARTY@@A, cx
  01498	74 0a		 je	 SHORT $LN10@lssproto_S

; 1456 : 							if (no2 == -1 && i > no)

  0149a	33 db		 xor	 ebx, ebx
  0149c	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  0149f	85 f6		 test	 esi, esi
  014a1	0f 48 c3	 cmovs	 eax, ebx
$LN10@lssproto_S:

; 1451 : 					for (i = 0; i < MAX_PARTY; i++)
; 1452 : 					{
; 1453 : 						if (party[i].useFlag != 0)

  014a4	66 83 3d 30 00
	00 00 00	 cmp	 WORD PTR ?party@@3PAUPARTY@@A+48, 0
  014ac	74 10		 je	 SHORT $LN362@lssproto_S

; 1454 : 						{
; 1455 : 							checkPartyCount++;

  014ae	41		 inc	 ecx

; 1456 : 							if (no2 == -1 && i > no)

  014af	83 f8 ff	 cmp	 eax, -1
  014b2	75 0a		 jne	 SHORT $LN362@lssproto_S
  014b4	bb 01 00 00 00	 mov	 ebx, 1
  014b9	3b f3		 cmp	 esi, ebx
  014bb	0f 4c c3	 cmovl	 eax, ebx
$LN362@lssproto_S:

; 1451 : 					for (i = 0; i < MAX_PARTY; i++)
; 1452 : 					{
; 1453 : 						if (party[i].useFlag != 0)

  014be	66 83 3d 60 00
	00 00 00	 cmp	 WORD PTR ?party@@3PAUPARTY@@A+96, 0
  014c6	74 10		 je	 SHORT $LN364@lssproto_S

; 1454 : 						{
; 1455 : 							checkPartyCount++;

  014c8	41		 inc	 ecx

; 1456 : 							if (no2 == -1 && i > no)

  014c9	83 f8 ff	 cmp	 eax, -1
  014cc	75 0a		 jne	 SHORT $LN364@lssproto_S
  014ce	bb 02 00 00 00	 mov	 ebx, 2
  014d3	3b f3		 cmp	 esi, ebx
  014d5	0f 4c c3	 cmovl	 eax, ebx
$LN364@lssproto_S:

; 1451 : 					for (i = 0; i < MAX_PARTY; i++)
; 1452 : 					{
; 1453 : 						if (party[i].useFlag != 0)

  014d8	66 83 3d 90 00
	00 00 00	 cmp	 WORD PTR ?party@@3PAUPARTY@@A+144, 0
  014e0	74 10		 je	 SHORT $LN366@lssproto_S

; 1454 : 						{
; 1455 : 							checkPartyCount++;

  014e2	41		 inc	 ecx

; 1456 : 							if (no2 == -1 && i > no)

  014e3	83 f8 ff	 cmp	 eax, -1
  014e6	75 0a		 jne	 SHORT $LN366@lssproto_S
  014e8	bb 03 00 00 00	 mov	 ebx, 3
  014ed	3b f3		 cmp	 esi, ebx
  014ef	0f 4c c3	 cmovl	 eax, ebx
$LN366@lssproto_S:

; 1451 : 					for (i = 0; i < MAX_PARTY; i++)
; 1452 : 					{
; 1453 : 						if (party[i].useFlag != 0)

  014f2	66 83 3d c0 00
	00 00 00	 cmp	 WORD PTR ?party@@3PAUPARTY@@A+192, 0
  014fa	74 10		 je	 SHORT $LN368@lssproto_S

; 1454 : 						{
; 1455 : 							checkPartyCount++;

  014fc	41		 inc	 ecx

; 1456 : 							if (no2 == -1 && i > no)

  014fd	83 f8 ff	 cmp	 eax, -1
  01500	75 0a		 jne	 SHORT $LN368@lssproto_S
  01502	bb 04 00 00 00	 mov	 ebx, 4
  01507	3b f3		 cmp	 esi, ebx
  01509	0f 4c c3	 cmovl	 eax, ebx
$LN368@lssproto_S:

; 1457 : 								no2 = i;
; 1458 : 						}
; 1459 : 					}
; 1460 : 					if (checkPartyCount <= 1)

  0150c	83 f9 01	 cmp	 ecx, 1
  0150f	77 41		 ja	 SHORT $LN184@lssproto_S

; 1461 : 					{
; 1462 : 						partyModeFlag = 0;

  01511	33 c0		 xor	 eax, eax
  01513	66 a3 00 00 00
	00		 mov	 WORD PTR ?partyModeFlag@@3FA, ax ; partyModeFlag

; 1463 : 						clearPartyParam();

  01519	e8 00 00 00 00	 call	 ?clearPartyParam@@YAXXZ	; clearPartyParam

; 1464 : #ifdef _CHANNEL_MODIFY
; 1465 : 						pc.etcFlag &= ~PC_ETCFLAG_CHAT_MODE;

  0151e	b8 f7 ff 00 00	 mov	 eax, 65527		; 0000fff7H
  01523	66 21 05 a8 00
	00 00		 and	 WORD PTR ?pc@@3UPC@@A+168, ax

; 1466 : 						if (TalkMode == 2)

  0152a	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?TalkMode@@3HA, 2 ; TalkMode
  01531	0f 85 4f 0d 00
	00		 jne	 $LN439@lssproto_S

; 1467 : 							TalkMode = 0;

  01537	5e		 pop	 esi
  01538	5b		 pop	 ebx
  01539	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?TalkMode@@3HA, 0 ; TalkMode
  01543	5f		 pop	 edi

; 1803 : 			}
; 1804 : 			break;
; 1805 :     }
; 1806 : } 

  01544	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01547	33 cd		 xor	 ecx, ebp
  01549	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0154e	8b e5		 mov	 esp, ebp
  01550	5d		 pop	 ebp
  01551	c3		 ret	 0
$LN184@lssproto_S:

; 1468 : #endif
; 1469 : 					}
; 1470 : 					else
; 1471 : 					{
; 1472 : 						if (no2 >= 0 || gx >= 0 || gy >= 0)

  01552	85 c0		 test	 eax, eax
  01554	79 0c		 jns	 SHORT $LN188@lssproto_S
  01556	85 d2		 test	 edx, edx
  01558	79 08		 jns	 SHORT $LN188@lssproto_S
  0155a	85 ff		 test	 edi, edi
  0155c	0f 88 24 0d 00
	00		 js	 $LN439@lssproto_S
$LN188@lssproto_S:

; 1473 : 							goFrontPartyCharacter(no2, gx, gy);

  01562	57		 push	 edi
  01563	52		 push	 edx
  01564	50		 push	 eax
  01565	e8 00 00 00 00	 call	 ?goFrontPartyCharacter@@YAXHHH@Z ; goFrontPartyCharacter

; 1791 : 					//å¯æ‹¿ç»™å® ç‰©è£…å¤‡çš„é“å…·,å°±ä¸ä¼šæ˜¯æ‹¼å›¾äº†,ä»¥ä¸‹å°±å…äº†
; 1792 : 					//if( i == JigsawIdx )
; 1793 : 					//	SetJigsaw( pc.item[i].graNo, pc.item[i].jigsaw );
; 1794 : 				}
; 1795 : 			}
; 1796 : 			break;
; 1797 : #endif
; 1798 : 			case 'V':
; 1799 : 			{
; 1800 : 				extern int itemWndMaxBag;
; 1801 : 				//V|1
; 1802 : 				itemWndMaxBag = getIntegerToken(data, '|', 2);

  0156a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0156d	5e		 pop	 esi
  0156e	5b		 pop	 ebx
  0156f	5f		 pop	 edi

; 1803 : 			}
; 1804 : 			break;
; 1805 :     }
; 1806 : } 

  01570	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01573	33 cd		 xor	 ecx, ebp
  01575	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0157a	8b e5		 mov	 esp, ebp
  0157c	5d		 pop	 ebp
  0157d	c3		 ret	 0
$LN178@lssproto_S:

; 1474 : 					}
; 1475 : 					break;
; 1476 : 				}
; 1477 : 				partyModeFlag = 1;

  0157e	b8 01 00 00 00	 mov	 eax, 1

; 1478 : 				prSendFlag = 0;

  01583	33 d2		 xor	 edx, edx
  01585	66 a3 00 00 00
	00		 mov	 WORD PTR ?partyModeFlag@@3FA, ax ; partyModeFlag
  0158b	66 89 15 00 00
	00 00		 mov	 WORD PTR ?prSendFlag@@3FA, dx ; prSendFlag

; 1479 : 				party[no].useFlag = 1;

  01592	66 89 83 00 00
	00 00		 mov	 WORD PTR ?party@@3PAUPARTY@@A[ebx], ax

; 1480 : 				
; 1481 : 				if (kubun == 1)

  01599	3b c8		 cmp	 ecx, eax
  0159b	0f 85 bc 00 00
	00		 jne	 $LN189@lssproto_S

; 1482 : 				{
; 1483 : 					party[no].id		= getIntegerToken(data, S_DELIM, 2);	// 0x00000002

  015a1	6a 02		 push	 2
  015a3	6a 7c		 push	 124			; 0000007cH
  015a5	57		 push	 edi
  015a6	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1484 : 					party[no].level		= getIntegerToken(data, S_DELIM, 3);	// 0x00000004

  015ab	6a 03		 push	 3
  015ad	6a 7c		 push	 124			; 0000007cH
  015af	57		 push	 edi
  015b0	89 83 04 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[ebx+4], eax
  015b6	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1485 : 					party[no].maxHp		= getIntegerToken(data, S_DELIM, 4);	// 0x00000008

  015bb	6a 04		 push	 4
  015bd	6a 7c		 push	 124			; 0000007cH
  015bf	57		 push	 edi
  015c0	89 83 08 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[ebx+8], eax
  015c6	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1486 : 					party[no].hp		= getIntegerToken(data, S_DELIM, 5);	// 0x00000010

  015cb	6a 05		 push	 5
  015cd	6a 7c		 push	 124			; 0000007cH
  015cf	57		 push	 edi
  015d0	89 83 0c 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[ebx+12], eax
  015d6	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1487 : 					party[no].mp		= getIntegerToken(data, S_DELIM, 6);	// 0x00000020

  015db	6a 06		 push	 6
  015dd	6a 7c		 push	 124			; 0000007cH
  015df	57		 push	 edi
  015e0	89 83 10 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[ebx+16], eax
  015e6	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  015eb	89 83 14 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[ebx+20], eax

; 1488 : 					getStringToken(data, S_DELIM, 7, sizeof(name) - 1, name);	// 0x00000040

  015f1	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _name$5[ebp]
  015f7	50		 push	 eax
  015f8	68 ff 00 00 00	 push	 255			; 000000ffH
  015fd	6a 07		 push	 7
  015ff	6a 7c		 push	 124			; 0000007cH
  01601	57		 push	 edi
  01602	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  01607	83 c4 50	 add	 esp, 80			; 00000050H

; 1489 : 					makeStringFromEscaped(name);

  0160a	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _name$5[ebp]
  01610	50		 push	 eax
  01611	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1490 : 					if (strlen(name) <= sizeof(party[no].name) - 1)

  01616	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _name$5[ebp]
  0161c	83 c4 04	 add	 esp, 4
  0161f	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL425@lssproto_S:
  01622	8a 01		 mov	 al, BYTE PTR [ecx]
  01624	41		 inc	 ecx
  01625	84 c0		 test	 al, al
  01627	75 f9		 jne	 SHORT $LL425@lssproto_S
  01629	2b ca		 sub	 ecx, edx
  0162b	8d 93 18 00 00
	00		 lea	 edx, DWORD PTR ?party@@3PAUPARTY@@A[ebx+24]
  01631	83 f9 10	 cmp	 ecx, 16			; 00000010H
  01634	77 1c		 ja	 SHORT $LN191@lssproto_S

; 1491 : 						strcpy(party[no].name, name);

  01636	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _name$5[ebp]
  0163c	8b c1		 mov	 eax, ecx
  0163e	2b d0		 sub	 edx, eax
$LL256@lssproto_S:
  01640	8a 01		 mov	 al, BYTE PTR [ecx]
  01642	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  01645	88 44 11 ff	 mov	 BYTE PTR [ecx+edx-1], al
  01649	84 c0		 test	 al, al
  0164b	75 f3		 jne	 SHORT $LL256@lssproto_S
  0164d	e9 35 01 00 00	 jmp	 $LN14@lssproto_S
$LN191@lssproto_S:

; 1492 : 					else
; 1493 : 						strcpy(party[no].name, "???");

  01652	c7 02 3f 3f 3f
	00		 mov	 DWORD PTR [edx], 4144959 ; 003f3f3fH

; 1494 : 				}

  01658	e9 2a 01 00 00	 jmp	 $LN14@lssproto_S
$LN189@lssproto_S:

; 1495 : 				else
; 1496 : 				{
; 1497 : 					mask = 2;

  0165d	b8 02 00 00 00	 mov	 eax, 2
  01662	89 85 88 fc ff
	ff		 mov	 DWORD PTR _mask$1$[ebp], eax

; 1498 : 					i = 2;

  01668	8b f0		 mov	 esi, eax
  0166a	66 0f 1f 44 00
	00		 npad	 6
$LL15@lssproto_S:

; 1500 : 					{
; 1501 : 						if (kubun & mask)

  01670	85 c1		 test	 eax, ecx
  01672	0f 84 fb 00 00
	00		 je	 $LN13@lssproto_S

; 1502 : 						{
; 1503 : 							if (mask == 0x00000002)

  01678	83 f8 02	 cmp	 eax, 2
  0167b	75 17		 jne	 SHORT $LN194@lssproto_S

; 1504 : 							{
; 1505 : 								party[no].id = getIntegerToken(data, S_DELIM, i);// 0x00000002

  0167d	56		 push	 esi
  0167e	6a 7c		 push	 124			; 0000007cH
  01680	57		 push	 edi
  01681	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01686	83 c4 0c	 add	 esp, 12			; 0000000cH
  01689	89 83 04 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[ebx+4], eax

; 1506 : 								i++;
; 1507 : 							}

  0168f	e9 d2 00 00 00	 jmp	 $LN206@lssproto_S
$LN194@lssproto_S:

; 1508 : 							else if (mask == 0x00000004)

  01694	83 f8 04	 cmp	 eax, 4
  01697	75 17		 jne	 SHORT $LN196@lssproto_S

; 1509 : 							{
; 1510 : 								party[no].level = getIntegerToken(data, S_DELIM, i);// 0x00000004

  01699	56		 push	 esi
  0169a	6a 7c		 push	 124			; 0000007cH
  0169c	57		 push	 edi
  0169d	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  016a2	83 c4 0c	 add	 esp, 12			; 0000000cH
  016a5	89 83 08 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[ebx+8], eax

; 1511 : 								i++;
; 1512 : 							}

  016ab	e9 b6 00 00 00	 jmp	 $LN206@lssproto_S
$LN196@lssproto_S:

; 1513 : 							else if (mask == 0x00000008)

  016b0	83 f8 08	 cmp	 eax, 8
  016b3	75 17		 jne	 SHORT $LN198@lssproto_S

; 1514 : 							{
; 1515 : 								party[no].maxHp = getIntegerToken(data, S_DELIM, i);// 0x00000008

  016b5	56		 push	 esi
  016b6	6a 7c		 push	 124			; 0000007cH
  016b8	57		 push	 edi
  016b9	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  016be	83 c4 0c	 add	 esp, 12			; 0000000cH
  016c1	89 83 0c 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[ebx+12], eax

; 1516 : 								i++;
; 1517 : 							}

  016c7	e9 9a 00 00 00	 jmp	 $LN206@lssproto_S
$LN198@lssproto_S:

; 1518 : 							else if (mask == 0x00000010)

  016cc	83 f8 10	 cmp	 eax, 16			; 00000010H
  016cf	75 17		 jne	 SHORT $LN200@lssproto_S

; 1519 : 							{
; 1520 : 								party[no].hp = getIntegerToken(data, S_DELIM, i);// 0x00000010

  016d1	56		 push	 esi
  016d2	6a 7c		 push	 124			; 0000007cH
  016d4	57		 push	 edi
  016d5	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  016da	83 c4 0c	 add	 esp, 12			; 0000000cH
  016dd	89 83 10 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[ebx+16], eax

; 1521 : 								i++;
; 1522 : 							}

  016e3	e9 7e 00 00 00	 jmp	 $LN206@lssproto_S
$LN200@lssproto_S:

; 1523 : 							else if (mask == 0x00000020)

  016e8	83 f8 20	 cmp	 eax, 32			; 00000020H
  016eb	75 14		 jne	 SHORT $LN202@lssproto_S

; 1524 : 							{
; 1525 : 								party[no].mp = getIntegerToken(data, S_DELIM, i);// 0x00000020

  016ed	56		 push	 esi
  016ee	6a 7c		 push	 124			; 0000007cH
  016f0	57		 push	 edi
  016f1	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  016f6	83 c4 0c	 add	 esp, 12			; 0000000cH
  016f9	89 83 14 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[ebx+20], eax

; 1526 : 								i++;
; 1527 : 							}

  016ff	eb 65		 jmp	 SHORT $LN206@lssproto_S
$LN202@lssproto_S:

; 1528 : 							else if (mask == 0x00000040)

  01701	83 f8 40	 cmp	 eax, 64			; 00000040H
  01704	75 6d		 jne	 SHORT $LN13@lssproto_S

; 1529 : 							{
; 1530 : 								getStringToken(data, S_DELIM, i, sizeof(name) - 1, name);// 0x00000040

  01706	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _name$5[ebp]
  0170c	50		 push	 eax
  0170d	68 ff 00 00 00	 push	 255			; 000000ffH
  01712	56		 push	 esi
  01713	6a 7c		 push	 124			; 0000007cH
  01715	57		 push	 edi
  01716	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1531 : 								makeStringFromEscaped(name);

  0171b	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _name$5[ebp]
  01721	50		 push	 eax
  01722	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1532 : 								if (strlen(name) <= sizeof(party[no].name) - 1)

  01727	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _name$5[ebp]
  0172d	83 c4 18	 add	 esp, 24			; 00000018H
  01730	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL426@lssproto_S:
  01733	8a 01		 mov	 al, BYTE PTR [ecx]
  01735	41		 inc	 ecx
  01736	84 c0		 test	 al, al
  01738	75 f9		 jne	 SHORT $LL426@lssproto_S
  0173a	2b ca		 sub	 ecx, edx
  0173c	8d 93 18 00 00
	00		 lea	 edx, DWORD PTR ?party@@3PAUPARTY@@A[ebx+24]
  01742	83 f9 10	 cmp	 ecx, 16			; 00000010H
  01745	77 19		 ja	 SHORT $LN205@lssproto_S

; 1533 : 									strcpy(party[no].name, name);

  01747	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _name$5[ebp]
  0174d	8b c1		 mov	 eax, ecx
  0174f	2b d0		 sub	 edx, eax
$LL257@lssproto_S:
  01751	8a 01		 mov	 al, BYTE PTR [ecx]
  01753	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  01756	88 44 11 ff	 mov	 BYTE PTR [ecx+edx-1], al
  0175a	84 c0		 test	 al, al
  0175c	75 f3		 jne	 SHORT $LL257@lssproto_S
  0175e	eb 06		 jmp	 SHORT $LN206@lssproto_S
$LN205@lssproto_S:

; 1534 : 								else
; 1535 : 									strcpy(party[no].name, "???");

  01760	c7 02 3f 3f 3f
	00		 mov	 DWORD PTR [edx], 4144959 ; 003f3f3fH
$LN206@lssproto_S:

; 1499 : 					for (; mask > 0; mask <<= 1)

  01766	8b 8d 8c fc ff
	ff		 mov	 ecx, DWORD PTR _kubun$1$[ebp]
  0176c	46		 inc	 esi
  0176d	8b 85 88 fc ff
	ff		 mov	 eax, DWORD PTR _mask$1$[ebp]
$LN13@lssproto_S:
  01773	03 c0		 add	 eax, eax
  01775	89 85 88 fc ff
	ff		 mov	 DWORD PTR _mask$1$[ebp], eax
  0177b	0f 85 ef fe ff
	ff		 jne	 $LL15@lssproto_S
  01781	8b b5 84 fc ff
	ff		 mov	 esi, DWORD PTR _no$1$[ebp]
$LN14@lssproto_S:

; 1536 : 								i++;
; 1537 : 							}
; 1538 : 						}
; 1539 : 					}
; 1540 : 				}
; 1541 : 				if (party[no].id != pc.id)

  01787	8b 83 04 00 00
	00		 mov	 eax, DWORD PTR ?party@@3PAUPARTY@@A[ebx+4]
  0178d	3b 05 08 00 00
	00		 cmp	 eax, DWORD PTR ?pc@@3UPC@@A+8
  01793	74 5b		 je	 SHORT $LN207@lssproto_S

; 1542 : 				{
; 1543 : 					ptAct = getCharObjAct(party[no].id);

  01795	50		 push	 eax
  01796	e8 00 00 00 00	 call	 ?getCharObjAct@@YAPAUaction@@H@Z ; getCharObjAct
  0179b	8b f8		 mov	 edi, eax
  0179d	83 c4 04	 add	 esp, 4

; 1544 : 					if (ptAct != NULL)

  017a0	85 ff		 test	 edi, edi
  017a2	74 31		 je	 SHORT $LN209@lssproto_S

; 1545 : 					{
; 1546 : 						party[no].ptAct = ptAct;
; 1547 : 						setCharParty(ptAct);

  017a4	57		 push	 edi
  017a5	89 bb 2c 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[ebx+44], edi
  017ab	e8 00 00 00 00	 call	 ?setCharParty@@YAXPAUaction@@@Z ; setCharParty
  017b0	83 c4 04	 add	 esp, 4

; 1548 : 						// NPC???????
; 1549 : 						if (no == 0)

  017b3	85 f6		 test	 esi, esi
  017b5	0f 85 cb 0a 00
	00		 jne	 $LN439@lssproto_S

; 1550 : 							setCharLeader(ptAct);

  017bb	57		 push	 edi
  017bc	e8 00 00 00 00	 call	 ?setCharLeader@@YAXPAUaction@@@Z ; setCharLeader
  017c1	83 c4 04	 add	 esp, 4
  017c4	5e		 pop	 esi
  017c5	5b		 pop	 ebx
  017c6	5f		 pop	 edi

; 1803 : 			}
; 1804 : 			break;
; 1805 :     }
; 1806 : } 

  017c7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  017ca	33 cd		 xor	 ecx, ebp
  017cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  017d1	8b e5		 mov	 esp, ebp
  017d3	5d		 pop	 ebp
  017d4	c3		 ret	 0
$LN209@lssproto_S:
  017d5	5e		 pop	 esi

; 1551 : 					}
; 1552 : 					else
; 1553 : 						party[no].ptAct = NULL;

  017d6	c7 83 2c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?party@@3PAUPARTY@@A[ebx+44], 0
  017e0	5b		 pop	 ebx
  017e1	5f		 pop	 edi

; 1803 : 			}
; 1804 : 			break;
; 1805 :     }
; 1806 : } 

  017e2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  017e5	33 cd		 xor	 ecx, ebp
  017e7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  017ec	8b e5		 mov	 esp, ebp
  017ee	5d		 pop	 ebp
  017ef	c3		 ret	 0
$LN207@lssproto_S:

; 1554 : 				}
; 1555 : 				else
; 1556 : 				{
; 1557 : 					party[no].ptAct = pc.ptAct;

  017f0	a1 ec 50 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+20716
  017f5	89 83 2c 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[ebx+44], eax

; 1558 : 					setPcParty();

  017fb	e8 00 00 00 00	 call	 ?setPcParty@@YAXXZ	; setPcParty

; 1559 : 					// PC???????
; 1560 : 					if (no == 0)

  01800	85 f6		 test	 esi, esi
  01802	0f 85 7e 0a 00
	00		 jne	 $LN439@lssproto_S

; 1561 : 						setPcLeader();

  01808	e8 00 00 00 00	 call	 ?setPcLeader@@YAXXZ	; setPcLeader
  0180d	5e		 pop	 esi
  0180e	5b		 pop	 ebx
  0180f	5f		 pop	 edi

; 1803 : 			}
; 1804 : 			break;
; 1805 :     }
; 1806 : } 

  01810	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01813	33 cd		 xor	 ecx, ebp
  01815	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0181a	8b e5		 mov	 esp, ebp
  0181c	5d		 pop	 ebp
  0181d	c3		 ret	 0
$LN213@lssproto_S:

; 1562 : 				}
; 1563 : 			}
; 1564 : 			break;
; 1565 : 		case 'I':
; 1566 : 			{
; 1567 : 				int i, no;
; 1568 : 				char temp[256];
; 1569 : 				
; 1570 : 				data++;

  0181e	33 c9		 xor	 ecx, ecx
  01820	c7 85 88 fc ff
	ff 3d 02 00 00	 mov	 DWORD PTR tv7756[ebp], OFFSET ?pc@@3UPC@@A+573
  0182a	be c7 01 00 00	 mov	 esi, OFFSET ?pc@@3UPC@@A+455
  0182f	89 8d 80 fc ff
	ff		 mov	 DWORD PTR _i$1$[ebp], ecx
  01835	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$10[ebp]
  0183b	47		 inc	 edi
  0183c	2b f0		 sub	 esi, eax
  0183e	66 90		 npad	 2
$LL18@lssproto_S:

; 1572 : 				{
; 1573 : #ifdef _PET_ITEM
; 1574 : 
; 1575 : 					//CC Fix
; 1576 : 					extern int g_æœåŠ¡å™¨;
; 1577 : 					if (g_æœåŠ¡å™¨ == SERVER_å°æœ)

  01840	33 c0		 xor	 eax, eax

; 1578 : 					{
; 1579 : 						no = i * 16;
; 1580 : 					}
; 1581 : 					else
; 1582 : 					{
; 1583 : 						no = i * 14;
; 1584 : 					}
; 1585 : 					
; 1586 : 					//old
; 1587 : 					//no = i * 13;
; 1588 : #else
; 1589 : #ifdef _ITEM_PILENUMS
; 1590 : #ifdef _ALCHEMIST //#ifdef _ITEMSET7_TXT
; 1591 : 					no = i * 12;
; 1592 : #else
; 1593 : 
; 1594 : 					no = i * 11;
; 1595 : 
; 1596 : #endif//_ALCHEMIST
; 1597 : #else
; 1598 : 
; 1599 : 					no = i * 10;
; 1600 : 
; 1601 : #endif//_ITEM_PILENUMS
; 1602 : #endif//_PET_ITEM
; 1603 : 					getStringToken(data, '|', no + 1, sizeof(temp) - 1 , temp);

  01842	8b d9		 mov	 ebx, ecx
  01844	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_Ü×?Ðï@@3HA, 1 ; g_Ü×?Ðï
  0184b	0f 94 c0	 sete	 al
  0184e	8d 04 45 0e 00
	00 00		 lea	 eax, DWORD PTR [eax*2+14]
  01855	0f af d8	 imul	 ebx, eax
  01858	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$10[ebp]
  0185e	50		 push	 eax
  0185f	68 ff 00 00 00	 push	 255			; 000000ffH
  01864	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  01867	50		 push	 eax
  01868	6a 7c		 push	 124			; 0000007cH
  0186a	57		 push	 edi
  0186b	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1604 : 					makeStringFromEscaped(temp);

  01870	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$10[ebp]
  01876	50		 push	 eax
  01877	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1605 : 					if (strlen(temp) == 0 )

  0187c	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$10[ebp]
  01882	83 c4 18	 add	 esp, 24			; 00000018H
  01885	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL427@lssproto_S:
  01888	8a 01		 mov	 al, BYTE PTR [ecx]
  0188a	41		 inc	 ecx
  0188b	84 c0		 test	 al, al
  0188d	75 f9		 jne	 SHORT $LL427@lssproto_S
  0188f	2b ca		 sub	 ecx, edx
  01891	75 0f		 jne	 SHORT $LN216@lssproto_S

; 1606 : 					{
; 1607 : 						pc.item[i].useFlag = 0;

  01893	33 c0		 xor	 eax, eax
  01895	66 89 84 35 c1
	fe ff ff	 mov	 WORD PTR _temp$10[ebp+esi-39], ax

; 1608 : 						continue;

  0189d	e9 75 02 00 00	 jmp	 $LN16@lssproto_S
$LN216@lssproto_S:

; 1609 : 					}
; 1610 : 					pc.item[i].useFlag = 1;

  018a2	b8 01 00 00 00	 mov	 eax, 1
  018a7	66 89 84 35 c1
	fe ff ff	 mov	 WORD PTR _temp$10[ebp+esi-39], ax

; 1611 : 					if (strlen(temp) <= ITEM_NAME_LEN)

  018af	83 f9 1c	 cmp	 ecx, 28			; 0000001cH
  018b2	77 19		 ja	 SHORT $LN217@lssproto_S

; 1612 : 						strcpy(pc.item[i].name, temp);

  018b4	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$10[ebp]
  018ba	66 0f 1f 44 00
	00		 npad	 6
$LL258@lssproto_S:
  018c0	8a 01		 mov	 al, BYTE PTR [ecx]
  018c2	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  018c5	88 44 31 e2	 mov	 BYTE PTR [ecx+esi-30], al
  018c9	84 c0		 test	 al, al
  018cb	75 f3		 jne	 SHORT $LL258@lssproto_S
$LN217@lssproto_S:

; 1613 : 					getStringToken(data, '|', no + 2, sizeof(temp) - 1, temp);

  018cd	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$10[ebp]
  018d3	50		 push	 eax
  018d4	68 ff 00 00 00	 push	 255			; 000000ffH
  018d9	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  018dc	50		 push	 eax
  018dd	6a 7c		 push	 124			; 0000007cH
  018df	57		 push	 edi
  018e0	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1614 : 					makeStringFromEscaped(temp);

  018e5	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$10[ebp]
  018eb	50		 push	 eax
  018ec	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1615 : 					if (strlen(temp) <= ITEM_NAME2_LEN)

  018f1	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$10[ebp]
  018f7	83 c4 18	 add	 esp, 24			; 00000018H
  018fa	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  018fd	0f 1f 00	 npad	 3
$LL428@lssproto_S:
  01900	8a 01		 mov	 al, BYTE PTR [ecx]
  01902	41		 inc	 ecx
  01903	84 c0		 test	 al, al
  01905	75 f9		 jne	 SHORT $LL428@lssproto_S
  01907	2b ca		 sub	 ecx, edx
  01909	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0190c	77 13		 ja	 SHORT $LN218@lssproto_S

; 1616 : 						strcpy(pc.item[i].name2, temp);

  0190e	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$10[ebp]
$LL259@lssproto_S:
  01914	8a 01		 mov	 al, BYTE PTR [ecx]
  01916	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  01919	88 44 31 ff	 mov	 BYTE PTR [ecx+esi-1], al
  0191d	84 c0		 test	 al, al
  0191f	75 f3		 jne	 SHORT $LL259@lssproto_S
$LN218@lssproto_S:

; 1617 : 					pc.item[i].color = getIntegerToken(data, '|', no + 3);

  01921	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  01924	50		 push	 eax
  01925	6a 7c		 push	 124			; 0000007cH
  01927	57		 push	 edi
  01928	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0192d	83 c4 0c	 add	 esp, 12			; 0000000cH
  01930	89 84 35 e5 fd
	ff ff		 mov	 DWORD PTR _temp$10[ebp+esi-259], eax

; 1618 : 					if (pc.item[i].color < 0)

  01937	85 c0		 test	 eax, eax
  01939	79 0b		 jns	 SHORT $LN219@lssproto_S

; 1619 : 						pc.item[i].color = 0;

  0193b	c7 84 35 e5 fd
	ff ff 00 00 00
	00		 mov	 DWORD PTR _temp$10[ebp+esi-259], 0
$LN219@lssproto_S:

; 1620 : 					getStringToken(data, '|', no + 4, sizeof(temp) - 1, temp);

  01946	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$10[ebp]
  0194c	50		 push	 eax
  0194d	68 ff 00 00 00	 push	 255			; 000000ffH
  01952	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  01955	50		 push	 eax
  01956	6a 7c		 push	 124			; 0000007cH
  01958	57		 push	 edi
  01959	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1621 : 					makeStringFromEscaped(temp);

  0195e	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$10[ebp]
  01964	50		 push	 eax
  01965	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1622 : 					if (strlen(temp) <= ITEM_MEMO_LEN)

  0196a	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$10[ebp]
  01970	83 c4 18	 add	 esp, 24			; 00000018H
  01973	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL429@lssproto_S:
  01976	8a 01		 mov	 al, BYTE PTR [ecx]
  01978	41		 inc	 ecx
  01979	84 c0		 test	 al, al
  0197b	75 f9		 jne	 SHORT $LL429@lssproto_S
  0197d	2b ca		 sub	 ecx, edx
  0197f	83 f9 54	 cmp	 ecx, 84			; 00000054H
  01982	77 19		 ja	 SHORT $LN220@lssproto_S

; 1623 : 						strcpy(pc.item[i].memo, temp);

  01984	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$10[ebp]
  0198a	66 0f 1f 44 00
	00		 npad	 6
$LL260@lssproto_S:
  01990	8a 01		 mov	 al, BYTE PTR [ecx]
  01992	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  01995	88 44 31 10	 mov	 BYTE PTR [ecx+esi+16], al
  01999	84 c0		 test	 al, al
  0199b	75 f3		 jne	 SHORT $LL260@lssproto_S
$LN220@lssproto_S:

; 1624 : 					pc.item[i].graNo = getIntegerToken(data, '|', no + 5);

  0199d	8d 43 05	 lea	 eax, DWORD PTR [ebx+5]
  019a0	50		 push	 eax
  019a1	6a 7c		 push	 124			; 0000007cH
  019a3	57		 push	 edi
  019a4	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  019a9	89 84 35 e9 fd
	ff ff		 mov	 DWORD PTR _temp$10[ebp+esi-255], eax

; 1625 : 					pc.item[i].field = getIntegerToken(data, '|', no + 6);

  019b0	8d 43 06	 lea	 eax, DWORD PTR [ebx+6]
  019b3	50		 push	 eax
  019b4	6a 7c		 push	 124			; 0000007cH
  019b6	57		 push	 edi
  019b7	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  019bc	66 89 84 35 c3
	fe ff ff	 mov	 WORD PTR _temp$10[ebp+esi-37], ax

; 1626 : 					pc.item[i].target = getIntegerToken(data, '|', no + 7);

  019c4	8d 43 07	 lea	 eax, DWORD PTR [ebx+7]
  019c7	50		 push	 eax
  019c8	6a 7c		 push	 124			; 0000007cH
  019ca	57		 push	 edi
  019cb	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  019d0	0f b7 c0	 movzx	 eax, ax
  019d3	83 c4 24	 add	 esp, 36			; 00000024H
  019d6	66 89 84 35 c5
	fe ff ff	 mov	 WORD PTR _temp$10[ebp+esi-35], ax

; 1627 : 					if (pc.item[i].target >= 100)

  019de	66 83 f8 64	 cmp	 ax, 100			; 00000064H
  019e2	7c 16		 jl	 SHORT $LN221@lssproto_S

; 1628 : 					{
; 1629 : 						pc.item[i].target %= 100;

  019e4	98		 cwde
  019e5	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  019ea	99		 cdq
  019eb	f7 f9		 idiv	 ecx

; 1630 : 						pc.item[i].deadTargetFlag = 1;

  019ed	8d 41 9d	 lea	 eax, DWORD PTR [ecx-99]
  019f0	66 89 94 35 c5
	fe ff ff	 mov	 WORD PTR _temp$10[ebp+esi-35], dx

; 1631 : 					}

  019f8	eb 02		 jmp	 SHORT $LN222@lssproto_S
$LN221@lssproto_S:

; 1632 : 					else
; 1633 : 						pc.item[i].deadTargetFlag = 0;

  019fa	33 c0		 xor	 eax, eax
$LN222@lssproto_S:

; 1634 : 					pc.item[i].level = getIntegerToken(data, '|', no + 8);

  019fc	66 89 84 35 c7
	fe ff ff	 mov	 WORD PTR _temp$10[ebp+esi-33], ax
  01a04	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  01a07	50		 push	 eax
  01a08	6a 7c		 push	 124			; 0000007cH
  01a0a	57		 push	 edi
  01a0b	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01a10	89 84 35 ed fd
	ff ff		 mov	 DWORD PTR _temp$10[ebp+esi-251], eax

; 1635 : 					pc.item[i].sendFlag = getIntegerToken(data, '|', no + 9);

  01a17	8d 43 09	 lea	 eax, DWORD PTR [ebx+9]
  01a1a	50		 push	 eax
  01a1b	6a 7c		 push	 124			; 0000007cH
  01a1d	57		 push	 edi
  01a1e	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01a23	66 89 84 35 c9
	fe ff ff	 mov	 WORD PTR _temp$10[ebp+esi-31], ax

; 1636 : 
; 1637 : 					// æ˜¾ç¤ºç‰©å“è€ä¹…åº¦
; 1638 : 					getStringToken(data, '|', no + 10, sizeof(temp) - 1, temp);

  01a2b	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$10[ebp]
  01a31	50		 push	 eax
  01a32	68 ff 00 00 00	 push	 255			; 000000ffH
  01a37	8d 43 0a	 lea	 eax, DWORD PTR [ebx+10]
  01a3a	50		 push	 eax
  01a3b	6a 7c		 push	 124			; 0000007cH
  01a3d	57		 push	 edi
  01a3e	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1639 : 					makeStringFromEscaped(temp);

  01a43	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$10[ebp]
  01a49	50		 push	 eax
  01a4a	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1640 : 					if (strlen(temp) <= 16)

  01a4f	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$10[ebp]
  01a55	83 c4 30	 add	 esp, 48			; 00000030H
  01a58	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  01a5b	0f 1f 44 00 00	 npad	 5
$LL430@lssproto_S:
  01a60	8a 01		 mov	 al, BYTE PTR [ecx]
  01a62	41		 inc	 ecx
  01a63	84 c0		 test	 al, al
  01a65	75 f9		 jne	 SHORT $LL430@lssproto_S
  01a67	2b ca		 sub	 ecx, edx
  01a69	83 f9 10	 cmp	 ecx, 16			; 00000010H
  01a6c	77 13		 ja	 SHORT $LN223@lssproto_S

; 1641 : 						strcpy(pc.item[i].damage, temp);

  01a6e	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$10[ebp]
$LL261@lssproto_S:
  01a74	8a 01		 mov	 al, BYTE PTR [ecx]
  01a76	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  01a79	88 44 31 65	 mov	 BYTE PTR [ecx+esi+101], al
  01a7d	84 c0		 test	 al, al
  01a7f	75 f3		 jne	 SHORT $LL261@lssproto_S
$LN223@lssproto_S:

; 1642 : #ifdef _ITEM_PILENUMS
; 1643 : 					getStringToken(data, '|', no + 11, sizeof(temp) - 1, temp);

  01a81	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$10[ebp]
  01a87	50		 push	 eax
  01a88	68 ff 00 00 00	 push	 255			; 000000ffH
  01a8d	8d 43 0b	 lea	 eax, DWORD PTR [ebx+11]
  01a90	50		 push	 eax
  01a91	6a 7c		 push	 124			; 0000007cH
  01a93	57		 push	 edi
  01a94	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1644 : 					makeStringFromEscaped(temp);

  01a99	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$10[ebp]
  01a9f	50		 push	 eax
  01aa0	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1645 : 					pc.item[i].pile = atoi(temp);

  01aa5	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$10[ebp]
  01aab	50		 push	 eax
  01aac	e8 00 00 00 00	 call	 _atoi
  01ab1	89 84 35 f1 fd
	ff ff		 mov	 DWORD PTR _temp$10[ebp+esi-247], eax

; 1646 : #endif
; 1647 : #ifdef _ALCHEMIST //_ITEMSET7_TXT
; 1648 : 					getStringToken(data, '|', no + 12, sizeof(temp) - 1, temp);

  01ab8	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$10[ebp]
  01abe	50		 push	 eax
  01abf	68 ff 00 00 00	 push	 255			; 000000ffH
  01ac4	8d 43 0c	 lea	 eax, DWORD PTR [ebx+12]
  01ac7	50		 push	 eax
  01ac8	6a 7c		 push	 124			; 0000007cH
  01aca	57		 push	 edi
  01acb	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1649 : 					makeStringFromEscaped(temp);

  01ad0	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$10[ebp]
  01ad6	50		 push	 eax
  01ad7	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  01adc	83 c4 34	 add	 esp, 52			; 00000034H

; 1650 : 					strcpy(pc.item[i].alch, temp);

  01adf	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$10[ebp]
  01ae5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL262@lssproto_S:
  01af0	8a 01		 mov	 al, BYTE PTR [ecx]
  01af2	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  01af5	88 84 31 0c ff
	ff ff		 mov	 BYTE PTR [ecx+esi-244], al
  01afc	84 c0		 test	 al, al
  01afe	75 f0		 jne	 SHORT $LL262@lssproto_S

; 1651 : #endif
; 1652 : #ifdef _PET_ITEM
; 1653 : 					pc.item[i].type = getIntegerToken(data, '|', no + 13);

  01b00	8d 43 0d	 lea	 eax, DWORD PTR [ebx+13]
  01b03	50		 push	 eax
  01b04	6a 7c		 push	 124			; 0000007cH
  01b06	57		 push	 edi
  01b07	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01b0c	8b 8d 88 fc ff
	ff		 mov	 ecx, DWORD PTR tv7756[ebp]
  01b12	83 c4 0c	 add	 esp, 12			; 0000000cH
  01b15	88 01		 mov	 BYTE PTR [ecx], al
$LN16@lssproto_S:

; 1571 : 				for (i = 0; i < MAX_ITEM; i++)

  01b17	8b 85 88 fc ff
	ff		 mov	 eax, DWORD PTR tv7756[ebp]
  01b1d	81 c6 7c 01 00
	00		 add	 esi, 380		; 0000017cH
  01b23	8b 8d 80 fc ff
	ff		 mov	 ecx, DWORD PTR _i$1$[ebp]
  01b29	05 7c 01 00 00	 add	 eax, 380		; 0000017cH
  01b2e	41		 inc	 ecx
  01b2f	89 85 88 fc ff
	ff		 mov	 DWORD PTR tv7756[ebp], eax
  01b35	89 8d 80 fc ff
	ff		 mov	 DWORD PTR _i$1$[ebp], ecx
  01b3b	3d 65 52 00 00	 cmp	 eax, OFFSET ?pc@@3UPC@@A+21093
  01b40	0f 8c fa fc ff
	ff		 jl	 $LL18@lssproto_S
  01b46	5e		 pop	 esi
  01b47	5b		 pop	 ebx
  01b48	5f		 pop	 edi

; 1803 : 			}
; 1804 : 			break;
; 1805 :     }
; 1806 : } 

  01b49	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01b4c	33 cd		 xor	 ecx, ebp
  01b4e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01b53	8b e5		 mov	 esp, ebp
  01b55	5d		 pop	 ebp
  01b56	c3		 ret	 0
$LN224@lssproto_S:

; 1654 : #endif
; 1655 : 
; 1656 : 				}
; 1657 : 			}
; 1658 : 			break;
; 1659 : 		//æŽ¥æ”¶åˆ°çš„å® ç‰©æŠ€èƒ½
; 1660 : 		case 'W':
; 1661 : 			{
; 1662 : 				int i, no, no2;
; 1663 : 				char temp[256];
; 1664 : 
; 1665 : 				no = data[1] - '0';

  01b57	0f be 47 01	 movsx	 eax, BYTE PTR [edi+1]

; 1666 : 				data += 3;
; 1667 : 				for (i = 0; i < MAX_SKILL; i++)
; 1668 : 					petSkill[no][i].useFlag = 0;

  01b5b	33 c9		 xor	 ecx, ecx
  01b5d	83 e8 30	 sub	 eax, 48			; 00000030H
  01b60	83 c7 03	 add	 edi, 3
  01b63	89 85 84 fc ff
	ff		 mov	 DWORD PTR _no$1$[ebp], eax
  01b69	be 01 00 00 00	 mov	 esi, 1
  01b6e	69 c0 e6 02 00
	00		 imul	 eax, eax, 742

; 1669 : 				for (i = 0; i < MAX_SKILL; i++)

  01b74	33 db		 xor	 ebx, ebx
  01b76	89 9d 88 fc ff
	ff		 mov	 DWORD PTR _i$1$[ebp], ebx
  01b7c	66 89 88 00 00
	00 00		 mov	 WORD PTR ?petSkill@@3PAY06UPET_SKILL@@A[eax], cx
  01b83	66 89 88 6a 00
	00 00		 mov	 WORD PTR ?petSkill@@3PAY06UPET_SKILL@@A[eax+106], cx
  01b8a	66 89 88 d4 00
	00 00		 mov	 WORD PTR ?petSkill@@3PAY06UPET_SKILL@@A[eax+212], cx
  01b91	66 89 88 3e 01
	00 00		 mov	 WORD PTR ?petSkill@@3PAY06UPET_SKILL@@A[eax+318], cx
  01b98	66 89 88 a8 01
	00 00		 mov	 WORD PTR ?petSkill@@3PAY06UPET_SKILL@@A[eax+424], cx
  01b9f	66 89 88 12 02
	00 00		 mov	 WORD PTR ?petSkill@@3PAY06UPET_SKILL@@A[eax+530], cx
  01ba6	66 89 88 7c 02
	00 00		 mov	 WORD PTR ?petSkill@@3PAY06UPET_SKILL@@A[eax+636], cx
  01bad	0f 1f 00	 npad	 3
$LL24@lssproto_S:

; 1670 : 				{
; 1671 : 					no2 = i * 5;
; 1672 : 					getStringToken(data, '|', no2 + 4, sizeof(temp) - 1, temp);

  01bb0	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _temp$4[ebp]
  01bb6	50		 push	 eax
  01bb7	68 ff 00 00 00	 push	 255			; 000000ffH
  01bbc	8d 46 03	 lea	 eax, DWORD PTR [esi+3]
  01bbf	50		 push	 eax
  01bc0	6a 7c		 push	 124			; 0000007cH
  01bc2	57		 push	 edi
  01bc3	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1673 : 					makeStringFromEscaped(temp);

  01bc8	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _temp$4[ebp]
  01bce	50		 push	 eax
  01bcf	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1674 : 					if (strlen(temp) == 0)

  01bd4	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _temp$4[ebp]
  01bda	83 c4 18	 add	 esp, 24			; 00000018H
  01bdd	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL431@lssproto_S:
  01be0	8a 01		 mov	 al, BYTE PTR [ecx]
  01be2	41		 inc	 ecx
  01be3	84 c0		 test	 al, al
  01be5	75 f9		 jne	 SHORT $LL431@lssproto_S
  01be7	2b ca		 sub	 ecx, edx
  01be9	0f 84 15 01 00
	00		 je	 $LN22@lssproto_S

; 1675 : 						continue;
; 1676 : 					petSkill[no][i].useFlag = 1;

  01bef	8b 95 84 fc ff
	ff		 mov	 edx, DWORD PTR _no$1$[ebp]
  01bf5	8d 04 d5 00 00
	00 00		 lea	 eax, DWORD PTR [edx*8]
  01bfc	2b c2		 sub	 eax, edx
  01bfe	03 c3		 add	 eax, ebx
  01c00	6b d8 6a	 imul	 ebx, eax, 106
  01c03	b8 01 00 00 00	 mov	 eax, 1
  01c08	66 89 83 00 00
	00 00		 mov	 WORD PTR ?petSkill@@3PAY06UPET_SKILL@@A[ebx], ax

; 1677 : 					if (strlen(temp) <= SKILL_NAME_LEN)

  01c0f	8d 93 08 00 00
	00		 lea	 edx, DWORD PTR ?petSkill@@3PAY06UPET_SKILL@@A[ebx+8]
  01c15	83 f9 18	 cmp	 ecx, 24			; 00000018H
  01c18	77 19		 ja	 SHORT $LN226@lssproto_S

; 1678 : 						strcpy(petSkill[no][i].name, temp);

  01c1a	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _temp$4[ebp]
  01c20	8b c1		 mov	 eax, ecx
  01c22	2b d0		 sub	 edx, eax
$LL263@lssproto_S:
  01c24	8a 01		 mov	 al, BYTE PTR [ecx]
  01c26	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  01c29	88 44 11 ff	 mov	 BYTE PTR [ecx+edx-1], al
  01c2d	84 c0		 test	 al, al
  01c2f	75 f3		 jne	 SHORT $LL263@lssproto_S
  01c31	eb 1c		 jmp	 SHORT $LN227@lssproto_S
$LN226@lssproto_S:

; 1679 : 					else
; 1680 : 						strcpy(petSkill[no][i].name, "??? name ???");

  01c33	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0N@GGCIJCKF@?$DP?$DP?$DP?5name?5?$DP?$DP?$DP@
  01c3b	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0N@GGCIJCKF@?$DP?$DP?$DP?5name?5?$DP?$DP?$DP@+8
  01c40	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  01c44	89 42 08	 mov	 DWORD PTR [edx+8], eax
  01c47	a0 0c 00 00 00	 mov	 al, BYTE PTR ??_C@_0N@GGCIJCKF@?$DP?$DP?$DP?5name?5?$DP?$DP?$DP@+12
  01c4c	88 42 0c	 mov	 BYTE PTR [edx+12], al
$LN227@lssproto_S:

; 1681 : 					petSkill[no][i].skillId = getIntegerToken(data, '|', no2 + 1);

  01c4f	56		 push	 esi
  01c50	6a 7c		 push	 124			; 0000007cH
  01c52	57		 push	 edi
  01c53	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01c58	66 89 83 02 00
	00 00		 mov	 WORD PTR ?petSkill@@3PAY06UPET_SKILL@@A[ebx+2], ax

; 1682 : 					petSkill[no][i].field = getIntegerToken(data, '|', no2 + 2);

  01c5f	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  01c62	50		 push	 eax
  01c63	6a 7c		 push	 124			; 0000007cH
  01c65	57		 push	 edi
  01c66	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01c6b	66 89 83 04 00
	00 00		 mov	 WORD PTR ?petSkill@@3PAY06UPET_SKILL@@A[ebx+4], ax

; 1683 : 					petSkill[no][i].target = getIntegerToken(data, '|', no2 + 3);

  01c72	8d 46 02	 lea	 eax, DWORD PTR [esi+2]
  01c75	50		 push	 eax
  01c76	6a 7c		 push	 124			; 0000007cH
  01c78	57		 push	 edi
  01c79	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01c7e	66 89 83 06 00
	00 00		 mov	 WORD PTR ?petSkill@@3PAY06UPET_SKILL@@A[ebx+6], ax

; 1684 : 					getStringToken(data, '|', no2 + 5, sizeof(temp) - 1, temp);

  01c85	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _temp$4[ebp]
  01c8b	50		 push	 eax
  01c8c	68 ff 00 00 00	 push	 255			; 000000ffH
  01c91	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  01c94	50		 push	 eax
  01c95	6a 7c		 push	 124			; 0000007cH
  01c97	57		 push	 edi
  01c98	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1685 : 					makeStringFromEscaped(temp);

  01c9d	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _temp$4[ebp]
  01ca3	50		 push	 eax
  01ca4	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1686 : 					if (strlen(temp) <= SKILL_MEMO_LEN)

  01ca9	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _temp$4[ebp]
  01caf	83 c4 3c	 add	 esp, 60			; 0000003cH
  01cb2	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL432@lssproto_S:
  01cb5	8a 01		 mov	 al, BYTE PTR [ecx]
  01cb7	41		 inc	 ecx
  01cb8	84 c0		 test	 al, al
  01cba	75 f9		 jne	 SHORT $LL432@lssproto_S
  01cbc	2b ca		 sub	 ecx, edx
  01cbe	8d 93 21 00 00
	00		 lea	 edx, DWORD PTR ?petSkill@@3PAY06UPET_SKILL@@A[ebx+33]
  01cc4	83 f9 48	 cmp	 ecx, 72			; 00000048H
  01cc7	77 19		 ja	 SHORT $LN228@lssproto_S

; 1687 : 						strcpy(petSkill[no][i].memo, temp);

  01cc9	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _temp$4[ebp]
  01ccf	8b c1		 mov	 eax, ecx
  01cd1	2b d0		 sub	 edx, eax
$LL264@lssproto_S:
  01cd3	8a 01		 mov	 al, BYTE PTR [ecx]
  01cd5	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  01cd8	88 44 11 ff	 mov	 BYTE PTR [ecx+edx-1], al
  01cdc	84 c0		 test	 al, al
  01cde	75 f3		 jne	 SHORT $LL264@lssproto_S
  01ce0	eb 1c		 jmp	 SHORT $LN443@lssproto_S
$LN228@lssproto_S:

; 1688 : 					else
; 1689 : 						strcpy(petSkill[no][i].memo, "??? memo ???");

  01ce2	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0N@HKHEIDPM@?$DP?$DP?$DP?5memo?5?$DP?$DP?$DP@
  01cea	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0N@HKHEIDPM@?$DP?$DP?$DP?5memo?5?$DP?$DP?$DP@+8
  01cef	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  01cf3	89 42 08	 mov	 DWORD PTR [edx+8], eax
  01cf6	a0 0c 00 00 00	 mov	 al, BYTE PTR ??_C@_0N@HKHEIDPM@?$DP?$DP?$DP?5memo?5?$DP?$DP?$DP@+12
  01cfb	88 42 0c	 mov	 BYTE PTR [edx+12], al
$LN443@lssproto_S:

; 1669 : 				for (i = 0; i < MAX_SKILL; i++)

  01cfe	8b 9d 88 fc ff
	ff		 mov	 ebx, DWORD PTR _i$1$[ebp]
$LN22@lssproto_S:
  01d04	43		 inc	 ebx
  01d05	83 c6 05	 add	 esi, 5
  01d08	89 9d 88 fc ff
	ff		 mov	 DWORD PTR _i$1$[ebp], ebx
  01d0e	83 fe 24	 cmp	 esi, 36			; 00000024H
  01d11	0f 8c 99 fe ff
	ff		 jl	 $LL24@lssproto_S
  01d17	5e		 pop	 esi
  01d18	5b		 pop	 ebx
  01d19	5f		 pop	 edi

; 1803 : 			}
; 1804 : 			break;
; 1805 :     }
; 1806 : } 

  01d1a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01d1d	33 cd		 xor	 ecx, ebp
  01d1f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01d24	8b e5		 mov	 esp, ebp
  01d26	5d		 pop	 ebp
  01d27	c3		 ret	 0
$LN230@lssproto_S:

; 1690 : 				}
; 1691 : 			}
; 1692 : 		break;
; 1693 : #ifdef _CHAR_PROFESSION			// WON ADD äººç‰©èŒä¸š
; 1694 : 		case 'S':
; 1695 : 			{
; 1696 : 				char name[CHAR_NAME_LEN + 1];
; 1697 : 				char memo[PROFESSION_MEMO_LEN + 1];
; 1698 : 				int i, count = 0;
; 1699 : 				
; 1700 : 				data++;

  01d28	47		 inc	 edi
  01d29	b8 06 00 00 00	 mov	 eax, OFFSET ?profession_skill@@3PAUPROFESSION_SKILL@@A+6
  01d2e	66 90		 npad	 2
$LL27@lssproto_S:

; 1701 : 				for (i = 0; i < MAX_PROFESSION_SKILL; i++)
; 1702 : 				{
; 1703 : 					profession_skill[i].useFlag = 0;

  01d30	33 c9		 xor	 ecx, ecx
  01d32	66 89 48 fa	 mov	 WORD PTR [eax-6], cx

; 1704 : 					profession_skill[i].kind = 0;

  01d36	66 89 08	 mov	 WORD PTR [eax], cx
  01d39	05 c0 00 00 00	 add	 eax, 192		; 000000c0H
  01d3e	3d 86 13 00 00	 cmp	 eax, OFFSET ?profession_skill@@3PAUPROFESSION_SKILL@@A+4998
  01d43	7c eb		 jl	 SHORT $LL27@lssproto_S

; 1705 : 				}
; 1706 : 				for (i = 0; i < MAX_PROFESSION_SKILL; i++)

  01d45	8d 71 02	 lea	 esi, DWORD PTR [ecx+2]
  01d48	b8 08 00 00 00	 mov	 eax, 8
  01d4d	8d 4d e8	 lea	 ecx, DWORD PTR _name$14[ebp]
  01d50	bb 00 00 00 00	 mov	 ebx, OFFSET ?profession_skill@@3PAUPROFESSION_SKILL@@A
  01d55	2b c1		 sub	 eax, ecx
  01d57	8d 8d 90 fd ff
	ff		 lea	 ecx, DWORD PTR _memo$3[ebp]
  01d5d	89 85 84 fc ff
	ff		 mov	 DWORD PTR tv7744[ebp], eax
  01d63	b8 5d 00 00 00	 mov	 eax, 93			; 0000005dH
  01d68	2b c1		 sub	 eax, ecx
  01d6a	89 85 7c fc ff
	ff		 mov	 DWORD PTR tv7742[ebp], eax
$LL30@lssproto_S:

; 1707 : 				{
; 1708 : 					count = i * 9;
; 1709 : 					profession_skill[i].useFlag  =  getIntegerToken(data, S_DELIM, 1 + count);

  01d70	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  01d73	50		 push	 eax
  01d74	6a 7c		 push	 124			; 0000007cH
  01d76	57		 push	 edi
  01d77	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 1710 : 					profession_skill[i].skillId  =  getIntegerToken(data, S_DELIM, 2 + count);

  01d7c	56		 push	 esi
  01d7d	6a 7c		 push	 124			; 0000007cH
  01d7f	57		 push	 edi
  01d80	66 89 03	 mov	 WORD PTR [ebx], ax
  01d83	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01d88	66 89 43 02	 mov	 WORD PTR [ebx+2], ax

; 1711 : 					profession_skill[i].target   =  getIntegerToken(data, S_DELIM, 3 + count);

  01d8c	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  01d8f	50		 push	 eax
  01d90	6a 7c		 push	 124			; 0000007cH
  01d92	57		 push	 edi
  01d93	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01d98	66 89 43 04	 mov	 WORD PTR [ebx+4], ax

; 1712 : 					profession_skill[i].kind	 =  getIntegerToken(data, S_DELIM, 4 + count);

  01d9c	8d 46 02	 lea	 eax, DWORD PTR [esi+2]
  01d9f	50		 push	 eax
  01da0	6a 7c		 push	 124			; 0000007cH
  01da2	57		 push	 edi
  01da3	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01da8	66 89 43 06	 mov	 WORD PTR [ebx+6], ax

; 1713 : 					profession_skill[i].icon	 =  getIntegerToken(data, S_DELIM, 5 + count);

  01dac	8d 46 03	 lea	 eax, DWORD PTR [esi+3]
  01daf	50		 push	 eax
  01db0	6a 7c		 push	 124			; 0000007cH
  01db2	57		 push	 edi
  01db3	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01db8	89 83 b4 00 00
	00		 mov	 DWORD PTR [ebx+180], eax

; 1714 : 					profession_skill[i].costmp	 =  getIntegerToken(data, S_DELIM, 6 + count);

  01dbe	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  01dc1	50		 push	 eax
  01dc2	6a 7c		 push	 124			; 0000007cH
  01dc4	57		 push	 edi
  01dc5	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01dca	83 c4 48	 add	 esp, 72			; 00000048H
  01dcd	89 83 b8 00 00
	00		 mov	 DWORD PTR [ebx+184], eax

; 1715 : 					profession_skill[i].skill_level = getIntegerToken(data, S_DELIM, 7 + count);

  01dd3	8d 46 05	 lea	 eax, DWORD PTR [esi+5]
  01dd6	50		 push	 eax
  01dd7	6a 7c		 push	 124			; 0000007cH
  01dd9	57		 push	 edi
  01dda	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01ddf	89 83 bc 00 00
	00		 mov	 DWORD PTR [ebx+188], eax
  01de5	0f 57 c0	 xorps	 xmm0, xmm0

; 1716 : 					memset(name, 0, sizeof(name));
; 1717 : 					getStringToken(data, S_DELIM, 8 + count, sizeof(name) - 1, name);

  01de8	8d 45 e8	 lea	 eax, DWORD PTR _name$14[ebp]
  01deb	c6 45 f8 00	 mov	 BYTE PTR _name$14[ebp+16], 0
  01def	50		 push	 eax
  01df0	6a 10		 push	 16			; 00000010H
  01df2	8d 46 06	 lea	 eax, DWORD PTR [esi+6]
  01df5	50		 push	 eax
  01df6	6a 7c		 push	 124			; 0000007cH
  01df8	57		 push	 edi
  01df9	0f 11 45 e8	 movups	 XMMWORD PTR _name$14[ebp], xmm0
  01dfd	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1718 : 					makeStringFromEscaped(name);

  01e02	8d 45 e8	 lea	 eax, DWORD PTR _name$14[ebp]
  01e05	50		 push	 eax
  01e06	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1719 : 					if (strlen(name) <= CHAR_NAME_LEN)

  01e0b	8d 4d e8	 lea	 ecx, DWORD PTR _name$14[ebp]
  01e0e	83 c4 24	 add	 esp, 36			; 00000024H
  01e11	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL433@lssproto_S:
  01e14	8a 01		 mov	 al, BYTE PTR [ecx]
  01e16	41		 inc	 ecx
  01e17	84 c0		 test	 al, al
  01e19	75 f9		 jne	 SHORT $LL433@lssproto_S
  01e1b	2b ca		 sub	 ecx, edx
  01e1d	83 f9 10	 cmp	 ecx, 16			; 00000010H
  01e20	77 1b		 ja	 SHORT $LN231@lssproto_S

; 1720 : 						strcpy(profession_skill[i].name, name);

  01e22	8b 95 84 fc ff
	ff		 mov	 edx, DWORD PTR tv7744[ebp]
  01e28	8d 4d e8	 lea	 ecx, DWORD PTR _name$14[ebp]
  01e2b	03 d3		 add	 edx, ebx
  01e2d	0f 1f 00	 npad	 3
$LL265@lssproto_S:
  01e30	8a 01		 mov	 al, BYTE PTR [ecx]
  01e32	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  01e35	88 44 11 ff	 mov	 BYTE PTR [ecx+edx-1], al
  01e39	84 c0		 test	 al, al
  01e3b	75 f3		 jne	 SHORT $LL265@lssproto_S
$LN231@lssproto_S:

; 1721 : 					memset(memo, 0, sizeof(memo));

  01e3d	6a 55		 push	 85			; 00000055H
  01e3f	8d 85 90 fd ff
	ff		 lea	 eax, DWORD PTR _memo$3[ebp]
  01e45	6a 00		 push	 0
  01e47	50		 push	 eax
  01e48	e8 00 00 00 00	 call	 _memset

; 1722 : 					getStringToken(data, S_DELIM, 9 + count, sizeof(memo) - 1, memo);

  01e4d	8d 85 90 fd ff
	ff		 lea	 eax, DWORD PTR _memo$3[ebp]
  01e53	50		 push	 eax
  01e54	6a 54		 push	 84			; 00000054H
  01e56	8d 46 07	 lea	 eax, DWORD PTR [esi+7]
  01e59	50		 push	 eax
  01e5a	6a 7c		 push	 124			; 0000007cH
  01e5c	57		 push	 edi
  01e5d	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1723 : 					makeStringFromEscaped(memo);

  01e62	8d 85 90 fd ff
	ff		 lea	 eax, DWORD PTR _memo$3[ebp]
  01e68	50		 push	 eax
  01e69	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1724 : 					if (strlen(memo) <= PROFESSION_MEMO_LEN)

  01e6e	8d 8d 90 fd ff
	ff		 lea	 ecx, DWORD PTR _memo$3[ebp]
  01e74	83 c4 24	 add	 esp, 36			; 00000024H
  01e77	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  01e7a	66 0f 1f 44 00
	00		 npad	 6
$LL434@lssproto_S:
  01e80	8a 01		 mov	 al, BYTE PTR [ecx]
  01e82	41		 inc	 ecx
  01e83	84 c0		 test	 al, al
  01e85	75 f9		 jne	 SHORT $LL434@lssproto_S
  01e87	2b ca		 sub	 ecx, edx
  01e89	83 f9 54	 cmp	 ecx, 84			; 00000054H
  01e8c	77 1f		 ja	 SHORT $LN28@lssproto_S

; 1725 : 						strcpy(profession_skill[i].memo, memo);

  01e8e	8b 95 7c fc ff
	ff		 mov	 edx, DWORD PTR tv7742[ebp]
  01e94	8d 8d 90 fd ff
	ff		 lea	 ecx, DWORD PTR _memo$3[ebp]
  01e9a	03 d3		 add	 edx, ebx
  01e9c	0f 1f 40 00	 npad	 4
$LL266@lssproto_S:
  01ea0	8a 01		 mov	 al, BYTE PTR [ecx]
  01ea2	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  01ea5	88 44 11 ff	 mov	 BYTE PTR [ecx+edx-1], al
  01ea9	84 c0		 test	 al, al
  01eab	75 f3		 jne	 SHORT $LL266@lssproto_S
$LN28@lssproto_S:

; 1705 : 				}
; 1706 : 				for (i = 0; i < MAX_PROFESSION_SKILL; i++)

  01ead	83 c6 09	 add	 esi, 9
  01eb0	81 c3 c0 00 00
	00		 add	 ebx, 192		; 000000c0H
  01eb6	81 fe ec 00 00
	00		 cmp	 esi, 236		; 000000ecH
  01ebc	0f 8c ae fe ff
	ff		 jl	 $LL30@lssproto_S

; 1726 : 				}
; 1727 : #ifdef _SKILLSORT
; 1728 : 				SortSkill();

  01ec2	e8 00 00 00 00	 call	 ?SortSkill@@YAXXZ	; SortSkill
  01ec7	5e		 pop	 esi
  01ec8	5b		 pop	 ebx
  01ec9	5f		 pop	 edi

; 1803 : 			}
; 1804 : 			break;
; 1805 :     }
; 1806 : } 

  01eca	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01ecd	33 cd		 xor	 ecx, ebp
  01ecf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01ed4	8b e5		 mov	 esp, ebp
  01ed6	5d		 pop	 ebp
  01ed7	c3		 ret	 0
$LN233@lssproto_S:

; 1729 : #endif
; 1730 : 			}
; 1731 : 		break;
; 1732 : #endif
; 1733 : #ifdef _PET_ITEM
; 1734 : 		case 'B':
; 1735 : 			{
; 1736 : 				int i, no, nPetIndex;
; 1737 : 				char szData[256];
; 1738 : 
; 1739 : 				nPetIndex = data[1] - '0';

  01ed8	0f be 47 01	 movsx	 eax, BYTE PTR [edi+1]
  01edc	bb 02 00 00 00	 mov	 ebx, 2
  01ee1	89 85 7c fc ff
	ff		 mov	 DWORD PTR tv7845[ebp], eax

; 1740 : 				data += 2;

  01ee7	83 c7 02	 add	 edi, 2
  01eea	83 c0 d0	 add	 eax, -48		; ffffffd0H
  01eed	89 bd 8c fc ff
	ff		 mov	 DWORD PTR _data$GSCopy$1$[ebp], edi
  01ef3	69 f0 78 0b 00
	00		 imul	 esi, eax, 2936
  01ef9	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _szData$9[ebp]
  01eff	c7 85 88 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv7740[ebp], 0
  01f09	c7 85 78 fc ff
	ff 64 00 00 00	 mov	 DWORD PTR tv7604[ebp], 100 ; 00000064H
  01f13	2b f0		 sub	 esi, eax
  01f15	81 c6 7f 01 00
	00		 add	 esi, OFFSET ?pet@@3PAUPET@@A+383
  01f1b	89 b5 84 fc ff
	ff		 mov	 DWORD PTR tv7671[ebp], esi
$LL33@lssproto_S:

; 1742 : 				{
; 1743 : 				//	no = i * 13;
; 1744 : 					no = i * 14;	//ä¿®å¤ä¸æ˜¾ç¤ºå® ç‰©èƒ¸ç”²å® è£…
; 1745 : 					getStringToken(data, '|', no + 1, sizeof(szData) - 1, szData);

  01f21	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _szData$9[ebp]
  01f27	50		 push	 eax
  01f28	68 ff 00 00 00	 push	 255			; 000000ffH
  01f2d	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  01f30	50		 push	 eax
  01f31	6a 7c		 push	 124			; 0000007cH
  01f33	57		 push	 edi
  01f34	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1746 : 					makeStringFromEscaped(szData);

  01f39	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _szData$9[ebp]
  01f3f	50		 push	 eax
  01f40	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1747 : 					if (strlen(szData) == 0)	// æ²¡é“å…·

  01f45	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _szData$9[ebp]
  01f4b	83 c4 18	 add	 esp, 24			; 00000018H
  01f4e	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL435@lssproto_S:
  01f51	8a 01		 mov	 al, BYTE PTR [ecx]
  01f53	41		 inc	 ecx
  01f54	84 c0		 test	 al, al
  01f56	75 f9		 jne	 SHORT $LL435@lssproto_S
  01f58	2b ca		 sub	 ecx, edx
  01f5a	75 1b		 jne	 SHORT $LN234@lssproto_S

; 1748 : 					{
; 1749 : 						memset(&pet[nPetIndex].item[i], 0, sizeof(pet[nPetIndex].item[i]));

  01f5c	68 7c 01 00 00	 push	 380			; 0000017cH
  01f61	51		 push	 ecx
  01f62	8d 84 35 e5 fd
	ff ff		 lea	 eax, DWORD PTR _szData$9[ebp+esi-259]
  01f69	50		 push	 eax
  01f6a	e8 00 00 00 00	 call	 _memset
  01f6f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1750 : 						continue;

  01f72	e9 ca 02 00 00	 jmp	 $LN31@lssproto_S
$LN234@lssproto_S:

; 1751 : 					}
; 1752 : 					pet[nPetIndex].item[i].useFlag = 1;

  01f77	b8 01 00 00 00	 mov	 eax, 1
  01f7c	66 89 84 35 c1
	fe ff ff	 mov	 WORD PTR _szData$9[ebp+esi-39], ax

; 1753 : 					if (strlen(szData) <= ITEM_NAME_LEN)

  01f84	83 f9 1c	 cmp	 ecx, 28			; 0000001cH
  01f87	77 14		 ja	 SHORT $LN235@lssproto_S

; 1754 : 						strcpy(pet[nPetIndex].item[i].name, szData);

  01f89	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _szData$9[ebp]
  01f8f	90		 npad	 1
$LL267@lssproto_S:
  01f90	8a 01		 mov	 al, BYTE PTR [ecx]
  01f92	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  01f95	88 44 0e e2	 mov	 BYTE PTR [esi+ecx-30], al
  01f99	84 c0		 test	 al, al
  01f9b	75 f3		 jne	 SHORT $LL267@lssproto_S
$LN235@lssproto_S:

; 1755 : 					getStringToken(data, '|', no + 2, sizeof(szData) - 1, szData);

  01f9d	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _szData$9[ebp]
  01fa3	50		 push	 eax
  01fa4	68 ff 00 00 00	 push	 255			; 000000ffH
  01fa9	53		 push	 ebx
  01faa	6a 7c		 push	 124			; 0000007cH
  01fac	57		 push	 edi
  01fad	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1756 : 					makeStringFromEscaped(szData);

  01fb2	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _szData$9[ebp]
  01fb8	50		 push	 eax
  01fb9	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1757 : 					if (strlen(szData) <= ITEM_NAME2_LEN)

  01fbe	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _szData$9[ebp]
  01fc4	83 c4 18	 add	 esp, 24			; 00000018H
  01fc7	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  01fca	66 0f 1f 44 00
	00		 npad	 6
$LL436@lssproto_S:
  01fd0	8a 01		 mov	 al, BYTE PTR [ecx]
  01fd2	41		 inc	 ecx
  01fd3	84 c0		 test	 al, al
  01fd5	75 f9		 jne	 SHORT $LL436@lssproto_S
  01fd7	2b ca		 sub	 ecx, edx
  01fd9	83 f9 10	 cmp	 ecx, 16			; 00000010H
  01fdc	77 13		 ja	 SHORT $LN236@lssproto_S

; 1758 : 						strcpy(pet[nPetIndex].item[i].name2, szData);

  01fde	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _szData$9[ebp]
$LL268@lssproto_S:
  01fe4	8a 01		 mov	 al, BYTE PTR [ecx]
  01fe6	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  01fe9	88 44 0e ff	 mov	 BYTE PTR [esi+ecx-1], al
  01fed	84 c0		 test	 al, al
  01fef	75 f3		 jne	 SHORT $LL268@lssproto_S
$LN236@lssproto_S:

; 1759 : 					pet[nPetIndex].item[i].color		= getIntegerToken(data, '|', no + 3);

  01ff1	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  01ff4	50		 push	 eax
  01ff5	6a 7c		 push	 124			; 0000007cH
  01ff7	57		 push	 edi
  01ff8	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01ffd	69 8d 7c fc ff
	ff 78 0b 00 00	 imul	 ecx, DWORD PTR tv7845[ebp], 2936
  02007	83 c4 0c	 add	 esp, 12			; 0000000cH
  0200a	8b b5 88 fc ff
	ff		 mov	 esi, DWORD PTR tv7740[ebp]
  02010	03 f1		 add	 esi, ecx
  02012	89 8d 80 fc ff
	ff		 mov	 DWORD PTR tv7785[ebp], ecx
  02018	89 86 fc d9 fd
	ff		 mov	 DWORD PTR ?pet@@3PAUPET@@A[esi-140804], eax

; 1760 : 					if (pet[nPetIndex].item[i].color < 0)

  0201e	85 c0		 test	 eax, eax
  02020	79 0a		 jns	 SHORT $LN237@lssproto_S

; 1761 : 						pet[nPetIndex].item[i].color			= 0;

  02022	c7 86 fc d9 fd
	ff 00 00 00 00	 mov	 DWORD PTR ?pet@@3PAUPET@@A[esi-140804], 0
$LN237@lssproto_S:

; 1762 : 					getStringToken(data, '|', no + 4, sizeof(szData) - 1, szData);

  0202c	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _szData$9[ebp]
  02032	50		 push	 eax
  02033	68 ff 00 00 00	 push	 255			; 000000ffH
  02038	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  0203b	50		 push	 eax
  0203c	6a 7c		 push	 124			; 0000007cH
  0203e	57		 push	 edi
  0203f	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1763 : 					makeStringFromEscaped(szData);

  02044	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _szData$9[ebp]
  0204a	50		 push	 eax
  0204b	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1764 : 					if (strlen(szData) <= ITEM_MEMO_LEN)

  02050	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _szData$9[ebp]
  02056	83 c4 18	 add	 esp, 24			; 00000018H
  02059	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0205c	0f 1f 40 00	 npad	 4
$LL437@lssproto_S:
  02060	8a 01		 mov	 al, BYTE PTR [ecx]
  02062	41		 inc	 ecx
  02063	84 c0		 test	 al, al
  02065	75 f9		 jne	 SHORT $LL437@lssproto_S
  02067	2b ca		 sub	 ecx, edx
  02069	83 f9 54	 cmp	 ecx, 84			; 00000054H
  0206c	77 22		 ja	 SHORT $LN238@lssproto_S

; 1765 : 						strcpy(pet[nPetIndex].item[i].memo, szData);

  0206e	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _szData$9[ebp]
  02074	8b d6		 mov	 edx, esi
  02076	8b c1		 mov	 eax, ecx
  02078	2b d0		 sub	 edx, eax
  0207a	66 0f 1f 44 00
	00		 npad	 6
$LL269@lssproto_S:
  02080	8a 01		 mov	 al, BYTE PTR [ecx]
  02082	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  02085	88 84 0a 0f db
	fd ff		 mov	 BYTE PTR ?pet@@3PAUPET@@A[edx+ecx-140529], al
  0208c	84 c0		 test	 al, al
  0208e	75 f0		 jne	 SHORT $LL269@lssproto_S
$LN238@lssproto_S:

; 1766 : 					pet[nPetIndex].item[i].graNo				= getIntegerToken(data, '|', no + 5);

  02090	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  02093	50		 push	 eax
  02094	6a 7c		 push	 124			; 0000007cH
  02096	57		 push	 edi
  02097	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0209c	8b 8d 80 fc ff
	ff		 mov	 ecx, DWORD PTR tv7785[ebp]
  020a2	8b 95 88 fc ff
	ff		 mov	 edx, DWORD PTR tv7740[ebp]
  020a8	89 84 11 00 da
	fd ff		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+edx-140800], eax

; 1767 : 					pet[nPetIndex].item[i].field				= getIntegerToken(data, '|', no + 6);

  020af	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  020b2	50		 push	 eax
  020b3	6a 7c		 push	 124			; 0000007cH
  020b5	57		 push	 edi
  020b6	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  020bb	66 89 86 da da
	fd ff		 mov	 WORD PTR ?pet@@3PAUPET@@A[esi-140582], ax

; 1768 : 					pet[nPetIndex].item[i].target				= getIntegerToken(data, '|', no + 7);

  020c2	8d 43 05	 lea	 eax, DWORD PTR [ebx+5]
  020c5	50		 push	 eax
  020c6	6a 7c		 push	 124			; 0000007cH
  020c8	57		 push	 edi
  020c9	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  020ce	0f b7 c0	 movzx	 eax, ax
  020d1	83 c4 24	 add	 esp, 36			; 00000024H
  020d4	66 89 86 dc da
	fd ff		 mov	 WORD PTR ?pet@@3PAUPET@@A[esi-140580], ax

; 1769 : 					if (pet[nPetIndex].item[i].target >= 100)

  020db	66 83 f8 64	 cmp	 ax, 100			; 00000064H
  020df	7c 2f		 jl	 SHORT $LN239@lssproto_S

; 1770 : 					{
; 1771 : 						pet[nPetIndex].item[i].target			%= 100;

  020e1	8b 95 88 fc ff
	ff		 mov	 edx, DWORD PTR tv7740[ebp]
  020e7	8d 8e 80 d9 fd
	ff		 lea	 ecx, DWORD PTR [esi-140928]
  020ed	8b 85 80 fc ff
	ff		 mov	 eax, DWORD PTR tv7785[ebp]
  020f3	0f bf 84 10 dc
	da fd ff	 movsx	 eax, WORD PTR ?pet@@3PAUPET@@A[eax+edx-140580]
  020fb	99		 cdq
  020fc	f7 bd 78 fc ff
	ff		 idiv	 DWORD PTR tv7604[ebp]
  02102	66 89 91 5c 01
	00 00		 mov	 WORD PTR ?pet@@3PAUPET@@A[ecx+348], dx

; 1772 : 						pet[nPetIndex].item[i].deadTargetFlag	= 1;

  02109	ba 01 00 00 00	 mov	 edx, 1

; 1773 : 					}

  0210e	eb 1c		 jmp	 SHORT $LN240@lssproto_S
$LN239@lssproto_S:

; 1774 : 					else
; 1775 : 						pet[nPetIndex].item[i].deadTargetFlag	= 0;

  02110	8b bd 88 fc ff
	ff		 mov	 edi, DWORD PTR tv7740[ebp]
  02116	33 d2		 xor	 edx, edx
  02118	8b 8d 80 fc ff
	ff		 mov	 ecx, DWORD PTR tv7785[ebp]
  0211e	81 c7 80 d9 fd
	ff		 add	 edi, -140928		; fffdd980H
  02124	03 cf		 add	 ecx, edi
  02126	8b bd 8c fc ff
	ff		 mov	 edi, DWORD PTR _data$GSCopy$1$[ebp]
$LN240@lssproto_S:

; 1776 : 					pet[nPetIndex].item[i].level				= getIntegerToken(data, '|', no + 8);

  0212c	8d 43 06	 lea	 eax, DWORD PTR [ebx+6]
  0212f	66 89 91 5e 01
	00 00		 mov	 WORD PTR ?pet@@3PAUPET@@A[ecx+350], dx
  02136	50		 push	 eax
  02137	6a 7c		 push	 124			; 0000007cH
  02139	57		 push	 edi
  0213a	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0213f	89 86 04 da fd
	ff		 mov	 DWORD PTR ?pet@@3PAUPET@@A[esi-140796], eax

; 1777 : 					pet[nPetIndex].item[i].sendFlag				= getIntegerToken(data, '|', no + 9);

  02145	8d 43 07	 lea	 eax, DWORD PTR [ebx+7]
  02148	50		 push	 eax
  02149	6a 7c		 push	 124			; 0000007cH
  0214b	57		 push	 edi
  0214c	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  02151	66 89 86 e0 da
	fd ff		 mov	 WORD PTR ?pet@@3PAUPET@@A[esi-140576], ax

; 1778 : 					
; 1779 : 					// æ˜¾ç¤ºç‰©å“è€ä¹…åº¦
; 1780 : 					getStringToken(data, '|', no + 10, sizeof(szData) - 1, szData);

  02158	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _szData$9[ebp]
  0215e	50		 push	 eax
  0215f	68 ff 00 00 00	 push	 255			; 000000ffH
  02164	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  02167	50		 push	 eax
  02168	6a 7c		 push	 124			; 0000007cH
  0216a	57		 push	 edi
  0216b	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1781 : 					makeStringFromEscaped(szData);

  02170	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _szData$9[ebp]
  02176	50		 push	 eax
  02177	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1782 : 					if (strlen(szData) <= 16)

  0217c	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _szData$9[ebp]
  02182	83 c4 30	 add	 esp, 48			; 00000030H
  02185	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL438@lssproto_S:
  02188	8a 01		 mov	 al, BYTE PTR [ecx]
  0218a	41		 inc	 ecx
  0218b	84 c0		 test	 al, al
  0218d	75 f9		 jne	 SHORT $LL438@lssproto_S
  0218f	2b ca		 sub	 ecx, edx
  02191	83 f9 10	 cmp	 ecx, 16			; 00000010H
  02194	77 1c		 ja	 SHORT $LN241@lssproto_S

; 1783 : 						strcpy(pet[nPetIndex].item[i].damage, szData);

  02196	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _szData$9[ebp]
  0219c	8b d6		 mov	 edx, esi
  0219e	8b c1		 mov	 eax, ecx
  021a0	2b d0		 sub	 edx, eax
$LL270@lssproto_S:
  021a2	8a 01		 mov	 al, BYTE PTR [ecx]
  021a4	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  021a7	88 84 0a 64 db
	fd ff		 mov	 BYTE PTR ?pet@@3PAUPET@@A[edx+ecx-140444], al
  021ae	84 c0		 test	 al, al
  021b0	75 f0		 jne	 SHORT $LL270@lssproto_S
$LN241@lssproto_S:

; 1784 : 					pet[nPetIndex].item[i].pile					= getIntegerToken(data, '|', no + 11);

  021b2	8d 43 09	 lea	 eax, DWORD PTR [ebx+9]
  021b5	50		 push	 eax
  021b6	6a 7c		 push	 124			; 0000007cH
  021b8	57		 push	 edi
  021b9	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  021be	89 86 08 da fd
	ff		 mov	 DWORD PTR ?pet@@3PAUPET@@A[esi-140792], eax

; 1785 : 	#ifdef _ALCHEMIST //_ITEMSET7_TXT
; 1786 : 					getStringToken(data, '|', no + 12, sizeof(szData) - 1, szData);

  021c4	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _szData$9[ebp]
  021ca	50		 push	 eax
  021cb	68 ff 00 00 00	 push	 255			; 000000ffH
  021d0	8d 43 0a	 lea	 eax, DWORD PTR [ebx+10]
  021d3	50		 push	 eax
  021d4	6a 7c		 push	 124			; 0000007cH
  021d6	57		 push	 edi
  021d7	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1787 : 					makeStringFromEscaped(szData);

  021dc	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _szData$9[ebp]
  021e2	50		 push	 eax
  021e3	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1788 : 					strcpy(pet[nPetIndex].item[i].alch, szData);

  021e8	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _szData$9[ebp]
  021ee	83 c4 24	 add	 esp, 36			; 00000024H
  021f1	8b c1		 mov	 eax, ecx
  021f3	2b f0		 sub	 esi, eax
  021f5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL271@lssproto_S:
  02200	8a 01		 mov	 al, BYTE PTR [ecx]
  02202	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  02205	88 84 0e 0b da
	fd ff		 mov	 BYTE PTR ?pet@@3PAUPET@@A[esi+ecx-140789], al
  0220c	84 c0		 test	 al, al
  0220e	75 f0		 jne	 SHORT $LL271@lssproto_S

; 1789 : 	#endif
; 1790 : 					pet[nPetIndex].item[i].type					= getIntegerToken(data, '|', no + 13);

  02210	8d 43 0b	 lea	 eax, DWORD PTR [ebx+11]
  02213	50		 push	 eax
  02214	6a 7c		 push	 124			; 0000007cH
  02216	57		 push	 edi
  02217	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0221c	8b 8d 7c fc ff
	ff		 mov	 ecx, DWORD PTR tv7845[ebp]
  02222	83 c4 0c	 add	 esp, 12			; 0000000cH
  02225	8b 95 88 fc ff
	ff		 mov	 edx, DWORD PTR tv7740[ebp]
  0222b	83 c1 d0	 add	 ecx, -48		; ffffffd0H
  0222e	8b b5 84 fc ff
	ff		 mov	 esi, DWORD PTR tv7671[ebp]
  02234	69 c9 78 0b 00
	00		 imul	 ecx, ecx, 2936
  0223a	88 84 11 f5 01
	00 00		 mov	 BYTE PTR ?pet@@3PAUPET@@A[ecx+edx+501], al
$LN31@lssproto_S:

; 1741 : 				for (i = 0; i < MAX_PET_ITEM; i++)

  02241	81 85 88 fc ff
	ff 7c 01 00 00	 add	 DWORD PTR tv7740[ebp], 380 ; 0000017cH
  0224b	83 c3 0e	 add	 ebx, 14			; 0000000eH
  0224e	81 c6 7c 01 00
	00		 add	 esi, 380		; 0000017cH
  02254	89 b5 84 fc ff
	ff		 mov	 DWORD PTR tv7671[ebp], esi
  0225a	83 fb 64	 cmp	 ebx, 100		; 00000064H
  0225d	0f 8c be fc ff
	ff		 jl	 $LL33@lssproto_S
  02263	5e		 pop	 esi
  02264	5b		 pop	 ebx
  02265	5f		 pop	 edi

; 1803 : 			}
; 1804 : 			break;
; 1805 :     }
; 1806 : } 

  02266	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02269	33 cd		 xor	 ecx, ebp
  0226b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02270	8b e5		 mov	 esp, ebp
  02272	5d		 pop	 ebp
  02273	c3		 ret	 0
$LN242@lssproto_S:

; 1791 : 					//å¯æ‹¿ç»™å® ç‰©è£…å¤‡çš„é“å…·,å°±ä¸ä¼šæ˜¯æ‹¼å›¾äº†,ä»¥ä¸‹å°±å…äº†
; 1792 : 					//if( i == JigsawIdx )
; 1793 : 					//	SetJigsaw( pc.item[i].graNo, pc.item[i].jigsaw );
; 1794 : 				}
; 1795 : 			}
; 1796 : 			break;
; 1797 : #endif
; 1798 : 			case 'V':
; 1799 : 			{
; 1800 : 				extern int itemWndMaxBag;
; 1801 : 				//V|1
; 1802 : 				itemWndMaxBag = getIntegerToken(data, '|', 2);

  02274	6a 02		 push	 2
  02276	6a 7c		 push	 124			; 0000007cH
  02278	57		 push	 edi
  02279	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0227e	a3 00 00 00 00	 mov	 DWORD PTR ?itemWndMaxBag@@3HA, eax ; itemWndMaxBag
  02283	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN439@lssproto_S:
  02286	5e		 pop	 esi
  02287	5b		 pop	 ebx
$LN2@lssproto_S:

; 1803 : 			}
; 1804 : 			break;
; 1805 :     }
; 1806 : } 

  02288	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0228b	33 cd		 xor	 ecx, ebp
  0228d	5f		 pop	 edi
  0228e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02293	8b e5		 mov	 esp, ebp
  02295	5d		 pop	 ebp
  02296	c3		 ret	 0
  02297	90		 npad	 1
$LN413@lssproto_S:
  02298	00 00 00 00	 DD	 $LN233@lssproto_S
  0229c	00 00 00 00	 DD	 $LN35@lssproto_S
  022a0	00 00 00 00	 DD	 $LN39@lssproto_S
  022a4	00 00 00 00	 DD	 $LN170@lssproto_S
  022a8	00 00 00 00	 DD	 $LN112@lssproto_S
  022ac	00 00 00 00	 DD	 $LN439@lssproto_S
  022b0	00 00 00 00	 DD	 $LN439@lssproto_S
  022b4	00 00 00 00	 DD	 $LN213@lssproto_S
  022b8	00 00 00 00	 DD	 $LN171@lssproto_S
  022bc	00 00 00 00	 DD	 $LN117@lssproto_S
  022c0	00 00 00 00	 DD	 $LN439@lssproto_S
  022c4	00 00 00 00	 DD	 $LN115@lssproto_S
  022c8	00 00 00 00	 DD	 $LN177@lssproto_S
  022cc	00 00 00 00	 DD	 $LN439@lssproto_S
  022d0	00 00 00 00	 DD	 $LN41@lssproto_S
  022d4	00 00 00 00	 DD	 $LN439@lssproto_S
  022d8	00 00 00 00	 DD	 $LN439@lssproto_S
  022dc	00 00 00 00	 DD	 $LN230@lssproto_S
  022e0	00 00 00 00	 DD	 $LN439@lssproto_S
  022e4	00 00 00 00	 DD	 $LN439@lssproto_S
  022e8	00 00 00 00	 DD	 $LN242@lssproto_S
  022ec	00 00 00 00	 DD	 $LN224@lssproto_S
  022f0	00 00 00 00	 DD	 $LN40@lssproto_S
?lssproto_S_recv@@YAXHPAD@Z ENDP			; lssproto_S_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_R_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_R_recv@@YAXHPAD@Z PROC			; lssproto_R_recv, COMDAT

; 4181 : }

  00000	c2 00 00	 ret	 0
?lssproto_R_recv@@YAXHPAD@Z ENDP			; lssproto_R_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_CD_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_CD_recv@@YAXHPAD@Z PROC			; lssproto_CD_recv, COMDAT

; 2527 : void lssproto_CD_recv( int fd, char *data ){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2528 : 	int i, j;
; 2529 : 	int id;
; 2530 : 	if ( logOutFlag )

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  0000a	75 73		 jne	 SHORT $LN16@lssproto_C

; 2531 : 		return;
; 2532 : 	for ( i = 1; ; i++ ){

  0000c	53		 push	 ebx

; 2533 : //		id = getInteger62Token(data, '|', i );
; 2534 : 		id = getInteger62Token(data, ',', i );

  0000d	8b 5d 0c	 mov	 ebx, DWORD PTR _data$[ebp]
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	bf 01 00 00 00	 mov	 edi, 1
  00017	57		 push	 edi
  00018	6a 2c		 push	 44			; 0000002cH
  0001a	53		 push	 ebx
  0001b	e8 00 00 00 00	 call	 ?getInteger62Token@@YAHPADDH@Z ; getInteger62Token
  00020	8b f0		 mov	 esi, eax
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2535 : 		if ( id == -1 )

  00025	83 fe ff	 cmp	 esi, -1
  00028	74 52		 je	 SHORT $LN24@lssproto_C
  0002a	66 0f 1f 44 00
	00		 npad	 6
$LL4@lssproto_C:

; 2536 : 			break;
; 2537 : 
; 2538 : 		delCharObj( id );

  00030	56		 push	 esi
  00031	e8 00 00 00 00	 call	 ?delCharObj@@YAXH@Z	; delCharObj
  00036	83 c4 04	 add	 esp, 4
  00039	b8 04 00 00 00	 mov	 eax, OFFSET ?party@@3PAUPARTY@@A+4

; 2539 : 
; 2540 : 		for ( j = 0; j < MAX_PARTY; j++ ){

  0003e	33 c9		 xor	 ecx, ecx
$LL7@lssproto_C:

; 2541 : 			if ( party[j].useFlag != 0 && party[j].id == id ){

  00040	66 83 78 fc 00	 cmp	 WORD PTR [eax-4], 0
  00045	74 04		 je	 SHORT $LN5@lssproto_C
  00047	39 30		 cmp	 DWORD PTR [eax], esi
  00049	74 0d		 je	 SHORT $LN15@lssproto_C
$LN5@lssproto_C:

; 2539 : 
; 2540 : 		for ( j = 0; j < MAX_PARTY; j++ ){

  0004b	83 c0 30	 add	 eax, 48			; 00000030H
  0004e	41		 inc	 ecx
  0004f	3d f4 00 00 00	 cmp	 eax, OFFSET ?party@@3PAUPARTY@@A+244
  00054	7c ea		 jl	 SHORT $LL7@lssproto_C
  00056	eb 10		 jmp	 SHORT $LN2@lssproto_C
$LN15@lssproto_C:

; 2542 : 				party[j].ptAct = NULL;

  00058	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0005b	c1 e0 04	 shl	 eax, 4
  0005e	c7 80 2c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?party@@3PAUPARTY@@A[eax+44], 0
$LN2@lssproto_C:

; 2533 : //		id = getInteger62Token(data, '|', i );
; 2534 : 		id = getInteger62Token(data, ',', i );

  00068	47		 inc	 edi
  00069	57		 push	 edi
  0006a	6a 2c		 push	 44			; 0000002cH
  0006c	53		 push	 ebx
  0006d	e8 00 00 00 00	 call	 ?getInteger62Token@@YAHPADDH@Z ; getInteger62Token
  00072	8b f0		 mov	 esi, eax
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2535 : 		if ( id == -1 )

  00077	83 fe ff	 cmp	 esi, -1
  0007a	75 b4		 jne	 SHORT $LL4@lssproto_C
$LN24@lssproto_C:
  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
$LN16@lssproto_C:

; 2543 : 				break;
; 2544 : 			}
; 2545 : 		}
; 2546 : 	}
; 2547 : }

  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
?lssproto_CD_recv@@YAXHPAD@Z ENDP			; lssproto_CD_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_CA_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_data$GSCopy$1$ = -4160					; size = 4
tv346 = -4156						; size = 4
_charindex$1$ = -4152					; size = 4
tv290 = -4148						; size = 4
_dir$1$ = -4148						; size = 4
_effectno$1$ = -4144					; size = 4
_x$1$ = -4140						; size = 4
_y$1$ = -4136						; size = 4
_effectparam1$1$ = -4132				; size = 4
_effectparam2$1$ = -4128				; size = 4
_bigtoken$ = -4124					; size = 2048
_smalltoken$ = -2076					; size = 2048
_szStreetVendorTitle$ = -28				; size = 21
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_CA_recv@@YAXHPAD@Z PROC			; lssproto_CA_recv, COMDAT

; 2407 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 40 10 00 00	 mov	 eax, 4160		; 00001040H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]

; 2408 : 	char bigtoken[2048];
; 2409 : 	char smalltoken[2048];
; 2410 : 	int alreadytellC[1024];
; 2411 : 	int tellCindex = 0;
; 2412 : 	int tellflag;
; 2413 : 	int i, j;
; 2414 : 	int charindex;
; 2415 : 	int x;
; 2416 : 	int y;
; 2417 : 	int act;
; 2418 : 	int dir;
; 2419 : 	int effectno = 0, effectparam1 = 0, effectparam2 = 0;

  0001a	33 c0		 xor	 eax, eax
  0001c	57		 push	 edi
  0001d	33 ff		 xor	 edi, edi
  0001f	89 8d c0 ef ff
	ff		 mov	 DWORD PTR _data$GSCopy$1$[ebp], ecx
  00025	89 bd d0 ef ff
	ff		 mov	 DWORD PTR _effectno$1$[ebp], edi
  0002b	89 bd dc ef ff
	ff		 mov	 DWORD PTR _effectparam1$1$[ebp], edi
  00031	89 85 e0 ef ff
	ff		 mov	 DWORD PTR _effectparam2$1$[ebp], eax

; 2420 : #ifdef _STREET_VENDOR
; 2421 : 	char szStreetVendorTitle[21];
; 2422 : #endif
; 2423 : 	ACTION *ptAct;
; 2424 : 	if ( logOutFlag )

  00037	39 05 00 00 00
	00		 cmp	 DWORD PTR ?logOutFlag@@3HA, eax ; logOutFlag
  0003d	0f 85 74 03 00
	00		 jne	 $LN32@lssproto_C

; 2425 : 		return;
; 2426 : 	if ( encountNowFlag )

  00043	66 39 05 00 00
	00 00		 cmp	 WORD PTR ?encountNowFlag@@3FA, ax ; encountNowFlag
  0004a	0f 85 67 03 00
	00		 jne	 $LN32@lssproto_C

; 2432 : 	{
; 2433 : 		getStringToken(data, ',', i+1, sizeof(bigtoken ) - 1, bigtoken );

  00050	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00056	50		 push	 eax
  00057	68 ff 07 00 00	 push	 2047			; 000007ffH
  0005c	6a 01		 push	 1
  0005e	6a 2c		 push	 44			; 0000002cH
  00060	51		 push	 ecx
  00061	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2434 : 		if ( strlen(bigtoken ) == 0 )

  00066	8d 8d e4 ef ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  0006c	83 c4 14	 add	 esp, 20			; 00000014H
  0006f	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL41@lssproto_C:
  00072	8a 01		 mov	 al, BYTE PTR [ecx]
  00074	41		 inc	 ecx
  00075	84 c0		 test	 al, al
  00077	75 f9		 jne	 SHORT $LL41@lssproto_C
  00079	2b ca		 sub	 ecx, edx
  0007b	0f 84 36 03 00
	00		 je	 $LN32@lssproto_C

; 2427 : 	{
; 2428 : 		return;
; 2429 : 	}
; 2430 : 
; 2431 : 	for ( i = 0; ; i++ )

  00081	53		 push	 ebx
  00082	c7 85 c4 ef ff
	ff 01 00 00 00	 mov	 DWORD PTR tv346[ebp], 1
  0008c	56		 push	 esi
  0008d	0f 1f 00	 npad	 3
$LL4@lssproto_C:

; 2435 : 			break;
; 2436 : 		getStringToken(bigtoken, '|', 1, sizeof(smalltoken) - 1, smalltoken);

  00090	8d 85 e4 f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00096	50		 push	 eax
  00097	68 ff 07 00 00	 push	 2047			; 000007ffH
  0009c	6a 01		 push	 1
  0009e	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  000a4	6a 7c		 push	 124			; 0000007cH
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2437 : 		charindex = a62toi(smalltoken);

  000ac	8d 85 e4 f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 ?a62toi@@YAHPAD@Z	; a62toi
  000b8	89 85 c8 ef ff
	ff		 mov	 DWORD PTR _charindex$1$[ebp], eax

; 2438 : 		getStringToken(bigtoken, '|', 2, sizeof(smalltoken) - 1, smalltoken);

  000be	8d 85 e4 f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  000c4	50		 push	 eax
  000c5	68 ff 07 00 00	 push	 2047			; 000007ffH
  000ca	6a 02		 push	 2
  000cc	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  000d2	6a 7c		 push	 124			; 0000007cH
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2439 : 		x = atoi(smalltoken);

  000da	8d 85 e4 f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 _atoi
  000e6	89 85 d4 ef ff
	ff		 mov	 DWORD PTR _x$1$[ebp], eax

; 2440 : 		getStringToken(bigtoken, '|', 3, sizeof(smalltoken) - 1, smalltoken);

  000ec	8d 85 e4 f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  000f2	50		 push	 eax
  000f3	68 ff 07 00 00	 push	 2047			; 000007ffH
  000f8	6a 03		 push	 3
  000fa	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00100	6a 7c		 push	 124			; 0000007cH
  00102	50		 push	 eax
  00103	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00108	83 c4 44	 add	 esp, 68			; 00000044H

; 2441 : 		y = atoi(smalltoken);

  0010b	8d 85 e4 f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00111	50		 push	 eax
  00112	e8 00 00 00 00	 call	 _atoi
  00117	89 85 d8 ef ff
	ff		 mov	 DWORD PTR _y$1$[ebp], eax

; 2442 : 		getStringToken(bigtoken, '|', 4, sizeof(smalltoken) - 1, smalltoken);

  0011d	8d 85 e4 f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00123	50		 push	 eax
  00124	68 ff 07 00 00	 push	 2047			; 000007ffH
  00129	6a 04		 push	 4
  0012b	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00131	6a 7c		 push	 124			; 0000007cH
  00133	50		 push	 eax
  00134	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2443 : 		act = atoi(smalltoken);

  00139	8d 85 e4 f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 _atoi
  00145	8b d8		 mov	 ebx, eax

; 2444 : 		getStringToken(bigtoken, '|', 5, sizeof(smalltoken) - 1, smalltoken);

  00147	8d 85 e4 f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0014d	50		 push	 eax
  0014e	68 ff 07 00 00	 push	 2047			; 000007ffH
  00153	6a 05		 push	 5
  00155	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  0015b	6a 7c		 push	 124			; 0000007cH
  0015d	50		 push	 eax
  0015e	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2445 : 		dir = (atoi(smalltoken)+3)%8;

  00163	8d 85 e4 f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00169	50		 push	 eax
  0016a	e8 00 00 00 00	 call	 _atoi
  0016f	8d 70 03	 lea	 esi, DWORD PTR [eax+3]
  00172	81 e6 07 00 00
	80		 and	 esi, -2147483641	; 80000007H
  00178	79 05		 jns	 SHORT $LN43@lssproto_C
  0017a	4e		 dec	 esi
  0017b	83 ce f8	 or	 esi, -8			; fffffff8H
  0017e	46		 inc	 esi
$LN43@lssproto_C:

; 2446 : 		getStringToken(bigtoken, '|', 6, sizeof(smalltoken) - 1, smalltoken);

  0017f	8d 85 e4 f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00185	89 b5 cc ef ff
	ff		 mov	 DWORD PTR _dir$1$[ebp], esi
  0018b	50		 push	 eax
  0018c	68 ff 07 00 00	 push	 2047			; 000007ffH
  00191	6a 06		 push	 6
  00193	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00199	6a 7c		 push	 124			; 0000007cH
  0019b	50		 push	 eax
  0019c	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  001a1	83 c4 48	 add	 esp, 72			; 00000048H

; 2447 : #ifdef _STREET_VENDOR
; 2448 : 		if (act == 41) strncpy(szStreetVendorTitle,smalltoken,sizeof(szStreetVendorTitle));

  001a4	8d 85 e4 f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  001aa	83 fb 29	 cmp	 ebx, 41			; 00000029H
  001ad	75 17		 jne	 SHORT $LN11@lssproto_C
  001af	6a 15		 push	 21			; 00000015H
  001b1	50		 push	 eax
  001b2	8d 45 e4	 lea	 eax, DWORD PTR _szStreetVendorTitle$[ebp]
  001b5	50		 push	 eax
  001b6	e8 00 00 00 00	 call	 _strncpy
  001bb	8b 8d e0 ef ff
	ff		 mov	 ecx, DWORD PTR _effectparam2$1$[ebp]
  001c1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c4	eb 3f		 jmp	 SHORT $LN12@lssproto_C
$LN11@lssproto_C:

; 2449 : 		else
; 2450 : #endif
; 2451 : 		{
; 2452 : 		effectno = atoi(smalltoken);

  001c6	50		 push	 eax
  001c7	e8 00 00 00 00	 call	 _atoi
  001cc	8b f8		 mov	 edi, eax

; 2453 : 		effectparam1 = getIntegerToken(bigtoken, '|', 7 );

  001ce	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  001d4	6a 07		 push	 7
  001d6	6a 7c		 push	 124			; 0000007cH
  001d8	50		 push	 eax
  001d9	89 bd d0 ef ff
	ff		 mov	 DWORD PTR _effectno$1$[ebp], edi
  001df	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 2454 : 		effectparam2 = getIntegerToken(bigtoken, '|', 8 );

  001e4	6a 08		 push	 8
  001e6	89 85 dc ef ff
	ff		 mov	 DWORD PTR _effectparam1$1$[ebp], eax
  001ec	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  001f2	6a 7c		 push	 124			; 0000007cH
  001f4	50		 push	 eax
  001f5	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  001fa	8b c8		 mov	 ecx, eax
  001fc	83 c4 1c	 add	 esp, 28			; 0000001cH
  001ff	89 8d e0 ef ff
	ff		 mov	 DWORD PTR _effectparam2$1$[ebp], ecx
$LN12@lssproto_C:

; 2455 : 		}
; 2456 : 
; 2457 : 
; 2458 : 		if ( pc.id == charindex ){

  00205	8b 85 c8 ef ff
	ff		 mov	 eax, DWORD PTR _charindex$1$[ebp]
  0020b	39 05 08 00 00
	00		 cmp	 DWORD PTR ?pc@@3UPC@@A+8, eax
  00211	0f 85 e4 00 00
	00		 jne	 $LN13@lssproto_C

; 2459 : 			if ( pc.ptAct == NULL
; 2460 : 			 || (pc.ptAct != NULL && pc.ptAct->anim_chr_no == 0) )

  00217	a1 ec 50 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+20716
  0021c	85 c0		 test	 eax, eax
  0021e	0f 84 46 01 00
	00		 je	 $LN2@lssproto_C
  00224	83 b8 44 01 00
	00 00		 cmp	 DWORD PTR [eax+324], 0
  0022b	0f 84 39 01 00
	00		 je	 $LN2@lssproto_C

; 2461 : 			{
; 2462 : // JL 2016.8.25 ç¦æ­¢æŸ¥è¯¢
; 2463 : #if 0
; 2464 : 				if (bNewServer)
; 2465 : 					lssproto_C_send(sockfd, charindex );
; 2466 : 				else
; 2467 : 					old_lssproto_C_send(sockfd, charindex );
; 2468 : #endif
; 2469 : 			}
; 2470 : 			else
; 2471 : 			{
; 2472 : #ifdef _STREET_VENDOR
; 2473 : 				if (act == 41){

  00231	83 fb 29	 cmp	 ebx, 41			; 00000029H
  00234	0f 85 a1 00 00
	00		 jne	 $LN17@lssproto_C

; 2474 : 					if (pc.iOnStreetVendor == 1){

  0023a	83 3d b8 a1 00
	00 01		 cmp	 DWORD PTR ?pc@@3UPC@@A+41400, 1
  00241	0f 85 23 01 00
	00		 jne	 $LN2@lssproto_C

; 2475 : 						memset(pc.ptAct->szStreetVendorTitle,0,sizeof(pc.ptAct->szStreetVendorTitle));

  00247	6a 40		 push	 64			; 00000040H
  00249	05 e8 01 00 00	 add	 eax, 488		; 000001e8H
  0024e	6a 00		 push	 0
  00250	50		 push	 eax
  00251	e8 00 00 00 00	 call	 _memset

; 2476 : 						strncpy(pc.ptAct->szStreetVendorTitle,szStreetVendorTitle,sizeof(szStreetVendorTitle));

  00256	6a 15		 push	 21			; 00000015H
  00258	8d 45 e4	 lea	 eax, DWORD PTR _szStreetVendorTitle$[ebp]
  0025b	50		 push	 eax
  0025c	a1 ec 50 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+20716
  00261	05 e8 01 00 00	 add	 eax, 488		; 000001e8H
  00266	50		 push	 eax
  00267	e8 00 00 00 00	 call	 _strncpy

; 2477 : 						changePcAct( x, y, dir, act, effectno, effectparam1, effectparam2 );

  0026c	8b 85 e0 ef ff
	ff		 mov	 eax, DWORD PTR _effectparam2$1$[ebp]
  00272	50		 push	 eax
  00273	ff b5 dc ef ff
	ff		 push	 DWORD PTR _effectparam1$1$[ebp]
  00279	57		 push	 edi
  0027a	53		 push	 ebx
  0027b	56		 push	 esi
  0027c	ff b5 d8 ef ff
	ff		 push	 DWORD PTR _y$1$[ebp]
  00282	ff b5 d4 ef ff
	ff		 push	 DWORD PTR _x$1$[ebp]
  00288	e8 00 00 00 00	 call	 ?changePcAct@@YAXHHHHHHH@Z ; changePcAct
  0028d	83 c4 34	 add	 esp, 52			; 00000034H

; 2478 : #ifdef _STREET_VENDOR_CHANGE_ICON
; 2479 : 						if (bNewServer)

  00290	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bNewServer@@3HA, 0 ; bNewServer
  00297	6a 05		 push	 5
  00299	ff 35 00 00 00
	00		 push	 DWORD PTR ?nowGy@@3HA	; nowGy
  0029f	ff 35 00 00 00
	00		 push	 DWORD PTR ?nowGx@@3HA	; nowGx
  002a5	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  002ab	74 17		 je	 SHORT $LN20@lssproto_C

; 2480 : 							lssproto_AC_send(sockfd,nowGx,nowGy,5);

  002ad	e8 00 00 00 00	 call	 ?lssproto_AC_send@@YAXHHHH@Z ; lssproto_AC_send

; 2483 : 						setPcAction(5);

  002b2	83 c4 10	 add	 esp, 16			; 00000010H
  002b5	6a 05		 push	 5
  002b7	e8 00 00 00 00	 call	 ?setPcAction@@YAXH@Z	; setPcAction
  002bc	83 c4 04	 add	 esp, 4

; 2484 : #endif
; 2485 : 					}
; 2486 : 				}

  002bf	e9 a6 00 00 00	 jmp	 $LN2@lssproto_C
$LN20@lssproto_C:

; 2481 : 						else
; 2482 : 							old_lssproto_AC_send(sockfd,nowGx,nowGy,5);

  002c4	e8 00 00 00 00	 call	 ?old_lssproto_AC_send@@YAXHHHH@Z ; old_lssproto_AC_send

; 2483 : 						setPcAction(5);

  002c9	83 c4 10	 add	 esp, 16			; 00000010H
  002cc	6a 05		 push	 5
  002ce	e8 00 00 00 00	 call	 ?setPcAction@@YAXH@Z	; setPcAction
  002d3	83 c4 04	 add	 esp, 4

; 2484 : #endif
; 2485 : 					}
; 2486 : 				}

  002d6	e9 8f 00 00 00	 jmp	 $LN2@lssproto_C
$LN17@lssproto_C:

; 2487 : 				else
; 2488 : #endif
; 2489 : 				changePcAct( x, y, dir, act, effectno, effectparam1, effectparam2 );

  002db	51		 push	 ecx
  002dc	ff b5 dc ef ff
	ff		 push	 DWORD PTR _effectparam1$1$[ebp]
  002e2	57		 push	 edi
  002e3	53		 push	 ebx
  002e4	56		 push	 esi
  002e5	ff b5 d8 ef ff
	ff		 push	 DWORD PTR _y$1$[ebp]
  002eb	ff b5 d4 ef ff
	ff		 push	 DWORD PTR _x$1$[ebp]
  002f1	e8 00 00 00 00	 call	 ?changePcAct@@YAXHHHHHHH@Z ; changePcAct
  002f6	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2490 : 			}
; 2491 : 			continue;

  002f9	eb 6f		 jmp	 SHORT $LN2@lssproto_C
$LN13@lssproto_C:

; 2492 : 		}
; 2493 : 
; 2494 : 		ptAct = getCharObjAct( charindex );

  002fb	50		 push	 eax
  002fc	e8 00 00 00 00	 call	 ?getCharObjAct@@YAPAUaction@@H@Z ; getCharObjAct
  00301	8b f8		 mov	 edi, eax
  00303	83 c4 04	 add	 esp, 4

; 2495 : 		if ( ptAct == NULL ){

  00306	85 ff		 test	 edi, edi
  00308	74 60		 je	 SHORT $LN2@lssproto_C

; 2496 : 			tellflag = 0;
; 2497 : 			for ( j = 0; j < tellCindex; j++ ){
; 2498 : 				if ( alreadytellC[j] == charindex ){
; 2499 : 					tellflag = 1;
; 2500 : 					break;
; 2501 : 				}
; 2502 : 			}
; 2503 : 			if ( tellflag == 0 && tellCindex < sizeof(alreadytellC) ){
; 2504 : 				alreadytellC[tellCindex] = charindex;
; 2505 : 				tellCindex++;
; 2506 : // JL 2016.8.25 ç¦æ­¢æŸ¥è¯¢
; 2507 : #if 0
; 2508 : 				if (bNewServer)
; 2509 : 					lssproto_C_send(sockfd, charindex);
; 2510 : 				else
; 2511 : 					old_lssproto_C_send(sockfd, charindex);
; 2512 : #endif
; 2513 : 			}
; 2514 : 		}else{
; 2515 : 			ptAct->objIndex = charindex;

  0030a	8b 85 c8 ef ff
	ff		 mov	 eax, DWORD PTR _charindex$1$[ebp]
  00310	89 87 38 02 00
	00		 mov	 DWORD PTR [edi+568], eax

; 2516 : #ifdef _STREET_VENDOR
; 2517 : 			if (act == 41){

  00316	83 fb 29	 cmp	 ebx, 41			; 00000029H
  00319	75 25		 jne	 SHORT $LN26@lssproto_C

; 2518 : 				memset(ptAct->szStreetVendorTitle,0,sizeof(ptAct->szStreetVendorTitle));

  0031b	6a 40		 push	 64			; 00000040H
  0031d	8d b7 e8 01 00
	00		 lea	 esi, DWORD PTR [edi+488]
  00323	6a 00		 push	 0
  00325	56		 push	 esi
  00326	e8 00 00 00 00	 call	 _memset

; 2519 : 				strncpy(ptAct->szStreetVendorTitle,szStreetVendorTitle,sizeof(szStreetVendorTitle));

  0032b	6a 15		 push	 21			; 00000015H
  0032d	8d 45 e4	 lea	 eax, DWORD PTR _szStreetVendorTitle$[ebp]
  00330	50		 push	 eax
  00331	56		 push	 esi
  00332	e8 00 00 00 00	 call	 _strncpy
  00337	8b b5 cc ef ff
	ff		 mov	 esi, DWORD PTR _dir$1$[ebp]
  0033d	83 c4 18	 add	 esp, 24			; 00000018H
$LN26@lssproto_C:

; 2520 : 			}
; 2521 : #endif
; 2522 : 			changeCharAct( ptAct, x, y, dir, act, effectno, effectparam1, effectparam2 );

  00340	8b 85 e0 ef ff
	ff		 mov	 eax, DWORD PTR _effectparam2$1$[ebp]
  00346	50		 push	 eax
  00347	ff b5 dc ef ff
	ff		 push	 DWORD PTR _effectparam1$1$[ebp]
  0034d	ff b5 d0 ef ff
	ff		 push	 DWORD PTR _effectno$1$[ebp]
  00353	53		 push	 ebx
  00354	56		 push	 esi
  00355	ff b5 d8 ef ff
	ff		 push	 DWORD PTR _y$1$[ebp]
  0035b	ff b5 d4 ef ff
	ff		 push	 DWORD PTR _x$1$[ebp]
  00361	57		 push	 edi
  00362	e8 00 00 00 00	 call	 ?changeCharAct@@YAXPAUaction@@HHHHHHH@Z ; changeCharAct
  00367	83 c4 20	 add	 esp, 32			; 00000020H
$LN2@lssproto_C:

; 2432 : 	{
; 2433 : 		getStringToken(data, ',', i+1, sizeof(bigtoken ) - 1, bigtoken );

  0036a	8b 85 c4 ef ff
	ff		 mov	 eax, DWORD PTR tv346[ebp]
  00370	8d 8d e4 ef ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00376	51		 push	 ecx
  00377	40		 inc	 eax
  00378	68 ff 07 00 00	 push	 2047			; 000007ffH
  0037d	50		 push	 eax
  0037e	6a 2c		 push	 44			; 0000002cH
  00380	ff b5 c0 ef ff
	ff		 push	 DWORD PTR _data$GSCopy$1$[ebp]
  00386	89 85 c4 ef ff
	ff		 mov	 DWORD PTR tv346[ebp], eax
  0038c	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2434 : 		if ( strlen(bigtoken ) == 0 )

  00391	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00397	83 c4 14	 add	 esp, 20			; 00000014H
  0039a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0039d	0f 1f 00	 npad	 3
$LL42@lssproto_C:
  003a0	8a 08		 mov	 cl, BYTE PTR [eax]
  003a2	40		 inc	 eax
  003a3	84 c9		 test	 cl, cl
  003a5	75 f9		 jne	 SHORT $LL42@lssproto_C
  003a7	8b bd d0 ef ff
	ff		 mov	 edi, DWORD PTR _effectno$1$[ebp]
  003ad	2b c2		 sub	 eax, edx
  003af	0f 85 db fc ff
	ff		 jne	 $LL4@lssproto_C
  003b5	5e		 pop	 esi
  003b6	5b		 pop	 ebx
$LN32@lssproto_C:

; 2523 : 		}
; 2524 : 	}
; 2525 : }

  003b7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003ba	33 cd		 xor	 ecx, ebp
  003bc	5f		 pop	 edi
  003bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003c2	8b e5		 mov	 esp, ebp
  003c4	5d		 pop	 ebp
  003c5	c3		 ret	 0
?lssproto_CA_recv@@YAXHPAD@Z ENDP			; lssproto_CA_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_C_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_data$GSCopy$1$ = -12360				; size = 4
_herofloor$1$ = -12356					; size = 4
tv741 = -12352						; size = 4
_charType$1$ = -12348					; size = 4
_x$1$ = -12344						; size = 4
_y$1$ = -12340						; size = 4
_dir$1$ = -12336					; size = 4
_walkable$1$ = -12332					; size = 4
_profession_class$1$ = -12328				; size = 4
_profession_skill_point$1$ = -12324			; size = 4
_id$2$ = -12324						; size = 4
_level$ = -12320					; size = 4
_petlevel$ = -12316					; size = 4
_nameColor$ = -12312					; size = 4
_height$ = -12308					; size = 4
_charNameColor$2$ = -12304				; size = 4
_picture$1$ = -12297					; size = 1
tv756 = -12296						; size = 4
tv644 = -12296						; size = 4
tv642 = -12296						; size = 4
_profession_level$1$ = -12296				; size = 4
_x$2$ = -12296						; size = 4
_id$3$ = -12296						; size = 4
_fmname$ = -12292					; size = 2048
_freeName$ = -10244					; size = 2048
_name$ = -8196						; size = 2048
_petname$ = -6148					; size = 1024
_info$ = -5124						; size = 1024
_bigtoken$ = -4100					; size = 2048
_smalltoken$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_C_recv@@YAXHPAD@Z PROC			; lssproto_C_recv, COMDAT

; 2022 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 48 30 00 00	 mov	 eax, 12360		; 00003048H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2023 : 	int i, j, id, x, y, dir, graNo, level, nameColor, walkable, height, classNo, money, charType, charNameColor;
; 2024 : 	char bigtoken[2048], smalltoken[2048], name[2048], freeName[2048], info[1024], fmname[2048], petname[1024];
; 2025 : 	int petlevel;
; 2026 : #ifdef _CHAR_PROFESSION			// WON ADD äººç‰©èŒä¸š
; 2027 : 	int profession_class, profession_level, profession_skill_point;
; 2028 : #endif
; 2029 : #ifdef _ALLDOMAN // (ä¸å¯å¼€) Syu ADD æŽ’è¡Œæ¦œNPC
; 2030 : 	int herofloor;
; 2031 : #endif
; 2032 : #ifdef _NPC_PICTURE
; 2033 : 	char picture;
; 2034 : #endif
; 2035 : #ifdef _NB_æ–‡å­—ç§°å·
; 2036 : 	char nb_name[64];
; 2037 : 	int nb_namecolor;
; 2038 : #endif
; 2039 : #ifdef _NB_ä»»åŠ¡æŒ‡å¼•
; 2040 : 	int noticeNo;
; 2041 : #endif
; 2042 : 	ACTION *ptAct;
; 2043 : 
; 2044 : 	if (logOutFlag)

  00017	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  0001e	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00021	89 85 b8 cf ff
	ff		 mov	 DWORD PTR _data$GSCopy$1$[ebp], eax
  00027	0f 85 6a 0a 00
	00		 jne	 $LN65@lssproto_C

; 2045 : 		return;
; 2046 : 	if (encountNowFlag)

  0002d	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR ?encountNowFlag@@3FA, 0 ; encountNowFlag
  00035	0f 85 5c 0a 00
	00		 jne	 $LN65@lssproto_C

; 2049 : 	{
; 2050 : 		getStringToken(data, ',', i + 1, sizeof(bigtoken) - 1, bigtoken);

  0003b	8d 8d fc ef ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00041	51		 push	 ecx
  00042	68 ff 07 00 00	 push	 2047			; 000007ffH
  00047	6a 01		 push	 1
  00049	6a 2c		 push	 44			; 0000002cH
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2051 : 		if (strlen(bigtoken) == 0)

  00051	8d 8d fc ef ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00057	83 c4 14	 add	 esp, 20			; 00000014H
  0005a	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0005d	0f 1f 00	 npad	 3
$LL61@lssproto_C:
  00060	8a 01		 mov	 al, BYTE PTR [ecx]
  00062	41		 inc	 ecx
  00063	84 c0		 test	 al, al
  00065	75 f9		 jne	 SHORT $LL61@lssproto_C
  00067	2b ca		 sub	 ecx, edx
  00069	0f 84 28 0a 00
	00		 je	 $LN65@lssproto_C

; 2047 : 		return;
; 2048 : 	for (i = 0; ; i++)

  0006f	53		 push	 ebx
  00070	56		 push	 esi
  00071	c7 85 c0 cf ff
	ff 01 00 00 00	 mov	 DWORD PTR tv741[ebp], 1
  0007b	57		 push	 edi
  0007c	0f 1f 40 00	 npad	 4
$LL4@lssproto_C:

; 2052 : 			break;
; 2053 : #ifdef _OBJSEND_C
; 2054 : 		getStringToken(bigtoken, '|', 1, sizeof(smalltoken) - 1, smalltoken);

  00080	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00086	50		 push	 eax
  00087	68 ff 07 00 00	 push	 2047			; 000007ffH
  0008c	6a 01		 push	 1
  0008e	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00094	6a 7c		 push	 124			; 0000007cH
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2055 : 		if (strlen(smalltoken) == 0)

  0009c	8d 8d fc f7 ff
	ff		 lea	 ecx, DWORD PTR _smalltoken$[ebp]
  000a2	83 c4 14	 add	 esp, 20			; 00000014H
  000a5	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL62@lssproto_C:
  000a8	8a 01		 mov	 al, BYTE PTR [ecx]
  000aa	41		 inc	 ecx
  000ab	84 c0		 test	 al, al
  000ad	75 f9		 jne	 SHORT $LL62@lssproto_C
  000af	2b ca		 sub	 ecx, edx
  000b1	0f 84 dd 09 00
	00		 je	 $LN66@lssproto_C

; 2056 : 			return;
; 2057 : 		switch (atoi(smalltoken))

  000b7	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 _atoi
  000c3	48		 dec	 eax
  000c4	83 c4 04	 add	 esp, 4
  000c7	83 f8 03	 cmp	 eax, 3
  000ca	0f 87 82 09 00
	00		 ja	 $LN2@lssproto_C
  000d0	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN63@lssproto_C[eax*4]
$LN17@lssproto_C:

; 2058 : 		{
; 2059 : 		case 1://OBJTYPE_CHARA
; 2060 : 			//printf("bigtoken %s\n",bigtoken);
; 2061 : 			charType = getIntegerToken(bigtoken, '|', 2);

  000d7	6a 02		 push	 2
  000d9	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  000df	6a 7c		 push	 124			; 0000007cH
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  000e7	89 85 c4 cf ff
	ff		 mov	 DWORD PTR _charType$1$[ebp], eax

; 2062 : 			getStringToken(bigtoken, '|', 3, sizeof(smalltoken) - 1, smalltoken);

  000ed	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  000f3	50		 push	 eax
  000f4	68 ff 07 00 00	 push	 2047			; 000007ffH
  000f9	6a 03		 push	 3
  000fb	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00101	6a 7c		 push	 124			; 0000007cH
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2063 : 			id = a62toi(smalltoken);

  00109	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0010f	50		 push	 eax
  00110	e8 00 00 00 00	 call	 ?a62toi@@YAHPAD@Z	; a62toi
  00115	8b f8		 mov	 edi, eax

; 2064 : 			getStringToken(bigtoken, '|', 4, sizeof(smalltoken) - 1, smalltoken);

  00117	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0011d	50		 push	 eax
  0011e	68 ff 07 00 00	 push	 2047			; 000007ffH
  00123	6a 04		 push	 4
  00125	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  0012b	6a 7c		 push	 124			; 0000007cH
  0012d	50		 push	 eax
  0012e	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2065 : 			x = atoi(smalltoken);

  00133	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00139	50		 push	 eax
  0013a	e8 00 00 00 00	 call	 _atoi
  0013f	89 85 c8 cf ff
	ff		 mov	 DWORD PTR _x$1$[ebp], eax

; 2066 : 			getStringToken(bigtoken, '|', 5, sizeof(smalltoken) - 1, smalltoken);

  00145	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0014b	50		 push	 eax
  0014c	68 ff 07 00 00	 push	 2047			; 000007ffH
  00151	6a 05		 push	 5
  00153	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00159	6a 7c		 push	 124			; 0000007cH
  0015b	50		 push	 eax
  0015c	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00161	83 c4 50	 add	 esp, 80			; 00000050H

; 2067 : 			y = atoi(smalltoken);

  00164	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0016a	50		 push	 eax
  0016b	e8 00 00 00 00	 call	 _atoi
  00170	89 85 cc cf ff
	ff		 mov	 DWORD PTR _y$1$[ebp], eax

; 2068 : 			getStringToken(bigtoken, '|', 6, sizeof(smalltoken) - 1, smalltoken);

  00176	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0017c	50		 push	 eax
  0017d	68 ff 07 00 00	 push	 2047			; 000007ffH
  00182	6a 06		 push	 6
  00184	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  0018a	6a 7c		 push	 124			; 0000007cH
  0018c	50		 push	 eax
  0018d	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2069 : 			dir = (atoi(smalltoken) + 3) % 8;

  00192	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 _atoi
  0019e	83 c0 03	 add	 eax, 3
  001a1	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  001a6	79 05		 jns	 SHORT $LN69@lssproto_C
  001a8	48		 dec	 eax
  001a9	83 c8 f8	 or	 eax, -8			; fffffff8H
  001ac	40		 inc	 eax
$LN69@lssproto_C:
  001ad	89 85 d0 cf ff
	ff		 mov	 DWORD PTR _dir$1$[ebp], eax

; 2070 : 			getStringToken(bigtoken, '|', 7, sizeof(smalltoken) - 1, smalltoken);

  001b3	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  001b9	50		 push	 eax
  001ba	68 ff 07 00 00	 push	 2047			; 000007ffH
  001bf	6a 07		 push	 7
  001c1	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  001c7	6a 7c		 push	 124			; 0000007cH
  001c9	50		 push	 eax
  001ca	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2071 : 			graNo = atoi(smalltoken);

  001cf	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  001d5	50		 push	 eax
  001d6	e8 00 00 00 00	 call	 _atoi
  001db	8b d8		 mov	 ebx, eax

; 2072 : 			getStringToken(bigtoken, '|', 8, sizeof(smalltoken) - 1,smalltoken);

  001dd	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  001e3	50		 push	 eax
  001e4	68 ff 07 00 00	 push	 2047			; 000007ffH
  001e9	6a 08		 push	 8
  001eb	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  001f1	6a 7c		 push	 124			; 0000007cH
  001f3	50		 push	 eax
  001f4	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  001f9	83 c4 48	 add	 esp, 72			; 00000048H

; 2073 : 			level = atoi(smalltoken);

  001fc	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00202	50		 push	 eax
  00203	e8 00 00 00 00	 call	 _atoi

; 2074 : 			nameColor = getIntegerToken(bigtoken, '|', 9);

  00208	6a 09		 push	 9
  0020a	89 85 e0 cf ff
	ff		 mov	 DWORD PTR _level$[ebp], eax
  00210	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00216	6a 7c		 push	 124			; 0000007cH
  00218	50		 push	 eax
  00219	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0021e	89 85 e8 cf ff
	ff		 mov	 DWORD PTR _nameColor$[ebp], eax

; 2075 : 			getStringToken(bigtoken, '|', 10, sizeof(name) - 1, name);

  00224	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  0022a	50		 push	 eax
  0022b	68 ff 07 00 00	 push	 2047			; 000007ffH
  00230	6a 0a		 push	 10			; 0000000aH
  00232	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00238	6a 7c		 push	 124			; 0000007cH
  0023a	50		 push	 eax
  0023b	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2076 : 			makeStringFromEscaped(name);

  00240	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  00246	50		 push	 eax
  00247	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 2077 : 			getStringToken(bigtoken, '|', 11, sizeof(freeName) - 1, freeName);

  0024c	8d 85 fc d7 ff
	ff		 lea	 eax, DWORD PTR _freeName$[ebp]
  00252	50		 push	 eax
  00253	68 ff 07 00 00	 push	 2047			; 000007ffH
  00258	6a 0b		 push	 11			; 0000000bH
  0025a	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00260	6a 7c		 push	 124			; 0000007cH
  00262	50		 push	 eax
  00263	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2078 : 			makeStringFromEscaped(freeName);

  00268	8d 85 fc d7 ff
	ff		 lea	 eax, DWORD PTR _freeName$[ebp]
  0026e	50		 push	 eax
  0026f	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  00274	83 c4 40	 add	 esp, 64			; 00000040H

; 2079 : 			getStringToken(bigtoken, '|', 12, sizeof(smalltoken) - 1, smalltoken);

  00277	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0027d	50		 push	 eax
  0027e	68 ff 07 00 00	 push	 2047			; 000007ffH
  00283	6a 0c		 push	 12			; 0000000cH
  00285	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  0028b	6a 7c		 push	 124			; 0000007cH
  0028d	50		 push	 eax
  0028e	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2080 : 			walkable = atoi(smalltoken);

  00293	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00299	50		 push	 eax
  0029a	e8 00 00 00 00	 call	 _atoi
  0029f	89 85 d4 cf ff
	ff		 mov	 DWORD PTR _walkable$1$[ebp], eax

; 2081 : 			getStringToken(bigtoken, '|', 13, sizeof(smalltoken) - 1, smalltoken);

  002a5	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  002ab	50		 push	 eax
  002ac	68 ff 07 00 00	 push	 2047			; 000007ffH
  002b1	6a 0d		 push	 13			; 0000000dH
  002b3	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  002b9	6a 7c		 push	 124			; 0000007cH
  002bb	50		 push	 eax
  002bc	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2082 : 			height = atoi(smalltoken);

  002c1	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  002c7	50		 push	 eax
  002c8	e8 00 00 00 00	 call	 _atoi

; 2083 : 			charNameColor = getIntegerToken(bigtoken, '|', 14);

  002cd	6a 0e		 push	 14			; 0000000eH
  002cf	89 85 ec cf ff
	ff		 mov	 DWORD PTR _height$[ebp], eax
  002d5	6a 7c		 push	 124			; 0000007cH
  002d7	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  002dd	50		 push	 eax
  002de	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  002e3	89 85 f0 cf ff
	ff		 mov	 DWORD PTR _charNameColor$2$[ebp], eax

; 2084 : 			getStringToken(bigtoken , '|', 15, sizeof(fmname) - 1, fmname);

  002e9	8d 85 fc cf ff
	ff		 lea	 eax, DWORD PTR _fmname$[ebp]
  002ef	50		 push	 eax
  002f0	68 ff 07 00 00	 push	 2047			; 000007ffH
  002f5	6a 0f		 push	 15			; 0000000fH
  002f7	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  002fd	6a 7c		 push	 124			; 0000007cH
  002ff	50		 push	 eax
  00300	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00305	83 c4 50	 add	 esp, 80			; 00000050H

; 2085 : 			makeStringFromEscaped(fmname);

  00308	8d 85 fc cf ff
	ff		 lea	 eax, DWORD PTR _fmname$[ebp]
  0030e	50		 push	 eax
  0030f	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 2086 : 			getStringToken(bigtoken , '|', 16, sizeof(petname) - 1, petname);

  00314	8d 85 fc e7 ff
	ff		 lea	 eax, DWORD PTR _petname$[ebp]
  0031a	50		 push	 eax
  0031b	68 ff 03 00 00	 push	 1023			; 000003ffH
  00320	6a 10		 push	 16			; 00000010H
  00322	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00328	6a 7c		 push	 124			; 0000007cH
  0032a	50		 push	 eax
  0032b	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2087 : 			makeStringFromEscaped(petname);

  00330	8d 85 fc e7 ff
	ff		 lea	 eax, DWORD PTR _petname$[ebp]
  00336	50		 push	 eax
  00337	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 2088 : 			getStringToken(bigtoken, '|', 17, sizeof(smalltoken) - 1, smalltoken);

  0033c	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00342	50		 push	 eax
  00343	68 ff 07 00 00	 push	 2047			; 000007ffH
  00348	6a 11		 push	 17			; 00000011H
  0034a	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00350	6a 7c		 push	 124			; 0000007cH
  00352	50		 push	 eax
  00353	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2089 : 			petlevel = atoi(smalltoken);

  00358	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0035e	50		 push	 eax
  0035f	e8 00 00 00 00	 call	 _atoi
  00364	89 85 e4 cf ff
	ff		 mov	 DWORD PTR _petlevel$[ebp], eax

; 2090 : 
; 2091 : #ifdef _CHAR_PROFESSION			// WON ADD äººç‰©èŒä¸š
; 2092 : 			getStringToken(bigtoken, '|', 18, sizeof(smalltoken) - 1, smalltoken);

  0036a	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00370	50		 push	 eax
  00371	68 ff 07 00 00	 push	 2047			; 000007ffH
  00376	6a 12		 push	 18			; 00000012H
  00378	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  0037e	6a 7c		 push	 124			; 0000007cH
  00380	50		 push	 eax
  00381	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00386	83 c4 48	 add	 esp, 72			; 00000048H

; 2093 : 			profession_class = atoi(smalltoken);

  00389	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0038f	50		 push	 eax
  00390	e8 00 00 00 00	 call	 _atoi
  00395	89 85 d8 cf ff
	ff		 mov	 DWORD PTR _profession_class$1$[ebp], eax

; 2094 : 			getStringToken(bigtoken, '|', 19, sizeof(smalltoken) - 1, smalltoken);

  0039b	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  003a1	50		 push	 eax
  003a2	68 ff 07 00 00	 push	 2047			; 000007ffH
  003a7	6a 13		 push	 19			; 00000013H
  003a9	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  003af	6a 7c		 push	 124			; 0000007cH
  003b1	50		 push	 eax
  003b2	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2095 : 			profession_level = atoi(smalltoken);

  003b7	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  003bd	50		 push	 eax
  003be	e8 00 00 00 00	 call	 _atoi
  003c3	89 85 f8 cf ff
	ff		 mov	 DWORD PTR _profession_level$1$[ebp], eax

; 2096 : //			getStringToken(bigtoken, '|', 20, sizeof(smalltoken) - 1, smalltoken);
; 2097 : //			profession_exp = atoi(smalltoken);
; 2098 : 			getStringToken(bigtoken, '|', 20, sizeof(smalltoken) - 1, smalltoken);

  003c9	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  003cf	50		 push	 eax
  003d0	68 ff 07 00 00	 push	 2047			; 000007ffH
  003d5	6a 14		 push	 20			; 00000014H
  003d7	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  003dd	6a 7c		 push	 124			; 0000007cH
  003df	50		 push	 eax
  003e0	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2099 : 			profession_skill_point = atoi(smalltoken);

  003e5	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  003eb	50		 push	 eax
  003ec	e8 00 00 00 00	 call	 _atoi
  003f1	89 85 dc cf ff
	ff		 mov	 DWORD PTR _profession_skill_point$1$[ebp], eax

; 2100 : #ifdef _ALLDOMAN // Syu ADD æŽ’è¡Œæ¦œNPC
; 2101 : 			getStringToken(bigtoken, '|', 21, sizeof(smalltoken) - 1, smalltoken);

  003f7	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  003fd	50		 push	 eax
  003fe	68 ff 07 00 00	 push	 2047			; 000007ffH
  00403	6a 15		 push	 21			; 00000015H
  00405	6a 7c		 push	 124			; 0000007cH
  00407	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  0040d	50		 push	 eax
  0040e	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00413	83 c4 48	 add	 esp, 72			; 00000048H

; 2102 : 			herofloor = atoi(smalltoken);

  00416	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0041c	50		 push	 eax
  0041d	e8 00 00 00 00	 call	 _atoi
  00422	89 85 bc cf ff
	ff		 mov	 DWORD PTR _herofloor$1$[ebp], eax

; 2103 : #endif
; 2104 : #ifdef _NPC_PICTURE
; 2105 : 			getStringToken(bigtoken, '|', 22, sizeof(smalltoken) - 1, smalltoken);

  00428	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0042e	50		 push	 eax
  0042f	68 ff 07 00 00	 push	 2047			; 000007ffH
  00434	6a 16		 push	 22			; 00000016H
  00436	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  0043c	6a 7c		 push	 124			; 0000007cH
  0043e	50		 push	 eax
  0043f	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2106 : 			picture = atoi(smalltoken);

  00444	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0044a	50		 push	 eax
  0044b	e8 00 00 00 00	 call	 _atoi
  00450	88 85 f7 cf ff
	ff		 mov	 BYTE PTR _picture$1$[ebp], al

; 2107 : #endif
; 2108 : #ifdef _GM_IDENTIFY		// Rog ADD GMè¯†åˆ«
; 2109 : 			getStringToken(bigtoken , '|', 23 , sizeof( gm_name ) - 1, gm_name );
; 2110 : 			makeStringFromEscaped( gm_name );
; 2111 : #endif
; 2112 : #endif
; 2113 : #ifdef _NB_ä»»åŠ¡æŒ‡å¼•
; 2114 : 			getStringToken(bigtoken, '|', 23, sizeof(smalltoken) - 1, smalltoken);

  00456	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0045c	50		 push	 eax
  0045d	68 ff 07 00 00	 push	 2047			; 000007ffH
  00462	6a 17		 push	 23			; 00000017H
  00464	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  0046a	6a 7c		 push	 124			; 0000007cH
  0046c	50		 push	 eax
  0046d	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2115 : 			noticeNo = atoi(smalltoken);

  00472	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00478	50		 push	 eax
  00479	e8 00 00 00 00	 call	 _atoi
  0047e	8b f0		 mov	 esi, eax

; 2116 : 			//printf("name %s noticeNo %d\n",name,noticeNo);
; 2117 : #endif
; 2118 : #ifdef _NB_æ–‡å­—ç§°å·
; 2119 : 			getStringToken(bigtoken , '|', 24 , sizeof( nb_name ) - 1, nb_name);
; 2120 : 			makeStringFromEscaped(nb_name);
; 2121 : 			getStringToken(bigtoken, '|', 25, sizeof(smalltoken) - 1, smalltoken);
; 2122 : 			nb_namecolor = atoi(smalltoken);
; 2123 : #endif
; 2124 : 
; 2125 : 			if (charNameColor < 0)

  00480	33 c9		 xor	 ecx, ecx
  00482	8b 85 f0 cf ff
	ff		 mov	 eax, DWORD PTR _charNameColor$2$[ebp]
  00488	83 c4 34	 add	 esp, 52			; 00000034H
  0048b	85 c0		 test	 eax, eax
  0048d	0f 48 c1	 cmovs	 eax, ecx
  00490	89 85 f0 cf ff
	ff		 mov	 DWORD PTR _charNameColor$2$[ebp], eax

; 2126 : 				charNameColor = 0;
; 2127 : 			if (pc.id == id){

  00496	39 3d 08 00 00
	00		 cmp	 DWORD PTR ?pc@@3UPC@@A+8, edi
  0049c	0f 85 31 01 00
	00		 jne	 $LN19@lssproto_C

; 2128 : 				if (pc.ptAct == NULL){

  004a2	39 0d ec 50 00
	00		 cmp	 DWORD PTR ?pc@@3UPC@@A+20716, ecx
  004a8	75 22		 jne	 SHORT $LN21@lssproto_C

; 2129 : 					createPc(graNo, x, y, dir);

  004aa	ff b5 d0 cf ff
	ff		 push	 DWORD PTR _dir$1$[ebp]
  004b0	ff b5 cc cf ff
	ff		 push	 DWORD PTR _y$1$[ebp]
  004b6	ff b5 c8 cf ff
	ff		 push	 DWORD PTR _x$1$[ebp]
  004bc	53		 push	 ebx
  004bd	e8 00 00 00 00	 call	 ?createPc@@YAXHHHH@Z	; createPc
  004c2	83 c4 10	 add	 esp, 16			; 00000010H

; 2130 : 					updataPcAct();

  004c5	e8 00 00 00 00	 call	 ?updataPcAct@@YAXXZ	; updataPcAct

; 2131 : 				}

  004ca	eb 0f		 jmp	 SHORT $LN22@lssproto_C
$LN21@lssproto_C:

; 2132 : 				else
; 2133 : 					setPcGraNo(graNo, pc.dir);

  004cc	ff 35 0c 00 00
	00		 push	 DWORD PTR ?pc@@3UPC@@A+12
  004d2	53		 push	 ebx
  004d3	e8 00 00 00 00	 call	 ?setPcGraNo@@YAXHH@Z	; setPcGraNo
  004d8	83 c4 08	 add	 esp, 8
$LN22@lssproto_C:

; 2134 : 				updateMapArea();

  004db	e8 00 00 00 00	 call	 ?updateMapArea@@YAXXZ	; updateMapArea

; 2135 : 
; 2136 : #ifdef _NB_æ–‡å­—ç§°å·
; 2137 : 				setPcParam(name, freeName, level, petname, petlevel, nameColor, walkable, height, profession_class, profession_level, profession_skill_point,herofloor,nb_name,nb_namecolor);
; 2138 : #else
; 2139 : #ifdef _CHAR_PROFESSION			// WON ADD äººç‰©èŒä¸š
; 2140 : //    #ifdef _GM_IDENTIFY		// Rog ADD GMè¯†åˆ«
; 2141 : //				setPcParam(name, freeName, level, petname, petlevel, nameColor, walkable, height, profession_class, profession_level, profession_exp, profession_skill_point , gm_name);
; 2142 : //				setPcParam(name, freeName, level, petname, petlevel, nameColor, walkable, height, profession_class, profession_level, profession_skill_point , gm_name);
; 2143 : //    #else
; 2144 : //				setPcParam(name, freeName, level, petname, petlevel, nameColor, walkable, height, profession_class, profession_level, profession_exp, profession_skill_point);
; 2145 : #ifdef _ALLDOMAN // Syu ADD æŽ’è¡Œæ¦œNPC
; 2146 : 				setPcParam(name, freeName, level, petname, petlevel, nameColor, walkable, height, profession_class, profession_level, profession_skill_point , herofloor);

  004e0	ff b5 bc cf ff
	ff		 push	 DWORD PTR _herofloor$1$[ebp]
  004e6	8d 85 fc e7 ff
	ff		 lea	 eax, DWORD PTR _petname$[ebp]
  004ec	ff b5 dc cf ff
	ff		 push	 DWORD PTR _profession_skill_point$1$[ebp]
  004f2	ff b5 f8 cf ff
	ff		 push	 DWORD PTR _profession_level$1$[ebp]
  004f8	ff b5 d8 cf ff
	ff		 push	 DWORD PTR _profession_class$1$[ebp]
  004fe	ff b5 ec cf ff
	ff		 push	 DWORD PTR _height$[ebp]
  00504	ff b5 d4 cf ff
	ff		 push	 DWORD PTR _walkable$1$[ebp]
  0050a	ff b5 e8 cf ff
	ff		 push	 DWORD PTR _nameColor$[ebp]
  00510	ff b5 e4 cf ff
	ff		 push	 DWORD PTR _petlevel$[ebp]
  00516	50		 push	 eax
  00517	ff b5 e0 cf ff
	ff		 push	 DWORD PTR _level$[ebp]
  0051d	8d 85 fc d7 ff
	ff		 lea	 eax, DWORD PTR _freeName$[ebp]
  00523	50		 push	 eax
  00524	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  0052a	50		 push	 eax
  0052b	e8 00 00 00 00	 call	 ?setPcParam@@YAXPAD0H0HHHHHHHH@Z ; setPcParam

; 2147 : #else
; 2148 : 				setPcParam(name, freeName, level, petname, petlevel, nameColor, walkable, height, profession_class, profession_level, profession_skill_point);
; 2149 : #endif
; 2150 : //    #endif
; 2151 : #else
; 2152 : 				setPcParam(name, freeName, level, petname, petlevel, nameColor, walkable, height);
; 2153 : #endif
; 2154 : 
; 2155 : #endif
; 2156 : 				//JL è®¾ç½®id
; 2157 : 				pc.ptAct->objIndex = id;

  00530	a1 ec 50 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+20716
  00535	89 b8 38 02 00
	00		 mov	 DWORD PTR [eax+568], edi

; 2158 : 
; 2159 : 				setPcNameColor(charNameColor);

  0053b	8b 85 f0 cf ff
	ff		 mov	 eax, DWORD PTR _charNameColor$2$[ebp]
  00541	50		 push	 eax
  00542	e8 00 00 00 00	 call	 ?setPcNameColor@@YAXH@Z	; setPcNameColor
  00547	83 c4 34	 add	 esp, 52			; 00000034H

; 2160 : 				if ((pc.status & CHR_STATUS_LEADER) != 0 && party[0].useFlag != 0)

  0054a	f7 05 a4 00 00
	00 00 01 00 00	 test	 DWORD PTR ?pc@@3UPC@@A+164, 256 ; 00000100H
  00554	74 2d		 je	 SHORT $LN23@lssproto_C
  00556	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR ?party@@3PAUPARTY@@A, 0
  0055e	74 23		 je	 SHORT $LN23@lssproto_C

; 2161 : 				{
; 2162 : 					party[0].level = pc.level;

  00560	a1 38 00 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+56

; 2163 : 					strcpy(party[0].name, pc.name);

  00565	33 c9		 xor	 ecx, ecx
  00567	a3 08 00 00 00	 mov	 DWORD PTR ?party@@3PAUPARTY@@A+8, eax
  0056c	0f 1f 40 00	 npad	 4
$LL38@lssproto_C:
  00570	8a 81 70 00 00
	00		 mov	 al, BYTE PTR ?pc@@3UPC@@A[ecx+112]
  00576	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00579	88 81 17 00 00
	00		 mov	 BYTE PTR ?party@@3PAUPARTY@@A[ecx+23], al
  0057f	84 c0		 test	 al, al
  00581	75 ed		 jne	 SHORT $LL38@lssproto_C
$LN23@lssproto_C:

; 2164 : 				}
; 2165 : 				for (j = 0; j < MAX_PARTY; j++)

  00583	33 f6		 xor	 esi, esi
  00585	b8 04 00 00 00	 mov	 eax, OFFSET ?party@@3PAUPARTY@@A+4
  0058a	66 0f 1f 44 00
	00		 npad	 6
$LL9@lssproto_C:

; 2166 : 				{
; 2167 : 					if (party[j].useFlag != 0 && party[j].id == id)

  00590	66 83 78 fc 00	 cmp	 WORD PTR [eax-4], 0
  00595	74 04		 je	 SHORT $LN7@lssproto_C
  00597	39 38		 cmp	 DWORD PTR [eax], edi
  00599	74 10		 je	 SHORT $LN44@lssproto_C
$LN7@lssproto_C:

; 2164 : 				}
; 2165 : 				for (j = 0; j < MAX_PARTY; j++)

  0059b	83 c0 30	 add	 eax, 48			; 00000030H
  0059e	46		 inc	 esi
  0059f	3d f4 00 00 00	 cmp	 eax, OFFSET ?party@@3PAUPARTY@@A+244
  005a4	7c ea		 jl	 SHORT $LL9@lssproto_C
  005a6	e9 a7 04 00 00	 jmp	 $LN2@lssproto_C
$LN44@lssproto_C:

; 2168 : 					{
; 2169 : 						party[j].ptAct = pc.ptAct;

  005ab	a1 ec 50 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+20716
  005b0	8d 0c 76	 lea	 ecx, DWORD PTR [esi+esi*2]
  005b3	c1 e1 04	 shl	 ecx, 4
  005b6	89 81 2c 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[ecx+44], eax

; 2170 : 						setPcParty();

  005bc	e8 00 00 00 00	 call	 ?setPcParty@@YAXXZ	; setPcParty

; 2171 : 						if (j == 0)

  005c1	85 f6		 test	 esi, esi
  005c3	0f 85 89 04 00
	00		 jne	 $LN2@lssproto_C

; 2172 : 							setPcLeader();

  005c9	e8 00 00 00 00	 call	 ?setPcLeader@@YAXXZ	; setPcLeader

; 2173 : 						break;
; 2174 : 					}
; 2175 : 				}
; 2176 : 			}else{

  005ce	e9 7f 04 00 00	 jmp	 $LN2@lssproto_C
$LN19@lssproto_C:

; 2177 : 				setNpcCharObj(id, graNo, x, y, dir, fmname, name, freeName,

  005d3	0f be 85 f7 cf
	ff ff		 movsx	 eax, BYTE PTR _picture$1$[ebp]
  005da	56		 push	 esi
  005db	50		 push	 eax
  005dc	ff b5 d8 cf ff
	ff		 push	 DWORD PTR _profession_class$1$[ebp]
  005e2	8d 85 fc e7 ff
	ff		 lea	 eax, DWORD PTR _petname$[ebp]
  005e8	ff b5 c4 cf ff
	ff		 push	 DWORD PTR _charType$1$[ebp]
  005ee	ff b5 ec cf ff
	ff		 push	 DWORD PTR _height$[ebp]
  005f4	ff b5 d4 cf ff
	ff		 push	 DWORD PTR _walkable$1$[ebp]
  005fa	ff b5 e8 cf ff
	ff		 push	 DWORD PTR _nameColor$[ebp]
  00600	ff b5 e4 cf ff
	ff		 push	 DWORD PTR _petlevel$[ebp]
  00606	50		 push	 eax
  00607	ff b5 e0 cf ff
	ff		 push	 DWORD PTR _level$[ebp]
  0060d	8d 85 fc d7 ff
	ff		 lea	 eax, DWORD PTR _freeName$[ebp]
  00613	50		 push	 eax
  00614	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  0061a	50		 push	 eax
  0061b	8d 85 fc cf ff
	ff		 lea	 eax, DWORD PTR _fmname$[ebp]
  00621	50		 push	 eax
  00622	ff b5 d0 cf ff
	ff		 push	 DWORD PTR _dir$1$[ebp]
  00628	ff b5 cc cf ff
	ff		 push	 DWORD PTR _y$1$[ebp]
  0062e	ff b5 c8 cf ff
	ff		 push	 DWORD PTR _x$1$[ebp]
  00634	53		 push	 ebx
  00635	57		 push	 edi
  00636	e8 00 00 00 00	 call	 ?setNpcCharObj@@YAXHHHHHPAD00H0HHHHHHHH@Z ; setNpcCharObj

; 2178 : 					level, petname, petlevel, nameColor, walkable, height, charType, profession_class
; 2179 : #ifdef _NPC_PICTURE
; 2180 : 					, picture
; 2181 : #endif
; 2182 : #ifdef _NB_æ–‡å­—ç§°å·
; 2183 : 					,nb_name,nb_namecolor
; 2184 : #endif
; 2185 : #ifdef _NB_ä»»åŠ¡æŒ‡å¼•
; 2186 : 					,noticeNo
; 2187 : #endif
; 2188 : 					);
; 2189 : 				ptAct = getCharObjAct(id);

  0063b	57		 push	 edi
  0063c	e8 00 00 00 00	 call	 ?getCharObjAct@@YAPAUaction@@H@Z ; getCharObjAct
  00641	83 c4 4c	 add	 esp, 76			; 0000004cH
  00644	8b d8		 mov	 ebx, eax

; 2190 : #ifdef _NB_ä»»åŠ¡æŒ‡å¼•
; 2191 : 				if(charType==13 && noticeNo>0){

  00646	83 bd c4 cf ff
	ff 0d		 cmp	 DWORD PTR _charType$1$[ebp], 13 ; 0000000dH
  0064d	75 0e		 jne	 SHORT $LN26@lssproto_C
  0064f	85 f6		 test	 esi, esi
  00651	7e 0a		 jle	 SHORT $LN26@lssproto_C

; 2192 : 					setNpcNotice( ptAct, noticeNo);

  00653	56		 push	 esi
  00654	53		 push	 ebx
  00655	e8 00 00 00 00	 call	 ?setNpcNotice@@YAXPAUaction@@H@Z ; setNpcNotice
  0065a	83 c4 08	 add	 esp, 8
$LN26@lssproto_C:

; 2193 : 				}
; 2194 : #endif
; 2195 : 				if (ptAct != NULL)

  0065d	85 db		 test	 ebx, ebx
  0065f	0f 84 ed 03 00
	00		 je	 $LN2@lssproto_C

; 2196 : 				{
; 2197 : 					//JL è®¾ç½®id
; 2198 : 					ptAct->objIndex = id;

  00665	89 bb 38 02 00
	00		 mov	 DWORD PTR [ebx+568], edi

; 2199 : 					for (j = 0; j < MAX_PARTY; j++)

  0066b	33 f6		 xor	 esi, esi
  0066d	b8 04 00 00 00	 mov	 eax, OFFSET ?party@@3PAUPARTY@@A+4
$LL12@lssproto_C:

; 2200 : 					{
; 2201 : 						if (party[j].useFlag != 0 && party[j].id == id)

  00672	66 83 78 fc 00	 cmp	 WORD PTR [eax-4], 0
  00677	74 04		 je	 SHORT $LN10@lssproto_C
  00679	39 38		 cmp	 DWORD PTR [eax], edi
  0067b	74 20		 je	 SHORT $LN45@lssproto_C
$LN10@lssproto_C:

; 2199 : 					for (j = 0; j < MAX_PARTY; j++)

  0067d	83 c0 30	 add	 eax, 48			; 00000030H
  00680	46		 inc	 esi
  00681	3d f4 00 00 00	 cmp	 eax, OFFSET ?party@@3PAUPARTY@@A+244
  00686	7c ea		 jl	 SHORT $LL12@lssproto_C

; 2207 : 							break;
; 2208 : 						}
; 2209 : 					}
; 2210 : 					setCharNameColor(ptAct, charNameColor);

  00688	8b 85 f0 cf ff
	ff		 mov	 eax, DWORD PTR _charNameColor$2$[ebp]
  0068e	50		 push	 eax
  0068f	53		 push	 ebx
  00690	e8 00 00 00 00	 call	 ?setCharNameColor@@YAXPAUaction@@H@Z ; setCharNameColor
  00695	83 c4 08	 add	 esp, 8

; 2211 : 				}
; 2212 : 			}
; 2213 : 			break;

  00698	e9 b5 03 00 00	 jmp	 $LN2@lssproto_C
$LN45@lssproto_C:

; 2202 : 						{
; 2203 : 							party[j].ptAct = ptAct;

  0069d	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  006a0	c1 e0 04	 shl	 eax, 4

; 2204 : 							setCharParty(ptAct);

  006a3	53		 push	 ebx
  006a4	89 98 2c 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[eax+44], ebx
  006aa	e8 00 00 00 00	 call	 ?setCharParty@@YAXPAUaction@@@Z ; setCharParty
  006af	83 c4 04	 add	 esp, 4

; 2205 : 							if (j == 0)

  006b2	85 f6		 test	 esi, esi
  006b4	75 09		 jne	 SHORT $LN60@lssproto_C

; 2206 : 								setCharLeader(ptAct);

  006b6	53		 push	 ebx
  006b7	e8 00 00 00 00	 call	 ?setCharLeader@@YAXPAUaction@@@Z ; setCharLeader
  006bc	83 c4 04	 add	 esp, 4
$LN60@lssproto_C:

; 2207 : 							break;
; 2208 : 						}
; 2209 : 					}
; 2210 : 					setCharNameColor(ptAct, charNameColor);

  006bf	8b 85 f0 cf ff
	ff		 mov	 eax, DWORD PTR _charNameColor$2$[ebp]
  006c5	50		 push	 eax
  006c6	53		 push	 ebx
  006c7	e8 00 00 00 00	 call	 ?setCharNameColor@@YAXPAUaction@@H@Z ; setCharNameColor
  006cc	83 c4 08	 add	 esp, 8

; 2211 : 				}
; 2212 : 			}
; 2213 : 			break;

  006cf	e9 7e 03 00 00	 jmp	 $LN2@lssproto_C
$LN30@lssproto_C:

; 2214 : 		case 2://OBJTYPE_ITEM
; 2215 : 				getStringToken(bigtoken, '|', 2, sizeof(smalltoken) - 1, smalltoken);

  006d4	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  006da	50		 push	 eax
  006db	68 ff 07 00 00	 push	 2047			; 000007ffH
  006e0	6a 02		 push	 2
  006e2	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  006e8	6a 7c		 push	 124			; 0000007cH
  006ea	50		 push	 eax
  006eb	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2216 : 				id = a62toi(smalltoken);

  006f0	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  006f6	50		 push	 eax
  006f7	e8 00 00 00 00	 call	 ?a62toi@@YAHPAD@Z	; a62toi
  006fc	89 85 dc cf ff
	ff		 mov	 DWORD PTR _id$2$[ebp], eax

; 2217 : 				getStringToken(bigtoken, '|', 3, sizeof(smalltoken) - 1, smalltoken);

  00702	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00708	50		 push	 eax
  00709	68 ff 07 00 00	 push	 2047			; 000007ffH
  0070e	6a 03		 push	 3
  00710	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00716	6a 7c		 push	 124			; 0000007cH
  00718	50		 push	 eax
  00719	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2218 : 				x = atoi(smalltoken);

  0071e	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00724	50		 push	 eax
  00725	e8 00 00 00 00	 call	 _atoi
  0072a	89 85 f8 cf ff
	ff		 mov	 DWORD PTR _x$2$[ebp], eax

; 2219 : 				getStringToken(bigtoken, '|', 4, sizeof(smalltoken) - 1, smalltoken);

  00730	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00736	50		 push	 eax
  00737	68 ff 07 00 00	 push	 2047			; 000007ffH
  0073c	6a 04		 push	 4
  0073e	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00744	6a 7c		 push	 124			; 0000007cH
  00746	50		 push	 eax
  00747	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0074c	83 c4 44	 add	 esp, 68			; 00000044H

; 2220 : 				y = atoi(smalltoken);

  0074f	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00755	50		 push	 eax
  00756	e8 00 00 00 00	 call	 _atoi
  0075b	8b d8		 mov	 ebx, eax

; 2221 : 				getStringToken(bigtoken, '|', 5, sizeof(smalltoken) - 1, smalltoken);

  0075d	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00763	50		 push	 eax
  00764	68 ff 07 00 00	 push	 2047			; 000007ffH
  00769	6a 05		 push	 5
  0076b	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00771	6a 7c		 push	 124			; 0000007cH
  00773	50		 push	 eax
  00774	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2222 : 				graNo = atoi(smalltoken);

  00779	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0077f	50		 push	 eax
  00780	e8 00 00 00 00	 call	 _atoi

; 2223 : 				classNo = getIntegerToken(bigtoken, '|', 6);

  00785	6a 06		 push	 6
  00787	8b f8		 mov	 edi, eax
  00789	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  0078f	6a 7c		 push	 124			; 0000007cH
  00791	50		 push	 eax
  00792	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00797	8b f0		 mov	 esi, eax

; 2224 : 				getStringToken(bigtoken, '|', 7, sizeof(info) - 1, info);

  00799	8d 85 fc eb ff
	ff		 lea	 eax, DWORD PTR _info$[ebp]
  0079f	50		 push	 eax
  007a0	68 ff 03 00 00	 push	 1023			; 000003ffH
  007a5	6a 07		 push	 7
  007a7	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  007ad	6a 7c		 push	 124			; 0000007cH
  007af	50		 push	 eax
  007b0	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2225 : 				makeStringFromEscaped(info);

  007b5	8d 85 fc eb ff
	ff		 lea	 eax, DWORD PTR _info$[ebp]
  007bb	50		 push	 eax
  007bc	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  007c1	83 c4 40	 add	 esp, 64			; 00000040H

; 2226 : 				setItemCharObj(id, graNo, x, y, 0, classNo, info);

  007c4	8d 85 fc eb ff
	ff		 lea	 eax, DWORD PTR _info$[ebp]
  007ca	50		 push	 eax
  007cb	56		 push	 esi
  007cc	6a 00		 push	 0
  007ce	53		 push	 ebx
  007cf	ff b5 f8 cf ff
	ff		 push	 DWORD PTR _x$2$[ebp]
  007d5	57		 push	 edi
  007d6	ff b5 dc cf ff
	ff		 push	 DWORD PTR _id$2$[ebp]
  007dc	e8 00 00 00 00	 call	 ?setItemCharObj@@YAXHHHHHHPAD@Z ; setItemCharObj
  007e1	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2227 : 			break;

  007e4	e9 69 02 00 00	 jmp	 $LN2@lssproto_C
$LN31@lssproto_C:

; 2228 : 		case 3://OBJTYPE_GOLD
; 2229 : 				getStringToken(bigtoken, '|', 2, sizeof(smalltoken) - 1, smalltoken);

  007e9	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  007ef	50		 push	 eax
  007f0	68 ff 07 00 00	 push	 2047			; 000007ffH
  007f5	6a 02		 push	 2
  007f7	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  007fd	6a 7c		 push	 124			; 0000007cH
  007ff	50		 push	 eax
  00800	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2230 : 				id = a62toi(smalltoken);

  00805	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0080b	50		 push	 eax
  0080c	e8 00 00 00 00	 call	 ?a62toi@@YAHPAD@Z	; a62toi
  00811	8b f8		 mov	 edi, eax

; 2231 : 				getStringToken(bigtoken, '|', 3, sizeof(smalltoken) - 1, smalltoken);

  00813	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00819	50		 push	 eax
  0081a	68 ff 07 00 00	 push	 2047			; 000007ffH
  0081f	6a 03		 push	 3
  00821	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00827	6a 7c		 push	 124			; 0000007cH
  00829	50		 push	 eax
  0082a	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2232 : 				x = atoi(smalltoken);

  0082f	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00835	50		 push	 eax
  00836	e8 00 00 00 00	 call	 _atoi
  0083b	8b d8		 mov	 ebx, eax

; 2233 : 				getStringToken(bigtoken, '|', 4, sizeof(smalltoken) - 1, smalltoken);

  0083d	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00843	50		 push	 eax
  00844	68 ff 07 00 00	 push	 2047			; 000007ffH
  00849	6a 04		 push	 4
  0084b	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00851	6a 7c		 push	 124			; 0000007cH
  00853	50		 push	 eax
  00854	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00859	83 c4 44	 add	 esp, 68			; 00000044H

; 2234 : 				y = atoi(smalltoken);

  0085c	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00862	50		 push	 eax
  00863	e8 00 00 00 00	 call	 _atoi
  00868	89 85 f8 cf ff
	ff		 mov	 DWORD PTR tv756[ebp], eax

; 2235 : 				getStringToken(bigtoken, '|', 5, sizeof(smalltoken) - 1, smalltoken);

  0086e	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00874	50		 push	 eax
  00875	68 ff 07 00 00	 push	 2047			; 000007ffH
  0087a	6a 05		 push	 5
  0087c	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00882	6a 7c		 push	 124			; 0000007cH
  00884	50		 push	 eax
  00885	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2236 : 				money = atoi(smalltoken);

  0088a	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00890	50		 push	 eax
  00891	e8 00 00 00 00	 call	 _atoi
  00896	8b f0		 mov	 esi, eax

; 2237 : 				sprintf(info, "%d Stone", money);

  00898	8d 85 fc eb ff
	ff		 lea	 eax, DWORD PTR _info$[ebp]
  0089e	56		 push	 esi
  0089f	68 00 00 00 00	 push	 OFFSET ??_C@_08PFECBJKL@?$CFd?5Stone@
  008a4	50		 push	 eax
  008a5	e8 00 00 00 00	 call	 _sprintf
  008aa	83 c4 28	 add	 esp, 40			; 00000028H

; 2238 : 				if (money > 10000)

  008ad	81 fe 10 27 00
	00		 cmp	 esi, 10000		; 00002710H
  008b3	7e 07		 jle	 SHORT $LN32@lssproto_C

; 2239 : 					setMoneyCharObj(id, 24050, x, y, 0, money, info);

  008b5	b8 f2 5d 00 00	 mov	 eax, 24050		; 00005df2H
  008ba	eb 10		 jmp	 SHORT $LN34@lssproto_C
$LN32@lssproto_C:

; 2240 : 				else if (money > 1000)

  008bc	33 c0		 xor	 eax, eax
  008be	81 fe e8 03 00
	00		 cmp	 esi, 1000		; 000003e8H
  008c4	0f 9e c0	 setle	 al
  008c7	05 f3 5d 00 00	 add	 eax, 24051		; 00005df3H
$LN34@lssproto_C:

; 2241 : 					setMoneyCharObj(id, 24051, x, y, 0, money, info);
; 2242 : 				else
; 2243 : 					setMoneyCharObj(id, 24052, x, y, 0, money, info);
; 2244 : 			break;

  008cc	8d 8d fc eb ff
	ff		 lea	 ecx, DWORD PTR _info$[ebp]
  008d2	51		 push	 ecx
  008d3	56		 push	 esi
  008d4	6a 00		 push	 0
  008d6	ff b5 f8 cf ff
	ff		 push	 DWORD PTR tv756[ebp]
  008dc	53		 push	 ebx
  008dd	50		 push	 eax
  008de	57		 push	 edi
  008df	e8 00 00 00 00	 call	 ?setMoneyCharObj@@YAXHHHHHHPAD@Z ; setMoneyCharObj
  008e4	83 c4 1c	 add	 esp, 28			; 0000001cH
  008e7	e9 66 01 00 00	 jmp	 $LN2@lssproto_C
$LN36@lssproto_C:

; 2245 : 		case 4:
; 2246 : 			getStringToken(bigtoken, '|', 2, sizeof(smalltoken) - 1, smalltoken);

  008ec	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  008f2	50		 push	 eax
  008f3	68 ff 07 00 00	 push	 2047			; 000007ffH
  008f8	6a 02		 push	 2
  008fa	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00900	6a 7c		 push	 124			; 0000007cH
  00902	50		 push	 eax
  00903	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2247 : 			id = a62toi(smalltoken);

  00908	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0090e	50		 push	 eax
  0090f	e8 00 00 00 00	 call	 ?a62toi@@YAHPAD@Z	; a62toi
  00914	89 85 f8 cf ff
	ff		 mov	 DWORD PTR _id$3$[ebp], eax

; 2248 : 			getStringToken(bigtoken, '|', 3, sizeof(name) - 1, name);

  0091a	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  00920	50		 push	 eax
  00921	68 ff 07 00 00	 push	 2047			; 000007ffH
  00926	6a 03		 push	 3
  00928	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  0092e	6a 7c		 push	 124			; 0000007cH
  00930	50		 push	 eax
  00931	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2249 : 			makeStringFromEscaped(name);

  00936	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  0093c	50		 push	 eax
  0093d	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 2250 : 			getStringToken(bigtoken, '|', 4, sizeof(smalltoken) - 1, smalltoken);

  00942	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00948	50		 push	 eax
  00949	68 ff 07 00 00	 push	 2047			; 000007ffH
  0094e	6a 04		 push	 4
  00950	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00956	6a 7c		 push	 124			; 0000007cH
  00958	50		 push	 eax
  00959	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0095e	83 c4 44	 add	 esp, 68			; 00000044H

; 2251 : 			dir = (atoi(smalltoken) + 3) % 8;

  00961	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00967	50		 push	 eax
  00968	e8 00 00 00 00	 call	 _atoi
  0096d	8d 58 03	 lea	 ebx, DWORD PTR [eax+3]
  00970	81 e3 07 00 00
	80		 and	 ebx, -2147483641	; 80000007H
  00976	79 05		 jns	 SHORT $LN70@lssproto_C
  00978	4b		 dec	 ebx
  00979	83 cb f8	 or	 ebx, -8			; fffffff8H
  0097c	43		 inc	 ebx
$LN70@lssproto_C:

; 2252 : 			getStringToken(bigtoken, '|', 5, sizeof(smalltoken) - 1, smalltoken);

  0097d	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00983	50		 push	 eax
  00984	68 ff 07 00 00	 push	 2047			; 000007ffH
  00989	6a 05		 push	 5
  0098b	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00991	6a 7c		 push	 124			; 0000007cH
  00993	50		 push	 eax
  00994	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2253 : 			graNo = atoi(smalltoken);

  00999	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0099f	50		 push	 eax
  009a0	e8 00 00 00 00	 call	 _atoi
  009a5	8b f8		 mov	 edi, eax

; 2254 : 			getStringToken(bigtoken, '|', 6, sizeof(smalltoken) - 1, smalltoken);

  009a7	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  009ad	50		 push	 eax
  009ae	68 ff 07 00 00	 push	 2047			; 000007ffH
  009b3	6a 06		 push	 6
  009b5	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  009bb	6a 7c		 push	 124			; 0000007cH
  009bd	50		 push	 eax
  009be	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2255 : 			x = atoi(smalltoken);

  009c3	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  009c9	50		 push	 eax
  009ca	e8 00 00 00 00	 call	 _atoi
  009cf	8b f0		 mov	 esi, eax

; 2256 : 			getStringToken(bigtoken, '|', 7, sizeof(smalltoken) - 1, smalltoken);

  009d1	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  009d7	50		 push	 eax
  009d8	68 ff 07 00 00	 push	 2047			; 000007ffH
  009dd	6a 07		 push	 7
  009df	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  009e5	6a 7c		 push	 124			; 0000007cH
  009e7	50		 push	 eax
  009e8	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  009ed	83 c4 48	 add	 esp, 72			; 00000048H

; 2257 : 			y = atoi(smalltoken);

  009f0	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  009f6	50		 push	 eax
  009f7	e8 00 00 00 00	 call	 _atoi

; 2258 : 			setNpcCharObj( id, graNo, x, y, dir, "", name, "",

  009fc	6a 00		 push	 0
  009fe	6a 00		 push	 0
  00a00	6a 00		 push	 0
  00a02	6a 02		 push	 2
  00a04	ff b5 ec cf ff
	ff		 push	 DWORD PTR _height$[ebp]
  00a0a	8d 8d fc e7 ff
	ff		 lea	 ecx, DWORD PTR _petname$[ebp]
  00a10	6a 00		 push	 0
  00a12	ff b5 e8 cf ff
	ff		 push	 DWORD PTR _nameColor$[ebp]
  00a18	ff b5 e4 cf ff
	ff		 push	 DWORD PTR _petlevel$[ebp]
  00a1e	51		 push	 ecx
  00a1f	ff b5 e0 cf ff
	ff		 push	 DWORD PTR _level$[ebp]
  00a25	8d 8d fc df ff
	ff		 lea	 ecx, DWORD PTR _name$[ebp]
  00a2b	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  00a30	51		 push	 ecx
  00a31	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  00a36	53		 push	 ebx
  00a37	50		 push	 eax
  00a38	56		 push	 esi
  00a39	8b b5 f8 cf ff
	ff		 mov	 esi, DWORD PTR _id$3$[ebp]
  00a3f	57		 push	 edi
  00a40	56		 push	 esi
  00a41	e8 00 00 00 00	 call	 ?setNpcCharObj@@YAXHHHHHPAD00H0HHHHHHHH@Z ; setNpcCharObj
  00a46	83 c4 4c	 add	 esp, 76			; 0000004cH

; 2259 : 				level, petname, petlevel, nameColor, 0, height, 2, 0
; 2260 : #ifdef _NPC_PICTURE
; 2261 : 			,0 
; 2262 : #endif
; 2263 : #ifdef _NB_æ–‡å­—ç§°å·
; 2264 : 			,"",0
; 2265 : #endif
; 2266 : #ifdef _NB_ä»»åŠ¡æŒ‡å¼•
; 2267 : 			,0
; 2268 : #endif
; 2269 : 			);
; 2270 : 			ptAct = getCharObjAct( id );

  00a49	56		 push	 esi
  00a4a	e8 00 00 00 00	 call	 ?getCharObjAct@@YAPAUaction@@H@Z ; getCharObjAct
  00a4f	83 c4 04	 add	 esp, 4
$LN2@lssproto_C:

; 2049 : 	{
; 2050 : 		getStringToken(data, ',', i + 1, sizeof(bigtoken) - 1, bigtoken);

  00a52	8b 85 c0 cf ff
	ff		 mov	 eax, DWORD PTR tv741[ebp]
  00a58	8d 8d fc ef ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00a5e	51		 push	 ecx
  00a5f	40		 inc	 eax
  00a60	68 ff 07 00 00	 push	 2047			; 000007ffH
  00a65	50		 push	 eax
  00a66	6a 2c		 push	 44			; 0000002cH
  00a68	ff b5 b8 cf ff
	ff		 push	 DWORD PTR _data$GSCopy$1$[ebp]
  00a6e	89 85 c0 cf ff
	ff		 mov	 DWORD PTR tv741[ebp], eax
  00a74	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2051 : 		if (strlen(bigtoken) == 0)

  00a79	8d 8d fc ef ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00a7f	83 c4 14	 add	 esp, 20			; 00000014H
  00a82	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL64@lssproto_C:
  00a85	8a 01		 mov	 al, BYTE PTR [ecx]
  00a87	41		 inc	 ecx
  00a88	84 c0		 test	 al, al
  00a8a	75 f9		 jne	 SHORT $LL64@lssproto_C
  00a8c	2b ca		 sub	 ecx, edx
  00a8e	0f 85 ec f5 ff
	ff		 jne	 $LL4@lssproto_C
$LN66@lssproto_C:
  00a94	5f		 pop	 edi
  00a95	5e		 pop	 esi
  00a96	5b		 pop	 ebx
$LN65@lssproto_C:

; 2271 : 			break;
; 2272 : 		}
; 2273 : #else
; 2274 : 		getStringToken(bigtoken , '|' , 11 , sizeof(smalltoken) - 1, smalltoken);
; 2275 : 		if ( strlen(smalltoken) > 0 ){
; 2276 : 			// NPC?îºîŸ«
; 2277 : 			charType = getIntegerToken(bigtoken, '|', 1 );
; 2278 : 			getStringToken(bigtoken, '|', 2, sizeof(smalltoken) - 1, smalltoken);
; 2279 : 			id = a62toi(smalltoken);
; 2280 : 			getStringToken(bigtoken, '|', 3, sizeof(smalltoken) - 1, smalltoken);
; 2281 : 			x = atoi(smalltoken);
; 2282 : 			getStringToken(bigtoken, '|', 4, sizeof(smalltoken) - 1, smalltoken);
; 2283 : 			y = atoi(smalltoken);
; 2284 : 			getStringToken(bigtoken, '|', 5, sizeof(smalltoken) - 1, smalltoken);
; 2285 : 			dir = (atoi(smalltoken) + 3) % 8;
; 2286 : 			getStringToken(bigtoken, '|', 6, sizeof(smalltoken) - 1, smalltoken);
; 2287 : 			graNo = atoi(smalltoken);
; 2288 : 			getStringToken(bigtoken, '|', 7, sizeof(smalltoken) - 1,smalltoken);
; 2289 : 			level = atoi(smalltoken);
; 2290 : 			nameColor = getIntegerToken(bigtoken, '|', 8 );
; 2291 : 			getStringToken(bigtoken , '|' , 9 , sizeof(name) - 1, name );
; 2292 : 			makeStringFromEscaped(name);
; 2293 : 			getStringToken(bigtoken , '|' , 10 , sizeof( freeName ) - 1, freeName );
; 2294 : 			makeStringFromEscaped( freeName );
; 2295 : 			getStringToken(bigtoken, '|', 11, sizeof(smalltoken) - 1, smalltoken);
; 2296 : 			walkable = atoi(smalltoken);
; 2297 : 			getStringToken(bigtoken, '|', 12, sizeof(smalltoken) - 1, smalltoken);
; 2298 : 			height = atoi(smalltoken);
; 2299 : 			charNameColor = getIntegerToken(bigtoken, '|', 13 );
; 2300 : 			getStringToken(bigtoken , '|' , 14, sizeof( fmname ) - 1, fmname );
; 2301 : 			makeStringFromEscaped( fmname );
; 2302 : 			getStringToken(bigtoken , '|' , 15 , sizeof( petname ) - 1, petname );
; 2303 : 			makeStringFromEscaped( petname );
; 2304 : 			getStringToken(bigtoken, '|', 16, sizeof(smalltoken) - 1, smalltoken);
; 2305 : 			petlevel = atoi(smalltoken);
; 2306 : 			if ( charNameColor < 0 )
; 2307 : 				charNameColor = 0;
; 2308 : 
; 2309 : 			if ( pc.id == id ){
; 2310 : 				if ( pc.ptAct == NULL ){
; 2311 : 					createPc( graNo, x, y, dir );
; 2312 : 					updataPcAct();
; 2313 : 				}else{
; 2314 : 					setPcGraNo( graNo, pc.dir );
; 2315 : 				}
; 2316 : 				updateMapArea();
; 2317 : 				setPcParam( name, freeName, level, petname, petlevel, nameColor, walkable, height );			
; 2318 : 				setPcNameColor( charNameColor );
; 2319 : 				if ( (pc.status & CHR_STATUS_LEADER) != 0
; 2320 : 				 && party[0].useFlag != 0 ){
; 2321 : 					party[0].level = pc.level;
; 2322 : 					strcpy( party[0].name, pc.name );
; 2323 : 				}
; 2324 : 				for ( j = 0; j < MAX_PARTY; j++ ){
; 2325 : 					if ( party[j].useFlag != 0 && party[j].id == id ){
; 2326 : 						party[j].ptAct = pc.ptAct;
; 2327 : 						setPcParty();
; 2328 : 						if ( j == 0 ){
; 2329 : 							setPcLeader();
; 2330 : 						}
; 2331 : 						break;
; 2332 : 					}
; 2333 : 				}
; 2334 : 			}else{
; 2335 : 				setNpcCharObj( id, graNo, x, y, dir, fmname, name, freeName,
; 2336 : 					level, petname, petlevel, nameColor, walkable, height, charType
; 2337 : #ifdef _NPC_PICTURE
; 2338 : 					, 0 
; 2339 : #endif
; 2340 : #ifdef _NB_æ–‡å­—ç§°å·
; 2341 : 					,"",0
; 2342 : #endif
; 2343 : #ifdef _NB_ä»»åŠ¡æŒ‡å¼•	
; 2344 : 					,0
; 2345 : #endif
; 2346 : 					);
; 2347 : 				ptAct = getCharObjAct( id );
; 2348 : 				if ( ptAct != NULL ){
; 2349 : 					for ( j = 0; j < MAX_PARTY; j++ ){
; 2350 : 						if ( party[j].useFlag != 0 && party[j].id == id ){
; 2351 : 							party[j].ptAct = ptAct;
; 2352 : 							setCharParty( ptAct );
; 2353 : 							if ( j == 0 ){
; 2354 : 								setCharLeader( ptAct );
; 2355 : 							}
; 2356 : 							break;
; 2357 : 						}
; 2358 : 					}
; 2359 : 					setCharNameColor( ptAct, charNameColor );
; 2360 : 				}
; 2361 : 			}
; 2362 : 		}else{
; 2363 : 			getStringToken(bigtoken, '|', 6, sizeof(smalltoken) - 1, smalltoken);
; 2364 : 			if ( strlen(smalltoken) > 0 ){
; 2365 : 				getStringToken(bigtoken, '|', 1, sizeof(smalltoken) - 1, smalltoken);
; 2366 : 				id = a62toi(smalltoken);
; 2367 : 				getStringToken(bigtoken, '|', 2, sizeof(smalltoken) - 1, smalltoken);
; 2368 : 				x = atoi(smalltoken);
; 2369 : 				getStringToken(bigtoken, '|', 3, sizeof(smalltoken) - 1, smalltoken);
; 2370 : 				y = atoi(smalltoken);
; 2371 : 				getStringToken(bigtoken, '|', 4, sizeof(smalltoken) - 1, smalltoken);
; 2372 : 				graNo = atoi(smalltoken);
; 2373 : 				classNo = getIntegerToken(bigtoken, '|', 5 );
; 2374 : 				getStringToken(bigtoken, '|', 6, sizeof( info ) - 1, info );
; 2375 : 				makeStringFromEscaped( info );
; 2376 : 				setItemCharObj( id, graNo, x, y, 0, classNo, info );
; 2377 : 			}else{
; 2378 : 				getStringToken(bigtoken, '|', 4, sizeof(smalltoken) - 1, smalltoken);
; 2379 : 				if ( strlen(smalltoken) > 0 ){
; 2380 : 					getStringToken(bigtoken, '|', 1, sizeof(smalltoken) - 1, smalltoken);
; 2381 : 					id = a62toi(smalltoken);
; 2382 : 					getStringToken(bigtoken, '|', 2, sizeof(smalltoken) - 1, smalltoken);
; 2383 : 					x = atoi(smalltoken);
; 2384 : 					getStringToken(bigtoken, '|', 3, sizeof(smalltoken) - 1, smalltoken);
; 2385 : 					y = atoi(smalltoken);
; 2386 : 					getStringToken(bigtoken, '|', 4, sizeof(smalltoken) - 1, smalltoken);
; 2387 : 					money = atoi(smalltoken);
; 2388 : 					sprintf( info, "%d Stone", money );
; 2389 : 					if ( money > 10000 ){
; 2390 : 						setMoneyCharObj( id, 24050, x, y, 0, money, info );
; 2391 : 					}else
; 2392 : 					if ( money > 1000 ){
; 2393 : 						setMoneyCharObj( id, 24051, x, y, 0, money, info );
; 2394 : 					}else{
; 2395 : 						setMoneyCharObj( id, 24052, x, y, 0, money, info );
; 2396 : 					}
; 2397 : 				}
; 2398 : 			}
; 2399 : 		}
; 2400 : #endif
; 2401 : 	}
; 2402 : 
; 2403 : }

  00a97	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a9a	33 cd		 xor	 ecx, ebp
  00a9c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00aa1	8b e5		 mov	 esp, ebp
  00aa3	5d		 pop	 ebp
  00aa4	c3		 ret	 0
  00aa5	0f 1f 00	 npad	 3
$LN63@lssproto_C:
  00aa8	00 00 00 00	 DD	 $LN17@lssproto_C
  00aac	00 00 00 00	 DD	 $LN30@lssproto_C
  00ab0	00 00 00 00	 DD	 $LN31@lssproto_C
  00ab4	00 00 00 00	 DD	 $LN36@lssproto_C
?lssproto_C_recv@@YAXHPAD@Z ENDP			; lssproto_C_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_M_recv@@YAXHHHHHHPAD@Z
_TEXT	SEGMENT
tv330 = -67548						; size = 4
_eventstring$ = -67544					; size = 18192
_partsstring$ = -49352					; size = 18192
_tilestring$ = -31160					; size = 18192
_tile$ = -12968						; size = 4096
_parts$ = -8872						; size = 4096
_event$ = -4776						; size = 4096
_showString$ = -680					; size = 512
_strPal$1 = -168					; size = 32
_floorName$ = -136					; size = 32
_tmp$ = -104						; size = 100
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_fl$ = 12						; size = 4
_x1$ = 16						; size = 4
_y1$ = 20						; size = 4
_x2$ = 24						; size = 4
_y2$ = 28						; size = 4
_data$ = 32						; size = 4
?lssproto_M_recv@@YAXHHHHHHPAD@Z PROC			; lssproto_M_recv, COMDAT

; 1902 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 dc 07 01 00	 mov	 eax, 67548		; 000107dcH
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1903 : 	char showString[512], floorName[32], tilestring[18192], partsstring[18192], eventstring[18192], tmp[100];
; 1904 : 	unsigned short tile[2048] , parts[2048], event[2048];
; 1905 : 	int i, flag;
; 1906 : 
; 1907 : 	if (logOutFlag)

  00017	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  0001e	56		 push	 esi
  0001f	8b 75 20	 mov	 esi, DWORD PTR _data$[ebp]
  00022	0f 85 1d 03 00
	00		 jne	 $LN1@lssproto_M

; 1908 : 		return;
; 1909 : 
; 1910 : #ifdef DEBUGPUSH
; 1911 :     char msg[800];
; 1912 :     sprintf(msg , "??????ä½‹????????FL%d %d,%d-%d,%d", fl, x1, y1, x2, y2);
; 1913 :     PUSH(msg);
; 1914 : #endif
; 1915 : 	getStringToken(data, '|', 1, sizeof(showString) - 1, showString);

  00028	53		 push	 ebx
  00029	57		 push	 edi
  0002a	8d 85 58 fd ff
	ff		 lea	 eax, DWORD PTR _showString$[ebp]
  00030	50		 push	 eax
  00031	68 ff 01 00 00	 push	 511			; 000001ffH
  00036	6a 01		 push	 1
  00038	6a 7c		 push	 124			; 0000007cH
  0003a	56		 push	 esi
  0003b	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1916 : 	makeStringFromEscaped(showString);

  00040	8d 85 58 fd ff
	ff		 lea	 eax, DWORD PTR _showString$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1917 : 	if (nowFloor == fl)

  0004c	8b 5d 0c	 mov	 ebx, DWORD PTR _fl$[ebp]
  0004f	83 c4 18	 add	 esp, 24			; 00000018H
  00052	bf 01 00 00 00	 mov	 edi, 1
  00057	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?nowFloor@@3HA, ebx ; nowFloor
  0005d	0f 85 f8 00 00
	00		 jne	 $LN20@lssproto_M

; 1918 : 	{
; 1919 : 		char strPal[32];
; 1920 : 
; 1921 : 		getStringToken(showString, '|', 1, sizeof(floorName) - 1, floorName);

  00063	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _floorName$[ebp]
  00069	50		 push	 eax
  0006a	6a 1f		 push	 31			; 0000001fH
  0006c	57		 push	 edi
  0006d	8d 85 58 fd ff
	ff		 lea	 eax, DWORD PTR _showString$[ebp]
  00073	6a 7c		 push	 124			; 0000007cH
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1922 : 		if (strlen(floorName) <= FLOOR_NAME_LEN)

  0007b	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _floorName$[ebp]
  00081	83 c4 14	 add	 esp, 20			; 00000014H
  00084	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL50@lssproto_M:
  00087	8a 01		 mov	 al, BYTE PTR [ecx]
  00089	41		 inc	 ecx
  0008a	84 c0		 test	 al, al
  0008c	75 f9		 jne	 SHORT $LL50@lssproto_M
  0008e	2b ca		 sub	 ecx, edx
  00090	83 f9 18	 cmp	 ecx, 24			; 00000018H
  00093	77 21		 ja	 SHORT $LN10@lssproto_M

; 1923 : 			strcpy(nowFloorName, floorName);

  00095	33 c9		 xor	 ecx, ecx
  00097	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL34@lssproto_M:
  000a0	8a 84 0d 78 ff
	ff ff		 mov	 al, BYTE PTR _floorName$[ebp+ecx]
  000a7	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  000aa	88 81 ff ff ff
	ff		 mov	 BYTE PTR ?nowFloorName@@3PADA[ecx-1], al
  000b0	84 c0		 test	 al, al
  000b2	75 ec		 jne	 SHORT $LL34@lssproto_M
  000b4	eb 0a		 jmp	 SHORT $LN11@lssproto_M
$LN10@lssproto_M:

; 1924 : 		else
; 1925 : 			strcpy(nowFloorName, "???");

  000b6	c7 05 00 00 00
	00 3f 3f 3f 00	 mov	 DWORD PTR ?nowFloorName@@3PADA, 4144959 ; 003f3f3fH
$LN11@lssproto_M:

; 1926 : 		palNo = -2;
; 1927 : 		getStringToken(showString, '|', 2, sizeof(strPal) - 1, strPal);

  000c0	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _strPal$1[ebp]
  000c6	c7 05 00 00 00
	00 fe ff ff ff	 mov	 DWORD PTR ?palNo@@3HA, -2 ; palNo, fffffffeH
  000d0	50		 push	 eax
  000d1	6a 1f		 push	 31			; 0000001fH
  000d3	6a 02		 push	 2
  000d5	8d 85 58 fd ff
	ff		 lea	 eax, DWORD PTR _showString$[ebp]
  000db	6a 7c		 push	 124			; 0000007cH
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1928 : 		if (strlen(strPal) == 0)

  000e3	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _strPal$1[ebp]
  000e9	83 c4 14	 add	 esp, 20			; 00000014H
  000ec	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  000ef	90		 npad	 1
$LL51@lssproto_M:
  000f0	8a 01		 mov	 al, BYTE PTR [ecx]
  000f2	41		 inc	 ecx
  000f3	84 c0		 test	 al, al
  000f5	75 f9		 jne	 SHORT $LL51@lssproto_M
  000f7	2b ca		 sub	 ecx, edx
  000f9	74 33		 je	 SHORT $LN16@lssproto_M

; 1929 : 		{
; 1930 : 			if (TimeZonePalChangeFlag == FALSE || loginFlag)
; 1931 : 			{
; 1932 : 				palNo = -1;
; 1933 : 				palTime = 0;
; 1934 : 				drawTimeAnimeFlag = 1;
; 1935 : 			}
; 1936 : 		}
; 1937 : 		else
; 1938 : 		{
; 1939 : 			int pal;
; 1940 : 
; 1941 : 			pal = atoi(strPal);

  000fb	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _strPal$1[ebp]
  00101	50		 push	 eax
  00102	e8 00 00 00 00	 call	 _atoi
  00107	83 c4 04	 add	 esp, 4

; 1942 : 			if (pal >= 0)

  0010a	85 c0		 test	 eax, eax
  0010c	78 20		 js	 SHORT $LN16@lssproto_M

; 1943 : 			{
; 1944 : 				if (TimeZonePalChangeFlag == TRUE || loginFlag)

  0010e	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?TimeZonePalChangeFlag@@3HA, edi ; TimeZonePalChangeFlag
  00114	74 09		 je	 SHORT $LN19@lssproto_M
  00116	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?loginFlag@@3HA, 0 ; loginFlag
  0011d	74 3c		 je	 SHORT $LN20@lssproto_M
$LN19@lssproto_M:

; 1945 : 				{
; 1946 : 					palNo = pal;

  0011f	a3 00 00 00 00	 mov	 DWORD PTR ?palNo@@3HA, eax ; palNo

; 1947 : 					palTime = 0;
; 1948 : 					drawTimeAnimeFlag = 0;

  00124	33 c0		 xor	 eax, eax
  00126	66 a3 00 00 00
	00		 mov	 WORD PTR ?drawTimeAnimeFlag@@3FA, ax ; drawTimeAnimeFlag

; 1949 : 				}
; 1950 : 			}

  0012c	eb 23		 jmp	 SHORT $LN55@lssproto_M
$LN16@lssproto_M:

; 1951 : 			else
; 1952 : 			{
; 1953 : 				if (TimeZonePalChangeFlag == FALSE || loginFlag)
; 1954 : 				{
; 1955 : 					palNo = -1;
; 1956 : 					palTime = 0;
; 1957 : 					drawTimeAnimeFlag = 1;
; 1958 : 				}
; 1959 : 			}
; 1960 : 		}
; 1961 : 	}
; 1962 : 
; 1963 : 
; 1964 : 	//JL fix 2017.9.25  ä¿®å¤ç»„é˜Ÿè·‘çš„æ—¶å€™å®¢æˆ·ç«¯å¡çš„é—®é¢˜ï¼Œå› ä¸ºä¼šé¢‘ç¹æ”¶åˆ°æ­¤åŒ…ï¼Œå¦‚æžœæ˜¯é˜Ÿå‘˜åˆ™æŠŠåŽé¢çš„åœ°å›¾æ“ä½œ??æŽ‰
; 1965 : 	for (int i = 1; i < MAX_PARTY; i++)  //æ£€æµ‹æ˜¯å¦ä¸ºé˜Ÿå‘˜

  0012e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?TimeZonePalChangeFlag@@3HA, 0 ; TimeZonePalChangeFlag
  00135	74 09		 je	 SHORT $LN21@lssproto_M
  00137	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?loginFlag@@3HA, 0 ; loginFlag
  0013e	74 1b		 je	 SHORT $LN20@lssproto_M
$LN21@lssproto_M:
  00140	66 89 3d 00 00
	00 00		 mov	 WORD PTR ?drawTimeAnimeFlag@@3FA, di ; drawTimeAnimeFlag
  00147	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?palNo@@3HA, -1 ; palNo
$LN55@lssproto_M:
  00151	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?palTime@@3HA, 0 ; palTime
$LN20@lssproto_M:
  0015b	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?pc@@3UPC@@A+8
  00161	b8 34 00 00 00	 mov	 eax, OFFSET ?party@@3PAUPARTY@@A+52
$LL4@lssproto_M:

; 1966 : 	{
; 1967 : 		if (party[i].useFlag != 0)

  00166	66 83 78 fc 00	 cmp	 WORD PTR [eax-4], 0
  0016b	74 08		 je	 SHORT $LN2@lssproto_M

; 1968 : 		{
; 1969 : 			if (party[i].id == pc.id)

  0016d	39 08		 cmp	 DWORD PTR [eax], ecx
  0016f	0f 84 df 01 00
	00		 je	 $LN39@lssproto_M
$LN2@lssproto_M:

; 1951 : 			else
; 1952 : 			{
; 1953 : 				if (TimeZonePalChangeFlag == FALSE || loginFlag)
; 1954 : 				{
; 1955 : 					palNo = -1;
; 1956 : 					palTime = 0;
; 1957 : 					drawTimeAnimeFlag = 1;
; 1958 : 				}
; 1959 : 			}
; 1960 : 		}
; 1961 : 	}
; 1962 : 
; 1963 : 
; 1964 : 	//JL fix 2017.9.25  ä¿®å¤ç»„é˜Ÿè·‘çš„æ—¶å€™å®¢æˆ·ç«¯å¡çš„é—®é¢˜ï¼Œå› ä¸ºä¼šé¢‘ç¹æ”¶åˆ°æ­¤åŒ…ï¼Œå¦‚æžœæ˜¯é˜Ÿå‘˜åˆ™æŠŠåŽé¢çš„åœ°å›¾æ“ä½œ??æŽ‰
; 1965 : 	for (int i = 1; i < MAX_PARTY; i++)  //æ£€æµ‹æ˜¯å¦ä¸ºé˜Ÿå‘˜

  00175	83 c0 30	 add	 eax, 48			; 00000030H
  00178	3d f4 00 00 00	 cmp	 eax, OFFSET ?party@@3PAUPARTY@@A+244
  0017d	7c e7		 jl	 SHORT $LL4@lssproto_M

; 1979 : 					}
; 1980 : 				}
; 1981 : 				loginFlag = FALSE;
; 1982 : 				return;
; 1983 : 			}
; 1984 : 		}
; 1985 : 	}
; 1986 : 
; 1987 : 	getStringToken(data, '|', 2, sizeof(tilestring) - 1, tilestring);	

  0017f	8d 85 48 86 ff
	ff		 lea	 eax, DWORD PTR _tilestring$[ebp]
  00185	50		 push	 eax
  00186	68 0f 47 00 00	 push	 18191			; 0000470fH
  0018b	6a 02		 push	 2
  0018d	6a 7c		 push	 124			; 0000007cH
  0018f	56		 push	 esi
  00190	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1988 : 	getStringToken(data, '|', 3, sizeof(partsstring) - 1, partsstring);

  00195	8d 85 38 3f ff
	ff		 lea	 eax, DWORD PTR _partsstring$[ebp]
  0019b	50		 push	 eax
  0019c	68 0f 47 00 00	 push	 18191			; 0000470fH
  001a1	6a 03		 push	 3
  001a3	6a 7c		 push	 124			; 0000007cH
  001a5	56		 push	 esi
  001a6	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1989 : 	getStringToken(data, '|', 4, sizeof(eventstring) - 1, eventstring);

  001ab	8d 85 28 f8 fe
	ff		 lea	 eax, DWORD PTR _eventstring$[ebp]
  001b1	50		 push	 eax
  001b2	68 0f 47 00 00	 push	 18191			; 0000470fH
  001b7	6a 04		 push	 4
  001b9	6a 7c		 push	 124			; 0000007cH
  001bb	56		 push	 esi
  001bc	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1990 : 	for (i = 0; ; i++)
; 1991 : 	{
; 1992 : 		flag = getStringToken(tilestring, ',', i + 1, sizeof(tmp) - 1, tmp);

  001c1	8d 45 98	 lea	 eax, DWORD PTR _tmp$[ebp]
  001c4	50		 push	 eax
  001c5	6a 63		 push	 99			; 00000063H
  001c7	6a 01		 push	 1
  001c9	8d 85 48 86 ff
	ff		 lea	 eax, DWORD PTR _tilestring$[ebp]
  001cf	6a 2c		 push	 44			; 0000002cH
  001d1	50		 push	 eax
  001d2	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  001d7	83 c4 50	 add	 esp, 80			; 00000050H
  001da	8b f0		 mov	 esi, eax

; 1993 : 		tile[i] = a62toi(tmp);

  001dc	8d 45 98	 lea	 eax, DWORD PTR _tmp$[ebp]
  001df	50		 push	 eax
  001e0	e8 00 00 00 00	 call	 ?a62toi@@YAHPAD@Z	; a62toi
  001e5	66 89 85 58 cd
	ff ff		 mov	 WORD PTR _tile$[ebp], ax

; 1994 : 		getStringToken(partsstring, ',', i + 1, sizeof(tmp) - 1, tmp);

  001ec	8d 45 98	 lea	 eax, DWORD PTR _tmp$[ebp]
  001ef	50		 push	 eax
  001f0	6a 63		 push	 99			; 00000063H
  001f2	6a 01		 push	 1
  001f4	8d 85 38 3f ff
	ff		 lea	 eax, DWORD PTR _partsstring$[ebp]
  001fa	6a 2c		 push	 44			; 0000002cH
  001fc	50		 push	 eax
  001fd	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1995 : 		parts[i] = a62toi(tmp);

  00202	8d 45 98	 lea	 eax, DWORD PTR _tmp$[ebp]
  00205	50		 push	 eax
  00206	e8 00 00 00 00	 call	 ?a62toi@@YAHPAD@Z	; a62toi
  0020b	66 89 85 58 dd
	ff ff		 mov	 WORD PTR _parts$[ebp], ax

; 1996 : 		getStringToken(eventstring, ',', i + 1, sizeof(tmp) - 1, tmp);

  00212	8d 45 98	 lea	 eax, DWORD PTR _tmp$[ebp]
  00215	50		 push	 eax
  00216	6a 63		 push	 99			; 00000063H
  00218	6a 01		 push	 1
  0021a	8d 85 28 f8 fe
	ff		 lea	 eax, DWORD PTR _eventstring$[ebp]
  00220	6a 2c		 push	 44			; 0000002cH
  00222	50		 push	 eax
  00223	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1997 : 		event[i] = a62toi(tmp);

  00228	8d 45 98	 lea	 eax, DWORD PTR _tmp$[ebp]
  0022b	50		 push	 eax
  0022c	e8 00 00 00 00	 call	 ?a62toi@@YAHPAD@Z	; a62toi
  00231	83 c4 34	 add	 esp, 52			; 00000034H
  00234	66 89 85 58 ed
	ff ff		 mov	 WORD PTR _event$[ebp], ax

; 1998 : 		if (flag == 1)

  0023b	83 fe 01	 cmp	 esi, 1
  0023e	0f 84 8e 00 00
	00		 je	 $LN40@lssproto_M

; 1979 : 					}
; 1980 : 				}
; 1981 : 				loginFlag = FALSE;
; 1982 : 				return;
; 1983 : 			}
; 1984 : 		}
; 1985 : 	}
; 1986 : 
; 1987 : 	getStringToken(data, '|', 2, sizeof(tilestring) - 1, tilestring);	

  00244	33 db		 xor	 ebx, ebx
$LL7@lssproto_M:

; 1990 : 	for (i = 0; ; i++)
; 1991 : 	{
; 1992 : 		flag = getStringToken(tilestring, ',', i + 1, sizeof(tmp) - 1, tmp);

  00246	8d 45 98	 lea	 eax, DWORD PTR _tmp$[ebp]
  00249	47		 inc	 edi
  0024a	50		 push	 eax
  0024b	6a 63		 push	 99			; 00000063H
  0024d	57		 push	 edi
  0024e	8d 85 48 86 ff
	ff		 lea	 eax, DWORD PTR _tilestring$[ebp]
  00254	6a 2c		 push	 44			; 0000002cH
  00256	50		 push	 eax
  00257	8d 5b 02	 lea	 ebx, DWORD PTR [ebx+2]
  0025a	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0025f	8b f0		 mov	 esi, eax

; 1993 : 		tile[i] = a62toi(tmp);

  00261	8d 45 98	 lea	 eax, DWORD PTR _tmp$[ebp]
  00264	50		 push	 eax
  00265	e8 00 00 00 00	 call	 ?a62toi@@YAHPAD@Z	; a62toi
  0026a	66 89 84 1d 58
	cd ff ff	 mov	 WORD PTR _tile$[ebp+ebx], ax

; 1994 : 		getStringToken(partsstring, ',', i + 1, sizeof(tmp) - 1, tmp);

  00272	8d 45 98	 lea	 eax, DWORD PTR _tmp$[ebp]
  00275	50		 push	 eax
  00276	6a 63		 push	 99			; 00000063H
  00278	57		 push	 edi
  00279	8d 85 38 3f ff
	ff		 lea	 eax, DWORD PTR _partsstring$[ebp]
  0027f	6a 2c		 push	 44			; 0000002cH
  00281	50		 push	 eax
  00282	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1995 : 		parts[i] = a62toi(tmp);

  00287	8d 45 98	 lea	 eax, DWORD PTR _tmp$[ebp]
  0028a	50		 push	 eax
  0028b	e8 00 00 00 00	 call	 ?a62toi@@YAHPAD@Z	; a62toi
  00290	66 89 84 1d 58
	dd ff ff	 mov	 WORD PTR _parts$[ebp+ebx], ax

; 1996 : 		getStringToken(eventstring, ',', i + 1, sizeof(tmp) - 1, tmp);

  00298	8d 45 98	 lea	 eax, DWORD PTR _tmp$[ebp]
  0029b	50		 push	 eax
  0029c	6a 63		 push	 99			; 00000063H
  0029e	57		 push	 edi
  0029f	8d 85 28 f8 fe
	ff		 lea	 eax, DWORD PTR _eventstring$[ebp]
  002a5	6a 2c		 push	 44			; 0000002cH
  002a7	50		 push	 eax
  002a8	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  002ad	83 c4 44	 add	 esp, 68			; 00000044H

; 1997 : 		event[i] = a62toi(tmp);

  002b0	8d 45 98	 lea	 eax, DWORD PTR _tmp$[ebp]
  002b3	50		 push	 eax
  002b4	e8 00 00 00 00	 call	 ?a62toi@@YAHPAD@Z	; a62toi
  002b9	83 c4 04	 add	 esp, 4
  002bc	66 89 84 1d 58
	ed ff ff	 mov	 WORD PTR _event$[ebp+ebx], ax

; 1998 : 		if (flag == 1)

  002c4	83 fe 01	 cmp	 esi, 1
  002c7	0f 85 79 ff ff
	ff		 jne	 $LL7@lssproto_M
  002cd	8b 5d 0c	 mov	 ebx, DWORD PTR _fl$[ebp]
  002d0	8b fe		 mov	 edi, esi
$LN40@lssproto_M:

; 1999 : 			break;
; 2000 : 	}
; 2001 : 	writeMap(fl, x1, y1, x2, y2, tile, parts, event);

  002d2	8d 85 58 ed ff
	ff		 lea	 eax, DWORD PTR _event$[ebp]
  002d8	50		 push	 eax
  002d9	8d 85 58 dd ff
	ff		 lea	 eax, DWORD PTR _parts$[ebp]
  002df	50		 push	 eax
  002e0	8d 85 58 cd ff
	ff		 lea	 eax, DWORD PTR _tile$[ebp]
  002e6	50		 push	 eax
  002e7	ff 75 1c	 push	 DWORD PTR _y2$[ebp]
  002ea	ff 75 18	 push	 DWORD PTR _x2$[ebp]
  002ed	ff 75 14	 push	 DWORD PTR _y1$[ebp]
  002f0	ff 75 10	 push	 DWORD PTR _x1$[ebp]
  002f3	53		 push	 ebx
  002f4	e8 00 00 00 00	 call	 ?writeMap@@YAHHHHHHPAG00@Z ; writeMap
  002f9	83 c4 20	 add	 esp, 32			; 00000020H

; 2002 : 	if (mapEmptyFlag || floorChangeFlag)

  002fc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?mapEmptyFlag@@3HA, 0 ; mapEmptyFlag
  00303	75 09		 jne	 SHORT $LN30@lssproto_M
  00305	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?floorChangeFlag@@3HA, 0 ; floorChangeFlag
  0030c	74 2b		 je	 SHORT $LN32@lssproto_M
$LN30@lssproto_M:

; 2003 : 	{
; 2004 : 		if (nowFloor == fl)

  0030e	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?nowFloor@@3HA, ebx ; nowFloor
  00314	75 23		 jne	 SHORT $LN32@lssproto_M

; 2005 : 		{
; 2006 : 			redrawMap();

  00316	e8 00 00 00 00	 call	 ?redrawMap@@YAXXZ	; redrawMap

; 2007 : 			floorChangeFlag = FALSE;
; 2008 : 			if (warpEffectStart)

  0031b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?warpEffectOk@@3HA ; warpEffectOk
  00320	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?warpEffectStart@@3HA, 0 ; warpEffectStart
  00327	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?floorChangeFlag@@3HA, 0 ; floorChangeFlag
  00331	0f 45 c7	 cmovne	 eax, edi
  00334	a3 00 00 00 00	 mov	 DWORD PTR ?warpEffectOk@@3HA, eax ; warpEffectOk
$LN32@lssproto_M:

; 2009 : 				warpEffectOk = TRUE;
; 2010 : 		}
; 2011 : 	}
; 2012 : 	loginFlag = FALSE;

  00339	5f		 pop	 edi
  0033a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?loginFlag@@3HA, 0 ; loginFlag
  00344	5b		 pop	 ebx
$LN1@lssproto_M:

; 2013 : }

  00345	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00348	33 cd		 xor	 ecx, ebp
  0034a	5e		 pop	 esi
  0034b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00350	8b e5		 mov	 esp, ebp
  00352	5d		 pop	 ebp
  00353	c3		 ret	 0
$LN39@lssproto_M:

; 1970 : 			{
; 1971 : 				if (mapEmptyFlag || floorChangeFlag)

  00354	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?mapEmptyFlag@@3HA, 0 ; mapEmptyFlag
  0035b	75 09		 jne	 SHORT $LN25@lssproto_M
  0035d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?floorChangeFlag@@3HA, 0 ; floorChangeFlag
  00364	74 d3		 je	 SHORT $LN32@lssproto_M
$LN25@lssproto_M:

; 1972 : 				{
; 1973 : 					if (nowFloor == fl)

  00366	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?nowFloor@@3HA, ebx ; nowFloor
  0036c	75 cb		 jne	 SHORT $LN32@lssproto_M

; 1974 : 					{
; 1975 : 						redrawMap();

  0036e	e8 00 00 00 00	 call	 ?redrawMap@@YAXXZ	; redrawMap

; 1976 : 						floorChangeFlag = FALSE;
; 1977 : 						if (warpEffectStart)

  00373	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?warpEffectStart@@3HA, 0 ; warpEffectStart
  0037a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?floorChangeFlag@@3HA, 0 ; floorChangeFlag
  00384	74 b3		 je	 SHORT $LN32@lssproto_M

; 1978 : 							warpEffectOk = TRUE;

  00386	89 3d 00 00 00
	00		 mov	 DWORD PTR ?warpEffectOk@@3HA, edi ; warpEffectOk
  0038c	eb ab		 jmp	 SHORT $LN32@lssproto_M
?lssproto_M_recv@@YAXHHHHHHPAD@Z ENDP			; lssproto_M_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_MC_recv@@YAXHHHHHHHHHPAD@Z
_TEXT	SEGMENT
tv202 = -584						; size = 4
_showString$ = -580					; size = 512
_strPal$1 = -68						; size = 32
_floorName$ = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_fl$ = 12						; size = 4
_x1$ = 16						; size = 4
_y1$ = 20						; size = 4
_x2$ = 24						; size = 4
_y2$ = 28						; size = 4
_tileSum$ = 32						; size = 4
_partsSum$ = 36						; size = 4
_eventSum$ = 40						; size = 4
_data$ = 44						; size = 4
?lssproto_MC_recv@@YAXHHHHHHHHHPAD@Z PROC		; lssproto_MC_recv, COMDAT

; 1809 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 02 00
	00		 sub	 esp, 584		; 00000248H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1810 : 	char showString[512], floorName[32];
; 1811 : 
; 1812 : 	if (logOutFlag)

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  0001a	8b 45 2c	 mov	 eax, DWORD PTR _data$[ebp]
  0001d	0f 85 96 01 00
	00		 jne	 $LN23@lssproto_M

; 1813 : 		return;
; 1814 : 
; 1815 : #ifdef DEBUGPUSH
; 1816 :     char msg[800];
; 1817 :     sprintf(msg, "ä½‹???????????????FL%d %d,%d-%d,%d (%ud/%ud)", fl, x1, y1, x2, y2, tileSum, partsSum);
; 1818 :     PUSH(msg);
; 1819 : #endif
; 1820 : 	getStringToken(data, '|', 1, sizeof(showString) - 1, showString);

  00023	56		 push	 esi
  00024	57		 push	 edi
  00025	8d 8d bc fd ff
	ff		 lea	 ecx, DWORD PTR _showString$[ebp]
  0002b	51		 push	 ecx
  0002c	68 ff 01 00 00	 push	 511			; 000001ffH
  00031	6a 01		 push	 1
  00033	6a 7c		 push	 124			; 0000007cH
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1821 : 	makeStringFromEscaped(showString);

  0003b	8d 85 bc fd ff
	ff		 lea	 eax, DWORD PTR _showString$[ebp]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 1822 : 	if (nowFloor == fl)

  00047	8b 75 0c	 mov	 esi, DWORD PTR _fl$[ebp]
  0004a	83 c4 18	 add	 esp, 24			; 00000018H
  0004d	bf 01 00 00 00	 mov	 edi, 1
  00052	39 35 00 00 00
	00		 cmp	 DWORD PTR ?nowFloor@@3HA, esi ; nowFloor
  00058	0f 85 e0 00 00
	00		 jne	 $LN17@lssproto_M

; 1823 : 	{
; 1824 : 		char strPal[32];
; 1825 : 
; 1826 : 		getStringToken(showString, '|', 1, sizeof(floorName) - 1, floorName);

  0005e	8d 45 dc	 lea	 eax, DWORD PTR _floorName$[ebp]
  00061	50		 push	 eax
  00062	6a 1f		 push	 31			; 0000001fH
  00064	57		 push	 edi
  00065	8d 85 bc fd ff
	ff		 lea	 eax, DWORD PTR _showString$[ebp]
  0006b	6a 7c		 push	 124			; 0000007cH
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1827 : 		if (strlen(floorName) <= FLOOR_NAME_LEN)

  00073	8d 4d dc	 lea	 ecx, DWORD PTR _floorName$[ebp]
  00076	83 c4 14	 add	 esp, 20			; 00000014H
  00079	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0007c	0f 1f 40 00	 npad	 4
$LL37@lssproto_M:
  00080	8a 01		 mov	 al, BYTE PTR [ecx]
  00082	41		 inc	 ecx
  00083	84 c0		 test	 al, al
  00085	75 f9		 jne	 SHORT $LL37@lssproto_M
  00087	2b ca		 sub	 ecx, edx
  00089	83 f9 18	 cmp	 ecx, 24			; 00000018H
  0008c	77 15		 ja	 SHORT $LN7@lssproto_M

; 1828 : 			strcpy(nowFloorName, floorName);

  0008e	33 c9		 xor	 ecx, ecx
$LL27@lssproto_M:
  00090	8a 44 0d dc	 mov	 al, BYTE PTR _floorName$[ebp+ecx]
  00094	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00097	88 81 ff ff ff
	ff		 mov	 BYTE PTR ?nowFloorName@@3PADA[ecx-1], al
  0009d	84 c0		 test	 al, al
  0009f	75 ef		 jne	 SHORT $LL27@lssproto_M
  000a1	eb 0a		 jmp	 SHORT $LN8@lssproto_M
$LN7@lssproto_M:

; 1829 : 		else
; 1830 : 			strcpy(nowFloorName, "???");

  000a3	c7 05 00 00 00
	00 3f 3f 3f 00	 mov	 DWORD PTR ?nowFloorName@@3PADA, 4144959 ; 003f3f3fH
$LN8@lssproto_M:

; 1831 : 		palNo = -2;
; 1832 : 		getStringToken(showString, '|', 2, sizeof(strPal) - 1, strPal);

  000ad	8d 45 bc	 lea	 eax, DWORD PTR _strPal$1[ebp]
  000b0	c7 05 00 00 00
	00 fe ff ff ff	 mov	 DWORD PTR ?palNo@@3HA, -2 ; palNo, fffffffeH
  000ba	50		 push	 eax
  000bb	6a 1f		 push	 31			; 0000001fH
  000bd	6a 02		 push	 2
  000bf	8d 85 bc fd ff
	ff		 lea	 eax, DWORD PTR _showString$[ebp]
  000c5	6a 7c		 push	 124			; 0000007cH
  000c7	50		 push	 eax
  000c8	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 1833 : 		if (strlen(strPal) == 0)

  000cd	8d 4d bc	 lea	 ecx, DWORD PTR _strPal$1[ebp]
  000d0	83 c4 14	 add	 esp, 20			; 00000014H
  000d3	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL38@lssproto_M:
  000d6	8a 01		 mov	 al, BYTE PTR [ecx]
  000d8	41		 inc	 ecx
  000d9	84 c0		 test	 al, al
  000db	75 f9		 jne	 SHORT $LL38@lssproto_M
  000dd	2b ca		 sub	 ecx, edx
  000df	74 30		 je	 SHORT $LN13@lssproto_M

; 1834 : 		{
; 1835 : 			if (TimeZonePalChangeFlag == FALSE || loginFlag)
; 1836 : 			{
; 1837 : 				palNo = -1;
; 1838 : 				palTime = 0;
; 1839 : 				drawTimeAnimeFlag = 1;
; 1840 : 			}
; 1841 : 		}
; 1842 : 		else
; 1843 : 		{
; 1844 : 			int pal;
; 1845 : 
; 1846 : 			pal = atoi(strPal);

  000e1	8d 45 bc	 lea	 eax, DWORD PTR _strPal$1[ebp]
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 _atoi
  000ea	83 c4 04	 add	 esp, 4

; 1847 : 			if (pal >= 0)

  000ed	85 c0		 test	 eax, eax
  000ef	78 20		 js	 SHORT $LN13@lssproto_M

; 1848 : 			{
; 1849 : 				if (TimeZonePalChangeFlag == TRUE || loginFlag)

  000f1	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?TimeZonePalChangeFlag@@3HA, edi ; TimeZonePalChangeFlag
  000f7	74 09		 je	 SHORT $LN16@lssproto_M
  000f9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?loginFlag@@3HA, 0 ; loginFlag
  00100	74 3c		 je	 SHORT $LN17@lssproto_M
$LN16@lssproto_M:

; 1850 : 				{
; 1851 : 					palNo = pal;

  00102	a3 00 00 00 00	 mov	 DWORD PTR ?palNo@@3HA, eax ; palNo

; 1852 : 					palTime = 0;
; 1853 : 					drawTimeAnimeFlag = 0;

  00107	33 c0		 xor	 eax, eax
  00109	66 a3 00 00 00
	00		 mov	 WORD PTR ?drawTimeAnimeFlag@@3FA, ax ; drawTimeAnimeFlag

; 1854 : 				}
; 1855 : 			}

  0010f	eb 23		 jmp	 SHORT $LN44@lssproto_M
$LN13@lssproto_M:

; 1856 : 			else
; 1857 : 			{
; 1858 : 				if (TimeZonePalChangeFlag == FALSE || loginFlag)
; 1859 : 				{
; 1860 : 					palNo = -1;
; 1861 : 					palTime = 0;
; 1862 : 					drawTimeAnimeFlag = 1;
; 1863 : 				}
; 1864 : 			}
; 1865 : 		}
; 1866 : 	}
; 1867 : 
; 1868 : 	//JL fix 2017.9.25 ç»„é˜Ÿæƒ…å†µä¸‹ï¼Œé˜Ÿå‘˜ä¸æ£€æŸ¥åœ°å›¾ï¼Œé˜²æ­¢å¾ˆå¡
; 1869 : 	for (int i = 1; i < MAX_PARTY; i++) 

  00111	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?TimeZonePalChangeFlag@@3HA, 0 ; TimeZonePalChangeFlag
  00118	74 09		 je	 SHORT $LN18@lssproto_M
  0011a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?loginFlag@@3HA, 0 ; loginFlag
  00121	74 1b		 je	 SHORT $LN17@lssproto_M
$LN18@lssproto_M:
  00123	66 89 3d 00 00
	00 00		 mov	 WORD PTR ?drawTimeAnimeFlag@@3FA, di ; drawTimeAnimeFlag
  0012a	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?palNo@@3HA, -1 ; palNo
$LN44@lssproto_M:
  00134	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?palTime@@3HA, 0 ; palTime
$LN17@lssproto_M:
  0013e	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?pc@@3UPC@@A+8
  00144	b8 34 00 00 00	 mov	 eax, OFFSET ?party@@3PAUPARTY@@A+52
  00149	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@lssproto_M:

; 1870 : 	{
; 1871 : 		if (party[i].useFlag != 0)

  00150	66 83 78 fc 00	 cmp	 WORD PTR [eax-4], 0
  00155	74 04		 je	 SHORT $LN2@lssproto_M

; 1872 : 		{
; 1873 : 			if (party[i].id == pc.id)

  00157	39 08		 cmp	 DWORD PTR [eax], ecx
  00159	74 6c		 je	 SHORT $LN30@lssproto_M
$LN2@lssproto_M:

; 1856 : 			else
; 1857 : 			{
; 1858 : 				if (TimeZonePalChangeFlag == FALSE || loginFlag)
; 1859 : 				{
; 1860 : 					palNo = -1;
; 1861 : 					palTime = 0;
; 1862 : 					drawTimeAnimeFlag = 1;
; 1863 : 				}
; 1864 : 			}
; 1865 : 		}
; 1866 : 	}
; 1867 : 
; 1868 : 	//JL fix 2017.9.25 ç»„é˜Ÿæƒ…å†µä¸‹ï¼Œé˜Ÿå‘˜ä¸æ£€æŸ¥åœ°å›¾ï¼Œé˜²æ­¢å¾ˆå¡
; 1869 : 	for (int i = 1; i < MAX_PARTY; i++) 

  0015b	83 c0 30	 add	 eax, 48			; 00000030H
  0015e	3d f4 00 00 00	 cmp	 eax, OFFSET ?party@@3PAUPARTY@@A+244
  00163	7c eb		 jl	 SHORT $LL4@lssproto_M

; 1880 : 				}
; 1881 : 				loginFlag = FALSE;
; 1882 : 				return;
; 1883 : 			}
; 1884 : 		}
; 1885 : 	}
; 1886 : 
; 1887 : 
; 1888 : 
; 1889 : 	if (mapCheckSum(fl, x1, y1, x2, y2, tileSum, partsSum, eventSum))

  00165	ff 75 28	 push	 DWORD PTR _eventSum$[ebp]
  00168	ff 75 24	 push	 DWORD PTR _partsSum$[ebp]
  0016b	ff 75 20	 push	 DWORD PTR _tileSum$[ebp]
  0016e	ff 75 1c	 push	 DWORD PTR _y2$[ebp]
  00171	ff 75 18	 push	 DWORD PTR _x2$[ebp]
  00174	ff 75 14	 push	 DWORD PTR _y1$[ebp]
  00177	ff 75 10	 push	 DWORD PTR _x1$[ebp]
  0017a	56		 push	 esi
  0017b	e8 00 00 00 00	 call	 ?mapCheckSum@@YAHHHHHHHHH@Z ; mapCheckSum
  00180	83 c4 20	 add	 esp, 32			; 00000020H
  00183	85 c0		 test	 eax, eax
  00185	74 30		 je	 SHORT $LN40@lssproto_M

; 1890 : 	{
; 1891 : 		if (nowFloor == fl)

  00187	39 35 00 00 00
	00		 cmp	 DWORD PTR ?nowFloor@@3HA, esi ; nowFloor
  0018d	75 1e		 jne	 SHORT $LN25@lssproto_M

; 1892 : 		{
; 1893 : 			floorChangeFlag = FALSE;
; 1894 : 			if (warpEffectStart)

  0018f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?warpEffectOk@@3HA ; warpEffectOk
  00194	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?warpEffectStart@@3HA, 0 ; warpEffectStart
  0019b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?floorChangeFlag@@3HA, 0 ; floorChangeFlag
  001a5	0f 45 c7	 cmovne	 eax, edi
  001a8	a3 00 00 00 00	 mov	 DWORD PTR ?warpEffectOk@@3HA, eax ; warpEffectOk
$LN25@lssproto_M:

; 1895 : 				warpEffectOk = TRUE;
; 1896 : 		}
; 1897 : 		loginFlag = FALSE;

  001ad	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?loginFlag@@3HA, 0 ; loginFlag
$LN40@lssproto_M:
  001b7	5f		 pop	 edi
  001b8	5e		 pop	 esi
$LN23@lssproto_M:

; 1898 : 	}
; 1899 : }

  001b9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bc	33 cd		 xor	 ecx, ebp
  001be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c3	8b e5		 mov	 esp, ebp
  001c5	5d		 pop	 ebp
  001c6	c3		 ret	 0
$LN30@lssproto_M:

; 1874 : 			{
; 1875 : 				if (nowFloor == fl)

  001c7	39 35 00 00 00
	00		 cmp	 DWORD PTR ?nowFloor@@3HA, esi ; nowFloor
  001cd	75 de		 jne	 SHORT $LN25@lssproto_M

; 1876 : 				{
; 1877 : 					floorChangeFlag = FALSE;
; 1878 : 					if (warpEffectStart)

  001cf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?warpEffectStart@@3HA, 0 ; warpEffectStart
  001d6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?floorChangeFlag@@3HA, 0 ; floorChangeFlag
  001e0	74 cb		 je	 SHORT $LN25@lssproto_M

; 1879 : 						warpEffectOk = TRUE;

  001e2	89 3d 00 00 00
	00		 mov	 DWORD PTR ?warpEffectOk@@3HA, edi ; warpEffectOk
  001e8	eb c3		 jmp	 SHORT $LN25@lssproto_M
?lssproto_MC_recv@@YAXHHHHHHHHHPAD@Z ENDP		; lssproto_MC_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_TK_recv@@YAXHHPADH@Z
_TEXT	SEGMENT
_id$ = -2052						; size = 2
_fontsize$3$ = -2048					; size = 4
_type$ = -2048						; size = 4
_szToken$1 = -2044					; size = 4
_msg$ = -2040						; size = 2024
_token$2 = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_index$ = 12						; size = 4
_message$ = 16						; size = 4
_color$ = 20						; size = 4
?lssproto_TK_recv@@YAXHHPADH@Z PROC			; lssproto_TK_recv, COMDAT

; 2727 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 08 00
	00		 sub	 esp, 2052		; 00000804H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2728 : 	char id[2];
; 2729 : 	char msg[2024];
; 2730 : 	ACTION *ptAct;
; 2731 : 	int fontsize =0;
; 2732 : 
; 2733 : 	int type;
; 2734 : 
; 2735 : 	// ????????????????îºîŸ«?î¡Š???
; 2736 : 	if ( logOutFlag )

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  0001a	53		 push	 ebx
  0001b	8b 5d 0c	 mov	 ebx, DWORD PTR _index$[ebp]
  0001e	56		 push	 esi
  0001f	8b 75 10	 mov	 esi, DWORD PTR _message$[ebp]
  00022	c7 85 00 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR _fontsize$3$[ebp], 0
  0002c	0f 85 c7 02 00
	00		 jne	 $LN26@lssproto_T

; 2737 : 		return;
; 2738 : 
; 2739 : 	getStringToken( message, '|', 1, sizeof( id  ) - 1, id );

  00032	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _id$[ebp]
  00038	50		 push	 eax
  00039	6a 01		 push	 1
  0003b	6a 01		 push	 1
  0003d	6a 7c		 push	 124			; 0000007cH
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00045	83 c4 14	 add	 esp, 20			; 00000014H

; 2740 : 
; 2741 : 	if ( id[0] == 'P' ){

  00048	80 bd fc f7 ff
	ff 50		 cmp	 BYTE PTR _id$[ebp], 80	; 00000050H
  0004f	0f 85 a4 02 00
	00		 jne	 $LN26@lssproto_T

; 2742 : #ifndef _CHANNEL_MODIFY
; 2743 : 		getStringToken( message, '|', 2, sizeof( msg ) - 1, msg );
; 2744 : 		makeStringFromEscaped( msg );
; 2745 : 	#ifdef _TRADETALKWND				// (ä¸å¯å¼€) Syu ADD äº¤æ˜“æ–°å¢žå¯¹è¯æ¡†æž¶
; 2746 : 		TradeTalk( msg ) ; 
; 2747 : 	#endif
; 2748 : #endif
; 2749 : 
; 2750 : #ifdef _CHANNEL_MODIFY
; 2751 : 		char szToken[4];
; 2752 : 
; 2753 : 		if (getStringToken(message,'|',2,sizeof(szToken) - 1,szToken) == 0){

  00055	57		 push	 edi
  00056	8d 85 04 f8 ff
	ff		 lea	 eax, DWORD PTR _szToken$1[ebp]
  0005c	50		 push	 eax
  0005d	6a 03		 push	 3
  0005f	6a 02		 push	 2
  00061	6a 7c		 push	 124			; 0000007cH
  00063	56		 push	 esi
  00064	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00069	83 c4 14	 add	 esp, 20			; 00000014H
  0006c	85 c0		 test	 eax, eax
  0006e	8d 85 08 f8 ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  00074	50		 push	 eax
  00075	68 e7 07 00 00	 push	 2023			; 000007e7H
  0007a	0f 85 a9 01 00
	00		 jne	 $LN6@lssproto_T

; 2754 : 			getStringToken(message,'|',3,sizeof(msg) - 1,msg);

  00080	6a 03		 push	 3
  00082	6a 7c		 push	 124			; 0000007cH
  00084	56		 push	 esi
  00085	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2755 : 			makeStringFromEscaped(msg);

  0008a	8d 85 08 f8 ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 2756 : #ifdef _FONT_SIZE
; 2757 : 			char token[10];
; 2758 : 			if ( getStringToken(message,'|',4,sizeof(token) - 1,token) == 1) {

  00096	8d 45 f0	 lea	 eax, DWORD PTR _token$2[ebp]
  00099	50		 push	 eax
  0009a	6a 09		 push	 9
  0009c	6a 04		 push	 4
  0009e	6a 7c		 push	 124			; 0000007cH
  000a0	56		 push	 esi
  000a1	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  000a6	83 c4 2c	 add	 esp, 44			; 0000002cH
  000a9	83 f8 01	 cmp	 eax, 1
  000ac	75 23		 jne	 SHORT $LN8@lssproto_T

; 2759 : 				fontsize = atoi( token);

  000ae	8d 45 f0	 lea	 eax, DWORD PTR _token$2[ebp]
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 _atoi

; 2760 : 				if ( fontsize < 0 )	fontsize = 0;

  000b7	33 c9		 xor	 ecx, ecx
  000b9	83 c4 04	 add	 esp, 4
  000bc	85 c0		 test	 eax, eax
  000be	0f 48 c1	 cmovs	 eax, ecx

; 2761 : 
; 2762 : 				//CC fix
; 2763 : 				//é€‚é…ä¸–ç•Œé¢‘é“
; 2764 : 				if (fontsize == 99)	fontsize = 0;
; 2765 : 			}

  000c1	33 d2		 xor	 edx, edx
  000c3	83 f8 63	 cmp	 eax, 99			; 00000063H
  000c6	0f 45 d0	 cmovne	 edx, eax
  000c9	89 95 00 f8 ff
	ff		 mov	 DWORD PTR _fontsize$3$[ebp], edx
  000cf	eb 0a		 jmp	 SHORT $LN9@lssproto_T
$LN8@lssproto_T:

; 2766 : 			else {
; 2767 : 				fontsize = 0;

  000d1	c7 85 00 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR _fontsize$3$[ebp], 0
$LN9@lssproto_T:

; 2768 : 			}
; 2769 : #endif
; 2770 : 
; 2771 : 			type = TYPE_TALK::é™„è¿‘;
; 2772 : 
; 2773 : 			if (strlen(szToken) > 1){

  000db	8d 8d 04 f8 ff
	ff		 lea	 ecx, DWORD PTR _szToken$1[ebp]
  000e1	bf 01 00 00 00	 mov	 edi, 1
  000e6	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  000e9	0f 1f 80 00 00
	00 00		 npad	 7
$LL28@lssproto_T:
  000f0	8a 01		 mov	 al, BYTE PTR [ecx]
  000f2	41		 inc	 ecx
  000f3	84 c0		 test	 al, al
  000f5	75 f9		 jne	 SHORT $LL28@lssproto_T
  000f7	2b ca		 sub	 ecx, edx
  000f9	83 f9 01	 cmp	 ecx, 1
  000fc	0f 86 a7 00 00
	00		 jbe	 $LN12@lssproto_T

; 2774 : 				if (strcmp(szToken,"TK") == 0)	InitSelectChar(message,0);

  00102	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_02HIIGDGEP@TK@
  00107	8d 85 04 f8 ff
	ff		 lea	 eax, DWORD PTR _szToken$1[ebp]
  0010d	0f 1f 00	 npad	 3
$LL29@lssproto_T:
  00110	8a 10		 mov	 dl, BYTE PTR [eax]
  00112	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00114	75 1a		 jne	 SHORT $LN30@lssproto_T
  00116	84 d2		 test	 dl, dl
  00118	74 12		 je	 SHORT $LN31@lssproto_T
  0011a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0011d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00120	75 0e		 jne	 SHORT $LN30@lssproto_T
  00122	83 c0 02	 add	 eax, 2
  00125	83 c1 02	 add	 ecx, 2
  00128	84 d2		 test	 dl, dl
  0012a	75 e4		 jne	 SHORT $LL29@lssproto_T
$LN31@lssproto_T:
  0012c	33 c0		 xor	 eax, eax
  0012e	eb 05		 jmp	 SHORT $LN32@lssproto_T
$LN30@lssproto_T:
  00130	1b c0		 sbb	 eax, eax
  00132	83 c8 01	 or	 eax, 1
$LN32@lssproto_T:
  00135	85 c0		 test	 eax, eax
  00137	75 1b		 jne	 SHORT $LN14@lssproto_T
  00139	50		 push	 eax
  0013a	56		 push	 esi
  0013b	e8 00 00 00 00	 call	 ?InitSelectChar@@YAXPADH@Z ; InitSelectChar

; 2857 : 				{
; 2858 : 					// 1000??î¾î¸î•
; 2859 : 					setCharFukidashi( ptAct, 1000 );

  00140	83 c4 08	 add	 esp, 8
  00143	5f		 pop	 edi
  00144	5e		 pop	 esi

; 2860 : 				}
; 2861 : 			}
; 2862 : 		}
; 2863 : 	}
; 2864 : 
; 2865 : /*#if 0
; 2866 : 	if (index == my_id_in_server){
; 2867 : 		if (pinfo.ptaction != NULL){
; 2868 : 			createPlayerCommonEffect( pinfo.ptaction, SPR_fukidasi, 0, 1, -5 );
; 2869 : 		}
; 2870 : 	}else{
; 2871 : 		int goind = searchGameObjectIndex( index );
; 2872 : //		if ( goind >= 0 ||gameobj[goind].ptaction!=NULL){
; 2873 : 		if ( goind >= 0 && gameobj[goind].ptaction!=NULL ){
; 2874 : 			createPlayerCommonEffect( gameobj[goind].ptaction, SPR_fukidasi, 0, 1, -5 );
; 2875 : 		}
; 2876 : 	}
; 2877 : 
; 2878 : #ifdef DEBUGPUSH
; 2879 : 	if (color<249)PUSHVAR("îŸ‰?î‘‘?????????%d?'%s'",color, message); 
; 2880 : #endif
; 2881 : 	char id[2];
; 2882 :     char msg[2024];
; 2883 : 	getStringToken( message , '|' , 1 , sizeof( id ) - 1, id);
; 2884 : 	if (id[0] == 'P'){
; 2885 : 		getStringToken( message , '|' , 2 , sizeof( msg ) - 1, msg);
; 2886 : 		makeStringFromEscaped(msg);
; 2887 : 		char cutmes[1024];
; 2888 : 		int i, j;
; 2889 : 		for (i=0, j=0;;i++,j++){
; 2890 : 			cutmes[j] = msg[i];
; 2891 : 			if (msg[i] == '\0'){
; 2892 : 				chatinputPushString(cutmes, color);
; 2893 : 				break;
; 2894 : 			}
; 2895 : 			if ( IsDBCSTrailByte( msg, &msg[i+1] ) ){
; 2896 : 				continue;
; 2897 : 			}
; 2898 : 			cutmes[j+1]='\0';
; 2899 : 			if (GetStringWidth(cutmes)>600){
; 2900 : 				j = -1;
; 2901 : 				chatinputPushString(cutmes, color);
; 2902 : 			}
; 2903 : 		}
; 2904 : 	}else if (id[0] == 'D'){
; 2905 : 		int i;
; 2906 : 		selectwindowid = getIntegerToken(message, '|', 2);
; 2907 : 		void setDengonbanMessageNumber(int i);//netaction.cpp?î ´î•’
; 2908 : 		setDengonbanMessageNumber(getIntegerToken(message, '|', 3));
; 2909 : 		for (i=0;i<5;i++){
; 2910 : 			getStringToken( message , '|' , i+4 , sizeof( selectstringline[i] ) - 1, selectstringline[i]);
; 2911 : 			makeStringFromEscaped(selectstringline[i]);
; 2912 : 		}
; 2913 : 		cantclosewindowflag = 1;
; 2914 : 		OpenNPCWindow(NPC_BOARD_WINDOW);
; 2915 : 	}else if (id[0] == 'W'){
; 2916 : 		int i;
; 2917 : 		char token[1024];
; 2918 : 		getStringToken( message , '|' , 2 , sizeof( token ) - 1, token);
; 2919 : 		selectwindowid = atoi(token);
; 2920 : 		char mode[10];
; 2921 : 		getStringToken( message , '|' , 3 , sizeof( mode ) - 1, mode);
; 2922 : 		char caption[255];
; 2923 : 		int flag;
; 2924 : 		flag = getStringToken( message , '|' , 4 , sizeof( caption ) - 1, caption);
; 2925 : 		makeStringFromEscaped(caption);
; 2926 : 		strcpy(selectstringline[0],caption);
; 2927 : 		for (i=1;;i++){
; 2928 : 			selectstringlineindex[i] = getIntegerToken(message, '|', 3+i*2);
; 2929 : 			flag = getStringToken( message , '|' , 4+i*2 , sizeof( caption ) - 1, caption);
; 2930 : 			makeStringFromEscaped(caption);
; 2931 : 			strcpy(selectstringline[i],caption);
; 2932 : 			if (flag==1)break;
; 2933 : 		}
; 2934 : 		selectstringlinenumber=i;
; 2935 : 		cantclosewindowflag = 1;
; 2936 : 		if (mode[0] == 'G')OpenNPCWindow(NPC_KATARIBE_WINDOW);
; 2937 : 		else if (mode[0] == 'N')OpenNPCWindow(NPC_WINDOW);
; 2938 : 		else PUSHVAR("????????????????????????", msg);
; 2939 : 	}else if (id[0] == 'M'){
; 2940 : 		int i = 0, j = 0, k = 0;
; 2941 : 		if (strlen(message)>1024){
; 2942 : #ifdef DEBUGPUSH
; 2943 : 			PUSH("?????????????î—š?????");
; 2944 : #endif
; 2945 : 			return;
; 2946 : 		}
; 2947 : 		char token[1024];
; 2948 : 		getStringToken( message , '|' , 2 , sizeof( token ) - 1, token);
; 2949 : 		selectwindowid = atoi(token);
; 2950 : 		char mode[10];
; 2951 : 		getStringToken( message , '|' , 3 , sizeof( mode ) - 1, mode);
; 2952 : 		char caption[1024], onelinestring[1024];
; 2953 : 		getStringToken( message , '|' , 4 , sizeof( caption ) - 1, caption);
; 2954 : 		makeStringFromEscaped(caption);
; 2955 : 		for (i=0;;i++){
; 2956 : 			if (caption[i] == '\n'){
; 2957 : 				onelinestring[k] = '\0';
; 2958 : 				memcpy(selectstringline[j], onelinestring, k+1);
; 2959 : 				j++;
; 2960 : 				k = 0;
; 2961 : 			}else if (caption[i] == '\0'){
; 2962 : 				onelinestring[k] = '\0';
; 2963 : 				memcpy(selectstringline[j], onelinestring, k+1);
; 2964 : 				j++;
; 2965 : 				break;
; 2966 : 			}else{
; 2967 : 				onelinestring[k] = caption[i];
; 2968 : 				k++;
; 2969 : 			}
; 2970 : 		}
; 2971 : 		selectstringlinenumber=j;
; 2972 : 		if (mode[0] == 'G')OpenNPCWindow(NPC_G_MESSAGE_WINDOW);
; 2973 : 		else if (mode[0] == 'N')OpenNPCWindow(NPC_MESSAGE_WINDOW);
; 2974 : 		else PUSHVAR("????????????????????????", msg);
; 2975 : 	}else if (id[0] == 'S'){
; 2976 : 		int i;
; 2977 : #if 1
; 2978 : 		// î˜º?????????????????
; 2979 : 		for ( i = 0; i < MAXSHOPITEM; i++ )
; 2980 : 		{
; 2981 : 			shopitem[i].plice = 0;
; 2982 : 			shopitem[i].stock = 0;
; 2983 : 			shopitem[i].itm.name[0] = '\0';
; 2984 : 			shopitem[i].itm.name2[0] = '\0';
; 2985 : 			shopitem[i].itm.memo[0] = '\0';
; 2986 : 			shopitem[i].itm.stage = 0;
; 2987 : 			shopitem[i].itm.imgno = 0;
; 2988 : 		}
; 2989 : #endif
; 2990 : 		selectwindowid = getIntegerToken( message , '|' , 2 );	
; 2991 : 		for (i=0;i<7;i++){
; 2992 : 			getStringToken( message , '|' , 3+i , sizeof( shopmessage[i] ) - 1, shopmessage[i] );
; 2993 : 			makeStringFromEscaped(shopmessage[i]);
; 2994 : 		}
; 2995 : 		shopgold = getIntegerToken( message , '|' , 10 );
; 2996 : 		shopstock = getIntegerToken(message, '|', 11 );
; 2997 : 		for (i=0;i<shopstock;i++){
; 2998 : 			getStringToken( message , '|' , 12+i*5, sizeof(shopitem[i].itm.name) - 1, shopitem[i].itm.name);
; 2999 : 			makeStringFromEscaped(shopitem[i].itm.name);
; 3000 : 			if (strlen(shopitem[i].itm.name)==0)break;
; 3001 : 			shopitem[i].plice = getIntegerToken( message , '|' , 13+i*5);
; 3002 : 			shopitem[i].itm.stage = getIntegerToken( message , '|' , 14+i*5);
; 3003 : 			if (shopitem[i].itm.stage<0)shopitem[i].itm.stage=0;
; 3004 : 			shopitem[i].itm.imgno = getIntegerToken( message , '|' , 15+i*5);
; 3005 : 			getStringToken( message , '|' , 16+i*5, sizeof(shopitem[i].itm.memo) - 1, shopitem[i].itm.memo);
; 3006 : 			makeStringFromEscaped(shopitem[i].itm.memo);
; 3007 : 			shopitem[i].stock = 1;
; 3008 : 		}
; 3009 : 		for (i=0;i<40;i++){
; 3010 : 			charitemplice[i] = getIntegerToken(message, '|', 12+shopstock*5+i);
; 3011 : 		}
; 3012 : 		void setShoppage(int i);//layout.cpp
; 3013 : 		setShoppage (0);
; 3014 : 		OpenNPCWindow(NPC_SHOP_START_WINDOW);
; 3015 : 		cantclosewindowflag = 1;
; 3016 : 		PUSHVAR( "??????? '%s'??????????" , msg );
; 3017 : 	}else if (id[0] == 'L'){//???
; 3018 : 		getStringToken( message , '|' , 2 , sizeof( selectstringline[0] ) - 1, selectstringline[0] );
; 3019 : 			makeStringFromEscaped(selectstringline[0]);
; 3020 : 		getStringToken( message , '|' , 3 , sizeof( selectstringline[1] ) - 1, selectstringline[1] );
; 3021 : 			makeStringFromEscaped(selectstringline[1]);
; 3022 : 		selectstringlineindex[1] = SYSTEM_CHARLOST;
; 3023 : 		selectstringlinenumber=1;
; 3024 : 		cantclosewindowflag = 1;
; 3025 : 		OpenSystemWindow();
; 3026 : 	}else if (id[0] == 'K'){
; 3027 : 		void setSystemMessage(int i, char *mes, int index);//layout.cpp
; 3028 : 		int i;
; 3029 : 		char token[1024];
; 3030 : 		getStringToken( message , '|' , 2 , sizeof( token ) - 1, token);
; 3031 : 		selectwindowid = atoi(token);
; 3032 : 		char caption[255];
; 3033 : 		int flag;
; 3034 : 		int index;
; 3035 : 		flag = getStringToken( message , '|' , 3 , sizeof( caption ) - 1, caption);
; 3036 : 		makeStringFromEscaped(caption);
; 3037 : 		strcpy(selectstringline[0],caption);
; 3038 : 		setSystemMessage( 0, caption, SYSTEM_SYSTEM);
; 3039 : 		for (i=1;;i++){
; 3040 : 			flag = getStringToken( message , '|' , i+3 , sizeof( caption ) - 1, caption);
; 3041 : 			makeStringFromEscaped(caption);
; 3042 : 			strcpy(selectstringline[i],caption);
; 3043 : 			if (strcmp(selectstringline[i],"?????")==0){
; 3044 : 				index = SYSTEM_LOGOUT;
; 3045 : 			}else{
; 3046 : 				index = SYSTEM_SERVERPUSH_1+i-1;
; 3047 : 			}
; 3048 : 			selectstringlineindex[i]=index;
; 3049 : 			setSystemMessage( i, caption, index);
; 3050 : 			if (flag==1)break;
; 3051 : 		}
; 3052 : 		selectstringlinenumber=i;
; 3053 : 		deadflag = 1;
; 3054 : 		OpenSystemWindow();
; 3055 : //		OpenNPCWindow(NPC_WINDOW);
; 3056 : 		PUSH("TK?????????");
; 3057 : 	}else if (id[0] == 'R'){
; 3058 : 		deadflag = 0;
; 3059 : 	}else{
; 3060 : 		PUSH("TK????????????");
; 3061 : 	}
; 3062 : 
; 3063 : #endif
; 3064 : 	*/
; 3065 : }

  00145	5b		 pop	 ebx
  00146	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00149	33 cd		 xor	 ecx, ebp
  0014b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
$LN14@lssproto_T:

; 2775 : 				else if (strcmp(szToken,"TE") == 0) InitSelectChar(message,1);

  00154	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_02OGAFBLMB@TE@
  00159	8d 85 04 f8 ff
	ff		 lea	 eax, DWORD PTR _szToken$1[ebp]
  0015f	90		 npad	 1
$LL33@lssproto_T:
  00160	8a 10		 mov	 dl, BYTE PTR [eax]
  00162	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00164	75 1a		 jne	 SHORT $LN34@lssproto_T
  00166	84 d2		 test	 dl, dl
  00168	74 12		 je	 SHORT $LN35@lssproto_T
  0016a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0016d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00170	75 0e		 jne	 SHORT $LN34@lssproto_T
  00172	83 c0 02	 add	 eax, 2
  00175	83 c1 02	 add	 ecx, 2
  00178	84 d2		 test	 dl, dl
  0017a	75 e4		 jne	 SHORT $LL33@lssproto_T
$LN35@lssproto_T:
  0017c	33 c0		 xor	 eax, eax
  0017e	eb 05		 jmp	 SHORT $LN36@lssproto_T
$LN34@lssproto_T:
  00180	1b c0		 sbb	 eax, eax
  00182	83 c8 01	 or	 eax, 1
$LN36@lssproto_T:
  00185	85 c0		 test	 eax, eax
  00187	0f 85 6b 01 00
	00		 jne	 $LN43@lssproto_T
  0018d	6a 01		 push	 1
  0018f	56		 push	 esi
  00190	e8 00 00 00 00	 call	 ?InitSelectChar@@YAXPADH@Z ; InitSelectChar

; 2857 : 				{
; 2858 : 					// 1000??î¾î¸î•
; 2859 : 					setCharFukidashi( ptAct, 1000 );

  00195	83 c4 08	 add	 esp, 8
  00198	5f		 pop	 edi
  00199	5e		 pop	 esi

; 2860 : 				}
; 2861 : 			}
; 2862 : 		}
; 2863 : 	}
; 2864 : 
; 2865 : /*#if 0
; 2866 : 	if (index == my_id_in_server){
; 2867 : 		if (pinfo.ptaction != NULL){
; 2868 : 			createPlayerCommonEffect( pinfo.ptaction, SPR_fukidasi, 0, 1, -5 );
; 2869 : 		}
; 2870 : 	}else{
; 2871 : 		int goind = searchGameObjectIndex( index );
; 2872 : //		if ( goind >= 0 ||gameobj[goind].ptaction!=NULL){
; 2873 : 		if ( goind >= 0 && gameobj[goind].ptaction!=NULL ){
; 2874 : 			createPlayerCommonEffect( gameobj[goind].ptaction, SPR_fukidasi, 0, 1, -5 );
; 2875 : 		}
; 2876 : 	}
; 2877 : 
; 2878 : #ifdef DEBUGPUSH
; 2879 : 	if (color<249)PUSHVAR("îŸ‰?î‘‘?????????%d?'%s'",color, message); 
; 2880 : #endif
; 2881 : 	char id[2];
; 2882 :     char msg[2024];
; 2883 : 	getStringToken( message , '|' , 1 , sizeof( id ) - 1, id);
; 2884 : 	if (id[0] == 'P'){
; 2885 : 		getStringToken( message , '|' , 2 , sizeof( msg ) - 1, msg);
; 2886 : 		makeStringFromEscaped(msg);
; 2887 : 		char cutmes[1024];
; 2888 : 		int i, j;
; 2889 : 		for (i=0, j=0;;i++,j++){
; 2890 : 			cutmes[j] = msg[i];
; 2891 : 			if (msg[i] == '\0'){
; 2892 : 				chatinputPushString(cutmes, color);
; 2893 : 				break;
; 2894 : 			}
; 2895 : 			if ( IsDBCSTrailByte( msg, &msg[i+1] ) ){
; 2896 : 				continue;
; 2897 : 			}
; 2898 : 			cutmes[j+1]='\0';
; 2899 : 			if (GetStringWidth(cutmes)>600){
; 2900 : 				j = -1;
; 2901 : 				chatinputPushString(cutmes, color);
; 2902 : 			}
; 2903 : 		}
; 2904 : 	}else if (id[0] == 'D'){
; 2905 : 		int i;
; 2906 : 		selectwindowid = getIntegerToken(message, '|', 2);
; 2907 : 		void setDengonbanMessageNumber(int i);//netaction.cpp?î ´î•’
; 2908 : 		setDengonbanMessageNumber(getIntegerToken(message, '|', 3));
; 2909 : 		for (i=0;i<5;i++){
; 2910 : 			getStringToken( message , '|' , i+4 , sizeof( selectstringline[i] ) - 1, selectstringline[i]);
; 2911 : 			makeStringFromEscaped(selectstringline[i]);
; 2912 : 		}
; 2913 : 		cantclosewindowflag = 1;
; 2914 : 		OpenNPCWindow(NPC_BOARD_WINDOW);
; 2915 : 	}else if (id[0] == 'W'){
; 2916 : 		int i;
; 2917 : 		char token[1024];
; 2918 : 		getStringToken( message , '|' , 2 , sizeof( token ) - 1, token);
; 2919 : 		selectwindowid = atoi(token);
; 2920 : 		char mode[10];
; 2921 : 		getStringToken( message , '|' , 3 , sizeof( mode ) - 1, mode);
; 2922 : 		char caption[255];
; 2923 : 		int flag;
; 2924 : 		flag = getStringToken( message , '|' , 4 , sizeof( caption ) - 1, caption);
; 2925 : 		makeStringFromEscaped(caption);
; 2926 : 		strcpy(selectstringline[0],caption);
; 2927 : 		for (i=1;;i++){
; 2928 : 			selectstringlineindex[i] = getIntegerToken(message, '|', 3+i*2);
; 2929 : 			flag = getStringToken( message , '|' , 4+i*2 , sizeof( caption ) - 1, caption);
; 2930 : 			makeStringFromEscaped(caption);
; 2931 : 			strcpy(selectstringline[i],caption);
; 2932 : 			if (flag==1)break;
; 2933 : 		}
; 2934 : 		selectstringlinenumber=i;
; 2935 : 		cantclosewindowflag = 1;
; 2936 : 		if (mode[0] == 'G')OpenNPCWindow(NPC_KATARIBE_WINDOW);
; 2937 : 		else if (mode[0] == 'N')OpenNPCWindow(NPC_WINDOW);
; 2938 : 		else PUSHVAR("????????????????????????", msg);
; 2939 : 	}else if (id[0] == 'M'){
; 2940 : 		int i = 0, j = 0, k = 0;
; 2941 : 		if (strlen(message)>1024){
; 2942 : #ifdef DEBUGPUSH
; 2943 : 			PUSH("?????????????î—š?????");
; 2944 : #endif
; 2945 : 			return;
; 2946 : 		}
; 2947 : 		char token[1024];
; 2948 : 		getStringToken( message , '|' , 2 , sizeof( token ) - 1, token);
; 2949 : 		selectwindowid = atoi(token);
; 2950 : 		char mode[10];
; 2951 : 		getStringToken( message , '|' , 3 , sizeof( mode ) - 1, mode);
; 2952 : 		char caption[1024], onelinestring[1024];
; 2953 : 		getStringToken( message , '|' , 4 , sizeof( caption ) - 1, caption);
; 2954 : 		makeStringFromEscaped(caption);
; 2955 : 		for (i=0;;i++){
; 2956 : 			if (caption[i] == '\n'){
; 2957 : 				onelinestring[k] = '\0';
; 2958 : 				memcpy(selectstringline[j], onelinestring, k+1);
; 2959 : 				j++;
; 2960 : 				k = 0;
; 2961 : 			}else if (caption[i] == '\0'){
; 2962 : 				onelinestring[k] = '\0';
; 2963 : 				memcpy(selectstringline[j], onelinestring, k+1);
; 2964 : 				j++;
; 2965 : 				break;
; 2966 : 			}else{
; 2967 : 				onelinestring[k] = caption[i];
; 2968 : 				k++;
; 2969 : 			}
; 2970 : 		}
; 2971 : 		selectstringlinenumber=j;
; 2972 : 		if (mode[0] == 'G')OpenNPCWindow(NPC_G_MESSAGE_WINDOW);
; 2973 : 		else if (mode[0] == 'N')OpenNPCWindow(NPC_MESSAGE_WINDOW);
; 2974 : 		else PUSHVAR("????????????????????????", msg);
; 2975 : 	}else if (id[0] == 'S'){
; 2976 : 		int i;
; 2977 : #if 1
; 2978 : 		// î˜º?????????????????
; 2979 : 		for ( i = 0; i < MAXSHOPITEM; i++ )
; 2980 : 		{
; 2981 : 			shopitem[i].plice = 0;
; 2982 : 			shopitem[i].stock = 0;
; 2983 : 			shopitem[i].itm.name[0] = '\0';
; 2984 : 			shopitem[i].itm.name2[0] = '\0';
; 2985 : 			shopitem[i].itm.memo[0] = '\0';
; 2986 : 			shopitem[i].itm.stage = 0;
; 2987 : 			shopitem[i].itm.imgno = 0;
; 2988 : 		}
; 2989 : #endif
; 2990 : 		selectwindowid = getIntegerToken( message , '|' , 2 );	
; 2991 : 		for (i=0;i<7;i++){
; 2992 : 			getStringToken( message , '|' , 3+i , sizeof( shopmessage[i] ) - 1, shopmessage[i] );
; 2993 : 			makeStringFromEscaped(shopmessage[i]);
; 2994 : 		}
; 2995 : 		shopgold = getIntegerToken( message , '|' , 10 );
; 2996 : 		shopstock = getIntegerToken(message, '|', 11 );
; 2997 : 		for (i=0;i<shopstock;i++){
; 2998 : 			getStringToken( message , '|' , 12+i*5, sizeof(shopitem[i].itm.name) - 1, shopitem[i].itm.name);
; 2999 : 			makeStringFromEscaped(shopitem[i].itm.name);
; 3000 : 			if (strlen(shopitem[i].itm.name)==0)break;
; 3001 : 			shopitem[i].plice = getIntegerToken( message , '|' , 13+i*5);
; 3002 : 			shopitem[i].itm.stage = getIntegerToken( message , '|' , 14+i*5);
; 3003 : 			if (shopitem[i].itm.stage<0)shopitem[i].itm.stage=0;
; 3004 : 			shopitem[i].itm.imgno = getIntegerToken( message , '|' , 15+i*5);
; 3005 : 			getStringToken( message , '|' , 16+i*5, sizeof(shopitem[i].itm.memo) - 1, shopitem[i].itm.memo);
; 3006 : 			makeStringFromEscaped(shopitem[i].itm.memo);
; 3007 : 			shopitem[i].stock = 1;
; 3008 : 		}
; 3009 : 		for (i=0;i<40;i++){
; 3010 : 			charitemplice[i] = getIntegerToken(message, '|', 12+shopstock*5+i);
; 3011 : 		}
; 3012 : 		void setShoppage(int i);//layout.cpp
; 3013 : 		setShoppage (0);
; 3014 : 		OpenNPCWindow(NPC_SHOP_START_WINDOW);
; 3015 : 		cantclosewindowflag = 1;
; 3016 : 		PUSHVAR( "??????? '%s'??????????" , msg );
; 3017 : 	}else if (id[0] == 'L'){//???
; 3018 : 		getStringToken( message , '|' , 2 , sizeof( selectstringline[0] ) - 1, selectstringline[0] );
; 3019 : 			makeStringFromEscaped(selectstringline[0]);
; 3020 : 		getStringToken( message , '|' , 3 , sizeof( selectstringline[1] ) - 1, selectstringline[1] );
; 3021 : 			makeStringFromEscaped(selectstringline[1]);
; 3022 : 		selectstringlineindex[1] = SYSTEM_CHARLOST;
; 3023 : 		selectstringlinenumber=1;
; 3024 : 		cantclosewindowflag = 1;
; 3025 : 		OpenSystemWindow();
; 3026 : 	}else if (id[0] == 'K'){
; 3027 : 		void setSystemMessage(int i, char *mes, int index);//layout.cpp
; 3028 : 		int i;
; 3029 : 		char token[1024];
; 3030 : 		getStringToken( message , '|' , 2 , sizeof( token ) - 1, token);
; 3031 : 		selectwindowid = atoi(token);
; 3032 : 		char caption[255];
; 3033 : 		int flag;
; 3034 : 		int index;
; 3035 : 		flag = getStringToken( message , '|' , 3 , sizeof( caption ) - 1, caption);
; 3036 : 		makeStringFromEscaped(caption);
; 3037 : 		strcpy(selectstringline[0],caption);
; 3038 : 		setSystemMessage( 0, caption, SYSTEM_SYSTEM);
; 3039 : 		for (i=1;;i++){
; 3040 : 			flag = getStringToken( message , '|' , i+3 , sizeof( caption ) - 1, caption);
; 3041 : 			makeStringFromEscaped(caption);
; 3042 : 			strcpy(selectstringline[i],caption);
; 3043 : 			if (strcmp(selectstringline[i],"?????")==0){
; 3044 : 				index = SYSTEM_LOGOUT;
; 3045 : 			}else{
; 3046 : 				index = SYSTEM_SERVERPUSH_1+i-1;
; 3047 : 			}
; 3048 : 			selectstringlineindex[i]=index;
; 3049 : 			setSystemMessage( i, caption, index);
; 3050 : 			if (flag==1)break;
; 3051 : 		}
; 3052 : 		selectstringlinenumber=i;
; 3053 : 		deadflag = 1;
; 3054 : 		OpenSystemWindow();
; 3055 : //		OpenNPCWindow(NPC_WINDOW);
; 3056 : 		PUSH("TK?????????");
; 3057 : 	}else if (id[0] == 'R'){
; 3058 : 		deadflag = 0;
; 3059 : 	}else{
; 3060 : 		PUSH("TK????????????");
; 3061 : 	}
; 3062 : 
; 3063 : #endif
; 3064 : 	*/
; 3065 : }

  0019a	5b		 pop	 ebx
  0019b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0019e	33 cd		 xor	 ecx, ebp
  001a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a5	8b e5		 mov	 esp, ebp
  001a7	5d		 pop	 ebp
  001a8	c3		 ret	 0
$LN12@lssproto_T:

; 2776 : 				return;
; 2777 : 			}
; 2778 : 			else{
; 2779 : 				switch (szToken[0]){

  001a9	8b 85 04 f8 ff
	ff		 mov	 eax, DWORD PTR _szToken$1[ebp]
  001af	0f be c8	 movsx	 ecx, al
  001b2	83 c1 ba	 add	 ecx, -70		; ffffffbaH
  001b5	83 f9 0e	 cmp	 ecx, 14			; 0000000eH
  001b8	77 5b		 ja	 SHORT $LN2@lssproto_T
  001ba	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN37@lssproto_T[ecx]
  001c1	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN38@lssproto_T[ecx*4]
$LN17@lssproto_T:

; 2795 : 					break;
; 2796 : 				}
; 2797 : 				SaveChatData(msg,szToken[0],false);

  001c8	6a 00		 push	 0
  001ca	50		 push	 eax
  001cb	8d 85 08 f8 ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  001d1	bf 03 00 00 00	 mov	 edi, 3
  001d6	50		 push	 eax
  001d7	e8 00 00 00 00	 call	 ?SaveChatData@@YAXPADD_N@Z ; SaveChatData
  001dc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2798 : 			}
; 2799 : 		}

  001df	eb 5b		 jmp	 SHORT $LN7@lssproto_T
$LN18@lssproto_T:

; 2795 : 					break;
; 2796 : 				}
; 2797 : 				SaveChatData(msg,szToken[0],false);

  001e1	6a 00		 push	 0
  001e3	50		 push	 eax
  001e4	8d 85 08 f8 ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  001ea	bf 02 00 00 00	 mov	 edi, 2
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 ?SaveChatData@@YAXPADD_N@Z ; SaveChatData
  001f5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2798 : 			}
; 2799 : 		}

  001f8	eb 42		 jmp	 SHORT $LN7@lssproto_T
$LN19@lssproto_T:

; 2795 : 					break;
; 2796 : 				}
; 2797 : 				SaveChatData(msg,szToken[0],false);

  001fa	6a 00		 push	 0
  001fc	50		 push	 eax
  001fd	8d 85 08 f8 ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  00203	bf 04 00 00 00	 mov	 edi, 4
  00208	50		 push	 eax
  00209	e8 00 00 00 00	 call	 ?SaveChatData@@YAXPADD_N@Z ; SaveChatData
  0020e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2798 : 			}
; 2799 : 		}

  00211	eb 29		 jmp	 SHORT $LN7@lssproto_T
$LN20@lssproto_T:

; 2780 : 				
; 2781 : 				case 'M':
; 2782 : 					type = TYPE_TALK::ç§èŠ;  // å¯†è¯­é¢‘é“
; 2783 : 					break;
; 2784 : 				
; 2785 : 				case 'F':
; 2786 : 					type = TYPE_TALK::å®¶æ—;  // å®¶æ—é¢‘é“
; 2787 : 					break;
; 2788 : 			
; 2789 : 				case 'T':
; 2790 : 					type = TYPE_TALK::é˜Ÿä¼;  // é˜Ÿä¼é¢‘é“
; 2791 : 					break;	 
; 2792 : 
; 2793 : 				case 'O':
; 2794 : 					type = TYPE_TALK::ç³»ç»Ÿ;  // èŒä¸šé¢‘é“

  00213	33 ff		 xor	 edi, edi
$LN2@lssproto_T:

; 2795 : 					break;
; 2796 : 				}
; 2797 : 				SaveChatData(msg,szToken[0],false);

  00215	6a 00		 push	 0
  00217	50		 push	 eax
  00218	8d 85 08 f8 ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  0021e	50		 push	 eax
  0021f	e8 00 00 00 00	 call	 ?SaveChatData@@YAXPADD_N@Z ; SaveChatData
  00224	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2798 : 			}
; 2799 : 		}

  00227	eb 13		 jmp	 SHORT $LN7@lssproto_T
$LN6@lssproto_T:

; 2800 : 		else getStringToken(message,'|',2,sizeof(msg) - 1,msg);

  00229	6a 02		 push	 2
  0022b	6a 7c		 push	 124			; 0000007cH
  0022d	56		 push	 esi
  0022e	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00233	8b bd 00 f8 ff
	ff		 mov	 edi, DWORD PTR _type$[ebp]
  00239	83 c4 14	 add	 esp, 20			; 00000014H
$LN7@lssproto_T:

; 2801 : #ifdef _TALK_WINDOW
; 2802 : 		if (!g_bTalkWindow)
; 2803 : #endif
; 2804 : 		TradeTalk(msg);

  0023c	8d 85 08 f8 ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  00242	50		 push	 eax
  00243	e8 00 00 00 00	 call	 ?TradeTalk@@YAXPAD@Z	; TradeTalk
  00248	83 c4 04	 add	 esp, 4

; 2805 : 		if (strcmp(msg,"æˆç«‹èŠå¤©å®¤æ‰£é™¤ï¼’ï¼ï¼çŸ³å¸") == 0)	pc.gold -= 200;

  0024b	8d 85 08 f8 ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  00251	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BH@DFPJGLLL@?$OA?w?X?$KB?V?$PN?t?$LI?c?x?$DP?p?$LG?$KD?$LC?$KD?$LA?$KD?$LA?$OA?$LE?$DP@
$LL39@lssproto_T:
  00256	8a 10		 mov	 dl, BYTE PTR [eax]
  00258	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0025a	75 1a		 jne	 SHORT $LN40@lssproto_T
  0025c	84 d2		 test	 dl, dl
  0025e	74 12		 je	 SHORT $LN41@lssproto_T
  00260	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00263	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00266	75 0e		 jne	 SHORT $LN40@lssproto_T
  00268	83 c0 02	 add	 eax, 2
  0026b	83 c1 02	 add	 ecx, 2
  0026e	84 d2		 test	 dl, dl
  00270	75 e4		 jne	 SHORT $LL39@lssproto_T
$LN41@lssproto_T:
  00272	33 c0		 xor	 eax, eax
  00274	eb 05		 jmp	 SHORT $LN42@lssproto_T
$LN40@lssproto_T:
  00276	1b c0		 sbb	 eax, eax
  00278	83 c8 01	 or	 eax, 1
$LN42@lssproto_T:
  0027b	85 c0		 test	 eax, eax
  0027d	75 0a		 jne	 SHORT $LN21@lssproto_T
  0027f	81 2d 60 00 00
	00 c8 00 00 00	 sub	 DWORD PTR ?pc@@3UPC@@A+96, 200 ; 000000c8H
$LN21@lssproto_T:

; 2806 : #ifdef _FONT_SIZE
; 2807 : 
; 2808 : 		if (index == -1)type = TYPE_TALK::ç³»ç»Ÿ;
; 2809 : 
; 2810 : 
; 2811 : 		StockChatBufferLineExt( msg, color, fontsize, type);

  00289	33 c0		 xor	 eax, eax
  0028b	83 fb ff	 cmp	 ebx, -1
  0028e	0f 45 c7	 cmovne	 eax, edi
  00291	50		 push	 eax
  00292	ff b5 00 f8 ff
	ff		 push	 DWORD PTR _fontsize$3$[ebp]
  00298	8d 85 08 f8 ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  0029e	ff 75 14	 push	 DWORD PTR _color$[ebp]
  002a1	50		 push	 eax
  002a2	e8 00 00 00 00	 call	 ?StockChatBufferLineExt@@YAXPADEHH@Z ; StockChatBufferLineExt
  002a7	83 c4 10	 add	 esp, 16			; 00000010H

; 2812 : #else
; 2813 : 		StockChatBufferLine(msg,color);
; 2814 : #endif
; 2815 : #else
; 2816 : 	#ifdef _TELLCHANNEL		// (ä¸å¯å¼€) ROG ADD å¯†è¯­é¢‘é“
; 2817 : 		char tellName[128] = { "" };
; 2818 : 		char tmpMsg[STR_BUFFER_SIZE + 32];
; 2819 : 		char TK[4];
; 2820 : 
; 2821 : 		if ( getStringToken( msg, '|', 1, sizeof( TK ) - 1, TK ) == 0){
; 2822 : 			if (strcmp(TK,"TK") == 0)	InitSelectChar( msg, 0);
; 2823 : 			else if (strcmp(TK,"TE") == 0) InitSelectChar( msg, 1);
; 2824 : 		}
; 2825 : 		else{
; 2826 : 			char temp[] = "å‘Šè¯‰ä½ ï¼š";
; 2827 : 			char *found;
; 2828 : 
; 2829 : 			if (strcmp( msg, "æˆç«‹èŠå¤©å®¤æ‰£é™¤ï¼’ï¼ï¼çŸ³å¸") == 0)	pc.gold -= 200;
; 2830 : 
; 2831 : 			if ( found = strstr( msg, temp )){
; 2832 : 				strncpy(tellName, msg, strlen(msg) - strlen(found));
; 2833 : 				color = 5;
; 2834 : 				sprintf(tmpMsg,"[%s]%s",tellName, found);
; 2835 : 				StockChatBufferLine( tmpMsg, color );
; 2836 : 				sprintf(msg,"");
; 2837 : 				sprintf(secretName,"%s ",tellName);
; 2838 : 			}else StockChatBufferLine( msg, color );
; 2839 : 		}
; 2840 : 	#else
; 2841 : #ifdef _FONT_SIZE
; 2842 : 		StockChatBufferLineExt( msg, color, fontsize );
; 2843 : #else
; 2844 : 		StockChatBufferLine( msg, color );
; 2845 : #endif
; 2846 : #endif
; 2847 : #endif
; 2848 : 		if ( index >= 0 ){

  002aa	85 db		 test	 ebx, ebx
  002ac	78 4a		 js	 SHORT $LN43@lssproto_T

; 2849 : 			if ( pc.ptAct != NULL && pc.id == index ){

  002ae	83 3d ec 50 00
	00 00		 cmp	 DWORD PTR ?pc@@3UPC@@A+20716, 0
  002b5	74 26		 je	 SHORT $LN24@lssproto_T
  002b7	39 1d 08 00 00
	00		 cmp	 DWORD PTR ?pc@@3UPC@@A+8, ebx
  002bd	75 1e		 jne	 SHORT $LN24@lssproto_T

; 2850 : 				// JL æ³¨é‡Š è®¾ç½®è¯´è¯æ—¶æ°”æ³¡ä¿ç•™çš„æ—¶é—´î¸î•
; 2851 : 				setPcFukidashi( 1000 );  

  002bf	68 e8 03 00 00	 push	 1000			; 000003e8H
  002c4	e8 00 00 00 00	 call	 ?setPcFukidashi@@YAXI@Z	; setPcFukidashi
  002c9	83 c4 04	 add	 esp, 4
  002cc	5f		 pop	 edi
  002cd	5e		 pop	 esi

; 2860 : 				}
; 2861 : 			}
; 2862 : 		}
; 2863 : 	}
; 2864 : 
; 2865 : /*#if 0
; 2866 : 	if (index == my_id_in_server){
; 2867 : 		if (pinfo.ptaction != NULL){
; 2868 : 			createPlayerCommonEffect( pinfo.ptaction, SPR_fukidasi, 0, 1, -5 );
; 2869 : 		}
; 2870 : 	}else{
; 2871 : 		int goind = searchGameObjectIndex( index );
; 2872 : //		if ( goind >= 0 ||gameobj[goind].ptaction!=NULL){
; 2873 : 		if ( goind >= 0 && gameobj[goind].ptaction!=NULL ){
; 2874 : 			createPlayerCommonEffect( gameobj[goind].ptaction, SPR_fukidasi, 0, 1, -5 );
; 2875 : 		}
; 2876 : 	}
; 2877 : 
; 2878 : #ifdef DEBUGPUSH
; 2879 : 	if (color<249)PUSHVAR("îŸ‰?î‘‘?????????%d?'%s'",color, message); 
; 2880 : #endif
; 2881 : 	char id[2];
; 2882 :     char msg[2024];
; 2883 : 	getStringToken( message , '|' , 1 , sizeof( id ) - 1, id);
; 2884 : 	if (id[0] == 'P'){
; 2885 : 		getStringToken( message , '|' , 2 , sizeof( msg ) - 1, msg);
; 2886 : 		makeStringFromEscaped(msg);
; 2887 : 		char cutmes[1024];
; 2888 : 		int i, j;
; 2889 : 		for (i=0, j=0;;i++,j++){
; 2890 : 			cutmes[j] = msg[i];
; 2891 : 			if (msg[i] == '\0'){
; 2892 : 				chatinputPushString(cutmes, color);
; 2893 : 				break;
; 2894 : 			}
; 2895 : 			if ( IsDBCSTrailByte( msg, &msg[i+1] ) ){
; 2896 : 				continue;
; 2897 : 			}
; 2898 : 			cutmes[j+1]='\0';
; 2899 : 			if (GetStringWidth(cutmes)>600){
; 2900 : 				j = -1;
; 2901 : 				chatinputPushString(cutmes, color);
; 2902 : 			}
; 2903 : 		}
; 2904 : 	}else if (id[0] == 'D'){
; 2905 : 		int i;
; 2906 : 		selectwindowid = getIntegerToken(message, '|', 2);
; 2907 : 		void setDengonbanMessageNumber(int i);//netaction.cpp?î ´î•’
; 2908 : 		setDengonbanMessageNumber(getIntegerToken(message, '|', 3));
; 2909 : 		for (i=0;i<5;i++){
; 2910 : 			getStringToken( message , '|' , i+4 , sizeof( selectstringline[i] ) - 1, selectstringline[i]);
; 2911 : 			makeStringFromEscaped(selectstringline[i]);
; 2912 : 		}
; 2913 : 		cantclosewindowflag = 1;
; 2914 : 		OpenNPCWindow(NPC_BOARD_WINDOW);
; 2915 : 	}else if (id[0] == 'W'){
; 2916 : 		int i;
; 2917 : 		char token[1024];
; 2918 : 		getStringToken( message , '|' , 2 , sizeof( token ) - 1, token);
; 2919 : 		selectwindowid = atoi(token);
; 2920 : 		char mode[10];
; 2921 : 		getStringToken( message , '|' , 3 , sizeof( mode ) - 1, mode);
; 2922 : 		char caption[255];
; 2923 : 		int flag;
; 2924 : 		flag = getStringToken( message , '|' , 4 , sizeof( caption ) - 1, caption);
; 2925 : 		makeStringFromEscaped(caption);
; 2926 : 		strcpy(selectstringline[0],caption);
; 2927 : 		for (i=1;;i++){
; 2928 : 			selectstringlineindex[i] = getIntegerToken(message, '|', 3+i*2);
; 2929 : 			flag = getStringToken( message , '|' , 4+i*2 , sizeof( caption ) - 1, caption);
; 2930 : 			makeStringFromEscaped(caption);
; 2931 : 			strcpy(selectstringline[i],caption);
; 2932 : 			if (flag==1)break;
; 2933 : 		}
; 2934 : 		selectstringlinenumber=i;
; 2935 : 		cantclosewindowflag = 1;
; 2936 : 		if (mode[0] == 'G')OpenNPCWindow(NPC_KATARIBE_WINDOW);
; 2937 : 		else if (mode[0] == 'N')OpenNPCWindow(NPC_WINDOW);
; 2938 : 		else PUSHVAR("????????????????????????", msg);
; 2939 : 	}else if (id[0] == 'M'){
; 2940 : 		int i = 0, j = 0, k = 0;
; 2941 : 		if (strlen(message)>1024){
; 2942 : #ifdef DEBUGPUSH
; 2943 : 			PUSH("?????????????î—š?????");
; 2944 : #endif
; 2945 : 			return;
; 2946 : 		}
; 2947 : 		char token[1024];
; 2948 : 		getStringToken( message , '|' , 2 , sizeof( token ) - 1, token);
; 2949 : 		selectwindowid = atoi(token);
; 2950 : 		char mode[10];
; 2951 : 		getStringToken( message , '|' , 3 , sizeof( mode ) - 1, mode);
; 2952 : 		char caption[1024], onelinestring[1024];
; 2953 : 		getStringToken( message , '|' , 4 , sizeof( caption ) - 1, caption);
; 2954 : 		makeStringFromEscaped(caption);
; 2955 : 		for (i=0;;i++){
; 2956 : 			if (caption[i] == '\n'){
; 2957 : 				onelinestring[k] = '\0';
; 2958 : 				memcpy(selectstringline[j], onelinestring, k+1);
; 2959 : 				j++;
; 2960 : 				k = 0;
; 2961 : 			}else if (caption[i] == '\0'){
; 2962 : 				onelinestring[k] = '\0';
; 2963 : 				memcpy(selectstringline[j], onelinestring, k+1);
; 2964 : 				j++;
; 2965 : 				break;
; 2966 : 			}else{
; 2967 : 				onelinestring[k] = caption[i];
; 2968 : 				k++;
; 2969 : 			}
; 2970 : 		}
; 2971 : 		selectstringlinenumber=j;
; 2972 : 		if (mode[0] == 'G')OpenNPCWindow(NPC_G_MESSAGE_WINDOW);
; 2973 : 		else if (mode[0] == 'N')OpenNPCWindow(NPC_MESSAGE_WINDOW);
; 2974 : 		else PUSHVAR("????????????????????????", msg);
; 2975 : 	}else if (id[0] == 'S'){
; 2976 : 		int i;
; 2977 : #if 1
; 2978 : 		// î˜º?????????????????
; 2979 : 		for ( i = 0; i < MAXSHOPITEM; i++ )
; 2980 : 		{
; 2981 : 			shopitem[i].plice = 0;
; 2982 : 			shopitem[i].stock = 0;
; 2983 : 			shopitem[i].itm.name[0] = '\0';
; 2984 : 			shopitem[i].itm.name2[0] = '\0';
; 2985 : 			shopitem[i].itm.memo[0] = '\0';
; 2986 : 			shopitem[i].itm.stage = 0;
; 2987 : 			shopitem[i].itm.imgno = 0;
; 2988 : 		}
; 2989 : #endif
; 2990 : 		selectwindowid = getIntegerToken( message , '|' , 2 );	
; 2991 : 		for (i=0;i<7;i++){
; 2992 : 			getStringToken( message , '|' , 3+i , sizeof( shopmessage[i] ) - 1, shopmessage[i] );
; 2993 : 			makeStringFromEscaped(shopmessage[i]);
; 2994 : 		}
; 2995 : 		shopgold = getIntegerToken( message , '|' , 10 );
; 2996 : 		shopstock = getIntegerToken(message, '|', 11 );
; 2997 : 		for (i=0;i<shopstock;i++){
; 2998 : 			getStringToken( message , '|' , 12+i*5, sizeof(shopitem[i].itm.name) - 1, shopitem[i].itm.name);
; 2999 : 			makeStringFromEscaped(shopitem[i].itm.name);
; 3000 : 			if (strlen(shopitem[i].itm.name)==0)break;
; 3001 : 			shopitem[i].plice = getIntegerToken( message , '|' , 13+i*5);
; 3002 : 			shopitem[i].itm.stage = getIntegerToken( message , '|' , 14+i*5);
; 3003 : 			if (shopitem[i].itm.stage<0)shopitem[i].itm.stage=0;
; 3004 : 			shopitem[i].itm.imgno = getIntegerToken( message , '|' , 15+i*5);
; 3005 : 			getStringToken( message , '|' , 16+i*5, sizeof(shopitem[i].itm.memo) - 1, shopitem[i].itm.memo);
; 3006 : 			makeStringFromEscaped(shopitem[i].itm.memo);
; 3007 : 			shopitem[i].stock = 1;
; 3008 : 		}
; 3009 : 		for (i=0;i<40;i++){
; 3010 : 			charitemplice[i] = getIntegerToken(message, '|', 12+shopstock*5+i);
; 3011 : 		}
; 3012 : 		void setShoppage(int i);//layout.cpp
; 3013 : 		setShoppage (0);
; 3014 : 		OpenNPCWindow(NPC_SHOP_START_WINDOW);
; 3015 : 		cantclosewindowflag = 1;
; 3016 : 		PUSHVAR( "??????? '%s'??????????" , msg );
; 3017 : 	}else if (id[0] == 'L'){//???
; 3018 : 		getStringToken( message , '|' , 2 , sizeof( selectstringline[0] ) - 1, selectstringline[0] );
; 3019 : 			makeStringFromEscaped(selectstringline[0]);
; 3020 : 		getStringToken( message , '|' , 3 , sizeof( selectstringline[1] ) - 1, selectstringline[1] );
; 3021 : 			makeStringFromEscaped(selectstringline[1]);
; 3022 : 		selectstringlineindex[1] = SYSTEM_CHARLOST;
; 3023 : 		selectstringlinenumber=1;
; 3024 : 		cantclosewindowflag = 1;
; 3025 : 		OpenSystemWindow();
; 3026 : 	}else if (id[0] == 'K'){
; 3027 : 		void setSystemMessage(int i, char *mes, int index);//layout.cpp
; 3028 : 		int i;
; 3029 : 		char token[1024];
; 3030 : 		getStringToken( message , '|' , 2 , sizeof( token ) - 1, token);
; 3031 : 		selectwindowid = atoi(token);
; 3032 : 		char caption[255];
; 3033 : 		int flag;
; 3034 : 		int index;
; 3035 : 		flag = getStringToken( message , '|' , 3 , sizeof( caption ) - 1, caption);
; 3036 : 		makeStringFromEscaped(caption);
; 3037 : 		strcpy(selectstringline[0],caption);
; 3038 : 		setSystemMessage( 0, caption, SYSTEM_SYSTEM);
; 3039 : 		for (i=1;;i++){
; 3040 : 			flag = getStringToken( message , '|' , i+3 , sizeof( caption ) - 1, caption);
; 3041 : 			makeStringFromEscaped(caption);
; 3042 : 			strcpy(selectstringline[i],caption);
; 3043 : 			if (strcmp(selectstringline[i],"?????")==0){
; 3044 : 				index = SYSTEM_LOGOUT;
; 3045 : 			}else{
; 3046 : 				index = SYSTEM_SERVERPUSH_1+i-1;
; 3047 : 			}
; 3048 : 			selectstringlineindex[i]=index;
; 3049 : 			setSystemMessage( i, caption, index);
; 3050 : 			if (flag==1)break;
; 3051 : 		}
; 3052 : 		selectstringlinenumber=i;
; 3053 : 		deadflag = 1;
; 3054 : 		OpenSystemWindow();
; 3055 : //		OpenNPCWindow(NPC_WINDOW);
; 3056 : 		PUSH("TK?????????");
; 3057 : 	}else if (id[0] == 'R'){
; 3058 : 		deadflag = 0;
; 3059 : 	}else{
; 3060 : 		PUSH("TK????????????");
; 3061 : 	}
; 3062 : 
; 3063 : #endif
; 3064 : 	*/
; 3065 : }

  002ce	5b		 pop	 ebx
  002cf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d2	33 cd		 xor	 ecx, ebp
  002d4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d9	8b e5		 mov	 esp, ebp
  002db	5d		 pop	 ebp
  002dc	c3		 ret	 0
$LN24@lssproto_T:

; 2852 : 			}
; 2853 : 			else
; 2854 : 			{
; 2855 : 				ptAct = getCharObjAct( index );

  002dd	53		 push	 ebx
  002de	e8 00 00 00 00	 call	 ?getCharObjAct@@YAPAUaction@@H@Z ; getCharObjAct
  002e3	83 c4 04	 add	 esp, 4

; 2856 : 				if ( ptAct != NULL )

  002e6	85 c0		 test	 eax, eax
  002e8	74 0e		 je	 SHORT $LN43@lssproto_T

; 2857 : 				{
; 2858 : 					// 1000??î¾î¸î•
; 2859 : 					setCharFukidashi( ptAct, 1000 );

  002ea	68 e8 03 00 00	 push	 1000			; 000003e8H
  002ef	50		 push	 eax
  002f0	e8 00 00 00 00	 call	 ?setCharFukidashi@@YAXPAUaction@@I@Z ; setCharFukidashi
  002f5	83 c4 08	 add	 esp, 8
$LN43@lssproto_T:
  002f8	5f		 pop	 edi
$LN26@lssproto_T:

; 2860 : 				}
; 2861 : 			}
; 2862 : 		}
; 2863 : 	}
; 2864 : 
; 2865 : /*#if 0
; 2866 : 	if (index == my_id_in_server){
; 2867 : 		if (pinfo.ptaction != NULL){
; 2868 : 			createPlayerCommonEffect( pinfo.ptaction, SPR_fukidasi, 0, 1, -5 );
; 2869 : 		}
; 2870 : 	}else{
; 2871 : 		int goind = searchGameObjectIndex( index );
; 2872 : //		if ( goind >= 0 ||gameobj[goind].ptaction!=NULL){
; 2873 : 		if ( goind >= 0 && gameobj[goind].ptaction!=NULL ){
; 2874 : 			createPlayerCommonEffect( gameobj[goind].ptaction, SPR_fukidasi, 0, 1, -5 );
; 2875 : 		}
; 2876 : 	}
; 2877 : 
; 2878 : #ifdef DEBUGPUSH
; 2879 : 	if (color<249)PUSHVAR("îŸ‰?î‘‘?????????%d?'%s'",color, message); 
; 2880 : #endif
; 2881 : 	char id[2];
; 2882 :     char msg[2024];
; 2883 : 	getStringToken( message , '|' , 1 , sizeof( id ) - 1, id);
; 2884 : 	if (id[0] == 'P'){
; 2885 : 		getStringToken( message , '|' , 2 , sizeof( msg ) - 1, msg);
; 2886 : 		makeStringFromEscaped(msg);
; 2887 : 		char cutmes[1024];
; 2888 : 		int i, j;
; 2889 : 		for (i=0, j=0;;i++,j++){
; 2890 : 			cutmes[j] = msg[i];
; 2891 : 			if (msg[i] == '\0'){
; 2892 : 				chatinputPushString(cutmes, color);
; 2893 : 				break;
; 2894 : 			}
; 2895 : 			if ( IsDBCSTrailByte( msg, &msg[i+1] ) ){
; 2896 : 				continue;
; 2897 : 			}
; 2898 : 			cutmes[j+1]='\0';
; 2899 : 			if (GetStringWidth(cutmes)>600){
; 2900 : 				j = -1;
; 2901 : 				chatinputPushString(cutmes, color);
; 2902 : 			}
; 2903 : 		}
; 2904 : 	}else if (id[0] == 'D'){
; 2905 : 		int i;
; 2906 : 		selectwindowid = getIntegerToken(message, '|', 2);
; 2907 : 		void setDengonbanMessageNumber(int i);//netaction.cpp?î ´î•’
; 2908 : 		setDengonbanMessageNumber(getIntegerToken(message, '|', 3));
; 2909 : 		for (i=0;i<5;i++){
; 2910 : 			getStringToken( message , '|' , i+4 , sizeof( selectstringline[i] ) - 1, selectstringline[i]);
; 2911 : 			makeStringFromEscaped(selectstringline[i]);
; 2912 : 		}
; 2913 : 		cantclosewindowflag = 1;
; 2914 : 		OpenNPCWindow(NPC_BOARD_WINDOW);
; 2915 : 	}else if (id[0] == 'W'){
; 2916 : 		int i;
; 2917 : 		char token[1024];
; 2918 : 		getStringToken( message , '|' , 2 , sizeof( token ) - 1, token);
; 2919 : 		selectwindowid = atoi(token);
; 2920 : 		char mode[10];
; 2921 : 		getStringToken( message , '|' , 3 , sizeof( mode ) - 1, mode);
; 2922 : 		char caption[255];
; 2923 : 		int flag;
; 2924 : 		flag = getStringToken( message , '|' , 4 , sizeof( caption ) - 1, caption);
; 2925 : 		makeStringFromEscaped(caption);
; 2926 : 		strcpy(selectstringline[0],caption);
; 2927 : 		for (i=1;;i++){
; 2928 : 			selectstringlineindex[i] = getIntegerToken(message, '|', 3+i*2);
; 2929 : 			flag = getStringToken( message , '|' , 4+i*2 , sizeof( caption ) - 1, caption);
; 2930 : 			makeStringFromEscaped(caption);
; 2931 : 			strcpy(selectstringline[i],caption);
; 2932 : 			if (flag==1)break;
; 2933 : 		}
; 2934 : 		selectstringlinenumber=i;
; 2935 : 		cantclosewindowflag = 1;
; 2936 : 		if (mode[0] == 'G')OpenNPCWindow(NPC_KATARIBE_WINDOW);
; 2937 : 		else if (mode[0] == 'N')OpenNPCWindow(NPC_WINDOW);
; 2938 : 		else PUSHVAR("????????????????????????", msg);
; 2939 : 	}else if (id[0] == 'M'){
; 2940 : 		int i = 0, j = 0, k = 0;
; 2941 : 		if (strlen(message)>1024){
; 2942 : #ifdef DEBUGPUSH
; 2943 : 			PUSH("?????????????î—š?????");
; 2944 : #endif
; 2945 : 			return;
; 2946 : 		}
; 2947 : 		char token[1024];
; 2948 : 		getStringToken( message , '|' , 2 , sizeof( token ) - 1, token);
; 2949 : 		selectwindowid = atoi(token);
; 2950 : 		char mode[10];
; 2951 : 		getStringToken( message , '|' , 3 , sizeof( mode ) - 1, mode);
; 2952 : 		char caption[1024], onelinestring[1024];
; 2953 : 		getStringToken( message , '|' , 4 , sizeof( caption ) - 1, caption);
; 2954 : 		makeStringFromEscaped(caption);
; 2955 : 		for (i=0;;i++){
; 2956 : 			if (caption[i] == '\n'){
; 2957 : 				onelinestring[k] = '\0';
; 2958 : 				memcpy(selectstringline[j], onelinestring, k+1);
; 2959 : 				j++;
; 2960 : 				k = 0;
; 2961 : 			}else if (caption[i] == '\0'){
; 2962 : 				onelinestring[k] = '\0';
; 2963 : 				memcpy(selectstringline[j], onelinestring, k+1);
; 2964 : 				j++;
; 2965 : 				break;
; 2966 : 			}else{
; 2967 : 				onelinestring[k] = caption[i];
; 2968 : 				k++;
; 2969 : 			}
; 2970 : 		}
; 2971 : 		selectstringlinenumber=j;
; 2972 : 		if (mode[0] == 'G')OpenNPCWindow(NPC_G_MESSAGE_WINDOW);
; 2973 : 		else if (mode[0] == 'N')OpenNPCWindow(NPC_MESSAGE_WINDOW);
; 2974 : 		else PUSHVAR("????????????????????????", msg);
; 2975 : 	}else if (id[0] == 'S'){
; 2976 : 		int i;
; 2977 : #if 1
; 2978 : 		// î˜º?????????????????
; 2979 : 		for ( i = 0; i < MAXSHOPITEM; i++ )
; 2980 : 		{
; 2981 : 			shopitem[i].plice = 0;
; 2982 : 			shopitem[i].stock = 0;
; 2983 : 			shopitem[i].itm.name[0] = '\0';
; 2984 : 			shopitem[i].itm.name2[0] = '\0';
; 2985 : 			shopitem[i].itm.memo[0] = '\0';
; 2986 : 			shopitem[i].itm.stage = 0;
; 2987 : 			shopitem[i].itm.imgno = 0;
; 2988 : 		}
; 2989 : #endif
; 2990 : 		selectwindowid = getIntegerToken( message , '|' , 2 );	
; 2991 : 		for (i=0;i<7;i++){
; 2992 : 			getStringToken( message , '|' , 3+i , sizeof( shopmessage[i] ) - 1, shopmessage[i] );
; 2993 : 			makeStringFromEscaped(shopmessage[i]);
; 2994 : 		}
; 2995 : 		shopgold = getIntegerToken( message , '|' , 10 );
; 2996 : 		shopstock = getIntegerToken(message, '|', 11 );
; 2997 : 		for (i=0;i<shopstock;i++){
; 2998 : 			getStringToken( message , '|' , 12+i*5, sizeof(shopitem[i].itm.name) - 1, shopitem[i].itm.name);
; 2999 : 			makeStringFromEscaped(shopitem[i].itm.name);
; 3000 : 			if (strlen(shopitem[i].itm.name)==0)break;
; 3001 : 			shopitem[i].plice = getIntegerToken( message , '|' , 13+i*5);
; 3002 : 			shopitem[i].itm.stage = getIntegerToken( message , '|' , 14+i*5);
; 3003 : 			if (shopitem[i].itm.stage<0)shopitem[i].itm.stage=0;
; 3004 : 			shopitem[i].itm.imgno = getIntegerToken( message , '|' , 15+i*5);
; 3005 : 			getStringToken( message , '|' , 16+i*5, sizeof(shopitem[i].itm.memo) - 1, shopitem[i].itm.memo);
; 3006 : 			makeStringFromEscaped(shopitem[i].itm.memo);
; 3007 : 			shopitem[i].stock = 1;
; 3008 : 		}
; 3009 : 		for (i=0;i<40;i++){
; 3010 : 			charitemplice[i] = getIntegerToken(message, '|', 12+shopstock*5+i);
; 3011 : 		}
; 3012 : 		void setShoppage(int i);//layout.cpp
; 3013 : 		setShoppage (0);
; 3014 : 		OpenNPCWindow(NPC_SHOP_START_WINDOW);
; 3015 : 		cantclosewindowflag = 1;
; 3016 : 		PUSHVAR( "??????? '%s'??????????" , msg );
; 3017 : 	}else if (id[0] == 'L'){//???
; 3018 : 		getStringToken( message , '|' , 2 , sizeof( selectstringline[0] ) - 1, selectstringline[0] );
; 3019 : 			makeStringFromEscaped(selectstringline[0]);
; 3020 : 		getStringToken( message , '|' , 3 , sizeof( selectstringline[1] ) - 1, selectstringline[1] );
; 3021 : 			makeStringFromEscaped(selectstringline[1]);
; 3022 : 		selectstringlineindex[1] = SYSTEM_CHARLOST;
; 3023 : 		selectstringlinenumber=1;
; 3024 : 		cantclosewindowflag = 1;
; 3025 : 		OpenSystemWindow();
; 3026 : 	}else if (id[0] == 'K'){
; 3027 : 		void setSystemMessage(int i, char *mes, int index);//layout.cpp
; 3028 : 		int i;
; 3029 : 		char token[1024];
; 3030 : 		getStringToken( message , '|' , 2 , sizeof( token ) - 1, token);
; 3031 : 		selectwindowid = atoi(token);
; 3032 : 		char caption[255];
; 3033 : 		int flag;
; 3034 : 		int index;
; 3035 : 		flag = getStringToken( message , '|' , 3 , sizeof( caption ) - 1, caption);
; 3036 : 		makeStringFromEscaped(caption);
; 3037 : 		strcpy(selectstringline[0],caption);
; 3038 : 		setSystemMessage( 0, caption, SYSTEM_SYSTEM);
; 3039 : 		for (i=1;;i++){
; 3040 : 			flag = getStringToken( message , '|' , i+3 , sizeof( caption ) - 1, caption);
; 3041 : 			makeStringFromEscaped(caption);
; 3042 : 			strcpy(selectstringline[i],caption);
; 3043 : 			if (strcmp(selectstringline[i],"?????")==0){
; 3044 : 				index = SYSTEM_LOGOUT;
; 3045 : 			}else{
; 3046 : 				index = SYSTEM_SERVERPUSH_1+i-1;
; 3047 : 			}
; 3048 : 			selectstringlineindex[i]=index;
; 3049 : 			setSystemMessage( i, caption, index);
; 3050 : 			if (flag==1)break;
; 3051 : 		}
; 3052 : 		selectstringlinenumber=i;
; 3053 : 		deadflag = 1;
; 3054 : 		OpenSystemWindow();
; 3055 : //		OpenNPCWindow(NPC_WINDOW);
; 3056 : 		PUSH("TK?????????");
; 3057 : 	}else if (id[0] == 'R'){
; 3058 : 		deadflag = 0;
; 3059 : 	}else{
; 3060 : 		PUSH("TK????????????");
; 3061 : 	}
; 3062 : 
; 3063 : #endif
; 3064 : 	*/
; 3065 : }

  002f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002fc	5e		 pop	 esi
  002fd	33 cd		 xor	 ecx, ebp
  002ff	5b		 pop	 ebx
  00300	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00305	8b e5		 mov	 esp, ebp
  00307	5d		 pop	 ebp
  00308	c3		 ret	 0
  00309	0f 1f 00	 npad	 3
$LN38@lssproto_T:
  0030c	00 00 00 00	 DD	 $LN18@lssproto_T
  00310	00 00 00 00	 DD	 $LN17@lssproto_T
  00314	00 00 00 00	 DD	 $LN20@lssproto_T
  00318	00 00 00 00	 DD	 $LN19@lssproto_T
  0031c	00 00 00 00	 DD	 $LN2@lssproto_T
$LN37@lssproto_T:
  00320	00		 DB	 0
  00321	04		 DB	 4
  00322	04		 DB	 4
  00323	04		 DB	 4
  00324	04		 DB	 4
  00325	04		 DB	 4
  00326	04		 DB	 4
  00327	01		 DB	 1
  00328	04		 DB	 4
  00329	02		 DB	 2
  0032a	04		 DB	 4
  0032b	04		 DB	 4
  0032c	04		 DB	 4
  0032d	04		 DB	 4
  0032e	03		 DB	 3
?lssproto_TK_recv@@YAXHHPADH@Z ENDP			; lssproto_TK_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_ABI_recv@@YAXHHPAD@Z
_TEXT	SEGMENT
_name$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_num$ = 12						; size = 4
_data$ = 16						; size = 4
?lssproto_ABI_recv@@YAXHHPAD@Z PROC			; lssproto_ABI_recv, COMDAT

; 3376 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3377 : 	char name[256];
; 3378 : 	int nameLen;
; 3379 : 	int useFlag;
; 3380 : #ifdef _MAILSHOWPLANET				// (å¯å¼€æ”¾) Syu ADD æ˜¾ç¤ºåç‰‡æ˜Ÿçƒ
; 3381 : 	char planetid[8];
; 3382 : 	int j ;
; 3383 : #endif
; 3384 : 
; 3385 : 	// ????????????????îºîŸ«?î¡Š???
; 3386 : 	if ( logOutFlag )

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  0001a	56		 push	 esi
  0001b	8b 75 0c	 mov	 esi, DWORD PTR _num$[ebp]
  0001e	57		 push	 edi
  0001f	8b 7d 10	 mov	 edi, DWORD PTR _data$[ebp]
  00022	0f 85 8c 01 00
	00		 jne	 $LN10@lssproto_A

; 3387 : 		return;
; 3388 : 
; 3389 : 	useFlag = getIntegerToken(data, '|', 1 );

  00028	6a 01		 push	 1
  0002a	6a 7c		 push	 124			; 0000007cH
  0002c	57		 push	 edi
  0002d	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3390 : 	if ( useFlag == -1 )

  00035	83 f8 ff	 cmp	 eax, -1
  00038	0f 84 29 01 00
	00		 je	 $LN16@lssproto_A

; 3391 : 	{
; 3392 : 		useFlag = 0;
; 3393 : 	}
; 3394 : 	if ( useFlag == 0 )

  0003e	85 c0		 test	 eax, eax
  00040	0f 84 21 01 00
	00		 je	 $LN16@lssproto_A

; 3411 : 		return;
; 3412 : 	}
; 3413 : 
; 3414 : #ifdef _EXTEND_AB
; 3415 : 	if ( num == MAX_ADR_BOOK-1 )

  00046	53		 push	 ebx
  00047	6b de 68	 imul	 ebx, esi, 104

; 3416 : 		addressBook[num].useFlag = useFlag;

  0004a	0f b7 c0	 movzx	 eax, ax
  0004d	83 fe 4f	 cmp	 esi, 79			; 0000004fH
  00050	74 05		 je	 SHORT $LN7@lssproto_A

; 3417 : 	else
; 3418 : 		addressBook[num].useFlag = 1;

  00052	b8 01 00 00 00	 mov	 eax, 1
$LN7@lssproto_A:

; 3419 : #else
; 3420 : 	addressBook[num].useFlag = useFlag;
; 3421 : #endif
; 3422 : 
; 3423 : 	getStringToken(data, '|', 2, sizeof(name) - 1 , name );

  00057	66 89 83 00 00
	00 00		 mov	 WORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[ebx], ax
  0005e	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  00064	50		 push	 eax
  00065	68 ff 00 00 00	 push	 255			; 000000ffH
  0006a	6a 02		 push	 2
  0006c	6a 7c		 push	 124			; 0000007cH
  0006e	57		 push	 edi
  0006f	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 3424 : 	makeStringFromEscaped(name);

  00074	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 3425 : 	nameLen = strlen(name);

  00080	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _name$[ebp]
  00086	83 c4 18	 add	 esp, 24			; 00000018H
  00089	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0008c	0f 1f 40 00	 npad	 4
$LL17@lssproto_A:
  00090	8a 01		 mov	 al, BYTE PTR [ecx]
  00092	41		 inc	 ecx
  00093	84 c0		 test	 al, al
  00095	75 f9		 jne	 SHORT $LL17@lssproto_A
  00097	2b ca		 sub	 ecx, edx

; 3426 : 	if ( 0 < nameLen && nameLen <= CHAR_NAME_LEN )

  00099	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  0009c	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0009f	77 1f		 ja	 SHORT $LN8@lssproto_A

; 3427 : 	{
; 3428 : 		strcpy( addressBook[num].name, name );

  000a1	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _name$[ebp]
  000a7	8b c1		 mov	 eax, ecx
  000a9	2b d8		 sub	 ebx, eax
  000ab	0f 1f 44 00 00	 npad	 5
$LL12@lssproto_A:
  000b0	8a 01		 mov	 al, BYTE PTR [ecx]
  000b2	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  000b5	88 84 0b 13 00
	00 00		 mov	 BYTE PTR ?addressBook@@3PAUADDRESS_BOOK@@A[ebx+ecx+19], al
  000bc	84 c0		 test	 al, al
  000be	75 f0		 jne	 SHORT $LL12@lssproto_A
$LN8@lssproto_A:

; 3429 : 	}
; 3430 : 	addressBook[num].level = getIntegerToken(data, '|', 3 );

  000c0	6a 03		 push	 3
  000c2	6a 7c		 push	 124			; 0000007cH
  000c4	57		 push	 edi
  000c5	6b f6 68	 imul	 esi, esi, 104
  000c8	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 3431 : 	addressBook[num].dp = getIntegerToken(data, '|', 4 );

  000cd	6a 04		 push	 4
  000cf	6a 7c		 push	 124			; 0000007cH
  000d1	57		 push	 edi
  000d2	89 86 04 00 00
	00		 mov	 DWORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[esi+4], eax
  000d8	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 3432 : 	addressBook[num].onlineFlag = (short)getIntegerToken(data, '|', 5 );

  000dd	6a 05		 push	 5
  000df	6a 7c		 push	 124			; 0000007cH
  000e1	57		 push	 edi
  000e2	89 86 0c 00 00
	00		 mov	 DWORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[esi+12], eax
  000e8	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 3433 : 	addressBook[num].graNo = getIntegerToken(data, '|', 6 );

  000ed	6a 06		 push	 6
  000ef	6a 7c		 push	 124			; 0000007cH
  000f1	57		 push	 edi
  000f2	66 89 86 02 00
	00 00		 mov	 WORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[esi+2], ax
  000f9	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 3434 : 	addressBook[num].transmigration = getIntegerToken(data, '|', 7 );

  000fe	6a 07		 push	 7
  00100	6a 7c		 push	 124			; 0000007cH
  00102	57		 push	 edi
  00103	89 86 10 00 00
	00		 mov	 DWORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[esi+16], eax
  00109	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0010e	83 c4 3c	 add	 esp, 60			; 0000003cH
  00111	66 89 86 08 00
	00 00		 mov	 WORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[esi+8], ax

; 3435 : #ifdef ä¿®å¤é‚®ä»¶æœåŠ¡å™¨æ˜¾ç¤º				// (å¯å¼€æ”¾) Syu ADD æ˜¾ç¤ºåç‰‡æ˜Ÿçƒ
; 3436 : 	if ( addressBook[num].onlineFlag == 0 ) 

  00118	66 83 be 02 00
	00 00 00	 cmp	 WORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[esi+2], 0
  00120	8d 86 25 00 00
	00		 lea	 eax, DWORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[esi+37]
  00126	5b		 pop	 ebx
  00127	75 1e		 jne	 SHORT $LN9@lssproto_A

; 3437 : 		sprintf( addressBook[num].planetname , " ");

  00129	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 _sprintf
  00134	83 c4 08	 add	 esp, 8
  00137	5f		 pop	 edi

; 3440 : 	//for ( j = 0 ; j < MAX_GMSV ; j ++ ) {
; 3441 : 	//	if ( gmsv[j].used == '1' ) {
; 3442 : 	//		getStringToken( gmsv[j].ipaddr, '.', 4, sizeof( planetid ) -1, planetid );
; 3443 : 	//		if ( addressBook[num].onlineFlag == atoi(planetid) ) {
; 3444 : 	//			sprintf ( addressBook[num].planetname , "%s" , gmsv[j].name ) ; 
; 3445 : 	//			break;
; 3446 : 	//		}
; 3447 : 	//	}
; 3448 : 	//}
; 3449 : #endif
; 3450 : 
; 3451 : 
; 3452 : }

  00138	5e		 pop	 esi
  00139	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013c	33 cd		 xor	 ecx, ebp
  0013e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00143	8b e5		 mov	 esp, ebp
  00145	5d		 pop	 ebp
  00146	c3		 ret	 0
$LN9@lssproto_A:

; 3438 : 	else
; 3439 : 		getStringToken(data, '|',  8, 12, addressBook[num].planetname);

  00147	50		 push	 eax
  00148	6a 0c		 push	 12			; 0000000cH
  0014a	6a 08		 push	 8
  0014c	6a 7c		 push	 124			; 0000007cH
  0014e	57		 push	 edi
  0014f	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00154	83 c4 14	 add	 esp, 20			; 00000014H
  00157	5f		 pop	 edi

; 3440 : 	//for ( j = 0 ; j < MAX_GMSV ; j ++ ) {
; 3441 : 	//	if ( gmsv[j].used == '1' ) {
; 3442 : 	//		getStringToken( gmsv[j].ipaddr, '.', 4, sizeof( planetid ) -1, planetid );
; 3443 : 	//		if ( addressBook[num].onlineFlag == atoi(planetid) ) {
; 3444 : 	//			sprintf ( addressBook[num].planetname , "%s" , gmsv[j].name ) ; 
; 3445 : 	//			break;
; 3446 : 	//		}
; 3447 : 	//	}
; 3448 : 	//}
; 3449 : #endif
; 3450 : 
; 3451 : 
; 3452 : }

  00158	5e		 pop	 esi
  00159	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015c	33 cd		 xor	 ecx, ebp
  0015e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00163	8b e5		 mov	 esp, ebp
  00165	5d		 pop	 ebp
  00166	c3		 ret	 0
$LN16@lssproto_A:

; 3395 : 	{
; 3396 : #if 0
; 3397 : 		if ( addressBook[num].useFlag == 1 )
; 3398 : #else
; 3399 : 		if ( MailHistory[num].dateStr[MAIL_MAX_HISTORY-1][0] != '\0' )

  00167	69 c6 f0 0e 00
	00		 imul	 eax, esi, 3824
  0016d	80 b8 93 0c 00
	00 00		 cmp	 BYTE PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[eax+3219], 0
  00174	74 2c		 je	 SHORT $LN5@lssproto_A

; 3400 : #endif
; 3401 : 		{
; 3402 : 			memset( &MailHistory[num], 0, sizeof( MailHistory[0] ) ) ;

  00176	68 f0 0e 00 00	 push	 3824			; 00000ef0H
  0017b	8d 80 00 00 00
	00		 lea	 eax, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[eax]
  00181	6a 00		 push	 0
  00183	50		 push	 eax
  00184	e8 00 00 00 00	 call	 _memset

; 3403 : 			SaveMailHistory( num );

  00189	56		 push	 esi
  0018a	e8 00 00 00 00	 call	 ?SaveMailHistory@@YAHH@Z ; SaveMailHistory
  0018f	83 c4 10	 add	 esp, 16			; 00000010H

; 3404 : 			// î ¹îš‡????
; 3405 : 			mailLamp = CheckMailNoReadFlag();

  00192	e8 00 00 00 00	 call	 ?CheckMailNoReadFlag@@YAHXZ ; CheckMailNoReadFlag
  00197	66 a3 00 00 00
	00		 mov	 WORD PTR ?mailLamp@@3FA, ax ; mailLamp

; 3406 : 			// îŽ—????î?
; 3407 : 			DeathLetterAction();

  0019d	e8 00 00 00 00	 call	 ?DeathLetterAction@@YAXXZ ; DeathLetterAction
$LN5@lssproto_A:

; 3408 : 		}
; 3409 : 		addressBook[num].useFlag = useFlag;

  001a2	6b c6 68	 imul	 eax, esi, 104
  001a5	33 c9		 xor	 ecx, ecx
  001a7	66 89 88 00 00
	00 00		 mov	 WORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[eax], cx

; 3410 : 		addressBook[num].name[0] = '\0';

  001ae	88 88 14 00 00
	00		 mov	 BYTE PTR ?addressBook@@3PAUADDRESS_BOOK@@A[eax+20], cl
$LN10@lssproto_A:

; 3440 : 	//for ( j = 0 ; j < MAX_GMSV ; j ++ ) {
; 3441 : 	//	if ( gmsv[j].used == '1' ) {
; 3442 : 	//		getStringToken( gmsv[j].ipaddr, '.', 4, sizeof( planetid ) -1, planetid );
; 3443 : 	//		if ( addressBook[num].onlineFlag == atoi(planetid) ) {
; 3444 : 	//			sprintf ( addressBook[num].planetname , "%s" , gmsv[j].name ) ; 
; 3445 : 	//			break;
; 3446 : 	//		}
; 3447 : 	//	}
; 3448 : 	//}
; 3449 : #endif
; 3450 : 
; 3451 : 
; 3452 : }

  001b4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b7	5f		 pop	 edi
  001b8	33 cd		 xor	 ecx, ebp
  001ba	5e		 pop	 esi
  001bb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c0	8b e5		 mov	 esp, ebp
  001c2	5d		 pop	 ebp
  001c3	c3		 ret	 0
?lssproto_ABI_recv@@YAXHHPAD@Z ENDP			; lssproto_ABI_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_AB_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_name$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_AB_recv@@YAXHPAD@Z PROC			; lssproto_AB_recv, COMDAT

; 3277 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3278 : 	int i;
; 3279 : 	int no;
; 3280 : 	int nameLen;
; 3281 : 	char name[256];
; 3282 : 	int flag;
; 3283 : 	int useFlag;
; 3284 : #ifdef _MAILSHOWPLANET				// (å¯å¼€æ”¾) Syu ADD æ˜¾ç¤ºåç‰‡æ˜Ÿçƒ
; 3285 : 	char planetid[8];
; 3286 : 	int j ;
; 3287 : #endif
; 3288 : 	// ????????????????îºîŸ«?î¡Š???
; 3289 : 	if ( logOutFlag )

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  0001a	53		 push	 ebx
  0001b	8b 5d 0c	 mov	 ebx, DWORD PTR _data$[ebp]
  0001e	0f 85 b0 01 00
	00		 jne	 $LN26@lssproto_A

; 3290 : 		return;
; 3291 : 
; 3292 : 	for ( i = 0; i < MAX_ADR_BOOK; i++ )

  00024	56		 push	 esi
  00025	33 f6		 xor	 esi, esi
  00027	57		 push	 edi
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@lssproto_A:

; 3293 : 	{
; 3294 : 		//no = i * 6; //the second
; 3295 :         //CC_FIX å®¢æˆ·ç«¯åç‰‡æœ‰æ•…éšœï¼Œæ¯ä¸€ä¸ªåç‰‡åº”è¯¥æœ‰8ä¸ªè¯´æ˜Žç¬¦å·ï¼Œ7ä¸ªè¯´æ˜Žæœ‰å¼‚å¸¸ 20170806
; 3296 : 		//no = i * 7;
; 3297 : 		no = i * 8;
; 3298 : 		useFlag = getIntegerToken(data, '|', no+1 );

  00030	8d 04 f5 01 00
	00 00		 lea	 eax, DWORD PTR [esi*8+1]
  00037	50		 push	 eax
  00038	6a 7c		 push	 124			; 0000007cH
  0003a	53		 push	 ebx
  0003b	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3299 : 		if ( useFlag == -1 )

  00043	83 f8 ff	 cmp	 eax, -1
  00046	0f 84 2f 01 00
	00		 je	 $LN24@lssproto_A

; 3300 : 		{
; 3301 : 			useFlag = 0;
; 3302 : 		}
; 3303 : 		if ( useFlag <= 0 )

  0004c	85 c0		 test	 eax, eax
  0004e	0f 8e 27 01 00
	00		 jle	 $LN24@lssproto_A

; 3320 : 			continue;
; 3321 : 		}
; 3322 : 
; 3323 : #ifdef _EXTEND_AB
; 3324 : 		if ( i == MAX_ADR_BOOK-1 )

  00054	6b fe 68	 imul	 edi, esi, 104

; 3325 : 			addressBook[i].useFlag = useFlag;

  00057	0f b7 c0	 movzx	 eax, ax
  0005a	83 fe 4f	 cmp	 esi, 79			; 0000004fH
  0005d	74 05		 je	 SHORT $LN10@lssproto_A

; 3326 : 		else
; 3327 : 			addressBook[i].useFlag = 1;

  0005f	b8 01 00 00 00	 mov	 eax, 1
$LN10@lssproto_A:

; 3328 : #else
; 3329 : 		addressBook[i].useFlag = 1;
; 3330 : #endif
; 3331 : 
; 3332 : 		flag = getStringToken(data, '|', no+2, sizeof(name) - 1 , name );

  00064	66 89 87 00 00
	00 00		 mov	 WORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[edi], ax
  0006b	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  00071	50		 push	 eax
  00072	68 ff 00 00 00	 push	 255			; 000000ffH
  00077	8d 04 f5 02 00
	00 00		 lea	 eax, DWORD PTR [esi*8+2]
  0007e	50		 push	 eax
  0007f	6a 7c		 push	 124			; 0000007cH
  00081	53		 push	 ebx
  00082	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00087	83 c4 14	 add	 esp, 20			; 00000014H

; 3333 : 
; 3334 : 		if ( flag == 1 )

  0008a	83 f8 01	 cmp	 eax, 1
  0008d	0f 84 3f 01 00
	00		 je	 $LN28@lssproto_A

; 3335 : 			break;
; 3336 : 
; 3337 : 		makeStringFromEscaped(name);

  00093	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 3338 : 		nameLen = strlen(name);

  0009f	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _name$[ebp]
  000a5	83 c4 04	 add	 esp, 4
  000a8	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  000ab	0f 1f 44 00 00	 npad	 5
$LL25@lssproto_A:
  000b0	8a 01		 mov	 al, BYTE PTR [ecx]
  000b2	41		 inc	 ecx
  000b3	84 c0		 test	 al, al
  000b5	75 f9		 jne	 SHORT $LL25@lssproto_A
  000b7	2b ca		 sub	 ecx, edx

; 3339 : 		if ( 0 < nameLen && nameLen <= CHAR_NAME_LEN )

  000b9	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  000bc	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  000bf	77 1f		 ja	 SHORT $LN12@lssproto_A

; 3340 : 		{
; 3341 : 			strcpy( addressBook[i].name, name );

  000c1	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  000c7	8b cf		 mov	 ecx, edi
  000c9	8b d0		 mov	 edx, eax
  000cb	2b ca		 sub	 ecx, edx
  000cd	8d 91 14 00 00
	00		 lea	 edx, DWORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[ecx+20]
$LL15@lssproto_A:
  000d3	8a 08		 mov	 cl, BYTE PTR [eax]
  000d5	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  000d8	88 4c 02 ff	 mov	 BYTE PTR [edx+eax-1], cl
  000dc	84 c9		 test	 cl, cl
  000de	75 f3		 jne	 SHORT $LL15@lssproto_A
$LN12@lssproto_A:

; 3342 : 		}
; 3343 : 		addressBook[i].level = getIntegerToken(data, '|', no+3 );

  000e0	8d 04 f5 03 00
	00 00		 lea	 eax, DWORD PTR [esi*8+3]
  000e7	50		 push	 eax
  000e8	6a 7c		 push	 124			; 0000007cH
  000ea	53		 push	 ebx
  000eb	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  000f0	89 87 04 00 00
	00		 mov	 DWORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[edi+4], eax

; 3344 : 		addressBook[i].dp = getIntegerToken(data, '|', no+4 );

  000f6	8d 04 f5 04 00
	00 00		 lea	 eax, DWORD PTR [esi*8+4]
  000fd	50		 push	 eax
  000fe	6a 7c		 push	 124			; 0000007cH
  00100	53		 push	 ebx
  00101	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00106	89 87 0c 00 00
	00		 mov	 DWORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[edi+12], eax

; 3345 : 		addressBook[i].onlineFlag = (short)getIntegerToken(data, '|', no+5 );

  0010c	8d 04 f5 05 00
	00 00		 lea	 eax, DWORD PTR [esi*8+5]
  00113	50		 push	 eax
  00114	6a 7c		 push	 124			; 0000007cH
  00116	53		 push	 ebx
  00117	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0011c	66 89 87 02 00
	00 00		 mov	 WORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[edi+2], ax

; 3346 : 		addressBook[i].graNo = getIntegerToken(data, '|', no+6 );

  00123	8d 04 f5 06 00
	00 00		 lea	 eax, DWORD PTR [esi*8+6]
  0012a	50		 push	 eax
  0012b	6a 7c		 push	 124			; 0000007cH
  0012d	53		 push	 ebx
  0012e	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00133	89 87 10 00 00
	00		 mov	 DWORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[edi+16], eax

; 3347 : 		addressBook[i].transmigration = getIntegerToken(data, '|', no+7 );

  00139	8d 04 f5 07 00
	00 00		 lea	 eax, DWORD PTR [esi*8+7]
  00140	50		 push	 eax
  00141	6a 7c		 push	 124			; 0000007cH
  00143	53		 push	 ebx
  00144	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00149	83 c4 3c	 add	 esp, 60			; 0000003cH
  0014c	66 89 87 08 00
	00 00		 mov	 WORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[edi+8], ax

; 3348 : #ifdef ä¿®å¤é‚®ä»¶æœåŠ¡å™¨æ˜¾ç¤º
; 3349 : 		if (addressBook[i].onlineFlag)

  00153	66 83 bf 02 00
	00 00 00	 cmp	 WORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[edi+2], 0
  0015b	74 6b		 je	 SHORT $LN2@lssproto_A

; 3350 : 		{
; 3351 : 			getStringToken(data, '|', no + 8, 12, addressBook[i].planetname);

  0015d	8d 87 25 00 00
	00		 lea	 eax, DWORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[edi+37]
  00163	50		 push	 eax
  00164	6a 0c		 push	 12			; 0000000cH
  00166	8d 04 f5 08 00
	00 00		 lea	 eax, DWORD PTR [esi*8+8]
  0016d	50		 push	 eax
  0016e	6a 7c		 push	 124			; 0000007cH
  00170	53		 push	 ebx
  00171	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00176	83 c4 14	 add	 esp, 20			; 00000014H
  00179	eb 4d		 jmp	 SHORT $LN2@lssproto_A
$LN24@lssproto_A:

; 3304 : 		{
; 3305 : #if 0
; 3306 : 			if ( addressBook[i].useFlag == 1 )
; 3307 : #else
; 3308 : 			if ( MailHistory[i].dateStr[MAIL_MAX_HISTORY-1][0] != '\0' )

  0017b	69 c6 f0 0e 00
	00		 imul	 eax, esi, 3824
  00181	80 b8 93 0c 00
	00 00		 cmp	 BYTE PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[eax+3219], 0
  00188	74 2c		 je	 SHORT $LN8@lssproto_A

; 3309 : #endif
; 3310 : 			{
; 3311 : 				memset( &MailHistory[i], 0, sizeof( MailHistory[0] ) ) ;

  0018a	68 f0 0e 00 00	 push	 3824			; 00000ef0H
  0018f	8d 80 00 00 00
	00		 lea	 eax, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[eax]
  00195	6a 00		 push	 0
  00197	50		 push	 eax
  00198	e8 00 00 00 00	 call	 _memset

; 3312 : 				SaveMailHistory( i );

  0019d	56		 push	 esi
  0019e	e8 00 00 00 00	 call	 ?SaveMailHistory@@YAHH@Z ; SaveMailHistory
  001a3	83 c4 10	 add	 esp, 16			; 00000010H

; 3313 : 				// î ¹îš‡????
; 3314 : 				mailLamp = CheckMailNoReadFlag();

  001a6	e8 00 00 00 00	 call	 ?CheckMailNoReadFlag@@YAHXZ ; CheckMailNoReadFlag
  001ab	66 a3 00 00 00
	00		 mov	 WORD PTR ?mailLamp@@3FA, ax ; mailLamp

; 3315 : 				// îŽ—????î?
; 3316 : 				DeathLetterAction();

  001b1	e8 00 00 00 00	 call	 ?DeathLetterAction@@YAXXZ ; DeathLetterAction
$LN8@lssproto_A:

; 3317 : 			}
; 3318 : 			addressBook[i].useFlag = 0;

  001b6	6b c6 68	 imul	 eax, esi, 104
  001b9	33 c9		 xor	 ecx, ecx
  001bb	66 89 88 00 00
	00 00		 mov	 WORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[eax], cx

; 3319 : 			addressBook[i].name[0] = '\0';

  001c2	88 88 14 00 00
	00		 mov	 BYTE PTR ?addressBook@@3PAUADDRESS_BOOK@@A[eax+20], cl
$LN2@lssproto_A:

; 3290 : 		return;
; 3291 : 
; 3292 : 	for ( i = 0; i < MAX_ADR_BOOK; i++ )

  001c8	46		 inc	 esi
  001c9	83 fe 50	 cmp	 esi, 80			; 00000050H
  001cc	0f 8c 5e fe ff
	ff		 jl	 $LL4@lssproto_A
$LN28@lssproto_A:
  001d2	5f		 pop	 edi
  001d3	5e		 pop	 esi
$LN26@lssproto_A:

; 3352 : 		}
; 3353 : #endif // ä¿®å¤é‚®ä»¶æœåŠ¡å™¨æ˜¾ç¤º
; 3354 : 
; 3355 : 
; 3356 : 
; 3357 : //#ifdef _MAILSHOWPLANET				// (å¯å¼€æ”¾) Syu ADD æ˜¾ç¤ºåç‰‡æ˜Ÿçƒ
; 3358 : //		for ( j = 0 ; j < MAX_GMSV ; j ++ ) {
; 3359 : //			if ( gmsv[j].used == '1' ) {
; 3360 : //				getStringToken( gmsv[j].ipaddr, '.', 4, sizeof( planetid ) -1, planetid );
; 3361 : //				if ( addressBook[i].onlineFlag == atoi(planetid) ) {
; 3362 : //					sprintf ( addressBook[i].planetname , "%s" , gmsv[j].name ) ; 
; 3363 : //					break;
; 3364 : //				}
; 3365 : //			}
; 3366 : //		}
; 3367 : //#endif
; 3368 : 
; 3369 : 
; 3370 : 	}
; 3371 : }

  001d4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d7	33 cd		 xor	 ecx, ebp
  001d9	5b		 pop	 ebx
  001da	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001df	8b e5		 mov	 esp, ebp
  001e1	5d		 pop	 ebp
  001e2	c3		 ret	 0
?lssproto_AB_recv@@YAXHPAD@Z ENDP			; lssproto_AB_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_PME_recv@@YAXHHHHHHHHPAD@Z
_TEXT	SEGMENT
_id$1$ = -6176						; size = 4
_graNo$1$ = -6172					; size = 4
_x$1$ = -6168						; size = 4
_y$1$ = -6164						; size = 4
_dir$1$ = -6160						; size = 4
_charType$1$ = -6156					; size = 4
_cdata$GSCopy$1$ = -6152				; size = 4
_name$1 = -6148						; size = 2048
_freeName$2 = -4100					; size = 2048
_smalltoken$3 = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_objindex$ = 12						; size = 4
_graphicsno$ = 16					; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
_dir$ = 28						; size = 4
_flg$ = 32						; size = 4
_no$ = 36						; size = 4
_cdata$ = 40						; size = 4
?lssproto_PME_recv@@YAXHHHHHHHHPAD@Z PROC		; lssproto_PME_recv, COMDAT

; 3650 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 20 18 00 00	 mov	 eax, 6176		; 00001820H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3651 : 	// ????????????????îºîŸ«?î¡Š???
; 3652 : 	if ( logOutFlag )

  00017	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  0001e	56		 push	 esi
  0001f	8b 75 28	 mov	 esi, DWORD PTR _cdata$[ebp]
  00022	89 b5 f8 e7 ff
	ff		 mov	 DWORD PTR _cdata$GSCopy$1$[ebp], esi
  00028	0f 85 7a 02 00
	00		 jne	 $LN4@lssproto_P

; 3653 : 		return;
; 3654 : 
; 3655 : 	// î“–î™¬??î¡Š???
; 3656 : 	if ( encountNowFlag )

  0002e	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR ?encountNowFlag@@3FA, 0 ; encountNowFlag
  00036	0f 85 6c 02 00
	00		 jne	 $LN4@lssproto_P

; 3657 : 		return;
; 3658 : 
; 3659 : 	// ?î‘˜?î
; 3660 : 	if ( flg == 0 )

  0003c	83 7d 20 00	 cmp	 DWORD PTR _flg$[ebp], 0
  00040	75 44		 jne	 SHORT $LN8@lssproto_P

; 3661 : 	{
; 3662 : 		switch ( no )

  00042	8b 45 24	 mov	 eax, DWORD PTR _no$[ebp]
  00045	83 e8 00	 sub	 eax, 0
  00048	74 13		 je	 SHORT $LN10@lssproto_P
  0004a	83 e8 01	 sub	 eax, 1
  0004d	0f 85 55 02 00
	00		 jne	 $LN4@lssproto_P

; 3666 : 				break;
; 3667 : 			case 1:
; 3668 : 				createPetAction( graphicsno, x, y, dir, 2, 0, -1 );

  00053	6a ff		 push	 -1
  00055	50		 push	 eax
  00056	6a 02		 push	 2
  00058	ff 75 1c	 push	 DWORD PTR _dir$[ebp]
  0005b	eb 09		 jmp	 SHORT $LN20@lssproto_P
$LN10@lssproto_P:

; 3663 : 		{
; 3664 : 			case 0:
; 3665 : 				createPetAction( graphicsno, x, y, dir, 0, dir, -1 );

  0005d	8b 45 1c	 mov	 eax, DWORD PTR _dir$[ebp]
  00060	6a ff		 push	 -1
  00062	50		 push	 eax
  00063	6a 00		 push	 0
  00065	50		 push	 eax
$LN20@lssproto_P:

; 3727 : 					break;
; 3728 : 			}
; 3729 : 		}
; 3730 : 	}
; 3731 : }

  00066	ff 75 18	 push	 DWORD PTR _y$[ebp]
  00069	ff 75 14	 push	 DWORD PTR _x$[ebp]
  0006c	ff 75 10	 push	 DWORD PTR _graphicsno$[ebp]
  0006f	e8 00 00 00 00	 call	 ?createPetAction@@YAPAUaction@@HHHHHHH@Z ; createPetAction
  00074	83 c4 1c	 add	 esp, 28			; 0000001cH
  00077	5e		 pop	 esi
  00078	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007b	33 cd		 xor	 ecx, ebp
  0007d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
$LN8@lssproto_P:
  00086	53		 push	 ebx
  00087	57		 push	 edi

; 3669 : 				break;
; 3670 : 		}
; 3671 : 	}
; 3672 : 	else
; 3673 : 	// îŽ¢î‘˜?î
; 3674 : 	{
; 3675 : 		char smalltoken[2048];
; 3676 : 		int id;
; 3677 : 		int x;
; 3678 : 		int y;
; 3679 : 		int dir;
; 3680 : 		int graNo;
; 3681 : 		int level;
; 3682 : 		int nameColor;
; 3683 : 		char name[2048];
; 3684 : 		char freeName[2048];
; 3685 : 		int walkable;
; 3686 : 		int height;
; 3687 : 		int charType;
; 3688 : 		int ps=1;
; 3689 : #ifdef _OBJSEND_C
; 3690 : 		ps = 2;
; 3691 : #endif
; 3692 : 		charType = getIntegerToken( cdata, '|', ps++);

  00088	6a 02		 push	 2
  0008a	6a 7c		 push	 124			; 0000007cH
  0008c	56		 push	 esi
  0008d	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00092	89 85 f4 e7 ff
	ff		 mov	 DWORD PTR _charType$1$[ebp], eax

; 3693 : 		getStringToken( cdata, '|', ps++, sizeof(smalltoken) - 1, smalltoken);

  00098	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$3[ebp]
  0009e	50		 push	 eax
  0009f	68 ff 07 00 00	 push	 2047			; 000007ffH
  000a4	6a 03		 push	 3
  000a6	6a 7c		 push	 124			; 0000007cH
  000a8	56		 push	 esi
  000a9	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 3694 : 		id = a62toi(smalltoken);

  000ae	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$3[ebp]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ?a62toi@@YAHPAD@Z	; a62toi
  000ba	89 85 e0 e7 ff
	ff		 mov	 DWORD PTR _id$1$[ebp], eax

; 3695 : 		getStringToken( cdata, '|', ps++, sizeof(smalltoken) - 1, smalltoken);

  000c0	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$3[ebp]
  000c6	50		 push	 eax
  000c7	68 ff 07 00 00	 push	 2047			; 000007ffH
  000cc	6a 04		 push	 4
  000ce	6a 7c		 push	 124			; 0000007cH
  000d0	56		 push	 esi
  000d1	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 3696 : 		x = atoi(smalltoken);

  000d6	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$3[ebp]
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 _atoi
  000e2	89 85 e8 e7 ff
	ff		 mov	 DWORD PTR _x$1$[ebp], eax

; 3697 : 		getStringToken( cdata, '|', ps++, sizeof(smalltoken) - 1, smalltoken);

  000e8	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$3[ebp]
  000ee	50		 push	 eax
  000ef	68 ff 07 00 00	 push	 2047			; 000007ffH
  000f4	6a 05		 push	 5
  000f6	6a 7c		 push	 124			; 0000007cH
  000f8	56		 push	 esi
  000f9	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  000fe	83 c4 50	 add	 esp, 80			; 00000050H

; 3698 : 		y = atoi(smalltoken);

  00101	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$3[ebp]
  00107	50		 push	 eax
  00108	e8 00 00 00 00	 call	 _atoi
  0010d	89 85 ec e7 ff
	ff		 mov	 DWORD PTR _y$1$[ebp], eax

; 3699 : 		getStringToken( cdata, '|', ps++, sizeof(smalltoken) - 1, smalltoken);

  00113	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$3[ebp]
  00119	50		 push	 eax
  0011a	68 ff 07 00 00	 push	 2047			; 000007ffH
  0011f	6a 06		 push	 6
  00121	6a 7c		 push	 124			; 0000007cH
  00123	56		 push	 esi
  00124	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 3700 : 		dir = (atoi(smalltoken)+3)%8;

  00129	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$3[ebp]
  0012f	50		 push	 eax
  00130	e8 00 00 00 00	 call	 _atoi
  00135	83 c0 03	 add	 eax, 3
  00138	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0013d	79 05		 jns	 SHORT $LN18@lssproto_P
  0013f	48		 dec	 eax
  00140	83 c8 f8	 or	 eax, -8			; fffffff8H
  00143	40		 inc	 eax
$LN18@lssproto_P:
  00144	89 85 f0 e7 ff
	ff		 mov	 DWORD PTR _dir$1$[ebp], eax

; 3701 : 		getStringToken( cdata, '|', ps++, sizeof(smalltoken) - 1, smalltoken);

  0014a	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$3[ebp]
  00150	50		 push	 eax
  00151	68 ff 07 00 00	 push	 2047			; 000007ffH
  00156	6a 07		 push	 7
  00158	6a 7c		 push	 124			; 0000007cH
  0015a	56		 push	 esi
  0015b	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 3702 : 		graNo = atoi(smalltoken);

  00160	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$3[ebp]
  00166	50		 push	 eax
  00167	e8 00 00 00 00	 call	 _atoi
  0016c	89 85 e4 e7 ff
	ff		 mov	 DWORD PTR _graNo$1$[ebp], eax

; 3703 : 		getStringToken( cdata, '|', ps++, sizeof(smalltoken) - 1,smalltoken);

  00172	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$3[ebp]
  00178	50		 push	 eax
  00179	68 ff 07 00 00	 push	 2047			; 000007ffH
  0017e	6a 08		 push	 8
  00180	6a 7c		 push	 124			; 0000007cH
  00182	56		 push	 esi
  00183	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00188	83 c4 48	 add	 esp, 72			; 00000048H

; 3704 : 		level = atoi(smalltoken);

  0018b	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$3[ebp]
  00191	50		 push	 eax
  00192	e8 00 00 00 00	 call	 _atoi

; 3705 : 		nameColor = getIntegerToken( cdata, '|', ps++ );

  00197	6a 09		 push	 9
  00199	6a 7c		 push	 124			; 0000007cH
  0019b	56		 push	 esi
  0019c	8b d8		 mov	 ebx, eax
  0019e	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  001a3	8b f8		 mov	 edi, eax

; 3706 : 		getStringToken( cdata, '|' , ps++ , sizeof(name) - 1, name );

  001a5	8d 85 fc e7 ff
	ff		 lea	 eax, DWORD PTR _name$1[ebp]
  001ab	50		 push	 eax
  001ac	68 ff 07 00 00	 push	 2047			; 000007ffH
  001b1	6a 0a		 push	 10			; 0000000aH
  001b3	6a 7c		 push	 124			; 0000007cH
  001b5	56		 push	 esi
  001b6	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 3707 : 		makeStringFromEscaped(name);

  001bb	8d 85 fc e7 ff
	ff		 lea	 eax, DWORD PTR _name$1[ebp]
  001c1	50		 push	 eax
  001c2	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 3708 : 		getStringToken( cdata, '|' , ps++ , sizeof( freeName ) - 1, freeName );

  001c7	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _freeName$2[ebp]
  001cd	50		 push	 eax
  001ce	68 ff 07 00 00	 push	 2047			; 000007ffH
  001d3	6a 0b		 push	 11			; 0000000bH
  001d5	6a 7c		 push	 124			; 0000007cH
  001d7	56		 push	 esi
  001d8	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 3709 : 		makeStringFromEscaped( freeName );

  001dd	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _freeName$2[ebp]
  001e3	50		 push	 eax
  001e4	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  001e9	83 c4 40	 add	 esp, 64			; 00000040H

; 3710 : 		getStringToken( cdata, '|', ps++, sizeof(smalltoken) - 1, smalltoken);

  001ec	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$3[ebp]
  001f2	50		 push	 eax
  001f3	68 ff 07 00 00	 push	 2047			; 000007ffH
  001f8	6a 0c		 push	 12			; 0000000cH
  001fa	6a 7c		 push	 124			; 0000007cH
  001fc	56		 push	 esi
  001fd	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 3711 : 		walkable = atoi(smalltoken);

  00202	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$3[ebp]
  00208	50		 push	 eax
  00209	e8 00 00 00 00	 call	 _atoi
  0020e	8b f0		 mov	 esi, eax

; 3712 : 		getStringToken( cdata, '|', ps++, sizeof(smalltoken) - 1, smalltoken);

  00210	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$3[ebp]
  00216	50		 push	 eax
  00217	68 ff 07 00 00	 push	 2047			; 000007ffH
  0021c	6a 0d		 push	 13			; 0000000dH
  0021e	6a 7c		 push	 124			; 0000007cH
  00220	ff b5 f8 e7 ff
	ff		 push	 DWORD PTR _cdata$GSCopy$1$[ebp]
  00226	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 3713 : 		height = atoi(smalltoken);

  0022b	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$3[ebp]
  00231	50		 push	 eax
  00232	e8 00 00 00 00	 call	 _atoi

; 3714 : 
; 3715 : 		// ???îºîŸ«??????????
; 3716 : 		if ( setReturnPetObj( id, graNo, x, y, dir, name, freeName,

  00237	ff b5 f4 e7 ff
	ff		 push	 DWORD PTR _charType$1$[ebp]
  0023d	50		 push	 eax
  0023e	56		 push	 esi
  0023f	8b b5 f0 e7 ff
	ff		 mov	 esi, DWORD PTR _dir$1$[ebp]
  00245	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _freeName$2[ebp]
  0024b	57		 push	 edi
  0024c	53		 push	 ebx
  0024d	50		 push	 eax
  0024e	8d 85 fc e7 ff
	ff		 lea	 eax, DWORD PTR _name$1[ebp]
  00254	50		 push	 eax
  00255	8b bd ec e7 ff
	ff		 mov	 edi, DWORD PTR _y$1$[ebp]
  0025b	8b 9d e8 e7 ff
	ff		 mov	 ebx, DWORD PTR _x$1$[ebp]
  00261	56		 push	 esi
  00262	57		 push	 edi
  00263	53		 push	 ebx
  00264	ff b5 e4 e7 ff
	ff		 push	 DWORD PTR _graNo$1$[ebp]
  0026a	ff b5 e0 e7 ff
	ff		 push	 DWORD PTR _id$1$[ebp]
  00270	e8 00 00 00 00	 call	 ?setReturnPetObj@@YAHHHHHHPAD0HHHHH@Z ; setReturnPetObj
  00275	83 c4 60	 add	 esp, 96			; 00000060H
  00278	85 c0		 test	 eax, eax
  0027a	74 2a		 je	 SHORT $LN16@lssproto_P

; 3717 : 			level, nameColor, walkable, height, charType ) )
; 3718 : 		{
; 3719 : 			switch ( no )

  0027c	8b 45 24	 mov	 eax, DWORD PTR _no$[ebp]
  0027f	83 e8 00	 sub	 eax, 0
  00282	74 0d		 je	 SHORT $LN13@lssproto_P
  00284	83 e8 01	 sub	 eax, 1
  00287	75 1d		 jne	 SHORT $LN16@lssproto_P

; 3723 : 					break;
; 3724 : 
; 3725 : 				case 1:
; 3726 : 					createPetAction( graphicsno, x, y, dir, 3, 0, objindex );

  00289	ff 75 0c	 push	 DWORD PTR _objindex$[ebp]
  0028c	50		 push	 eax
  0028d	6a 03		 push	 3
  0028f	eb 07		 jmp	 SHORT $LN19@lssproto_P
$LN13@lssproto_P:

; 3720 : 			{
; 3721 : 				case 0:
; 3722 : 					createPetAction( graphicsno, x, y, dir, 1, 0, objindex );

  00291	ff 75 0c	 push	 DWORD PTR _objindex$[ebp]
  00294	6a 00		 push	 0
  00296	6a 01		 push	 1
$LN19@lssproto_P:
  00298	56		 push	 esi
  00299	57		 push	 edi
  0029a	53		 push	 ebx
  0029b	ff 75 10	 push	 DWORD PTR _graphicsno$[ebp]
  0029e	e8 00 00 00 00	 call	 ?createPetAction@@YAPAUaction@@HHHHHHH@Z ; createPetAction
  002a3	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN16@lssproto_P:
  002a6	5f		 pop	 edi
  002a7	5b		 pop	 ebx
$LN4@lssproto_P:

; 3727 : 					break;
; 3728 : 			}
; 3729 : 		}
; 3730 : 	}
; 3731 : }

  002a8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ab	33 cd		 xor	 ecx, ebp
  002ad	5e		 pop	 esi
  002ae	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b3	8b e5		 mov	 esp, ebp
  002b5	5d		 pop	 ebp
  002b6	c3		 ret	 0
?lssproto_PME_recv@@YAXHHHHHHHHPAD@Z ENDP		; lssproto_PME_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_MSG_recv@@YAXHHPADH@Z
_TEXT	SEGMENT
_text$GSCopy$1$ = -264					; size = 4
_moji$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_aindex$ = 12						; size = 4
_text$ = 16						; size = 4
_color$ = 20						; size = 4
?lssproto_MSG_recv@@YAXHHPADH@Z PROC			; lssproto_MSG_recv, COMDAT

; 3992 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b 7d 0c	 mov	 edi, DWORD PTR _aindex$[ebp]

; 3993 : 	char moji[ 256 ];
; 3994 : 	int noReadFlag;
; 3995 : 	
; 3996 : 	// ???????????
; 3997 : 	mailLamp = TRUE;

  00019	b8 01 00 00 00	 mov	 eax, 1

; 3998 : 	
; 3999 : 	// ?î‘¡??îœ±???î‘¡
; 4000 : 	MailHistory[ aindex ].newHistoryNo--;

  0001e	69 df f0 0e 00
	00		 imul	 ebx, edi, 3824

; 4001 : 	// ????????
; 4002 : 	if ( MailHistory[ aindex ].newHistoryNo <= -1 ) MailHistory[ aindex ].newHistoryNo = MAIL_MAX_HISTORY - 1;

  00024	b9 13 00 00 00	 mov	 ecx, 19			; 00000013H
  00029	66 a3 00 00 00
	00		 mov	 WORD PTR ?mailLamp@@3FA, ax ; mailLamp
  0002f	8b 75 10	 mov	 esi, DWORD PTR _text$[ebp]
  00032	89 b5 f8 fe ff
	ff		 mov	 DWORD PTR _text$GSCopy$1$[ebp], esi
  00038	8b 83 ec 0e 00
	00		 mov	 eax, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[ebx+3820]
  0003e	48		 dec	 eax
  0003f	83 f8 ff	 cmp	 eax, -1
  00042	0f 4e c1	 cmovle	 eax, ecx
  00045	89 83 ec 0e 00
	00		 mov	 DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[ebx+3820], eax

; 4003 : 	
; 4004 : 	// îšº??îŽ•?î?
; 4005 : 	getStringToken( text, '|', 1, sizeof( MailHistory[ aindex ].dateStr[ MailHistory[ aindex ].newHistoryNo ] ) - 1, 

  0004b	6b c0 15	 imul	 eax, eax, 21
  0004e	8d 80 04 0b 00
	00		 lea	 eax, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[eax+2820]
  00054	03 c3		 add	 eax, ebx
  00056	50		 push	 eax
  00057	6a 14		 push	 20			; 00000014H
  00059	6a 01		 push	 1
  0005b	6a 7c		 push	 124			; 0000007cH
  0005d	56		 push	 esi
  0005e	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 4006 : 					MailHistory[ aindex ].dateStr[ MailHistory[ aindex ].newHistoryNo ] );
; 4007 : 	// îž°î™?îŽ•?î?
; 4008 : 	getStringToken( text, '|', 2, sizeof( MailHistory[ aindex ].str[ MailHistory[ aindex ].newHistoryNo ] ) - 1, 

  00063	69 83 ec 0e 00
	00 8d 00 00 00	 imul	 eax, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[ebx+3820], 141
  0006d	8d 80 00 00 00
	00		 lea	 eax, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[eax]
  00073	03 c3		 add	 eax, ebx
  00075	50		 push	 eax
  00076	68 8c 00 00 00	 push	 140			; 0000008cH
  0007b	6a 02		 push	 2
  0007d	6a 7c		 push	 124			; 0000007cH
  0007f	56		 push	 esi
  00080	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 4009 : 					MailHistory[ aindex ].str[ MailHistory[ aindex ].newHistoryNo ] );
; 4010 : 	// ????????
; 4011 : 	makeStringFromEscaped( MailHistory[ aindex ].str[ MailHistory[ aindex ].newHistoryNo ] );

  00085	69 83 ec 0e 00
	00 8d 00 00 00	 imul	 eax, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[ebx+3820], 141
  0008f	8d 80 00 00 00
	00		 lea	 eax, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[eax]
  00095	03 c3		 add	 eax, ebx
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 4012 : 	
; 4013 : 	// ??????????îœ±?îŽ•?î?
; 4014 : 	noReadFlag = getIntegerToken( text, '|', 3 );

  0009d	6a 03		 push	 3
  0009f	6a 7c		 push	 124			; 0000007cH
  000a1	56		 push	 esi
  000a2	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  000a7	69 cf f0 0e 00
	00		 imul	 ecx, edi, 3824
  000ad	83 c4 38	 add	 esp, 56			; 00000038H
  000b0	69 d7 bc 03 00
	00		 imul	 edx, edi, 956
  000b6	8b 89 ec 0e 00
	00		 mov	 ecx, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[ecx+3820]
  000bc	03 ca		 add	 ecx, edx

; 4015 : 	// ????????
; 4016 : 	if ( noReadFlag != -1 ){

  000be	83 f8 ff	 cmp	 eax, -1
  000c1	0f 84 95 00 00
	00		 je	 $LN3@lssproto_M

; 4017 : 		// ??????????îœ±???
; 4018 : 		MailHistory[ aindex ].noReadFlag[ MailHistory[ aindex ].newHistoryNo ] = noReadFlag;
; 4019 : 		// ????????îŽ•?î?
; 4020 : 		MailHistory[ aindex ].petLevel[ MailHistory[ aindex ].newHistoryNo ] = getIntegerToken( text, '|', 4 );

  000c7	6a 04		 push	 4
  000c9	6a 7c		 push	 124			; 0000007cH
  000cb	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _text$GSCopy$1$[ebp]
  000d1	89 04 8d a8 0c
	00 00		 mov	 DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[ecx*4+3240], eax
  000d8	69 f7 bc 03 00
	00		 imul	 esi, edi, 956
  000de	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  000e3	8b 8b ec 0e 00
	00		 mov	 ecx, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[ebx+3820]
  000e9	03 ce		 add	 ecx, esi
  000eb	89 04 8d f8 0c
	00 00		 mov	 DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[ecx*4+3320], eax

; 4021 : 		// ????î¡“î“·?îŽ•?î?
; 4022 : 		getStringToken( text, '|', 5, sizeof( MailHistory[ aindex ].petName[ MailHistory[ aindex ].newHistoryNo ] ), 

  000f2	8b 8b ec 0e 00
	00		 mov	 ecx, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[ebx+3820]
  000f8	8b c1		 mov	 eax, ecx
  000fa	c1 e0 04	 shl	 eax, 4
  000fd	8d 80 48 0d 00
	00		 lea	 eax, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[eax+3400]
  00103	03 c3		 add	 eax, ebx
  00105	03 c1		 add	 eax, ecx
  00107	50		 push	 eax
  00108	6a 11		 push	 17			; 00000011H
  0010a	6a 05		 push	 5
  0010c	6a 7c		 push	 124			; 0000007cH
  0010e	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _text$GSCopy$1$[ebp]
  00114	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 4023 : 						MailHistory[ aindex ].petName[ MailHistory[ aindex ].newHistoryNo ] );
; 4024 : 		// ????î¡“î“·?????????
; 4025 : 		makeStringFromEscaped( MailHistory[ aindex ].petName[ MailHistory[ aindex ].newHistoryNo ] );

  00119	8b 8b ec 0e 00
	00		 mov	 ecx, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[ebx+3820]
  0011f	8b c1		 mov	 eax, ecx
  00121	c1 e0 04	 shl	 eax, 4
  00124	8d 80 48 0d 00
	00		 lea	 eax, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[eax+3400]
  0012a	03 c3		 add	 eax, ebx
  0012c	03 c1		 add	 eax, ecx
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 4026 : 		// ???????????îœ±??îŽ•?î?
; 4027 : 		MailHistory[ aindex ].itemGraNo[ MailHistory[ aindex ].newHistoryNo ] = getIntegerToken( text, '|', 6 );

  00134	6a 06		 push	 6
  00136	6a 7c		 push	 124			; 0000007cH
  00138	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _text$GSCopy$1$[ebp]
  0013e	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00143	8b 8b ec 0e 00
	00		 mov	 ecx, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[ebx+3820]
  00149	83 c4 30	 add	 esp, 48			; 00000030H
  0014c	03 ce		 add	 ecx, esi
  0014e	89 04 8d 9c 0e
	00 00		 mov	 DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[ecx*4+3740], eax

; 4028 : 		// ????îš????????î’•
; 4029 : 		sprintf( moji,"æ”¶åˆ°%sé€æ¥çš„å® ç‰©é‚®ä»¶ï¼", addressBook[ aindex ].name );

  00155	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BE@MGOKMGBK@?b?$KF?S?p?$CFs?a?j?$DP?n?$NM?$DP?Z?$KK?$DP?K?l?$KD?$KB@

; 4030 : 	}

  0015a	eb 10		 jmp	 SHORT $LN4@lssproto_M
$LN3@lssproto_M:

; 4031 : 	// ?î—­?????
; 4032 : 	else{	
; 4033 : 		MailHistory[ aindex ].noReadFlag[ MailHistory[ aindex ].newHistoryNo ] = TRUE;

  0015c	c7 04 8d a8 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[ecx*4+3240], 1

; 4034 : 		// ????îš????????î’•
; 4035 : 		sprintf( moji,"æ”¶åˆ°%sé€æ¥çš„é‚®ä»¶ï¼", addressBook[ aindex ].name );

  00167	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BB@JIMIMFE@?b?$KF?S?p?$CFs?a?j?$DP?n?$NM?$DP?K?l?$KD?$KB@
$LN4@lssproto_M:

; 4036 : 	}
; 4037 : 	
; 4038 : 	// ????îž°??????????????
; 4039 : 	StockChatBufferLine( moji, FONT_PAL_WHITE );

  0016c	6b c7 68	 imul	 eax, edi, 104
  0016f	05 14 00 00 00	 add	 eax, OFFSET ?addressBook@@3PAUADDRESS_BOOK@@A+20
  00174	50		 push	 eax
  00175	51		 push	 ecx
  00176	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _moji$[ebp]
  0017c	50		 push	 eax
  0017d	e8 00 00 00 00	 call	 _sprintf
  00182	6a 00		 push	 0
  00184	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _moji$[ebp]
  0018a	6a 00		 push	 0
  0018c	50		 push	 eax
  0018d	e8 00 00 00 00	 call	 ?StockChatBufferLine@@YAXPADEH@Z ; StockChatBufferLine
  00192	83 c4 18	 add	 esp, 24			; 00000018H

; 4040 : 	
; 4041 : 	// ????????
; 4042 : 	if ( mailHistoryWndSelectNo == aindex ){

  00195	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?mailHistoryWndSelectNo@@3HA, edi ; mailHistoryWndSelectNo
  0019b	75 13		 jne	 SHORT $LN6@lssproto_M

; 4043 : 		// ??????????????
; 4044 : 		mailHistoryWndPageNo++;

  0019d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?mailHistoryWndPageNo@@3HA ; mailHistoryWndPageNo

; 4045 : 		// ????????
; 4046 : 		if ( mailHistoryWndPageNo >= MAIL_MAX_HISTORY ) mailHistoryWndPageNo = 0;

  001a2	33 c9		 xor	 ecx, ecx
  001a4	40		 inc	 eax
  001a5	83 f8 14	 cmp	 eax, 20			; 00000014H
  001a8	0f 4d c1	 cmovge	 eax, ecx
  001ab	a3 00 00 00 00	 mov	 DWORD PTR ?mailHistoryWndPageNo@@3HA, eax ; mailHistoryWndPageNo
$LN6@lssproto_M:

; 4047 : 		// îŽ—?????????îŒ–
; 4048 : 	//	DeathLetterAction();
; 4049 : 	}
; 4050 : 	// îŽ¢î‘˜?
; 4051 : 	play_se( 101, 320, 240 );

  001b0	68 f0 00 00 00	 push	 240			; 000000f0H
  001b5	68 40 01 00 00	 push	 320			; 00000140H
  001ba	6a 65		 push	 101			; 00000065H
  001bc	e8 00 00 00 00	 call	 ?play_se@@YAHHHH@Z	; play_se

; 4052 : 	// ???????îŸ•î”¼
; 4053 : 	SaveMailHistory( aindex );

  001c1	57		 push	 edi
  001c2	e8 00 00 00 00	 call	 ?SaveMailHistory@@YAHH@Z ; SaveMailHistory

; 4054 : }

  001c7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ca	83 c4 10	 add	 esp, 16			; 00000010H
  001cd	33 cd		 xor	 ecx, ebp
  001cf	5f		 pop	 edi
  001d0	5e		 pop	 esi
  001d1	5b		 pop	 ebx
  001d2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d7	8b e5		 mov	 esp, ebp
  001d9	5d		 pop	 ebp
  001da	c3		 ret	 0
?lssproto_MSG_recv@@YAXHHPADH@Z ENDP			; lssproto_MSG_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_SI_recv@@YAXHHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
?lssproto_SI_recv@@YAXHHH@Z PROC			; lssproto_SI_recv, COMDAT

; 3523 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3524 : 	// ????????????????îºîŸ«?î¡Š???
; 3525 : 	if ( logOutFlag )

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  0000a	75 0e		 jne	 SHORT $LN1@lssproto_S

; 3526 : 		return;
; 3527 : 
; 3528 : 	swapItem( from, to );

  0000c	ff 75 10	 push	 DWORD PTR _to$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR _from$[ebp]
  00012	e8 00 00 00 00	 call	 ?swapItem@@YAXHH@Z	; swapItem
  00017	83 c4 08	 add	 esp, 8
$LN1@lssproto_S:

; 3529 : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?lssproto_SI_recv@@YAXHHH@Z ENDP			; lssproto_SI_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_I_recv@@YAXHPAD@Z
_TEXT	SEGMENT
tv699 = -1040						; size = 4
_memo$ = -1036						; size = 256
_name2$ = -780						; size = 256
_name$ = -524						; size = 256
_alch$1 = -268						; size = 256
_pile$2 = -268						; size = 256
_damage$3 = -268					; size = 256
_type$4 = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_I_recv@@YAXHPAD@Z PROC			; lssproto_I_recv, COMDAT

; 3534 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 04 00
	00		 sub	 esp, 1040		; 00000410H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3535 : 	int i, j;
; 3536 : 	int no;
; 3537 : 	char name[256];
; 3538 : 	char name2[256];
; 3539 : 	char memo[256];
; 3540 : 
; 3541 : 	// ????????????????îºîŸ«?î¡Š???
; 3542 : 	if ( logOutFlag )

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  0001a	57		 push	 edi
  0001b	8b 7d 0c	 mov	 edi, DWORD PTR _data$[ebp]
  0001e	0f 85 5d 03 00
	00		 jne	 $LN28@lssproto_I

; 3546 : 
; 3547 : #ifdef _PET_ITEM
; 3548 : 		//no = j * 14;
; 3549 : 		//CC FIX è¿™é‡Œä¿®å¤æˆ15ï¼Ÿï¼Ÿï¼Ÿ
; 3550 : 		no = j * 15;

  00024	53		 push	 ebx
  00025	56		 push	 esi

; 3551 : #endif//_PET_ITEM
; 3552 : 
; 3553 : 		i = getIntegerToken(data, '|', no+1 );

  00026	6a 01		 push	 1
  00028	6a 7c		 push	 124			; 0000007cH
  0002a	57		 push	 edi
  0002b	33 db		 xor	 ebx, ebx
  0002d	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00032	8b f0		 mov	 esi, eax

; 3554 : 		if ( getStringToken(data, '|', no+2, sizeof(name) - 1 , name ) == 1 )

  00034	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  0003a	50		 push	 eax
  0003b	68 ff 00 00 00	 push	 255			; 000000ffH
  00040	6a 02		 push	 2
  00042	6a 7c		 push	 124			; 0000007cH
  00044	57		 push	 edi
  00045	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0004a	83 c4 20	 add	 esp, 32			; 00000020H
  0004d	83 f8 01	 cmp	 eax, 1
  00050	0f 84 29 03 00
	00		 je	 $LN46@lssproto_I

; 3543 : 		return;
; 3544 : 
; 3545 : 	for ( j = 0; ; j++ ){

  00056	c7 85 f0 fb ff
	ff 02 00 00 00	 mov	 DWORD PTR tv699[ebp], 2
$LL4@lssproto_I:

; 3555 : 			break;
; 3556 : 		makeStringFromEscaped(name);

  00060	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 3557 : 		if ( strlen(name) == 0 ){

  0006c	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _name$[ebp]
  00072	83 c4 04	 add	 esp, 4
  00075	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL42@lssproto_I:
  00078	8a 01		 mov	 al, BYTE PTR [ecx]
  0007a	41		 inc	 ecx
  0007b	84 c0		 test	 al, al
  0007d	75 f9		 jne	 SHORT $LL42@lssproto_I
  0007f	69 f6 7c 01 00
	00		 imul	 esi, esi, 380
  00085	2b ca		 sub	 ecx, edx
  00087	75 0e		 jne	 SHORT $LN7@lssproto_I

; 3558 : 			pc.item[i].useFlag = 0;

  00089	33 c0		 xor	 eax, eax
  0008b	66 89 86 a0 01
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A[esi+416], ax

; 3559 : 			continue;

  00092	e9 a3 02 00 00	 jmp	 $LN2@lssproto_I
$LN7@lssproto_I:

; 3560 : 		}
; 3561 : 
; 3562 : 		pc.item[i].useFlag = 1;

  00097	b8 01 00 00 00	 mov	 eax, 1
  0009c	66 89 86 a0 01
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A[esi+416], ax

; 3563 : 		if ( strlen(name) <= ITEM_NAME_LEN ){

  000a3	83 f9 1c	 cmp	 ecx, 28			; 0000001cH
  000a6	77 25		 ja	 SHORT $LN8@lssproto_I

; 3564 : 			strcpy( pc.item[i].name, name );

  000a8	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _name$[ebp]
  000ae	8b c6		 mov	 eax, esi
  000b0	8b d1		 mov	 edx, ecx
  000b2	2b c2		 sub	 eax, edx
  000b4	8d 90 aa 01 00
	00		 lea	 edx, DWORD PTR ?pc@@3UPC@@A[eax+426]
  000ba	66 0f 1f 44 00
	00		 npad	 6
$LL16@lssproto_I:
  000c0	8a 01		 mov	 al, BYTE PTR [ecx]
  000c2	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  000c5	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  000c9	84 c0		 test	 al, al
  000cb	75 f3		 jne	 SHORT $LL16@lssproto_I
$LN8@lssproto_I:

; 3565 : 		}
; 3566 : 		getStringToken(data, '|', no+3, sizeof( name2 ) - 1, name2 );

  000cd	8d 85 f4 fc ff
	ff		 lea	 eax, DWORD PTR _name2$[ebp]
  000d3	50		 push	 eax
  000d4	68 ff 00 00 00	 push	 255			; 000000ffH
  000d9	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  000dc	50		 push	 eax
  000dd	6a 7c		 push	 124			; 0000007cH
  000df	57		 push	 edi
  000e0	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 3567 : 		makeStringFromEscaped( name2 );

  000e5	8d 85 f4 fc ff
	ff		 lea	 eax, DWORD PTR _name2$[ebp]
  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 3568 : 		if ( strlen( name2 ) <= ITEM_NAME2_LEN ){

  000f1	8d 8d f4 fc ff
	ff		 lea	 ecx, DWORD PTR _name2$[ebp]
  000f7	83 c4 18	 add	 esp, 24			; 00000018H
  000fa	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  000fd	0f 1f 00	 npad	 3
$LL43@lssproto_I:
  00100	8a 01		 mov	 al, BYTE PTR [ecx]
  00102	41		 inc	 ecx
  00103	84 c0		 test	 al, al
  00105	75 f9		 jne	 SHORT $LL43@lssproto_I
  00107	2b ca		 sub	 ecx, edx
  00109	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0010c	77 1f		 ja	 SHORT $LN9@lssproto_I

; 3569 : 			strcpy( pc.item[i].name2, name2 );

  0010e	8d 8d f4 fc ff
	ff		 lea	 ecx, DWORD PTR _name2$[ebp]
  00114	8b c6		 mov	 eax, esi
  00116	8b d1		 mov	 edx, ecx
  00118	2b c2		 sub	 eax, edx
  0011a	8d 90 c7 01 00
	00		 lea	 edx, DWORD PTR ?pc@@3UPC@@A[eax+455]
$LL17@lssproto_I:
  00120	8a 01		 mov	 al, BYTE PTR [ecx]
  00122	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00125	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  00129	84 c0		 test	 al, al
  0012b	75 f3		 jne	 SHORT $LL17@lssproto_I
$LN9@lssproto_I:

; 3570 : 		}
; 3571 : 		pc.item[i].color = getIntegerToken(data, '|', no+4 );

  0012d	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  00130	50		 push	 eax
  00131	6a 7c		 push	 124			; 0000007cH
  00133	57		 push	 edi
  00134	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00139	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013c	89 86 c4 00 00
	00		 mov	 DWORD PTR ?pc@@3UPC@@A[esi+196], eax

; 3572 : 		if ( pc.item[i].color < 0 )

  00142	85 c0		 test	 eax, eax
  00144	79 0a		 jns	 SHORT $LN10@lssproto_I

; 3573 : 			pc.item[i].color = 0;

  00146	c7 86 c4 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A[esi+196], 0
$LN10@lssproto_I:

; 3574 : 		getStringToken(data, '|', no+5, sizeof( memo ) - 1, memo );

  00150	8d 85 f4 fb ff
	ff		 lea	 eax, DWORD PTR _memo$[ebp]
  00156	50		 push	 eax
  00157	68 ff 00 00 00	 push	 255			; 000000ffH
  0015c	8d 43 05	 lea	 eax, DWORD PTR [ebx+5]
  0015f	50		 push	 eax
  00160	6a 7c		 push	 124			; 0000007cH
  00162	57		 push	 edi
  00163	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 3575 : 		makeStringFromEscaped( memo );

  00168	8d 85 f4 fb ff
	ff		 lea	 eax, DWORD PTR _memo$[ebp]
  0016e	50		 push	 eax
  0016f	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 3576 : 		if ( strlen( memo ) <= ITEM_MEMO_LEN ){

  00174	8d 8d f4 fb ff
	ff		 lea	 ecx, DWORD PTR _memo$[ebp]
  0017a	83 c4 18	 add	 esp, 24			; 00000018H
  0017d	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL44@lssproto_I:
  00180	8a 01		 mov	 al, BYTE PTR [ecx]
  00182	41		 inc	 ecx
  00183	84 c0		 test	 al, al
  00185	75 f9		 jne	 SHORT $LL44@lssproto_I
  00187	2b ca		 sub	 ecx, edx
  00189	83 f9 54	 cmp	 ecx, 84			; 00000054H
  0018c	77 1f		 ja	 SHORT $LN11@lssproto_I

; 3577 : 			strcpy( pc.item[i].memo, memo );

  0018e	8d 8d f4 fb ff
	ff		 lea	 ecx, DWORD PTR _memo$[ebp]
  00194	8b c6		 mov	 eax, esi
  00196	8b d1		 mov	 edx, ecx
  00198	2b c2		 sub	 eax, edx
  0019a	8d 90 d8 01 00
	00		 lea	 edx, DWORD PTR ?pc@@3UPC@@A[eax+472]
$LL18@lssproto_I:
  001a0	8a 01		 mov	 al, BYTE PTR [ecx]
  001a2	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  001a5	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  001a9	84 c0		 test	 al, al
  001ab	75 f3		 jne	 SHORT $LL18@lssproto_I
$LN11@lssproto_I:

; 3578 : 		}
; 3579 : 		pc.item[i].graNo = getIntegerToken(data, '|', no+6 );

  001ad	8d 43 06	 lea	 eax, DWORD PTR [ebx+6]
  001b0	50		 push	 eax
  001b1	6a 7c		 push	 124			; 0000007cH
  001b3	57		 push	 edi
  001b4	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  001b9	89 86 c8 00 00
	00		 mov	 DWORD PTR ?pc@@3UPC@@A[esi+200], eax

; 3580 : 		pc.item[i].field = getIntegerToken(data, '|', no+7 );

  001bf	8d 43 07	 lea	 eax, DWORD PTR [ebx+7]
  001c2	50		 push	 eax
  001c3	6a 7c		 push	 124			; 0000007cH
  001c5	57		 push	 edi
  001c6	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  001cb	66 89 86 a2 01
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A[esi+418], ax

; 3581 : 		pc.item[i].target = getIntegerToken(data, '|', no+8 );

  001d2	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  001d5	50		 push	 eax
  001d6	6a 7c		 push	 124			; 0000007cH
  001d8	57		 push	 edi
  001d9	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  001de	0f b7 c0	 movzx	 eax, ax
  001e1	83 c4 24	 add	 esp, 36			; 00000024H
  001e4	66 89 86 a4 01
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A[esi+420], ax

; 3582 : 		if ( pc.item[i].target >= 100 ){

  001eb	66 83 f8 64	 cmp	 ax, 100			; 00000064H
  001ef	7c 15		 jl	 SHORT $LN12@lssproto_I

; 3583 : 			pc.item[i].target %= 100;

  001f1	98		 cwde
  001f2	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  001f7	99		 cdq
  001f8	f7 f9		 idiv	 ecx

; 3584 : 			pc.item[i].deadTargetFlag = 1;

  001fa	8d 41 9d	 lea	 eax, DWORD PTR [ecx-99]
  001fd	66 89 96 a4 01
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A[esi+420], dx

; 3585 : 		}else{

  00204	eb 02		 jmp	 SHORT $LN13@lssproto_I
$LN12@lssproto_I:

; 3586 : 			pc.item[i].deadTargetFlag = 0;

  00206	33 c0		 xor	 eax, eax
$LN13@lssproto_I:

; 3587 : 		}
; 3588 : 		pc.item[i].level = getIntegerToken(data, '|', no+9 );

  00208	66 89 86 a6 01
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A[esi+422], ax
  0020f	8d 43 09	 lea	 eax, DWORD PTR [ebx+9]
  00212	50		 push	 eax
  00213	6a 7c		 push	 124			; 0000007cH
  00215	57		 push	 edi
  00216	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0021b	89 86 cc 00 00
	00		 mov	 DWORD PTR ?pc@@3UPC@@A[esi+204], eax

; 3589 : 		pc.item[i].sendFlag = getIntegerToken(data, '|', no+10 );

  00221	8d 43 0a	 lea	 eax, DWORD PTR [ebx+10]
  00224	50		 push	 eax
  00225	6a 7c		 push	 124			; 0000007cH
  00227	57		 push	 edi
  00228	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0022d	66 89 86 a8 01
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A[esi+424], ax

; 3590 : 
; 3591 : 		{
; 3592 : 			// æ˜¾ç¤ºç‰©å“è€ä¹…åº¦
; 3593 : 			char damage[256];
; 3594 : 			getStringToken(data, '|', no+11, sizeof( damage ) - 1, damage );

  00234	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _damage$3[ebp]
  0023a	50		 push	 eax
  0023b	68 ff 00 00 00	 push	 255			; 000000ffH
  00240	8d 43 0b	 lea	 eax, DWORD PTR [ebx+11]
  00243	50		 push	 eax
  00244	6a 7c		 push	 124			; 0000007cH
  00246	57		 push	 edi
  00247	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 3595 : 			makeStringFromEscaped( damage );

  0024c	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _damage$3[ebp]
  00252	50		 push	 eax
  00253	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 3596 : 			if ( strlen( damage ) <= 16 ){	

  00258	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _damage$3[ebp]
  0025e	83 c4 30	 add	 esp, 48			; 00000030H
  00261	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL45@lssproto_I:
  00264	8a 01		 mov	 al, BYTE PTR [ecx]
  00266	41		 inc	 ecx
  00267	84 c0		 test	 al, al
  00269	75 f9		 jne	 SHORT $LL45@lssproto_I
  0026b	2b ca		 sub	 ecx, edx
  0026d	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00270	77 1f		 ja	 SHORT $LN14@lssproto_I

; 3597 : 				strcpy( pc.item[i].damage, damage );

  00272	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _damage$3[ebp]
  00278	8b ce		 mov	 ecx, esi
  0027a	8b d0		 mov	 edx, eax
  0027c	2b ca		 sub	 ecx, edx
  0027e	8d 91 2d 02 00
	00		 lea	 edx, DWORD PTR ?pc@@3UPC@@A[ecx+557]
$LL19@lssproto_I:
  00284	8a 08		 mov	 cl, BYTE PTR [eax]
  00286	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00289	88 4c 02 ff	 mov	 BYTE PTR [edx+eax-1], cl
  0028d	84 c9		 test	 cl, cl
  0028f	75 f3		 jne	 SHORT $LL19@lssproto_I
$LN14@lssproto_I:

; 3598 : 			}
; 3599 : 		} 
; 3600 : 
; 3601 : #ifdef _ITEM_PILENUMS
; 3602 : 		{
; 3603 : 			char pile[256];
; 3604 : 			getStringToken(data, '|', no+12, sizeof( pile ) - 1, pile );

  00291	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _pile$2[ebp]
  00297	50		 push	 eax
  00298	68 ff 00 00 00	 push	 255			; 000000ffH
  0029d	8d 43 0c	 lea	 eax, DWORD PTR [ebx+12]
  002a0	50		 push	 eax
  002a1	6a 7c		 push	 124			; 0000007cH
  002a3	57		 push	 edi
  002a4	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 3605 : 			makeStringFromEscaped( pile );

  002a9	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _pile$2[ebp]
  002af	50		 push	 eax
  002b0	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 3606 : 			pc.item[i].pile = atoi( pile);

  002b5	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _pile$2[ebp]
  002bb	50		 push	 eax
  002bc	e8 00 00 00 00	 call	 _atoi
  002c1	89 86 d0 00 00
	00		 mov	 DWORD PTR ?pc@@3UPC@@A[esi+208], eax

; 3607 : 		}
; 3608 : #endif
; 3609 : 
; 3610 : #ifdef _ALCHEMIST //_ITEMSET7_TXT
; 3611 : 		{
; 3612 : 			char alch[256];
; 3613 : 			getStringToken(data, '|', no+13, sizeof( alch ) - 1, alch );

  002c7	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _alch$1[ebp]
  002cd	50		 push	 eax
  002ce	68 ff 00 00 00	 push	 255			; 000000ffH
  002d3	8d 43 0d	 lea	 eax, DWORD PTR [ebx+13]
  002d6	50		 push	 eax
  002d7	6a 7c		 push	 124			; 0000007cH
  002d9	57		 push	 edi
  002da	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 3614 : 			makeStringFromEscaped( alch );

  002df	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _alch$1[ebp]
  002e5	50		 push	 eax
  002e6	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 3615 : 			strcpy( pc.item[i].alch, alch );

  002eb	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _alch$1[ebp]
  002f1	8b c6		 mov	 eax, esi
  002f3	8b d1		 mov	 edx, ecx
  002f5	83 c4 34	 add	 esp, 52			; 00000034H
  002f8	2b c2		 sub	 eax, edx
  002fa	8d 90 d4 00 00
	00		 lea	 edx, DWORD PTR ?pc@@3UPC@@A[eax+212]
$LL20@lssproto_I:
  00300	8a 01		 mov	 al, BYTE PTR [ecx]
  00302	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00305	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  00309	84 c0		 test	 al, al
  0030b	75 f3		 jne	 SHORT $LL20@lssproto_I

; 3616 : 		}
; 3617 : #endif
; 3618 : #ifdef _PET_ITEM
; 3619 : 		{
; 3620 : 			char type[8];
; 3621 : 			getStringToken(data, '|', no + 14, sizeof(type) - 1, type);

  0030d	8d 45 f4	 lea	 eax, DWORD PTR _type$4[ebp]
  00310	50		 push	 eax
  00311	6a 07		 push	 7
  00313	8d 43 0e	 lea	 eax, DWORD PTR [ebx+14]
  00316	50		 push	 eax
  00317	6a 7c		 push	 124			; 0000007cH
  00319	57		 push	 edi
  0031a	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 3622 : 			makeStringFromEscaped(type);

  0031f	8d 45 f4	 lea	 eax, DWORD PTR _type$4[ebp]
  00322	50		 push	 eax
  00323	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 3623 : 			pc.item[i].type = atoi(type);

  00328	8d 45 f4	 lea	 eax, DWORD PTR _type$4[ebp]
  0032b	50		 push	 eax
  0032c	e8 00 00 00 00	 call	 _atoi
  00331	83 c4 1c	 add	 esp, 28			; 0000001cH
  00334	88 86 3d 02 00
	00		 mov	 BYTE PTR ?pc@@3UPC@@A[esi+573], al
$LN2@lssproto_I:

; 3543 : 		return;
; 3544 : 
; 3545 : 	for ( j = 0; ; j++ ){

  0033a	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR tv699[ebp]
  00340	83 c0 0f	 add	 eax, 15			; 0000000fH
  00343	89 85 f0 fb ff
	ff		 mov	 DWORD PTR tv699[ebp], eax

; 3546 : 
; 3547 : #ifdef _PET_ITEM
; 3548 : 		//no = j * 14;
; 3549 : 		//CC FIX è¿™é‡Œä¿®å¤æˆ15ï¼Ÿï¼Ÿï¼Ÿ
; 3550 : 		no = j * 15;

  00349	8d 58 fe	 lea	 ebx, DWORD PTR [eax-2]

; 3551 : #endif//_PET_ITEM
; 3552 : 
; 3553 : 		i = getIntegerToken(data, '|', no+1 );

  0034c	48		 dec	 eax
  0034d	50		 push	 eax
  0034e	6a 7c		 push	 124			; 0000007cH
  00350	57		 push	 edi
  00351	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00356	8b f0		 mov	 esi, eax

; 3554 : 		if ( getStringToken(data, '|', no+2, sizeof(name) - 1 , name ) == 1 )

  00358	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  0035e	50		 push	 eax
  0035f	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR tv699[ebp]
  00365	68 ff 00 00 00	 push	 255			; 000000ffH
  0036a	50		 push	 eax
  0036b	6a 7c		 push	 124			; 0000007cH
  0036d	57		 push	 edi
  0036e	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00373	83 c4 20	 add	 esp, 32			; 00000020H
  00376	83 f8 01	 cmp	 eax, 1
  00379	0f 85 e1 fc ff
	ff		 jne	 $LL4@lssproto_I
$LN46@lssproto_I:
  0037f	5e		 pop	 esi
  00380	5b		 pop	 ebx
$LN28@lssproto_I:

; 3624 : 		}
; 3625 : #endif
; 3626 : 
; 3627 : 
; 3628 : 	}
; 3629 : }

  00381	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00384	33 cd		 xor	 ecx, ebp
  00386	5f		 pop	 edi
  00387	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0038c	8b e5		 mov	 esp, ebp
  0038e	5d		 pop	 ebp
  0038f	c3		 ret	 0
?lssproto_I_recv@@YAXHPAD@Z ENDP			; lssproto_I_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_B_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_command$ = 12						; size = 4
?lssproto_B_recv@@YAXHPAD@Z PROC			; lssproto_B_recv, COMDAT

; 3866 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3867 : 	//JLWG æ˜¯å¿«é€Ÿæˆ˜æ–—åˆ™ä¸å¤„ç†æ­¤åŒ…
; 3868 : 	extern int g_bFastFight;
; 3869 : 	if (g_bFastFight)

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bFastFight@@3HA, 0 ; g_bFastFight
  0000a	0f 85 2f 01 00
	00		 jne	 $LN14@lssproto_B

; 3870 : 	{
; 3871 : 		return;
; 3872 : 	}
; 3873 : 	//printf("\n%s",command);
; 3874 : 	if ( *( command + 1 ) == 'C'){

  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _command$[ebp]
  00014	8a 46 01	 mov	 al, BYTE PTR [esi+1]
  00017	3c 43		 cmp	 al, 67			; 00000043H
  00019	75 30		 jne	 SHORT $LN3@lssproto_B

; 3875 : 		strcpy( BattleStatusBak[ BattleStatusWritePointer ], command );

  0001b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?BattleStatusWritePointer@@3HA ; BattleStatusWritePointer
  00021	8b c2		 mov	 eax, edx
  00023	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  00026	2b c6		 sub	 eax, esi
  00028	8d 88 00 00 00
	00		 lea	 ecx, DWORD PTR ?BattleStatusBak@@3PAY0BAAA@DA[eax]
  0002e	66 90		 npad	 2
$LL18@lssproto_B:
  00030	8a 06		 mov	 al, BYTE PTR [esi]
  00032	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  00035	88 44 31 ff	 mov	 BYTE PTR [ecx+esi-1], al
  00039	84 c0		 test	 al, al
  0003b	75 f3		 jne	 SHORT $LL18@lssproto_B

; 3876 : 		BattleStatusWritePointer = ( BattleStatusWritePointer + 1 ) & ( BATTLE_BUF_SIZE-1 );

  0003d	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00040	83 e0 03	 and	 eax, 3
  00043	a3 00 00 00 00	 mov	 DWORD PTR ?BattleStatusWritePointer@@3HA, eax ; BattleStatusWritePointer
  00048	5e		 pop	 esi

; 3907 : 	}
; 3908 : 	
; 3909 : #ifdef  _STONDEBUG__MSG
; 3910 : //	StockChatBufferLine( command, FONT_PAL_RED );
; 3911 : #endif
; 3912 : 
; 3913 : }

  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
$LN3@lssproto_B:

; 3877 : 	}else if (*(command + 1) == 'P') {

  0004b	3c 50		 cmp	 al, 80			; 00000050H
  0004d	75 3a		 jne	 SHORT $LN5@lssproto_B

; 3878 : 		sscanf(command + 3, "%X|%X|%X", &BattleMyNo, &BattleBpFlag, &BattleMyMp);

  0004f	68 00 00 00 00	 push	 OFFSET ?BattleMyMp@@3HA	; BattleMyMp
  00054	68 00 00 00 00	 push	 OFFSET ?BattleBpFlag@@3HA ; BattleBpFlag
  00059	68 00 00 00 00	 push	 OFFSET ?BattleMyNo@@3HA	; BattleMyNo
  0005e	8d 46 03	 lea	 eax, DWORD PTR [esi+3]
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_08EOJECCGN@?$CFX?$HM?$CFX?$HM?$CFX@
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 _sscanf
  0006c	83 c4 14	 add	 esp, 20			; 00000014H

; 3879 : 		//JL fix é‡æ•Œå·è¢­
; 3880 : 		if (BattleBpFlag == 26)

  0006f	83 3d 00 00 00
	00 1a		 cmp	 DWORD PTR ?BattleBpFlag@@3HA, 26 ; BattleBpFlag, 0000001aH
  00076	0f 85 c2 00 00
	00		 jne	 $LN26@lssproto_B

; 3881 : 		{
; 3882 : 			BattleBpFlag = 0;

  0007c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BattleBpFlag@@3HA, 0 ; BattleBpFlag
  00086	5e		 pop	 esi

; 3907 : 	}
; 3908 : 	
; 3909 : #ifdef  _STONDEBUG__MSG
; 3910 : //	StockChatBufferLine( command, FONT_PAL_RED );
; 3911 : #endif
; 3912 : 
; 3913 : }

  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
$LN5@lssproto_B:

; 3883 : 		}
; 3884 : 	}else if ( *( command + 1 ) == 'A'){

  00089	3c 41		 cmp	 al, 65			; 00000041H
  0008b	75 3f		 jne	 SHORT $LN8@lssproto_B

; 3885 : 		sscanf( command + 3, "%X|%X", &BattleAnimFlag, &BattleSvTurnNo );

  0008d	68 00 00 00 00	 push	 OFFSET ?BattleSvTurnNo@@3HA ; BattleSvTurnNo
  00092	68 00 00 00 00	 push	 OFFSET ?BattleAnimFlag@@3HA ; BattleAnimFlag
  00097	8d 46 03	 lea	 eax, DWORD PTR [esi+3]
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_05HMDCACKA@?$CFX?$HM?$CFX@
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 _sscanf
  000a5	83 c4 10	 add	 esp, 16			; 00000010H

; 3886 : 
; 3887 : 		if ( BattleTurnReceiveFlag == TRUE ){ 

  000a8	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?BattleTurnReceiveFlag@@3HA, 1 ; BattleTurnReceiveFlag
  000af	0f 85 89 00 00
	00		 jne	 $LN26@lssproto_B

; 3888 : 			BattleCliTurnNo = BattleSvTurnNo;

  000b5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BattleSvTurnNo@@3HA ; BattleSvTurnNo
  000ba	a3 00 00 00 00	 mov	 DWORD PTR ?BattleCliTurnNo@@3HA, eax ; BattleCliTurnNo

; 3889 : 			BattleTurnReceiveFlag = FALSE;

  000bf	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BattleTurnReceiveFlag@@3HA, 0 ; BattleTurnReceiveFlag
  000c9	5e		 pop	 esi

; 3907 : 	}
; 3908 : 	
; 3909 : #ifdef  _STONDEBUG__MSG
; 3910 : //	StockChatBufferLine( command, FONT_PAL_RED );
; 3911 : #endif
; 3912 : 
; 3913 : }

  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
$LN8@lssproto_B:

; 3890 : 		}
; 3891 : 	}else if ( *( command + 1 ) == 'U')

  000cc	3c 55		 cmp	 al, 85			; 00000055H
  000ce	75 0d		 jne	 SHORT $LN11@lssproto_B

; 3892 : 		BattleEscFlag = TRUE;

  000d0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?BattleEscFlag@@3HA, 1 ; BattleEscFlag
  000da	5e		 pop	 esi

; 3907 : 	}
; 3908 : 	
; 3909 : #ifdef  _STONDEBUG__MSG
; 3910 : //	StockChatBufferLine( command, FONT_PAL_RED );
; 3911 : #endif
; 3912 : 
; 3913 : }

  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
$LN11@lssproto_B:

; 3893 : #ifdef æˆ˜æ–—å…‰çŽ¯
; 3894 : 	else if (*(command + 1) == '&'){

  000dd	3c 26		 cmp	 al, 38			; 00000026H
  000df	75 32		 jne	 SHORT $LN13@lssproto_B

; 3895 : 		printf("\n%s",command);

  000e1	56		 push	 esi
  000e2	68 00 00 00 00	 push	 OFFSET ??_C@_03ILJCGOLJ@?6?$CFs@
  000e7	e8 00 00 00 00	 call	 _printf
  000ec	83 c4 08	 add	 esp, 8

; 3896 : 		if (*(command + 2) == '|'  && *(command + 3) && *(command + 4)){

  000ef	80 7e 02 7c	 cmp	 BYTE PTR [esi+2], 124	; 0000007cH
  000f3	75 49		 jne	 SHORT $LN26@lssproto_B
  000f5	80 7e 03 00	 cmp	 BYTE PTR [esi+3], 0
  000f9	8d 46 03	 lea	 eax, DWORD PTR [esi+3]
  000fc	74 40		 je	 SHORT $LN26@lssproto_B
  000fe	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  00102	74 3a		 je	 SHORT $LN26@lssproto_B

; 3897 : 			lstrcpyA(gStrå…‰çŽ¯, command + 3);

  00104	50		 push	 eax
  00105	68 00 00 00 00	 push	 OFFSET ?gStrÎÃ?@@3PADA	; gStrÎÃ?
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8
  00110	5e		 pop	 esi

; 3907 : 	}
; 3908 : 	
; 3909 : #ifdef  _STONDEBUG__MSG
; 3910 : //	StockChatBufferLine( command, FONT_PAL_RED );
; 3911 : #endif
; 3912 : 
; 3913 : }

  00111	5d		 pop	 ebp
  00112	c3		 ret	 0
$LN13@lssproto_B:

; 3898 : 		}else{
; 3899 : 			return;
; 3900 : 		}
; 3901 : 	
; 3902 : 	}
; 3903 : #endif
; 3904 : 	else {
; 3905 : 		strcpy( BattleCmdBak[ BattleCmdWritePointer ], command );

  00113	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?BattleCmdWritePointer@@3HA ; BattleCmdWritePointer
  00119	8b c2		 mov	 eax, edx
  0011b	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  0011e	2b c6		 sub	 eax, esi
  00120	8d 88 00 00 00
	00		 lea	 ecx, DWORD PTR ?BattleCmdBak@@3PAY0BAAA@DA[eax]
$LL19@lssproto_B:
  00126	8a 06		 mov	 al, BYTE PTR [esi]
  00128	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  0012b	88 44 31 ff	 mov	 BYTE PTR [ecx+esi-1], al
  0012f	84 c0		 test	 al, al
  00131	75 f3		 jne	 SHORT $LL19@lssproto_B

; 3906 : 		BattleCmdWritePointer = ( BattleCmdWritePointer + 1 ) & ( BATTLE_BUF_SIZE-1 );

  00133	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00136	83 e0 03	 and	 eax, 3
  00139	a3 00 00 00 00	 mov	 DWORD PTR ?BattleCmdWritePointer@@3HA, eax ; BattleCmdWritePointer
$LN26@lssproto_B:
  0013e	5e		 pop	 esi
$LN14@lssproto_B:

; 3907 : 	}
; 3908 : 	
; 3909 : #ifdef  _STONDEBUG__MSG
; 3910 : //	StockChatBufferLine( command, FONT_PAL_RED );
; 3911 : #endif
; 3912 : 
; 3913 : }

  0013f	5d		 pop	 ebp
  00140	c3		 ret	 0
?lssproto_B_recv@@YAXHPAD@Z ENDP			; lssproto_B_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_RD_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_RD_recv@@YAXHPAD@Z PROC			; lssproto_RD_recv, COMDAT

; 3509 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3510 : 	// ????????????????îºîŸ«?î¡Š???
; 3511 : 	if ( logOutFlag )

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  0000a	75 30		 jne	 SHORT $LN1@lssproto_R

; 3512 : 		return;
; 3513 : 
; 3514 : 	battleResultMsg.useFlag = 2;
; 3515 : 
; 3516 : 	battleResultMsg.resChr[0].exp = getInteger62Token(data, '|', 1 );

  0000c	6a 01		 push	 1
  0000e	6a 7c		 push	 124			; 0000007cH
  00010	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  00013	b8 02 00 00 00	 mov	 eax, 2
  00018	66 a3 00 00 00
	00		 mov	 WORD PTR ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A, ax
  0001e	e8 00 00 00 00	 call	 ?getInteger62Token@@YAHPADDH@Z ; getInteger62Token

; 3517 : 	battleResultMsg.resChr[1].exp = getInteger62Token(data, '|', 2 );

  00023	6a 02		 push	 2
  00025	6a 7c		 push	 124			; 0000007cH
  00027	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  0002a	a3 08 00 00 00	 mov	 DWORD PTR ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A+8, eax
  0002f	e8 00 00 00 00	 call	 ?getInteger62Token@@YAHPADDH@Z ; getInteger62Token
  00034	83 c4 18	 add	 esp, 24			; 00000018H
  00037	a3 10 00 00 00	 mov	 DWORD PTR ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A+16, eax
$LN1@lssproto_R:

; 3518 : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?lssproto_RD_recv@@YAXHPAD@Z ENDP			; lssproto_RD_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_RS_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_cols$1$ = -4104					; size = 4
_token$ = -4100						; size = 2048
_item$ = -2052						; size = 2048
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_RS_recv@@YAXHPAD@Z PROC			; lssproto_RS_recv, COMDAT

; 3456 : void lssproto_RS_recv( int fd, char *data ){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 08 10 00 00	 mov	 eax, 4104		; 00001008H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3457 : 	int i;
; 3458 : 	char token[2048];
; 3459 : 	char item[2048];
; 3460 : 
; 3461 : 	//JLWG æ˜¯å¿«é€Ÿæˆ˜æ–—åˆ™ä¸å¤„ç†æ­¤åŒ…
; 3462 : 	extern int g_bFastFight;
; 3463 : 	if (g_bFastFight){

  00017	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bFastFight@@3HA, 0 ; g_bFastFight
  0001e	53		 push	 ebx
  0001f	8b 5d 0c	 mov	 ebx, DWORD PTR _data$[ebp]
  00022	0f 85 0c 02 00
	00		 jne	 $LN10@lssproto_R

; 3464 : 		return;
; 3465 : 	}
; 3466 : 
; 3467 : 	if ( logOutFlag )

  00028	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  0002f	0f 85 ff 01 00
	00		 jne	 $LN10@lssproto_R

; 3468 : 		return;
; 3469 : 
; 3470 : 	battleResultMsg.useFlag = 1;

  00035	b8 01 00 00 00	 mov	 eax, 1

; 3471 : 	//cary ?? æ ä½ æ•°
; 3472 : 	int cols = RESULT_CHR_EXP;

  0003a	c7 85 f8 ef ff
	ff 05 00 00 00	 mov	 DWORD PTR _cols$1$[ebp], 5
  00044	66 a3 00 00 00
	00		 mov	 WORD PTR ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A, ax

; 3473 : 	getStringToken(data, ',', RESULT_CHR_EXP+1, sizeof( token ) - 1, token );

  0004a	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _token$[ebp]
  00050	50		 push	 eax
  00051	68 ff 07 00 00	 push	 2047			; 000007ffH
  00056	6a 06		 push	 6
  00058	6a 2c		 push	 44			; 0000002cH
  0005a	53		 push	 ebx
  0005b	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00060	83 c4 14	 add	 esp, 20			; 00000014H

; 3474 : 	if ( token[0] == 0){

  00063	80 bd fc ef ff
	ff 00		 cmp	 BYTE PTR _token$[ebp], 0
  0006a	75 1e		 jne	 SHORT $LN7@lssproto_R

; 3475 : 		cols = RESULT_CHR_EXP - 1;
; 3476 : 		battleResultMsg.resChr[RESULT_CHR_EXP-1].petNo = -1;

  0006c	83 c8 ff	 or	 eax, -1
  0006f	c7 85 f8 ef ff
	ff 04 00 00 00	 mov	 DWORD PTR _cols$1$[ebp], 4
  00079	66 a3 24 00 00
	00		 mov	 WORD PTR ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A+36, ax

; 3477 : 		battleResultMsg.resChr[RESULT_CHR_EXP-1].levelUp = -1;

  0007f	66 a3 26 00 00
	00		 mov	 WORD PTR ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A+38, ax

; 3478 : 		battleResultMsg.resChr[RESULT_CHR_EXP-1].exp = -1;

  00085	a3 28 00 00 00	 mov	 DWORD PTR ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A+40, eax
$LN7@lssproto_R:

; 3479 : 	}
; 3480 : 	//end cary
; 3481 : 	for ( i = 0; i < cols; i++ ){

  0008a	56		 push	 esi
  0008b	57		 push	 edi
  0008c	33 ff		 xor	 edi, edi
  0008e	66 90		 npad	 2
$LL4@lssproto_R:

; 3482 : 		getStringToken(data, ',', i+1, sizeof( token ) - 1, token );

  00090	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _token$[ebp]
  00096	50		 push	 eax
  00097	68 ff 07 00 00	 push	 2047			; 000007ffH
  0009c	8d 77 01	 lea	 esi, DWORD PTR [edi+1]
  0009f	56		 push	 esi
  000a0	6a 2c		 push	 44			; 0000002cH
  000a2	53		 push	 ebx
  000a3	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 3483 : 		battleResultMsg.resChr[i].petNo = getIntegerToken( token, '|', 1 );

  000a8	6a 01		 push	 1
  000aa	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _token$[ebp]
  000b0	6a 7c		 push	 124			; 0000007cH
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 3484 : 		battleResultMsg.resChr[i].levelUp = getIntegerToken( token, '|', 2 );

  000b8	6a 02		 push	 2
  000ba	66 89 04 fd 04
	00 00 00	 mov	 WORD PTR ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A[edi*8+4], ax
  000c2	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _token$[ebp]
  000c8	6a 7c		 push	 124			; 0000007cH
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken

; 3485 : 		battleResultMsg.resChr[i].exp = getInteger62Token( token, '|', 3 );

  000d0	6a 03		 push	 3
  000d2	66 89 04 fd 06
	00 00 00	 mov	 WORD PTR ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A[edi*8+6], ax
  000da	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _token$[ebp]
  000e0	6a 7c		 push	 124			; 0000007cH
  000e2	50		 push	 eax
  000e3	e8 00 00 00 00	 call	 ?getInteger62Token@@YAHPADDH@Z ; getInteger62Token
  000e8	89 04 fd 08 00
	00 00		 mov	 DWORD PTR ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A[edi*8+8], eax
  000ef	83 c4 38	 add	 esp, 56			; 00000038H
  000f2	8b fe		 mov	 edi, esi
  000f4	3b bd f8 ef ff
	ff		 cmp	 edi, DWORD PTR _cols$1$[ebp]
  000fa	7c 94		 jl	 SHORT $LL4@lssproto_R

; 3486 : 	}
; 3487 : 
; 3488 : 	getStringToken(data, ',', i+1, sizeof( token ) - 1, token );

  000fc	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _token$[ebp]
  00102	50		 push	 eax
  00103	68 ff 07 00 00	 push	 2047			; 000007ffH
  00108	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0010b	50		 push	 eax
  0010c	6a 2c		 push	 44			; 0000002cH
  0010e	53		 push	 ebx
  0010f	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 3489 : 	getStringToken( token, '|', 1, sizeof( item ) - 1, item );

  00114	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _item$[ebp]
  0011a	50		 push	 eax
  0011b	68 ff 07 00 00	 push	 2047			; 000007ffH
  00120	6a 01		 push	 1
  00122	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _token$[ebp]
  00128	6a 7c		 push	 124			; 0000007cH
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 3490 : 	makeStringFromEscaped( item );

  00130	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _item$[ebp]
  00136	50		 push	 eax
  00137	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  0013c	83 c4 2c	 add	 esp, 44			; 0000002cH

; 3491 : 	if ( strlen( item ) <= RESULT_ITEM_NAME_LEN ){

  0013f	8d 8d fc f7 ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  00145	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00148	5f		 pop	 edi
  00149	5e		 pop	 esi
  0014a	66 0f 1f 44 00
	00		 npad	 6
$LL28@lssproto_R:
  00150	8a 01		 mov	 al, BYTE PTR [ecx]
  00152	41		 inc	 ecx
  00153	84 c0		 test	 al, al
  00155	75 f9		 jne	 SHORT $LL28@lssproto_R
  00157	2b ca		 sub	 ecx, edx
  00159	83 f9 18	 cmp	 ecx, 24			; 00000018H
  0015c	77 16		 ja	 SHORT $LN8@lssproto_R

; 3492 : 		strcpy( battleResultMsg.item[0], item );

  0015e	33 c9		 xor	 ecx, ecx
$LL12@lssproto_R:
  00160	8a 84 0d fc f7
	ff ff		 mov	 al, BYTE PTR _item$[ebp+ecx]
  00167	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  0016a	88 81 2b 00 00
	00		 mov	 BYTE PTR ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A[ecx+43], al
  00170	84 c0		 test	 al, al
  00172	75 ec		 jne	 SHORT $LL12@lssproto_R
$LN8@lssproto_R:

; 3493 : 	}
; 3494 : 	getStringToken( token, '|', 2, sizeof( item ) - 1, item );

  00174	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _item$[ebp]
  0017a	50		 push	 eax
  0017b	68 ff 07 00 00	 push	 2047			; 000007ffH
  00180	6a 02		 push	 2
  00182	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _token$[ebp]
  00188	6a 7c		 push	 124			; 0000007cH
  0018a	50		 push	 eax
  0018b	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 3495 : 	makeStringFromEscaped( item );

  00190	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _item$[ebp]
  00196	50		 push	 eax
  00197	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 3496 : 	if ( strlen( item ) <= RESULT_ITEM_NAME_LEN ){

  0019c	8d 8d fc f7 ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  001a2	83 c4 18	 add	 esp, 24			; 00000018H
  001a5	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL29@lssproto_R:
  001a8	8a 01		 mov	 al, BYTE PTR [ecx]
  001aa	41		 inc	 ecx
  001ab	84 c0		 test	 al, al
  001ad	75 f9		 jne	 SHORT $LL29@lssproto_R
  001af	2b ca		 sub	 ecx, edx
  001b1	83 f9 18	 cmp	 ecx, 24			; 00000018H
  001b4	77 1e		 ja	 SHORT $LN9@lssproto_R

; 3497 : 		strcpy( battleResultMsg.item[1], item );

  001b6	33 c9		 xor	 ecx, ecx
  001b8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL13@lssproto_R:
  001c0	8a 84 0d fc f7
	ff ff		 mov	 al, BYTE PTR _item$[ebp+ecx]
  001c7	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  001ca	88 81 44 00 00
	00		 mov	 BYTE PTR ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A[ecx+68], al
  001d0	84 c0		 test	 al, al
  001d2	75 ec		 jne	 SHORT $LL13@lssproto_R
$LN9@lssproto_R:

; 3498 : 	}
; 3499 : 	getStringToken( token, '|', 3, sizeof( item ) - 1, item );

  001d4	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _item$[ebp]
  001da	50		 push	 eax
  001db	68 ff 07 00 00	 push	 2047			; 000007ffH
  001e0	6a 03		 push	 3
  001e2	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _token$[ebp]
  001e8	6a 7c		 push	 124			; 0000007cH
  001ea	50		 push	 eax
  001eb	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 3500 : 	makeStringFromEscaped( item );

  001f0	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _item$[ebp]
  001f6	50		 push	 eax
  001f7	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped

; 3501 : 	if ( strlen( item ) <= RESULT_ITEM_NAME_LEN ){

  001fc	8d 8d fc f7 ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  00202	83 c4 18	 add	 esp, 24			; 00000018H
  00205	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL30@lssproto_R:
  00208	8a 01		 mov	 al, BYTE PTR [ecx]
  0020a	41		 inc	 ecx
  0020b	84 c0		 test	 al, al
  0020d	75 f9		 jne	 SHORT $LL30@lssproto_R
  0020f	2b ca		 sub	 ecx, edx
  00211	83 f9 18	 cmp	 ecx, 24			; 00000018H
  00214	77 1e		 ja	 SHORT $LN10@lssproto_R

; 3502 : 		strcpy( battleResultMsg.item[2], item );

  00216	33 c9		 xor	 ecx, ecx
  00218	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL14@lssproto_R:
  00220	8a 84 0d fc f7
	ff ff		 mov	 al, BYTE PTR _item$[ebp+ecx]
  00227	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  0022a	88 81 5d 00 00
	00		 mov	 BYTE PTR ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A[ecx+93], al
  00230	84 c0		 test	 al, al
  00232	75 ec		 jne	 SHORT $LL14@lssproto_R
$LN10@lssproto_R:

; 3503 : 	}
; 3504 : }

  00234	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00237	33 cd		 xor	 ecx, ebp
  00239	5b		 pop	 ebx
  0023a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0023f	8b e5		 mov	 esp, ebp
  00241	5d		 pop	 ebp
  00242	c3		 ret	 0
?lssproto_RS_recv@@YAXHPAD@Z ENDP			; lssproto_RS_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_EN_recv@@YAXHHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_result$ = 12						; size = 4
_field$ = 16						; size = 4
?lssproto_EN_recv@@YAXHHH@Z PROC			; lssproto_EN_recv, COMDAT

; 3797 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3798 : 
; 3799 : 	if ( logOutFlag )

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  0000a	57		 push	 edi
  0000b	8b 7d 10	 mov	 edi, DWORD PTR _field$[ebp]
  0000e	0f 85 fb 00 00
	00		 jne	 $LN4@lssproto_E

; 3800 : 		return;
; 3801 : 	if ( result > 0 ){

  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR _result$[ebp]
  00018	85 f6		 test	 esi, esi
  0001a	0f 8e da 00 00
	00		 jle	 $LN3@lssproto_E

; 3802 : 		EncountFlag = TRUE;

  00020	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?EncountFlag@@3HA, 1 ; EncountFlag

; 3803 : 		if ( result == 4)

  0002a	83 fe 04	 cmp	 esi, 4
  0002d	75 19		 jne	 SHORT $LN5@lssproto_E

; 3804 : 			vsLookFlag = 1;

  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	6a 00		 push	 0
  00036	66 a3 00 00 00
	00		 mov	 WORD PTR ?vsLookFlag@@3FA, ax ; vsLookFlag
  0003c	e8 00 00 00 00	 call	 ?JL_SetFastFightFlag@@YAX_N@Z ; JL_SetFastFightFlag
  00041	83 c4 04	 add	 esp, 4

; 3824 : 		else
; 3825 : 			eventEnemyFlag = 0;

  00044	33 c0		 xor	 eax, eax
  00046	eb 59		 jmp	 SHORT $LN9@lssproto_E
$LN5@lssproto_E:

; 3805 : 		
; 3806 : 
; 3807 : 		//JLWG 2016.9.16 å¿«é€Ÿæˆ˜æ–—å¤„ç†
; 3808 : 		extern int g_flag_FastFight;
; 3809 : 		if (vsLookFlag == 0 && g_flag_FastFight == 1)	//å¦‚æžœæ˜¯å¿«é€Ÿæˆ˜æ–—çš„å¤„ç†

  00048	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR ?vsLookFlag@@3FA, 0 ; vsLookFlag
  00050	75 32		 jne	 SHORT $LN6@lssproto_E
  00052	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_flag_FastFight@@3HA, 1 ; g_flag_FastFight
  00059	75 29		 jne	 SHORT $LN6@lssproto_E

; 3810 : 		{
; 3811 : 			EncountFlag = FALSE;
; 3812 : 			pc.status |= CHR_STATUS_BATTLE;

  0005b	81 0d a4 00 00
	00 00 04 00 00	 or	 DWORD PTR ?pc@@3UPC@@A+164, 1024 ; 00000400H

; 3813 : 			JL_SetFastFightFlag(true);

  00065	6a 01		 push	 1
  00067	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?EncountFlag@@3HA, 0 ; EncountFlag
  00071	e8 00 00 00 00	 call	 ?JL_SetFastFightFlag@@YAX_N@Z ; JL_SetFastFightFlag

; 3814 : 			JL_é”å®šäººç‰©(true);

  00076	6a 01		 push	 1
  00078	e8 00 00 00 00	 call	 ?JL_?ïÒìÑÚª@@YAX_N@Z	; JL_?ïÒìÑÚª
  0007d	83 c4 08	 add	 esp, 8
  00080	5e		 pop	 esi
  00081	5f		 pop	 edi

; 3852 : 	}
; 3853 : }

  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
$LN6@lssproto_E:

; 3815 : 
; 3816 : 			return;
; 3817 : 		}else{
; 3818 : 			JL_SetFastFightFlag(false);

  00084	6a 00		 push	 0
  00086	e8 00 00 00 00	 call	 ?JL_SetFastFightFlag@@YAX_N@Z ; JL_SetFastFightFlag
  0008b	83 c4 04	 add	 esp, 4

; 3819 : 		}
; 3820 : 
; 3821 : 
; 3822 : 		if ( result == 6 || result == 2 )

  0008e	83 fe 06	 cmp	 esi, 6
  00091	74 09		 je	 SHORT $LN10@lssproto_E
  00093	83 fe 02	 cmp	 esi, 2
  00096	74 04		 je	 SHORT $LN10@lssproto_E

; 3824 : 		else
; 3825 : 			eventEnemyFlag = 0;

  00098	33 c0		 xor	 eax, eax
  0009a	eb 05		 jmp	 SHORT $LN9@lssproto_E
$LN10@lssproto_E:

; 3823 : 			eventEnemyFlag = 1;

  0009c	b8 01 00 00 00	 mov	 eax, 1
$LN9@lssproto_E:

; 3826 : 
; 3827 : 		if ( field < 0 || BATTLE_MAP_FILES <= field )

  000a1	66 a3 00 00 00
	00		 mov	 WORD PTR ?eventEnemyFlag@@3FA, ax ; eventEnemyFlag

; 3828 : 			BattleMapNo = 0;
; 3829 : 		else
; 3830 : 			BattleMapNo = field;
; 3831 : 
; 3832 : 		if (result == 2)

  000a7	33 c0		 xor	 eax, eax
  000a9	81 ff db 00 00
	00		 cmp	 edi, 219		; 000000dbH
  000af	0f 47 f8	 cmova	 edi, eax
  000b2	89 3d 00 00 00
	00		 mov	 DWORD PTR ?BattleMapNo@@3HA, edi ; BattleMapNo
  000b8	83 fe 02	 cmp	 esi, 2
  000bb	75 0a		 jne	 SHORT $LN14@lssproto_E

; 3833 : 		{
; 3834 : 			NoCastFlag = false;  //JL fix 2018/8/28 å†³æ–—æ—¶å¼ºåˆ¶å¤ä½æ²‰é»˜ï¼Œå¯ä»¥ä¸‹æŒ‡ä»¤

  000bd	a3 00 00 00 00	 mov	 DWORD PTR ?NoCastFlag@@3HA, eax ; NoCastFlag

; 3835 : 			DuelFlag = TRUE;

  000c2	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]

; 3836 : 		}

  000c5	eb 02		 jmp	 SHORT $LN15@lssproto_E
$LN14@lssproto_E:

; 3837 : 		else
; 3838 : 			DuelFlag = FALSE;

  000c7	33 c0		 xor	 eax, eax
$LN15@lssproto_E:
  000c9	5e		 pop	 esi

; 3839 : 
; 3840 : 		//if ( result == 2 || result == 5 )
; 3841 : 		//	NoHelpFlag = TRUE;
; 3842 : 		//else
; 3843 : 		//	NoHelpFlag = FALSE;
; 3844 : 
; 3845 : 		BattleStatusReadPointer = BattleStatusWritePointer =0;

  000ca	a3 00 00 00 00	 mov	 DWORD PTR ?DuelFlag@@3HA, eax ; DuelFlag
  000cf	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BattleStatusWritePointer@@3HA, 0 ; BattleStatusWritePointer
  000d9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BattleStatusReadPointer@@3HA, 0 ; BattleStatusReadPointer

; 3846 : 		BattleCmdReadPointer = BattleCmdWritePointer =0;

  000e3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BattleCmdWritePointer@@3HA, 0 ; BattleCmdWritePointer
  000ed	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BattleCmdReadPointer@@3HA, 0 ; BattleCmdReadPointer
  000f7	5f		 pop	 edi

; 3852 : 	}
; 3853 : }

  000f8	5d		 pop	 ebp
  000f9	c3		 ret	 0
$LN3@lssproto_E:

; 3847 : 
; 3848 : 	}else{
; 3849 : 		sendEnFlag = 0;

  000fa	33 c0		 xor	 eax, eax
  000fc	66 a3 00 00 00
	00		 mov	 WORD PTR ?sendEnFlag@@3FA, ax ; sendEnFlag

; 3850 : 		duelSendFlag = 0;

  00102	66 a3 00 00 00
	00		 mov	 WORD PTR ?duelSendFlag@@3FA, ax ; duelSendFlag

; 3851 : 		jbSendFlag = 0;

  00108	66 a3 00 00 00
	00		 mov	 WORD PTR ?jbSendFlag@@3FA, ax ; jbSendFlag
  0010e	5e		 pop	 esi
$LN4@lssproto_E:
  0010f	5f		 pop	 edi

; 3852 : 	}
; 3853 : }

  00110	5d		 pop	 ebp
  00111	c3		 ret	 0
?lssproto_EN_recv@@YAXHHH@Z ENDP			; lssproto_EN_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_EV_recv@@YAXHHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_seqno$ = 12						; size = 4
_result$ = 16						; size = 4
?lssproto_EV_recv@@YAXHHH@Z PROC			; lssproto_EV_recv, COMDAT

; 3227 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3228 : 
; 3229 : 
; 3230 : 	// ????????????????îºîŸ«?î¡Š???
; 3231 : 	if ( logOutFlag )

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  0000a	75 4f		 jne	 SHORT $LN7@lssproto_E

; 3232 : 		return;
; 3233 : 
; 3234 : 	if ( eventWarpSendId == seqno )

  0000c	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?eventWarpSendId@@3FA ; eventWarpSendId
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _seqno$[ebp]
  00016	3b c1		 cmp	 eax, ecx
  00018	75 28		 jne	 SHORT $LN3@lssproto_E

; 3235 : 	{
; 3236 : 		eventWarpSendFlag = 0;

  0001a	33 c0		 xor	 eax, eax
  0001c	66 a3 00 00 00
	00		 mov	 WORD PTR ?eventWarpSendFlag@@3FA, ax ; eventWarpSendFlag

; 3237 : 		if ( result == 0 )

  00022	39 45 10	 cmp	 DWORD PTR _result$[ebp], eax
  00025	75 34		 jne	 SHORT $LN7@lssproto_E

; 3238 : 		{
; 3239 : 			// ???î§î›²??????î¡¡?î¸î•???
; 3240 : 			redrawMap();

  00027	e8 00 00 00 00	 call	 ?redrawMap@@YAXXZ	; redrawMap

; 3241 : 			floorChangeFlag = FALSE;

  0002c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?floorChangeFlag@@3HA, 0 ; floorChangeFlag

; 3242 : 			// ?î’î˜«??????????
; 3243 : 			warpEffectStart = TRUE;

  00036	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?warpEffectStart@@3HA, 1 ; warpEffectStart

; 3253 : 		}
; 3254 : 		//else
; 3255 : 		//{
; 3256 : 			// ??????process.cpp???
; 3257 : 		//}
; 3258 : 	}
; 3259 : }

  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
$LN3@lssproto_E:

; 3244 : 
; 3245 : 		}
; 3246 : 	}
; 3247 : 	else
; 3248 : 	if ( eventEnemySendId == seqno )

  00042	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?eventEnemySendId@@3FA ; eventEnemySendId
  00049	3b c1		 cmp	 eax, ecx
  0004b	75 0e		 jne	 SHORT $LN7@lssproto_E

; 3249 : 	{
; 3250 : 		if ( result == 0 )

  0004d	83 7d 10 00	 cmp	 DWORD PTR _result$[ebp], 0
  00051	75 08		 jne	 SHORT $LN7@lssproto_E

; 3251 : 		{
; 3252 : 			eventEnemySendFlag = 0;

  00053	33 c0		 xor	 eax, eax
  00055	66 a3 00 00 00
	00		 mov	 WORD PTR ?eventEnemySendFlag@@3FA, ax ; eventEnemySendFlag
$LN7@lssproto_E:

; 3253 : 		}
; 3254 : 		//else
; 3255 : 		//{
; 3256 : 			// ??????process.cpp???
; 3257 : 		//}
; 3258 : 	}
; 3259 : }

  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
?lssproto_EV_recv@@YAXHHH@Z ENDP			; lssproto_EV_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_XYD_recv@@YAXHHHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_dir$ = 20						; size = 4
?lssproto_XYD_recv@@YAXHHHH@Z PROC			; lssproto_XYD_recv, COMDAT

; 4095 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4096 : 	updateMapArea();

  00003	e8 00 00 00 00	 call	 ?updateMapArea@@YAXXZ	; updateMapArea

; 4097 : 	setPcWarpPoint( x, y );

  00008	ff 75 10	 push	 DWORD PTR _y$[ebp]
  0000b	ff 75 0c	 push	 DWORD PTR _x$[ebp]
  0000e	e8 00 00 00 00	 call	 ?setPcWarpPoint@@YAXHH@Z ; setPcWarpPoint

; 4098 : 	setPcPoint();

  00013	e8 00 00 00 00	 call	 ?setPcPoint@@YAXXZ	; setPcPoint

; 4099 : 	dir = (dir+3) % 8;

  00018	8b 45 14	 mov	 eax, DWORD PTR _dir$[ebp]
  0001b	83 c0 03	 add	 eax, 3
  0001e	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00023	79 05		 jns	 SHORT $LN3@lssproto_X
  00025	48		 dec	 eax
  00026	83 c8 f8	 or	 eax, -8			; fffffff8H
  00029	40		 inc	 eax
$LN3@lssproto_X:

; 4100 : 	setPcDir( dir );

  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?setPcDir@@YAXH@Z	; setPcDir

; 4101 : 
; 4102 : 	//JLWG 2016.9.16 æ”¶åˆ°2å·åŒ…ï¼Œæˆ˜æ–—ç»“æŸï¼ŒåŽ»æŽ‰å¤´é¡¶æˆ˜æ–—vså›¾æ¡ˆ
; 4103 : 	pc.status &= (~CHR_STATUS_BATTLE);

  00030	81 25 a4 00 00
	00 ff fb ff ff	 and	 DWORD PTR ?pc@@3UPC@@A+164, -1025 ; fffffbffH

; 4104 : 
; 4105 : 	vsLookFlag = 0;

  0003a	33 c0		 xor	 eax, eax

; 4106 : 	JL_é”å®šäººç‰©(false);

  0003c	50		 push	 eax
  0003d	66 a3 00 00 00
	00		 mov	 WORD PTR ?vsLookFlag@@3FA, ax ; vsLookFlag
  00043	e8 00 00 00 00	 call	 ?JL_?ïÒìÑÚª@@YAX_N@Z	; JL_?ïÒìÑÚª
  00048	83 c4 10	 add	 esp, 16			; 00000010H

; 4107 : 
; 4108 : 	//JL fix 2017.9.18  æŠŠeoæ”¾åˆ°è¿™é‡Œå‘,å› ä¸ºåŽŸeoéœ€è¦SubProcNo=8æ—¶å‘,(battleProc.cpp line:1011)
; 4109 : 	//è€Œå¦‚æžœç”»é¢é€Ÿåº¦è¿‡å¿«,å¯èƒ½ä¼šä¸ç»è¿‡SubProcNo=8,å¯¼è‡´ä¸å‘eo,å¡ç”»é¢
; 4110 : 	//æš‚æ—¶å…ˆä¸ä¿®,ä¼šå‡ºçŽ°æˆ˜æ–—åŽç”»é¢è¢«æ¸…
; 4111 : 	//if (bNewServer)
; 4112 : 	//	lssproto_EO_send(sockfd, 0);
; 4113 : 	//else
; 4114 : 	//	old_lssproto_EO_send(sockfd, 0);
; 4115 : }

  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?lssproto_XYD_recv@@YAXHHHH@Z ENDP			; lssproto_XYD_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?lssproto_DENGON_recv@@YAXPADHH@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
_colors$ = 12						; size = 4
_nums$ = 16						; size = 4
?lssproto_DENGON_recv@@YAXPADHH@Z PROC			; lssproto_DENGON_recv, COMDAT

; 4706 : void lssproto_DENGON_recv(char *data, int colors, int nums){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4707 : 	extern int å…¬å‘Šæ•°é‡;
; 4708 : 	extern char å…¬å‘Šå†…å®¹[512];
; 4709 : 	extern int å…¬å‘Šé¢œè‰²;
; 4710 : 	extern int å…¬å‘Šæ—¶é—´;
; 4711 : 	å…¬å‘Šæ—¶é—´=0;
; 4712 : 	sprintf(å…¬å‘Šå†…å®¹, "%s", data);

  00003	ff 75 08	 push	 DWORD PTR _data$[ebp]
  00006	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ÍëÍ±??@@3HA, 0 ; ÍëÍ±??
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00015	68 00 00 00 00	 push	 OFFSET ?ÍëÍ±?é»@@3PADA	; ÍëÍ±?é»
  0001a	e8 00 00 00 00	 call	 _sprintf

; 4713 : 	å…¬å‘Šé¢œè‰² = colors;

  0001f	8b 45 0c	 mov	 eax, DWORD PTR _colors$[ebp]
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH
  00025	a3 00 00 00 00	 mov	 DWORD PTR ?ÍëÍ±?ßä@@3HA, eax ; ÍëÍ±?ßä

; 4714 : 	å…¬å‘Šæ•°é‡ = nums;

  0002a	8b 45 10	 mov	 eax, DWORD PTR _nums$[ebp]
  0002d	a3 00 00 00 00	 mov	 DWORD PTR ?ÍëÍ±?Õá@@3HA, eax ; ÍëÍ±?Õá

; 4715 : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?lssproto_DENGON_recv@@YAXPADHH@Z ENDP			; lssproto_DENGON_recv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?delCharProc@@YAHXZ
_TEXT	SEGMENT
?delCharProc@@YAHXZ PROC				; delCharProc, COMDAT

; 3157 : 	if ( netproc_sending == NETPROC_RECEIVED )

  00000	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?netproc_sending@@3HA, 2 ; netproc_sending
  00007	75 20		 jne	 SHORT $LN4@delCharPro

; 3158 : 	{
; 3159 : 		netproc_sending = NETPROC_NOTSEND;
; 3160 : 		if ( charDelStatus )

  00009	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR ?charDelStatus@@3FA, 0 ; charDelStatus
  00011	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00016	b9 01 00 00 00	 mov	 ecx, 1
  0001b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 0 ; netproc_sending
  00025	0f 45 c1	 cmovne	 eax, ecx

; 3173 : }

  00028	c3		 ret	 0
$LN4@delCharPro:

; 3161 : 		{
; 3162 : 			return 1;
; 3163 : 		}
; 3164 : 		else
; 3165 : 		{
; 3166 : 			return -2;
; 3167 : 		}
; 3168 : 	}
; 3169 : 
; 3170 : 	SETTIMEOUT2( NET_ERRMSG_DELETECHARTIMEOUT );

  00029	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  0002e	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?start_time@@3KA ; start_time
  00034	3d c0 27 09 00	 cmp	 eax, 600000		; 000927c0H
  00039	76 16		 jbe	 SHORT $LN5@delCharPro
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@ILDAKNL@?l?Q?Z?$KK?$NO?$PL?p?$LG?$DP?$DP?l?$KL?S?p?$KB?$KD@
  00040	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  00045	e8 00 00 00 00	 call	 _sprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	83 c8 ff	 or	 eax, -1

; 3173 : }

  00050	c3		 ret	 0
$LN5@delCharPro:

; 3171 : 
; 3172 : 	return 0;

  00051	33 c0		 xor	 eax, eax

; 3173 : }

  00053	c3		 ret	 0
?delCharProc@@YAHXZ ENDP				; delCharProc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?delCharStart@@YAXXZ
_TEXT	SEGMENT
?delCharStart@@YAXXZ PROC				; delCharStart, COMDAT

; 3142 : 	charDelStatus = 0;

  00000	33 c0		 xor	 eax, eax

; 3143 : 
; 3144 : 	if (bNewServer)

  00002	68 00 00 00 00	 push	 OFFSET ?gamestate_deletechar_charname@@3PADA ; gamestate_deletechar_charname
  00007	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  0000d	66 a3 00 00 00
	00		 mov	 WORD PTR ?charDelStatus@@3FA, ax ; charDelStatus
  00013	39 05 00 00 00
	00		 cmp	 DWORD PTR ?bNewServer@@3HA, eax ; bNewServer
  00019	74 07		 je	 SHORT $LN2@delCharSta

; 3145 : 		lssproto_CharDelete_send(sockfd, gamestate_deletechar_charname );

  0001b	e8 00 00 00 00	 call	 ?lssproto_CharDelete_send@@YAXHPAD@Z ; lssproto_CharDelete_send
  00020	eb 05		 jmp	 SHORT $LN5@delCharSta
$LN2@delCharSta:

; 3146 : 	else
; 3147 : 		old_lssproto_CharDelete_send(sockfd, gamestate_deletechar_charname );

  00022	e8 00 00 00 00	 call	 ?old_lssproto_CharDelete_send@@YAXHPAD@Z ; old_lssproto_CharDelete_send
$LN5@delCharSta:

; 3148 : 
; 3149 : 	SETSENDING;

  00027	83 c4 08	 add	 esp, 8
  0002a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 1 ; netproc_sending
  00034	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00039	a3 00 00 00 00	 mov	 DWORD PTR ?start_time@@3KA, eax ; start_time

; 3150 : }

  0003e	c3		 ret	 0
?delCharStart@@YAXXZ ENDP				; delCharStart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?chatStrSendForServer@@YAXPADH@Z
_TEXT	SEGMENT
_y$1$ = -2344						; size = 4
_m$ = -2340						; size = 1024
_dest$ = -1316						; size = 1024
_tmpMsg$ = -292						; size = 128
_tmp1$ = -164						; size = 128
_tellName$ = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_str$ = 8						; size = 4
_color$ = 12						; size = 4
?chatStrSendForServer@@YAXPADH@Z PROC			; chatStrSendForServer, COMDAT

; 2605 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 28 09 00
	00		 sub	 esp, 2344		; 00000928H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx

; 2606 : 	char dest[1024], m[1024];
; 2607 : 	int x, y;
; 2608 : #ifdef _FRIENDCHANNEL
; 2609 : 	char tmpMsg[128];
; 2610 : #endif
; 2611 : #ifdef _TELLCHANNEL
; 2612 : 	char tmp1[128] ;
; 2613 : #endif
; 2614 : 
; 2615 : #ifdef _CHAR_MANOR_DEBUG
; 2616 : 	if (strstr(str, ".å…‰çŽ¯")) {
; 2617 : 		int å…‰çŽ¯ID = 0;
; 2618 : 		å…‰çŽ¯ID = getIntegerToken(str, ' ', 2);
; 2619 : 		setCharmManor(pc.ptAct, å…‰çŽ¯ID);
; 2620 : 		return;
; 2621 : 	}
; 2622 : #endif
; 2623 : 
; 2624 : #ifdef _äººç‰©ç§°å·_DEBUG
; 2625 : 	if (strstr(str, ".ç§°å·")) {
; 2626 : 		int ç§°å·ID = 0;
; 2627 : 		ç§°å·ID = getIntegerToken(str, ' ', 2);
; 2628 : 		setCharmTitle(pc.ptAct, ç§°å·ID);
; 2629 : 		return;
; 2630 : 	}
; 2631 : #endif
; 2632 : 
; 2633 : 
; 2634 : #ifdef _SETTICK_COUNT
; 2635 : 	if ( fTalkTick == NULL || (GetTickCount() - *fTalkTick) > 60000 ){
; 2636 : 		FREE( fTalkTick);
; 2637 : #ifdef  _STONDEBUG_
; 2638 : 		g_iMallocCount--;
; 2639 : #endif
; 2640 : 		fTalkTick = (float *)MALLOC( sizeof(float));
; 2641 : #ifdef  _STONDEBUG_
; 2642 : 		g_iMallocCount++;
; 2643 : #endif
; 2644 : 		*fTalkTick = (float)0.00;
; 2645 : 	}
; 2646 : 	if ( (GetTickCount() - *fTalkTick) > 2500 ){
; 2647 : 		*fTalkTick = (float)GetTickCount();
; 2648 : 	}else{
; 2649 : 		return;
; 2650 : 	}
; 2651 : #endif
; 2652 : 	x = nowGx;

  00014	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?nowGx@@3HA ; nowGx

; 2653 : 	y = nowGy;
; 2654 : 	makeEscapeString( str, dest, sizeof(dest) );

  0001a	8d 85 dc fa ff
	ff		 lea	 eax, DWORD PTR _dest$[ebp]
  00020	56		 push	 esi
  00021	8b 75 08	 mov	 esi, DWORD PTR _str$[ebp]
  00024	57		 push	 edi
  00025	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?nowGy@@3HA ; nowGy
  0002b	68 00 04 00 00	 push	 1024			; 00000400H
  00030	50		 push	 eax
  00031	56		 push	 esi
  00032	89 bd d8 f6 ff
	ff		 mov	 DWORD PTR _y$1$[ebp], edi
  00038	e8 00 00 00 00	 call	 ?makeEscapeString@@YAPADPAD0H@Z ; makeEscapeString

; 2655 : 
; 2656 : #ifdef _TELLCHANNEL
; 2657 : 	getStringToken( str , ' ', 1, sizeof( tmp1 ) -1, tmp1 );

  0003d	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR _tmp1$[ebp]
  00043	50		 push	 eax
  00044	6a 7f		 push	 127			; 0000007fH
  00046	6a 01		 push	 1
  00048	6a 20		 push	 32			; 00000020H
  0004a	56		 push	 esi
  0004b	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken

; 2658 : 		char *found;
; 2659 : 		char tellName[32]={""};
; 2660 : 
; 2661 : 	switch (TalkMode){

  00050	a1 00 00 00 00	 mov	 eax, DWORD PTR ?TalkMode@@3HA ; TalkMode
  00055	0f 57 c0	 xorps	 xmm0, xmm0
  00058	83 c4 20	 add	 esp, 32			; 00000020H
  0005b	0f 11 45 dc	 movups	 XMMWORD PTR _tellName$[ebp], xmm0
  0005f	0f 11 45 ec	 movups	 XMMWORD PTR _tellName$[ebp+16], xmm0
  00063	83 f8 07	 cmp	 eax, 7
  00066	0f 87 ab 01 00
	00		 ja	 $LN2@chatStrSen
  0006c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN20@chatStrSen[eax*4]
$LN4@chatStrSen:

; 2662 : 	case 0:
; 2663 : 
; 2664 : #ifdef _CHANNEL_MODIFY
; 2665 : 	case 2:
; 2666 : #endif
; 2667 : 		sprintf( m, "P|%s", dest );

  00073	8d 85 dc fa ff
	ff		 lea	 eax, DWORD PTR _dest$[ebp]
  00079	50		 push	 eax
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_04BKLDHGDD@P?$HM?$CFs@

; 2668 : 		break;

  0007f	e9 84 01 00 00	 jmp	 $LN28@chatStrSen
$LN6@chatStrSen:

; 2669 : 	case 1:
; 2670 : 		if ( strcmp ( tmp1 , str ) == 0 || strlen(tmp1) > 16) {

  00084	8b ce		 mov	 ecx, esi
  00086	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR _tmp1$[ebp]
  0008c	0f 1f 40 00	 npad	 4
$LL21@chatStrSen:
  00090	8a 10		 mov	 dl, BYTE PTR [eax]
  00092	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00094	75 1a		 jne	 SHORT $LN22@chatStrSen
  00096	84 d2		 test	 dl, dl
  00098	74 12		 je	 SHORT $LN23@chatStrSen
  0009a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0009d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000a0	75 0e		 jne	 SHORT $LN22@chatStrSen
  000a2	83 c0 02	 add	 eax, 2
  000a5	83 c1 02	 add	 ecx, 2
  000a8	84 d2		 test	 dl, dl
  000aa	75 e4		 jne	 SHORT $LL21@chatStrSen
$LN23@chatStrSen:
  000ac	33 c0		 xor	 eax, eax
  000ae	eb 05		 jmp	 SHORT $LN24@chatStrSen
$LN22@chatStrSen:
  000b0	1b c0		 sbb	 eax, eax
  000b2	83 c8 01	 or	 eax, 1
$LN24@chatStrSen:
  000b5	85 c0		 test	 eax, eax
  000b7	0f 84 95 00 00
	00		 je	 $LN8@chatStrSen
  000bd	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _tmp1$[ebp]
  000c3	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL25@chatStrSen:
  000c6	8a 01		 mov	 al, BYTE PTR [ecx]
  000c8	41		 inc	 ecx
  000c9	84 c0		 test	 al, al
  000cb	75 f9		 jne	 SHORT $LL25@chatStrSen
  000cd	2b ca		 sub	 ecx, edx
  000cf	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000d2	77 7e		 ja	 SHORT $LN8@chatStrSen
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h

; 520  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  000d4	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  000d9	56		 push	 esi
  000da	e8 00 00 00 00	 call	 _strstr
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp

; 2675 : 		if ( found = strstr( str, " " )){

  000df	8b c8		 mov	 ecx, eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\string.h

; 520  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  000e1	83 c4 08	 add	 esp, 8
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp

; 2675 : 		if ( found = strstr( str, " " )){

  000e4	85 c9		 test	 ecx, ecx
  000e6	74 37		 je	 SHORT $LN9@chatStrSen

; 2676 : 			strncpy(tellName, str, strlen(str) - strlen(found));

  000e8	8b d6		 mov	 edx, esi
  000ea	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
  000ed	0f 1f 00	 npad	 3
$LL26@chatStrSen:
  000f0	8a 02		 mov	 al, BYTE PTR [edx]
  000f2	42		 inc	 edx
  000f3	84 c0		 test	 al, al
  000f5	75 f9		 jne	 SHORT $LL26@chatStrSen
  000f7	2b d7		 sub	 edx, edi
  000f9	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
  000fc	0f 1f 40 00	 npad	 4
$LL27@chatStrSen:
  00100	8a 01		 mov	 al, BYTE PTR [ecx]
  00102	41		 inc	 ecx
  00103	84 c0		 test	 al, al
  00105	75 f9		 jne	 SHORT $LL27@chatStrSen
  00107	2b cf		 sub	 ecx, edi
  00109	8d 45 dc	 lea	 eax, DWORD PTR _tellName$[ebp]
  0010c	2b d1		 sub	 edx, ecx
  0010e	52		 push	 edx
  0010f	56		 push	 esi
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 _strncpy
  00116	8b bd d8 f6 ff
	ff		 mov	 edi, DWORD PTR _y$1$[ebp]
  0011c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@chatStrSen:

; 2677 : 		}
; 2678 : 		sprintf( secretName, "%s ",tellName);

  0011f	8d 45 dc	 lea	 eax, DWORD PTR _tellName$[ebp]
  00122	50		 push	 eax
  00123	68 00 00 00 00	 push	 OFFSET ??_C@_03IKGEINEE@?$CFs?5@
  00128	68 00 00 00 00	 push	 OFFSET ?secretName@@3PADA ; secretName
  0012d	e8 00 00 00 00	 call	 _sprintf

; 2679 : 		sprintf( m, "P|/tell %s", dest );

  00132	8d 85 dc fa ff
	ff		 lea	 eax, DWORD PTR _dest$[ebp]
  00138	50		 push	 eax
  00139	8d 85 dc f6 ff
	ff		 lea	 eax, DWORD PTR _m$[ebp]
  0013f	68 00 00 00 00	 push	 OFFSET ??_C@_0L@BFDNBDBG@P?$HM?1tell?5?$CFs@
  00144	50		 push	 eax
  00145	e8 00 00 00 00	 call	 _sprintf
  0014a	83 c4 18	 add	 esp, 24			; 00000018H

; 2680 : 		break;

  0014d	e9 c5 00 00 00	 jmp	 $LN2@chatStrSen
$LN8@chatStrSen:

; 2671 : 			StockChatBufferLine(  "æŒ‡ä»¤ä½¿ç”¨æ ¼å¼ä¸æ­£ç¡®ï¼" , FONT_PAL_RED);

  00152	6a 00		 push	 0
  00154	6a 06		 push	 6
  00156	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@BFJFDKGC@?r?$KG?V?$LF?$NO?E?i?D?L?$KL?c?R?$NM?t?o?a?$DP?$KD?$KB@
  0015b	e8 00 00 00 00	 call	 ?StockChatBufferLine@@YAXPADEH@Z ; StockChatBufferLine
  00160	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2672 : 			strcpy(secretName,"");

  00163	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?secretName@@3PADA, 0
  0016a	5f		 pop	 edi

; 2720 : }

  0016b	5e		 pop	 esi
  0016c	5b		 pop	 ebx
  0016d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00170	33 cd		 xor	 ecx, ebp
  00172	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00177	8b e5		 mov	 esp, ebp
  00179	5d		 pop	 ebp
  0017a	c3		 ret	 0
$LN10@chatStrSen:

; 2681 : #ifndef _CHANNEL_MODIFY
; 2682 : 	#ifdef _FRIENDCHANNEL
; 2683 : 		case 2:
; 2684 : 			sprintf(tmpMsg,"T|%s : %s",pc.name,dest);
; 2685 : 			lssproto_CHATROOM_send (sockfd ,tmpMsg);
; 2686 : 			return;
; 2687 : 	#endif
; 2688 : #else
; 2689 : 		case 3:
; 2690 : 			sprintf(m,"P|/FM%s",dest);

  0017b	8d 85 dc fa ff
	ff		 lea	 eax, DWORD PTR _dest$[ebp]
  00181	50		 push	 eax
  00182	68 00 00 00 00	 push	 OFFSET ??_C@_07JGJAFNNL@P?$HM?1FM?$CFs@

; 2691 : 			break;

  00187	eb 7f		 jmp	 SHORT $LN28@chatStrSen
$LN11@chatStrSen:

; 2692 : 		case 4:
; 2693 : 			sprintf(m,"P|/OCC%sï¼š%s",pc.name,dest);

  00189	8d 85 dc fa ff
	ff		 lea	 eax, DWORD PTR _dest$[ebp]
  0018f	50		 push	 eax
  00190	68 70 00 00 00	 push	 OFFSET ?pc@@3UPC@@A+112
  00195	8d 85 dc f6 ff
	ff		 lea	 eax, DWORD PTR _m$[ebp]
  0019b	68 00 00 00 00	 push	 OFFSET ??_C@_0N@INHGBDFL@P?$HM?1OCC?$CFs?$KD?$LK?$CFs@
  001a0	50		 push	 eax
  001a1	e8 00 00 00 00	 call	 _sprintf
  001a6	83 c4 10	 add	 esp, 16			; 00000010H

; 2694 : 			break;

  001a9	eb 6c		 jmp	 SHORT $LN2@chatStrSen
$LN12@chatStrSen:

; 2695 : #ifdef _CHATROOMPROTOCOL
; 2696 : 		case 5:
; 2697 : 			sprintf(tmpMsg,"T|%sï¼š%s",pc.name,dest);

  001ab	8d 85 dc fa ff
	ff		 lea	 eax, DWORD PTR _dest$[ebp]
  001b1	50		 push	 eax
  001b2	68 70 00 00 00	 push	 OFFSET ?pc@@3UPC@@A+112
  001b7	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _tmpMsg$[ebp]
  001bd	68 00 00 00 00	 push	 OFFSET ??_C@_08KCFIPDCG@T?$HM?$CFs?$KD?$LK?$CFs@
  001c2	50		 push	 eax
  001c3	e8 00 00 00 00	 call	 _sprintf

; 2698 : 			lssproto_CHATROOM_send (sockfd ,tmpMsg);

  001c8	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _tmpMsg$[ebp]
  001ce	50		 push	 eax
  001cf	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  001d5	e8 00 00 00 00	 call	 ?lssproto_CHATROOM_send@@YAXHPAD@Z ; lssproto_CHATROOM_send

; 2720 : }

  001da	83 c4 18	 add	 esp, 24			; 00000018H
  001dd	5f		 pop	 edi
  001de	5e		 pop	 esi
  001df	5b		 pop	 ebx
  001e0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e3	33 cd		 xor	 ecx, ebp
  001e5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ea	8b e5		 mov	 esp, ebp
  001ec	5d		 pop	 ebp
  001ed	c3		 ret	 0
$LN13@chatStrSen:

; 2699 : 			return;
; 2700 : #endif
; 2701 : #ifdef _CHATWORLDWIDEPROTOCOL
; 2702 : 		case 6:
; 2703 : 			sprintf(m, "P|/WD %s", dest);

  001ee	8d 85 dc fa ff
	ff		 lea	 eax, DWORD PTR _dest$[ebp]
  001f4	50		 push	 eax
  001f5	68 00 00 00 00	 push	 OFFSET ??_C@_08IPPAKAEL@P?$HM?1WD?5?$CFs@

; 2704 : 			break;

  001fa	eb 0c		 jmp	 SHORT $LN28@chatStrSen
$LN14@chatStrSen:

; 2705 : #endif
; 2706 : #ifdef _NB_CHANNEL_ALLSERV
; 2707 : 		case 7:
; 2708 : 			sprintf(m, "P|/XQ %s", dest);

  001fc	8d 85 dc fa ff
	ff		 lea	 eax, DWORD PTR _dest$[ebp]
  00202	50		 push	 eax
  00203	68 00 00 00 00	 push	 OFFSET ??_C@_08NGKGAKGM@P?$HM?1XQ?5?$CFs@
$LN28@chatStrSen:

; 2709 : 			break;
; 2710 : #endif
; 2711 : #endif
; 2712 : 	}
; 2713 : #else
; 2714 : 	sprintf( m, "P|%s", dest );
; 2715 : #endif
; 2716 : 	if (bNewServer)

  00208	8d 85 dc f6 ff
	ff		 lea	 eax, DWORD PTR _m$[ebp]
  0020e	50		 push	 eax
  0020f	e8 00 00 00 00	 call	 _sprintf
  00214	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@chatStrSen:
  00217	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bNewServer@@3HA, 0 ; bNewServer
  0021e	8d 85 dc f6 ff
	ff		 lea	 eax, DWORD PTR _m$[ebp]
  00224	ff 35 00 00 00
	00		 push	 DWORD PTR ?NowMaxVoice@@3HA ; NowMaxVoice
  0022a	ff 75 0c	 push	 DWORD PTR _color$[ebp]
  0022d	50		 push	 eax
  0022e	57		 push	 edi
  0022f	53		 push	 ebx
  00230	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  00236	74 19		 je	 SHORT $LN15@chatStrSen

; 2717 : 		lssproto_TK_send(sockfd, x, y, m, color, NowMaxVoice );

  00238	e8 00 00 00 00	 call	 ?lssproto_TK_send@@YAXHHHPADHH@Z ; lssproto_TK_send

; 2720 : }

  0023d	83 c4 18	 add	 esp, 24			; 00000018H
  00240	5f		 pop	 edi
  00241	5e		 pop	 esi
  00242	5b		 pop	 ebx
  00243	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00246	33 cd		 xor	 ecx, ebp
  00248	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0024d	8b e5		 mov	 esp, ebp
  0024f	5d		 pop	 ebp
  00250	c3		 ret	 0
$LN15@chatStrSen:

; 2718 : 	else
; 2719 : 		old_lssproto_TK_send(sockfd, x, y, m, color, NowMaxVoice );

  00251	e8 00 00 00 00	 call	 ?old_lssproto_TK_send@@YAXHHHPADHH@Z ; old_lssproto_TK_send

; 2720 : }

  00256	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00259	83 c4 18	 add	 esp, 24			; 00000018H
  0025c	33 cd		 xor	 ecx, ebp
  0025e	5f		 pop	 edi
  0025f	5e		 pop	 esi
  00260	5b		 pop	 ebx
  00261	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00266	8b e5		 mov	 esp, ebp
  00268	5d		 pop	 ebp
  00269	c3		 ret	 0
  0026a	66 90		 npad	 2
$LN20@chatStrSen:
  0026c	00 00 00 00	 DD	 $LN4@chatStrSen
  00270	00 00 00 00	 DD	 $LN6@chatStrSen
  00274	00 00 00 00	 DD	 $LN4@chatStrSen
  00278	00 00 00 00	 DD	 $LN10@chatStrSen
  0027c	00 00 00 00	 DD	 $LN11@chatStrSen
  00280	00 00 00 00	 DD	 $LN12@chatStrSen
  00284	00 00 00 00	 DD	 $LN13@chatStrSen
  00288	00 00 00 00	 DD	 $LN14@chatStrSen
?chatStrSendForServer@@YAXPADH@Z ENDP			; chatStrSendForServer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?noChecksumWalkSendForServer@@YAXHHPAD@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_direction$ = 16					; size = 4
?noChecksumWalkSendForServer@@YAXHHPAD@Z PROC		; noChecksumWalkSendForServer, COMDAT

; 2583 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2584 : //#ifdef __NEW_PROTOCOL
; 2585 : 	if (bNewServer)

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bNewServer@@3HA, 0 ; bNewServer
  0000a	ff 75 10	 push	 DWORD PTR _direction$[ebp]
  0000d	ff 75 0c	 push	 DWORD PTR _y$[ebp]
  00010	ff 75 08	 push	 DWORD PTR _x$[ebp]
  00013	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  00019	74 0a		 je	 SHORT $LN2@noChecksum

; 2586 : 		lssproto_W2_send(sockfd , x, y, direction );

  0001b	e8 00 00 00 00	 call	 ?lssproto_W2_send@@YAXHHHPAD@Z ; lssproto_W2_send

; 2590 : //#endif
; 2591 : }

  00020	83 c4 10	 add	 esp, 16			; 00000010H
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
$LN2@noChecksum:

; 2587 : 	else
; 2588 : //#else
; 2589 : 		old_lssproto_w_send(sockfd , x, y, direction );

  00025	e8 00 00 00 00	 call	 ?old_lssproto_w_send@@YAXHHHPAD@Z ; old_lssproto_w_send

; 2590 : //#endif
; 2591 : }

  0002a	83 c4 10	 add	 esp, 16			; 00000010H
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?noChecksumWalkSendForServer@@YAXHHPAD@Z ENDP		; noChecksumWalkSendForServer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?walkSendForServer@@YAXHHPAD@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_direction$ = 16					; size = 4
?walkSendForServer@@YAXHHPAD@Z PROC			; walkSendForServer, COMDAT

; 2553 : void walkSendForServer( int x, int y, char *direction ){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2554 : #ifdef _MIND_ICON
; 2555 : 
; 2556 : 	//JL fix 2017.8.13 åˆ‡æ¢åœ°å›¾çš„æ—¶å€™å´©æºƒ(å¯èƒ½è¿›äº†æˆ˜æ–—)ï¼Œæ­¤æ—¶pc.ptAct = NULL
; 2557 : 	if (pc.ptAct == NULL) return;

  00004	8b 35 ec 50 00
	00		 mov	 esi, DWORD PTR ?pc@@3UPC@@A+20716
  0000a	85 f6		 test	 esi, esi
  0000c	0f 84 83 00 00
	00		 je	 $LN6@walkSendFo

; 2558 : 	if ( (pc.ptAct->sMindIcon == SPR_asleep) ||
; 2559 : 		(pc.ptAct->sMindIcon == SPR_cafe)   ||

  00012	8b 86 c0 01 00
	00		 mov	 eax, DWORD PTR [esi+448]
  00018	3d aa 8b 01 00	 cmp	 eax, 101290		; 00018baaH
  0001d	74 0e		 je	 SHORT $LN4@walkSendFo
  0001f	3d ae 8b 01 00	 cmp	 eax, 101294		; 00018baeH
  00024	74 07		 je	 SHORT $LN4@walkSendFo
  00026	3d a8 8b 01 00	 cmp	 eax, 101288		; 00018ba8H
  0002b	75 3d		 jne	 SHORT $LN3@walkSendFo
$LN4@walkSendFo:

; 2560 : 		(pc.ptAct->sMindIcon == SPR_accent) ){
; 2561 : 			CHAREXTRA *ext;
; 2562 : 			ext = (CHAREXTRA *)pc.ptAct->pYobi;

  0002d	8b 76 0c	 mov	 esi, DWORD PTR [esi+12]

; 2563 : 
; 2564 : 			DeathAction( ext->ptMindIcon);

  00030	ff 76 10	 push	 DWORD PTR [esi+16]
  00033	e8 00 00 00 00	 call	 ?DeathAction@@YAXPAUaction@@@Z ; DeathAction

; 2565 : 			ext->ptMindIcon = NULL;

  00038	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 2566 : 			pc.ptAct->sMindIcon = 0;

  0003f	a1 ec 50 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+20716

; 2567 : 			
; 2568 : 			lssproto_MA_send(sockfd, nowGx, nowGy, 0);

  00044	6a 00		 push	 0
  00046	c7 80 c0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+448], 0
  00050	ff 35 00 00 00
	00		 push	 DWORD PTR ?nowGy@@3HA	; nowGy
  00056	ff 35 00 00 00
	00		 push	 DWORD PTR ?nowGx@@3HA	; nowGx
  0005c	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  00062	e8 00 00 00 00	 call	 ?lssproto_MA_send@@YAXHHHH@Z ; lssproto_MA_send
  00067	83 c4 14	 add	 esp, 20			; 00000014H
$LN3@walkSendFo:

; 2569 : 	}
; 2570 : #endif
; 2571 : #ifdef _REMAKE_20
; 2572 : 	if (!ChangedLibrary()) 
; 2573 : 		RestoreLibrary();
; 2574 : #endif
; 2575 : 	if (bNewServer)

  0006a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bNewServer@@3HA, 0 ; bNewServer
  00071	ff 75 10	 push	 DWORD PTR _direction$[ebp]
  00074	ff 75 0c	 push	 DWORD PTR _y$[ebp]
  00077	ff 75 08	 push	 DWORD PTR _x$[ebp]
  0007a	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  00080	74 0b		 je	 SHORT $LN5@walkSendFo

; 2576 : 		lssproto_W2_send(sockfd , x, y, direction );

  00082	e8 00 00 00 00	 call	 ?lssproto_W2_send@@YAXHHHPAD@Z ; lssproto_W2_send

; 2579 : }

  00087	83 c4 10	 add	 esp, 16			; 00000010H
  0008a	5e		 pop	 esi
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
$LN5@walkSendFo:

; 2577 : 	else
; 2578 : 		old_lssproto_W_send(sockfd , x, y, direction );

  0008d	e8 00 00 00 00	 call	 ?old_lssproto_W_send@@YAXHHHPAD@Z ; old_lssproto_W_send

; 2579 : }

  00092	83 c4 10	 add	 esp, 16			; 00000010H
$LN6@walkSendFo:
  00095	5e		 pop	 esi
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
?walkSendForServer@@YAXHHPAD@Z ENDP			; walkSendForServer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?charLogoutProc@@YAHXZ
_TEXT	SEGMENT
?charLogoutProc@@YAHXZ PROC				; charLogoutProc, COMDAT

; 840  : 	if (netproc_sending == NETPROC_RECEIVED)

  00000	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?netproc_sending@@3HA, 2 ; netproc_sending
  00007	75 1f		 jne	 SHORT $LN4@charLogout

; 841  : 	{
; 842  : 		netproc_sending = NETPROC_NOTSEND;
; 843  : 		if (charLogoutStatus == 1)

  00009	b9 01 00 00 00	 mov	 ecx, 1
  0000e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 0 ; netproc_sending
  00018	66 39 0d 00 00
	00 00		 cmp	 WORD PTR ?charLogoutStatus@@3FA, cx ; charLogoutStatus
  0001f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00024	0f 44 c1	 cmove	 eax, ecx

; 850  : }

  00027	c3		 ret	 0
$LN4@charLogout:

; 844  : 			return 1;
; 845  : 		else
; 846  : 			return -2;
; 847  :     }
; 848  : 	SETTIMEOUT2(NET_ERRMSG_LOGOUTTIMEOUT);

  00028	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  0002d	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?start_time@@3KA ; start_time
  00033	3d c0 27 09 00	 cmp	 eax, 600000		; 000927c0H
  00038	76 16		 jbe	 SHORT $LN5@charLogout
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@KHEOLEJA@?T?t?u?s?$DP?W?b?$DP?$DP?l?$KL?S?p?$KB?$KD@
  0003f	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  00044	e8 00 00 00 00	 call	 _sprintf
  00049	83 c4 08	 add	 esp, 8
  0004c	83 c8 ff	 or	 eax, -1

; 850  : }

  0004f	c3		 ret	 0
$LN5@charLogout:

; 849  : 	return 0;

  00050	33 c0		 xor	 eax, eax

; 850  : }

  00052	c3		 ret	 0
?charLogoutProc@@YAHXZ ENDP				; charLogoutProc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?charLogoutStart@@YAXXZ
_TEXT	SEGMENT
?charLogoutStart@@YAXXZ PROC				; charLogoutStart, COMDAT

; 830  : 	charLogoutStatus = 0;

  00000	33 c0		 xor	 eax, eax
  00002	66 a3 00 00 00
	00		 mov	 WORD PTR ?charLogoutStatus@@3FA, ax ; charLogoutStatus

; 831  : 	if (bNewServer)

  00008	39 05 00 00 00
	00		 cmp	 DWORD PTR ?bNewServer@@3HA, eax ; bNewServer
  0000e	74 12		 je	 SHORT $LN2@charLogout

; 832  : 		lssproto_CharLogout_send(sockfd, 1);

  00010	6a 01		 push	 1
  00012	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  00018	e8 00 00 00 00	 call	 ?lssproto_CharLogout_send@@YAXHH@Z ; lssproto_CharLogout_send
  0001d	83 c4 08	 add	 esp, 8
  00020	eb 0e		 jmp	 SHORT $LN3@charLogout
$LN2@charLogout:

; 833  : 	else
; 834  : 		old_lssproto_CharLogout_send(sockfd);

  00022	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  00028	e8 00 00 00 00	 call	 ?old_lssproto_CharLogout_send@@YAXH@Z ; old_lssproto_CharLogout_send
  0002d	83 c4 04	 add	 esp, 4
$LN3@charLogout:

; 835  : 	SETSENDING;

  00030	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 1 ; netproc_sending
  0003a	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  0003f	a3 00 00 00 00	 mov	 DWORD PTR ?start_time@@3KA, eax ; start_time

; 836  : }

  00044	c3		 ret	 0
?charLogoutStart@@YAXXZ ENDP				; charLogoutStart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?createNewCharProc@@YAHXZ
_TEXT	SEGMENT
?createNewCharProc@@YAHXZ PROC				; createNewCharProc, COMDAT

; 3098 : 	if ( netproc_sending == NETPROC_RECEIVED )

  00000	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?netproc_sending@@3HA, 2 ; netproc_sending
  00007	75 1f		 jne	 SHORT $LN4@createNewC

; 3099 : 	{
; 3100 : 		netproc_sending = NETPROC_NOTSEND;
; 3101 : 		if ( newCharStatus == 1 )

  00009	b9 01 00 00 00	 mov	 ecx, 1
  0000e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 0 ; netproc_sending
  00018	66 39 0d 00 00
	00 00		 cmp	 WORD PTR ?newCharStatus@@3FA, cx ; newCharStatus
  0001f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00024	0f 44 c1	 cmove	 eax, ecx

; 3114 : }

  00027	c3		 ret	 0
$LN4@createNewC:

; 3102 : 		{
; 3103 : 			return 1;
; 3104 : 		}
; 3105 : 		else
; 3106 : 		{
; 3107 : 			return -2;
; 3108 : 		}
; 3109 :     }
; 3110 : 
; 3111 : 	SETTIMEOUT2( NET_ERRMSG_CREATECHARTIMEOUT );

  00028	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  0002d	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?start_time@@3KA ; start_time
  00033	3d c0 27 09 00	 cmp	 eax, 600000		; 000927c0H
  00038	76 16		 jbe	 SHORT $LN5@createNewC
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JFAECEMN@?l?Q?Z?$KK?p?$KE?m?B?$DP?$DP?l?$KL?S?p?$KB?$KD@
  0003f	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  00044	e8 00 00 00 00	 call	 _sprintf
  00049	83 c4 08	 add	 esp, 8
  0004c	83 c8 ff	 or	 eax, -1

; 3114 : }

  0004f	c3		 ret	 0
$LN5@createNewC:

; 3112 : 
; 3113 : 	return 0;

  00050	33 c0		 xor	 eax, eax

; 3114 : }

  00052	c3		 ret	 0
?createNewCharProc@@YAHXZ ENDP				; createNewCharProc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?createNewCharStart@@YAXXZ
_TEXT	SEGMENT
?createNewCharStart@@YAXXZ PROC				; createNewCharStart, COMDAT

; 3074 : 	newCharStatus = 0;
; 3075 : 
; 3076 : 	// ????îŸ•î”¼?î–º??î˜‹???????????
; 3077 : 	if (bNewServer)

  00000	ff 35 00 00 00
	00		 push	 DWORD PTR ?newCharacterHomeTown@@3HA ; newCharacterHomeTown
  00006	33 c0		 xor	 eax, eax
  00008	ff 35 00 00 00
	00		 push	 DWORD PTR ?newCharacterWind@@3HA ; newCharacterWind
  0000e	39 05 00 00 00
	00		 cmp	 DWORD PTR ?bNewServer@@3HA, eax ; bNewServer
  00014	ff 35 00 00 00
	00		 push	 DWORD PTR ?newCharacterFire@@3HA ; newCharacterFire
  0001a	66 a3 00 00 00
	00		 mov	 WORD PTR ?newCharStatus@@3FA, ax ; newCharStatus
  00020	ff 35 00 00 00
	00		 push	 DWORD PTR ?newCharacterWater@@3HA ; newCharacterWater
  00026	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?selectPcNo@@3FA ; selectPcNo
  0002d	ff 35 00 00 00
	00		 push	 DWORD PTR ?newCharacterEarth@@3HA ; newCharacterEarth
  00033	ff 35 00 00 00
	00		 push	 DWORD PTR ?newCharacterDex@@3HA ; newCharacterDex
  00039	ff 35 00 00 00
	00		 push	 DWORD PTR ?newCharacterTgh@@3HA ; newCharacterTgh
  0003f	ff 35 00 00 00
	00		 push	 DWORD PTR ?newCharacterStr@@3HA ; newCharacterStr
  00045	ff 35 00 00 00
	00		 push	 DWORD PTR ?newCharacterVit@@3HA ; newCharacterVit
  0004b	ff 35 00 00 00
	00		 push	 DWORD PTR ?newCharacterFaceGraNo@@3HA ; newCharacterFaceGraNo
  00051	ff 35 00 00 00
	00		 push	 DWORD PTR ?newCharacterGraNo@@3HA ; newCharacterGraNo
  00057	68 00 00 00 00	 push	 OFFSET ?newCharacterName@@3PADA ; newCharacterName
  0005c	50		 push	 eax
  0005d	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  00063	74 07		 je	 SHORT $LN2@createNewC

; 3078 : 		lssproto_CreateNewChar_send(sockfd, selectPcNo, newCharacterName,

  00065	e8 00 00 00 00	 call	 ?lssproto_CreateNewChar_send@@YAXHHPADHHHHHHHHHHH@Z ; lssproto_CreateNewChar_send
  0006a	eb 05		 jmp	 SHORT $LN5@createNewC
$LN2@createNewC:

; 3079 : 			newCharacterGraNo, newCharacterFaceGraNo,
; 3080 : 			newCharacterVit, newCharacterStr, newCharacterTgh, newCharacterDex,
; 3081 : 			newCharacterEarth, newCharacterWater, newCharacterFire, newCharacterWind,
; 3082 : 			newCharacterHomeTown );
; 3083 : 	else
; 3084 : 		old_lssproto_CreateNewChar_send(sockfd, selectPcNo, newCharacterName,

  0006c	e8 00 00 00 00	 call	 ?old_lssproto_CreateNewChar_send@@YAXHHPADHHHHHHHHHHH@Z ; old_lssproto_CreateNewChar_send
$LN5@createNewC:

; 3085 : 			newCharacterGraNo, newCharacterFaceGraNo,
; 3086 : 			newCharacterVit, newCharacterStr, newCharacterTgh, newCharacterDex,
; 3087 : 			newCharacterEarth, newCharacterWater, newCharacterFire, newCharacterWind,
; 3088 : 			newCharacterHomeTown );
; 3089 : 
; 3090 : 	SETSENDING;

  00071	83 c4 38	 add	 esp, 56			; 00000038H
  00074	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 1 ; netproc_sending
  0007e	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00083	a3 00 00 00 00	 mov	 DWORD PTR ?start_time@@3KA, eax ; start_time

; 3091 : }

  00088	c3		 ret	 0
?createNewCharStart@@YAXXZ ENDP				; createNewCharStart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?charLoginProc@@YAHXZ
_TEXT	SEGMENT
?charLoginProc@@YAHXZ PROC				; charLoginProc, COMDAT

; 775  : 	SendCount = 30;
; 776  : 	tradeStatus = 0;

  00000	33 c0		 xor	 eax, eax
  00002	c7 05 00 00 00
	00 1e 00 00 00	 mov	 DWORD PTR ?SendCount@@3HA, 30 ; SendCount, 0000001eH
  0000c	66 a3 00 00 00
	00		 mov	 WORD PTR ?tradeStatus@@3FA, ax ; tradeStatus

; 777  : 	if (!server_choosed)

  00012	39 05 00 00 00
	00		 cmp	 DWORD PTR ?server_choosed@@3HA, eax ; server_choosed
  00018	74 57		 je	 SHORT $LN8@charLoginP

; 778  : 		return 0;
; 779  : 	if (netproc_sending == NETPROC_RECEIVED){

  0001a	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?netproc_sending@@3HA, 2 ; netproc_sending
  00021	75 26		 jne	 SHORT $LN7@charLoginP

; 780  : 		netproc_sending = NETPROC_NOTSEND;
; 781  : 		if (charLoginStatus == 1)

  00023	66 83 3d 00 00
	00 00 01	 cmp	 WORD PTR ?charLoginStatus@@3FA, 1 ; charLoginStatus
  0002b	a3 00 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, eax ; netproc_sending
  00030	75 06		 jne	 SHORT $LN4@charLoginP

; 782  : 			return 1;

  00032	b8 01 00 00 00	 mov	 eax, 1

; 793  : }

  00037	c3		 ret	 0
$LN4@charLoginP:

; 783  : 		else
; 784  : #ifdef _NEW_WGS_MSG				// WON ADD WGSçš„æ–°è§†çª—
; 785  : 			if (ERROR_MESSAGE != 0)

  00038	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ERROR_MESSAGE@@3HA ; ERROR_MESSAGE
  0003e	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00043	85 c9		 test	 ecx, ecx
  00045	0f 45 c1	 cmovne	 eax, ecx

; 793  : }

  00048	c3		 ret	 0
$LN7@charLoginP:

; 786  : 				return ERROR_MESSAGE;
; 787  : 			else
; 788  : #endif
; 789  : 				return -2;
; 790  : 	}
; 791  : 	SETTIMEOUT2(NET_ERRMSG_LOGINTIMEOUT);

  00049	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  0004e	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?start_time@@3KA ; start_time
  00054	3d c0 27 09 00	 cmp	 eax, 600000		; 000927c0H
  00059	76 16		 jbe	 SHORT $LN8@charLoginP
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFEMHLAM@?T?t?l?$PN?$DP?W?b?$DP?$DP?l?$KL?S?p?$KB?$KD@
  00060	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  00065	e8 00 00 00 00	 call	 _sprintf
  0006a	83 c4 08	 add	 esp, 8
  0006d	83 c8 ff	 or	 eax, -1

; 793  : }

  00070	c3		 ret	 0
$LN8@charLoginP:

; 792  : 	return 0;

  00071	33 c0		 xor	 eax, eax

; 793  : }

  00073	c3		 ret	 0
?charLoginProc@@YAHXZ ENDP				; charLoginProc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?charLoginStart@@YAXXZ
_TEXT	SEGMENT
?charLoginStart@@YAXXZ PROC				; charLoginStart, COMDAT

; 763  : 	charLoginStatus = 0;

  00000	33 c0		 xor	 eax, eax

; 764  : #ifdef _NEW_WGS_MSG				// WON ADD WGSçš„æ–°è§†çª—
; 765  : 	ERROR_MESSAGE = 0;
; 766  : #endif
; 767  : 	if (bNewServer)

  00002	68 00 00 00 00	 push	 OFFSET ?gamestate_login_charname@@3PADA ; gamestate_login_charname
  00007	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  0000d	66 a3 00 00 00
	00		 mov	 WORD PTR ?charLoginStatus@@3FA, ax ; charLoginStatus
  00013	a3 00 00 00 00	 mov	 DWORD PTR ?ERROR_MESSAGE@@3HA, eax ; ERROR_MESSAGE
  00018	39 05 00 00 00
	00		 cmp	 DWORD PTR ?bNewServer@@3HA, eax ; bNewServer
  0001e	74 07		 je	 SHORT $LN2@charLoginS

; 768  : 		lssproto_CharLogin_send(sockfd, gamestate_login_charname);

  00020	e8 00 00 00 00	 call	 ?lssproto_CharLogin_send@@YAXHPAD@Z ; lssproto_CharLogin_send
  00025	eb 05		 jmp	 SHORT $LN5@charLoginS
$LN2@charLoginS:

; 769  : 	else
; 770  : 		old_lssproto_CharLogin_send(sockfd, gamestate_login_charname);

  00027	e8 00 00 00 00	 call	 ?old_lssproto_CharLogin_send@@YAXHPAD@Z ; old_lssproto_CharLogin_send
$LN5@charLoginS:

; 771  : 	SETSENDING;

  0002c	83 c4 08	 add	 esp, 8
  0002f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 1 ; netproc_sending
  00039	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  0003e	a3 00 00 00 00	 mov	 DWORD PTR ?start_time@@3KA, eax ; start_time

; 772  : }

  00043	c3		 ret	 0
?charLoginStart@@YAXXZ ENDP				; charLoginStart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?charListProc@@YAHXZ
_TEXT	SEGMENT
?charListProc@@YAHXZ PROC				; charListProc, COMDAT

; 675  : 	if (netproc_sending == NETPROC_RECEIVED){

  00000	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?netproc_sending@@3HA, 2 ; netproc_sending
  00007	75 47		 jne	 SHORT $LN10@charListPr

; 676  : 		netproc_sending = NETPROC_NOTSEND;
; 677  : 		if (charListStatus == 1)

  00009	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR ?charListStatus@@3FA ; charListStatus
  00010	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 0 ; netproc_sending
  0001a	66 83 f9 01	 cmp	 cx, 1
  0001e	75 06		 jne	 SHORT $LN3@charListPr

; 678  : 			return 1;

  00020	b8 01 00 00 00	 mov	 eax, 1

; 694  : }

  00025	c3		 ret	 0
$LN3@charListPr:

; 679  : 		else if (charListStatus == 2)

  00026	66 83 f9 02	 cmp	 cx, 2
  0002a	75 06		 jne	 SHORT $LN5@charListPr

; 680  : 			return -3;

  0002c	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 694  : }

  00031	c3		 ret	 0
$LN5@charListPr:

; 681  : #ifdef _CHANGEGALAXY
; 682  : 		else if (charListStatus == 3)

  00032	66 83 f9 03	 cmp	 cx, 3
  00036	75 06		 jne	 SHORT $LN7@charListPr

; 683  : 			return -12;

  00038	b8 f4 ff ff ff	 mov	 eax, -12		; fffffff4H

; 694  : }

  0003d	c3		 ret	 0
$LN7@charListPr:

; 684  : #endif
; 685  : #ifdef _ERROR301
; 686  : 		else if (charListStatus == 4)

  0003e	66 83 f9 04	 cmp	 cx, 4
  00042	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00047	ba f3 ff ff ff	 mov	 edx, -13		; fffffff3H
  0004c	0f 44 c2	 cmove	 eax, edx

; 694  : }

  0004f	c3		 ret	 0
$LN10@charListPr:

; 687  : 			return -13;
; 688  : #endif
; 689  : 		else
; 690  : 			return -2;
; 691  : 	}
; 692  : 	SETTIMEOUT2(NET_ERRMSG_CHARLISTTIMEOUT);

  00050	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00055	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?start_time@@3KA ; start_time
  0005b	3d c0 27 09 00	 cmp	 eax, 600000		; 000927c0H
  00060	76 16		 jbe	 SHORT $LN11@charListPr
  00062	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OCCGLCLB@?$DP?v?$KC?l?Q?Z?$KK?x?z?$DP?$DP?l?$KL?S?p?$KB?$KD@
  00067	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  0006c	e8 00 00 00 00	 call	 _sprintf
  00071	83 c4 08	 add	 esp, 8
  00074	83 c8 ff	 or	 eax, -1

; 694  : }

  00077	c3		 ret	 0
$LN11@charListPr:

; 693  : 	return 0;

  00078	33 c0		 xor	 eax, eax

; 694  : }

  0007a	c3		 ret	 0
?charListProc@@YAHXZ ENDP				; charListProc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?charListStart@@YAXXZ
_TEXT	SEGMENT
?charListStart@@YAXXZ PROC				; charListStart, COMDAT

; 660  : void charListStart(void){

  00000	56		 push	 esi

; 661  : 	int i;
; 662  : 
; 663  : 	for (i = 0; i < MAXCHARACTER; i++)

  00001	33 f6		 xor	 esi, esi
$LL4@charListSt:

; 664  : 		resetCharacterList(i);

  00003	56		 push	 esi
  00004	e8 00 00 00 00	 call	 ?resetCharacterList@@YAHH@Z ; resetCharacterList
  00009	46		 inc	 esi
  0000a	83 c4 04	 add	 esp, 4
  0000d	83 fe 02	 cmp	 esi, 2
  00010	7c f1		 jl	 SHORT $LL4@charListSt

; 665  : 
; 666  : 	charListStatus = 0;

  00012	33 c0		 xor	 eax, eax
  00014	5e		 pop	 esi

; 667  : 	if (bNewServer)

  00015	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  0001b	66 a3 00 00 00
	00		 mov	 WORD PTR ?charListStatus@@3FA, ax ; charListStatus
  00021	39 05 00 00 00
	00		 cmp	 DWORD PTR ?bNewServer@@3HA, eax ; bNewServer
  00027	74 07		 je	 SHORT $LN5@charListSt

; 668  : 		lssproto_CharList_send(sockfd);

  00029	e8 00 00 00 00	 call	 ?lssproto_CharList_send@@YAXH@Z ; lssproto_CharList_send
  0002e	eb 05		 jmp	 SHORT $LN12@charListSt
$LN5@charListSt:

; 669  : 	else
; 670  : 		old_lssproto_CharList_send(sockfd);

  00030	e8 00 00 00 00	 call	 ?old_lssproto_CharList_send@@YAXH@Z ; old_lssproto_CharList_send
$LN12@charListSt:

; 671  : 	SETSENDING;

  00035	83 c4 04	 add	 esp, 4
  00038	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 1 ; netproc_sending
  00042	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00047	a3 00 00 00 00	 mov	 DWORD PTR ?start_time@@3KA, eax ; start_time

; 672  : }

  0004c	c3		 ret	 0
?charListStart@@YAXXZ ENDP				; charListStart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?connectServer@@YAHXZ
_TEXT	SEGMENT
_flag$1 = -1016						; size = 4
_flg$2 = -1012						; size = 4
_tm$3 = -1008						; size = 8
_pt$4 = -1004						; size = 2
_efds$5 = -1000						; size = 260
_wfds$6 = -736						; size = 260
_rfds$7 = -472						; size = 260
_hostname$8 = -208					; size = 128
_userPassword$9 = -80					; size = 32
_userId$10 = -48					; size = 32
__$ArrayPad$ = -4					; size = 4
?connectServer@@YAHXZ PROC				; connectServer, COMDAT

; 406  : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 00 04 00
	00		 sub	 esp, 1024		; 00000400H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 407  : 	if (!init_net)

  00026	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?init_net@@3HA, 0 ; init_net
  0002d	0f 84 a1 06 00
	00		 je	 $LN54@connectSer

; 408  : 		return 0;
; 409  : 	static int count = 0;
; 410  : 
; 411  : 	if (connectServerCounter == 0){

  00033	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?connectServerCounter@@3HA ; connectServerCounter
  00039	85 c9		 test	 ecx, ecx
  0003b	0f 85 be 02 00
	00		 jne	 $LN12@connectSer

; 412  : 		char hostname[128];
; 413  : 		short pt;
; 414  : 		unsigned long flg = 1;
; 415  : 		struct hostent *h;
; 416  : 
; 417  : 		lstrcpy(PersonalKey, _DEFAULT_PKEY);

  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LCBBLLOI@www?493sa?4com@
  00046	68 00 00 00 00	 push	 OFFSET ?PersonalKey@@3PADA ; PersonalKey
  0004b	c7 85 0c fc ff
	ff 01 00 00 00	 mov	 DWORD PTR _flg$2[ebp], 1
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8

; 418  : 		//lstrcpy(PersonalKey, "forever");
; 419  : 		start_time = TimeGetTime();

  0005b	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00060	a3 00 00 00 00	 mov	 DWORD PTR ?start_time@@3KA, eax ; start_time

; 420  : 		if (getServerInfo(selectServerIndex, hostname, &pt) < 0)

  00065	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR _pt$4[ebp]
  0006b	50		 push	 eax
  0006c	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _hostname$8[ebp]
  00072	50		 push	 eax
  00073	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?selectServerIndex@@3FA ; selectServerIndex
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 ?getServerInfo@@YAHHPADPAF@Z ; getServerInfo
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH
  00083	85 c0		 test	 eax, eax
  00085	79 41		 jns	 SHORT $LN14@connectSer

; 421  : 		{
; 422  : 			count = 0;

  00087	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA, 0

; 423  : #ifdef _NB_æ–­çº¿è‡ªåŠ¨é‡è¿ž
; 424  : 			PcLanded.ç™»é™†å»¶æ—¶æ—¶é—´ = TimeGetTime() + 2000;

  00091	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00096	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H

; 425  : #endif
; 426  : 			sprintf(netprocErrmsg, NET_ERRMSG_BADNAME);

  0009b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KFDLBKA@?$NO?C?$NM?W?P?o?Y?$KD?$DP?$NM?t?o?a?$DP?$KB?$KD@
  000a0	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  000a5	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax
  000aa	e8 00 00 00 00	 call	 _sprintf
  000af	83 c4 08	 add	 esp, 8

; 427  : 			return -2;

  000b2	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 635  : 	return 0;
; 636  : }

  000b7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ba	33 cd		 xor	 ecx, ebp
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	8b e3		 mov	 esp, ebx
  000c6	5b		 pop	 ebx
  000c7	c3		 ret	 0
$LN14@connectSer:

; 428  : 		}
; 429  : 		sockfd = socket(AF_INET, SOCK_STREAM, 0);

  000c8	6a 00		 push	 0
  000ca	6a 01		 push	 1
  000cc	6a 02		 push	 2
  000ce	e8 00 00 00 00	 call	 _socket@12
  000d3	a3 00 00 00 00	 mov	 DWORD PTR ?sockfd@@3IA, eax ; sockfd

; 430  : 		if (sockfd == INVALID_SOCKET)

  000d8	83 f8 ff	 cmp	 eax, -1
  000db	75 41		 jne	 SHORT $LN15@connectSer

; 431  : 		{
; 432  : 			count = 0;

  000dd	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA, 0

; 433  : #ifdef _NB_æ–­çº¿è‡ªåŠ¨é‡è¿ž
; 434  : 			PcLanded.ç™»é™†å»¶æ—¶æ—¶é—´ = TimeGetTime() + 2000;

  000e7	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  000ec	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H

; 435  : #endif
; 436  : 			sprintf(netprocErrmsg, NET_ERRMSG_SOCKETERROR);

  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@JAKPHLLB@?Y?i?$NL?v?$DP?z?$LMsocket?n?$NMTCP?$KB?$KD@
  000f6	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  000fb	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax
  00100	e8 00 00 00 00	 call	 _sprintf
  00105	83 c4 08	 add	 esp, 8

; 437  : 			return -3;

  00108	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 635  : 	return 0;
; 636  : }

  0010d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00110	33 cd		 xor	 ecx, ebp
  00112	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	8b e3		 mov	 esp, ebx
  0011c	5b		 pop	 ebx
  0011d	c3		 ret	 0
$LN15@connectSer:

; 438  : 		}
; 439  : 		ioctlsocket(sockfd, FIONBIO, &flg);

  0011e	8d 8d 0c fc ff
	ff		 lea	 ecx, DWORD PTR _flg$2[ebp]
  00124	51		 push	 ecx
  00125	68 7e 66 04 80	 push	 -2147195266		; 8004667eH
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 _ioctlsocket@12

; 440  : 
; 441  : 		extern BOOL NoDelay;
; 442  : 		if (NoDelay)

  00130	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?NoDelay@@3HA, 0 ; NoDelay
  00137	74 46		 je	 SHORT $LN17@connectSer

; 443  : 		{
; 444  : 			int flag = 1;
; 445  : 
; 446  : 			if (setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, (char*)&flag, sizeof(int)) != 0)

  00139	6a 04		 push	 4
  0013b	8d 85 08 fc ff
	ff		 lea	 eax, DWORD PTR _flag$1[ebp]
  00141	c7 85 08 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR _flag$1[ebp], 1
  0014b	50		 push	 eax
  0014c	6a 01		 push	 1
  0014e	6a 06		 push	 6
  00150	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  00156	e8 00 00 00 00	 call	 _setsockopt@20
  0015b	85 c0		 test	 eax, eax
  0015d	74 20		 je	 SHORT $LN17@connectSer

; 447  : 			{
; 448  : 				count = 0;

  0015f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA, 0

; 449  : 				return -100;

  00169	b8 9c ff ff ff	 mov	 eax, -100		; ffffff9cH

; 635  : 	return 0;
; 636  : }

  0016e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00171	33 cd		 xor	 ecx, ebp
  00173	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00178	8b e5		 mov	 esp, ebp
  0017a	5d		 pop	 ebp
  0017b	8b e3		 mov	 esp, ebx
  0017d	5b		 pop	 ebx
  0017e	c3		 ret	 0
$LN17@connectSer:

; 450  : 			}
; 451  : 		}
; 452  : 		ZeroMemory(&sin_server, sizeof(sin_server));
; 453  : 		sin_server.sin_family = AF_INET;
; 454  : 		sin_server.sin_port = htons(pt);

  0017f	ff b5 14 fc ff
	ff		 push	 DWORD PTR _pt$4[ebp]
  00185	0f 57 c0	 xorps	 xmm0, xmm0
  00188	b8 02 00 00 00	 mov	 eax, 2
  0018d	0f 11 05 00 00
	00 00		 movups	 XMMWORD PTR ?sin_server@@3Usockaddr_in@@A, xmm0
  00194	66 a3 00 00 00
	00		 mov	 WORD PTR ?sin_server@@3Usockaddr_in@@A, ax
  0019a	e8 00 00 00 00	 call	 _htons@4
  0019f	66 a3 02 00 00
	00		 mov	 WORD PTR ?sin_server@@3Usockaddr_in@@A+2, ax

; 455  : 		sin_server.sin_addr.s_addr = inet_addr(hostname);     /* accept only dot notaion  */

  001a5	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _hostname$8[ebp]
  001ab	50		 push	 eax
  001ac	e8 00 00 00 00	 call	 _inet_addr@4
  001b1	a3 04 00 00 00	 mov	 DWORD PTR ?sin_server@@3Usockaddr_in@@A+4, eax

; 456  : 		if (sin_server.sin_addr.s_addr == -1)

  001b6	83 f8 ff	 cmp	 eax, -1
  001b9	75 74		 jne	 SHORT $LN18@connectSer

; 457  : 		{
; 458  : 			h = gethostbyname(hostname);

  001bb	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _hostname$8[ebp]
  001c1	50		 push	 eax
  001c2	e8 00 00 00 00	 call	 _gethostbyname@4

; 459  : 			if (h == NULL)

  001c7	85 c0		 test	 eax, eax
  001c9	75 58		 jne	 SHORT $LN19@connectSer

; 460  : 			{
; 461  : 				count = 0;

  001cb	a3 00 00 00 00	 mov	 DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA, eax

; 462  : #ifdef _NB_æ–­çº¿è‡ªåŠ¨é‡è¿ž
; 463  : 				PcLanded.ç™»é™†å»¶æ—¶æ—¶é—´ = TimeGetTime() + 2000;

  001d0	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  001d5	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  001da	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax

; 464  : #endif
; 465  : 				sprintf(netprocErrmsg, NET_ERRMSG_NOTGETADDR, hostname);

  001df	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _hostname$8[ebp]
  001e5	50		 push	 eax
  001e6	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@BHPEJLIB@?Y?i?$NL?v?$DP?T?p?$NO?C?$NM?W?P?o?n?$NM?$KD?I?$KD?P?j?H?v?G?$KB?$KD?$CI?$CFs?$CJ@
  001eb	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  001f0	e8 00 00 00 00	 call	 _sprintf
  001f5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 466  : 				closesocket(sockfd); 

  001f8	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  001fe	e8 00 00 00 00	 call	 _closesocket@4

; 467  : 				dwServer = NULL;

  00203	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 0 ; dwServer

; 468  : 				return -4;

  0020d	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH

; 635  : 	return 0;
; 636  : }

  00212	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00215	33 cd		 xor	 ecx, ebp
  00217	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0021c	8b e5		 mov	 esp, ebp
  0021e	5d		 pop	 ebp
  0021f	8b e3		 mov	 esp, ebx
  00221	5b		 pop	 ebx
  00222	c3		 ret	 0
$LN19@connectSer:

; 469  : 			}
; 470  : 			memcpy((void*)&sin_server.sin_addr.s_addr, h->h_addr, sizeof(struct in_addr));

  00223	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00226	8b 00		 mov	 eax, DWORD PTR [eax]
  00228	8b 00		 mov	 eax, DWORD PTR [eax]
  0022a	a3 04 00 00 00	 mov	 DWORD PTR ?sin_server@@3Usockaddr_in@@A+4, eax
$LN18@connectSer:

; 471  : 		}
; 472  : 		// Non blocking Connect
; 473  : 		int ret = connect(sockfd, (struct sockaddr*)&sin_server, sizeof(sin_server));

  0022f	6a 10		 push	 16			; 00000010H
  00231	68 00 00 00 00	 push	 OFFSET ?sin_server@@3Usockaddr_in@@A ; sin_server
  00236	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  0023c	e8 00 00 00 00	 call	 _connect@12

; 474  : 		if (ret == SOCKET_ERROR)

  00241	83 f8 ff	 cmp	 eax, -1
  00244	75 7d		 jne	 SHORT $LN53@connectSer

; 475  : 		{
; 476  : 			if (WSAGetLastError() != WSAEWOULDBLOCK)

  00246	e8 00 00 00 00	 call	 _WSAGetLastError@0
  0024b	3d 33 27 00 00	 cmp	 eax, 10035		; 00002733H
  00250	74 56		 je	 SHORT $LN21@connectSer

; 477  : 			{
; 478  : 				count = 0;
; 479  : 				closesocket(sockfd);

  00252	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  00258	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA, 0
  00262	e8 00 00 00 00	 call	 _closesocket@4

; 480  : 				dwServer = NULL;

  00267	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 0 ; dwServer

; 481  : #ifdef _NB_æ–­çº¿è‡ªåŠ¨é‡è¿ž
; 482  : 				PcLanded.ç™»é™†å»¶æ—¶æ—¶é—´ = TimeGetTime() + 2000;

  00271	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00276	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H

; 483  : #endif
; 484  : 				sprintf(netprocErrmsg, NET_ERRMSG_NOTCONNECT_S);

  0027b	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CKHMFIAG@?Y?i?$NL?v?$DP?c?$LH?$DP?z?$LM?$NO?C?$NM?W?P?o?n?$NM?$DP?o?H?$KB?$KD@
  00280	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  00285	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax
  0028a	e8 00 00 00 00	 call	 _sprintf
  0028f	83 c4 08	 add	 esp, 8

; 485  : 				return -5;

  00292	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH

; 635  : 	return 0;
; 636  : }

  00297	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0029a	33 cd		 xor	 ecx, ebp
  0029c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a1	8b e5		 mov	 esp, ebp
  002a3	5d		 pop	 ebp
  002a4	8b e3		 mov	 esp, ebx
  002a6	5b		 pop	 ebx
  002a7	c3		 ret	 0
$LN21@connectSer:

; 486  : 			}
; 487  : 			connectServerCounter = 1;

  002a8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, 1 ; connectServerCounter

; 488  : 			c_temp[0] = 0;

  002b2	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?c_temp@@3PADA, 0

; 489  : 			bNewServer = FALSE;

  002b9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bNewServer@@3HA, 0 ; bNewServer
$LN53@connectSer:

; 633  : 	}
; 634  : 	SETTIMEOUT2(NET_ERRMSG_CONNECTTIMEOUT);

  002c3	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  002c8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?start_time@@3KA ; start_time
  002ce	3d c0 27 09 00	 cmp	 eax, 600000		; 000927c0H
  002d3	0f 86 fb 03 00
	00		 jbe	 $LN54@connectSer
  002d9	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@PMNBOGBM@?$NO?C?$NM?W?P?o?$DP?o?H?$DP?$DP?l?$KL?S?p?$KB?$KD@
  002de	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  002e3	e8 00 00 00 00	 call	 _sprintf
  002e8	83 c4 08	 add	 esp, 8
  002eb	83 c8 ff	 or	 eax, -1

; 635  : 	return 0;
; 636  : }

  002ee	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002f1	33 cd		 xor	 ecx, ebp
  002f3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002f8	8b e5		 mov	 esp, ebp
  002fa	5d		 pop	 ebp
  002fb	8b e3		 mov	 esp, ebx
  002fd	5b		 pop	 ebx
  002fe	c3		 ret	 0
$LN12@connectSer:

; 490  : 			/*sprintf(netprocErrmsg, NET_ERRMSG_NOTCONNECT);
; 491  : 			closesocket(sockfd);
; 492  : 			dwServer = NULL;
; 493  : 			return -6; */
; 494  : 		}
; 495  : 	}else if (connectServerCounter >= 1 && connectServerCounter <= 70){

  002ff	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00302	83 f8 45	 cmp	 eax, 69			; 00000045H
  00305	0f 87 f9 01 00
	00		 ja	 $LN22@connectSer

; 496  : 		fd_set rfds, wfds, efds;
; 497  : 		struct timeval tm;
; 498  : 
; 499  : 		connectServerCounter++;

  0030b	41		 inc	 ecx

; 500  : 		if (connectServerCounter == 70)
; 501  : 			connectServerCounter = 69;
; 502  : 
; 503  : 		tm.tv_sec = 0;

  0030c	c7 85 10 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _tm$3[ebp], 0
  00316	83 f9 46	 cmp	 ecx, 70			; 00000046H

; 504  : 		tm.tv_usec = 0;

  00319	c7 85 14 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _tm$3[ebp+4], 0
  00323	b8 45 00 00 00	 mov	 eax, 69			; 00000045H

; 505  : 		FD_ZERO(&rfds);
; 506  : 		FD_ZERO(&wfds);
; 507  : 		FD_ZERO(&efds);
; 508  : 		FD_SET(sockfd, &rfds);

  00328	c7 85 28 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _rfds$7[ebp], 1
  00332	0f 44 c8	 cmove	 ecx, eax

; 509  : 		FD_SET(sockfd, &wfds);

  00335	c7 85 20 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR _wfds$6[ebp], 1
  0033f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  00344	89 0d 00 00 00
	00		 mov	 DWORD PTR ?connectServerCounter@@3HA, ecx ; connectServerCounter

; 510  : 		FD_SET(sockfd, &efds);
; 511  : 		int a = select(sockfd, &rfds, &wfds, &efds, &tm);

  0034a	8d 8d 10 fc ff
	ff		 lea	 ecx, DWORD PTR _tm$3[ebp]
  00350	51		 push	 ecx
  00351	8d 8d 18 fc ff
	ff		 lea	 ecx, DWORD PTR _efds$5[ebp]
  00357	89 85 2c fe ff
	ff		 mov	 DWORD PTR _rfds$7[ebp+4], eax
  0035d	51		 push	 ecx
  0035e	8d 8d 20 fd ff
	ff		 lea	 ecx, DWORD PTR _wfds$6[ebp]
  00364	89 85 24 fd ff
	ff		 mov	 DWORD PTR _wfds$6[ebp+4], eax
  0036a	51		 push	 ecx
  0036b	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR _rfds$7[ebp]
  00371	89 85 1c fc ff
	ff		 mov	 DWORD PTR _efds$5[ebp+4], eax
  00377	51		 push	 ecx
  00378	50		 push	 eax
  00379	c7 85 18 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR _efds$5[ebp], 1
  00383	e8 00 00 00 00	 call	 _select@20

; 512  : 		if (a > 0){

  00388	85 c0		 test	 eax, eax
  0038a	0f 8e 4f 01 00
	00		 jle	 $LN28@connectSer

; 513  : 			if (FD_ISSET(sockfd, &rfds)){

  00390	8d 85 28 fe ff
	ff		 lea	 eax, DWORD PTR _rfds$7[ebp]
  00396	50		 push	 eax
  00397	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  0039d	e8 00 00 00 00	 call	 ___WSAFDIsSet@8
  003a2	85 c0		 test	 eax, eax
  003a4	0f 84 b6 00 00
	00		 je	 $LN32@connectSer

; 514  : 				// Nuke start
; 515  : 				int i_len = recv(sockfd, c_temp, sizeof(c_temp) - 1, 0);

  003aa	6a 00		 push	 0
  003ac	68 ff 03 00 00	 push	 1023			; 000003ffH
  003b1	68 00 00 00 00	 push	 OFFSET ?c_temp@@3PADA	; c_temp
  003b6	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  003bc	e8 00 00 00 00	 call	 _recv@16

; 516  : 				if (i_len > 0){

  003c1	85 c0		 test	 eax, eax
  003c3	0f 8e b1 00 00
	00		 jle	 $LN31@connectSer

; 517  : 					
; 518  : 					if (c_temp[0] == 'E'){

  003c9	a0 00 00 00 00	 mov	 al, BYTE PTR ?c_temp@@3PADA
  003ce	3c 45		 cmp	 al, 69			; 00000045H
  003d0	75 56		 jne	 SHORT $LN33@connectSer

; 519  : #ifdef _NB_æ–­çº¿è‡ªåŠ¨é‡è¿ž
; 520  : 						PcLanded.ç™»é™†å»¶æ—¶æ—¶é—´ = TimeGetTime() + 2000;

  003d2	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime

; 521  : #endif
; 522  : 						count = 0;
; 523  : 						sprintf(netprocErrmsg, c_temp + 1);

  003d7	68 01 00 00 00	 push	 OFFSET ?c_temp@@3PADA+1
$LN61@connectSer:

; 635  : 	return 0;
; 636  : }

  003dc	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  003e1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA, 0
  003eb	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  003f0	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax
  003f5	e8 00 00 00 00	 call	 _sprintf
  003fa	83 c4 08	 add	 esp, 8
  003fd	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  00403	e8 00 00 00 00	 call	 _closesocket@4
  00408	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 0 ; dwServer
  00412	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  00417	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0041a	33 cd		 xor	 ecx, ebp
  0041c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00421	8b e5		 mov	 esp, ebp
  00423	5d		 pop	 ebp
  00424	8b e3		 mov	 esp, ebx
  00426	5b		 pop	 ebx
  00427	c3		 ret	 0
$LN33@connectSer:

; 524  : 						closesocket(sockfd);
; 525  : 						dwServer = NULL;
; 526  : 						return -6;
; 527  : 					}else if (c_temp[0] == _SA_VERSION){

  00428	3c 4c		 cmp	 al, 76			; 0000004cH
  0042a	75 5d		 jne	 SHORT $LN35@connectSer

; 528  : 						bNewServer = 0xf000000 | 1;
; 529  : 						if (FD_ISSET(sockfd, &wfds)){

  0042c	8d 85 20 fd ff
	ff		 lea	 eax, DWORD PTR _wfds$6[ebp]
  00432	c7 05 00 00 00
	00 01 00 00 0f	 mov	 DWORD PTR ?bNewServer@@3HA, 251658241 ; bNewServer, 0f000001H
  0043c	50		 push	 eax
  0043d	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  00443	e8 00 00 00 00	 call	 ___WSAFDIsSet@8
  00448	85 c0		 test	 eax, eax
  0044a	74 14		 je	 SHORT $LN32@connectSer

; 530  : 							connectServerCounter = 71;					

  0044c	c7 05 00 00 00
	00 47 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, 71 ; connectServerCounter, 00000047H

; 531  : 							server_choosed = 1;

  00456	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?server_choosed@@3HA, 1 ; server_choosed
$LN32@connectSer:

; 542  : 					}
; 543  : 				}else{
; 544  : #ifdef _NB_æ–­çº¿è‡ªåŠ¨é‡è¿ž
; 545  : 					PcLanded.ç™»é™†å»¶æ—¶æ—¶é—´ = TimeGetTime() + 2000;
; 546  : #endif
; 547  : 					count = 0;
; 548  : 					sprintf(netprocErrmsg, NET_ERRMSG_NOTCONNECT);
; 549  : 					closesocket(sockfd);
; 550  : 					dwServer = NULL;
; 551  : 					return -6; 
; 552  : 				}
; 553  : 			}
; 554  : 			if (FD_ISSET(sockfd, &efds)){

  00460	8d 85 18 fc ff
	ff		 lea	 eax, DWORD PTR _efds$5[ebp]
  00466	50		 push	 eax
  00467	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  0046d	e8 00 00 00 00	 call	 ___WSAFDIsSet@8
  00472	85 c0		 test	 eax, eax
  00474	0f 84 49 fe ff
	ff		 je	 $LN53@connectSer
$LN31@connectSer:

; 635  : 	return 0;
; 636  : }

  0047a	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  0047f	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@NBOLBDPM@?$LN?$LK?E?f?$LP?$KB?$MA?L?A?v?5?D?$KL?$LP?$MA?$LN?$LK?$LM?$KN?$LJ?v?$LE?B?5?G?v?$MA?g?5?A?$KB@
  00484	e9 53 ff ff ff	 jmp	 $LN61@connectSer
$LN35@connectSer:

; 532  : 						}
; 533  : 					}else{
; 534  : #ifdef _NB_æ–­çº¿è‡ªåŠ¨é‡è¿ž
; 535  : 						PcLanded.ç™»é™†å»¶æ—¶æ—¶é—´ = TimeGetTime() + 2000;

  00489	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  0048e	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H

; 536  : #endif
; 537  : 						count = 0;

  00493	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA, 0

; 538  : 						sprintf(netprocErrmsg, NET_ERRMSG_VERSIONERROR);

  0049d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@NDJIOBBC@?$OA?$LE?P?o?$DP?S?$NL?w?z?$NM?b?$NM?t?T?R@
  004a2	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  004a7	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax
  004ac	e8 00 00 00 00	 call	 _sprintf
  004b1	83 c4 08	 add	 esp, 8

; 539  : 						closesocket(sockfd);

  004b4	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  004ba	e8 00 00 00 00	 call	 _closesocket@4

; 540  : 						dwServer = NULL;

  004bf	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 0 ; dwServer

; 541  : 						return -8;

  004c9	b8 f8 ff ff ff	 mov	 eax, -8			; fffffff8H

; 635  : 	return 0;
; 636  : }

  004ce	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004d1	33 cd		 xor	 ecx, ebp
  004d3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004d8	8b e5		 mov	 esp, ebp
  004da	5d		 pop	 ebp
  004db	8b e3		 mov	 esp, ebx
  004dd	5b		 pop	 ebx
  004de	c3		 ret	 0
$LN28@connectSer:

; 555  : #ifdef _NB_æ–­çº¿è‡ªåŠ¨é‡è¿ž
; 556  : 				PcLanded.ç™»é™†å»¶æ—¶æ—¶é—´ = TimeGetTime() + 2000;
; 557  : #endif
; 558  : 				count = 0;
; 559  : 				sprintf(netprocErrmsg, NET_ERRMSG_NOTCONNECT);
; 560  : 				closesocket(sockfd);
; 561  : 				dwServer = NULL;
; 562  : 				return -6; 
; 563  : 			}
; 564  : 		}else{
; 565  : 			count++;

  004df	a1 00 00 00 00	 mov	 eax, DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA
  004e4	40		 inc	 eax
  004e5	a3 00 00 00 00	 mov	 DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA, eax
  004ea	3d dc 05 00 00	 cmp	 eax, 1500		; 000005dcH

; 566  : 			if(count >= 1500){

  004ef	0f 8c ce fd ff
	ff		 jl	 $LN53@connectSer

; 635  : 	return 0;
; 636  : }

  004f5	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  004fa	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@NBOLBDPM@?$LN?$LK?E?f?$LP?$KB?$MA?L?A?v?5?D?$KL?$LP?$MA?$LN?$LK?$LM?$KN?$LJ?v?$LE?B?5?G?v?$MA?g?5?A?$KB@
  004ff	e9 d8 fe ff ff	 jmp	 $LN61@connectSer
$LN22@connectSer:

; 567  : #ifdef _NB_æ–­çº¿è‡ªåŠ¨é‡è¿ž
; 568  : 				PcLanded.ç™»é™†å»¶æ—¶æ—¶é—´ = TimeGetTime() + 2000;
; 569  : #endif
; 570  : 				count = 0;
; 571  : 				sprintf(netprocErrmsg, NET_ERRMSG_NOTCONNECT);
; 572  : 				closesocket(sockfd);
; 573  : 				dwServer = NULL;
; 574  : 				return -6; 
; 575  : 			}
; 576  : 		}
; 577  : 	}else if (connectServerCounter >= 71 && connectServerCounter <= 80){

  00504	8d 41 b9	 lea	 eax, DWORD PTR [ecx-71]
  00507	83 f8 09	 cmp	 eax, 9
  0050a	0f 87 89 01 00
	00		 ja	 $LN40@connectSer

; 578  : 		count = 0;

  00510	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA, 0

; 579  : 		if (connectServerCounter == 71){

  0051a	83 f9 47	 cmp	 ecx, 71			; 00000047H
  0051d	0f 85 df 00 00
	00		 jne	 $LN42@connectSer

; 580  : VMProtectBegin("login");

  00523	68 00 00 00 00	 push	 OFFSET ??_C@_05DAOAAINN@login@
  00528	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VMProtectBegin@4

; 581  : 			char userId[32], userPassword[32];
; 582  : 
; 583  : 			clientLoginStatus = 0;
; 584  : 			CopyMemory(userId, szUser, 32);

  0052e	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ?szUser@@3PADA
  00535	33 c0		 xor	 eax, eax

; 585  : 			ecb_crypt("f;encor1c", userId, 32, DES_DECRYPT);

  00537	6a 01		 push	 1
  00539	66 a3 00 00 00
	00		 mov	 WORD PTR ?clientLoginStatus@@3FA, ax ; clientLoginStatus
  0053f	8d 45 d0	 lea	 eax, DWORD PTR _userId$10[ebp]
  00542	0f 11 45 d0	 movups	 XMMWORD PTR _userId$10[ebp], xmm0
  00546	6a 20		 push	 32			; 00000020H
  00548	0f 10 05 10 00
	00 00		 movups	 xmm0, XMMWORD PTR ?szUser@@3PADA+16
  0054f	50		 push	 eax
  00550	68 00 00 00 00	 push	 OFFSET ??_C@_09BACHGGGK@f?$DLencor1c@
  00555	0f 11 45 e0	 movups	 XMMWORD PTR _userId$10[ebp+16], xmm0
  00559	e8 00 00 00 00	 call	 ?ecb_crypt@@YAHPAD0II@Z	; ecb_crypt

; 586  : 			CopyMemory(userPassword, szPassword, 32);

  0055e	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ?szPassword@@3PADA

; 587  : 			ecb_crypt("f;encor1c", userPassword, 32, DES_DECRYPT);

  00565	6a 01		 push	 1
  00567	6a 20		 push	 32			; 00000020H
  00569	0f 11 45 b0	 movups	 XMMWORD PTR _userPassword$9[ebp], xmm0
  0056d	8d 45 b0	 lea	 eax, DWORD PTR _userPassword$9[ebp]
  00570	0f 10 05 10 00
	00 00		 movups	 xmm0, XMMWORD PTR ?szPassword@@3PADA+16
  00577	50		 push	 eax
  00578	68 00 00 00 00	 push	 OFFSET ??_C@_09BACHGGGK@f?$DLencor1c@
  0057d	0f 11 45 c0	 movups	 XMMWORD PTR _userPassword$9[ebp+16], xmm0
  00581	e8 00 00 00 00	 call	 ?ecb_crypt@@YAHPAD0II@Z	; ecb_crypt
  00586	83 c4 20	 add	 esp, 32			; 00000020H

; 588  : 
; 589  : 			if (bNewServer)

  00589	8d 45 b0	 lea	 eax, DWORD PTR _userPassword$9[ebp]
  0058c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bNewServer@@3HA, 0 ; bNewServer
  00593	50		 push	 eax
  00594	8d 45 d0	 lea	 eax, DWORD PTR _userId$10[ebp]
  00597	50		 push	 eax
  00598	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  0059e	74 07		 je	 SHORT $LN43@connectSer

; 590  : 				lssproto_ClientLogin_send(sockfd, userId, userPassword);

  005a0	e8 00 00 00 00	 call	 ?lssproto_ClientLogin_send@@YAXHPAD0@Z ; lssproto_ClientLogin_send
  005a5	eb 05		 jmp	 SHORT $LN58@connectSer
$LN43@connectSer:

; 591  : 			else
; 592  : 				old_lssproto_ClientLogin_send(sockfd, userId, userPassword);

  005a7	e8 00 00 00 00	 call	 ?old_lssproto_ClientLogin_send@@YAXHPAD0@Z ; old_lssproto_ClientLogin_send
$LN58@connectSer:

; 593  : 
; 594  : 			//cary 2001 9 6
; 595  : 			if ((bNewServer & 0xf000000) == 0xf000000){

  005ac	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bNewServer@@3HA ; bNewServer
  005b1	83 c4 0c	 add	 esp, 12			; 0000000cH
  005b4	25 00 00 00 0f	 and	 eax, 251658240		; 0f000000H
  005b9	3d 00 00 00 0f	 cmp	 eax, 251658240		; 0f000000H
  005be	8d 45 d0	 lea	 eax, DWORD PTR _userId$10[ebp]
  005c1	50		 push	 eax
  005c2	68 00 00 00 00	 push	 OFFSET ?PersonalKey@@3PADA ; PersonalKey
  005c7	75 0d		 jne	 SHORT $LN45@connectSer

; 596  : 				lstrcpy(PersonalKey, userId);

  005c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8

; 597  : 				lstrcat(PersonalKey, _RUNNING_KEY);

  005cf	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LCBBLLOI@www?493sa?4com@

; 598  : 			}else{

  005d4	eb 0b		 jmp	 SHORT $LN59@connectSer
$LN45@connectSer:

; 599  : 				lstrcpy(PersonalKey, userId);

  005d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8

; 600  : 				lstrcat(PersonalKey, "19761101");

  005dc	68 00 00 00 00	 push	 OFFSET ??_C@_08DDDJOECK@19761101@
$LN59@connectSer:

; 601  : 			}
; 602  : 			netproc_sending = NETPROC_SENDING;

  005e1	68 00 00 00 00	 push	 OFFSET ?PersonalKey@@3PADA ; PersonalKey
  005e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcatA@8
  005ec	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 1 ; netproc_sending

; 603  : VMProtectEnd();

  005f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VMProtectEnd@0
  005fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?connectServerCounter@@3HA ; connectServerCounter
$LN42@connectSer:

; 604  : 		}
; 605  : 		if (netproc_sending == NETPROC_RECEIVED){

  00602	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?netproc_sending@@3HA, 2 ; netproc_sending
  00609	75 0f		 jne	 SHORT $LN49@connectSer

; 606  : 			if (clientLoginStatus)

  0060b	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR ?clientLoginStatus@@3FA, 0 ; clientLoginStatus
  00613	74 24		 je	 SHORT $LN48@connectSer

; 607  : 				connectServerCounter = 81;

  00615	b9 51 00 00 00	 mov	 ecx, 81			; 00000051H
$LN49@connectSer:

; 622  : 			}
; 623  : 		}
; 624  : 		connectServerCounter++;

  0061a	41		 inc	 ecx
  0061b	89 0d 00 00 00
	00		 mov	 DWORD PTR ?connectServerCounter@@3HA, ecx ; connectServerCounter
  00621	83 f9 51	 cmp	 ecx, 81			; 00000051H

; 625  : 		if (connectServerCounter == 81)

  00624	0f 85 99 fc ff
	ff		 jne	 $LN53@connectSer

; 626  : 			connectServerCounter = 80;

  0062a	c7 05 00 00 00
	00 50 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, 80 ; connectServerCounter, 00000050H

; 627  : 	}

  00634	e9 8a fc ff ff	 jmp	 $LN53@connectSer
$LN48@connectSer:

; 608  : 			else{
; 609  : #ifdef _NB_æ–­çº¿è‡ªåŠ¨é‡è¿ž
; 610  : 				PcLanded.ç™»é™†å»¶æ—¶æ—¶é—´ = TimeGetTime() + 2000;

  00639	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  0063e	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H

; 611  : #endif
; 612  : 				count = 0;

  00643	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA, 0

; 613  : 				netproc_sending = NETPROC_NOTSEND;
; 614  : #ifdef _NB_ç™»å½•é”™è¯¯ä¿¡æ¯æç¤º
; 615  : 				sprintf(netprocErrmsg, ç™»å½•é”™è¯¯æç¤º);

  0064d	68 00 00 00 00	 push	 OFFSET ?Ôô???ð«ãÆ@@3PADA ; Ôô???ð«ãÆ
  00652	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  00657	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax
  0065c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 0 ; netproc_sending
  00666	e8 00 00 00 00	 call	 _sprintf
  0066b	83 c4 08	 add	 esp, 8

; 616  : #else
; 617  : 				sprintf(netprocErrmsg, NET_ERRMSG_LOGINFAIL);
; 618  : #endif
; 619  : 				closesocket(sockfd);

  0066e	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  00674	e8 00 00 00 00	 call	 _closesocket@4

; 620  : 				dwServer = NULL;

  00679	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 0 ; dwServer

; 621  : 				return -7;

  00683	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H

; 635  : 	return 0;
; 636  : }

  00688	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0068b	33 cd		 xor	 ecx, ebp
  0068d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00692	8b e5		 mov	 esp, ebp
  00694	5d		 pop	 ebp
  00695	8b e3		 mov	 esp, ebx
  00697	5b		 pop	 ebx
  00698	c3		 ret	 0
$LN40@connectSer:

; 628  : 	else if (connectServerCounter >= 81 && connectServerCounter <= 98)

  00699	8d 41 af	 lea	 eax, DWORD PTR [ecx-81]
  0069c	83 f8 11	 cmp	 eax, 17			; 00000011H
  0069f	77 0c		 ja	 SHORT $LN51@connectSer

; 629  : 		connectServerCounter ++;

  006a1	41		 inc	 ecx
  006a2	89 0d 00 00 00
	00		 mov	 DWORD PTR ?connectServerCounter@@3HA, ecx ; connectServerCounter
  006a8	e9 16 fc ff ff	 jmp	 $LN53@connectSer
$LN51@connectSer:

; 630  : 	else if (connectServerCounter == 99){

  006ad	83 f9 63	 cmp	 ecx, 99			; 00000063H
  006b0	0f 85 0d fc ff
	ff		 jne	 $LN53@connectSer

; 631  : 		netproc_sending = NETPROC_NOTSEND;

  006b6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 0 ; netproc_sending

; 632  : 		return 1;

  006c0	8d 41 9e	 lea	 eax, DWORD PTR [ecx-98]

; 635  : 	return 0;
; 636  : }

  006c3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006c6	33 cd		 xor	 ecx, ebp
  006c8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006cd	8b e5		 mov	 esp, ebp
  006cf	5d		 pop	 ebp
  006d0	8b e3		 mov	 esp, ebx
  006d2	5b		 pop	 ebx
  006d3	c3		 ret	 0
$LN54@connectSer:
  006d4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006d7	33 c0		 xor	 eax, eax
  006d9	33 cd		 xor	 ecx, ebp
  006db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006e0	8b e5		 mov	 esp, ebp
  006e2	5d		 pop	 ebp
  006e3	8b e3		 mov	 esp, ebx
  006e5	5b		 pop	 ebx
  006e6	c3		 ret	 0
?connectServer@@YAHXZ ENDP				; connectServer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?ConnectWGS@@YAHXZ
_TEXT	SEGMENT
_tm$1 = -808						; size = 8
_tm$2 = -808						; size = 8
_flg$3 = -804						; size = 4
_flg$4 = -804						; size = 4
_rfds$5 = -800						; size = 260
_rfds$6 = -800						; size = 260
_wfds$7 = -540						; size = 260
_efds$8 = -540						; size = 260
_efds$9 = -280						; size = 260
_wfds$10 = -280						; size = 260
_sin$11 = -20						; size = 16
_sin$12 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
?ConnectWGS@@YAHXZ PROC					; ConnectWGS, COMDAT

; 174  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 28 03 00
	00		 sub	 esp, 808		; 00000328H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 175  : 	if (connectServerCounter == 0)

  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?connectServerCounter@@3HA ; connectServerCounter
  00019	85 c9		 test	 ecx, ecx
  0001b	0f 85 31 02 00
	00		 jne	 $LN20@ConnectWGS

; 176  : 	{
; 177  : 		HANDLE hFileMapping = NULL;
; 178  : 		LPSTR lpstr = NULL;
; 179  : 
; 180  : 		cleanupNetwork();

  00021	e8 00 00 00 00	 call	 ?cleanupNetwork@@YAXXZ	; cleanupNetwork

; 181  : 		if (initNet())

  00026	e8 00 00 00 00	 call	 ?initNet@@YAHXZ		; initNet
  0002b	85 c0		 test	 eax, eax
  0002d	0f 84 d7 01 00
	00		 je	 $LN22@ConnectWGS

; 182  : 		{
; 183  : 			unsigned long flg = 1;

  00033	c7 85 dc fc ff
	ff 01 00 00 00	 mov	 DWORD PTR _flg$4[ebp], 1

; 184  : 			struct sockaddr_in sin;
; 185  : 			struct hostent *h;
; 186  : 
; 187  : 			iWGS = 0;

  0003d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?iWGS@@3HA, 0	; iWGS

; 188  : 			iEncrypt = E_INIT;

  00047	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?iEncrypt@@3HA, 0 ; iEncrypt

; 189  : 			start_time = TimeGetTime();

  00051	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime

; 190  : 			if (INVALID_SOCKET == (sockfd = socket(AF_INET, SOCK_STREAM, 0)))

  00056	6a 00		 push	 0
  00058	6a 01		 push	 1
  0005a	6a 02		 push	 2
  0005c	a3 00 00 00 00	 mov	 DWORD PTR ?start_time@@3KA, eax ; start_time
  00061	e8 00 00 00 00	 call	 _socket@12
  00066	a3 00 00 00 00	 mov	 DWORD PTR ?sockfd@@3IA, eax ; sockfd
  0006b	83 f8 ff	 cmp	 eax, -1
  0006e	75 34		 jne	 SHORT $LN24@ConnectWGS
$LN65@ConnectWGS:

; 398  : 	return 0;
; 399  : }

  00070	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00075	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@JAKPHLLB@?Y?i?$NL?v?$DP?z?$LMsocket?n?$NMTCP?$KB?$KD@
  0007f	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  00084	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax
  00089	e8 00 00 00 00	 call	 _sprintf
  0008e	83 c4 08	 add	 esp, 8
  00091	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00096	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00099	33 cd		 xor	 ecx, ebp
  0009b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
$LN24@ConnectWGS:

; 191  : 			{
; 192  : #ifdef _NB_æ–­çº¿è‡ªåŠ¨é‡è¿ž
; 193  : 				PcLanded.ç™»é™†å»¶æ—¶æ—¶é—´ = TimeGetTime() + 2000;
; 194  : #endif
; 195  : 				sprintf(netprocErrmsg, NET_ERRMSG_SOCKETERROR);
; 196  : 				return -3;
; 197  : 			}
; 198  : 			ioctlsocket(sockfd, FIONBIO, &flg);

  000a4	8d 8d dc fc ff
	ff		 lea	 ecx, DWORD PTR _flg$4[ebp]
  000aa	51		 push	 ecx
  000ab	68 7e 66 04 80	 push	 -2147195266		; 8004667eH
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 _ioctlsocket@12

; 199  : 			sin.sin_family = AF_INET;

  000b6	b8 02 00 00 00	 mov	 eax, 2
  000bb	66 89 45 ec	 mov	 WORD PTR _sin$12[ebp], ax

; 200  : 			sin.sin_port = htons(wWGS);

  000bf	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?wWGS@@3GA ; wWGS
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 _htons@4

; 201  : 			sin.sin_addr.s_addr = inet_addr(szWGS);

  000cc	68 00 00 00 00	 push	 OFFSET ?szWGS@@3PADA	; szWGS
  000d1	66 89 45 ee	 mov	 WORD PTR _sin$12[ebp+2], ax
  000d5	e8 00 00 00 00	 call	 _inet_addr@4
  000da	89 45 f0	 mov	 DWORD PTR _sin$12[ebp+4], eax

; 202  : 			if (sin.sin_addr.s_addr == -1)

  000dd	83 f8 ff	 cmp	 eax, -1
  000e0	75 66		 jne	 SHORT $LN25@ConnectWGS

; 203  : 			{
; 204  : 				if (!(h = gethostbyname(szWGS)))

  000e2	68 00 00 00 00	 push	 OFFSET ?szWGS@@3PADA	; szWGS
  000e7	e8 00 00 00 00	 call	 _gethostbyname@4
  000ec	85 c0		 test	 eax, eax
  000ee	75 4e		 jne	 SHORT $LN26@ConnectWGS

; 205  : 				{
; 206  : #ifdef _NB_æ–­çº¿è‡ªåŠ¨é‡è¿ž
; 207  : 					PcLanded.ç™»é™†å»¶æ—¶æ—¶é—´ = TimeGetTime() + 2000;

  000f0	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime

; 208  : #endif
; 209  : 					sprintf(netprocErrmsg, NET_ERRMSG_NOTGETADDR, "WGS");

  000f5	68 00 00 00 00	 push	 OFFSET ??_C@_03GMCCICCK@WGS@
$LN68@ConnectWGS:

; 398  : 	return 0;
; 399  : }

  000fa	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  000ff	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@BHPEJLIB@?Y?i?$NL?v?$DP?T?p?$NO?C?$NM?W?P?o?n?$NM?$KD?I?$KD?P?j?H?v?G?$KB?$KD?$CI?$CFs?$CJ@
  00104	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  00109	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax
  0010e	e8 00 00 00 00	 call	 _sprintf
  00113	83 c4 0c	 add	 esp, 12			; 0000000cH
  00116	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  0011c	e8 00 00 00 00	 call	 _closesocket@4
  00121	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 0 ; dwServer
  0012b	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00130	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00133	33 cd		 xor	 ecx, ebp
  00135	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013a	8b e5		 mov	 esp, ebp
  0013c	5d		 pop	 ebp
  0013d	c3		 ret	 0
$LN26@ConnectWGS:

; 210  : 					closesocket(sockfd);
; 211  : 					dwServer = NULL;
; 212  : 					return -4;
; 213  : 				}
; 214  : 				memcpy((void*)&sin.sin_addr.s_addr, h->h_addr, sizeof(struct in_addr));

  0013e	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00141	8b 00		 mov	 eax, DWORD PTR [eax]
  00143	8b 00		 mov	 eax, DWORD PTR [eax]
  00145	89 45 f0	 mov	 DWORD PTR _sin$12[ebp+4], eax
$LN25@ConnectWGS:

; 215  : 			}
; 216  : 			int ret = connect(sockfd, (struct sockaddr*)&sin, sizeof(sin));

  00148	6a 10		 push	 16			; 00000010H
  0014a	8d 45 ec	 lea	 eax, DWORD PTR _sin$12[ebp]
  0014d	50		 push	 eax
  0014e	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  00154	e8 00 00 00 00	 call	 _connect@12

; 217  : 			if (ret == SOCKET_ERROR)

  00159	83 f8 ff	 cmp	 eax, -1
  0015c	75 55		 jne	 SHORT $LN28@ConnectWGS

; 218  : 			{
; 219  : 				if (WSAGetLastError() != WSAEWOULDBLOCK)

  0015e	e8 00 00 00 00	 call	 _WSAGetLastError@0
  00163	3d 33 27 00 00	 cmp	 eax, 10035		; 00002733H
  00168	74 49		 je	 SHORT $LN28@ConnectWGS
$LN67@ConnectWGS:

; 398  : 	return 0;
; 399  : }

  0016a	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  00170	e8 00 00 00 00	 call	 _closesocket@4
  00175	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 0 ; dwServer
  0017f	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00184	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  00189	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CKHMFIAG@?Y?i?$NL?v?$DP?c?$LH?$DP?z?$LM?$NO?C?$NM?W?P?o?n?$NM?$DP?o?H?$KB?$KD@
  0018e	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  00193	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax
  00198	e8 00 00 00 00	 call	 _sprintf
  0019d	83 c4 08	 add	 esp, 8
  001a0	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  001a5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a8	33 cd		 xor	 ecx, ebp
  001aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001af	8b e5		 mov	 esp, ebp
  001b1	5d		 pop	 ebp
  001b2	c3		 ret	 0
$LN28@ConnectWGS:

; 220  : 				{
; 221  : 					closesocket(sockfd);
; 222  : 					dwServer = NULL;
; 223  : #ifdef _NB_æ–­çº¿è‡ªåŠ¨é‡è¿ž
; 224  : 					PcLanded.ç™»é™†å»¶æ—¶æ—¶é—´ = TimeGetTime() + 2000;
; 225  : #endif
; 226  : 					sprintf(netprocErrmsg, NET_ERRMSG_NOTCONNECT_S);
; 227  : 					return -5;
; 228  : 				}
; 229  : 			}
; 230  : 			dwServer = WGS;

  001b3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 1 ; dwServer

; 231  : 			iWGS = 1;

  001bd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?iWGS@@3HA, 1	; iWGS

; 232  : 			connectServerCounter = 1;

  001c7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, 1 ; connectServerCounter
$LN61@ConnectWGS:

; 397  : 	SETTIMEOUT2(NET_ERRMSG_CONNECTTIMEOUT);

  001d1	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  001d6	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?start_time@@3KA ; start_time
  001dc	3d c0 27 09 00	 cmp	 eax, 600000		; 000927c0H
  001e1	0f 86 71 04 00
	00		 jbe	 $LN62@ConnectWGS
  001e7	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@PMNBOGBM@?$NO?C?$NM?W?P?o?$DP?o?H?$DP?$DP?l?$KL?S?p?$KB?$KD@
  001ec	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  001f1	e8 00 00 00 00	 call	 _sprintf
  001f6	83 c4 08	 add	 esp, 8
  001f9	83 c8 ff	 or	 eax, -1

; 398  : 	return 0;
; 399  : }

  001fc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ff	33 cd		 xor	 ecx, ebp
  00201	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00206	8b e5		 mov	 esp, ebp
  00208	5d		 pop	 ebp
  00209	c3		 ret	 0
$LN22@ConnectWGS:

; 233  : 		}
; 234  : 		else
; 235  : 		{
; 236  : #ifdef _NB_æ–­çº¿è‡ªåŠ¨é‡è¿ž
; 237  : 			PcLanded.ç™»é™†å»¶æ—¶æ—¶é—´ = TimeGetTime() + 2000;

  0020a	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime

; 238  : #endif
; 239  : 			strcpy(netprocErrmsg, NET_ERRMSG_SOCKLIBERROR);

  0020f	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0O@KDOBPHMN@?$DP?V?X?$DP?Z?$LB?q?W?$DP?$PL?$LP?$KB?$KD@
  00217	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  0021c	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax
  00221	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0O@KDOBPHMN@?$DP?V?X?$DP?Z?$LB?q?W?$DP?$PL?$LP?$KB?$KD@+8
  00226	a3 08 00 00 00	 mov	 DWORD PTR ?netprocErrmsg@@3PADA+8, eax
  0022b	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ??_C@_0O@KDOBPHMN@?$DP?V?X?$DP?Z?$LB?q?W?$DP?$PL?$LP?$KB?$KD@+12
  00231	66 a3 0c 00 00
	00		 mov	 WORD PTR ?netprocErrmsg@@3PADA+12, ax

; 240  : 			return -1;

  00237	b8 ff ff ff ff	 mov	 eax, -1
  0023c	66 0f d6 05 00
	00 00 00	 movq	 QWORD PTR ?netprocErrmsg@@3PADA, xmm0

; 398  : 	return 0;
; 399  : }

  00244	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00247	33 cd		 xor	 ecx, ebp
  00249	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0024e	8b e5		 mov	 esp, ebp
  00250	5d		 pop	 ebp
  00251	c3		 ret	 0
$LN20@ConnectWGS:

; 241  : 		}
; 242  : 	}else if (connectServerCounter >= 1 && connectServerCounter <= 70){

  00252	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00255	83 f8 45	 cmp	 eax, 69			; 00000045H
  00258	0f 87 0b 01 00
	00		 ja	 $LN29@ConnectWGS

; 243  : 		fd_set rfds, wfds, efds;
; 244  : 		struct timeval tm;
; 245  : 
; 246  : 		if (++connectServerCounter == 70)

  0025e	41		 inc	 ecx

; 247  : 			connectServerCounter = 69;
; 248  : 		tm.tv_sec = 0;

  0025f	c7 85 d8 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _tm$2[ebp], 0
  00269	83 f9 46	 cmp	 ecx, 70			; 00000046H

; 249  : 		tm.tv_usec = 0;

  0026c	c7 85 dc fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _tm$2[ebp+4], 0
  00276	b8 45 00 00 00	 mov	 eax, 69			; 00000045H

; 250  : 		FD_ZERO(&rfds);
; 251  : 		FD_ZERO(&wfds);
; 252  : 		FD_ZERO(&efds);
; 253  : 		FD_SET(sockfd, &rfds);

  0027b	c7 85 e0 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR _rfds$6[ebp], 1
  00285	0f 44 c8	 cmove	 ecx, eax

; 254  : 		FD_SET(sockfd, &wfds);

  00288	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _wfds$10[ebp], 1
  00292	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  00297	89 85 e4 fc ff
	ff		 mov	 DWORD PTR _rfds$6[ebp+4], eax
  0029d	89 85 ec fe ff
	ff		 mov	 DWORD PTR _wfds$10[ebp+4], eax

; 255  : 		FD_SET(sockfd, &efds);

  002a3	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _efds$8[ebp+4], eax

; 256  : 		int a = select(2, &rfds, &wfds, &efds, &tm);

  002a9	8d 85 d8 fc ff
	ff		 lea	 eax, DWORD PTR _tm$2[ebp]
  002af	50		 push	 eax
  002b0	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _efds$8[ebp]
  002b6	89 0d 00 00 00
	00		 mov	 DWORD PTR ?connectServerCounter@@3HA, ecx ; connectServerCounter
  002bc	50		 push	 eax
  002bd	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _wfds$10[ebp]
  002c3	c7 85 e4 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR _efds$8[ebp], 1
  002cd	50		 push	 eax
  002ce	8d 85 e0 fc ff
	ff		 lea	 eax, DWORD PTR _rfds$6[ebp]
  002d4	50		 push	 eax
  002d5	6a 02		 push	 2
  002d7	e8 00 00 00 00	 call	 _select@20

; 257  : 		if (FD_ISSET(sockfd, &wfds))

  002dc	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _wfds$10[ebp]
  002e2	50		 push	 eax
  002e3	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  002e9	e8 00 00 00 00	 call	 ___WSAFDIsSet@8
  002ee	85 c0		 test	 eax, eax
  002f0	74 14		 je	 SHORT $LN35@ConnectWGS

; 258  : 		{
; 259  : 			connectServerCounter = 71;

  002f2	c7 05 00 00 00
	00 47 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, 71 ; connectServerCounter, 00000047H

; 260  : 			server_choosed = 100;

  002fc	c7 05 00 00 00
	00 64 00 00 00	 mov	 DWORD PTR ?server_choosed@@3HA, 100 ; server_choosed, 00000064H
$LN35@ConnectWGS:

; 261  : 		}
; 262  : #ifdef _OMIT_WGS
; 263  : 		testtest();
; 264  : 		connectServerCounter = 143;   // æš‚å®š
; 265  : 		iWGS = 7;
; 266  : #endif
; 267  : 		if (FD_ISSET(sockfd, &efds))

  00306	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _efds$8[ebp]
  0030c	50		 push	 eax
  0030d	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  00313	e8 00 00 00 00	 call	 ___WSAFDIsSet@8
  00318	85 c0		 test	 eax, eax
  0031a	0f 84 17 03 00
	00		 je	 $LN64@ConnectWGS

; 268  : 		{
; 269  : #ifdef _NB_æ–­çº¿è‡ªåŠ¨é‡è¿ž
; 270  : 			PcLanded.ç™»é™†å»¶æ—¶æ—¶é—´ = TimeGetTime() + 2000;

  00320	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00325	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H

; 271  : #endif
; 272  : 			sprintf(netprocErrmsg, NET_ERRMSG_NOTCONNECT);

  0032a	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@NBOLBDPM@?$LN?$LK?E?f?$LP?$KB?$MA?L?A?v?5?D?$KL?$LP?$MA?$LN?$LK?$LM?$KN?$LJ?v?$LE?B?5?G?v?$MA?g?5?A?$KB@
  0032f	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  00334	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax
  00339	e8 00 00 00 00	 call	 _sprintf
  0033e	83 c4 08	 add	 esp, 8

; 273  : 			closesocket(sockfd);

  00341	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  00347	e8 00 00 00 00	 call	 _closesocket@4

; 274  : 			dwServer = NULL;

  0034c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 0 ; dwServer

; 275  : 			return -6;

  00356	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH

; 398  : 	return 0;
; 399  : }

  0035b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0035e	33 cd		 xor	 ecx, ebp
  00360	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00365	8b e5		 mov	 esp, ebp
  00367	5d		 pop	 ebp
  00368	c3		 ret	 0
$LN29@ConnectWGS:

; 276  : 		}
; 277  : 	}
; 278  : 	else if (connectServerCounter == 71)

  00369	83 f9 47	 cmp	 ecx, 71			; 00000047H
  0036c	0f 85 f4 00 00
	00		 jne	 $LN37@ConnectWGS

; 279  : 	{
; 280  : 		if (iWGS == 2)

  00372	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iWGS@@3HA ; iWGS
  00377	83 f8 02	 cmp	 eax, 2
  0037a	0f 85 bc 02 00
	00		 jne	 $LN60@ConnectWGS

; 281  : 		{
; 282  : 			unsigned long flg = 1;
; 283  : 			struct sockaddr_in sin;
; 284  : 			struct hostent *h;
; 285  : 
; 286  : 			closesocket(sockfd);

  00380	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  00386	c7 85 dc fc ff
	ff 01 00 00 00	 mov	 DWORD PTR _flg$3[ebp], 1
  00390	e8 00 00 00 00	 call	 _closesocket@4

; 287  : 			dwServer = NULL;
; 288  : 			if (INVALID_SOCKET == (sockfd = socket(AF_INET, SOCK_STREAM, 0)))

  00395	6a 00		 push	 0
  00397	6a 01		 push	 1
  00399	6a 02		 push	 2
  0039b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 0 ; dwServer
  003a5	e8 00 00 00 00	 call	 _socket@12
  003aa	a3 00 00 00 00	 mov	 DWORD PTR ?sockfd@@3IA, eax ; sockfd
  003af	83 f8 ff	 cmp	 eax, -1
  003b2	0f 84 b8 fc ff
	ff		 je	 $LN65@ConnectWGS

; 289  : 			{
; 290  : #ifdef _NB_æ–­çº¿è‡ªåŠ¨é‡è¿ž
; 291  : 				PcLanded.ç™»é™†å»¶æ—¶æ—¶é—´ = TimeGetTime() + 2000;
; 292  : #endif
; 293  : 				sprintf(netprocErrmsg, NET_ERRMSG_SOCKETERROR);
; 294  : 				return -3;
; 295  : 			}
; 296  : 			ioctlsocket(sockfd, FIONBIO, &flg);

  003b8	8d 8d dc fc ff
	ff		 lea	 ecx, DWORD PTR _flg$3[ebp]
  003be	51		 push	 ecx
  003bf	68 7e 66 04 80	 push	 -2147195266		; 8004667eH
  003c4	50		 push	 eax
  003c5	e8 00 00 00 00	 call	 _ioctlsocket@12

; 297  : 			sin.sin_family = AF_INET;

  003ca	b8 02 00 00 00	 mov	 eax, 2
  003cf	66 89 45 ec	 mov	 WORD PTR _sin$11[ebp], ax

; 298  : 			sin.sin_port = htons(wCS);

  003d3	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?wCS@@3GA	; wCS
  003da	50		 push	 eax
  003db	e8 00 00 00 00	 call	 _htons@4

; 299  : 			sin.sin_addr.s_addr = inet_addr(szCSIP);

  003e0	68 00 00 00 00	 push	 OFFSET ?szCSIP@@3PADA	; szCSIP
  003e5	66 89 45 ee	 mov	 WORD PTR _sin$11[ebp+2], ax
  003e9	e8 00 00 00 00	 call	 _inet_addr@4
  003ee	89 45 f0	 mov	 DWORD PTR _sin$11[ebp+4], eax

; 300  : 			if (sin.sin_addr.s_addr == -1)

  003f1	83 f8 ff	 cmp	 eax, -1
  003f4	75 27		 jne	 SHORT $LN41@ConnectWGS

; 301  : 			{
; 302  : 				if (!(h = gethostbyname(szCSIP)))

  003f6	68 00 00 00 00	 push	 OFFSET ?szCSIP@@3PADA	; szCSIP
  003fb	e8 00 00 00 00	 call	 _gethostbyname@4
  00400	85 c0		 test	 eax, eax
  00402	75 0f		 jne	 SHORT $LN42@ConnectWGS

; 303  : 				{
; 304  : #ifdef _NB_æ–­çº¿è‡ªåŠ¨é‡è¿ž
; 305  : 					PcLanded.ç™»é™†å»¶æ—¶æ—¶é—´ = TimeGetTime() + 2000;

  00404	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime

; 306  : #endif
; 307  : 					sprintf(netprocErrmsg, NET_ERRMSG_NOTGETADDR, "CS");

  00409	68 00 00 00 00	 push	 OFFSET ??_C@_02ODPEBLOD@CS@

; 308  : 					closesocket(sockfd);
; 309  : 					dwServer = NULL;
; 310  : 					return -4;

  0040e	e9 e7 fc ff ff	 jmp	 $LN68@ConnectWGS
$LN42@ConnectWGS:

; 311  : 				}
; 312  : 				memcpy((void*)&sin.sin_addr.s_addr, h->h_addr, sizeof(struct in_addr));

  00413	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00416	8b 00		 mov	 eax, DWORD PTR [eax]
  00418	8b 00		 mov	 eax, DWORD PTR [eax]
  0041a	89 45 f0	 mov	 DWORD PTR _sin$11[ebp+4], eax
$LN41@ConnectWGS:

; 313  : 			}
; 314  : 			int ret = connect(sockfd, (struct sockaddr*)&sin, sizeof(sin));

  0041d	6a 10		 push	 16			; 00000010H
  0041f	8d 45 ec	 lea	 eax, DWORD PTR _sin$11[ebp]
  00422	50		 push	 eax
  00423	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  00429	e8 00 00 00 00	 call	 _connect@12

; 315  : 			if (ret == SOCKET_ERROR)

  0042e	83 f8 ff	 cmp	 eax, -1
  00431	75 10		 jne	 SHORT $LN44@ConnectWGS

; 316  : 			{
; 317  : 				if (WSAGetLastError() != WSAEWOULDBLOCK)

  00433	e8 00 00 00 00	 call	 _WSAGetLastError@0
  00438	3d 33 27 00 00	 cmp	 eax, 10035		; 00002733H
  0043d	0f 85 27 fd ff
	ff		 jne	 $LN67@ConnectWGS
$LN44@ConnectWGS:

; 318  : 				{
; 319  : 					closesocket(sockfd);
; 320  : 					dwServer = NULL;
; 321  : #ifdef _NB_æ–­çº¿è‡ªåŠ¨é‡è¿ž
; 322  : 					PcLanded.ç™»é™†å»¶æ—¶æ—¶é—´ = TimeGetTime() + 2000;
; 323  : #endif
; 324  : 					sprintf(netprocErrmsg, NET_ERRMSG_NOTCONNECT_S);
; 325  : 					return -5;
; 326  : 				}
; 327  : 			}
; 328  : 			dwServer = CS;

  00443	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 2 ; dwServer

; 329  : 			iWGS = 3;

  0044d	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?iWGS@@3HA, 3	; iWGS

; 330  : 			connectServerCounter = 72;

  00457	c7 05 00 00 00
	00 48 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, 72 ; connectServerCounter, 00000048H

; 331  : 		}
; 332  : 	}

  00461	e9 6b fd ff ff	 jmp	 $LN61@ConnectWGS
$LN37@ConnectWGS:

; 333  : 	else if (connectServerCounter >= 72 && connectServerCounter <= 140)

  00466	8d 41 b8	 lea	 eax, DWORD PTR [ecx-72]
  00469	83 f8 44	 cmp	 eax, 68			; 00000044H
  0046c	0f 87 0e 01 00
	00		 ja	 $LN45@ConnectWGS

; 334  : 	{
; 335  : 		fd_set rfds, wfds, efds;
; 336  : 		struct timeval tm;
; 337  : 
; 338  : 		if (++connectServerCounter == 140)

  00472	41		 inc	 ecx

; 339  : 			connectServerCounter = 139;
; 340  : 		tm.tv_sec = 0;

  00473	c7 85 d8 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _tm$1[ebp], 0
  0047d	81 f9 8c 00 00
	00		 cmp	 ecx, 140		; 0000008cH

; 341  : 		tm.tv_usec = 0;

  00483	c7 85 dc fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _tm$1[ebp+4], 0
  0048d	b8 8b 00 00 00	 mov	 eax, 139		; 0000008bH

; 342  : 		FD_ZERO(&rfds);
; 343  : 		FD_ZERO(&wfds);
; 344  : 		FD_ZERO(&efds);
; 345  : 		FD_SET(sockfd, &rfds);

  00492	c7 85 e0 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR _rfds$5[ebp], 1
  0049c	0f 44 c8	 cmove	 ecx, eax

; 346  : 		FD_SET(sockfd, &wfds);

  0049f	c7 85 e4 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR _wfds$7[ebp], 1
  004a9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  004ae	89 85 e4 fc ff
	ff		 mov	 DWORD PTR _rfds$5[ebp+4], eax
  004b4	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _wfds$7[ebp+4], eax

; 347  : 		FD_SET(sockfd, &efds);

  004ba	89 85 ec fe ff
	ff		 mov	 DWORD PTR _efds$9[ebp+4], eax

; 348  : 		int a = select(2, &rfds, &wfds, &efds, &tm);

  004c0	8d 85 d8 fc ff
	ff		 lea	 eax, DWORD PTR _tm$1[ebp]
  004c6	50		 push	 eax
  004c7	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _efds$9[ebp]
  004cd	89 0d 00 00 00
	00		 mov	 DWORD PTR ?connectServerCounter@@3HA, ecx ; connectServerCounter
  004d3	50		 push	 eax
  004d4	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _wfds$7[ebp]
  004da	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _efds$9[ebp], 1
  004e4	50		 push	 eax
  004e5	8d 85 e0 fc ff
	ff		 lea	 eax, DWORD PTR _rfds$5[ebp]
  004eb	50		 push	 eax
  004ec	6a 02		 push	 2
  004ee	e8 00 00 00 00	 call	 _select@20

; 349  : 		if (FD_ISSET(sockfd, &wfds))

  004f3	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _wfds$7[ebp]
  004f9	50		 push	 eax
  004fa	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  00500	e8 00 00 00 00	 call	 ___WSAFDIsSet@8
  00505	85 c0		 test	 eax, eax
  00507	74 14		 je	 SHORT $LN51@ConnectWGS

; 350  : 		{
; 351  : 			connectServerCounter = 141;

  00509	c7 05 00 00 00
	00 8d 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, 141 ; connectServerCounter, 0000008dH

; 352  : 			server_choosed = 100;

  00513	c7 05 00 00 00
	00 64 00 00 00	 mov	 DWORD PTR ?server_choosed@@3HA, 100 ; server_choosed, 00000064H
$LN51@ConnectWGS:

; 353  : 		}
; 354  : 		if (FD_ISSET(sockfd, &efds))

  0051d	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _efds$9[ebp]
  00523	50		 push	 eax
  00524	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  0052a	e8 00 00 00 00	 call	 ___WSAFDIsSet@8
  0052f	85 c0		 test	 eax, eax
  00531	0f 84 00 01 00
	00		 je	 $LN64@ConnectWGS

; 355  : 		{
; 356  : #ifdef _NB_æ–­çº¿è‡ªåŠ¨é‡è¿ž
; 357  : 			PcLanded.ç™»é™†å»¶æ—¶æ—¶é—´ = TimeGetTime() + 2000;

  00537	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  0053c	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H

; 358  : #endif
; 359  : 			sprintf(netprocErrmsg, NET_ERRMSG_NOTCONNECT);

  00541	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@NBOLBDPM@?$LN?$LK?E?f?$LP?$KB?$MA?L?A?v?5?D?$KL?$LP?$MA?$LN?$LK?$LM?$KN?$LJ?v?$LE?B?5?G?v?$MA?g?5?A?$KB@
  00546	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  0054b	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax
  00550	e8 00 00 00 00	 call	 _sprintf
  00555	83 c4 08	 add	 esp, 8

; 360  : 			closesocket(sockfd);

  00558	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  0055e	e8 00 00 00 00	 call	 _closesocket@4

; 361  : 			dwServer = NULL;

  00563	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 0 ; dwServer

; 362  : 			return -6;

  0056d	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH

; 398  : 	return 0;
; 399  : }

  00572	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00575	33 cd		 xor	 ecx, ebp
  00577	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0057c	8b e5		 mov	 esp, ebp
  0057e	5d		 pop	 ebp
  0057f	c3		 ret	 0
$LN45@ConnectWGS:

; 363  : 		}
; 364  : 	}
; 365  : 	else if (connectServerCounter == 141)

  00580	81 f9 8d 00 00
	00		 cmp	 ecx, 141		; 0000008dH
  00586	75 2c		 jne	 SHORT $LN53@ConnectWGS

; 366  : 	{
; 367  : 		if (iWGS == 4)

  00588	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iWGS@@3HA ; iWGS
  0058d	83 f8 04	 cmp	 eax, 4
  00590	0f 85 a6 00 00
	00		 jne	 $LN60@ConnectWGS

; 368  : 		{
; 369  : 			DoSKey();

  00596	e8 00 00 00 00	 call	 ?DoSKey@@YAXXZ		; DoSKey

; 370  : 			connectServerCounter = 142;

  0059b	c7 05 00 00 00
	00 8e 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, 142 ; connectServerCounter, 0000008eH

; 371  : 			iWGS = 5;

  005a5	c7 05 00 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?iWGS@@3HA, 5	; iWGS

; 372  : 		}
; 373  : 	}

  005af	e9 1d fc ff ff	 jmp	 $LN61@ConnectWGS
$LN53@ConnectWGS:

; 374  : 	else if (connectServerCounter == 142)

  005b4	81 f9 8e 00 00
	00		 cmp	 ecx, 142		; 0000008eH
  005ba	75 28		 jne	 SHORT $LN56@ConnectWGS

; 375  : 	{
; 376  : 		if (iWGS == 6)

  005bc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iWGS@@3HA ; iWGS
  005c1	83 f8 06	 cmp	 eax, 6
  005c4	75 76		 jne	 SHORT $LN60@ConnectWGS

; 377  : 		{
; 378  : 			DoHellow();

  005c6	e8 00 00 00 00	 call	 ?DoHellow@@YAXXZ	; DoHellow

; 379  : 			connectServerCounter = 143;

  005cb	c7 05 00 00 00
	00 8f 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, 143 ; connectServerCounter, 0000008fH

; 380  : 			iWGS = 7;

  005d5	c7 05 00 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?iWGS@@3HA, 7	; iWGS

; 381  : 		}
; 382  : 	}

  005df	e9 ed fb ff ff	 jmp	 $LN61@ConnectWGS
$LN56@ConnectWGS:

; 383  : 	else if (connectServerCounter == 143)

  005e4	81 f9 8f 00 00
	00		 cmp	 ecx, 143		; 0000008fH
  005ea	75 4b		 jne	 SHORT $LN64@ConnectWGS

; 384  : 	{
; 385  : 		if (iWGS == 8)

  005ec	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iWGS@@3HA ; iWGS
  005f1	83 f8 08	 cmp	 eax, 8
  005f4	75 46		 jne	 SHORT $LN60@ConnectWGS

; 386  : 		{
; 387  : 			cleanupNetwork();

  005f6	e8 00 00 00 00	 call	 ?cleanupNetwork@@YAXXZ	; cleanupNetwork

; 388  : 			disconnectServerFlag = TRUE;
; 389  : 			oldDisconnectServerFlag = TRUE;
; 390  : 			closesocket(sockfd);

  005fb	ff 35 00 00 00
	00		 push	 DWORD PTR ?sockfd@@3IA	; sockfd
  00601	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?disconnectServerFlag@@3HA, 1 ; disconnectServerFlag
  0060b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?oldDisconnectServerFlag@@3HA, 1 ; oldDisconnectServerFlag
  00615	e8 00 00 00 00	 call	 _closesocket@4

; 391  : 			dwServer = GS;

  0061a	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 3 ; dwServer

; 392  : 			return 1;

  00624	b8 01 00 00 00	 mov	 eax, 1

; 398  : 	return 0;
; 399  : }

  00629	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0062c	33 cd		 xor	 ecx, ebp
  0062e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00633	8b e5		 mov	 esp, ebp
  00635	5d		 pop	 ebp
  00636	c3		 ret	 0
$LN64@ConnectWGS:

; 383  : 	else if (connectServerCounter == 143)

  00637	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iWGS@@3HA ; iWGS
$LN60@ConnectWGS:

; 393  : 		}
; 394  : 	}
; 395  : 	if (iWGS == 9)

  0063c	83 f8 09	 cmp	 eax, 9
  0063f	0f 85 8c fb ff
	ff		 jne	 $LN61@ConnectWGS

; 396  : 		return -7;

  00645	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H

; 398  : 	return 0;
; 399  : }

  0064a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0064d	33 cd		 xor	 ecx, ebp
  0064f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00654	8b e5		 mov	 esp, ebp
  00656	5d		 pop	 ebp
  00657	c3		 ret	 0
$LN62@ConnectWGS:
  00658	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0065b	33 c0		 xor	 eax, eax
  0065d	33 cd		 xor	 ecx, ebp
  0065f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00664	8b e5		 mov	 esp, ebp
  00666	5d		 pop	 ebp
  00667	c3		 ret	 0
?ConnectWGS@@YAHXZ ENDP					; ConnectWGS
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\system\netproc.cpp
;	COMDAT ?initConnectServer@@YAXXZ
_TEXT	SEGMENT
?initConnectServer@@YAXXZ PROC				; initConnectServer, COMDAT

; 152  : 	connectServerCounter = 0;

  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, 0 ; connectServerCounter

; 153  : }

  0000a	c3		 ret	 0
?initConnectServer@@YAXXZ ENDP				; initConnectServer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _sscanf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sscanf	PROC						; COMDAT

; 2247 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2153 :         return __stdio_common_vsscanf(

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_scanf_options
  00016	ff 70 04	 push	 DWORD PTR [eax+4]
  00019	ff 30		 push	 DWORD PTR [eax]
  0001b	e8 00 00 00 00	 call	 ___stdio_common_vsscanf
  00020	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);
; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);
; 2252 :         __crt_va_end(_ArgList);
; 2253 :         return _Result;
; 2254 :     }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);
; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1777 : 
; 1778 :         __crt_va_end(_ArgList);
; 1779 :         return _Result;
; 1780 :     }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 956  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);
; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Format$[ebp]
  00007	6a 01		 push	 1
  00009	e8 00 00 00 00	 call	 ___acrt_iob_func
  0000e	83 c4 04	 add	 esp, 4

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00011	8d 4d 0c	 lea	 ecx, DWORD PTR __Format$[ebp+4]
  00014	51		 push	 ecx
  00015	6a 00		 push	 0
  00017	56		 push	 esi
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001e	ff 70 04	 push	 DWORD PTR [eax+4]
  00021	ff 30		 push	 DWORD PTR [eax]
  00023	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  00028	83 c4 18	 add	 esp, 24			; 00000018H

; 961  :         __crt_va_end(_ArgList);
; 962  :         return _Result;

  0002b	5e		 pop	 esi

; 963  :     }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 837  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Stream$[ebp]
  0000f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00014	ff 70 04	 push	 DWORD PTR [eax+4]
  00017	ff 30		 push	 DWORD PTR [eax]
  00019	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);
; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 842  :         __crt_va_end(_ArgList);
; 843  :         return _Result;
; 844  :     }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00005	c3		 ret	 0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
