; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30133.0 

	TITLE	\\VBOXSVR\_stoneage\repos\ssm-sacli\Release\PtternSeparationBin.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?MaxAdrnID@@3HA					; MaxAdrnID
PUBLIC	?nextMaxAdrnID@@3HA				; nextMaxAdrnID
_BSS	SEGMENT
?MaxAdrnID@@3HA DD 01H DUP (?)				; MaxAdrnID
?nextMaxAdrnID@@3HA DD 01H DUP (?)			; nextMaxAdrnID
_BSS	ENDS
PUBLIC	?AdrnInit@@YAHPBD0H@Z				; AdrnInit
PUBLIC	?InitPteernSeparationBin@@YAXPBD@Z		; InitPteernSeparationBin
PUBLIC	?getfilesize@@YAHPAU_iobuf@@@Z			; getfilesize
PUBLIC	??_C@_01KICIPPFI@?2@				; `string'
PUBLIC	??_C@_03EMIMMIHL@?$CK?4?$CK@			; `string'
PUBLIC	??_C@_06PDPEOAFG@?$CFs?1?1?$CFs@		; `string'
PUBLIC	??_C@_0N@KDCKLNDG@?$CFs?1?1adrn?4bin@		; `string'
PUBLIC	??_C@_0N@OBDDOEEE@?$CFs?1?1real?4bin@		; `string'
PUBLIC	??_C@_0BA@DMKBCIEN@?$CFs?1?1spradrn?4bin@	; `string'
PUBLIC	??_C@_0M@FLJNEGFM@?$CFs?1?1spr?4bin@		; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
EXTRN	__imp__GetCurrentDirectoryA@8:PROC
EXTRN	__imp__FindClose@4:PROC
EXTRN	__imp__FindFirstFileA@8:PROC
EXTRN	__imp__FindNextFileA@8:PROC
EXTRN	__imp__lstrcpyA@8:PROC
EXTRN	__imp__lstrcatA@8:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	_fopen_s:PROC
EXTRN	_fclose:PROC
EXTRN	_feof:PROC
EXTRN	_fread:PROC
EXTRN	_fseek:PROC
EXTRN	_ftell:PROC
EXTRN	?InitSprBinFileOpen@@YAHPAD0@Z:PROC		; InitSprBinFileOpen
EXTRN	@__security_check_cookie@4:PROC
EXTRN	?adrnbuff@@3PAUADRNBIN@@A:BYTE			; adrnbuff
EXTRN	?bitmapnumbertable@@3PAKA:BYTE			; bitmapnumbertable
EXTRN	?Realbinfp@@3PAPAU_iobuf@@A:BYTE		; Realbinfp
EXTRN	___security_cookie:DWORD
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FLJNEGFM@?$CFs?1?1spr?4bin@
CONST	SEGMENT
??_C@_0M@FLJNEGFM@?$CFs?1?1spr?4bin@ DB '%s//spr.bin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DMKBCIEN@?$CFs?1?1spradrn?4bin@
CONST	SEGMENT
??_C@_0BA@DMKBCIEN@?$CFs?1?1spradrn?4bin@ DB '%s//spradrn.bin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OBDDOEEE@?$CFs?1?1real?4bin@
CONST	SEGMENT
??_C@_0N@OBDDOEEE@?$CFs?1?1real?4bin@ DB '%s//real.bin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KDCKLNDG@?$CFs?1?1adrn?4bin@
CONST	SEGMENT
??_C@_0N@KDCKLNDG@?$CFs?1?1adrn?4bin@ DB '%s//adrn.bin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06PDPEOAFG@?$CFs?1?1?$CFs@
CONST	SEGMENT
??_C@_06PDPEOAFG@?$CFs?1?1?$CFs@ DB '%s//%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03EMIMMIHL@?$CK?4?$CK@
CONST	SEGMENT
??_C@_03EMIMMIHL@?$CK?4?$CK@ DB '*.*', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2@
CONST	SEGMENT
??_C@_01KICIPPFI@?2@ DB '\', 00H			; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\other\PtternSeparationBin.cpp
;	COMDAT ?getfilesize@@YAHPAU_iobuf@@@Z
_TEXT	SEGMENT
_fp$ = 8						; size = 4
?getfilesize@@YAHPAU_iobuf@@@Z PROC			; getfilesize, COMDAT

; 19   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 20   : 	if (fp == NULL) return 0;

  00004	8b 7d 08	 mov	 edi, DWORD PTR _fp$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	75 05		 jne	 SHORT $LN2@getfilesiz
  0000b	33 c0		 xor	 eax, eax
  0000d	5f		 pop	 edi

; 26   : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
$LN2@getfilesiz:
  00010	56		 push	 esi

; 21   : 	int size;
; 22   : 	fseek(fp, 0, SEEK_END);

  00011	6a 02		 push	 2
  00013	6a 00		 push	 0
  00015	57		 push	 edi
  00016	e8 00 00 00 00	 call	 _fseek

; 23   : 	size = ftell(fp);

  0001b	57		 push	 edi
  0001c	e8 00 00 00 00	 call	 _ftell

; 24   : 	fseek(fp, 0, SEEK_SET);

  00021	6a 00		 push	 0
  00023	6a 00		 push	 0
  00025	57		 push	 edi
  00026	8b f0		 mov	 esi, eax
  00028	e8 00 00 00 00	 call	 _fseek
  0002d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 25   : 	return size;

  00030	8b c6		 mov	 eax, esi
  00032	5e		 pop	 esi
  00033	5f		 pop	 edi

; 26   : }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?getfilesize@@YAHPAU_iobuf@@@Z ENDP			; getfilesize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\other\PtternSeparationBin.cpp
;	COMDAT ?InitPteernSeparationBin@@YAXPBD@Z
_TEXT	SEGMENT
_lpszPath$GSCopy$1$ = -2088				; size = 4
_wfd$ = -2084						; size = 320
_szFindSprName$1 = -1764				; size = 260
_szFindSprAdrnName$2 = -1504				; size = 260
_szFindAdrnName$3 = -1244				; size = 260
_szFindRealName$4 = -984				; size = 260
_FilePath$5 = -724					; size = 200
_szFind$ = -524						; size = 260
_szFile$6 = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_lpszPath$ = 8						; size = 4
?InitPteernSeparationBin@@YAXPBD@Z PROC			; InitPteernSeparationBin, COMDAT

; 32   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 28 08 00
	00		 sub	 esp, 2088		; 00000828H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _lpszPath$[ebp]
  00016	53		 push	 ebx
  00017	56		 push	 esi

; 33   : 
; 34   : 	TCHAR szFind[MAX_PATH]; 
; 35   : 	lstrcpy(szFind, lpszPath); 

  00018	50		 push	 eax
  00019	89 85 d8 f7 ff
	ff		 mov	 DWORD PTR _lpszPath$GSCopy$1$[ebp], eax
  0001f	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szFind$[ebp]
  00025	50		 push	 eax
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8

; 36   : 	lstrcat(szFind, "\\"); 

  0002c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__lstrcatA@8
  00032	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szFind$[ebp]
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2@
  0003d	50		 push	 eax
  0003e	ff d6		 call	 esi

; 37   : 	lstrcat(szFind, "*.*"); // 找所有文件 

  00040	68 00 00 00 00	 push	 OFFSET ??_C@_03EMIMMIHL@?$CK?4?$CK@
  00045	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szFind$[ebp]
  0004b	50		 push	 eax
  0004c	ff d6		 call	 esi

; 38   : 	WIN32_FIND_DATA wfd; 
; 39   : 	HANDLE hFind = FindFirstFile(szFind, &wfd); 

  0004e	8d 85 dc f7 ff
	ff		 lea	 eax, DWORD PTR _wfd$[ebp]
  00054	50		 push	 eax
  00055	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szFind$[ebp]
  0005b	50		 push	 eax
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindFirstFileA@8
  00062	8b d8		 mov	 ebx, eax

; 40   : 	if (hFind == INVALID_HANDLE_VALUE) // 如果没有找到或查找失败 

  00064	83 fb ff	 cmp	 ebx, -1
  00067	0f 84 2e 01 00
	00		 je	 $LN1@InitPteern

; 41   : 		return; 
; 42   : 	int index = 2;

  0006d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__wsprintfA
  00073	57		 push	 edi
  00074	bf 02 00 00 00	 mov	 edi, 2
  00079	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@InitPteern:

; 43   : 	do 
; 44   : 	{ 
; 45   : 		if (wfd.cFileName[0] == '.') 

  00080	80 bd 08 f8 ff
	ff 2e		 cmp	 BYTE PTR _wfd$[ebp+44], 46 ; 0000002eH
  00087	0f 84 f0 00 00
	00		 je	 $LN2@InitPteern

; 46   : 			continue; // 过滤这两个目录 
; 47   : 		if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY){ 

  0008d	f6 85 dc f7 ff
	ff 10		 test	 BYTE PTR _wfd$[ebp], 16	; 00000010H
  00094	0f 84 e3 00 00
	00		 je	 $LN2@InitPteern

; 48   : 			TCHAR szFile[MAX_PATH]; 
; 49   : 			TCHAR szFindAdrnName[MAX_PATH]; 
; 50   : 			TCHAR szFindRealName[MAX_PATH]; 
; 51   : 			TCHAR szFindSprAdrnName[MAX_PATH]; 
; 52   : 			TCHAR szFindSprName[MAX_PATH]; 
; 53   : 
; 54   : 			char FilePath[200]; 
; 55   : 			GetCurrentDirectory(200,FilePath); 

  0009a	8d 85 2c fd ff
	ff		 lea	 eax, DWORD PTR _FilePath$5[ebp]
  000a0	50		 push	 eax
  000a1	68 c8 00 00 00	 push	 200			; 000000c8H
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentDirectoryA@8

; 56   : 			wsprintf(szFile, "%s//%s", FilePath, lpszPath); 

  000ac	ff b5 d8 f7 ff
	ff		 push	 DWORD PTR _lpszPath$GSCopy$1$[ebp]
  000b2	8d 85 2c fd ff
	ff		 lea	 eax, DWORD PTR _FilePath$5[ebp]
  000b8	50		 push	 eax
  000b9	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szFile$6[ebp]
  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_06PDPEOAFG@?$CFs?1?1?$CFs@
  000c4	50		 push	 eax
  000c5	ff d6		 call	 esi

; 57   : 			wsprintf(szFile, "%s//%s", lpszPath, wfd.cFileName); 

  000c7	8d 85 08 f8 ff
	ff		 lea	 eax, DWORD PTR _wfd$[ebp+44]
  000cd	50		 push	 eax
  000ce	ff b5 d8 f7 ff
	ff		 push	 DWORD PTR _lpszPath$GSCopy$1$[ebp]
  000d4	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szFile$6[ebp]
  000da	68 00 00 00 00	 push	 OFFSET ??_C@_06PDPEOAFG@?$CFs?1?1?$CFs@
  000df	50		 push	 eax
  000e0	ff d6		 call	 esi

; 58   : 
; 59   : #ifdef 分离补丁加密
; 60   : 			wsprintf(szFindAdrnName, "%s//adrn.sq", szFile); 
; 61   : 			wsprintf(szFindRealName, "%s//real.sq", szFile); 
; 62   : #else
; 63   : 			wsprintf(szFindAdrnName, "%s//adrn.bin", szFile);

  000e2	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szFile$6[ebp]
  000e8	50		 push	 eax
  000e9	8d 85 24 fb ff
	ff		 lea	 eax, DWORD PTR _szFindAdrnName$3[ebp]
  000ef	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KDCKLNDG@?$CFs?1?1adrn?4bin@
  000f4	50		 push	 eax
  000f5	ff d6		 call	 esi

; 64   : 			wsprintf(szFindRealName, "%s//real.bin", szFile);

  000f7	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szFile$6[ebp]
  000fd	50		 push	 eax
  000fe	8d 85 28 fc ff
	ff		 lea	 eax, DWORD PTR _szFindRealName$4[ebp]
  00104	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OBDDOEEE@?$CFs?1?1real?4bin@
  00109	50		 push	 eax
  0010a	ff d6		 call	 esi

; 65   : #endif
; 66   : 
; 67   : 			if(AdrnInit(szFindAdrnName, szFindRealName, index)==TRUE){

  0010c	57		 push	 edi
  0010d	8d 85 28 fc ff
	ff		 lea	 eax, DWORD PTR _szFindRealName$4[ebp]
  00113	50		 push	 eax
  00114	8d 85 24 fb ff
	ff		 lea	 eax, DWORD PTR _szFindAdrnName$3[ebp]
  0011a	50		 push	 eax
  0011b	e8 00 00 00 00	 call	 ?AdrnInit@@YAHPBD0H@Z	; AdrnInit
  00120	83 c4 44	 add	 esp, 68			; 00000044H
  00123	83 f8 01	 cmp	 eax, 1
  00126	75 46		 jne	 SHORT $LN10@InitPteern

; 68   : #ifdef 分离补丁加密
; 69   : 				wsprintf(szFindSprAdrnName, "%s//spradrn.sq", szFile); 
; 70   : 				wsprintf(szFindSprName, "%s//spr.sq", szFile); 
; 71   : #else
; 72   : 				wsprintf(szFindSprAdrnName, "%s//spradrn.bin", szFile); 

  00128	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szFile$6[ebp]
  0012e	50		 push	 eax
  0012f	8d 85 20 fa ff
	ff		 lea	 eax, DWORD PTR _szFindSprAdrnName$2[ebp]
  00135	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@DMKBCIEN@?$CFs?1?1spradrn?4bin@
  0013a	50		 push	 eax
  0013b	ff d6		 call	 esi

; 73   : 				wsprintf(szFindSprName, "%s//spr.bin", szFile); 

  0013d	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szFile$6[ebp]
  00143	50		 push	 eax
  00144	8d 85 1c f9 ff
	ff		 lea	 eax, DWORD PTR _szFindSprName$1[ebp]
  0014a	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FLJNEGFM@?$CFs?1?1spr?4bin@
  0014f	50		 push	 eax
  00150	ff d6		 call	 esi

; 74   : #endif
; 75   : 				extern BOOL InitSprBinFileOpen( char *SPR_BIN, char *SPRADRN_BIN );
; 76   : 				InitSprBinFileOpen(szFindSprName,szFindSprAdrnName);

  00152	8d 85 20 fa ff
	ff		 lea	 eax, DWORD PTR _szFindSprAdrnName$2[ebp]
  00158	50		 push	 eax
  00159	8d 85 1c f9 ff
	ff		 lea	 eax, DWORD PTR _szFindSprName$1[ebp]
  0015f	50		 push	 eax
  00160	e8 00 00 00 00	 call	 ?InitSprBinFileOpen@@YAHPAD0@Z ; InitSprBinFileOpen

; 77   : 				index++;

  00165	47		 inc	 edi
  00166	83 c4 20	 add	 esp, 32			; 00000020H

; 78   : 				if(index>100)break;

  00169	83 ff 64	 cmp	 edi, 100		; 00000064H
  0016c	7f 25		 jg	 SHORT $LN3@InitPteern
$LN10@InitPteern:

; 79   : 			}
; 80   : 			InitPteernSeparationBin(szFile); // 如果找到的是目录，则进入此目录进行递归

  0016e	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szFile$6[ebp]
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 ?InitPteernSeparationBin@@YAXPBD@Z ; InitPteernSeparationBin
  0017a	83 c4 04	 add	 esp, 4
$LN2@InitPteern:

; 81   : 		}else{ 
; 82   : 
; 83   : 		} 
; 84   : 	} while (FindNextFile(hFind, &wfd)); 

  0017d	8d 85 dc f7 ff
	ff		 lea	 eax, DWORD PTR _wfd$[ebp]
  00183	50		 push	 eax
  00184	53		 push	 ebx
  00185	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindNextFileA@8
  0018b	85 c0		 test	 eax, eax
  0018d	0f 85 ed fe ff
	ff		 jne	 $LL4@InitPteern
$LN3@InitPteern:

; 85   : 	FindClose(hFind); // 关闭查找句柄 

  00193	53		 push	 ebx
  00194	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindClose@4
  0019a	5f		 pop	 edi
$LN1@InitPteern:

; 86   : 
; 87   : } 

  0019b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0019e	5e		 pop	 esi
  0019f	33 cd		 xor	 ecx, ebp
  001a1	5b		 pop	 ebx
  001a2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a7	8b e5		 mov	 esp, ebp
  001a9	5d		 pop	 ebp
  001aa	c3		 ret	 0
?InitPteernSeparationBin@@YAXPBD@Z ENDP			; InitPteernSeparationBin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File \\VBOXSVR\_stoneage\repos\ssm-sacli\other\PtternSeparationBin.cpp
;	COMDAT ?AdrnInit@@YAHPBD0H@Z
_TEXT	SEGMENT
_Realfp$ = -92						; size = 4
_Addrbinfp$ = -88					; size = 4
_tmpadrnbuff$ = -84					; size = 80
__$ArrayPad$ = -4					; size = 4
_strAdrnFileName$ = 8					; size = 4
_strRealFileName$ = 12					; size = 4
_index$ = 16						; size = 4
?AdrnInit@@YAHPBD0H@Z PROC				; AdrnInit, COMDAT

; 90   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _strAdrnFileName$[ebp]
  00013	56		 push	 esi

; 91   : 	ADRNBIN tmpadrnbuff;
; 92   : 	FILE *Realfp, *Addrbinfp;
; 93   : 	nextMaxAdrnID = MaxAdrnID;

  00014	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?MaxAdrnID@@3HA ; MaxAdrnID
  0001a	57		 push	 edi
  0001b	8b 7d 0c	 mov	 edi, DWORD PTR _strRealFileName$[ebp]

; 94   : 	int maxid = MaxAdrnID;
; 95   : 	if (fopen_s(&Addrbinfp, strAdrnFileName, "rb")) {

  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  00023	50		 push	 eax
  00024	8d 45 a8	 lea	 eax, DWORD PTR _Addrbinfp$[ebp]
  00027	89 35 00 00 00
	00		 mov	 DWORD PTR ?nextMaxAdrnID@@3HA, esi ; nextMaxAdrnID
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _fopen_s
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	85 c0		 test	 eax, eax
  00038	0f 85 dc 00 00
	00		 jne	 $LN12@AdrnInit

; 96   : 		return FALSE;
; 97   : 	}
; 98   : 	if (fopen_s(&Realfp, strRealFileName, "rb")) {

  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  00043	8d 45 a4	 lea	 eax, DWORD PTR _Realfp$[ebp]
  00046	57		 push	 edi
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _fopen_s
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00050	85 c0		 test	 eax, eax
  00052	0f 85 c2 00 00
	00		 jne	 $LN12@AdrnInit

; 99   : 		return FALSE;
; 100  : 	}
; 101  : #ifdef 分离补丁加密
; 102  : VMProtectBegin("bin");
; 103  : 	int size = getfilesize(Addrbinfp);
; 104  : 	char * sadrnbin = (char*)malloc(size);
; 105  : 	fread(sadrnbin, 1, size, Addrbinfp);
; 106  : 	TEA解密((long*)sadrnbin, (size / 4), (long *)VMProtectDecryptStringA(_分离补丁密钥));
; 107  : VMProtectEnd();
; 108  : 	int i = 0;
; 109  : 	for (i; i < size / sizeof(ADRNBIN); i++) {
; 110  : 		memcpy(&tmpadrnbuff, sadrnbin + i * sizeof(ADRNBIN), sizeof(ADRNBIN));
; 111  : 		if (adrnbuff[tmpadrnbuff.bitmapno + maxid].bitmapno)
; 112  : 		{
; 113  : 			__asm nop;
; 114  : 		}
; 115  : 		adrnbuff[tmpadrnbuff.bitmapno + maxid] = tmpadrnbuff;
; 116  : 		Realbinfp[tmpadrnbuff.bitmapno + maxid] = Realfp;
; 117  : 		if ((ULONG)MaxAdrnID < tmpadrnbuff.bitmapno + maxid) {
; 118  : 			MaxAdrnID = tmpadrnbuff.bitmapno + maxid;
; 119  : 		}
; 120  : 		if (tmpadrnbuff.attr.bmpnumber != 0) {
; 121  : 			bitmapnumbertable[tmpadrnbuff.attr.bmpnumber] = tmpadrnbuff.bitmapno + maxid;
; 122  : 		}
; 123  : 	}
; 124  : 	fclose(Addrbinfp);
; 125  : 	free(sadrnbin);
; 126  : #else
; 127  : 	while (!feof(Addrbinfp)) {

  00058	ff 75 a8	 push	 DWORD PTR _Addrbinfp$[ebp]
  0005b	e8 00 00 00 00	 call	 _feof
  00060	83 c4 04	 add	 esp, 4
  00063	85 c0		 test	 eax, eax
  00065	0f 85 8f 00 00
	00		 jne	 $LN3@AdrnInit
  0006b	0f 1f 44 00 00	 npad	 5
$LL2@AdrnInit:

; 128  : 		fread(&tmpadrnbuff, sizeof(tmpadrnbuff), 1, Addrbinfp);

  00070	ff 75 a8	 push	 DWORD PTR _Addrbinfp$[ebp]
  00073	8d 45 ac	 lea	 eax, DWORD PTR _tmpadrnbuff$[ebp]
  00076	6a 01		 push	 1
  00078	6a 50		 push	 80			; 00000050H
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _fread

; 129  : 		adrnbuff[tmpadrnbuff.bitmapno + maxid] = tmpadrnbuff;

  00080	8b 4d ac	 mov	 ecx, DWORD PTR _tmpadrnbuff$[ebp]
  00083	83 c4 10	 add	 esp, 16			; 00000010H
  00086	0f 10 45 ac	 movups	 xmm0, XMMWORD PTR _tmpadrnbuff$[ebp]
  0008a	03 ce		 add	 ecx, esi
  0008c	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0008f	c1 e0 04	 shl	 eax, 4
  00092	05 00 00 00 00	 add	 eax, OFFSET ?adrnbuff@@3PAUADRNBIN@@A ; adrnbuff
  00097	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  0009a	0f 10 45 bc	 movups	 xmm0, XMMWORD PTR _tmpadrnbuff$[ebp+16]
  0009e	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0
  000a2	0f 10 45 cc	 movups	 xmm0, XMMWORD PTR _tmpadrnbuff$[ebp+32]
  000a6	0f 11 40 20	 movups	 XMMWORD PTR [eax+32], xmm0
  000aa	0f 10 45 dc	 movups	 xmm0, XMMWORD PTR _tmpadrnbuff$[ebp+48]
  000ae	0f 11 40 30	 movups	 XMMWORD PTR [eax+48], xmm0
  000b2	0f 10 45 ec	 movups	 xmm0, XMMWORD PTR _tmpadrnbuff$[ebp+64]
  000b6	0f 11 40 40	 movups	 XMMWORD PTR [eax+64], xmm0

; 130  : 		Realbinfp[tmpadrnbuff.bitmapno + maxid] = Realfp;

  000ba	8b 45 a4	 mov	 eax, DWORD PTR _Realfp$[ebp]
  000bd	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?Realbinfp@@3PAPAU_iobuf@@A[ecx*4], eax

; 131  : 		if ((ULONG)MaxAdrnID < tmpadrnbuff.bitmapno + maxid) {

  000c4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?MaxAdrnID@@3HA ; MaxAdrnID
  000c9	3b c1		 cmp	 eax, ecx

; 132  : 			MaxAdrnID = tmpadrnbuff.bitmapno + maxid;
; 133  : 		}
; 134  : 		if (tmpadrnbuff.attr.bmpnumber != 0) {

  000cb	66 0f 73 d8 0c	 psrldq	 xmm0, 12		; 0000000cH
  000d0	0f 42 c1	 cmovb	 eax, ecx
  000d3	a3 00 00 00 00	 mov	 DWORD PTR ?MaxAdrnID@@3HA, eax ; MaxAdrnID
  000d8	66 0f 7e c0	 movd	 eax, xmm0
  000dc	85 c0		 test	 eax, eax
  000de	74 07		 je	 SHORT $LN7@AdrnInit

; 135  : 			bitmapnumbertable[tmpadrnbuff.attr.bmpnumber] = tmpadrnbuff.bitmapno + maxid;

  000e0	89 0c 85 00 00
	00 00		 mov	 DWORD PTR ?bitmapnumbertable@@3PAKA[eax*4], ecx
$LN7@AdrnInit:

; 99   : 		return FALSE;
; 100  : 	}
; 101  : #ifdef 分离补丁加密
; 102  : VMProtectBegin("bin");
; 103  : 	int size = getfilesize(Addrbinfp);
; 104  : 	char * sadrnbin = (char*)malloc(size);
; 105  : 	fread(sadrnbin, 1, size, Addrbinfp);
; 106  : 	TEA解密((long*)sadrnbin, (size / 4), (long *)VMProtectDecryptStringA(_分离补丁密钥));
; 107  : VMProtectEnd();
; 108  : 	int i = 0;
; 109  : 	for (i; i < size / sizeof(ADRNBIN); i++) {
; 110  : 		memcpy(&tmpadrnbuff, sadrnbin + i * sizeof(ADRNBIN), sizeof(ADRNBIN));
; 111  : 		if (adrnbuff[tmpadrnbuff.bitmapno + maxid].bitmapno)
; 112  : 		{
; 113  : 			__asm nop;
; 114  : 		}
; 115  : 		adrnbuff[tmpadrnbuff.bitmapno + maxid] = tmpadrnbuff;
; 116  : 		Realbinfp[tmpadrnbuff.bitmapno + maxid] = Realfp;
; 117  : 		if ((ULONG)MaxAdrnID < tmpadrnbuff.bitmapno + maxid) {
; 118  : 			MaxAdrnID = tmpadrnbuff.bitmapno + maxid;
; 119  : 		}
; 120  : 		if (tmpadrnbuff.attr.bmpnumber != 0) {
; 121  : 			bitmapnumbertable[tmpadrnbuff.attr.bmpnumber] = tmpadrnbuff.bitmapno + maxid;
; 122  : 		}
; 123  : 	}
; 124  : 	fclose(Addrbinfp);
; 125  : 	free(sadrnbin);
; 126  : #else
; 127  : 	while (!feof(Addrbinfp)) {

  000e7	ff 75 a8	 push	 DWORD PTR _Addrbinfp$[ebp]
  000ea	e8 00 00 00 00	 call	 _feof
  000ef	83 c4 04	 add	 esp, 4
  000f2	85 c0		 test	 eax, eax
  000f4	0f 84 76 ff ff
	ff		 je	 $LL2@AdrnInit
$LN3@AdrnInit:

; 136  : 		}
; 137  : 	}
; 138  : 	fclose(Addrbinfp);

  000fa	ff 75 a8	 push	 DWORD PTR _Addrbinfp$[ebp]
  000fd	e8 00 00 00 00	 call	 _fclose
  00102	83 c4 04	 add	 esp, 4

; 139  : #endif
; 140  : 	return TRUE;

  00105	b8 01 00 00 00	 mov	 eax, 1
  0010a	5f		 pop	 edi

; 141  : }

  0010b	5e		 pop	 esi
  0010c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010f	33 cd		 xor	 ecx, ebp
  00111	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00116	8b e5		 mov	 esp, ebp
  00118	5d		 pop	 ebp
  00119	c3		 ret	 0
$LN12@AdrnInit:
  0011a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011d	33 c0		 xor	 eax, eax
  0011f	5f		 pop	 edi
  00120	33 cd		 xor	 ecx, ebp
  00122	5e		 pop	 esi
  00123	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00128	8b e5		 mov	 esp, ebp
  0012a	5d		 pop	 ebp
  0012b	c3		 ret	 0
?AdrnInit@@YAHPBD0H@Z ENDP				; AdrnInit
_TEXT	ENDS
END
