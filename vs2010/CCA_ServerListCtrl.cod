; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Administrator\Desktop\????? ??\????? ??\Client Source Code\system\CCA_ServerListCtrl.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?serverListDecodeComplete@@3HA			; serverListDecodeComplete
PUBLIC	?serverListEncodeArray@@3PADA			; serverListEncodeArray
PUBLIC	?serverListDecodeArray@@3PADA			; serverListDecodeArray
PUBLIC	?serverListEncodeRealLenght@@3HA		; serverListEncodeRealLenght
_BSS	SEGMENT
?serverListDecodeComplete@@3HA DD 01H DUP (?)		; serverListDecodeComplete
?serverListEncodeArray@@3PADA DB 0800H DUP (?)		; serverListEncodeArray
?serverListDecodeArray@@3PADA DB 0800H DUP (?)		; serverListDecodeArray
_BSS	ENDS
_DATA	SEGMENT
?serverListEncodeRealLenght@@3HA DD 0ffffffffH		; serverListEncodeRealLenght
_DATA	ENDS
PUBLIC	?strstr@@YAPADQADQBD@Z				; strstr
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	?split_damage@@YAHPADDPAHI@Z			; split_damage
PUBLIC	?strncpy2@@YAPADPADPBDI@Z			; strncpy2
PUBLIC	?strncpysafe@@YAXPADIPBDH@Z			; strncpysafe
PUBLIC	?strcpysafe@@YAXPADIPBD@Z			; strcpysafe
PUBLIC	?ScanOneByte@@YAPADPADD@Z			; ScanOneByte
PUBLIC	?getStringFromIndexWithDelim_body@@YAHPAD0H0H0H@Z ; getStringFromIndexWithDelim_body
PUBLIC	?解析登陆列表明文@@YAXPAD0@Z			; 解析登陆列表明文
PUBLIC	?解密MAX内联代码@@YAXPADH@Z			; 解密MAX内联代码
PUBLIC	?写入serverMax@@YAXPADH@Z			; 写入serverMax
PUBLIC	?测试解码serverMax@@YAXXZ			; 测试解码serverMax
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_09KCBLGBPG@?$HM?$CFs?$HM?$CFs?4?$CFs?$AA@	; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0FN@LLDCKPMI@?$DP?z?$LM?$HM?X?$KB?u?U?$HM222?4186?451?4178?39065?6?$DP?z?$LM@ ; `string'
PUBLIC	??_C@_03BPOAKJOG@?$CFs?$AA?$AA@			; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_0L@PGDGOFEL@server?4max?$AA@		; `string'
EXTRN	_memset:PROC
EXTRN	__imp__strstr:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__lstrcpyA@8:PROC
EXTRN	__imp__lstrcatA@8:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__atoi:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp__fseek:PROC
EXTRN	__imp__ftell:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__chkstk:PROC
EXTRN	?gmsv@@3PAUgameserver@@A:BYTE			; gmsv
EXTRN	?gmgroup@@3PAUgamegroup@@A:BYTE			; gmgroup
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0L@PGDGOFEL@server?4max?$AA@
CONST	SEGMENT
??_C@_0L@PGDGOFEL@server?4max?$AA@ DB 'server.max', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BPOAKJOG@?$CFs?$AA?$AA@
CONST	SEGMENT
??_C@_03BPOAKJOG@?$CFs?$AA?$AA@ DB '%s', 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@LLDCKPMI@?$DP?z?$LM?$HM?X?$KB?u?U?$HM222?4186?451?4178?39065?6?$DP?z?$LM@
CONST	SEGMENT
??_C@_0FN@LLDCKPMI@?$DP?z?$LM?$HM?X?$KB?u?U?$HM222?4186?451?4178?39065?6?$DP?z?$LM@ DB '?'
	DB	0faH, 0bcH, '|', 0d8H, 0a1H, 0f5H, 0d5H, '|222.186.51.178:9065'
	DB	0aH, '?', 0faH, 0bcH, '|??', 0ecH, 0e9H, '?|amoijing.gicp.net:'
	DB	'9065', 0aH, '?', 0faH, 0bcH, '|', 0dcH, 0e2H, 0f2H, 0a2H, 0ecH
	DB	0e9H, '?|192.168.1.25:9065', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09KCBLGBPG@?$HM?$CFs?$HM?$CFs?4?$CFs?$AA@
CONST	SEGMENT
??_C@_09KCBLGBPG@?$HM?$CFs?$HM?$CFs?4?$CFs?$AA@ DB '|%s|%s.%s', 00H ; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\cca_serverlistctrl.cpp
;	COMDAT ?测试解码serverMax@@YAXXZ
_TEXT	SEGMENT
_pMax1$1 = -44						; size = 4
_pMax$2 = -32						; size = 4
_nFileLen$3 = -20					; size = 4
_pf$ = -8						; size = 4
?测试解码serverMax@@YAXXZ PROC				; 测试解码serverMax, COMDAT

; 609  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 610  : 	FILE *pf;
; 611  : 	if ((pf = fopen("server.max", "r")) == NULL)

  0001e	8b f4		 mov	 esi, esp
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0L@PGDGOFEL@server?4max?$AA@
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00030	83 c4 08	 add	 esp, 8
  00033	3b f4		 cmp	 esi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	89 45 f8	 mov	 DWORD PTR _pf$[ebp], eax
  0003d	83 7d f8 00	 cmp	 DWORD PTR _pf$[ebp], 0
  00041	75 05		 jne	 SHORT $LN2@

; 612  : 	{
; 613  : 	}
; 614  : 	else

  00043	e9 2a 01 00 00	 jmp	 $LN1@
$LN2@:

; 615  : 	{
; 616  : 		fseek(pf, 0, SEEK_END); //定位到文件末 

  00048	8b f4		 mov	 esi, esp
  0004a	6a 02		 push	 2
  0004c	6a 00		 push	 0
  0004e	8b 45 f8	 mov	 eax, DWORD PTR _pf$[ebp]
  00051	50		 push	 eax
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005b	3b f4		 cmp	 esi, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 617  : 		int nFileLen = ftell(pf); //文件长度 

  00062	8b f4		 mov	 esi, esp
  00064	8b 45 f8	 mov	 eax, DWORD PTR _pf$[ebp]
  00067	50		 push	 eax
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  0006e	83 c4 04	 add	 esp, 4
  00071	3b f4		 cmp	 esi, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	89 45 ec	 mov	 DWORD PTR _nFileLen$3[ebp], eax

; 618  : 		fseek(pf, 0, SEEK_SET); //定位到文件末 

  0007b	8b f4		 mov	 esi, esp
  0007d	6a 00		 push	 0
  0007f	6a 00		 push	 0
  00081	8b 45 f8	 mov	 eax, DWORD PTR _pf$[ebp]
  00084	50		 push	 eax
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008e	3b f4		 cmp	 esi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 619  : 
; 620  : 		char * pMax = (char *)malloc(nFileLen);

  00095	8b f4		 mov	 esi, esp
  00097	8b 45 ec	 mov	 eax, DWORD PTR _nFileLen$3[ebp]
  0009a	50		 push	 eax
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  000a1	83 c4 04	 add	 esp, 4
  000a4	3b f4		 cmp	 esi, esp
  000a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ab	89 45 e0	 mov	 DWORD PTR _pMax$2[ebp], eax

; 621  : 		char * pMax1 = (char *)malloc(2048);

  000ae	8b f4		 mov	 esi, esp
  000b0	68 00 08 00 00	 push	 2048			; 00000800H
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  000bb	83 c4 04	 add	 esp, 4
  000be	3b f4		 cmp	 esi, esp
  000c0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c5	89 45 d4	 mov	 DWORD PTR _pMax1$1[ebp], eax

; 622  : 		memset(pMax, 0, nFileLen);

  000c8	8b 45 ec	 mov	 eax, DWORD PTR _nFileLen$3[ebp]
  000cb	50		 push	 eax
  000cc	6a 00		 push	 0
  000ce	8b 4d e0	 mov	 ecx, DWORD PTR _pMax$2[ebp]
  000d1	51		 push	 ecx
  000d2	e8 00 00 00 00	 call	 _memset
  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 623  : 		memset(pMax1, 0, 2048);

  000da	68 00 08 00 00	 push	 2048			; 00000800H
  000df	6a 00		 push	 0
  000e1	8b 45 d4	 mov	 eax, DWORD PTR _pMax1$1[ebp]
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 _memset
  000ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 624  : 		fread(pMax, sizeof(char), nFileLen, pf);

  000ed	8b f4		 mov	 esi, esp
  000ef	8b 45 f8	 mov	 eax, DWORD PTR _pf$[ebp]
  000f2	50		 push	 eax
  000f3	8b 4d ec	 mov	 ecx, DWORD PTR _nFileLen$3[ebp]
  000f6	51		 push	 ecx
  000f7	6a 01		 push	 1
  000f9	8b 55 e0	 mov	 edx, DWORD PTR _pMax$2[ebp]
  000fc	52		 push	 edx
  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00103	83 c4 10	 add	 esp, 16			; 00000010H
  00106	3b f4		 cmp	 esi, esp
  00108	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 625  : 		解密MAX内联代码(pMax, nFileLen);

  0010d	8b 45 ec	 mov	 eax, DWORD PTR _nFileLen$3[ebp]
  00110	50		 push	 eax
  00111	8b 4d e0	 mov	 ecx, DWORD PTR _pMax$2[ebp]
  00114	51		 push	 ecx
  00115	e8 00 00 00 00	 call	 ?解密MAX内联代码@@YAXPADH@Z ; 解密MAX内联代码
  0011a	83 c4 08	 add	 esp, 8

; 626  : 		解析登陆列表明文((char*)(pMax + 16), pMax1);

  0011d	8b 45 d4	 mov	 eax, DWORD PTR _pMax1$1[ebp]
  00120	50		 push	 eax
  00121	8b 4d e0	 mov	 ecx, DWORD PTR _pMax$2[ebp]
  00124	83 c1 10	 add	 ecx, 16			; 00000010H
  00127	51		 push	 ecx
  00128	e8 00 00 00 00	 call	 ?解析登陆列表明文@@YAXPAD0@Z ; 解析登陆列表明文
  0012d	83 c4 08	 add	 esp, 8

; 627  : 		//情缘|电信1|218.92.147.50:9065\nCC|CC|amoijing.gicp.net:9065\n本地|本地|192.168.0.110:9065\n
; 628  : 		fclose(pf);

  00130	8b f4		 mov	 esi, esp
  00132	8b 45 f8	 mov	 eax, DWORD PTR _pf$[ebp]
  00135	50		 push	 eax
  00136	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0013c	83 c4 04	 add	 esp, 4
  0013f	3b f4		 cmp	 esi, esp
  00141	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 629  : 		free(pMax);

  00146	8b f4		 mov	 esi, esp
  00148	8b 45 e0	 mov	 eax, DWORD PTR _pMax$2[ebp]
  0014b	50		 push	 eax
  0014c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00152	83 c4 04	 add	 esp, 4
  00155	3b f4		 cmp	 esi, esp
  00157	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 630  : 		free(pMax1);

  0015c	8b f4		 mov	 esi, esp
  0015e	8b 45 d4	 mov	 eax, DWORD PTR _pMax1$1[ebp]
  00161	50		 push	 eax
  00162	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00168	83 c4 04	 add	 esp, 4
  0016b	3b f4		 cmp	 esi, esp
  0016d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@:

; 631  : 	}
; 632  : }

  00172	5f		 pop	 edi
  00173	5e		 pop	 esi
  00174	5b		 pop	 ebx
  00175	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  0017b	3b ec		 cmp	 ebp, esp
  0017d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00182	8b e5		 mov	 esp, ebp
  00184	5d		 pop	 ebp
  00185	c3		 ret	 0
?测试解码serverMax@@YAXXZ ENDP				; 测试解码serverMax
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\cca_serverlistctrl.cpp
;	COMDAT ?写入serverMax@@YAXPADH@Z
_TEXT	SEGMENT
_n4$1 = -780						; size = 4
_j$2 = -768						; size = 4
_n3$3 = -756						; size = 4
_n2$4 = -744						; size = 4
_i$5 = -732						; size = 4
_n1$6 = -720						; size = 4
_array4$7 = -708					; size = 20
_array3$8 = -680					; size = 200
_array2$9 = -472					; size = 20
_array1$10 = -444					; size = 400
_tmstrposSearch$11 = -36				; size = 4
_strpos$12 = -24					; size = 4
_tmcount$13 = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_pEncode$ = 8						; size = 4
_LenEncode$ = 12					; size = 4
?写入serverMax@@YAXPADH@Z PROC				; 写入serverMax, COMDAT

; 505  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 04 00
	00		 sub	 esp, 1168		; 00000490H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 70 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1168]
  00012	b9 24 01 00 00	 mov	 ecx, 292		; 00000124H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 506  : 	//测试
; 507  : 	//sprintf(serverListDecodeArray, "%s\0", "情缘|电信1|218.92.147.50:9065\nCC|CC|amoijing.gicp.net:9065\n本地|本地|192.168.0.110:9065\n本地|本地2|192.168.0.110:9065\n本地|本地3|192.168.0.110:9065\n");
; 508  : 	memset(serverListDecodeArray, 0, serverListEncodeLenght);

  00028	68 00 08 00 00	 push	 2048			; 00000800H
  0002d	6a 00		 push	 0
  0002f	68 00 00 00 00	 push	 OFFSET ?serverListDecodeArray@@3PADA ; serverListDecodeArray
  00034	e8 00 00 00 00	 call	 _memset
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 509  : 
; 510  : 	if (*pEncode == '\0')

  0003c	8b 45 08	 mov	 eax, DWORD PTR _pEncode$[ebp]
  0003f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00042	85 c9		 test	 ecx, ecx
  00044	75 17		 jne	 SHORT $LN8@

; 511  : 	{
; 512  : 		sprintf(serverListDecodeArray, "%s\0", "运行|立秋|222.186.51.178:9065\n运行|测试一线|amoijing.gicp.net:9065\n运行|本地一线|192.168.1.25:9065\n");

  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0FN@LLDCKPMI@?$DP?z?$LM?$HM?X?$KB?u?U?$HM222?4186?451?4178?39065?6?$DP?z?$LM@
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_03BPOAKJOG@?$CFs?$AA?$AA@
  00050	68 00 00 00 00	 push	 OFFSET ?serverListDecodeArray@@3PADA ; serverListDecodeArray
  00055	e8 00 00 00 00	 call	 _sprintf
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@:

; 513  : 	}
; 514  : 
; 515  : 	if (serverListDecodeComplete)

  0005d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?serverListDecodeComplete@@3HA, 0 ; serverListDecodeComplete
  00064	74 0a		 je	 SHORT $LN9@

; 516  : 	{
; 517  : 		//如果解码完成什么都不做
; 518  : 		return;

  00066	e9 12 02 00 00	 jmp	 $LN1@

; 519  : 	}
; 520  : 	else

  0006b	e9 0d 02 00 00	 jmp	 $LN1@
$LN9@:

; 521  : 	{
; 522  : 		//计算加密的encodeArray长度
; 523  : 		serverListEncodeRealLenght = LenEncode;

  00070	8b 45 0c	 mov	 eax, DWORD PTR _LenEncode$[ebp]
  00073	a3 00 00 00 00	 mov	 DWORD PTR ?serverListEncodeRealLenght@@3HA, eax ; serverListEncodeRealLenght

; 524  : 		//解码
; 525  : 
; 526  : 		if (*pEncode != '\0')

  00078	8b 45 08	 mov	 eax, DWORD PTR _pEncode$[ebp]
  0007b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0007e	85 c9		 test	 ecx, ecx
  00080	74 26		 je	 SHORT $LN12@

; 527  : 		{
; 528  : 			解密MAX内联代码(pEncode, serverListEncodeRealLenght);

  00082	a1 00 00 00 00	 mov	 eax, DWORD PTR ?serverListEncodeRealLenght@@3HA ; serverListEncodeRealLenght
  00087	50		 push	 eax
  00088	8b 4d 08	 mov	 ecx, DWORD PTR _pEncode$[ebp]
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 ?解密MAX内联代码@@YAXPADH@Z ; 解密MAX内联代码
  00091	83 c4 08	 add	 esp, 8

; 529  : 			解析登陆列表明文((char*)(pEncode + 16), serverListDecodeArray);

  00094	68 00 00 00 00	 push	 OFFSET ?serverListDecodeArray@@3PADA ; serverListDecodeArray
  00099	8b 45 08	 mov	 eax, DWORD PTR _pEncode$[ebp]
  0009c	83 c0 10	 add	 eax, 16			; 00000010H
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 ?解析登陆列表明文@@YAXPAD0@Z ; 解析登陆列表明文
  000a5	83 c4 08	 add	 esp, 8
$LN12@:

; 530  : 		}
; 531  : 		else
; 532  : 		{
; 533  : 			//如果没有写入serverListEncodeArray
; 534  : 			//那么就用默认的数据
; 535  : 		}
; 536  : 		//解码完成，写入列表数据到原有的逻辑
; 537  : 		//情缘电信|立秋-电信一线|222.186.51.178:9065|立春-电信二线|222.186.51.178:9066|雨水-电信三线|222.186.51.178:9067|谷雨-电信四线|222.186.51.178:9068\n
; 538  : 		//情缘网通 | 秋分 - 网通一线 | 153.37.74.177:9065 | 白露 - 网通二线 | 153.37.74.177 : 9066 | 惊蛰 - 网通三线 | 153.37.74.177 : 9067 | 夏至 - 网通四线 | 153.37.74.177 : 9068\n
; 539  : 		//	CC | CC | amoijing.gicp.net : 9065\n
; 540  : 		//	本地 | 本地 | 192.168.0.110 : 9065\n
; 541  : 
; 542  : 		int tmcount = 0; 

  000a8	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _tmcount$13[ebp], 0

; 543  : 		char *strpos = NULL;

  000af	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _strpos$12[ebp], 0

; 544  : 		char *tmstrposSearch = &serverListDecodeArray[0];

  000b6	b8 01 00 00 00	 mov	 eax, 1
  000bb	6b c8 00	 imul	 ecx, eax, 0
  000be	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?serverListDecodeArray@@3PADA ; serverListDecodeArray
  000c4	89 4d dc	 mov	 DWORD PTR _tmstrposSearch$11[ebp], ecx

; 545  : 		//统计 \n的列表数量 
; 546  : 
; 547  : 		char* array1[100]; //  \n分割
; 548  : 		char* array2[5];   //  |分割一次
; 549  : 		char* array3[50];  //  |分割
; 550  : 		char* array4[5];   //  :分割
; 551  : 		int n1 = split_damage(serverListDecodeArray, '\n', (int*)array1, 100);

  000c7	6a 64		 push	 100			; 00000064H
  000c9	8d 85 44 fe ff
	ff		 lea	 eax, DWORD PTR _array1$10[ebp]
  000cf	50		 push	 eax
  000d0	6a 0a		 push	 10			; 0000000aH
  000d2	68 00 00 00 00	 push	 OFFSET ?serverListDecodeArray@@3PADA ; serverListDecodeArray
  000d7	e8 00 00 00 00	 call	 ?split_damage@@YAHPADDPAHI@Z ; split_damage
  000dc	83 c4 10	 add	 esp, 16			; 00000010H
  000df	89 85 30 fd ff
	ff		 mov	 DWORD PTR _n1$6[ebp], eax

; 552  : 		for (int i = 0; i < n1; i++)

  000e5	c7 85 24 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$5[ebp], 0
  000ef	eb 0f		 jmp	 SHORT $LN4@
$LN2@:
  000f1	8b 85 24 fd ff
	ff		 mov	 eax, DWORD PTR _i$5[ebp]
  000f7	83 c0 01	 add	 eax, 1
  000fa	89 85 24 fd ff
	ff		 mov	 DWORD PTR _i$5[ebp], eax
$LN4@:
  00100	8b 85 24 fd ff
	ff		 mov	 eax, DWORD PTR _i$5[ebp]
  00106	3b 85 30 fd ff
	ff		 cmp	 eax, DWORD PTR _n1$6[ebp]
  0010c	0f 8d 63 01 00
	00		 jge	 $_ret$24

; 553  : 		{
; 554  : 			int n2 = split_damage(array1[i], '|', (int*)array2, 2);

  00112	6a 02		 push	 2
  00114	8d 85 28 fe ff
	ff		 lea	 eax, DWORD PTR _array2$9[ebp]
  0011a	50		 push	 eax
  0011b	6a 7c		 push	 124			; 0000007cH
  0011d	8b 8d 24 fd ff
	ff		 mov	 ecx, DWORD PTR _i$5[ebp]
  00123	8b 94 8d 44 fe
	ff ff		 mov	 edx, DWORD PTR _array1$10[ebp+ecx*4]
  0012a	52		 push	 edx
  0012b	e8 00 00 00 00	 call	 ?split_damage@@YAHPADDPAHI@Z ; split_damage
  00130	83 c4 10	 add	 esp, 16			; 00000010H
  00133	89 85 18 fd ff
	ff		 mov	 DWORD PTR _n2$4[ebp], eax

; 555  : 			if (n2 != 2) goto _ret;

  00139	83 bd 18 fd ff
	ff 02		 cmp	 DWORD PTR _n2$4[ebp], 2
  00140	74 0a		 je	 SHORT $LN13@
  00142	e9 2e 01 00 00	 jmp	 $_ret$24
  00147	e9 29 01 00 00	 jmp	 $_ret$24
$LN13@:

; 556  : 
; 557  : 			int n3 = split_damage(array2[1], '|', (int*)array3, 50);

  0014c	6a 32		 push	 50			; 00000032H
  0014e	8d 85 58 fd ff
	ff		 lea	 eax, DWORD PTR _array3$8[ebp]
  00154	50		 push	 eax
  00155	6a 7c		 push	 124			; 0000007cH
  00157	b9 04 00 00 00	 mov	 ecx, 4
  0015c	c1 e1 00	 shl	 ecx, 0
  0015f	8b 94 0d 28 fe
	ff ff		 mov	 edx, DWORD PTR _array2$9[ebp+ecx]
  00166	52		 push	 edx
  00167	e8 00 00 00 00	 call	 ?split_damage@@YAHPADDPAHI@Z ; split_damage
  0016c	83 c4 10	 add	 esp, 16			; 00000010H
  0016f	89 85 0c fd ff
	ff		 mov	 DWORD PTR _n3$3[ebp], eax

; 558  : 			for (int j = 0; j < n3; )

  00175	c7 85 00 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$2[ebp], 0
$LN7@:
  0017f	8b 85 00 fd ff
	ff		 mov	 eax, DWORD PTR _j$2[ebp]
  00185	3b 85 0c fd ff
	ff		 cmp	 eax, DWORD PTR _n3$3[ebp]
  0018b	0f 8d df 00 00
	00		 jge	 $LN6@

; 559  : 			{
; 560  : 				gmsv[tmcount].used = '1';

  00191	8b 45 f4	 mov	 eax, DWORD PTR _tmcount$13[ebp]
  00194	c1 e0 08	 shl	 eax, 8
  00197	c6 80 00 00 00
	00 31		 mov	 BYTE PTR ?gmsv@@3PAUgameserver@@A[eax], 49 ; 00000031H

; 561  : 				lstrcpy(gmsv[tmcount].name, array3[j]);

  0019e	8b f4		 mov	 esi, esp
  001a0	8b 85 00 fd ff
	ff		 mov	 eax, DWORD PTR _j$2[ebp]
  001a6	8b 8c 85 58 fd
	ff ff		 mov	 ecx, DWORD PTR _array3$8[ebp+eax*4]
  001ad	51		 push	 ecx
  001ae	8b 55 f4	 mov	 edx, DWORD PTR _tmcount$13[ebp]
  001b1	c1 e2 08	 shl	 edx, 8
  001b4	81 c2 c0 00 00
	00		 add	 edx, OFFSET ?gmsv@@3PAUgameserver@@A+192
  001ba	52		 push	 edx
  001bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8
  001c1	3b f4		 cmp	 esi, esp
  001c3	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 562  : 				int n4 = split_damage(array3[j + 1], ':', (int*)array4, 3);

  001c8	6a 03		 push	 3
  001ca	8d 85 3c fd ff
	ff		 lea	 eax, DWORD PTR _array4$7[ebp]
  001d0	50		 push	 eax
  001d1	6a 3a		 push	 58			; 0000003aH
  001d3	8b 8d 00 fd ff
	ff		 mov	 ecx, DWORD PTR _j$2[ebp]
  001d9	8b 94 8d 5c fd
	ff ff		 mov	 edx, DWORD PTR _array3$8[ebp+ecx*4+4]
  001e0	52		 push	 edx
  001e1	e8 00 00 00 00	 call	 ?split_damage@@YAHPADDPAHI@Z ; split_damage
  001e6	83 c4 10	 add	 esp, 16			; 00000010H
  001e9	89 85 f4 fc ff
	ff		 mov	 DWORD PTR _n4$1[ebp], eax

; 563  : 				if (n4 != 2)  goto _ret;

  001ef	83 bd f4 fc ff
	ff 02		 cmp	 DWORD PTR _n4$1[ebp], 2
  001f6	74 04		 je	 SHORT $LN15@
  001f8	eb 7b		 jmp	 SHORT $_ret$24
  001fa	eb 79		 jmp	 SHORT $_ret$24
$LN15@:

; 564  : 				lstrcpy(gmsv[tmcount].ipaddr, array4[0]);

  001fc	b8 04 00 00 00	 mov	 eax, 4
  00201	6b c8 00	 imul	 ecx, eax, 0
  00204	8b f4		 mov	 esi, esp
  00206	8b 94 0d 3c fd
	ff ff		 mov	 edx, DWORD PTR _array4$7[ebp+ecx]
  0020d	52		 push	 edx
  0020e	8b 45 f4	 mov	 eax, DWORD PTR _tmcount$13[ebp]
  00211	c1 e0 08	 shl	 eax, 8
  00214	05 01 00 00 00	 add	 eax, OFFSET ?gmsv@@3PAUgameserver@@A+1
  00219	50		 push	 eax
  0021a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8
  00220	3b f4		 cmp	 esi, esp
  00222	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 565  : 				lstrcpy(gmsv[tmcount].port, array4[1]);

  00227	b8 04 00 00 00	 mov	 eax, 4
  0022c	c1 e0 00	 shl	 eax, 0
  0022f	8b f4		 mov	 esi, esp
  00231	8b 8c 05 3c fd
	ff ff		 mov	 ecx, DWORD PTR _array4$7[ebp+eax]
  00238	51		 push	 ecx
  00239	8b 55 f4	 mov	 edx, DWORD PTR _tmcount$13[ebp]
  0023c	c1 e2 08	 shl	 edx, 8
  0023f	81 c2 80 00 00
	00		 add	 edx, OFFSET ?gmsv@@3PAUgameserver@@A+128
  00245	52		 push	 edx
  00246	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8
  0024c	3b f4		 cmp	 esi, esp
  0024e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 566  : 				j = j + 2;

  00253	8b 85 00 fd ff
	ff		 mov	 eax, DWORD PTR _j$2[ebp]
  00259	83 c0 02	 add	 eax, 2
  0025c	89 85 00 fd ff
	ff		 mov	 DWORD PTR _j$2[ebp], eax

; 567  : 				tmcount++;

  00262	8b 45 f4	 mov	 eax, DWORD PTR _tmcount$13[ebp]
  00265	83 c0 01	 add	 eax, 1
  00268	89 45 f4	 mov	 DWORD PTR _tmcount$13[ebp], eax

; 568  : 			}

  0026b	e9 0f ff ff ff	 jmp	 $LN7@
$LN6@:

; 569  : 		}

  00270	e9 7c fe ff ff	 jmp	 $LN2@
$_ret$24:

; 570  : 		_ret:
; 571  : 		gmgroup->num = (char)tmcount;

  00275	8a 45 f4	 mov	 al, BYTE PTR _tmcount$13[ebp]
  00278	a2 01 00 00 00	 mov	 BYTE PTR ?gmgroup@@3PAUgamegroup@@A+1, al
$LN1@:

; 572  : 	//	for (; ;)
; 573  : 	//	{
; 574  : 	//		strpos = strstr(tmstrposSearch, "\n");
; 575  : 	//		if (strpos != NULL)
; 576  : 	//		{
; 577  : 
; 578  : 	//			//修改 gmsv信息
; 579  : 	//			char    splitBuf[512];
; 580  : 	//			getStringFromIndexWithDelim(serverListDecodeArray, "\n", tmcount +1, splitBuf, sizeof(splitBuf));
; 581  : 	//			gmsv[tmcount].used = '1';
; 582  : 	//			getStringFromIndexWithDelim(splitBuf, "|", 2, gmsv[tmcount].name, sizeof(gmsv[tmcount].name));
; 583  : 	//			char    serverBuf[512];
; 584  : 	//			getStringFromIndexWithDelim(splitBuf, "|", 3, serverBuf, sizeof(serverBuf));
; 585  : 	//			getStringFromIndexWithDelim(serverBuf, ":", 1, gmsv[tmcount].ipaddr, sizeof(gmsv[tmcount].ipaddr));
; 586  : 	//			getStringFromIndexWithDelim(serverBuf, ":", 2, gmsv[tmcount].port, sizeof(gmsv[tmcount].port));
; 587  : 
; 588  : 	//			tmcount++; 
; 589  : 	//			tmstrposSearch = strpos + 1;
; 590  : 
; 591  : 
; 592  : 	//		}
; 593  : 	//		else
; 594  : 	//		{
; 595  : 	//			break;
; 596  : 	//		}
; 597  : 	//	}
; 598  : 	//	//已统计出具体的列表数量
; 599  : 
; 600  : 	//	//修改group 信息
; 601  : 	//	gmgroup->num = (char)tmcount;
; 602  : 	//	//写入完成
; 603  : 	//	serverListDecodeComplete = true;
; 604  : 	}
; 605  : 	return;
; 606  : }

  0027d	52		 push	 edx
  0027e	8b cd		 mov	 ecx, ebp
  00280	50		 push	 eax
  00281	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN23@
  00287	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0028c	58		 pop	 eax
  0028d	5a		 pop	 edx
  0028e	5f		 pop	 edi
  0028f	5e		 pop	 esi
  00290	5b		 pop	 ebx
  00291	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00294	33 cd		 xor	 ecx, ebp
  00296	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0029b	81 c4 90 04 00
	00		 add	 esp, 1168		; 00000490H
  002a1	3b ec		 cmp	 ebp, esp
  002a3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002a8	8b e5		 mov	 esp, ebp
  002aa	5d		 pop	 ebp
  002ab	c3		 ret	 0
$LN23@:
  002ac	04 00 00 00	 DD	 4
  002b0	00 00 00 00	 DD	 $LN22@
$LN22@:
  002b4	44 fe ff ff	 DD	 -444			; fffffe44H
  002b8	90 01 00 00	 DD	 400			; 00000190H
  002bc	00 00 00 00	 DD	 $LN18@
  002c0	28 fe ff ff	 DD	 -472			; fffffe28H
  002c4	14 00 00 00	 DD	 20			; 00000014H
  002c8	00 00 00 00	 DD	 $LN19@
  002cc	58 fd ff ff	 DD	 -680			; fffffd58H
  002d0	c8 00 00 00	 DD	 200			; 000000c8H
  002d4	00 00 00 00	 DD	 $LN20@
  002d8	3c fd ff ff	 DD	 -708			; fffffd3cH
  002dc	14 00 00 00	 DD	 20			; 00000014H
  002e0	00 00 00 00	 DD	 $LN21@
$LN21@:
  002e4	61		 DB	 97			; 00000061H
  002e5	72		 DB	 114			; 00000072H
  002e6	72		 DB	 114			; 00000072H
  002e7	61		 DB	 97			; 00000061H
  002e8	79		 DB	 121			; 00000079H
  002e9	34		 DB	 52			; 00000034H
  002ea	00		 DB	 0
$LN20@:
  002eb	61		 DB	 97			; 00000061H
  002ec	72		 DB	 114			; 00000072H
  002ed	72		 DB	 114			; 00000072H
  002ee	61		 DB	 97			; 00000061H
  002ef	79		 DB	 121			; 00000079H
  002f0	33		 DB	 51			; 00000033H
  002f1	00		 DB	 0
$LN19@:
  002f2	61		 DB	 97			; 00000061H
  002f3	72		 DB	 114			; 00000072H
  002f4	72		 DB	 114			; 00000072H
  002f5	61		 DB	 97			; 00000061H
  002f6	79		 DB	 121			; 00000079H
  002f7	32		 DB	 50			; 00000032H
  002f8	00		 DB	 0
$LN18@:
  002f9	61		 DB	 97			; 00000061H
  002fa	72		 DB	 114			; 00000072H
  002fb	72		 DB	 114			; 00000072H
  002fc	61		 DB	 97			; 00000061H
  002fd	79		 DB	 121			; 00000079H
  002fe	31		 DB	 49			; 00000031H
  002ff	00		 DB	 0
?写入serverMax@@YAXPADH@Z ENDP				; 写入serverMax
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\cca_serverlistctrl.cpp
;	COMDAT ?解密MAX内联代码@@YAXPADH@Z
_TEXT	SEGMENT
_pMax$ = 8						; size = 4
_file_size$ = 12					; size = 4
?解密MAX内联代码@@YAXPADH@Z PROC			; 解密MAX内联代码, COMDAT

; 306  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 307  : 	*(int *)pMax = 0x1234;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _pMax$[ebp]
  00021	c7 00 34 12 00
	00		 mov	 DWORD PTR [eax], 4660	; 00001234H

; 308  : 	*(int *)(pMax + 4) = 0x5678;

  00027	8b 45 08	 mov	 eax, DWORD PTR _pMax$[ebp]
  0002a	c7 40 04 78 56
	00 00		 mov	 DWORD PTR [eax+4], 22136 ; 00005678H

; 309  : 	*(int *)(pMax + 8) = 0x9ABC;

  00031	8b 45 08	 mov	 eax, DWORD PTR _pMax$[ebp]
  00034	c7 40 08 bc 9a
	00 00		 mov	 DWORD PTR [eax+8], 39612 ; 00009abcH

; 310  : 	*(int *)(pMax + 12) = 0xDEF0;

  0003b	8b 45 08	 mov	 eax, DWORD PTR _pMax$[ebp]
  0003e	c7 40 0c f0 de
	00 00		 mov	 DWORD PTR [eax+12], 57072 ; 0000def0H

; 311  : 	__asm{
; 312  : 		pushad

  00045	60		 pushad

; 313  : 
; 314  : 			mov ecx, [file_size]; 文件大小->ecx

  00046	8b 4d 0c	 mov	 ecx, DWORD PTR _file_size$[ebp]

; 315  : 			mov edi, ecx

  00049	8b f9		 mov	 edi, ecx

; 316  : 			and ecx, 0x80000007

  0004b	81 e1 07 00 00
	80		 and	 ecx, -2147483641	; 80000007H

; 317  : 			jns sa_8018_0048C866

  00051	79 05		 jns	 SHORT $sa_8018_0048C866$3

; 318  : 			dec ecx

  00053	49		 dec	 ecx

; 319  : 			or ecx, 0xFFFFFFF8

  00054	83 c9 f8	 or	 ecx, -8			; fffffff8H

; 320  : 			inc ecx

  00057	41		 inc	 ecx
$sa_8018_0048C866$3:

; 321  : 
; 322  : 		sa_8018_0048C866 :
; 323  : 
; 324  : 		mov eax, edi

  00058	8b c7		 mov	 eax, edi

; 325  : 			je sa_8018_0048C878

  0005a	74 0e		 je	 SHORT $sa_8018_0048C878$4

; 326  : 			sub eax, ecx

  0005c	2b c1		 sub	 eax, ecx

; 327  : 			cdq

  0005e	99		 cdq

; 328  : 			and edx, 0x7

  0005f	83 e2 07	 and	 edx, 7

; 329  : 			add eax, edx

  00062	03 c2		 add	 eax, edx

; 330  : 			sar eax, 0x3

  00064	c1 f8 03	 sar	 eax, 3

; 331  : 			inc eax

  00067	40		 inc	 eax

; 332  : 			jmp sa_8018_0048C881

  00068	eb 09		 jmp	 SHORT $sa_8018_0048C881$5
$sa_8018_0048C878$4:

; 333  : 
; 334  : 		sa_8018_0048C878 :
; 335  : 
; 336  : 		cdq

  0006a	99		 cdq

; 337  : 			and edx, 0x7

  0006b	83 e2 07	 and	 edx, 7

; 338  : 			add eax, edx

  0006e	03 c2		 add	 eax, edx

; 339  : 			sar eax, 0x3

  00070	c1 f8 03	 sar	 eax, 3
$sa_8018_0048C881$5:

; 340  : 
; 341  : 		sa_8018_0048C881 :
; 342  : 
; 343  : 						 test eax, eax; 根据文件大小计算出来的eax

  00073	85 c0		 test	 eax, eax

; 344  : 						 jle sa_8018_0048C89F

  00075	7e 1b		 jle	 SHORT $sa_8018_0048C89F$6

; 345  : 						 mov esi, pMax

  00077	8b 75 08	 mov	 esi, DWORD PTR _pMax$[ebp]

; 346  : 						 add esi, 16

  0007a	83 c6 10	 add	 esi, 16			; 00000010H

; 347  : 						 mov edi, eax

  0007d	8b f8		 mov	 edi, eax
$sa_8018_0048C88B$7:

; 348  : 
; 349  : 					 sa_8018_0048C88B :
; 350  : 
; 351  : 		mov ecx, pMax

  0007f	8b 4d 08	 mov	 ecx, DWORD PTR _pMax$[ebp]

; 352  : 			push esi

  00082	56		 push	 esi

; 353  : 			push ecx

  00083	51		 push	 ecx

; 354  : 			call 解密max; <= Jump / Call Address Not Resolved; 解密max文件

  00084	e8 0e 00 00 00	 call	 $解密max$8

; 355  : 			add esp, 0x8

  00089	83 c4 08	 add	 esp, 8

; 356  : 			add esi, 0x8

  0008c	83 c6 08	 add	 esi, 8

; 357  : 			dec edi

  0008f	4f		 dec	 edi

; 358  : 			jnz sa_8018_0048C88B

  00090	75 ed		 jne	 SHORT $sa_8018_0048C88B$7
$sa_8018_0048C89F$6:

; 359  : 
; 360  : 		sa_8018_0048C89F :
; 361  : 		jmp ooookkkk

  00092	e9 08 01 00 00	 jmp	 $ooookkkk$9
$解密max$8:

; 362  : 
; 363  : 		解密max : ; <= Procedure Start
; 364  : 
; 365  : 				mov eax, dword ptr ss : [esp + 0x8]

  00097	36 8b 44 24 08	 mov	 eax, DWORD PTR ss:[esp+8]

; 366  : 				mov ecx, dword ptr ss : [esp + 0x4]

  0009c	36 8b 4c 24 04	 mov	 ecx, DWORD PTR ss:[esp+4]

; 367  : 				push - 0x20

  000a1	6a e0		 push	 -32			; ffffffe0H

; 368  : 				push eax

  000a3	50		 push	 eax

; 369  : 				push ecx

  000a4	51		 push	 ecx

; 370  : 				call max加密解密; <= Jump / Call Address Not Resolved

  000a5	e8 04 00 00 00	 call	 $max加密解密$10

; 371  : 				add esp, 0xC

  000aa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 372  : 				retn; <= Procedure End

  000ad	c3		 ret	 0
$max加密解密$10:

; 373  : 
; 374  : 
; 375  : 
; 376  : 			max加密解密 : ; <= Procedure Start
; 377  : 
; 378  : 					  mov edx, dword ptr ss : [esp + 0xC]

  000ae	36 8b 54 24 0c	 mov	 edx, DWORD PTR ss:[esp+12]

; 379  : 					  push ebx

  000b3	53		 push	 ebx

; 380  : 					  push ebp

  000b4	55		 push	 ebp

; 381  : 					  push esi

  000b5	56		 push	 esi

; 382  : 					  push edi

  000b6	57		 push	 edi

; 383  : 					  mov edi, dword ptr ss : [esp + 0x18]

  000b7	36 8b 7c 24 18	 mov	 edi, DWORD PTR ss:[esp+24]

; 384  : 					  xor esi, esi

  000bc	33 f6		 xor	 esi, esi

; 385  : 					  mov ecx, dword ptr ds : [edi]

  000be	3e 8b 0f	 mov	 ecx, DWORD PTR ds:[edi]

; 386  : 					  mov eax, dword ptr ds : [edi + 0x4]

  000c1	3e 8b 47 04	 mov	 eax, DWORD PTR ds:[edi+4]

; 387  : 					  test edx, edx

  000c5	85 d2		 test	 edx, edx

; 388  : 					  jle sa_8018_0048C622

  000c7	7e 74		 jle	 SHORT $sa_8018_0048C622$11

; 389  : 					  imul edx, edx, 0x9E3779B9

  000c9	69 d2 b9 79 37
	9e		 imul	 edx, edx, -1640531527

; 390  : 					  test edx, edx

  000cf	85 d2		 test	 edx, edx

; 391  : 					  mov dword ptr ss : [esp + 0x18], edx

  000d1	36 89 54 24 18	 mov	 DWORD PTR ss:[esp+24], edx

; 392  : 					  je sa_8018_0048C675

  000d6	0f 84 b7 00 00
	00		 je	 $sa_8018_0048C675$12

; 393  : 					  mov edx, dword ptr ss : [esp + 0x14]

  000dc	36 8b 54 24 14	 mov	 edx, DWORD PTR ss:[esp+20]
$sa_8018_0048C5CD$13:

; 394  : 
; 395  : 				  sa_8018_0048C5CD :
; 396  : 
; 397  : 								   mov ebx, eax

  000e1	8b d8		 mov	 ebx, eax

; 398  : 								   mov ebp, eax

  000e3	8b e8		 mov	 ebp, eax

; 399  : 								   sar ebx, 0x5

  000e5	c1 fb 05	 sar	 ebx, 5

; 400  : 								   shl ebp, 0x4

  000e8	c1 e5 04	 shl	 ebp, 4

; 401  : 								   xor ebx, ebp

  000eb	33 dd		 xor	 ebx, ebp

; 402  : 								   mov ebp, esi

  000ed	8b ee		 mov	 ebp, esi

; 403  : 								   and ebp, 0x3

  000ef	83 e5 03	 and	 ebp, 3

; 404  : 								   add ebx, dword ptr ds : [edx + ebp * 4]

  000f2	3e 03 1c aa	 add	 ebx, DWORD PTR ds:[edx+ebp*4]

; 405  : 								   mov ebp, esi

  000f6	8b ee		 mov	 ebp, esi

; 406  : 								   xor ebp, eax

  000f8	33 e8		 xor	 ebp, eax

; 407  : 								   sub esi, 0x61C88647

  000fa	81 ee 47 86 c8
	61		 sub	 esi, 1640531527		; 61c88647H

; 408  : 								   add ebp, ecx

  00100	03 e9		 add	 ebp, ecx

; 409  : 								   lea ecx, dword ptr ds : [ebx + ebp]

  00102	3e 8d 0c 2b	 lea	 ecx, DWORD PTR ds:[ebx+ebp]

; 410  : 								   mov ebx, ecx

  00106	8b d9		 mov	 ebx, ecx

; 411  : 								   mov ebp, ecx

  00108	8b e9		 mov	 ebp, ecx

; 412  : 								   sar ebx, 0x5

  0010a	c1 fb 05	 sar	 ebx, 5

; 413  : 								   shl ebp, 0x4

  0010d	c1 e5 04	 shl	 ebp, 4

; 414  : 								   xor ebx, ebp

  00110	33 dd		 xor	 ebx, ebp

; 415  : 								   mov ebp, esi

  00112	8b ee		 mov	 ebp, esi

; 416  : 								   sar ebp, 0xB

  00114	c1 fd 0b	 sar	 ebp, 11			; 0000000bH

; 417  : 								   and ebp, 0x3

  00117	83 e5 03	 and	 ebp, 3

; 418  : 								   add ebx, dword ptr ds : [edx + ebp * 4]

  0011a	3e 03 1c aa	 add	 ebx, DWORD PTR ds:[edx+ebp*4]

; 419  : 								   mov ebp, esi

  0011e	8b ee		 mov	 ebp, esi

; 420  : 								   xor ebp, ecx

  00120	33 e9		 xor	 ebp, ecx

; 421  : 								   add ebp, eax

  00122	03 e8		 add	 ebp, eax

; 422  : 								   lea eax, dword ptr ds : [ebx + ebp]

  00124	3e 8d 04 2b	 lea	 eax, DWORD PTR ds:[ebx+ebp]

; 423  : 								   mov ebx, dword ptr ss : [esp + 0x18]

  00128	36 8b 5c 24 18	 mov	 ebx, DWORD PTR ss:[esp+24]

; 424  : 								   cmp esi, ebx

  0012d	3b f3		 cmp	 esi, ebx

; 425  : 								   jnz sa_8018_0048C5CD

  0012f	75 b0		 jne	 SHORT $sa_8018_0048C5CD$13

; 426  : 								   mov dword ptr ds : [edi], ecx

  00131	3e 89 0f	 mov	 DWORD PTR ds:[edi], ecx

; 427  : 								   mov dword ptr ds : [edi + 0x4], eax

  00134	3e 89 47 04	 mov	 DWORD PTR ds:[edi+4], eax

; 428  : 								   pop edi

  00138	5f		 pop	 edi

; 429  : 								   pop esi

  00139	5e		 pop	 esi

; 430  : 								   pop ebp

  0013a	5d		 pop	 ebp

; 431  : 								   pop ebx

  0013b	5b		 pop	 ebx

; 432  : 								   retn

  0013c	c3		 ret	 0
$sa_8018_0048C622$11:

; 433  : 
; 434  : 							   sa_8018_0048C622 :
; 435  : 
; 436  : 		imul edx, edx, 0x61C88647

  0013d	69 d2 47 86 c8
	61		 imul	 edx, edx, 1640531527

; 437  : 			test edx, edx

  00143	85 d2		 test	 edx, edx

; 438  : 			je sa_8018_0048C675

  00145	74 4c		 je	 SHORT $sa_8018_0048C675$12

; 439  : 			mov esi, dword ptr ss : [esp + 0x14]

  00147	36 8b 74 24 14	 mov	 esi, DWORD PTR ss:[esp+20]
$sa_8018_0048C630$14:

; 440  : 
; 441  : 		sa_8018_0048C630 :
; 442  : 
; 443  : 						 mov ebx, ecx

  0014c	8b d9		 mov	 ebx, ecx

; 444  : 						 mov ebp, ecx

  0014e	8b e9		 mov	 ebp, ecx

; 445  : 						 sar ebx, 0x5

  00150	c1 fb 05	 sar	 ebx, 5

; 446  : 						 shl ebp, 0x4

  00153	c1 e5 04	 shl	 ebp, 4

; 447  : 						 xor ebx, ebp

  00156	33 dd		 xor	 ebx, ebp

; 448  : 						 mov ebp, edx

  00158	8b ea		 mov	 ebp, edx

; 449  : 						 sar ebp, 0xB

  0015a	c1 fd 0b	 sar	 ebp, 11			; 0000000bH

; 450  : 						 and ebp, 0x3

  0015d	83 e5 03	 and	 ebp, 3

; 451  : 						 add ebx, dword ptr ds : [esi + ebp * 4]

  00160	3e 03 1c ae	 add	 ebx, DWORD PTR ds:[esi+ebp*4]

; 452  : 						 mov ebp, edx

  00164	8b ea		 mov	 ebp, edx

; 453  : 						 xor ebp, ecx

  00166	33 e9		 xor	 ebp, ecx

; 454  : 						 add edx, 0x61C88647

  00168	81 c2 47 86 c8
	61		 add	 edx, 1640531527		; 61c88647H

; 455  : 						 add ebx, ebp

  0016e	03 dd		 add	 ebx, ebp

; 456  : 						 sub eax, ebx

  00170	2b c3		 sub	 eax, ebx

; 457  : 						 mov ebx, eax

  00172	8b d8		 mov	 ebx, eax

; 458  : 						 mov ebp, eax

  00174	8b e8		 mov	 ebp, eax

; 459  : 						 sar ebx, 0x5

  00176	c1 fb 05	 sar	 ebx, 5

; 460  : 						 shl ebp, 0x4

  00179	c1 e5 04	 shl	 ebp, 4

; 461  : 						 xor ebx, ebp

  0017c	33 dd		 xor	 ebx, ebp

; 462  : 						 mov ebp, edx

  0017e	8b ea		 mov	 ebp, edx

; 463  : 						 and ebp, 0x3

  00180	83 e5 03	 and	 ebp, 3

; 464  : 						 add ebx, dword ptr ds : [esi + ebp * 4]

  00183	3e 03 1c ae	 add	 ebx, DWORD PTR ds:[esi+ebp*4]

; 465  : 						 mov ebp, edx

  00187	8b ea		 mov	 ebp, edx

; 466  : 						 xor ebp, eax

  00189	33 e8		 xor	 ebp, eax

; 467  : 						 add ebx, ebp

  0018b	03 dd		 add	 ebx, ebp

; 468  : 						 sub ecx, ebx

  0018d	2b cb		 sub	 ecx, ebx

; 469  : 						 test edx, edx

  0018f	85 d2		 test	 edx, edx

; 470  : 						 jnz sa_8018_0048C630

  00191	75 b9		 jne	 SHORT $sa_8018_0048C630$14
$sa_8018_0048C675$12:

; 471  : 
; 472  : 					 sa_8018_0048C675 :
; 473  : 
; 474  : 		mov dword ptr ds : [edi], ecx

  00193	3e 89 0f	 mov	 DWORD PTR ds:[edi], ecx

; 475  : 			mov dword ptr ds : [edi + 0x4], eax

  00196	3e 89 47 04	 mov	 DWORD PTR ds:[edi+4], eax

; 476  : 			pop edi

  0019a	5f		 pop	 edi

; 477  : 			pop esi

  0019b	5e		 pop	 esi

; 478  : 			pop ebp

  0019c	5d		 pop	 ebp

; 479  : 			pop ebx

  0019d	5b		 pop	 ebx

; 480  : 			retn; <= Procedure End

  0019e	c3		 ret	 0
$ooookkkk$9:

; 481  : 
; 482  : 
; 483  : 
; 484  : 		ooookkkk :
; 485  : 		popad

  0019f	61		 popad

; 486  : 	}
; 487  : 
; 488  : }

  001a0	5f		 pop	 edi
  001a1	5e		 pop	 esi
  001a2	5b		 pop	 ebx
  001a3	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  001a9	3b ec		 cmp	 ebp, esp
  001ab	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b0	8b e5		 mov	 esp, ebp
  001b2	5d		 pop	 ebp
  001b3	c3		 ret	 0
?解密MAX内联代码@@YAXPADH@Z ENDP			; 解密MAX内联代码
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\cca_serverlistctrl.cpp
;	COMDAT ?解析登陆列表明文@@YAXPAD0@Z
_TEXT	SEGMENT
_buf2$1 = -20236					; size = 100
_IP尾$2 = -20128					; size = 4
_副机名$3 = -20116					; size = 4
_j$4 = -20104						; size = 4
_IP头$5 = -20092					; size = 4
_count_小服数量$6 = -20080				; size = 4
_主机名$7 = -20068					; size = 4
_i$8 = -20056						; size = 4
_count_大服数量$ = -20044				; size = 4
_index$ = -20032					; size = 4
_count$ = -20020					; size = 4
_array_split$ = -20008					; size = 20000
__$ArrayPad$ = -4					; size = 4
_src$ = 8						; size = 4
_dest$ = 12						; size = 4
?解析登陆列表明文@@YAXPAD0@Z PROC			; 解析登陆列表明文, COMDAT

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 10 55 00 00	 mov	 eax, 21776		; 00005510H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8d bd f0 aa ff
	ff		 lea	 edi, DWORD PTR [ebp-21776]
  00016	b9 44 15 00 00	 mov	 ecx, 5444		; 00001544H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 255  : 	int array_split[5000];
; 256  : 	int count = split_damage(src, ';', array_split, 5000);

  0002c	68 88 13 00 00	 push	 5000			; 00001388H
  00031	8d 85 d8 b1 ff
	ff		 lea	 eax, DWORD PTR _array_split$[ebp]
  00037	50		 push	 eax
  00038	6a 3b		 push	 59			; 0000003bH
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ?split_damage@@YAHPADDPAHI@Z ; split_damage
  00043	83 c4 10	 add	 esp, 16			; 00000010H
  00046	89 85 cc b1 ff
	ff		 mov	 DWORD PTR _count$[ebp], eax

; 257  : 
; 258  : 	int index = 1;

  0004c	c7 85 c0 b1 ff
	ff 01 00 00 00	 mov	 DWORD PTR _index$[ebp], 1

; 259  : 	int count_大服数量 = atoi((char*)array_split[index]);

  00056	8b f4		 mov	 esi, esp
  00058	8b 85 c0 b1 ff
	ff		 mov	 eax, DWORD PTR _index$[ebp]
  0005e	8b 8c 85 d8 b1
	ff ff		 mov	 ecx, DWORD PTR _array_split$[ebp+eax*4]
  00065	51		 push	 ecx
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0006c	83 c4 04	 add	 esp, 4
  0006f	3b f4		 cmp	 esi, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	89 85 b4 b1 ff
	ff		 mov	 DWORD PTR _count_大服数量$[ebp], eax

; 260  : 	index++;

  0007c	8b 85 c0 b1 ff
	ff		 mov	 eax, DWORD PTR _index$[ebp]
  00082	83 c0 01	 add	 eax, 1
  00085	89 85 c0 b1 ff
	ff		 mov	 DWORD PTR _index$[ebp], eax

; 261  : 
; 262  : 	*dest = 0;

  0008b	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0008e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 263  : 
; 264  : 	for (int i = 0; i < count_大服数量; i++)

  00091	c7 85 a8 b1 ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$8[ebp], 0
  0009b	eb 0f		 jmp	 SHORT $LN4@
$LN2@:
  0009d	8b 85 a8 b1 ff
	ff		 mov	 eax, DWORD PTR _i$8[ebp]
  000a3	83 c0 01	 add	 eax, 1
  000a6	89 85 a8 b1 ff
	ff		 mov	 DWORD PTR _i$8[ebp], eax
$LN4@:
  000ac	8b 85 a8 b1 ff
	ff		 mov	 eax, DWORD PTR _i$8[ebp]
  000b2	3b 85 b4 b1 ff
	ff		 cmp	 eax, DWORD PTR _count_大服数量$[ebp]
  000b8	0f 8d a1 01 00
	00		 jge	 $LN1@

; 265  : 	{
; 266  : 		index++; //跳过0   0;本地;3;192.168.0;本地;110:9065;雨水;146:9070;立春;134:9075;;

  000be	8b 85 c0 b1 ff
	ff		 mov	 eax, DWORD PTR _index$[ebp]
  000c4	83 c0 01	 add	 eax, 1
  000c7	89 85 c0 b1 ff
	ff		 mov	 DWORD PTR _index$[ebp], eax

; 267  : 		char* 主机名 = (char*)array_split[index];

  000cd	8b 85 c0 b1 ff
	ff		 mov	 eax, DWORD PTR _index$[ebp]
  000d3	8b 8c 85 d8 b1
	ff ff		 mov	 ecx, DWORD PTR _array_split$[ebp+eax*4]
  000da	89 8d 9c b1 ff
	ff		 mov	 DWORD PTR _主机名$7[ebp], ecx

; 268  : 		index++;

  000e0	8b 85 c0 b1 ff
	ff		 mov	 eax, DWORD PTR _index$[ebp]
  000e6	83 c0 01	 add	 eax, 1
  000e9	89 85 c0 b1 ff
	ff		 mov	 DWORD PTR _index$[ebp], eax

; 269  : 		int count_小服数量 = atoi((char*)array_split[index]);

  000ef	8b f4		 mov	 esi, esp
  000f1	8b 85 c0 b1 ff
	ff		 mov	 eax, DWORD PTR _index$[ebp]
  000f7	8b 8c 85 d8 b1
	ff ff		 mov	 ecx, DWORD PTR _array_split$[ebp+eax*4]
  000fe	51		 push	 ecx
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00105	83 c4 04	 add	 esp, 4
  00108	3b f4		 cmp	 esi, esp
  0010a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010f	89 85 90 b1 ff
	ff		 mov	 DWORD PTR _count_小服数量$6[ebp], eax

; 270  : 		index++;

  00115	8b 85 c0 b1 ff
	ff		 mov	 eax, DWORD PTR _index$[ebp]
  0011b	83 c0 01	 add	 eax, 1
  0011e	89 85 c0 b1 ff
	ff		 mov	 DWORD PTR _index$[ebp], eax

; 271  : 
; 272  : 		// 主机名|副机|IP|副机|IP\n主机名|副机|IP
; 273  : 		lstrcatA(dest, 主机名);

  00124	8b f4		 mov	 esi, esp
  00126	8b 85 9c b1 ff
	ff		 mov	 eax, DWORD PTR _主机名$7[ebp]
  0012c	50		 push	 eax
  0012d	8b 4d 0c	 mov	 ecx, DWORD PTR _dest$[ebp]
  00130	51		 push	 ecx
  00131	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcatA@8
  00137	3b f4		 cmp	 esi, esp
  00139	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 274  : 
; 275  : 
; 276  : 
; 277  : 		char* IP头 = (char*)array_split[index];

  0013e	8b 85 c0 b1 ff
	ff		 mov	 eax, DWORD PTR _index$[ebp]
  00144	8b 8c 85 d8 b1
	ff ff		 mov	 ecx, DWORD PTR _array_split$[ebp+eax*4]
  0014b	89 8d 84 b1 ff
	ff		 mov	 DWORD PTR _IP头$5[ebp], ecx

; 278  : 		index++;

  00151	8b 85 c0 b1 ff
	ff		 mov	 eax, DWORD PTR _index$[ebp]
  00157	83 c0 01	 add	 eax, 1
  0015a	89 85 c0 b1 ff
	ff		 mov	 DWORD PTR _index$[ebp], eax

; 279  : 
; 280  : 		for (int j = 0; j < count_小服数量; j++)

  00160	c7 85 78 b1 ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$4[ebp], 0
  0016a	eb 0f		 jmp	 SHORT $LN7@
$LN5@:
  0016c	8b 85 78 b1 ff
	ff		 mov	 eax, DWORD PTR _j$4[ebp]
  00172	83 c0 01	 add	 eax, 1
  00175	89 85 78 b1 ff
	ff		 mov	 DWORD PTR _j$4[ebp], eax
$LN7@:
  0017b	8b 85 78 b1 ff
	ff		 mov	 eax, DWORD PTR _j$4[ebp]
  00181	3b 85 90 b1 ff
	ff		 cmp	 eax, DWORD PTR _count_小服数量$6[ebp]
  00187	0f 8d a6 00 00
	00		 jge	 $LN6@

; 281  : 		{
; 282  : 			char* 副机名 = (char*)array_split[index];

  0018d	8b 85 c0 b1 ff
	ff		 mov	 eax, DWORD PTR _index$[ebp]
  00193	8b 8c 85 d8 b1
	ff ff		 mov	 ecx, DWORD PTR _array_split$[ebp+eax*4]
  0019a	89 8d 6c b1 ff
	ff		 mov	 DWORD PTR _副机名$3[ebp], ecx

; 283  : 			index++;

  001a0	8b 85 c0 b1 ff
	ff		 mov	 eax, DWORD PTR _index$[ebp]
  001a6	83 c0 01	 add	 eax, 1
  001a9	89 85 c0 b1 ff
	ff		 mov	 DWORD PTR _index$[ebp], eax

; 284  : 			char* IP尾 = (char*)array_split[index];

  001af	8b 85 c0 b1 ff
	ff		 mov	 eax, DWORD PTR _index$[ebp]
  001b5	8b 8c 85 d8 b1
	ff ff		 mov	 ecx, DWORD PTR _array_split$[ebp+eax*4]
  001bc	89 8d 60 b1 ff
	ff		 mov	 DWORD PTR _IP尾$2[ebp], ecx

; 285  : 			index++;

  001c2	8b 85 c0 b1 ff
	ff		 mov	 eax, DWORD PTR _index$[ebp]
  001c8	83 c0 01	 add	 eax, 1
  001cb	89 85 c0 b1 ff
	ff		 mov	 DWORD PTR _index$[ebp], eax

; 286  : 
; 287  : 			if (index > count)

  001d1	8b 85 c0 b1 ff
	ff		 mov	 eax, DWORD PTR _index$[ebp]
  001d7	3b 85 cc b1 ff
	ff		 cmp	 eax, DWORD PTR _count$[ebp]
  001dd	7e 02		 jle	 SHORT $LN8@

; 288  : 			{
; 289  : 				return;

  001df	eb 7e		 jmp	 SHORT $LN1@
$LN8@:

; 290  : 			}
; 291  : 
; 292  : 			char buf2[100];
; 293  : 			wsprintfA(buf2, "|%s|%s.%s", 副机名, IP头, IP尾);

  001e1	8b f4		 mov	 esi, esp
  001e3	8b 85 60 b1 ff
	ff		 mov	 eax, DWORD PTR _IP尾$2[ebp]
  001e9	50		 push	 eax
  001ea	8b 8d 84 b1 ff
	ff		 mov	 ecx, DWORD PTR _IP头$5[ebp]
  001f0	51		 push	 ecx
  001f1	8b 95 6c b1 ff
	ff		 mov	 edx, DWORD PTR _副机名$3[ebp]
  001f7	52		 push	 edx
  001f8	68 00 00 00 00	 push	 OFFSET ??_C@_09KCBLGBPG@?$HM?$CFs?$HM?$CFs?4?$CFs?$AA@
  001fd	8d 85 f4 b0 ff
	ff		 lea	 eax, DWORD PTR _buf2$1[ebp]
  00203	50		 push	 eax
  00204	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0020a	83 c4 14	 add	 esp, 20			; 00000014H
  0020d	3b f4		 cmp	 esi, esp
  0020f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 294  : 			lstrcatA(dest, buf2);

  00214	8b f4		 mov	 esi, esp
  00216	8d 85 f4 b0 ff
	ff		 lea	 eax, DWORD PTR _buf2$1[ebp]
  0021c	50		 push	 eax
  0021d	8b 4d 0c	 mov	 ecx, DWORD PTR _dest$[ebp]
  00220	51		 push	 ecx
  00221	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcatA@8
  00227	3b f4		 cmp	 esi, esp
  00229	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 295  : 
; 296  : 		}

  0022e	e9 39 ff ff ff	 jmp	 $LN5@
$LN6@:

; 297  : 		index++;

  00233	8b 85 c0 b1 ff
	ff		 mov	 eax, DWORD PTR _index$[ebp]
  00239	83 c0 01	 add	 eax, 1
  0023c	89 85 c0 b1 ff
	ff		 mov	 DWORD PTR _index$[ebp], eax

; 298  : 
; 299  : 		lstrcatA(dest, "\n");

  00242	8b f4		 mov	 esi, esp
  00244	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  00249	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0024c	50		 push	 eax
  0024d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcatA@8
  00253	3b f4		 cmp	 esi, esp
  00255	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 300  : 
; 301  : 	}

  0025a	e9 3e fe ff ff	 jmp	 $LN2@
$LN1@:

; 302  : 
; 303  : }

  0025f	52		 push	 edx
  00260	8b cd		 mov	 ecx, ebp
  00262	50		 push	 eax
  00263	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@
  00269	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0026e	58		 pop	 eax
  0026f	5a		 pop	 edx
  00270	5f		 pop	 edi
  00271	5e		 pop	 esi
  00272	5b		 pop	 ebx
  00273	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00276	33 cd		 xor	 ecx, ebp
  00278	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0027d	81 c4 10 55 00
	00		 add	 esp, 21776		; 00005510H
  00283	3b ec		 cmp	 ebp, esp
  00285	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0028a	8b e5		 mov	 esp, ebp
  0028c	5d		 pop	 ebp
  0028d	c3		 ret	 0
  0028e	66 90		 npad	 2
$LN13@:
  00290	02 00 00 00	 DD	 2
  00294	00 00 00 00	 DD	 $LN12@
$LN12@:
  00298	d8 b1 ff ff	 DD	 -20008			; ffffb1d8H
  0029c	20 4e 00 00	 DD	 20000			; 00004e20H
  002a0	00 00 00 00	 DD	 $LN10@
  002a4	f4 b0 ff ff	 DD	 -20236			; ffffb0f4H
  002a8	64 00 00 00	 DD	 100			; 00000064H
  002ac	00 00 00 00	 DD	 $LN11@
$LN11@:
  002b0	62		 DB	 98			; 00000062H
  002b1	75		 DB	 117			; 00000075H
  002b2	66		 DB	 102			; 00000066H
  002b3	32		 DB	 50			; 00000032H
  002b4	00		 DB	 0
$LN10@:
  002b5	61		 DB	 97			; 00000061H
  002b6	72		 DB	 114			; 00000072H
  002b7	72		 DB	 114			; 00000072H
  002b8	61		 DB	 97			; 00000061H
  002b9	79		 DB	 121			; 00000079H
  002ba	5f		 DB	 95			; 0000005fH
  002bb	73		 DB	 115			; 00000073H
  002bc	70		 DB	 112			; 00000070H
  002bd	6c		 DB	 108			; 0000006cH
  002be	69		 DB	 105			; 00000069H
  002bf	74		 DB	 116			; 00000074H
  002c0	00		 DB	 0
?解析登陆列表明文@@YAXPAD0@Z ENDP			; 解析登陆列表明文
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\cca_serverlistctrl.cpp
;	COMDAT ?getStringFromIndexWithDelim_body@@YAHPAD0H0H0H@Z
_TEXT	SEGMENT
_last$1 = -56						; size = 4
_oneByteMode$ = -44					; size = 4
_addlen$ = -32						; size = 4
_length$ = -20						; size = 4
_i$ = -8						; size = 4
_src$ = 8						; size = 4
_delim$ = 12						; size = 4
_index$ = 16						; size = 4
_buf$ = 20						; size = 4
_buflen$ = 24						; size = 4
_file$ = 28						; size = 4
_line$ = 32						; size = 4
?getStringFromIndexWithDelim_body@@YAHPAD0H0H0H@Z PROC	; getStringFromIndexWithDelim_body, COMDAT

; 179  : {//ttom this function all change,copy from the second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00012	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 180  : 	int i;          /* 伙□皿  醒 */
; 181  : 	int length = 0;  /* 潸曰请仄凶  侬  及赢今 */

  0001e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _length$[ebp], 0

; 182  : 	int addlen = 0;   /* 箫今木月赢今 */

  00025	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _addlen$[ebp], 0

; 183  : 	int oneByteMode = 0; /* ㄠ田奶玄乒□玉井＂ */

  0002c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _oneByteMode$[ebp], 0

; 184  : 
; 185  : 	if (strlen(delim) == 1){ // 腹绸互ㄠ田奶玄卅日ㄠ田奶玄乒□玉卞允月

  00033	8b 45 0c	 mov	 eax, DWORD PTR _delim$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 _strlen
  0003c	83 c4 04	 add	 esp, 4
  0003f	83 f8 01	 cmp	 eax, 1
  00042	75 07		 jne	 SHORT $LN5@getStringF

; 186  : 		oneByteMode = 1;// 公及端ㄡ田奶玄  侬反民尼永弁仄卅中

  00044	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _oneByteMode$[ebp], 1
$LN5@getStringF:

; 187  : 	}
; 188  : 	for (i = 0; i < index; i++){

  0004b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00052	eb 09		 jmp	 SHORT $LN4@getStringF
$LN2@getStringF:
  00054	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00057	83 c0 01	 add	 eax, 1
  0005a	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@getStringF:
  0005d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00060	3b 45 10	 cmp	 eax, DWORD PTR _index$[ebp]
  00063	0f 8d 93 00 00
	00		 jge	 $LN3@getStringF

; 189  : 		char* last;
; 190  : 		src += addlen;/* 心勾井匀凶赢今毛箫允 */

  00069	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0006c	03 45 e0	 add	 eax, DWORD PTR _addlen$[ebp]
  0006f	89 45 08	 mov	 DWORD PTR _src$[ebp], eax

; 191  : 
; 192  : 		if (oneByteMode){

  00072	83 7d d4 00	 cmp	 DWORD PTR _oneByteMode$[ebp], 0
  00076	74 21		 je	 SHORT $LN6@getStringF

; 193  : 			// ㄠ田奶玄乒□玉分匀凶日仇切日匹腹绸
; 194  : 			last = ScanOneByte(src, delim[0]);

  00078	b8 01 00 00 00	 mov	 eax, 1
  0007d	6b c8 00	 imul	 ecx, eax, 0
  00080	8b 55 0c	 mov	 edx, DWORD PTR _delim$[ebp]
  00083	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00087	50		 push	 eax
  00088	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 ?ScanOneByte@@YAPADPADD@Z ; ScanOneByte
  00091	83 c4 08	 add	 esp, 8
  00094	89 45 c8	 mov	 DWORD PTR _last$1[ebp], eax

; 195  : 		}
; 196  : 		else{

  00097	eb 13		 jmp	 SHORT $LN7@getStringF
$LN6@getStringF:

; 197  : 			last = strstr(src, delim);  /* 苇尥仃月 */

  00099	8b 45 0c	 mov	 eax, DWORD PTR _delim$[ebp]
  0009c	50		 push	 eax
  0009d	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 ?strstr@@YAPADQADQBD@Z	; strstr
  000a6	83 c4 08	 add	 esp, 8
  000a9	89 45 c8	 mov	 DWORD PTR _last$1[ebp], eax
$LN7@getStringF:

; 198  : 		}
; 199  : 		if (last == NULL){

  000ac	83 7d c8 00	 cmp	 DWORD PTR _last$1[ebp], 0
  000b0	75 2a		 jne	 SHORT $LN8@getStringF

; 200  : 			/*
; 201  : 			* 心勾井日卅井匀凶及匹允屯化戊疋□仄化 return［
; 202  : 			*/
; 203  : 			strcpysafe(buf, buflen, src);

  000b2	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  000b5	50		 push	 eax
  000b6	8b 4d 18	 mov	 ecx, DWORD PTR _buflen$[ebp]
  000b9	51		 push	 ecx
  000ba	8b 55 14	 mov	 edx, DWORD PTR _buf$[ebp]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 ?strcpysafe@@YAXPADIPBD@Z ; strcpysafe
  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 204  : 
; 205  : 			if (i == index - 1)

  000c6	8b 45 10	 mov	 eax, DWORD PTR _index$[ebp]
  000c9	83 e8 01	 sub	 eax, 1
  000cc	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  000cf	75 07		 jne	 SHORT $LN9@getStringF

; 206  : 				/*切斤丹升心勾井匀凶*/
; 207  : 				return TRUE;

  000d1	b8 01 00 00 00	 mov	 eax, 1
  000d6	eb 41		 jmp	 SHORT $LN1@getStringF
$LN9@getStringF:

; 208  : 
; 209  : 			/*心勾井日卅井匀凶*/
; 210  : 			return FALSE;

  000d8	33 c0		 xor	 eax, eax
  000da	eb 3d		 jmp	 SHORT $LN1@getStringF
$LN8@getStringF:

; 211  : 		}
; 212  : 
; 213  : 		/*
; 214  : 		* 心勾井匀凶赭午  赓及匏  及犒毛菲户月
; 215  : 		* 勾引曰嗉濠日木化中月  侬  及赢今
; 216  : 		*/
; 217  : 		length = last - src;

  000dc	8b 45 c8	 mov	 eax, DWORD PTR _last$1[ebp]
  000df	2b 45 08	 sub	 eax, DWORD PTR _src$[ebp]
  000e2	89 45 ec	 mov	 DWORD PTR _length$[ebp], eax

; 218  : 
; 219  : 		/*
; 220  : 		* 戚及伙□皿及啃卞心勾井匀凶赢今午 delim 及赢今毛箫仄化云仁
; 221  : 		*/
; 222  : 		addlen = length + strlen(delim);

  000e5	8b 45 0c	 mov	 eax, DWORD PTR _delim$[ebp]
  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 _strlen
  000ee	83 c4 04	 add	 esp, 4
  000f1	03 45 ec	 add	 eax, DWORD PTR _length$[ebp]
  000f4	89 45 e0	 mov	 DWORD PTR _addlen$[ebp], eax

; 223  : 	}

  000f7	e9 58 ff ff ff	 jmp	 $LN2@getStringF
$LN3@getStringF:

; 224  : 	strncpysafe(buf, buflen, src, length);

  000fc	8b 45 ec	 mov	 eax, DWORD PTR _length$[ebp]
  000ff	50		 push	 eax
  00100	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  00103	51		 push	 ecx
  00104	8b 55 18	 mov	 edx, DWORD PTR _buflen$[ebp]
  00107	52		 push	 edx
  00108	8b 45 14	 mov	 eax, DWORD PTR _buf$[ebp]
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 ?strncpysafe@@YAXPADIPBDH@Z ; strncpysafe
  00111	83 c4 10	 add	 esp, 16			; 00000010H

; 225  : 
; 226  : 	return TRUE;

  00114	b8 01 00 00 00	 mov	 eax, 1
$LN1@getStringF:

; 227  : }

  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi
  0011b	5b		 pop	 ebx
  0011c	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  00122	3b ec		 cmp	 ebp, esp
  00124	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c3		 ret	 0
?getStringFromIndexWithDelim_body@@YAHPAD0H0H0H@Z ENDP	; getStringFromIndexWithDelim_body
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\cca_serverlistctrl.cpp
;	COMDAT ?ScanOneByte@@YAPADPADD@Z
_TEXT	SEGMENT
_src$ = 8						; size = 4
_delim$ = 12						; size = 1
?ScanOneByte@@YAPADPADD@Z PROC				; ScanOneByte, COMDAT

; 153  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 154  : 	// Nuke
; 155  : 	if (!src) return NULL;

  0001e	83 7d 08 00	 cmp	 DWORD PTR _src$[ebp], 0
  00022	75 07		 jne	 SHORT $LN5@ScanOneByt
  00024	33 c0		 xor	 eax, eax
  00026	e9 84 00 00 00	 jmp	 $LN1@ScanOneByt
$LN5@ScanOneByt:

; 156  : 
; 157  : 	//   侬  互卅仁卅月引匹腹绸
; 158  : 	for (; src[0] != '\0'; src++){

  0002b	eb 09		 jmp	 SHORT $LN4@ScanOneByt
$LN2@ScanOneByt:
  0002d	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00030	83 c0 01	 add	 eax, 1
  00033	89 45 08	 mov	 DWORD PTR _src$[ebp], eax
$LN4@ScanOneByt:
  00036	b8 01 00 00 00	 mov	 eax, 1
  0003b	6b c8 00	 imul	 ecx, eax, 0
  0003e	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  00041	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00045	85 c0		 test	 eax, eax
  00047	74 64		 je	 SHORT $LN3@ScanOneByt

; 159  : 		if (IS_2BYTEWORD(src[0])){

  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	6b c8 00	 imul	 ecx, eax, 0
  00051	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  00054	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00058	83 f8 80	 cmp	 eax, -128		; ffffff80H
  0005b	7c 32		 jl	 SHORT $LN6@ScanOneByt
  0005d	b8 01 00 00 00	 mov	 eax, 1
  00062	6b c8 00	 imul	 ecx, eax, 0
  00065	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  00068	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0006c	83 f8 ff	 cmp	 eax, -1
  0006f	7f 1e		 jg	 SHORT $LN6@ScanOneByt

; 160  : 			// 蝈剩分［公及桦宁反ㄠ田奶玄芴坌卞褡引六月［
; 161  : 			// 凶分仄ㄠ田奶玄仄井卅中桦宁反公丹仄卅中
; 162  : 			if (src[1] != 0){

  00071	b8 01 00 00 00	 mov	 eax, 1
  00076	c1 e0 00	 shl	 eax, 0
  00079	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  0007c	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00080	85 d2		 test	 edx, edx
  00082	74 09		 je	 SHORT $LN7@ScanOneByt

; 163  : 				src++;

  00084	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00087	83 c0 01	 add	 eax, 1
  0008a	89 45 08	 mov	 DWORD PTR _src$[ebp], eax
$LN7@ScanOneByt:

; 164  : 			}
; 165  : 			continue;

  0008d	eb 9e		 jmp	 SHORT $LN2@ScanOneByt
$LN6@ScanOneByt:

; 166  : 		}
; 167  : 		//   剩分匀凶［仇仇匹覆擂及  侬午  胜
; 168  : 		if (src[0] == delim){

  0008f	b8 01 00 00 00	 mov	 eax, 1
  00094	6b c8 00	 imul	 ecx, eax, 0
  00097	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  0009a	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0009e	0f be 4d 0c	 movsx	 ecx, BYTE PTR _delim$[ebp]
  000a2	3b c1		 cmp	 eax, ecx
  000a4	75 05		 jne	 SHORT $LN8@ScanOneByt

; 169  : 			return src;

  000a6	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  000a9	eb 04		 jmp	 SHORT $LN1@ScanOneByt
$LN8@ScanOneByt:

; 170  : 		}
; 171  : 	}

  000ab	eb 80		 jmp	 SHORT $LN2@ScanOneByt
$LN3@ScanOneByt:

; 172  : 	// 伙□皿  仃凶日苇勾井日卅井匀凶［
; 173  : 	return NULL;

  000ad	33 c0		 xor	 eax, eax
$LN1@ScanOneByt:

; 174  : }

  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
?ScanOneByte@@YAPADPADD@Z ENDP				; ScanOneByte
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\cca_serverlistctrl.cpp
;	COMDAT ?strcpysafe@@YAXPADIPBD@Z
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_n$ = 12						; size = 4
_src$ = 16						; size = 4
?strcpysafe@@YAXPADIPBD@Z PROC				; strcpysafe, COMDAT

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 116  : 	/*
; 117  : 	* src 井日 dest 尺戊疋□允月.
; 118  : 	* strcpy, strncpy 匹反 dest 方曰 戊疋□允月汹互
; 119  : 	*   五中凛卞裟少午,丢乒伉陆失弁本旦互粟月.
; 120  : 	* 仇木毛  什啃卞, strncpy 互丐月互 strlen( src ) 互 n 方曰
; 121  : 	*   五中凛卞反, dest 及    互 NULL   侬午反卅日卅中.
; 122  : 	*
; 123  : 	* 仄凶互匀化 dest 及  五今方曰 src 及幻丹互赢中凛卞反
; 124  : 	* n-1 匹 strncpy 毛允月. 凝今中凛反公及引引戊疋□允月
; 125  : 	*
; 126  : 	* n 互  及凛反云井仄仁卅月及匹  及凛反 窒手仄卅中［
; 127  : 	*
; 128  : 	*/
; 129  : 	// Nuke +1 (08/25): Danger if src=0
; 130  : 	if (!src) {

  0001e	83 7d 10 00	 cmp	 DWORD PTR _src$[ebp], 0
  00022	75 08		 jne	 SHORT $LN2@strcpysafe

; 131  : 		*dest = '\0';

  00024	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00027	c6 00 00	 mov	 BYTE PTR [eax], 0

; 132  : 		return;

  0002a	eb 51		 jmp	 SHORT $LN1@strcpysafe
$LN2@strcpysafe:

; 133  : 	}
; 134  : 	if (n <= 0)        /* 窒手仄卅中   */

  0002c	83 7d 0c 00	 cmp	 DWORD PTR _n$[ebp], 0
  00030	77 04		 ja	 SHORT $LN3@strcpysafe

; 135  : 		return;

  00032	eb 49		 jmp	 SHORT $LN1@strcpysafe
  00034	eb 47		 jmp	 SHORT $LN1@strcpysafe
$LN3@strcpysafe:

; 136  : 
; 137  : 	/*  仇及凛鳔匹｝ n >= 1 动晓互瑁烂  */
; 138  : 	/*  NULL  侬毛哔  仄化  胜允月  */
; 139  : 	else if (n < strlen(src) + 1){

  00036	8b 45 10	 mov	 eax, DWORD PTR _src$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _strlen
  0003f	83 c4 04	 add	 esp, 4
  00042	83 c0 01	 add	 eax, 1
  00045	39 45 0c	 cmp	 DWORD PTR _n$[ebp], eax
  00048	73 23		 jae	 SHORT $LN5@strcpysafe

; 140  : 		/*
; 141  : 		* 田永白央互箫曰卅中及匹 n - 1(NULL  侬)
; 142  : 		* 匹 strncpy 毛裟少
; 143  : 		*/
; 144  : 		strncpy2(dest, src, n - 1);

  0004a	8b 45 0c	 mov	 eax, DWORD PTR _n$[ebp]
  0004d	83 e8 01	 sub	 eax, 1
  00050	50		 push	 eax
  00051	8b 4d 10	 mov	 ecx, DWORD PTR _src$[ebp]
  00054	51		 push	 ecx
  00055	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  00058	52		 push	 edx
  00059	e8 00 00 00 00	 call	 ?strncpy2@@YAPADPADPBDI@Z ; strncpy2
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 145  : 		dest[n - 1] = '\0';

  00061	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00064	03 45 0c	 add	 eax, DWORD PTR _n$[ebp]
  00067	c6 40 ff 00	 mov	 BYTE PTR [eax-1], 0

; 146  : 	}
; 147  : 	else

  0006b	eb 10		 jmp	 SHORT $LN1@strcpysafe
$LN5@strcpysafe:

; 148  : 		strcpy(dest, src);

  0006d	8b 45 10	 mov	 eax, DWORD PTR _src$[ebp]
  00070	50		 push	 eax
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 _strcpy
  0007a	83 c4 08	 add	 esp, 8
$LN1@strcpysafe:

; 149  : 
; 150  : }

  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00086	3b ec		 cmp	 ebp, esp
  00088	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
?strcpysafe@@YAXPADIPBD@Z ENDP				; strcpysafe
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\cca_serverlistctrl.cpp
;	COMDAT ?strncpysafe@@YAXPADIPBDH@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_Short$ = -8						; size = 4
_dest$ = 8						; size = 4
_n$ = 12						; size = 4
_src$ = 16						; size = 4
_length$ = 20						; size = 4
?strncpysafe@@YAXPADIPBDH@Z PROC			; strncpysafe, COMDAT

; 75   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 76   : 	/*
; 77   : 	* src 井日 dest 卞 length 戊疋□允月
; 78   : 	* strcpy, strncpy 匹反 dest 方曰 戊疋□允月汹互
; 79   : 	*   五中凛卞裟少午,丢乒伉陆失弁本旦互粟月.
; 80   : 	* 仇及楮醒匹反｝strlen( src ) 午 length 及凝今中幻丹
; 81   : 	* (  端卞戊疋□允月汹) 午 dest 及扔奶术毛  屯化｝
; 82   : 	* strcpysafe 午  元仪毛允月［
; 83   : 	*/
; 84   : 
; 85   : 	int Short;
; 86   : 	Short = min(strlen(src), length);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _src$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _strlen
  00027	83 c4 04	 add	 esp, 4
  0002a	3b 45 14	 cmp	 eax, DWORD PTR _length$[ebp]
  0002d	73 14		 jae	 SHORT $LN7@strncpysaf
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR _src$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 _strlen
  00038	83 c4 04	 add	 esp, 4
  0003b	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
  00041	eb 09		 jmp	 SHORT $LN8@strncpysaf
$LN7@strncpysaf:
  00043	8b 55 14	 mov	 edx, DWORD PTR _length$[ebp]
  00046	89 95 30 ff ff
	ff		 mov	 DWORD PTR tv69[ebp], edx
$LN8@strncpysaf:
  0004c	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv69[ebp]
  00052	89 45 f8	 mov	 DWORD PTR _Short$[ebp], eax

; 87   : 
; 88   : 	/* NULL  侬 毛哔  仄凶  胜 */
; 89   : 	if (n < Short + 1){

  00055	8b 45 f8	 mov	 eax, DWORD PTR _Short$[ebp]
  00058	83 c0 01	 add	 eax, 1
  0005b	39 45 0c	 cmp	 DWORD PTR _n$[ebp], eax
  0005e	73 23		 jae	 SHORT $LN2@strncpysaf

; 90   : 		/*
; 91   : 		* 田永白央互箫曰卅中及匹 n - 1(NULL  侬)
; 92   : 		* 匹 strncpy 毛裟少
; 93   : 		*/
; 94   : 		strncpy2(dest, src, n - 1);

  00060	8b 45 0c	 mov	 eax, DWORD PTR _n$[ebp]
  00063	83 e8 01	 sub	 eax, 1
  00066	50		 push	 eax
  00067	8b 4d 10	 mov	 ecx, DWORD PTR _src$[ebp]
  0006a	51		 push	 ecx
  0006b	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  0006e	52		 push	 edx
  0006f	e8 00 00 00 00	 call	 ?strncpy2@@YAPADPADPBDI@Z ; strncpy2
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH

; 95   : 		dest[n - 1] = '\0';

  00077	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0007a	03 45 0c	 add	 eax, DWORD PTR _n$[ebp]
  0007d	c6 40 ff 00	 mov	 BYTE PTR [eax-1], 0
  00081	eb 27		 jmp	 SHORT $LN1@strncpysaf
$LN2@strncpysaf:

; 96   : 
; 97   : 	}
; 98   : 	else if (n <= 0){

  00083	83 7d 0c 00	 cmp	 DWORD PTR _n$[ebp], 0
  00087	77 04		 ja	 SHORT $LN4@strncpysaf

; 99   : 		return;

  00089	eb 1f		 jmp	 SHORT $LN1@strncpysaf

; 100  : 	}
; 101  : 	else{

  0008b	eb 1d		 jmp	 SHORT $LN1@strncpysaf
$LN4@strncpysaf:

; 102  : 		/*
; 103  : 		* 田永白央反蜗坌卞丐月及匹 Short 匹strncpy毛裟少
; 104  : 		* 卅云 src 卞反 Short 及赢今  卞 NULL 互卅中及匹｝
; 105  : 		* dest 卞反 馨笛仄化云仁［
; 106  : 		*/
; 107  : 
; 108  : 		strncpy2(dest, src, Short);

  0008d	8b 45 f8	 mov	 eax, DWORD PTR _Short$[ebp]
  00090	50		 push	 eax
  00091	8b 4d 10	 mov	 ecx, DWORD PTR _src$[ebp]
  00094	51		 push	 ecx
  00095	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  00098	52		 push	 edx
  00099	e8 00 00 00 00	 call	 ?strncpy2@@YAPADPADPBDI@Z ; strncpy2
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 109  : 		dest[Short] = '\0';

  000a1	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  000a4	03 45 f8	 add	 eax, DWORD PTR _Short$[ebp]
  000a7	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN1@strncpysaf:

; 110  : 
; 111  : 	}
; 112  : }

  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000b3	3b ec		 cmp	 ebp, esp
  000b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
?strncpysafe@@YAXPADIPBDH@Z ENDP			; strncpysafe
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\cca_serverlistctrl.cpp
;	COMDAT ?strncpy2@@YAPADPADPBDI@Z
_TEXT	SEGMENT
_i$1 = -32						; size = 4
_s$2 = -20						; size = 4
_d$3 = -8						; size = 4
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_n$ = 16						; size = 4
?strncpy2@@YAPADPADPBDI@Z PROC				; strncpy2, COMDAT

; 46   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 47   : 	if (n > 0){

  0001e	83 7d 10 00	 cmp	 DWORD PTR _n$[ebp], 0
  00022	0f 86 aa 00 00
	00		 jbe	 $LN5@strncpy2

; 48   : 		char*   d = dest;

  00028	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	89 45 f8	 mov	 DWORD PTR _d$3[ebp], eax

; 49   : 		const char*   s = src;

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00031	89 45 ec	 mov	 DWORD PTR _s$2[ebp], eax

; 50   : 		int i;
; 51   : 		for (i = 0; i<n; i++){

  00034	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0003b	eb 09		 jmp	 SHORT $LN4@strncpy2
$LN2@strncpy2:
  0003d	8b 45 e0	 mov	 eax, DWORD PTR _i$1[ebp]
  00040	83 c0 01	 add	 eax, 1
  00043	89 45 e0	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@strncpy2:
  00046	8b 45 e0	 mov	 eax, DWORD PTR _i$1[ebp]
  00049	3b 45 10	 cmp	 eax, DWORD PTR _n$[ebp]
  0004c	0f 83 80 00 00
	00		 jae	 $LN5@strncpy2

; 52   : 			if (*(s + i) == 0){

  00052	8b 45 ec	 mov	 eax, DWORD PTR _s$2[ebp]
  00055	03 45 e0	 add	 eax, DWORD PTR _i$1[ebp]
  00058	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0005b	85 c9		 test	 ecx, ecx
  0005d	75 0e		 jne	 SHORT $LN6@strncpy2

; 53   : 				/*  戊疋□仄云歹匀凶日 NULL   侬毛  木月   */
; 54   : 				*(d + i) = '\0';

  0005f	8b 45 f8	 mov	 eax, DWORD PTR _d$3[ebp]
  00062	03 45 e0	 add	 eax, DWORD PTR _i$1[ebp]
  00065	c6 00 00	 mov	 BYTE PTR [eax], 0

; 55   : 				return dest;

  00068	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0006b	eb 68		 jmp	 SHORT $LN1@strncpy2
$LN6@strncpy2:

; 56   : 			}
; 57   : 			if (*(s + i) & 0x80){

  0006d	8b 45 ec	 mov	 eax, DWORD PTR _s$2[ebp]
  00070	03 45 e0	 add	 eax, DWORD PTR _i$1[ebp]
  00073	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00076	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  0007c	74 3f		 je	 SHORT $LN7@strncpy2

; 58   : 				*(d + i) = *(s + i);

  0007e	8b 45 f8	 mov	 eax, DWORD PTR _d$3[ebp]
  00081	03 45 e0	 add	 eax, DWORD PTR _i$1[ebp]
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _s$2[ebp]
  00087	03 4d e0	 add	 ecx, DWORD PTR _i$1[ebp]
  0008a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0008c	88 10		 mov	 BYTE PTR [eax], dl

; 59   : 				i++;

  0008e	8b 45 e0	 mov	 eax, DWORD PTR _i$1[ebp]
  00091	83 c0 01	 add	 eax, 1
  00094	89 45 e0	 mov	 DWORD PTR _i$1[ebp], eax

; 60   : 				if (i >= n){

  00097	8b 45 e0	 mov	 eax, DWORD PTR _i$1[ebp]
  0009a	3b 45 10	 cmp	 eax, DWORD PTR _n$[ebp]
  0009d	72 0c		 jb	 SHORT $LN9@strncpy2

; 61   : 					*(d + i - 1) = '\0';

  0009f	8b 45 f8	 mov	 eax, DWORD PTR _d$3[ebp]
  000a2	03 45 e0	 add	 eax, DWORD PTR _i$1[ebp]
  000a5	c6 40 ff 00	 mov	 BYTE PTR [eax-1], 0

; 62   : 					break;

  000a9	eb 27		 jmp	 SHORT $LN5@strncpy2
$LN9@strncpy2:

; 63   : 				}
; 64   : 				*(d + i) = *(s + i);

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _d$3[ebp]
  000ae	03 45 e0	 add	 eax, DWORD PTR _i$1[ebp]
  000b1	8b 4d ec	 mov	 ecx, DWORD PTR _s$2[ebp]
  000b4	03 4d e0	 add	 ecx, DWORD PTR _i$1[ebp]
  000b7	8a 11		 mov	 dl, BYTE PTR [ecx]
  000b9	88 10		 mov	 BYTE PTR [eax], dl

; 65   : 			}
; 66   : 			else

  000bb	eb 10		 jmp	 SHORT $LN8@strncpy2
$LN7@strncpy2:

; 67   : 				*(d + i) = *(s + i);

  000bd	8b 45 f8	 mov	 eax, DWORD PTR _d$3[ebp]
  000c0	03 45 e0	 add	 eax, DWORD PTR _i$1[ebp]
  000c3	8b 4d ec	 mov	 ecx, DWORD PTR _s$2[ebp]
  000c6	03 4d e0	 add	 ecx, DWORD PTR _i$1[ebp]
  000c9	8a 11		 mov	 dl, BYTE PTR [ecx]
  000cb	88 10		 mov	 BYTE PTR [eax], dl
$LN8@strncpy2:

; 68   : 		}

  000cd	e9 6b ff ff ff	 jmp	 $LN2@strncpy2
$LN5@strncpy2:

; 69   : 	}
; 70   : 	return dest;

  000d2	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
$LN1@strncpy2:

; 71   : }

  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx
  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c3		 ret	 0
?strncpy2@@YAPADPADPBDI@Z ENDP				; strncpy2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\cca_serverlistctrl.cpp
;	COMDAT ?split_damage@@YAHPADDPAHI@Z
_TEXT	SEGMENT
_i$ = -20						; size = 4
_count$ = -8						; size = 4
_src$ = 8						; size = 4
_delim$ = 12						; size = 1
_pArraySplitAddr$ = 16					; size = 4
_maxCount$ = 20						; size = 4
?split_damage@@YAHPADDPAHI@Z PROC			; split_damage, COMDAT

; 231  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 232  : 
; 233  : 	unsigned int count = 1;	//最少能分割1个成员(当分隔符不存在的时候，返回自身)

  0001e	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _count$[ebp], 1

; 234  : 	*pArraySplitAddr = (int)src;

  00025	8b 45 10	 mov	 eax, DWORD PTR _pArraySplitAddr$[ebp]
  00028	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  0002b	89 08		 mov	 DWORD PTR [eax], ecx

; 235  : 	pArraySplitAddr++;

  0002d	8b 45 10	 mov	 eax, DWORD PTR _pArraySplitAddr$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 10	 mov	 DWORD PTR _pArraySplitAddr$[ebp], eax

; 236  : 	int i = 0;

  00036	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN2@split_dama:

; 237  : 	while (*(src + i)){	//当非0的时候继续循环

  0003d	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00040	03 45 ec	 add	 eax, DWORD PTR _i$[ebp]
  00043	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00046	85 c9		 test	 ecx, ecx
  00048	74 53		 je	 SHORT $LN3@split_dama

; 238  : 		if (*(src + i) == delim){	//如果找到了分隔符

  0004a	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0004d	03 45 ec	 add	 eax, DWORD PTR _i$[ebp]
  00050	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00053	0f be 55 0c	 movsx	 edx, BYTE PTR _delim$[ebp]
  00057	3b ca		 cmp	 ecx, edx
  00059	75 37		 jne	 SHORT $LN4@split_dama

; 239  : 			if (count >= maxCount){

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  0005e	3b 45 14	 cmp	 eax, DWORD PTR _maxCount$[ebp]
  00061	72 05		 jb	 SHORT $LN5@split_dama

; 240  : 				return count;

  00063	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00066	eb 38		 jmp	 SHORT $LN1@split_dama
$LN5@split_dama:

; 241  : 			}
; 242  : 			*(src + i) = 0;	//将分隔符置0

  00068	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0006b	03 45 ec	 add	 eax, DWORD PTR _i$[ebp]
  0006e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 243  : 			*pArraySplitAddr = (int)(src + i + 1);	//将分隔符的下一个字节地址储存

  00071	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00074	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  00077	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  0007b	8b 45 10	 mov	 eax, DWORD PTR _pArraySplitAddr$[ebp]
  0007e	89 10		 mov	 DWORD PTR [eax], edx

; 244  : 			pArraySplitAddr++;

  00080	8b 45 10	 mov	 eax, DWORD PTR _pArraySplitAddr$[ebp]
  00083	83 c0 04	 add	 eax, 4
  00086	89 45 10	 mov	 DWORD PTR _pArraySplitAddr$[ebp], eax

; 245  : 			count++;

  00089	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  0008c	83 c0 01	 add	 eax, 1
  0008f	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN4@split_dama:

; 246  : 		}
; 247  : 		i++;

  00092	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00095	83 c0 01	 add	 eax, 1
  00098	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax

; 248  : 	}

  0009b	eb a0		 jmp	 SHORT $LN2@split_dama
$LN3@split_dama:

; 249  : 
; 250  : 	return count;

  0009d	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
$LN1@split_dama:

; 251  : }

  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi
  000a2	5b		 pop	 ebx
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
?split_damage@@YAHPADDPAHI@Z ENDP			; split_damage
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

  0001e	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
  00023	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00026	89 45 ec	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00029	8b 45 ec	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0002c	50		 push	 eax
  0002d	6a 00		 push	 0
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 __vsprintf_l
  0003c	83 c4 10	 add	 esp, 16			; 00000010H
  0003f	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

  00042	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 1788 : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  0001e	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00029	52		 push	 edx
  0002a	6a ff		 push	 -1
  0002c	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 __vsnprintf_l
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -208						; size = 4
__Result$ = -8						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1386 :     int const _Result = __stdio_common_vsprintf(

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  0002f	50		 push	 eax
  00030	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00039	8b 10		 mov	 edx, DWORD PTR [eax]
  0003b	83 ca 01	 or	 edx, 1
  0003e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00041	50		 push	 eax
  00042	52		 push	 edx
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  00049	83 c4 1c	 add	 esp, 28			; 0000001cH
  0004c	3b f4		 cmp	 esi, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00056	83 7d f8 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0005a	7d 0c		 jge	 SHORT $LN3@vsnprintf_
  0005c	c7 85 30 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv74[ebp], -1
  00066	eb 09		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00068	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]
  0006b	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  00071	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv74[ebp]

; 1391 : }

  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00080	3b ec		 cmp	 ebp, esp
  00082	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 144  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
;	COMDAT ?strstr@@YAPADQADQBD@Z
_TEXT	SEGMENT
__String$ = 8						; size = 4
__SubString$ = 12					; size = 4
?strstr@@YAPADQADQBD@Z PROC				; strstr, COMDAT

; 536  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 537  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 0c	 mov	 eax, DWORD PTR __SubString$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR __String$[ebp]
  00027	51		 push	 ecx
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strstr
  0002e	83 c4 08	 add	 esp, 8
  00031	3b f4		 cmp	 esi, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 538  :     }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?strstr@@YAPADQADQBD@Z ENDP				; strstr
_TEXT	ENDS
END
