; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Administrator\Desktop\????? ??\????? ??\Client Source Code\system\loadrealbin.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?autoMapColorTbl@@3PAEA				; autoMapColorTbl
PUBLIC	?bitmapnumbertable@@3PAKA			; bitmapnumbertable
PUBLIC	?Realbinfp@@3PAPAU_iobuf@@A			; Realbinfp
PUBLIC	?Addrbinfp@@3PAU_iobuf@@A			; Addrbinfp
PUBLIC	?adrnbuff@@3PAUADRNBIN@@A			; adrnbuff
PUBLIC	?g_realgetimagebuf@@3PAEA			; g_realgetimagebuf
PUBLIC	?g_realgetimagebuf2@@3PAEA			; g_realgetimagebuf2
PUBLIC	?NewColor16Flg@@3HA				; NewColor16Flg
_BSS	SEGMENT
?autoMapColorTbl@@3PAEA DB 0f4240H DUP (?)		; autoMapColorTbl
?bitmapnumbertable@@3PAKA DD 0f4240H DUP (?)		; bitmapnumbertable
?Realbinfp@@3PAPAU_iobuf@@A DD 0f4240H DUP (?)		; Realbinfp
?Addrbinfp@@3PAU_iobuf@@A DD 01H DUP (?)		; Addrbinfp
?adrnbuff@@3PAUADRNBIN@@A DB 04c4b400H DUP (?)		; adrnbuff
?g_realgetimagebuf@@3PAEA DB 0600020H DUP (?)		; g_realgetimagebuf
?g_realgetimagebuf2@@3PAEA DB 0600020H DUP (?)		; g_realgetimagebuf2
?NewColor16Flg@@3HA DD 01H DUP (?)			; NewColor16Flg
_BSS	ENDS
_DATA	SEGMENT
?FontPal@@3PAKA DD 0ffffffH				; FontPal
	DD	0ffff00H
	DD	0ff00ffH
	DD	0ff0000H
	DD	0ffffH
	DD	0ff00H
	DD	0ffH
	DD	0a4a0a0H
	DD	0f0caa6H
	DD	0c0dcc0H
	DD	08cffH
	DD	0247fffH
_DATA	ENDS
PUBLIC	?strstr@@YAPADQADQBD@Z				; strstr
PUBLIC	___local_stdio_scanf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	__vsscanf_s_l
PUBLIC	_vsscanf_s
PUBLIC	_sscanf_s
PUBLIC	?initAutoMapColor@@YAXPAD@Z			; initAutoMapColor
PUBLIC	?makeAutoMapColor@@YAXXZ			; makeAutoMapColor
PUBLIC	?writeAutoMapColor@@YAHPAD0@Z			; writeAutoMapColor
PUBLIC	?readAutoMapColor@@YAHPAD0@Z			; readAutoMapColor
PUBLIC	?cleanupRealbin@@YAXXZ				; cleanupRealbin
PUBLIC	?realGetImage@@YAHHPAPAEPAH1@Z			; realGetImage
PUBLIC	?realGetPos@@YAHKPAF0@Z				; realGetPos
PUBLIC	?realGetWH@@YAHKPAF0@Z				; realGetWH
PUBLIC	?realGetHitPoints@@YAHKPAF0@Z			; realGetHitPoints
PUBLIC	?realGetHitFlag@@YAHKPAF@Z			; realGetHitFlag
PUBLIC	?realGetPrioType@@YAHKPAF@Z			; realGetPrioType
PUBLIC	?realGetHeightFlag@@YAHKPAF@Z			; realGetHeightFlag
PUBLIC	?realGetNo@@YAHKPAK@Z				; realGetNo
PUBLIC	?realGetSoundEffect@@YAHK@Z			; realGetSoundEffect
PUBLIC	?realGetWalkSoundEffect@@YAHK@Z			; realGetWalkSoundEffect
PUBLIC	?realGetBitmapNo@@YAHH@Z			; realGetBitmapNo
PUBLIC	?initRealbinFileOpen@@YAHPAD0@Z			; initRealbinFileOpen
PUBLIC	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0O@PLLALPBE@data?2auto?4dat?$AA@		; `string'
PUBLIC	??_C@_04IFMAMMFM@adrn?$AA@			; `string'
PUBLIC	??_C@_0M@GAINFBKI@adrn_?$CFd?4bin?$AA@		; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp__strstr:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__feof:PROC
EXTRN	__imp___fileno:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp__fseek:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp____stdio_common_vsscanf:PROC
EXTRN	?getAutoMapColor@@YAHI@Z:PROC			; getAutoMapColor
EXTRN	?decoder@@YAPAEPAEPAPAEPAI22@Z:PROC		; decoder
EXTRN	__imp___fstat64i32:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	?MaxAdrnID@@3HA:DWORD				; MaxAdrnID
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GAINFBKI@adrn_?$CFd?4bin?$AA@
CONST	SEGMENT
??_C@_0M@GAINFBKI@adrn_?$CFd?4bin?$AA@ DB 'adrn_%d.bin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IFMAMMFM@adrn?$AA@
CONST	SEGMENT
??_C@_04IFMAMMFM@adrn?$AA@ DB 'adrn', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PLLALPBE@data?2auto?4dat?$AA@
CONST	SEGMENT
??_C@_0O@PLLALPBE@data?2auto?4dat?$AA@ DB 'data\auto.dat', 00H ; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\loadrealbin.cpp
;	COMDAT ?initRealbinFileOpen@@YAHPAD0@Z
_TEXT	SEGMENT
_Realfp$ = -100						; size = 4
_tmpadrnbuff$ = -88					; size = 80
__$ArrayPad$ = -4					; size = 4
_realbinfilename$ = 8					; size = 4
_addrbinfilename$ = 12					; size = 4
?initRealbinFileOpen@@YAHPAD0@Z PROC			; initRealbinFileOpen, COMDAT

; 176  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd d8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-296]
  00012	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 177  : 	ADRNBIN tmpadrnbuff;
; 178  : 	if ((Addrbinfp = fopen(addrbinfilename, "rb")) == NULL)

  00028	8b f4		 mov	 esi, esp
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  0002f	8b 45 0c	 mov	 eax, DWORD PTR _addrbinfilename$[ebp]
  00032	50		 push	 eax
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00039	83 c4 08	 add	 esp, 8
  0003c	3b f4		 cmp	 esi, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	a3 00 00 00 00	 mov	 DWORD PTR ?Addrbinfp@@3PAU_iobuf@@A, eax ; Addrbinfp
  00048	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?Addrbinfp@@3PAU_iobuf@@A, 0 ; Addrbinfp
  0004f	75 07		 jne	 SHORT $LN4@initRealbi

; 179  : 		return FALSE;

  00051	33 c0		 xor	 eax, eax
  00053	e9 3f 01 00 00	 jmp	 $LN1@initRealbi
$LN4@initRealbi:

; 180  : #ifdef _PTTERN_SEPARATION_BIN
; 181  : 	FILE *Realfp;
; 182  : 	if ((Realfp = fopen(realbinfilename, "rb")) == NULL)

  00058	8b f4		 mov	 esi, esp
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  0005f	8b 45 08	 mov	 eax, DWORD PTR _realbinfilename$[ebp]
  00062	50		 push	 eax
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00069	83 c4 08	 add	 esp, 8
  0006c	3b f4		 cmp	 esi, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	89 45 9c	 mov	 DWORD PTR _Realfp$[ebp], eax
  00076	83 7d 9c 00	 cmp	 DWORD PTR _Realfp$[ebp], 0
  0007a	75 07		 jne	 SHORT $LN2@initRealbi

; 183  : 		return FALSE;

  0007c	33 c0		 xor	 eax, eax
  0007e	e9 14 01 00 00	 jmp	 $LN1@initRealbi
$LN2@initRealbi:

; 184  : #else
; 185  : 	if ((fopen_s(&Realbinfp, realbinfilename, "rb")) != NULL)
; 186  : 		return FALSE;
; 187  : #endif
; 188  : 	//adrn.bin
; 189  : 	while (!feof(Addrbinfp)) {

  00083	8b f4		 mov	 esi, esp
  00085	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Addrbinfp@@3PAU_iobuf@@A ; Addrbinfp
  0008a	50		 push	 eax
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__feof
  00091	83 c4 04	 add	 esp, 4
  00094	3b f4		 cmp	 esi, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009b	85 c0		 test	 eax, eax
  0009d	0f 85 d7 00 00
	00		 jne	 $LN3@initRealbi

; 190  : 		fread(&tmpadrnbuff, sizeof(tmpadrnbuff), 1, Addrbinfp);

  000a3	8b f4		 mov	 esi, esp
  000a5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Addrbinfp@@3PAU_iobuf@@A ; Addrbinfp
  000aa	50		 push	 eax
  000ab	6a 01		 push	 1
  000ad	6a 50		 push	 80			; 00000050H
  000af	8d 4d a8	 lea	 ecx, DWORD PTR _tmpadrnbuff$[ebp]
  000b2	51		 push	 ecx
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  000b9	83 c4 10	 add	 esp, 16			; 00000010H
  000bc	3b f4		 cmp	 esi, esp
  000be	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 191  : 		adrnbuff[tmpadrnbuff.bitmapno] = tmpadrnbuff;

  000c3	6b 7d a8 50	 imul	 edi, DWORD PTR _tmpadrnbuff$[ebp], 80
  000c7	81 c7 00 00 00
	00		 add	 edi, OFFSET ?adrnbuff@@3PAUADRNBIN@@A ; adrnbuff
  000cd	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  000d2	8d 75 a8	 lea	 esi, DWORD PTR _tmpadrnbuff$[ebp]
  000d5	f3 a5		 rep movsd

; 192  : 
; 193  : #ifdef _PTTERN_SEPARATION_BIN
; 194  : 		Realbinfp[tmpadrnbuff.bitmapno] = Realfp;

  000d7	8b 45 a8	 mov	 eax, DWORD PTR _tmpadrnbuff$[ebp]
  000da	8b 4d 9c	 mov	 ecx, DWORD PTR _Realfp$[ebp]
  000dd	89 0c 85 00 00
	00 00		 mov	 DWORD PTR ?Realbinfp@@3PAPAU_iobuf@@A[eax*4], ecx

; 195  : 		if ((ULONG)MaxAdrnID < tmpadrnbuff.bitmapno) {

  000e4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?MaxAdrnID@@3HA ; MaxAdrnID
  000e9	3b 45 a8	 cmp	 eax, DWORD PTR _tmpadrnbuff$[ebp]
  000ec	73 08		 jae	 SHORT $LN6@initRealbi

; 196  : 			MaxAdrnID = tmpadrnbuff.bitmapno;

  000ee	8b 45 a8	 mov	 eax, DWORD PTR _tmpadrnbuff$[ebp]
  000f1	a3 00 00 00 00	 mov	 DWORD PTR ?MaxAdrnID@@3HA, eax ; MaxAdrnID
$LN6@initRealbi:

; 197  : 		}
; 198  : #endif
; 199  : 		if (tmpadrnbuff.attr.bmpnumber != 0) {

  000f6	83 7d f4 00	 cmp	 DWORD PTR _tmpadrnbuff$[ebp+76], 0
  000fa	74 6b		 je	 SHORT $LN7@initRealbi

; 200  : 			if ((12802 <= tmpadrnbuff.attr.bmpnumber && tmpadrnbuff.attr.bmpnumber <= 12811)
; 201  : 				|| (10132 <= tmpadrnbuff.attr.bmpnumber && tmpadrnbuff.attr.bmpnumber <= 10136)) {

  000fc	81 7d f4 02 32
	00 00		 cmp	 DWORD PTR _tmpadrnbuff$[ebp+76], 12802 ; 00003202H
  00103	72 09		 jb	 SHORT $LN11@initRealbi
  00105	81 7d f4 0b 32
	00 00		 cmp	 DWORD PTR _tmpadrnbuff$[ebp+76], 12811 ; 0000320bH
  0010c	76 12		 jbe	 SHORT $LN10@initRealbi
$LN11@initRealbi:
  0010e	81 7d f4 94 27
	00 00		 cmp	 DWORD PTR _tmpadrnbuff$[ebp+76], 10132 ; 00002794H
  00115	72 2d		 jb	 SHORT $LN9@initRealbi
  00117	81 7d f4 98 27
	00 00		 cmp	 DWORD PTR _tmpadrnbuff$[ebp+76], 10136 ; 00002798H
  0011e	77 24		 ja	 SHORT $LN9@initRealbi
$LN10@initRealbi:

; 202  : 				adrnbuff[tmpadrnbuff.bitmapno].attr.hit =

  00120	6b 45 a8 50	 imul	 eax, DWORD PTR _tmpadrnbuff$[ebp], 80
  00124	0f b7 80 1e 00
	00 00		 movzx	 eax, WORD PTR ?adrnbuff@@3PAUADRNBIN@@A[eax+30]
  0012b	99		 cdq
  0012c	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00131	f7 f9		 idiv	 ecx
  00133	81 c2 2c 01 00
	00		 add	 edx, 300		; 0000012cH
  00139	6b 45 a8 50	 imul	 eax, DWORD PTR _tmpadrnbuff$[ebp], 80
  0013d	66 89 90 1e 00
	00 00		 mov	 WORD PTR ?adrnbuff@@3PAUADRNBIN@@A[eax+30], dx
$LN9@initRealbi:

; 203  : 					300 + (adrnbuff[tmpadrnbuff.bitmapno].attr.hit % 100);
; 204  : 			}
; 205  : 			if (tmpadrnbuff.attr.bmpnumber <= 33 && tmpadrnbuff.bitmapno>230000) {//防堵魔法图号覆盖声音的bug

  00144	83 7d f4 21	 cmp	 DWORD PTR _tmpadrnbuff$[ebp+76], 33 ; 00000021H
  00148	77 0e		 ja	 SHORT $LN12@initRealbi
  0014a	81 7d a8 70 82
	03 00		 cmp	 DWORD PTR _tmpadrnbuff$[ebp], 230000 ; 00038270H
  00151	76 05		 jbe	 SHORT $LN12@initRealbi

; 206  : 				continue;

  00153	e9 2b ff ff ff	 jmp	 $LN2@initRealbi
$LN12@initRealbi:

; 207  : 			}
; 208  : 			bitmapnumbertable[tmpadrnbuff.attr.bmpnumber] = tmpadrnbuff.bitmapno;

  00158	8b 45 f4	 mov	 eax, DWORD PTR _tmpadrnbuff$[ebp+76]
  0015b	8b 4d a8	 mov	 ecx, DWORD PTR _tmpadrnbuff$[ebp]
  0015e	89 0c 85 00 00
	00 00		 mov	 DWORD PTR ?bitmapnumbertable@@3PAKA[eax*4], ecx

; 209  : 		}
; 210  : 		else

  00165	eb 0e		 jmp	 SHORT $LN8@initRealbi
$LN7@initRealbi:

; 211  : 			bitmapnumbertable[tmpadrnbuff.attr.bmpnumber] = 0;

  00167	8b 45 f4	 mov	 eax, DWORD PTR _tmpadrnbuff$[ebp+76]
  0016a	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ?bitmapnumbertable@@3PAKA[eax*4], 0
$LN8@initRealbi:

; 212  : 	}

  00175	e9 09 ff ff ff	 jmp	 $LN2@initRealbi
$LN3@initRealbi:

; 213  : 	fclose(Addrbinfp);

  0017a	8b f4		 mov	 esi, esp
  0017c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Addrbinfp@@3PAU_iobuf@@A ; Addrbinfp
  00181	50		 push	 eax
  00182	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00188	83 c4 04	 add	 esp, 4
  0018b	3b f4		 cmp	 esi, esp
  0018d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 214  : 	return TRUE;

  00192	b8 01 00 00 00	 mov	 eax, 1
$LN1@initRealbi:

; 215  : }

  00197	52		 push	 edx
  00198	8b cd		 mov	 ecx, ebp
  0019a	50		 push	 eax
  0019b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN17@initRealbi
  001a1	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001a6	58		 pop	 eax
  001a7	5a		 pop	 edx
  001a8	5f		 pop	 edi
  001a9	5e		 pop	 esi
  001aa	5b		 pop	 ebx
  001ab	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ae	33 cd		 xor	 ecx, ebp
  001b0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b5	81 c4 28 01 00
	00		 add	 esp, 296		; 00000128H
  001bb	3b ec		 cmp	 ebp, esp
  001bd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c2	8b e5		 mov	 esp, ebp
  001c4	5d		 pop	 ebp
  001c5	c3		 ret	 0
  001c6	66 90		 npad	 2
$LN17@initRealbi:
  001c8	01 00 00 00	 DD	 1
  001cc	00 00 00 00	 DD	 $LN16@initRealbi
$LN16@initRealbi:
  001d0	a8 ff ff ff	 DD	 -88			; ffffffa8H
  001d4	50 00 00 00	 DD	 80			; 00000050H
  001d8	00 00 00 00	 DD	 $LN15@initRealbi
$LN15@initRealbi:
  001dc	74		 DB	 116			; 00000074H
  001dd	6d		 DB	 109			; 0000006dH
  001de	70		 DB	 112			; 00000070H
  001df	61		 DB	 97			; 00000061H
  001e0	64		 DB	 100			; 00000064H
  001e1	72		 DB	 114			; 00000072H
  001e2	6e		 DB	 110			; 0000006eH
  001e3	62		 DB	 98			; 00000062H
  001e4	75		 DB	 117			; 00000075H
  001e5	66		 DB	 102			; 00000066H
  001e6	66		 DB	 102			; 00000066H
  001e7	00		 DB	 0
?initRealbinFileOpen@@YAHPAD0@Z ENDP			; initRealbinFileOpen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\loadrealbin.cpp
;	COMDAT ?realGetBitmapNo@@YAHH@Z
_TEXT	SEGMENT
_num$ = 8						; size = 4
?realGetBitmapNo@@YAHH@Z PROC				; realGetBitmapNo, COMDAT

; 363  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 364  : #ifndef _READ16BITBMP
; 365  : 	if (num < 0 || num >= MAX_GRAPHICS) return -1;

  0001e	83 7d 08 00	 cmp	 DWORD PTR _num$[ebp], 0
  00022	7c 09		 jl	 SHORT $LN3@realGetBit
  00024	81 7d 08 40 42
	0f 00		 cmp	 DWORD PTR _num$[ebp], 1000000 ; 000f4240H
  0002b	7c 05		 jl	 SHORT $LN2@realGetBit
$LN3@realGetBit:
  0002d	83 c8 ff	 or	 eax, -1
  00030	eb 0a		 jmp	 SHORT $LN1@realGetBit
$LN2@realGetBit:

; 366  : 	return adrnbuff[num].attr.bmpnumber;

  00032	6b 45 08 50	 imul	 eax, DWORD PTR _num$[ebp], 80
  00036	8b 80 4c 00 00
	00		 mov	 eax, DWORD PTR ?adrnbuff@@3PAUADRNBIN@@A[eax+76]
$LN1@realGetBit:

; 367  : #else
; 368  : 	if (num < 0) return -1;
; 369  : 	if (num >= OLD_GRAPHICS_START) {
; 370  : 		if (num >= MAX_GRAPHICS) return -1;
; 371  : 		return adrntruebuff[num - OLD_GRAPHICS_START].bitmapno;
; 372  : 	}
; 373  : 	else return adrnbuff[num].attr.bmpnumber;
; 374  : #endif
; 375  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?realGetBitmapNo@@YAHH@Z ENDP				; realGetBitmapNo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\loadrealbin.cpp
;	COMDAT ?realGetWalkSoundEffect@@YAHK@Z
_TEXT	SEGMENT
_GraphicNo$ = 8						; size = 4
?realGetWalkSoundEffect@@YAHK@Z PROC			; realGetWalkSoundEffect, COMDAT

; 332  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 333  : 	if (GraphicNo<0 || GraphicNo >= MAX_GRAPHICS) { return FALSE; }

  0001e	83 7d 08 00	 cmp	 DWORD PTR _GraphicNo$[ebp], 0
  00022	72 09		 jb	 SHORT $LN3@realGetWal
  00024	81 7d 08 40 42
	0f 00		 cmp	 DWORD PTR _GraphicNo$[ebp], 1000000 ; 000f4240H
  0002b	72 04		 jb	 SHORT $LN2@realGetWal
$LN3@realGetWal:
  0002d	33 c0		 xor	 eax, eax
  0002f	eb 0b		 jmp	 SHORT $LN1@realGetWal
$LN2@realGetWal:

; 334  : 	return adrnbuff[GraphicNo].attr.effect2;

  00031	6b 45 08 50	 imul	 eax, DWORD PTR _GraphicNo$[ebp], 80
  00035	0f bf 80 42 00
	00 00		 movsx	 eax, WORD PTR ?adrnbuff@@3PAUADRNBIN@@A[eax+66]
$LN1@realGetWal:

; 335  : 
; 336  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?realGetWalkSoundEffect@@YAHK@Z ENDP			; realGetWalkSoundEffect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\loadrealbin.cpp
;	COMDAT ?realGetSoundEffect@@YAHK@Z
_TEXT	SEGMENT
_GraphicNo$ = 8						; size = 4
?realGetSoundEffect@@YAHK@Z PROC			; realGetSoundEffect, COMDAT

; 325  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 326  : 	if (GraphicNo<0 || GraphicNo >= MAX_GRAPHICS)return FALSE;

  0001e	83 7d 08 00	 cmp	 DWORD PTR _GraphicNo$[ebp], 0
  00022	72 09		 jb	 SHORT $LN3@realGetSou
  00024	81 7d 08 40 42
	0f 00		 cmp	 DWORD PTR _GraphicNo$[ebp], 1000000 ; 000f4240H
  0002b	72 04		 jb	 SHORT $LN2@realGetSou
$LN3@realGetSou:
  0002d	33 c0		 xor	 eax, eax
  0002f	eb 12		 jmp	 SHORT $LN1@realGetSou
$LN2@realGetSou:

; 327  : 	return adrnbuff[bitmapnumbertable[GraphicNo]].attr.effect1;

  00031	8b 45 08	 mov	 eax, DWORD PTR _GraphicNo$[ebp]
  00034	6b 0c 85 00 00
	00 00 50	 imul	 ecx, DWORD PTR ?bitmapnumbertable@@3PAKA[eax*4], 80
  0003c	0f bf 81 40 00
	00 00		 movsx	 eax, WORD PTR ?adrnbuff@@3PAUADRNBIN@@A[ecx+64]
$LN1@realGetSou:

; 328  : 
; 329  : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
?realGetSoundEffect@@YAHK@Z ENDP			; realGetSoundEffect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\loadrealbin.cpp
;	COMDAT ?realGetNo@@YAHKPAK@Z
_TEXT	SEGMENT
_CharAction$ = 8					; size = 4
_GraphicNo$ = 12					; size = 4
?realGetNo@@YAHKPAK@Z PROC				; realGetNo, COMDAT

; 339  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 340  : #ifndef _READ16BITBMP
; 341  : 	if (CharAction<0 || CharAction >= MAX_GRAPHICS) { *GraphicNo = 0; return FALSE; }

  0001e	83 7d 08 00	 cmp	 DWORD PTR _CharAction$[ebp], 0
  00022	72 09		 jb	 SHORT $LN3@realGetNo
  00024	81 7d 08 40 42
	0f 00		 cmp	 DWORD PTR _CharAction$[ebp], 1000000 ; 000f4240H
  0002b	72 0d		 jb	 SHORT $LN2@realGetNo
$LN3@realGetNo:
  0002d	8b 45 0c	 mov	 eax, DWORD PTR _GraphicNo$[ebp]
  00030	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00036	33 c0		 xor	 eax, eax
  00038	eb 14		 jmp	 SHORT $LN1@realGetNo
$LN2@realGetNo:

; 342  : 	*GraphicNo = bitmapnumbertable[CharAction];

  0003a	8b 45 0c	 mov	 eax, DWORD PTR _GraphicNo$[ebp]
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _CharAction$[ebp]
  00040	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?bitmapnumbertable@@3PAKA[ecx*4]
  00047	89 10		 mov	 DWORD PTR [eax], edx

; 343  : 	return TRUE;

  00049	b8 01 00 00 00	 mov	 eax, 1
$LN1@realGetNo:

; 344  : #else
; 345  : 	if (CharAction < 0) {
; 346  : 		*GraphicNo = 0;
; 347  : 		return FALSE;
; 348  : 	}
; 349  : 	if (CharAction >= OLD_GRAPHICS_START) {
; 350  : 		if (CharAction >= MAX_GRAPHICS) {
; 351  : 			*GraphicNo = 0;
; 352  : 			return FALSE;
; 353  : 		}
; 354  : 		*GraphicNo = CharAction;
; 355  : 		return TRUE;
; 356  : 	}
; 357  : 	else *GraphicNo = bitmapnumbertable[CharAction];
; 358  : 	return TRUE;
; 359  : #endif
; 360  : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?realGetNo@@YAHKPAK@Z ENDP				; realGetNo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\loadrealbin.cpp
;	COMDAT ?realGetHeightFlag@@YAHKPAF@Z
_TEXT	SEGMENT
_GraphicNo$ = 8						; size = 4
_Height$ = 12						; size = 4
?realGetHeightFlag@@YAHKPAF@Z PROC			; realGetHeightFlag, COMDAT

; 317  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 318  : 	if (GraphicNo<0 || GraphicNo >= MAX_GRAPHICS) { *Height = 0; return FALSE; }

  0001e	83 7d 08 00	 cmp	 DWORD PTR _GraphicNo$[ebp], 0
  00022	72 09		 jb	 SHORT $LN3@realGetHei
  00024	81 7d 08 40 42
	0f 00		 cmp	 DWORD PTR _GraphicNo$[ebp], 1000000 ; 000f4240H
  0002b	72 0c		 jb	 SHORT $LN2@realGetHei
$LN3@realGetHei:
  0002d	33 c0		 xor	 eax, eax
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _Height$[ebp]
  00032	66 89 01	 mov	 WORD PTR [ecx], ax
  00035	33 c0		 xor	 eax, eax
  00037	eb 16		 jmp	 SHORT $LN1@realGetHei
$LN2@realGetHei:

; 319  : 	*Height = adrnbuff[GraphicNo].attr.height;

  00039	6b 45 08 50	 imul	 eax, DWORD PTR _GraphicNo$[ebp], 80
  0003d	8b 4d 0c	 mov	 ecx, DWORD PTR _Height$[ebp]
  00040	66 8b 90 20 00
	00 00		 mov	 dx, WORD PTR ?adrnbuff@@3PAUADRNBIN@@A[eax+32]
  00047	66 89 11	 mov	 WORD PTR [ecx], dx

; 320  : 
; 321  : 	return TRUE;

  0004a	b8 01 00 00 00	 mov	 eax, 1
$LN1@realGetHei:

; 322  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?realGetHeightFlag@@YAHKPAF@Z ENDP			; realGetHeightFlag
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\loadrealbin.cpp
;	COMDAT ?realGetPrioType@@YAHKPAF@Z
_TEXT	SEGMENT
_GraphicNo$ = 8						; size = 4
_prioType$ = 12						; size = 4
?realGetPrioType@@YAHKPAF@Z PROC			; realGetPrioType, COMDAT

; 306  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 307  : 	if (GraphicNo<0 || GraphicNo >= MAX_GRAPHICS) {

  0001e	83 7d 08 00	 cmp	 DWORD PTR _GraphicNo$[ebp], 0
  00022	72 09		 jb	 SHORT $LN3@realGetPri
  00024	81 7d 08 40 42
	0f 00		 cmp	 DWORD PTR _GraphicNo$[ebp], 1000000 ; 000f4240H
  0002b	72 0c		 jb	 SHORT $LN2@realGetPri
$LN3@realGetPri:

; 308  : 		*prioType = 0;

  0002d	33 c0		 xor	 eax, eax
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _prioType$[ebp]
  00032	66 89 01	 mov	 WORD PTR [ecx], ax

; 309  : 		return FALSE;

  00035	33 c0		 xor	 eax, eax
  00037	eb 1e		 jmp	 SHORT $LN1@realGetPri
$LN2@realGetPri:

; 310  : 	}
; 311  : 
; 312  : 	*prioType = (adrnbuff[GraphicNo].attr.hit / 100);

  00039	6b 45 08 50	 imul	 eax, DWORD PTR _GraphicNo$[ebp], 80
  0003d	0f b7 80 1e 00
	00 00		 movzx	 eax, WORD PTR ?adrnbuff@@3PAUADRNBIN@@A[eax+30]
  00044	99		 cdq
  00045	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0004a	f7 f9		 idiv	 ecx
  0004c	8b 55 0c	 mov	 edx, DWORD PTR _prioType$[ebp]
  0004f	66 89 02	 mov	 WORD PTR [edx], ax

; 313  : 	return TRUE;

  00052	b8 01 00 00 00	 mov	 eax, 1
$LN1@realGetPri:

; 314  : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
?realGetPrioType@@YAHKPAF@Z ENDP			; realGetPrioType
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\loadrealbin.cpp
;	COMDAT ?realGetHitFlag@@YAHKPAF@Z
_TEXT	SEGMENT
_GraphicNo$ = 8						; size = 4
_Hit$ = 12						; size = 4
?realGetHitFlag@@YAHKPAF@Z PROC				; realGetHitFlag, COMDAT

; 289  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 290  : 	if (GraphicNo<0 || GraphicNo >= MAX_GRAPHICS) {

  0001e	83 7d 08 00	 cmp	 DWORD PTR _GraphicNo$[ebp], 0
  00022	72 09		 jb	 SHORT $LN3@realGetHit
  00024	81 7d 08 40 42
	0f 00		 cmp	 DWORD PTR _GraphicNo$[ebp], 1000000 ; 000f4240H
  0002b	72 0c		 jb	 SHORT $LN2@realGetHit
$LN3@realGetHit:

; 291  : 		*Hit = 0;

  0002d	33 c0		 xor	 eax, eax
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _Hit$[ebp]
  00032	66 89 01	 mov	 WORD PTR [ecx], ax

; 292  : 		return FALSE;

  00035	33 c0		 xor	 eax, eax
  00037	eb 65		 jmp	 SHORT $LN1@realGetHit
$LN2@realGetHit:

; 293  : 	}
; 294  : 
; 295  : 	if ((GraphicNo >= 369715 && GraphicNo <= 369847) || GraphicNo == 369941)//强制地表可走

  00039	81 7d 08 33 a4
	05 00		 cmp	 DWORD PTR _GraphicNo$[ebp], 369715 ; 0005a433H
  00040	72 09		 jb	 SHORT $LN7@realGetHit
  00042	81 7d 08 b7 a4
	05 00		 cmp	 DWORD PTR _GraphicNo$[ebp], 369847 ; 0005a4b7H
  00049	76 09		 jbe	 SHORT $LN6@realGetHit
$LN7@realGetHit:
  0004b	81 7d 08 15 a5
	05 00		 cmp	 DWORD PTR _GraphicNo$[ebp], 369941 ; 0005a515H
  00052	75 0d		 jne	 SHORT $LN4@realGetHit
$LN6@realGetHit:

; 296  : 		*Hit = 1;

  00054	b8 01 00 00 00	 mov	 eax, 1
  00059	8b 4d 0c	 mov	 ecx, DWORD PTR _Hit$[ebp]
  0005c	66 89 01	 mov	 WORD PTR [ecx], ax
  0005f	eb 38		 jmp	 SHORT $LN5@realGetHit
$LN4@realGetHit:

; 297  : 	else if (GraphicNo >= 369641 && GraphicNo <= 369654)

  00061	81 7d 08 e9 a3
	05 00		 cmp	 DWORD PTR _GraphicNo$[ebp], 369641 ; 0005a3e9H
  00068	72 16		 jb	 SHORT $LN8@realGetHit
  0006a	81 7d 08 f6 a3
	05 00		 cmp	 DWORD PTR _GraphicNo$[ebp], 369654 ; 0005a3f6H
  00071	77 0d		 ja	 SHORT $LN8@realGetHit

; 298  : 		*Hit = 1;

  00073	b8 01 00 00 00	 mov	 eax, 1
  00078	8b 4d 0c	 mov	 ecx, DWORD PTR _Hit$[ebp]
  0007b	66 89 01	 mov	 WORD PTR [ecx], ax

; 299  : 	else

  0007e	eb 19		 jmp	 SHORT $LN5@realGetHit
$LN8@realGetHit:

; 300  : 		*Hit = (adrnbuff[GraphicNo].attr.hit % 100);

  00080	6b 45 08 50	 imul	 eax, DWORD PTR _GraphicNo$[ebp], 80
  00084	0f b7 80 1e 00
	00 00		 movzx	 eax, WORD PTR ?adrnbuff@@3PAUADRNBIN@@A[eax+30]
  0008b	99		 cdq
  0008c	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00091	f7 f9		 idiv	 ecx
  00093	8b 45 0c	 mov	 eax, DWORD PTR _Hit$[ebp]
  00096	66 89 10	 mov	 WORD PTR [eax], dx
$LN5@realGetHit:

; 301  : 
; 302  : 	return TRUE;

  00099	b8 01 00 00 00	 mov	 eax, 1
$LN1@realGetHit:

; 303  : }

  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	5b		 pop	 ebx
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
?realGetHitFlag@@YAHKPAF@Z ENDP				; realGetHitFlag
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\loadrealbin.cpp
;	COMDAT ?realGetHitPoints@@YAHKPAF0@Z
_TEXT	SEGMENT
_GraphicNo$ = 8						; size = 4
_HitX$ = 12						; size = 4
_HitY$ = 16						; size = 4
?realGetHitPoints@@YAHKPAF0@Z PROC			; realGetHitPoints, COMDAT

; 279  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 280  : 	if (GraphicNo<0 || GraphicNo >= MAX_GRAPHICS) { *HitX = 0; *HitY = 0; return FALSE; }

  0001e	83 7d 08 00	 cmp	 DWORD PTR _GraphicNo$[ebp], 0
  00022	72 09		 jb	 SHORT $LN3@realGetHit
  00024	81 7d 08 40 42
	0f 00		 cmp	 DWORD PTR _GraphicNo$[ebp], 1000000 ; 000f4240H
  0002b	72 14		 jb	 SHORT $LN2@realGetHit
$LN3@realGetHit:
  0002d	33 c0		 xor	 eax, eax
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _HitX$[ebp]
  00032	66 89 01	 mov	 WORD PTR [ecx], ax
  00035	33 c0		 xor	 eax, eax
  00037	8b 4d 10	 mov	 ecx, DWORD PTR _HitY$[ebp]
  0003a	66 89 01	 mov	 WORD PTR [ecx], ax
  0003d	33 c0		 xor	 eax, eax
  0003f	eb 29		 jmp	 SHORT $LN1@realGetHit
$LN2@realGetHit:

; 281  : 
; 282  : 	*HitX = adrnbuff[GraphicNo].attr.atari_x;

  00041	6b 45 08 50	 imul	 eax, DWORD PTR _GraphicNo$[ebp], 80
  00045	66 0f b6 88 1c
	00 00 00	 movzx	 cx, BYTE PTR ?adrnbuff@@3PAUADRNBIN@@A[eax+28]
  0004d	8b 55 0c	 mov	 edx, DWORD PTR _HitX$[ebp]
  00050	66 89 0a	 mov	 WORD PTR [edx], cx

; 283  : 	*HitY = adrnbuff[GraphicNo].attr.atari_y;

  00053	6b 45 08 50	 imul	 eax, DWORD PTR _GraphicNo$[ebp], 80
  00057	66 0f b6 88 1d
	00 00 00	 movzx	 cx, BYTE PTR ?adrnbuff@@3PAUADRNBIN@@A[eax+29]
  0005f	8b 55 10	 mov	 edx, DWORD PTR _HitY$[ebp]
  00062	66 89 0a	 mov	 WORD PTR [edx], cx

; 284  : 
; 285  : 	return TRUE;

  00065	b8 01 00 00 00	 mov	 eax, 1
$LN1@realGetHit:

; 286  : }

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
?realGetHitPoints@@YAHKPAF0@Z ENDP			; realGetHitPoints
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\loadrealbin.cpp
;	COMDAT ?realGetWH@@YAHKPAF0@Z
_TEXT	SEGMENT
_GraphicNo$ = 8						; size = 4
_w$ = 12						; size = 4
_h$ = 16						; size = 4
?realGetWH@@YAHKPAF0@Z PROC				; realGetWH, COMDAT

; 257  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 258  : #ifndef _READ16BITBMP
; 259  : 	if (GraphicNo<0 || GraphicNo >= MAX_GRAPHICS) { *w = 0; *h = 0; return FALSE; }

  0001e	83 7d 08 00	 cmp	 DWORD PTR _GraphicNo$[ebp], 0
  00022	72 09		 jb	 SHORT $LN3@realGetWH
  00024	81 7d 08 40 42
	0f 00		 cmp	 DWORD PTR _GraphicNo$[ebp], 1000000 ; 000f4240H
  0002b	72 14		 jb	 SHORT $LN2@realGetWH
$LN3@realGetWH:
  0002d	33 c0		 xor	 eax, eax
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _w$[ebp]
  00032	66 89 01	 mov	 WORD PTR [ecx], ax
  00035	33 c0		 xor	 eax, eax
  00037	8b 4d 10	 mov	 ecx, DWORD PTR _h$[ebp]
  0003a	66 89 01	 mov	 WORD PTR [ecx], ax
  0003d	33 c0		 xor	 eax, eax
  0003f	eb 27		 jmp	 SHORT $LN1@realGetWH
$LN2@realGetWH:

; 260  : 	*w = adrnbuff[GraphicNo].width;

  00041	6b 45 08 50	 imul	 eax, DWORD PTR _GraphicNo$[ebp], 80
  00045	8b 4d 0c	 mov	 ecx, DWORD PTR _w$[ebp]
  00048	66 8b 90 14 00
	00 00		 mov	 dx, WORD PTR ?adrnbuff@@3PAUADRNBIN@@A[eax+20]
  0004f	66 89 11	 mov	 WORD PTR [ecx], dx

; 261  : 	*h = adrnbuff[GraphicNo].height;

  00052	6b 45 08 50	 imul	 eax, DWORD PTR _GraphicNo$[ebp], 80
  00056	8b 4d 10	 mov	 ecx, DWORD PTR _h$[ebp]
  00059	66 8b 90 18 00
	00 00		 mov	 dx, WORD PTR ?adrnbuff@@3PAUADRNBIN@@A[eax+24]
  00060	66 89 11	 mov	 WORD PTR [ecx], dx

; 262  : #else
; 263  : 	if (GraphicNo < 0) { *w = 0; *h = 0; return FALSE; }
; 264  : 	if (GraphicNo >= OLD_GRAPHICS_START) {
; 265  : 		if (GraphicNo > MAX_GRAPHICS) { *w = 0; *h = 0; return FALSE; }
; 266  : 		*w = adrntruebuff[GraphicNo - OLD_GRAPHICS_START].width;
; 267  : 		*h = adrntruebuff[GraphicNo - OLD_GRAPHICS_START].height;
; 268  : 	}
; 269  : 	else {
; 270  : 		*w = adrnbuff[GraphicNo].width;
; 271  : 		*h = adrnbuff[GraphicNo].height;
; 272  : 	}
; 273  : #endif
; 274  : 
; 275  : 	return TRUE;

  00063	b8 01 00 00 00	 mov	 eax, 1
$LN1@realGetWH:

; 276  : }

  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?realGetWH@@YAHKPAF0@Z ENDP				; realGetWH
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\loadrealbin.cpp
;	COMDAT ?realGetPos@@YAHKPAF0@Z
_TEXT	SEGMENT
_GraphicNo$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
?realGetPos@@YAHKPAF0@Z PROC				; realGetPos, COMDAT

; 236  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 237  : #ifndef _READ16BITBMP
; 238  : 	if (GraphicNo<0 || GraphicNo >= MAX_GRAPHICS) { *x = 0; *y = 0; return FALSE; }

  0001e	83 7d 08 00	 cmp	 DWORD PTR _GraphicNo$[ebp], 0
  00022	72 09		 jb	 SHORT $LN3@realGetPos
  00024	81 7d 08 40 42
	0f 00		 cmp	 DWORD PTR _GraphicNo$[ebp], 1000000 ; 000f4240H
  0002b	72 14		 jb	 SHORT $LN2@realGetPos
$LN3@realGetPos:
  0002d	33 c0		 xor	 eax, eax
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  00032	66 89 01	 mov	 WORD PTR [ecx], ax
  00035	33 c0		 xor	 eax, eax
  00037	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  0003a	66 89 01	 mov	 WORD PTR [ecx], ax
  0003d	33 c0		 xor	 eax, eax
  0003f	eb 27		 jmp	 SHORT $LN1@realGetPos
$LN2@realGetPos:

; 239  : 	*x = adrnbuff[GraphicNo].xoffset;

  00041	6b 45 08 50	 imul	 eax, DWORD PTR _GraphicNo$[ebp], 80
  00045	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  00048	66 8b 90 0c 00
	00 00		 mov	 dx, WORD PTR ?adrnbuff@@3PAUADRNBIN@@A[eax+12]
  0004f	66 89 11	 mov	 WORD PTR [ecx], dx

; 240  : 	*y = adrnbuff[GraphicNo].yoffset;

  00052	6b 45 08 50	 imul	 eax, DWORD PTR _GraphicNo$[ebp], 80
  00056	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  00059	66 8b 90 10 00
	00 00		 mov	 dx, WORD PTR ?adrnbuff@@3PAUADRNBIN@@A[eax+16]
  00060	66 89 11	 mov	 WORD PTR [ecx], dx

; 241  : #else
; 242  : 	if (GraphicNo < 0) { *x = 0; *y = 0; return FALSE; }
; 243  : 	if (GraphicNo >= OLD_GRAPHICS_START) {
; 244  : 		if (GraphicNo > MAX_GRAPHICS) { *x = 0; *y = 0; return FALSE; }
; 245  : 		*x = adrntruebuff[GraphicNo - OLD_GRAPHICS_START].xoffset;
; 246  : 		*y = adrntruebuff[GraphicNo - OLD_GRAPHICS_START].yoffset;
; 247  : 	}
; 248  : 	else {
; 249  : 		*x = adrnbuff[GraphicNo].xoffset;
; 250  : 		*y = adrnbuff[GraphicNo].yoffset;
; 251  : 	}
; 252  : #endif
; 253  : 	return TRUE;

  00063	b8 01 00 00 00	 mov	 eax, 1
$LN1@realGetPos:

; 254  : }

  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?realGetPos@@YAHKPAF0@Z ENDP				; realGetPos
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\loadrealbin.cpp
;	COMDAT ?realGetImage@@YAHHPAPAEPAH1@Z
_TEXT	SEGMENT
_len$ = -100						; size = 4
_adrdata$ = -88						; size = 80
__$ArrayPad$ = -4					; size = 4
_graphicNo$ = 8						; size = 4
_bmpdata$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
?realGetImage@@YAHHPAPAEPAH1@Z PROC			; realGetImage, COMDAT

; 385  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd d8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-296]
  00012	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 386  : #ifdef _NEW_COLOR_
; 387  : 	NewColor16Flg = 0;

  00028	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?NewColor16Flg@@3HA, 0 ; NewColor16Flg

; 388  : #endif
; 389  : 	ADRNBIN adrdata;
; 390  : 	if (graphicNo<0 || graphicNo >= MAX_GRAPHICS)return FALSE;

  00032	83 7d 08 00	 cmp	 DWORD PTR _graphicNo$[ebp], 0
  00036	7c 09		 jl	 SHORT $LN3@realGetIma
  00038	81 7d 08 40 42
	0f 00		 cmp	 DWORD PTR _graphicNo$[ebp], 1000000 ; 000f4240H
  0003f	7c 07		 jl	 SHORT $LN2@realGetIma
$LN3@realGetIma:
  00041	33 c0		 xor	 eax, eax
  00043	e9 af 00 00 00	 jmp	 $LN1@realGetIma
$LN2@realGetIma:

; 391  : 	adrdata = adrnbuff[graphicNo];

  00048	6b 75 08 50	 imul	 esi, DWORD PTR _graphicNo$[ebp], 80
  0004c	81 c6 00 00 00
	00		 add	 esi, OFFSET ?adrnbuff@@3PAUADRNBIN@@A ; adrnbuff
  00052	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00057	8d 7d a8	 lea	 edi, DWORD PTR _adrdata$[ebp]
  0005a	f3 a5		 rep movsd

; 392  : #ifdef _PTTERN_SEPARATION_BIN
; 393  : 	if (Realbinfp[graphicNo] == NULL) return FALSE;

  0005c	8b 45 08	 mov	 eax, DWORD PTR _graphicNo$[ebp]
  0005f	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR ?Realbinfp@@3PAPAU_iobuf@@A[eax*4], 0
  00067	75 07		 jne	 SHORT $LN4@realGetIma
  00069	33 c0		 xor	 eax, eax
  0006b	e9 87 00 00 00	 jmp	 $LN1@realGetIma
$LN4@realGetIma:

; 394  : 	fseek(Realbinfp[graphicNo], adrdata.adder, SEEK_SET);

  00070	8b f4		 mov	 esi, esp
  00072	6a 00		 push	 0
  00074	8b 45 ac	 mov	 eax, DWORD PTR _adrdata$[ebp+4]
  00077	50		 push	 eax
  00078	8b 4d 08	 mov	 ecx, DWORD PTR _graphicNo$[ebp]
  0007b	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?Realbinfp@@3PAPAU_iobuf@@A[ecx*4]
  00082	52		 push	 edx
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008c	3b f4		 cmp	 esi, esp
  0008e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 395  : 	if (fread(&g_realgetimagebuf, adrdata.size, 1, Realbinfp[graphicNo]) != 1)

  00093	8b f4		 mov	 esi, esp
  00095	8b 45 08	 mov	 eax, DWORD PTR _graphicNo$[ebp]
  00098	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?Realbinfp@@3PAPAU_iobuf@@A[eax*4]
  0009f	51		 push	 ecx
  000a0	6a 01		 push	 1
  000a2	8b 55 b0	 mov	 edx, DWORD PTR _adrdata$[ebp+8]
  000a5	52		 push	 edx
  000a6	68 00 00 00 00	 push	 OFFSET ?g_realgetimagebuf@@3PAEA ; g_realgetimagebuf
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  000b1	83 c4 10	 add	 esp, 16			; 00000010H
  000b4	3b f4		 cmp	 esi, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bb	83 f8 01	 cmp	 eax, 1
  000be	74 04		 je	 SHORT $LN5@realGetIma

; 396  : 		return FALSE;

  000c0	33 c0		 xor	 eax, eax
  000c2	eb 33		 jmp	 SHORT $LN1@realGetIma
$LN5@realGetIma:

; 397  : #else
; 398  : 	fseek(Realbinfp, adrdata.adder, SEEK_SET);
; 399  : 	if (fread(&g_realgetimagebuf, adrdata.size, 1, Realbinfp) != 1)
; 400  : 		return FALSE;
; 401  : #endif
; 402  : 	unsigned int len;
; 403  : 	*bmpdata = g_realgetimagebuf2;

  000c4	8b 45 0c	 mov	 eax, DWORD PTR _bmpdata$[ebp]
  000c7	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ?g_realgetimagebuf2@@3PAEA ; g_realgetimagebuf2

; 404  : 	if (decoder(g_realgetimagebuf, bmpdata,
; 405  : 		(unsigned int*)width, (unsigned int*)height, &len) == NULL) {

  000cd	8d 45 9c	 lea	 eax, DWORD PTR _len$[ebp]
  000d0	50		 push	 eax
  000d1	8b 4d 14	 mov	 ecx, DWORD PTR _height$[ebp]
  000d4	51		 push	 ecx
  000d5	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  000d8	52		 push	 edx
  000d9	8b 45 0c	 mov	 eax, DWORD PTR _bmpdata$[ebp]
  000dc	50		 push	 eax
  000dd	68 00 00 00 00	 push	 OFFSET ?g_realgetimagebuf@@3PAEA ; g_realgetimagebuf
  000e2	e8 00 00 00 00	 call	 ?decoder@@YAPAEPAEPAPAEPAI22@Z ; decoder
  000e7	83 c4 14	 add	 esp, 20			; 00000014H
  000ea	85 c0		 test	 eax, eax
  000ec	75 04		 jne	 SHORT $LN6@realGetIma

; 406  : 		return FALSE;

  000ee	33 c0		 xor	 eax, eax
  000f0	eb 05		 jmp	 SHORT $LN1@realGetIma
$LN6@realGetIma:

; 407  : 	}
; 408  : 	return TRUE;

  000f2	b8 01 00 00 00	 mov	 eax, 1
$LN1@realGetIma:

; 409  : }

  000f7	52		 push	 edx
  000f8	8b cd		 mov	 ecx, ebp
  000fa	50		 push	 eax
  000fb	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@realGetIma
  00101	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00106	58		 pop	 eax
  00107	5a		 pop	 edx
  00108	5f		 pop	 edi
  00109	5e		 pop	 esi
  0010a	5b		 pop	 ebx
  0010b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010e	33 cd		 xor	 ecx, ebp
  00110	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00115	81 c4 28 01 00
	00		 add	 esp, 296		; 00000128H
  0011b	3b ec		 cmp	 ebp, esp
  0011d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00122	8b e5		 mov	 esp, ebp
  00124	5d		 pop	 ebp
  00125	c3		 ret	 0
  00126	66 90		 npad	 2
$LN11@realGetIma:
  00128	02 00 00 00	 DD	 2
  0012c	00 00 00 00	 DD	 $LN10@realGetIma
$LN10@realGetIma:
  00130	a8 ff ff ff	 DD	 -88			; ffffffa8H
  00134	50 00 00 00	 DD	 80			; 00000050H
  00138	00 00 00 00	 DD	 $LN8@realGetIma
  0013c	9c ff ff ff	 DD	 -100			; ffffff9cH
  00140	04 00 00 00	 DD	 4
  00144	00 00 00 00	 DD	 $LN9@realGetIma
$LN9@realGetIma:
  00148	6c		 DB	 108			; 0000006cH
  00149	65		 DB	 101			; 00000065H
  0014a	6e		 DB	 110			; 0000006eH
  0014b	00		 DB	 0
$LN8@realGetIma:
  0014c	61		 DB	 97			; 00000061H
  0014d	64		 DB	 100			; 00000064H
  0014e	72		 DB	 114			; 00000072H
  0014f	64		 DB	 100			; 00000064H
  00150	61		 DB	 97			; 00000061H
  00151	74		 DB	 116			; 00000074H
  00152	61		 DB	 97			; 00000061H
  00153	00		 DB	 0
?realGetImage@@YAHHPAPAEPAH1@Z ENDP			; realGetImage
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\loadrealbin.cpp
;	COMDAT ?cleanupRealbin@@YAXXZ
_TEXT	SEGMENT
_i$1 = -8						; size = 4
?cleanupRealbin@@YAXXZ PROC				; cleanupRealbin, COMDAT

; 218  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 219  : #ifdef _PTTERN_SEPARATION_BIN
; 220  : 	for (int i = 0; i < MAX_GRAPHICS; i++) {

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00025	eb 09		 jmp	 SHORT $LN4@cleanupRea
$LN2@cleanupRea:
  00027	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0002a	83 c0 01	 add	 eax, 1
  0002d	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@cleanupRea:
  00030	81 7d f8 40 42
	0f 00		 cmp	 DWORD PTR _i$1[ebp], 1000000 ; 000f4240H
  00037	7d 3a		 jge	 SHORT $LN1@cleanupRea

; 221  : 		if (Realbinfp[i] != NULL) {

  00039	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0003c	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR ?Realbinfp@@3PAPAU_iobuf@@A[eax*4], 0
  00044	74 2b		 je	 SHORT $LN5@cleanupRea

; 222  : 			fclose(Realbinfp[i]);

  00046	8b f4		 mov	 esi, esp
  00048	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0004b	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?Realbinfp@@3PAPAU_iobuf@@A[eax*4]
  00052	51		 push	 ecx
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00059	83 c4 04	 add	 esp, 4
  0005c	3b f4		 cmp	 esi, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 223  : 			Realbinfp[i] = NULL;

  00063	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00066	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ?Realbinfp@@3PAPAU_iobuf@@A[eax*4], 0
$LN5@cleanupRea:

; 224  : 		}
; 225  : 	}

  00071	eb b4		 jmp	 SHORT $LN2@cleanupRea
$LN1@cleanupRea:

; 226  : #else
; 227  : 	fclose(Realbinfp);
; 228  : #endif
; 229  : 
; 230  : #ifdef _READ16BITBMP
; 231  : 	CloseHandle(hRealtrueFile);
; 232  : #endif
; 233  : }

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0007c	3b ec		 cmp	 ebp, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
?cleanupRealbin@@YAXXZ ENDP				; cleanupRealbin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\loadrealbin.cpp
;	COMDAT ?readAutoMapColor@@YAHPAD0@Z
_TEXT	SEGMENT
_tmpStr$ = -164						; size = 4
_rAutoMapColorVersion$ = -152				; size = 2
_autoMapColorVersion$ = -140				; size = 2
_rAdrnTime$ = -128					; size = 4
_adrnTime$ = -116					; size = 4
_rAdrnNo$ = -104					; size = 4
_adrnNo$ = -92						; size = 4
_statBuf$ = -80						; size = 48
_rfh$ = -24						; size = 4
_rfp$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_wFName$ = 8						; size = 4
_addrbinfilename$ = 12					; size = 4
?readAutoMapColor@@YAHPAD0@Z PROC			; readAutoMapColor, COMDAT

; 112  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 68 01 00
	00		 sub	 esp, 360		; 00000168H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 98 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-360]
  00012	b9 5a 00 00 00	 mov	 ecx, 90			; 0000005aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 113  : 	FILE *rfp;
; 114  : 	int rfh;
; 115  : 	struct _stat statBuf;
; 116  : 	int adrnNo, rAdrnNo;
; 117  : 	unsigned int adrnTime, rAdrnTime;
; 118  : 	unsigned short autoMapColorVersion = 4, rAutoMapColorVersion;

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	66 89 85 74 ff
	ff ff		 mov	 WORD PTR _autoMapColorVersion$[ebp], ax

; 119  : 	char *tmpStr;
; 120  : 	tmpStr = strstr(addrbinfilename, "adrn");

  00034	68 00 00 00 00	 push	 OFFSET ??_C@_04IFMAMMFM@adrn?$AA@
  00039	8b 45 0c	 mov	 eax, DWORD PTR _addrbinfilename$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ?strstr@@YAPADQADQBD@Z	; strstr
  00042	83 c4 08	 add	 esp, 8
  00045	89 85 5c ff ff
	ff		 mov	 DWORD PTR _tmpStr$[ebp], eax

; 121  : 	if (tmpStr == NULL)

  0004b	83 bd 5c ff ff
	ff 00		 cmp	 DWORD PTR _tmpStr$[ebp], 0
  00052	75 07		 jne	 SHORT $LN2@readAutoMa

; 122  : 		return 0;

  00054	33 c0		 xor	 eax, eax
  00056	e9 a4 02 00 00	 jmp	 $LN1@readAutoMa
$LN2@readAutoMa:

; 123  : 	if (tmpStr[4] == '.')

  0005b	b8 01 00 00 00	 mov	 eax, 1
  00060	c1 e0 02	 shl	 eax, 2
  00063	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _tmpStr$[ebp]
  00069	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  0006d	83 fa 2e	 cmp	 edx, 46			; 0000002eH
  00070	75 09		 jne	 SHORT $LN3@readAutoMa

; 124  : 		adrnNo = 0;

  00072	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _adrnNo$[ebp], 0

; 125  : 	else {

  00079	eb 2c		 jmp	 SHORT $LN4@readAutoMa
$LN3@readAutoMa:

; 126  : 		adrnNo = -1;

  0007b	c7 45 a4 ff ff
	ff ff		 mov	 DWORD PTR _adrnNo$[ebp], -1

; 127  : 		sscanf_s(tmpStr, "adrn_%d.bin", &adrnNo);

  00082	8d 45 a4	 lea	 eax, DWORD PTR _adrnNo$[ebp]
  00085	50		 push	 eax
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_0M@GAINFBKI@adrn_?$CFd?4bin?$AA@
  0008b	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _tmpStr$[ebp]
  00091	51		 push	 ecx
  00092	e8 00 00 00 00	 call	 _sscanf_s
  00097	83 c4 0c	 add	 esp, 12			; 0000000cH

; 128  : 		if (adrnNo < 0)

  0009a	83 7d a4 00	 cmp	 DWORD PTR _adrnNo$[ebp], 0
  0009e	7d 07		 jge	 SHORT $LN4@readAutoMa

; 129  : 			return 0;

  000a0	33 c0		 xor	 eax, eax
  000a2	e9 58 02 00 00	 jmp	 $LN1@readAutoMa
$LN4@readAutoMa:

; 130  : 	}
; 131  : 	if ((rfp = fopen(addrbinfilename, "rb")) == NULL)

  000a7	8b f4		 mov	 esi, esp
  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  000ae	8b 45 0c	 mov	 eax, DWORD PTR _addrbinfilename$[ebp]
  000b1	50		 push	 eax
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  000b8	83 c4 08	 add	 esp, 8
  000bb	3b f4		 cmp	 esi, esp
  000bd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c2	89 45 f4	 mov	 DWORD PTR _rfp$[ebp], eax
  000c5	83 7d f4 00	 cmp	 DWORD PTR _rfp$[ebp], 0
  000c9	75 07		 jne	 SHORT $LN6@readAutoMa

; 132  : 		return 0;

  000cb	33 c0		 xor	 eax, eax
  000cd	e9 2d 02 00 00	 jmp	 $LN1@readAutoMa
$LN6@readAutoMa:

; 133  : 	rfh = _fileno(rfp);

  000d2	8b f4		 mov	 esi, esp
  000d4	8b 45 f4	 mov	 eax, DWORD PTR _rfp$[ebp]
  000d7	50		 push	 eax
  000d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___fileno
  000de	83 c4 04	 add	 esp, 4
  000e1	3b f4		 cmp	 esi, esp
  000e3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e8	89 45 e8	 mov	 DWORD PTR _rfh$[ebp], eax

; 134  : 	if (_fstat(rfh, &statBuf) < 0) {

  000eb	8b f4		 mov	 esi, esp
  000ed	8d 45 b0	 lea	 eax, DWORD PTR _statBuf$[ebp]
  000f0	50		 push	 eax
  000f1	8b 4d e8	 mov	 ecx, DWORD PTR _rfh$[ebp]
  000f4	51		 push	 ecx
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___fstat64i32
  000fb	83 c4 08	 add	 esp, 8
  000fe	3b f4		 cmp	 esi, esp
  00100	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00105	85 c0		 test	 eax, eax
  00107	7d 1d		 jge	 SHORT $LN7@readAutoMa

; 135  : 		fclose(rfp);

  00109	8b f4		 mov	 esi, esp
  0010b	8b 45 f4	 mov	 eax, DWORD PTR _rfp$[ebp]
  0010e	50		 push	 eax
  0010f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00115	83 c4 04	 add	 esp, 4
  00118	3b f4		 cmp	 esi, esp
  0011a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 136  : 		return 0;

  0011f	33 c0		 xor	 eax, eax
  00121	e9 d9 01 00 00	 jmp	 $LN1@readAutoMa
$LN7@readAutoMa:

; 137  : 	}
; 138  : 	adrnTime = (UINT)statBuf.st_ctime;

  00126	8b 45 d8	 mov	 eax, DWORD PTR _statBuf$[ebp+40]
  00129	89 45 8c	 mov	 DWORD PTR _adrnTime$[ebp], eax

; 139  : 	fclose(rfp);

  0012c	8b f4		 mov	 esi, esp
  0012e	8b 45 f4	 mov	 eax, DWORD PTR _rfp$[ebp]
  00131	50		 push	 eax
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00138	83 c4 04	 add	 esp, 4
  0013b	3b f4		 cmp	 esi, esp
  0013d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 140  : 	if ((rfp = fopen(wFName, "rb")) == NULL)

  00142	8b f4		 mov	 esi, esp
  00144	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  00149	8b 45 08	 mov	 eax, DWORD PTR _wFName$[ebp]
  0014c	50		 push	 eax
  0014d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00153	83 c4 08	 add	 esp, 8
  00156	3b f4		 cmp	 esi, esp
  00158	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015d	89 45 f4	 mov	 DWORD PTR _rfp$[ebp], eax
  00160	83 7d f4 00	 cmp	 DWORD PTR _rfp$[ebp], 0
  00164	75 07		 jne	 SHORT $LN8@readAutoMa

; 141  : 		return 0;

  00166	33 c0		 xor	 eax, eax
  00168	e9 92 01 00 00	 jmp	 $LN1@readAutoMa
$LN8@readAutoMa:

; 142  : 
; 143  : 	if (fread(&rAutoMapColorVersion, sizeof(rAutoMapColorVersion), 1, rfp) != 1) {

  0016d	8b f4		 mov	 esi, esp
  0016f	8b 45 f4	 mov	 eax, DWORD PTR _rfp$[ebp]
  00172	50		 push	 eax
  00173	6a 01		 push	 1
  00175	6a 02		 push	 2
  00177	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _rAutoMapColorVersion$[ebp]
  0017d	51		 push	 ecx
  0017e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00184	83 c4 10	 add	 esp, 16			; 00000010H
  00187	3b f4		 cmp	 esi, esp
  00189	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0018e	83 f8 01	 cmp	 eax, 1
  00191	74 1d		 je	 SHORT $LN9@readAutoMa

; 144  : 		fclose(rfp);

  00193	8b f4		 mov	 esi, esp
  00195	8b 45 f4	 mov	 eax, DWORD PTR _rfp$[ebp]
  00198	50		 push	 eax
  00199	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0019f	83 c4 04	 add	 esp, 4
  001a2	3b f4		 cmp	 esi, esp
  001a4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 145  : 		return 0;

  001a9	33 c0		 xor	 eax, eax
  001ab	e9 4f 01 00 00	 jmp	 $LN1@readAutoMa
$LN9@readAutoMa:

; 146  : 	}
; 147  : 	if (autoMapColorVersion != rAutoMapColorVersion) {

  001b0	0f b7 85 74 ff
	ff ff		 movzx	 eax, WORD PTR _autoMapColorVersion$[ebp]
  001b7	0f b7 8d 68 ff
	ff ff		 movzx	 ecx, WORD PTR _rAutoMapColorVersion$[ebp]
  001be	3b c1		 cmp	 eax, ecx
  001c0	74 1d		 je	 SHORT $LN10@readAutoMa

; 148  : 		fclose(rfp);

  001c2	8b f4		 mov	 esi, esp
  001c4	8b 45 f4	 mov	 eax, DWORD PTR _rfp$[ebp]
  001c7	50		 push	 eax
  001c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  001ce	83 c4 04	 add	 esp, 4
  001d1	3b f4		 cmp	 esi, esp
  001d3	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 149  : 		return 0;

  001d8	33 c0		 xor	 eax, eax
  001da	e9 20 01 00 00	 jmp	 $LN1@readAutoMa
$LN10@readAutoMa:

; 150  : 	}
; 151  : 	if (fread(&rAdrnNo, sizeof(rAdrnNo), 1, rfp) != 1) {

  001df	8b f4		 mov	 esi, esp
  001e1	8b 45 f4	 mov	 eax, DWORD PTR _rfp$[ebp]
  001e4	50		 push	 eax
  001e5	6a 01		 push	 1
  001e7	6a 04		 push	 4
  001e9	8d 4d 98	 lea	 ecx, DWORD PTR _rAdrnNo$[ebp]
  001ec	51		 push	 ecx
  001ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  001f3	83 c4 10	 add	 esp, 16			; 00000010H
  001f6	3b f4		 cmp	 esi, esp
  001f8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001fd	83 f8 01	 cmp	 eax, 1
  00200	74 1d		 je	 SHORT $LN11@readAutoMa

; 152  : 		fclose(rfp);

  00202	8b f4		 mov	 esi, esp
  00204	8b 45 f4	 mov	 eax, DWORD PTR _rfp$[ebp]
  00207	50		 push	 eax
  00208	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0020e	83 c4 04	 add	 esp, 4
  00211	3b f4		 cmp	 esi, esp
  00213	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 153  : 		return 0;

  00218	33 c0		 xor	 eax, eax
  0021a	e9 e0 00 00 00	 jmp	 $LN1@readAutoMa
$LN11@readAutoMa:

; 154  : 	}
; 155  : 	if (adrnNo != rAdrnNo) {

  0021f	8b 45 a4	 mov	 eax, DWORD PTR _adrnNo$[ebp]
  00222	3b 45 98	 cmp	 eax, DWORD PTR _rAdrnNo$[ebp]
  00225	74 1d		 je	 SHORT $LN12@readAutoMa

; 156  : 		fclose(rfp);

  00227	8b f4		 mov	 esi, esp
  00229	8b 45 f4	 mov	 eax, DWORD PTR _rfp$[ebp]
  0022c	50		 push	 eax
  0022d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00233	83 c4 04	 add	 esp, 4
  00236	3b f4		 cmp	 esi, esp
  00238	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 157  : 		return 0;

  0023d	33 c0		 xor	 eax, eax
  0023f	e9 bb 00 00 00	 jmp	 $LN1@readAutoMa
$LN12@readAutoMa:

; 158  : 	}
; 159  : 	if (fread(&rAdrnTime, sizeof(rAdrnTime), 1, rfp) != 1) {

  00244	8b f4		 mov	 esi, esp
  00246	8b 45 f4	 mov	 eax, DWORD PTR _rfp$[ebp]
  00249	50		 push	 eax
  0024a	6a 01		 push	 1
  0024c	6a 04		 push	 4
  0024e	8d 4d 80	 lea	 ecx, DWORD PTR _rAdrnTime$[ebp]
  00251	51		 push	 ecx
  00252	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00258	83 c4 10	 add	 esp, 16			; 00000010H
  0025b	3b f4		 cmp	 esi, esp
  0025d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00262	83 f8 01	 cmp	 eax, 1
  00265	74 1a		 je	 SHORT $LN13@readAutoMa

; 160  : 		fclose(rfp);

  00267	8b f4		 mov	 esi, esp
  00269	8b 45 f4	 mov	 eax, DWORD PTR _rfp$[ebp]
  0026c	50		 push	 eax
  0026d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00273	83 c4 04	 add	 esp, 4
  00276	3b f4		 cmp	 esi, esp
  00278	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 161  : 		return 0;

  0027d	33 c0		 xor	 eax, eax
  0027f	eb 7e		 jmp	 SHORT $LN1@readAutoMa
$LN13@readAutoMa:

; 162  : 	}
; 163  : 	if (adrnTime != rAdrnTime) {

  00281	8b 45 8c	 mov	 eax, DWORD PTR _adrnTime$[ebp]
  00284	3b 45 80	 cmp	 eax, DWORD PTR _rAdrnTime$[ebp]
  00287	74 1a		 je	 SHORT $LN14@readAutoMa

; 164  : 		fclose(rfp);

  00289	8b f4		 mov	 esi, esp
  0028b	8b 45 f4	 mov	 eax, DWORD PTR _rfp$[ebp]
  0028e	50		 push	 eax
  0028f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00295	83 c4 04	 add	 esp, 4
  00298	3b f4		 cmp	 esi, esp
  0029a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 165  : 		return 0;

  0029f	33 c0		 xor	 eax, eax
  002a1	eb 5c		 jmp	 SHORT $LN1@readAutoMa
$LN14@readAutoMa:

; 166  : 	}
; 167  : 	if (fread(&autoMapColorTbl, sizeof(autoMapColorTbl), 1, rfp) != 1) {

  002a3	8b f4		 mov	 esi, esp
  002a5	8b 45 f4	 mov	 eax, DWORD PTR _rfp$[ebp]
  002a8	50		 push	 eax
  002a9	6a 01		 push	 1
  002ab	68 40 42 0f 00	 push	 1000000			; 000f4240H
  002b0	68 00 00 00 00	 push	 OFFSET ?autoMapColorTbl@@3PAEA ; autoMapColorTbl
  002b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  002bb	83 c4 10	 add	 esp, 16			; 00000010H
  002be	3b f4		 cmp	 esi, esp
  002c0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002c5	83 f8 01	 cmp	 eax, 1
  002c8	74 1a		 je	 SHORT $LN15@readAutoMa

; 168  : 		fclose(rfp);

  002ca	8b f4		 mov	 esi, esp
  002cc	8b 45 f4	 mov	 eax, DWORD PTR _rfp$[ebp]
  002cf	50		 push	 eax
  002d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  002d6	83 c4 04	 add	 esp, 4
  002d9	3b f4		 cmp	 esi, esp
  002db	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 169  : 		return 0;

  002e0	33 c0		 xor	 eax, eax
  002e2	eb 1b		 jmp	 SHORT $LN1@readAutoMa
$LN15@readAutoMa:

; 170  : 	}
; 171  : 	fclose(rfp);

  002e4	8b f4		 mov	 esi, esp
  002e6	8b 45 f4	 mov	 eax, DWORD PTR _rfp$[ebp]
  002e9	50		 push	 eax
  002ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  002f0	83 c4 04	 add	 esp, 4
  002f3	3b f4		 cmp	 esi, esp
  002f5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 172  : 	return TRUE;

  002fa	b8 01 00 00 00	 mov	 eax, 1
$LN1@readAutoMa:

; 173  : }

  002ff	52		 push	 edx
  00300	8b cd		 mov	 ecx, ebp
  00302	50		 push	 eax
  00303	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN23@readAutoMa
  00309	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0030e	58		 pop	 eax
  0030f	5a		 pop	 edx
  00310	5f		 pop	 edi
  00311	5e		 pop	 esi
  00312	5b		 pop	 ebx
  00313	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00316	33 cd		 xor	 ecx, ebp
  00318	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0031d	81 c4 68 01 00
	00		 add	 esp, 360		; 00000168H
  00323	3b ec		 cmp	 ebp, esp
  00325	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0032a	8b e5		 mov	 esp, ebp
  0032c	5d		 pop	 ebp
  0032d	c3		 ret	 0
  0032e	66 90		 npad	 2
$LN23@readAutoMa:
  00330	05 00 00 00	 DD	 5
  00334	00 00 00 00	 DD	 $LN22@readAutoMa
$LN22@readAutoMa:
  00338	b0 ff ff ff	 DD	 -80			; ffffffb0H
  0033c	30 00 00 00	 DD	 48			; 00000030H
  00340	00 00 00 00	 DD	 $LN17@readAutoMa
  00344	a4 ff ff ff	 DD	 -92			; ffffffa4H
  00348	04 00 00 00	 DD	 4
  0034c	00 00 00 00	 DD	 $LN18@readAutoMa
  00350	98 ff ff ff	 DD	 -104			; ffffff98H
  00354	04 00 00 00	 DD	 4
  00358	00 00 00 00	 DD	 $LN19@readAutoMa
  0035c	80 ff ff ff	 DD	 -128			; ffffff80H
  00360	04 00 00 00	 DD	 4
  00364	00 00 00 00	 DD	 $LN20@readAutoMa
  00368	68 ff ff ff	 DD	 -152			; ffffff68H
  0036c	02 00 00 00	 DD	 2
  00370	00 00 00 00	 DD	 $LN21@readAutoMa
$LN21@readAutoMa:
  00374	72		 DB	 114			; 00000072H
  00375	41		 DB	 65			; 00000041H
  00376	75		 DB	 117			; 00000075H
  00377	74		 DB	 116			; 00000074H
  00378	6f		 DB	 111			; 0000006fH
  00379	4d		 DB	 77			; 0000004dH
  0037a	61		 DB	 97			; 00000061H
  0037b	70		 DB	 112			; 00000070H
  0037c	43		 DB	 67			; 00000043H
  0037d	6f		 DB	 111			; 0000006fH
  0037e	6c		 DB	 108			; 0000006cH
  0037f	6f		 DB	 111			; 0000006fH
  00380	72		 DB	 114			; 00000072H
  00381	56		 DB	 86			; 00000056H
  00382	65		 DB	 101			; 00000065H
  00383	72		 DB	 114			; 00000072H
  00384	73		 DB	 115			; 00000073H
  00385	69		 DB	 105			; 00000069H
  00386	6f		 DB	 111			; 0000006fH
  00387	6e		 DB	 110			; 0000006eH
  00388	00		 DB	 0
$LN20@readAutoMa:
  00389	72		 DB	 114			; 00000072H
  0038a	41		 DB	 65			; 00000041H
  0038b	64		 DB	 100			; 00000064H
  0038c	72		 DB	 114			; 00000072H
  0038d	6e		 DB	 110			; 0000006eH
  0038e	54		 DB	 84			; 00000054H
  0038f	69		 DB	 105			; 00000069H
  00390	6d		 DB	 109			; 0000006dH
  00391	65		 DB	 101			; 00000065H
  00392	00		 DB	 0
$LN19@readAutoMa:
  00393	72		 DB	 114			; 00000072H
  00394	41		 DB	 65			; 00000041H
  00395	64		 DB	 100			; 00000064H
  00396	72		 DB	 114			; 00000072H
  00397	6e		 DB	 110			; 0000006eH
  00398	4e		 DB	 78			; 0000004eH
  00399	6f		 DB	 111			; 0000006fH
  0039a	00		 DB	 0
$LN18@readAutoMa:
  0039b	61		 DB	 97			; 00000061H
  0039c	64		 DB	 100			; 00000064H
  0039d	72		 DB	 114			; 00000072H
  0039e	6e		 DB	 110			; 0000006eH
  0039f	4e		 DB	 78			; 0000004eH
  003a0	6f		 DB	 111			; 0000006fH
  003a1	00		 DB	 0
$LN17@readAutoMa:
  003a2	73		 DB	 115			; 00000073H
  003a3	74		 DB	 116			; 00000074H
  003a4	61		 DB	 97			; 00000061H
  003a5	74		 DB	 116			; 00000074H
  003a6	42		 DB	 66			; 00000042H
  003a7	75		 DB	 117			; 00000075H
  003a8	66		 DB	 102			; 00000066H
  003a9	00		 DB	 0
?readAutoMapColor@@YAHPAD0@Z ENDP			; readAutoMapColor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\loadrealbin.cpp
;	COMDAT ?writeAutoMapColor@@YAHPAD0@Z
_TEXT	SEGMENT
_tmpStr$ = -140						; size = 4
_autoMapColorVersion$ = -128				; size = 2
_adrnTime$ = -116					; size = 4
_adrnNo$ = -104						; size = 4
_statBuf$ = -92						; size = 48
_rfh$ = -36						; size = 4
_rfp$ = -24						; size = 4
_wfp$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_wFName$ = 8						; size = 4
_addrbinfilename$ = 12					; size = 4
?writeAutoMapColor@@YAHPAD0@Z PROC			; writeAutoMapColor, COMDAT

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd b0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-336]
  00012	b9 54 00 00 00	 mov	 ecx, 84			; 00000054H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 73   : 	FILE *wfp, *rfp;
; 74   : 	int rfh;
; 75   : 	struct _stat statBuf;
; 76   : 	int adrnNo;
; 77   : 	unsigned int adrnTime;
; 78   : 	unsigned short autoMapColorVersion = 4;

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	66 89 45 80	 mov	 WORD PTR _autoMapColorVersion$[ebp], ax

; 79   : 	char *tmpStr;
; 80   : 
; 81   : 	tmpStr = strstr(addrbinfilename, "adrn");

  00031	68 00 00 00 00	 push	 OFFSET ??_C@_04IFMAMMFM@adrn?$AA@
  00036	8b 45 0c	 mov	 eax, DWORD PTR _addrbinfilename$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?strstr@@YAPADQADQBD@Z	; strstr
  0003f	83 c4 08	 add	 esp, 8
  00042	89 85 74 ff ff
	ff		 mov	 DWORD PTR _tmpStr$[ebp], eax

; 82   : 	if (tmpStr == NULL)

  00048	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _tmpStr$[ebp], 0
  0004f	75 07		 jne	 SHORT $LN2@writeAutoM

; 83   : 		return 0;

  00051	33 c0		 xor	 eax, eax
  00053	e9 a9 01 00 00	 jmp	 $LN1@writeAutoM
$LN2@writeAutoM:

; 84   : 	if (tmpStr[4] == '.')

  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	c1 e0 02	 shl	 eax, 2
  00060	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _tmpStr$[ebp]
  00066	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  0006a	83 fa 2e	 cmp	 edx, 46			; 0000002eH
  0006d	75 09		 jne	 SHORT $LN3@writeAutoM

; 85   : 		adrnNo = 0;

  0006f	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _adrnNo$[ebp], 0

; 86   : 	else {

  00076	eb 2c		 jmp	 SHORT $LN4@writeAutoM
$LN3@writeAutoM:

; 87   : 		adrnNo = -1;

  00078	c7 45 98 ff ff
	ff ff		 mov	 DWORD PTR _adrnNo$[ebp], -1

; 88   : 		sscanf_s(tmpStr, "adrn_%d.bin", &adrnNo);

  0007f	8d 45 98	 lea	 eax, DWORD PTR _adrnNo$[ebp]
  00082	50		 push	 eax
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0M@GAINFBKI@adrn_?$CFd?4bin?$AA@
  00088	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _tmpStr$[ebp]
  0008e	51		 push	 ecx
  0008f	e8 00 00 00 00	 call	 _sscanf_s
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH

; 89   : 		if (adrnNo < 0)

  00097	83 7d 98 00	 cmp	 DWORD PTR _adrnNo$[ebp], 0
  0009b	7d 07		 jge	 SHORT $LN4@writeAutoM

; 90   : 			return 0;

  0009d	33 c0		 xor	 eax, eax
  0009f	e9 5d 01 00 00	 jmp	 $LN1@writeAutoM
$LN4@writeAutoM:

; 91   : 	}
; 92   : 	if ((rfp = fopen(addrbinfilename, "rb")) == NULL)

  000a4	8b f4		 mov	 esi, esp
  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  000ab	8b 45 0c	 mov	 eax, DWORD PTR _addrbinfilename$[ebp]
  000ae	50		 push	 eax
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  000b5	83 c4 08	 add	 esp, 8
  000b8	3b f4		 cmp	 esi, esp
  000ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bf	89 45 e8	 mov	 DWORD PTR _rfp$[ebp], eax
  000c2	83 7d e8 00	 cmp	 DWORD PTR _rfp$[ebp], 0
  000c6	75 07		 jne	 SHORT $LN6@writeAutoM

; 93   : 		return 0;

  000c8	33 c0		 xor	 eax, eax
  000ca	e9 32 01 00 00	 jmp	 $LN1@writeAutoM
$LN6@writeAutoM:

; 94   : 	rfh = _fileno(rfp);

  000cf	8b f4		 mov	 esi, esp
  000d1	8b 45 e8	 mov	 eax, DWORD PTR _rfp$[ebp]
  000d4	50		 push	 eax
  000d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___fileno
  000db	83 c4 04	 add	 esp, 4
  000de	3b f4		 cmp	 esi, esp
  000e0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e5	89 45 dc	 mov	 DWORD PTR _rfh$[ebp], eax

; 95   : 	if (_fstat(rfh, &statBuf) < 0) {

  000e8	8b f4		 mov	 esi, esp
  000ea	8d 45 a4	 lea	 eax, DWORD PTR _statBuf$[ebp]
  000ed	50		 push	 eax
  000ee	8b 4d dc	 mov	 ecx, DWORD PTR _rfh$[ebp]
  000f1	51		 push	 ecx
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___fstat64i32
  000f8	83 c4 08	 add	 esp, 8
  000fb	3b f4		 cmp	 esi, esp
  000fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00102	85 c0		 test	 eax, eax
  00104	7d 1d		 jge	 SHORT $LN7@writeAutoM

; 96   : 		fclose(rfp);

  00106	8b f4		 mov	 esi, esp
  00108	8b 45 e8	 mov	 eax, DWORD PTR _rfp$[ebp]
  0010b	50		 push	 eax
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00112	83 c4 04	 add	 esp, 4
  00115	3b f4		 cmp	 esi, esp
  00117	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 97   : 		return 0;

  0011c	33 c0		 xor	 eax, eax
  0011e	e9 de 00 00 00	 jmp	 $LN1@writeAutoM
$LN7@writeAutoM:

; 98   : 	}
; 99   : 	adrnTime = (UINT)statBuf.st_ctime;

  00123	8b 45 cc	 mov	 eax, DWORD PTR _statBuf$[ebp+40]
  00126	89 45 8c	 mov	 DWORD PTR _adrnTime$[ebp], eax

; 100  : 	fclose(rfp);

  00129	8b f4		 mov	 esi, esp
  0012b	8b 45 e8	 mov	 eax, DWORD PTR _rfp$[ebp]
  0012e	50		 push	 eax
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00135	83 c4 04	 add	 esp, 4
  00138	3b f4		 cmp	 esi, esp
  0013a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 101  : 	if ((wfp = fopen(wFName, "wb")) == NULL)

  0013f	8b f4		 mov	 esi, esp
  00141	68 00 00 00 00	 push	 OFFSET ??_C@_02GMLFBBN@wb?$AA@
  00146	8b 45 08	 mov	 eax, DWORD PTR _wFName$[ebp]
  00149	50		 push	 eax
  0014a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00150	83 c4 08	 add	 esp, 8
  00153	3b f4		 cmp	 esi, esp
  00155	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015a	89 45 f4	 mov	 DWORD PTR _wfp$[ebp], eax
  0015d	83 7d f4 00	 cmp	 DWORD PTR _wfp$[ebp], 0
  00161	75 07		 jne	 SHORT $LN8@writeAutoM

; 102  : 		return 0;

  00163	33 c0		 xor	 eax, eax
  00165	e9 97 00 00 00	 jmp	 $LN1@writeAutoM
$LN8@writeAutoM:

; 103  : 	fwrite(&autoMapColorVersion, sizeof(autoMapColorVersion), 1, wfp);

  0016a	8b f4		 mov	 esi, esp
  0016c	8b 45 f4	 mov	 eax, DWORD PTR _wfp$[ebp]
  0016f	50		 push	 eax
  00170	6a 01		 push	 1
  00172	6a 02		 push	 2
  00174	8d 4d 80	 lea	 ecx, DWORD PTR _autoMapColorVersion$[ebp]
  00177	51		 push	 ecx
  00178	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  0017e	83 c4 10	 add	 esp, 16			; 00000010H
  00181	3b f4		 cmp	 esi, esp
  00183	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 104  : 	fwrite(&adrnNo, sizeof(adrnNo), 1, wfp);

  00188	8b f4		 mov	 esi, esp
  0018a	8b 45 f4	 mov	 eax, DWORD PTR _wfp$[ebp]
  0018d	50		 push	 eax
  0018e	6a 01		 push	 1
  00190	6a 04		 push	 4
  00192	8d 4d 98	 lea	 ecx, DWORD PTR _adrnNo$[ebp]
  00195	51		 push	 ecx
  00196	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  0019c	83 c4 10	 add	 esp, 16			; 00000010H
  0019f	3b f4		 cmp	 esi, esp
  001a1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 105  : 	fwrite(&adrnTime, sizeof(adrnTime), 1, wfp);

  001a6	8b f4		 mov	 esi, esp
  001a8	8b 45 f4	 mov	 eax, DWORD PTR _wfp$[ebp]
  001ab	50		 push	 eax
  001ac	6a 01		 push	 1
  001ae	6a 04		 push	 4
  001b0	8d 4d 8c	 lea	 ecx, DWORD PTR _adrnTime$[ebp]
  001b3	51		 push	 ecx
  001b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  001ba	83 c4 10	 add	 esp, 16			; 00000010H
  001bd	3b f4		 cmp	 esi, esp
  001bf	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 106  : 	fwrite(&autoMapColorTbl, sizeof(autoMapColorTbl), 1, wfp);

  001c4	8b f4		 mov	 esi, esp
  001c6	8b 45 f4	 mov	 eax, DWORD PTR _wfp$[ebp]
  001c9	50		 push	 eax
  001ca	6a 01		 push	 1
  001cc	68 40 42 0f 00	 push	 1000000			; 000f4240H
  001d1	68 00 00 00 00	 push	 OFFSET ?autoMapColorTbl@@3PAEA ; autoMapColorTbl
  001d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  001dc	83 c4 10	 add	 esp, 16			; 00000010H
  001df	3b f4		 cmp	 esi, esp
  001e1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 107  : 	fclose(wfp);

  001e6	8b f4		 mov	 esi, esp
  001e8	8b 45 f4	 mov	 eax, DWORD PTR _wfp$[ebp]
  001eb	50		 push	 eax
  001ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  001f2	83 c4 04	 add	 esp, 4
  001f5	3b f4		 cmp	 esi, esp
  001f7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 108  : 	return 1;

  001fc	b8 01 00 00 00	 mov	 eax, 1
$LN1@writeAutoM:

; 109  : }

  00201	52		 push	 edx
  00202	8b cd		 mov	 ecx, ebp
  00204	50		 push	 eax
  00205	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@writeAutoM
  0020b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00210	58		 pop	 eax
  00211	5a		 pop	 edx
  00212	5f		 pop	 edi
  00213	5e		 pop	 esi
  00214	5b		 pop	 ebx
  00215	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00218	33 cd		 xor	 ecx, ebp
  0021a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0021f	81 c4 50 01 00
	00		 add	 esp, 336		; 00000150H
  00225	3b ec		 cmp	 ebp, esp
  00227	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0022c	8b e5		 mov	 esp, ebp
  0022e	5d		 pop	 ebp
  0022f	c3		 ret	 0
$LN15@writeAutoM:
  00230	04 00 00 00	 DD	 4
  00234	00 00 00 00	 DD	 $LN14@writeAutoM
$LN14@writeAutoM:
  00238	a4 ff ff ff	 DD	 -92			; ffffffa4H
  0023c	30 00 00 00	 DD	 48			; 00000030H
  00240	00 00 00 00	 DD	 $LN10@writeAutoM
  00244	98 ff ff ff	 DD	 -104			; ffffff98H
  00248	04 00 00 00	 DD	 4
  0024c	00 00 00 00	 DD	 $LN11@writeAutoM
  00250	8c ff ff ff	 DD	 -116			; ffffff8cH
  00254	04 00 00 00	 DD	 4
  00258	00 00 00 00	 DD	 $LN12@writeAutoM
  0025c	80 ff ff ff	 DD	 -128			; ffffff80H
  00260	02 00 00 00	 DD	 2
  00264	00 00 00 00	 DD	 $LN13@writeAutoM
$LN13@writeAutoM:
  00268	61		 DB	 97			; 00000061H
  00269	75		 DB	 117			; 00000075H
  0026a	74		 DB	 116			; 00000074H
  0026b	6f		 DB	 111			; 0000006fH
  0026c	4d		 DB	 77			; 0000004dH
  0026d	61		 DB	 97			; 00000061H
  0026e	70		 DB	 112			; 00000070H
  0026f	43		 DB	 67			; 00000043H
  00270	6f		 DB	 111			; 0000006fH
  00271	6c		 DB	 108			; 0000006cH
  00272	6f		 DB	 111			; 0000006fH
  00273	72		 DB	 114			; 00000072H
  00274	56		 DB	 86			; 00000056H
  00275	65		 DB	 101			; 00000065H
  00276	72		 DB	 114			; 00000072H
  00277	73		 DB	 115			; 00000073H
  00278	69		 DB	 105			; 00000069H
  00279	6f		 DB	 111			; 0000006fH
  0027a	6e		 DB	 110			; 0000006eH
  0027b	00		 DB	 0
$LN12@writeAutoM:
  0027c	61		 DB	 97			; 00000061H
  0027d	64		 DB	 100			; 00000064H
  0027e	72		 DB	 114			; 00000072H
  0027f	6e		 DB	 110			; 0000006eH
  00280	54		 DB	 84			; 00000054H
  00281	69		 DB	 105			; 00000069H
  00282	6d		 DB	 109			; 0000006dH
  00283	65		 DB	 101			; 00000065H
  00284	00		 DB	 0
$LN11@writeAutoM:
  00285	61		 DB	 97			; 00000061H
  00286	64		 DB	 100			; 00000064H
  00287	72		 DB	 114			; 00000072H
  00288	6e		 DB	 110			; 0000006eH
  00289	4e		 DB	 78			; 0000004eH
  0028a	6f		 DB	 111			; 0000006fH
  0028b	00		 DB	 0
$LN10@writeAutoM:
  0028c	73		 DB	 115			; 00000073H
  0028d	74		 DB	 116			; 00000074H
  0028e	61		 DB	 97			; 00000061H
  0028f	74		 DB	 116			; 00000074H
  00290	42		 DB	 66			; 00000042H
  00291	75		 DB	 117			; 00000075H
  00292	66		 DB	 102			; 00000066H
  00293	00		 DB	 0
?writeAutoMapColor@@YAHPAD0@Z ENDP			; writeAutoMapColor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\loadrealbin.cpp
;	COMDAT ?makeAutoMapColor@@YAXXZ
_TEXT	SEGMENT
$T1 = -316						; size = 4
$T2 = -304						; size = 4
_chgTbl$ = -100						; size = 80
_i$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?makeAutoMapColor@@YAXXZ PROC				; makeAutoMapColor, COMDAT

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 40 01 00
	00		 sub	 esp, 320		; 00000140H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd c0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-320]
  00012	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 49   : 	unsigned int i;
; 50   : 	int chgTbl[20] = {
; 51   : 		166,  61,  80, 112,  96, 189, 112,  60, 164, 164,

  00028	c7 45 9c a6 00
	00 00		 mov	 DWORD PTR _chgTbl$[ebp], 166 ; 000000a6H
  0002f	c7 45 a0 3d 00
	00 00		 mov	 DWORD PTR _chgTbl$[ebp+4], 61 ; 0000003dH
  00036	c7 45 a4 50 00
	00 00		 mov	 DWORD PTR _chgTbl$[ebp+8], 80 ; 00000050H
  0003d	c7 45 a8 70 00
	00 00		 mov	 DWORD PTR _chgTbl$[ebp+12], 112 ; 00000070H
  00044	c7 45 ac 60 00
	00 00		 mov	 DWORD PTR _chgTbl$[ebp+16], 96 ; 00000060H
  0004b	c7 45 b0 bd 00
	00 00		 mov	 DWORD PTR _chgTbl$[ebp+20], 189 ; 000000bdH
  00052	c7 45 b4 70 00
	00 00		 mov	 DWORD PTR _chgTbl$[ebp+24], 112 ; 00000070H
  00059	c7 45 b8 3c 00
	00 00		 mov	 DWORD PTR _chgTbl$[ebp+28], 60 ; 0000003cH
  00060	c7 45 bc a4 00
	00 00		 mov	 DWORD PTR _chgTbl$[ebp+32], 164 ; 000000a4H
  00067	c7 45 c0 a4 00
	00 00		 mov	 DWORD PTR _chgTbl$[ebp+36], 164 ; 000000a4H

; 52   : 		111,   0,   0,   0,   0,   0,   0,   0,   0,   0 };

  0006e	c7 45 c4 6f 00
	00 00		 mov	 DWORD PTR _chgTbl$[ebp+40], 111 ; 0000006fH
  00075	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _chgTbl$[ebp+44], 0
  0007c	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _chgTbl$[ebp+48], 0
  00083	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _chgTbl$[ebp+52], 0
  0008a	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _chgTbl$[ebp+56], 0
  00091	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _chgTbl$[ebp+60], 0
  00098	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _chgTbl$[ebp+64], 0
  0009f	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _chgTbl$[ebp+68], 0
  000a6	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _chgTbl$[ebp+72], 0
  000ad	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _chgTbl$[ebp+76], 0

; 53   : 	for (i = 0; i < MAX_GRAPHICS; i++) {

  000b4	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000bb	eb 09		 jmp	 SHORT $LN4@makeAutoMa
$LN2@makeAutoMa:
  000bd	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000c0	83 c0 01	 add	 eax, 1
  000c3	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@makeAutoMa:
  000c6	81 7d f4 40 42
	0f 00		 cmp	 DWORD PTR _i$[ebp], 1000000 ; 000f4240H
  000cd	0f 83 f7 00 00
	00		 jae	 $LN11@makeAutoMa

; 54   : 		if (adrnbuff[i].attr.bmpnumber != 0) {

  000d3	6b 45 f4 50	 imul	 eax, DWORD PTR _i$[ebp], 80
  000d7	83 b8 4c 00 00
	00 00		 cmp	 DWORD PTR ?adrnbuff@@3PAUADRNBIN@@A[eax+76], 0
  000de	0f 84 b1 00 00
	00		 je	 $LN5@makeAutoMa

; 55   : 			if (100 <= adrnbuff[i].attr.bmpnumber && adrnbuff[i].attr.bmpnumber <= 19999) {

  000e4	6b 45 f4 50	 imul	 eax, DWORD PTR _i$[ebp], 80
  000e8	83 b8 4c 00 00
	00 64		 cmp	 DWORD PTR ?adrnbuff@@3PAUADRNBIN@@A[eax+76], 100 ; 00000064H
  000ef	72 35		 jb	 SHORT $LN7@makeAutoMa
  000f1	6b 45 f4 50	 imul	 eax, DWORD PTR _i$[ebp], 80
  000f5	81 b8 4c 00 00
	00 1f 4e 00 00	 cmp	 DWORD PTR ?adrnbuff@@3PAUADRNBIN@@A[eax+76], 19999 ; 00004e1fH
  000ff	77 25		 ja	 SHORT $LN7@makeAutoMa

; 56   : 				autoMapColorTbl[adrnbuff[i].attr.bmpnumber] = getAutoMapColor(adrnbuff[i].bitmapno);

  00101	6b 45 f4 50	 imul	 eax, DWORD PTR _i$[ebp], 80
  00105	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?adrnbuff@@3PAUADRNBIN@@A[eax]
  0010b	51		 push	 ecx
  0010c	e8 00 00 00 00	 call	 ?getAutoMapColor@@YAHI@Z ; getAutoMapColor
  00111	83 c4 04	 add	 esp, 4
  00114	6b 55 f4 50	 imul	 edx, DWORD PTR _i$[ebp], 80
  00118	8b 8a 4c 00 00
	00		 mov	 ecx, DWORD PTR ?adrnbuff@@3PAUADRNBIN@@A[edx+76]
  0011e	88 81 00 00 00
	00		 mov	 BYTE PTR ?autoMapColorTbl@@3PAEA[ecx], al
  00124	eb 6d		 jmp	 SHORT $LN8@makeAutoMa
$LN7@makeAutoMa:

; 57   : 			}
; 58   : 			else if (60 <= adrnbuff[i].attr.bmpnumber && adrnbuff[i].attr.bmpnumber <= 79) {

  00126	6b 45 f4 50	 imul	 eax, DWORD PTR _i$[ebp], 80
  0012a	83 b8 4c 00 00
	00 3c		 cmp	 DWORD PTR ?adrnbuff@@3PAUADRNBIN@@A[eax+76], 60 ; 0000003cH
  00131	72 30		 jb	 SHORT $LN9@makeAutoMa
  00133	6b 45 f4 50	 imul	 eax, DWORD PTR _i$[ebp], 80
  00137	83 b8 4c 00 00
	00 4f		 cmp	 DWORD PTR ?adrnbuff@@3PAUADRNBIN@@A[eax+76], 79 ; 0000004fH
  0013e	77 23		 ja	 SHORT $LN9@makeAutoMa

; 59   : 				autoMapColorTbl[adrnbuff[i].attr.bmpnumber] = (unsigned char)chgTbl[adrnbuff[i].attr.bmpnumber - 60];

  00140	6b 45 f4 50	 imul	 eax, DWORD PTR _i$[ebp], 80
  00144	8b 88 4c 00 00
	00		 mov	 ecx, DWORD PTR ?adrnbuff@@3PAUADRNBIN@@A[eax+76]
  0014a	6b 55 f4 50	 imul	 edx, DWORD PTR _i$[ebp], 80
  0014e	8b 82 4c 00 00
	00		 mov	 eax, DWORD PTR ?adrnbuff@@3PAUADRNBIN@@A[edx+76]
  00154	8a 8c 8d ac fe
	ff ff		 mov	 cl, BYTE PTR _chgTbl$[ebp+ecx*4-240]
  0015b	88 88 00 00 00
	00		 mov	 BYTE PTR ?autoMapColorTbl@@3PAEA[eax], cl

; 60   : 			}
; 61   : 			else {

  00161	eb 30		 jmp	 SHORT $LN8@makeAutoMa
$LN9@makeAutoMa:

; 62   : 				autoMapColorTbl[adrnbuff[i].attr.bmpnumber] = 0;

  00163	6b 45 f4 50	 imul	 eax, DWORD PTR _i$[ebp], 80
  00167	8b 88 4c 00 00
	00		 mov	 ecx, DWORD PTR ?adrnbuff@@3PAUADRNBIN@@A[eax+76]
  0016d	89 8d d0 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  00173	81 bd d0 fe ff
	ff 40 42 0f 00	 cmp	 DWORD PTR $T2[ebp], 1000000 ; 000f4240H
  0017d	73 02		 jae	 SHORT $LN12@makeAutoMa
  0017f	eb 05		 jmp	 SHORT $LN13@makeAutoMa
$LN12@makeAutoMa:
  00181	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN13@makeAutoMa:
  00186	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR $T2[ebp]
  0018c	c6 82 00 00 00
	00 00		 mov	 BYTE PTR ?autoMapColorTbl@@3PAEA[edx], 0
$LN8@makeAutoMa:

; 63   : 			}
; 64   : 		}
; 65   : 		else {

  00193	eb 30		 jmp	 SHORT $LN6@makeAutoMa
$LN5@makeAutoMa:

; 66   : 			autoMapColorTbl[adrnbuff[i].attr.bmpnumber] = 0;

  00195	6b 45 f4 50	 imul	 eax, DWORD PTR _i$[ebp], 80
  00199	8b 88 4c 00 00
	00		 mov	 ecx, DWORD PTR ?adrnbuff@@3PAUADRNBIN@@A[eax+76]
  0019f	89 8d c4 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  001a5	81 bd c4 fe ff
	ff 40 42 0f 00	 cmp	 DWORD PTR $T1[ebp], 1000000 ; 000f4240H
  001af	73 02		 jae	 SHORT $LN14@makeAutoMa
  001b1	eb 05		 jmp	 SHORT $LN15@makeAutoMa
$LN14@makeAutoMa:
  001b3	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN15@makeAutoMa:
  001b8	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  001be	c6 82 00 00 00
	00 00		 mov	 BYTE PTR ?autoMapColorTbl@@3PAEA[edx], 0
$LN6@makeAutoMa:

; 67   : 		}
; 68   : 	}

  001c5	e9 f3 fe ff ff	 jmp	 $LN2@makeAutoMa
$LN11@makeAutoMa:

; 69   : }

  001ca	52		 push	 edx
  001cb	8b cd		 mov	 ecx, ebp
  001cd	50		 push	 eax
  001ce	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN18@makeAutoMa
  001d4	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001d9	58		 pop	 eax
  001da	5a		 pop	 edx
  001db	5f		 pop	 edi
  001dc	5e		 pop	 esi
  001dd	5b		 pop	 ebx
  001de	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e1	33 cd		 xor	 ecx, ebp
  001e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e8	81 c4 40 01 00
	00		 add	 esp, 320		; 00000140H
  001ee	3b ec		 cmp	 ebp, esp
  001f0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f5	8b e5		 mov	 esp, ebp
  001f7	5d		 pop	 ebp
  001f8	c3		 ret	 0
  001f9	0f 1f 00	 npad	 3
$LN18@makeAutoMa:
  001fc	01 00 00 00	 DD	 1
  00200	00 00 00 00	 DD	 $LN17@makeAutoMa
$LN17@makeAutoMa:
  00204	9c ff ff ff	 DD	 -100			; ffffff9cH
  00208	50 00 00 00	 DD	 80			; 00000050H
  0020c	00 00 00 00	 DD	 $LN16@makeAutoMa
$LN16@makeAutoMa:
  00210	63		 DB	 99			; 00000063H
  00211	68		 DB	 104			; 00000068H
  00212	67		 DB	 103			; 00000067H
  00213	54		 DB	 84			; 00000054H
  00214	62		 DB	 98			; 00000062H
  00215	6c		 DB	 108			; 0000006cH
  00216	00		 DB	 0
?makeAutoMapColor@@YAXXZ ENDP				; makeAutoMapColor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\loadrealbin.cpp
;	COMDAT ?initAutoMapColor@@YAXPAD@Z
_TEXT	SEGMENT
_filename$ = -8						; size = 4
_addrbinfilename$ = 8					; size = 4
?initAutoMapColor@@YAXPAD@Z PROC			; initAutoMapColor, COMDAT

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 40   : 	char *filename = "data\\auto.dat";

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _filename$[ebp], OFFSET ??_C@_0O@PLLALPBE@data?2auto?4dat?$AA@

; 41   : 	if (readAutoMapColor(filename, addrbinfilename) == 0) {

  00025	8b 45 08	 mov	 eax, DWORD PTR _addrbinfilename$[ebp]
  00028	50		 push	 eax
  00029	8b 4d f8	 mov	 ecx, DWORD PTR _filename$[ebp]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ?readAutoMapColor@@YAHPAD0@Z ; readAutoMapColor
  00032	83 c4 08	 add	 esp, 8
  00035	85 c0		 test	 eax, eax
  00037	75 15		 jne	 SHORT $LN1@initAutoMa

; 42   : 		makeAutoMapColor();

  00039	e8 00 00 00 00	 call	 ?makeAutoMapColor@@YAXXZ ; makeAutoMapColor

; 43   : 		writeAutoMapColor(filename, addrbinfilename);

  0003e	8b 45 08	 mov	 eax, DWORD PTR _addrbinfilename$[ebp]
  00041	50		 push	 eax
  00042	8b 4d f8	 mov	 ecx, DWORD PTR _filename$[ebp]
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 ?writeAutoMapColor@@YAHPAD0@Z ; writeAutoMapColor
  0004b	83 c4 08	 add	 esp, 8
$LN1@initAutoMa:

; 44   : 	}
; 45   : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00057	3b ec		 cmp	 ebp, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
?initAutoMapColor@@YAXPAD@Z ENDP			; initAutoMapColor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sscanf_s
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sscanf_s PROC						; COMDAT

; 2300 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2301 :         int _Result;
; 2302 :         va_list _ArgList;
; 2303 :         __crt_va_start(_ArgList, _Format);

  0001e	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
  00023	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00026	89 45 ec	 mov	 DWORD PTR __ArgList$[ebp], eax

; 2304 : 
; 2305 :         #pragma warning(push)
; 2306 :         #pragma warning(disable: 4996) // Deprecation
; 2307 :         _Result = vsscanf_s(_Buffer, _Format, _ArgList);

  00029	8b 45 ec	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00030	51		 push	 ecx
  00031	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 _vsscanf_s
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003d	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 2308 :         #pragma warning(pop)
; 2309 : 
; 2310 :         __crt_va_end(_ArgList);

  00040	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 2311 :         return _Result;

  00047	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 2312 :     }

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_sscanf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsscanf_s
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__ArgList$ = 16						; size = 4
_vsscanf_s PROC						; COMDAT

; 2218 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2219 :         return _vsscanf_s_l(_Buffer, _Format, NULL, _ArgList);

  0001e	8b 45 10	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00021	50		 push	 eax
  00022	6a 00		 push	 0
  00024	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 __vsscanf_s_l
  00031	83 c4 10	 add	 esp, 16			; 00000010H

; 2220 :     }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_vsscanf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsscanf_s_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsscanf_s_l PROC					; COMDAT

; 2197 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2198 :     return __stdio_common_vsscanf(

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  0002b	52		 push	 edx
  0002c	6a ff		 push	 -1
  0002e	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ___local_stdio_scanf_options
  00037	8b 08		 mov	 ecx, DWORD PTR [eax]
  00039	83 c9 01	 or	 ecx, 1
  0003c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003f	52		 push	 edx
  00040	51		 push	 ecx
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsscanf
  00047	83 c4 1c	 add	 esp, 28			; 0000001cH
  0004a	3b f4		 cmp	 esi, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2199 :         _CRT_INTERNAL_LOCAL_SCANF_OPTIONS | _CRT_INTERNAL_SCANF_SECURECRT,
; 2200 :         _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2201 : }

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
__vsscanf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 144  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT

; 82   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 83   :     static unsigned __int64 _OptionsStorage;
; 84   :     return &_OptionsStorage;

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 85   : }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
;	COMDAT ?strstr@@YAPADQADQBD@Z
_TEXT	SEGMENT
__String$ = 8						; size = 4
__SubString$ = 12					; size = 4
?strstr@@YAPADQADQBD@Z PROC				; strstr, COMDAT

; 536  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 537  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 0c	 mov	 eax, DWORD PTR __SubString$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR __String$[ebp]
  00027	51		 push	 ecx
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strstr
  0002e	83 c4 08	 add	 esp, 8
  00031	3b f4		 cmp	 esi, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 538  :     }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?strstr@@YAPADQADQBD@Z ENDP				; strstr
_TEXT	ENDS
END
