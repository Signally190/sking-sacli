; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Administrator\Desktop\????? ??\????? ??\Client Source Code\NewProto\autil.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?MesgSlice@@3PAPADA				; MesgSlice
PUBLIC	?SliceCount@@3HA				; SliceCount
PUBLIC	?PersonalKey@@3PADA				; PersonalKey
PUBLIC	?wmstr@@3PAUWM_STR@@A				; wmstr
_BSS	SEGMENT
?MesgSlice@@3PAPADA DD 01H DUP (?)			; MesgSlice
?SliceCount@@3HA DD 01H DUP (?)				; SliceCount
?PersonalKey@@3PADA DB 020H DUP (?)			; PersonalKey
?wmstr@@3PAUWM_STR@@A DB 019a8cH DUP (?)		; wmstr
_BSS	ENDS
PUBLIC	?strstr@@YAPADQADQBD@Z				; strstr
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	?util_Init@@YAXXZ				; util_Init
PUBLIC	?util_Release@@YAXXZ				; util_Release
PUBLIC	?util_SplitMessage@@YAXPAD0@Z			; util_SplitMessage
PUBLIC	?util_EncodeMessage@@YAXPAD0@Z			; util_EncodeMessage
PUBLIC	?util_DecodeMessage@@YAXPAD0@Z			; util_DecodeMessage
PUBLIC	?util_GetFunctionFromSlice@@YAHPAH0@Z		; util_GetFunctionFromSlice
PUBLIC	?util_DiscardMessage@@YAXXZ			; util_DiscardMessage
PUBLIC	?util_SendMesg@@YAXHHPAD@Z			; util_SendMesg
PUBLIC	?util_256to64@@YAHPAD0H0@Z			; util_256to64
PUBLIC	?util_64to256@@YAHPAD00@Z			; util_64to256
PUBLIC	?util_256to64_shr@@YAHPAD0H00@Z			; util_256to64_shr
PUBLIC	?util_shl_64to256@@YAHPAD000@Z			; util_shl_64to256
PUBLIC	?util_256to64_shl@@YAHPAD0H00@Z			; util_256to64_shl
PUBLIC	?util_shr_64to256@@YAHPAD000@Z			; util_shr_64to256
PUBLIC	?util_swapint@@YAXPAH0PAD@Z			; util_swapint
PUBLIC	?util_xorstring@@YAXPAD0@Z			; util_xorstring
PUBLIC	?util_shrstring@@YAXPAD0H@Z			; util_shrstring
PUBLIC	?util_shlstring@@YAXPAD0H@Z			; util_shlstring
PUBLIC	?util_deint@@YAHHPAH@Z				; util_deint
PUBLIC	?util_mkint@@YAHPADH@Z				; util_mkint
PUBLIC	?util_destring@@YAHHPAD@Z			; util_destring
PUBLIC	?util_mkstring@@YAHPAD0@Z			; util_mkstring
PUBLIC	?getStrSplitNew@@YAXQAY0BAA@D@Z			; getStrSplitNew
PUBLIC	?PutWinText@@YAXHHDHPADHH@Z			; PutWinText
PUBLIC	?strcmptail@@YAHPAD0@Z				; strcmptail
PUBLIC	?getStringFromIndexWithDelim_body@@YAHPAD0H0H@Z	; getStringFromIndexWithDelim_body
PUBLIC	?ltrim@@YAXPAD@Z				; ltrim
PUBLIC	?rtrim@@YAXPAD@Z				; rtrim
PUBLIC	?getstrstyle@@YAXPADHHHQAUWM_STR@@@Z		; getstrstyle
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_04EMLHGGGF@2413?$AA@			; `string'
PUBLIC	??_C@_0EB@CPNIKEEC@0123456789ABCDEFGHIJKLMNOPQRSTUV@ ; `string'
PUBLIC	??_C@_04FJNJEMEN@3142?$AA@			; `string'
PUBLIC	??_C@_01IPJKGB@?$CD?$AA@			; `string'
PUBLIC	??_C@_09PELNNIGO@?$CG?$DL?$CFd?$CFs?$DL?$CD?$DL?$AA@ ; `string'
PUBLIC	??_C@_01ICJEACDI@?$DL?$AA@			; `string'
PUBLIC	??_C@_07IBAIKNAL@?$FLstyle?5?$AA@		; `string'
PUBLIC	??_C@_01LBDDMOBJ@?$FN?$AA@			; `string'
PUBLIC	??_C@_02CAMHBLCK@c?$DN?$AA@			; `string'
PUBLIC	??_C@_02DMOBLIFK@s?$DN?$AA@			; `string'
PUBLIC	??_C@_08EAKPCBLG@?$FL?1style?$FN?$AA@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__strstr:PROC
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__strncat:PROC
EXTRN	__imp__strncpy:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__rand:PROC
EXTRN	__imp__atoi:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	?JL_combineInt_RECV@@YAXHH@Z:PROC		; JL_combineInt_RECV
EXTRN	?JL_combineString_RECV@@YAXPADH@Z:PROC		; JL_combineString_RECV
EXTRN	?JL_combineInt_SEND@@YAXH@Z:PROC		; JL_combineInt_SEND
EXTRN	?JL_combineString_SEND@@YAXPADH@Z:PROC		; JL_combineString_SEND
EXTRN	?JL_combinePacket_SEND@@YAXHH@Z:PROC		; JL_combinePacket_SEND
EXTRN	?GBK2GB@@YIXPAD@Z:PROC				; GBK2GB
EXTRN	?BIG52GBK@@YIXPAD@Z:PROC			; BIG52GBK
EXTRN	?sunday@@YAPADPAD0@Z:PROC			; sunday
EXTRN	?StockFontBufferExt@@YAHHHDHPADHH@Z:PROC	; StockFontBufferExt
EXTRN	?lssproto_Send@@YAXHPAD@Z:PROC			; lssproto_Send
EXTRN	?ScanOneByte@@YAPADPADD@Z:PROC			; ScanOneByte
EXTRN	?strcpysafe@@YAXPADIPBD@Z:PROC			; strcpysafe
EXTRN	?strncpysafe@@YAXPADIPBDH@Z:PROC		; strncpysafe
EXTRN	?getTextLength@@YAHPAD@Z:PROC			; getTextLength
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__chkstk:PROC
EXTRN	?g_服务器@@3HA:DWORD				; g_服务器
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EAKPCBLG@?$FL?1style?$FN?$AA@
CONST	SEGMENT
??_C@_08EAKPCBLG@?$FL?1style?$FN?$AA@ DB '[/style]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DMOBLIFK@s?$DN?$AA@
CONST	SEGMENT
??_C@_02DMOBLIFK@s?$DN?$AA@ DB 's=', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02CAMHBLCK@c?$DN?$AA@
CONST	SEGMENT
??_C@_02CAMHBLCK@c?$DN?$AA@ DB 'c=', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01LBDDMOBJ@?$FN?$AA@
CONST	SEGMENT
??_C@_01LBDDMOBJ@?$FN?$AA@ DB ']', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07IBAIKNAL@?$FLstyle?5?$AA@
CONST	SEGMENT
??_C@_07IBAIKNAL@?$FLstyle?5?$AA@ DB '[style ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01ICJEACDI@?$DL?$AA@
CONST	SEGMENT
??_C@_01ICJEACDI@?$DL?$AA@ DB ';', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09PELNNIGO@?$CG?$DL?$CFd?$CFs?$DL?$CD?$DL?$AA@
CONST	SEGMENT
??_C@_09PELNNIGO@?$CG?$DL?$CFd?$CFs?$DL?$CD?$DL?$AA@ DB '&;%d%s;#;', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01IPJKGB@?$CD?$AA@
CONST	SEGMENT
??_C@_01IPJKGB@?$CD?$AA@ DB '#', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FJNJEMEN@3142?$AA@
CONST	SEGMENT
??_C@_04FJNJEMEN@3142?$AA@ DB '3142', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@CPNIKEEC@0123456789ABCDEFGHIJKLMNOPQRSTUV@
CONST	SEGMENT
??_C@_0EB@CPNIKEEC@0123456789ABCDEFGHIJKLMNOPQRSTUV@ DB '0123456789ABCDEF'
	DB	'GHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz{}', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04EMLHGGGF@2413?$AA@
CONST	SEGMENT
??_C@_04EMLHGGGF@2413?$AA@ DB '2413', 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?getstrstyle@@YAXPADHHHQAUWM_STR@@@Z
_TEXT	SEGMENT
$T1 = -332						; size = 4
$T2 = -320						; size = 4
_len$3 = -116						; size = 4
_i$4 = -104						; size = 4
_strsize$5 = -92					; size = 3
_ssize$6 = -80						; size = 4
_i$7 = -68						; size = 4
_strnum$8 = -56						; size = 3
_scolor$9 = -44						; size = 4
_len$10 = -32						; size = 4
_etemp$ = -20						; size = 4
_stemp$ = -8						; size = 4
_str$ = 8						; size = 4
_index$ = 12						; size = 4
_pos$ = 16						; size = 4
_flg$ = 20						; size = 4
_wm$ = 24						; size = 4
?getstrstyle@@YAXPADHHHQAUWM_STR@@@Z PROC		; getstrstyle, COMDAT

; 577  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd b0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-336]
  00012	b9 54 00 00 00	 mov	 ecx, 84			; 00000054H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 578  : 	char *stemp, *etemp;
; 579  : 	if (flg)

  0001e	83 7d 14 00	 cmp	 DWORD PTR _flg$[ebp], 0
  00022	74 08		 je	 SHORT $LN8@getstrstyl

; 580  : 		stemp = str;

  00024	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00027	89 45 f8	 mov	 DWORD PTR _stemp$[ebp], eax

; 581  : 	else

  0002a	eb 14		 jmp	 SHORT $LN9@getstrstyl
$LN8@getstrstyl:

; 582  : 		stemp = sunday(str, "[style ");

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_07IBAIKNAL@?$FLstyle?5?$AA@
  00031	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ?sunday@@YAPADPAD0@Z	; sunday
  0003a	83 c4 08	 add	 esp, 8
  0003d	89 45 f8	 mov	 DWORD PTR _stemp$[ebp], eax
$LN9@getstrstyl:

; 583  : 	if (stemp) {

  00040	83 7d f8 00	 cmp	 DWORD PTR _stemp$[ebp], 0
  00044	0f 84 17 04 00
	00		 je	 $LN10@getstrstyl

; 584  : 		if (stemp != str) {

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _stemp$[ebp]
  0004d	3b 45 08	 cmp	 eax, DWORD PTR _str$[ebp]
  00050	0f 84 2a 01 00
	00		 je	 $LN12@getstrstyl

; 585  : 			wm[index].flg = TRUE;

  00056	69 45 0c 6c 10
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 4204
  0005d	8b 4d 18	 mov	 ecx, DWORD PTR _wm$[ebp]
  00060	c7 04 01 01 00
	00 00		 mov	 DWORD PTR [ecx+eax], 1

; 586  : 			wm[index].style[pos].size = FONT_SIZE1;

  00067	69 45 0c 6c 10
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 4204
  0006e	03 45 18	 add	 eax, DWORD PTR _wm$[ebp]
  00071	69 4d 10 8c 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 140
  00078	c7 44 08 08 0e
	00 00 00	 mov	 DWORD PTR [eax+ecx+8], 14 ; 0000000eH

; 587  : 			if (pos == 0)

  00080	83 7d 10 00	 cmp	 DWORD PTR _pos$[ebp], 0
  00084	75 1b		 jne	 SHORT $LN14@getstrstyl

; 588  : 				wm[index].style[pos].x = 0;

  00086	69 45 0c 6c 10
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 4204
  0008d	03 45 18	 add	 eax, DWORD PTR _wm$[ebp]
  00090	69 4d 10 8c 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 140
  00097	c7 44 08 04 00
	00 00 00	 mov	 DWORD PTR [eax+ecx+4], 0

; 589  : 			else

  0009f	eb 52		 jmp	 SHORT $LN15@getstrstyl
$LN14@getstrstyl:

; 590  : 				wm[index].style[pos].x = getTextLength(wm[index].style[pos - 1].str) + wm[index].style[pos - 1].x;

  000a1	69 45 0c 6c 10
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 4204
  000a8	03 45 18	 add	 eax, DWORD PTR _wm$[ebp]
  000ab	8b 4d 10	 mov	 ecx, DWORD PTR _pos$[ebp]
  000ae	83 e9 01	 sub	 ecx, 1
  000b1	69 d1 8c 00 00
	00		 imul	 edx, ecx, 140
  000b7	8d 44 10 10	 lea	 eax, DWORD PTR [eax+edx+16]
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 ?getTextLength@@YAHPAD@Z ; getTextLength
  000c1	83 c4 04	 add	 esp, 4
  000c4	69 4d 0c 6c 10
	00 00		 imul	 ecx, DWORD PTR _index$[ebp], 4204
  000cb	03 4d 18	 add	 ecx, DWORD PTR _wm$[ebp]
  000ce	8b 55 10	 mov	 edx, DWORD PTR _pos$[ebp]
  000d1	83 ea 01	 sub	 edx, 1
  000d4	69 d2 8c 00 00
	00		 imul	 edx, edx, 140
  000da	03 44 11 04	 add	 eax, DWORD PTR [ecx+edx+4]
  000de	69 4d 0c 6c 10
	00 00		 imul	 ecx, DWORD PTR _index$[ebp], 4204
  000e5	03 4d 18	 add	 ecx, DWORD PTR _wm$[ebp]
  000e8	69 55 10 8c 00
	00 00		 imul	 edx, DWORD PTR _pos$[ebp], 140
  000ef	89 44 11 04	 mov	 DWORD PTR [ecx+edx+4], eax
$LN15@getstrstyl:

; 591  : 			wm[index].style[pos].color = 0;

  000f3	69 45 0c 6c 10
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 4204
  000fa	03 45 18	 add	 eax, DWORD PTR _wm$[ebp]
  000fd	69 4d 10 8c 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 140
  00104	c7 44 08 0c 00
	00 00 00	 mov	 DWORD PTR [eax+ecx+12], 0

; 592  : 			int len = stemp - str;

  0010c	8b 45 f8	 mov	 eax, DWORD PTR _stemp$[ebp]
  0010f	2b 45 08	 sub	 eax, DWORD PTR _str$[ebp]
  00112	89 45 e0	 mov	 DWORD PTR _len$10[ebp], eax

; 593  : 			memcpy(wm[index].style[pos].str, str, len);

  00115	8b 45 e0	 mov	 eax, DWORD PTR _len$10[ebp]
  00118	50		 push	 eax
  00119	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0011c	51		 push	 ecx
  0011d	69 55 0c 6c 10
	00 00		 imul	 edx, DWORD PTR _index$[ebp], 4204
  00124	03 55 18	 add	 edx, DWORD PTR _wm$[ebp]
  00127	69 45 10 8c 00
	00 00		 imul	 eax, DWORD PTR _pos$[ebp], 140
  0012e	8d 4c 02 10	 lea	 ecx, DWORD PTR [edx+eax+16]
  00132	51		 push	 ecx
  00133	e8 00 00 00 00	 call	 _memcpy
  00138	83 c4 0c	 add	 esp, 12			; 0000000cH

; 594  : 			wm[index].style[pos].str[len] = NULL;

  0013b	69 45 0c 6c 10
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 4204
  00142	03 45 18	 add	 eax, DWORD PTR _wm$[ebp]
  00145	69 4d 10 8c 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 140
  0014c	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  00150	8b 45 e0	 mov	 eax, DWORD PTR _len$10[ebp]
  00153	c6 44 02 0c 00	 mov	 BYTE PTR [edx+eax+12], 0

; 595  : 			pos++;

  00158	8b 45 10	 mov	 eax, DWORD PTR _pos$[ebp]
  0015b	83 c0 01	 add	 eax, 1
  0015e	89 45 10	 mov	 DWORD PTR _pos$[ebp], eax

; 596  : 			getstrstyle(stemp, index, pos, TRUE, wm);

  00161	8b 45 18	 mov	 eax, DWORD PTR _wm$[ebp]
  00164	50		 push	 eax
  00165	6a 01		 push	 1
  00167	8b 4d 10	 mov	 ecx, DWORD PTR _pos$[ebp]
  0016a	51		 push	 ecx
  0016b	8b 55 0c	 mov	 edx, DWORD PTR _index$[ebp]
  0016e	52		 push	 edx
  0016f	8b 45 f8	 mov	 eax, DWORD PTR _stemp$[ebp]
  00172	50		 push	 eax
  00173	e8 00 00 00 00	 call	 ?getstrstyle@@YAXPADHHHQAUWM_STR@@@Z ; getstrstyle
  00178	83 c4 14	 add	 esp, 20			; 00000014H

; 597  : 		}
; 598  : 		else {

  0017b	e9 dc 02 00 00	 jmp	 $LN13@getstrstyl
$LN12@getstrstyl:

; 599  : 			wm[index].flg = TRUE;

  00180	69 45 0c 6c 10
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 4204
  00187	8b 4d 18	 mov	 ecx, DWORD PTR _wm$[ebp]
  0018a	c7 04 01 01 00
	00 00		 mov	 DWORD PTR [ecx+eax], 1

; 600  : 			stemp = stemp + 7;

  00191	8b 45 f8	 mov	 eax, DWORD PTR _stemp$[ebp]
  00194	83 c0 07	 add	 eax, 7
  00197	89 45 f8	 mov	 DWORD PTR _stemp$[ebp], eax

; 601  : 			etemp = sunday(stemp, "]") + 1;

  0019a	68 00 00 00 00	 push	 OFFSET ??_C@_01LBDDMOBJ@?$FN?$AA@
  0019f	8b 45 f8	 mov	 eax, DWORD PTR _stemp$[ebp]
  001a2	50		 push	 eax
  001a3	e8 00 00 00 00	 call	 ?sunday@@YAPADPAD0@Z	; sunday
  001a8	83 c4 08	 add	 esp, 8
  001ab	83 c0 01	 add	 eax, 1
  001ae	89 45 ec	 mov	 DWORD PTR _etemp$[ebp], eax

; 602  : 			char *scolor = sunday(stemp, "c=");

  001b1	68 00 00 00 00	 push	 OFFSET ??_C@_02CAMHBLCK@c?$DN?$AA@
  001b6	8b 45 f8	 mov	 eax, DWORD PTR _stemp$[ebp]
  001b9	50		 push	 eax
  001ba	e8 00 00 00 00	 call	 ?sunday@@YAPADPAD0@Z	; sunday
  001bf	83 c4 08	 add	 esp, 8
  001c2	89 45 d4	 mov	 DWORD PTR _scolor$9[ebp], eax

; 603  : 			if (scolor) {

  001c5	83 7d d4 00	 cmp	 DWORD PTR _scolor$9[ebp], 0
  001c9	0f 84 9f 00 00
	00		 je	 $LN16@getstrstyl

; 604  : 				scolor = scolor + 2;

  001cf	8b 45 d4	 mov	 eax, DWORD PTR _scolor$9[ebp]
  001d2	83 c0 02	 add	 eax, 2
  001d5	89 45 d4	 mov	 DWORD PTR _scolor$9[ebp], eax

; 605  : 				char strnum[3];
; 606  : 				int i = 0;

  001d8	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _i$7[ebp], 0

; 607  : 				for (i; i<2 && scolor[i] != ' ' && scolor[i] != ']'; i++) {

  001df	eb 09		 jmp	 SHORT $LN4@getstrstyl
$LN2@getstrstyl:
  001e1	8b 45 bc	 mov	 eax, DWORD PTR _i$7[ebp]
  001e4	83 c0 01	 add	 eax, 1
  001e7	89 45 bc	 mov	 DWORD PTR _i$7[ebp], eax
$LN4@getstrstyl:
  001ea	83 7d bc 02	 cmp	 DWORD PTR _i$7[ebp], 2
  001ee	7d 2d		 jge	 SHORT $LN3@getstrstyl
  001f0	8b 45 d4	 mov	 eax, DWORD PTR _scolor$9[ebp]
  001f3	03 45 bc	 add	 eax, DWORD PTR _i$7[ebp]
  001f6	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001f9	83 f9 20	 cmp	 ecx, 32			; 00000020H
  001fc	74 1f		 je	 SHORT $LN3@getstrstyl
  001fe	8b 45 d4	 mov	 eax, DWORD PTR _scolor$9[ebp]
  00201	03 45 bc	 add	 eax, DWORD PTR _i$7[ebp]
  00204	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00207	83 f9 5d	 cmp	 ecx, 93			; 0000005dH
  0020a	74 11		 je	 SHORT $LN3@getstrstyl

; 608  : 					strnum[i] = scolor[i];

  0020c	8b 45 d4	 mov	 eax, DWORD PTR _scolor$9[ebp]
  0020f	03 45 bc	 add	 eax, DWORD PTR _i$7[ebp]
  00212	8b 4d bc	 mov	 ecx, DWORD PTR _i$7[ebp]
  00215	8a 10		 mov	 dl, BYTE PTR [eax]
  00217	88 54 0d c8	 mov	 BYTE PTR _strnum$8[ebp+ecx], dl

; 609  : 				}

  0021b	eb c4		 jmp	 SHORT $LN2@getstrstyl
$LN3@getstrstyl:

; 610  : 				strnum[i] = 0;

  0021d	8b 45 bc	 mov	 eax, DWORD PTR _i$7[ebp]
  00220	89 85 c0 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  00226	83 bd c0 fe ff
	ff 03		 cmp	 DWORD PTR $T2[ebp], 3
  0022d	73 02		 jae	 SHORT $LN25@getstrstyl
  0022f	eb 05		 jmp	 SHORT $LN26@getstrstyl
$LN25@getstrstyl:
  00231	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN26@getstrstyl:
  00236	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  0023c	c6 44 0d c8 00	 mov	 BYTE PTR _strnum$8[ebp+ecx], 0

; 611  : 				wm[index].style[pos].color = atoi(strnum);

  00241	8b f4		 mov	 esi, esp
  00243	8d 45 c8	 lea	 eax, DWORD PTR _strnum$8[ebp]
  00246	50		 push	 eax
  00247	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0024d	83 c4 04	 add	 esp, 4
  00250	3b f4		 cmp	 esi, esp
  00252	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00257	69 4d 0c 6c 10
	00 00		 imul	 ecx, DWORD PTR _index$[ebp], 4204
  0025e	03 4d 18	 add	 ecx, DWORD PTR _wm$[ebp]
  00261	69 55 10 8c 00
	00 00		 imul	 edx, DWORD PTR _pos$[ebp], 140
  00268	89 44 11 0c	 mov	 DWORD PTR [ecx+edx+12], eax
  0026c	eb 19		 jmp	 SHORT $LN17@getstrstyl
$LN16@getstrstyl:

; 612  : 			}
; 613  : 			else wm[index].style[pos].color = 0;

  0026e	69 45 0c 6c 10
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 4204
  00275	03 45 18	 add	 eax, DWORD PTR _wm$[ebp]
  00278	69 4d 10 8c 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 140
  0027f	c7 44 08 0c 00
	00 00 00	 mov	 DWORD PTR [eax+ecx+12], 0
$LN17@getstrstyl:

; 614  : 
; 615  : 			char *ssize = sunday(stemp, "s=");

  00287	68 00 00 00 00	 push	 OFFSET ??_C@_02DMOBLIFK@s?$DN?$AA@
  0028c	8b 45 f8	 mov	 eax, DWORD PTR _stemp$[ebp]
  0028f	50		 push	 eax
  00290	e8 00 00 00 00	 call	 ?sunday@@YAPADPAD0@Z	; sunday
  00295	83 c4 08	 add	 esp, 8
  00298	89 45 b0	 mov	 DWORD PTR _ssize$6[ebp], eax

; 616  : 			if (ssize) {

  0029b	83 7d b0 00	 cmp	 DWORD PTR _ssize$6[ebp], 0
  0029f	0f 84 9f 00 00
	00		 je	 $LN18@getstrstyl

; 617  : 				ssize = ssize + 2;

  002a5	8b 45 b0	 mov	 eax, DWORD PTR _ssize$6[ebp]
  002a8	83 c0 02	 add	 eax, 2
  002ab	89 45 b0	 mov	 DWORD PTR _ssize$6[ebp], eax

; 618  : 				char strsize[3];
; 619  : 				int i = 0;

  002ae	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _i$4[ebp], 0

; 620  : 				for (i; i<2 && ssize[i] != ' ' && ssize[i] != ']'; i++) {

  002b5	eb 09		 jmp	 SHORT $LN7@getstrstyl
$LN5@getstrstyl:
  002b7	8b 45 98	 mov	 eax, DWORD PTR _i$4[ebp]
  002ba	83 c0 01	 add	 eax, 1
  002bd	89 45 98	 mov	 DWORD PTR _i$4[ebp], eax
$LN7@getstrstyl:
  002c0	83 7d 98 02	 cmp	 DWORD PTR _i$4[ebp], 2
  002c4	7d 2d		 jge	 SHORT $LN6@getstrstyl
  002c6	8b 45 b0	 mov	 eax, DWORD PTR _ssize$6[ebp]
  002c9	03 45 98	 add	 eax, DWORD PTR _i$4[ebp]
  002cc	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  002cf	83 f9 20	 cmp	 ecx, 32			; 00000020H
  002d2	74 1f		 je	 SHORT $LN6@getstrstyl
  002d4	8b 45 b0	 mov	 eax, DWORD PTR _ssize$6[ebp]
  002d7	03 45 98	 add	 eax, DWORD PTR _i$4[ebp]
  002da	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  002dd	83 f9 5d	 cmp	 ecx, 93			; 0000005dH
  002e0	74 11		 je	 SHORT $LN6@getstrstyl

; 621  : 					strsize[i] = ssize[i];

  002e2	8b 45 b0	 mov	 eax, DWORD PTR _ssize$6[ebp]
  002e5	03 45 98	 add	 eax, DWORD PTR _i$4[ebp]
  002e8	8b 4d 98	 mov	 ecx, DWORD PTR _i$4[ebp]
  002eb	8a 10		 mov	 dl, BYTE PTR [eax]
  002ed	88 54 0d a4	 mov	 BYTE PTR _strsize$5[ebp+ecx], dl

; 622  : 				}

  002f1	eb c4		 jmp	 SHORT $LN5@getstrstyl
$LN6@getstrstyl:

; 623  : 				strsize[i] = 0;

  002f3	8b 45 98	 mov	 eax, DWORD PTR _i$4[ebp]
  002f6	89 85 b4 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  002fc	83 bd b4 fe ff
	ff 03		 cmp	 DWORD PTR $T1[ebp], 3
  00303	73 02		 jae	 SHORT $LN27@getstrstyl
  00305	eb 05		 jmp	 SHORT $LN28@getstrstyl
$LN27@getstrstyl:
  00307	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN28@getstrstyl:
  0030c	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  00312	c6 44 0d a4 00	 mov	 BYTE PTR _strsize$5[ebp+ecx], 0

; 624  : 				wm[index].style[pos].size = atoi(ssize);

  00317	8b f4		 mov	 esi, esp
  00319	8b 45 b0	 mov	 eax, DWORD PTR _ssize$6[ebp]
  0031c	50		 push	 eax
  0031d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00323	83 c4 04	 add	 esp, 4
  00326	3b f4		 cmp	 esi, esp
  00328	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0032d	69 4d 0c 6c 10
	00 00		 imul	 ecx, DWORD PTR _index$[ebp], 4204
  00334	03 4d 18	 add	 ecx, DWORD PTR _wm$[ebp]
  00337	69 55 10 8c 00
	00 00		 imul	 edx, DWORD PTR _pos$[ebp], 140
  0033e	89 44 11 08	 mov	 DWORD PTR [ecx+edx+8], eax
  00342	eb 19		 jmp	 SHORT $LN19@getstrstyl
$LN18@getstrstyl:

; 625  : 			}
; 626  : 			else wm[index].style[pos].size = FONT_SIZE1;

  00344	69 45 0c 6c 10
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 4204
  0034b	03 45 18	 add	 eax, DWORD PTR _wm$[ebp]
  0034e	69 4d 10 8c 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 140
  00355	c7 44 08 08 0e
	00 00 00	 mov	 DWORD PTR [eax+ecx+8], 14 ; 0000000eH
$LN19@getstrstyl:

; 627  : 
; 628  : 			stemp = sunday(str, "[/style]");

  0035d	68 00 00 00 00	 push	 OFFSET ??_C@_08EAKPCBLG@?$FL?1style?$FN?$AA@
  00362	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00365	50		 push	 eax
  00366	e8 00 00 00 00	 call	 ?sunday@@YAPADPAD0@Z	; sunday
  0036b	83 c4 08	 add	 esp, 8
  0036e	89 45 f8	 mov	 DWORD PTR _stemp$[ebp], eax

; 629  : 
; 630  : 			int len = stemp - etemp;

  00371	8b 45 f8	 mov	 eax, DWORD PTR _stemp$[ebp]
  00374	2b 45 ec	 sub	 eax, DWORD PTR _etemp$[ebp]
  00377	89 45 8c	 mov	 DWORD PTR _len$3[ebp], eax

; 631  : 			memcpy(wm[index].style[pos].str, etemp, len);

  0037a	8b 45 8c	 mov	 eax, DWORD PTR _len$3[ebp]
  0037d	50		 push	 eax
  0037e	8b 4d ec	 mov	 ecx, DWORD PTR _etemp$[ebp]
  00381	51		 push	 ecx
  00382	69 55 0c 6c 10
	00 00		 imul	 edx, DWORD PTR _index$[ebp], 4204
  00389	03 55 18	 add	 edx, DWORD PTR _wm$[ebp]
  0038c	69 45 10 8c 00
	00 00		 imul	 eax, DWORD PTR _pos$[ebp], 140
  00393	8d 4c 02 10	 lea	 ecx, DWORD PTR [edx+eax+16]
  00397	51		 push	 ecx
  00398	e8 00 00 00 00	 call	 _memcpy
  0039d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 632  : 			wm[index].style[pos].str[len] = NULL;

  003a0	69 45 0c 6c 10
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 4204
  003a7	03 45 18	 add	 eax, DWORD PTR _wm$[ebp]
  003aa	69 4d 10 8c 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 140
  003b1	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  003b5	8b 45 8c	 mov	 eax, DWORD PTR _len$3[ebp]
  003b8	c6 44 02 0c 00	 mov	 BYTE PTR [edx+eax+12], 0

; 633  : 			if (pos == 0)

  003bd	83 7d 10 00	 cmp	 DWORD PTR _pos$[ebp], 0
  003c1	75 1b		 jne	 SHORT $LN20@getstrstyl

; 634  : 				wm[index].style[pos].x = 0;

  003c3	69 45 0c 6c 10
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 4204
  003ca	03 45 18	 add	 eax, DWORD PTR _wm$[ebp]
  003cd	69 4d 10 8c 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 140
  003d4	c7 44 08 04 00
	00 00 00	 mov	 DWORD PTR [eax+ecx+4], 0

; 635  : 			else

  003dc	eb 52		 jmp	 SHORT $LN21@getstrstyl
$LN20@getstrstyl:

; 636  : 				wm[index].style[pos].x = getTextLength(wm[index].style[pos - 1].str) + wm[index].style[pos - 1].x;

  003de	69 45 0c 6c 10
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 4204
  003e5	03 45 18	 add	 eax, DWORD PTR _wm$[ebp]
  003e8	8b 4d 10	 mov	 ecx, DWORD PTR _pos$[ebp]
  003eb	83 e9 01	 sub	 ecx, 1
  003ee	69 d1 8c 00 00
	00		 imul	 edx, ecx, 140
  003f4	8d 44 10 10	 lea	 eax, DWORD PTR [eax+edx+16]
  003f8	50		 push	 eax
  003f9	e8 00 00 00 00	 call	 ?getTextLength@@YAHPAD@Z ; getTextLength
  003fe	83 c4 04	 add	 esp, 4
  00401	69 4d 0c 6c 10
	00 00		 imul	 ecx, DWORD PTR _index$[ebp], 4204
  00408	03 4d 18	 add	 ecx, DWORD PTR _wm$[ebp]
  0040b	8b 55 10	 mov	 edx, DWORD PTR _pos$[ebp]
  0040e	83 ea 01	 sub	 edx, 1
  00411	69 d2 8c 00 00
	00		 imul	 edx, edx, 140
  00417	03 44 11 04	 add	 eax, DWORD PTR [ecx+edx+4]
  0041b	69 4d 0c 6c 10
	00 00		 imul	 ecx, DWORD PTR _index$[ebp], 4204
  00422	03 4d 18	 add	 ecx, DWORD PTR _wm$[ebp]
  00425	69 55 10 8c 00
	00 00		 imul	 edx, DWORD PTR _pos$[ebp], 140
  0042c	89 44 11 04	 mov	 DWORD PTR [ecx+edx+4], eax
$LN21@getstrstyl:

; 637  : 			pos++;

  00430	8b 45 10	 mov	 eax, DWORD PTR _pos$[ebp]
  00433	83 c0 01	 add	 eax, 1
  00436	89 45 10	 mov	 DWORD PTR _pos$[ebp], eax

; 638  : 			stemp = stemp + 8;

  00439	8b 45 f8	 mov	 eax, DWORD PTR _stemp$[ebp]
  0043c	83 c0 08	 add	 eax, 8
  0043f	89 45 f8	 mov	 DWORD PTR _stemp$[ebp], eax

; 639  : 			getstrstyle(stemp, index, pos, FALSE, wm);

  00442	8b 45 18	 mov	 eax, DWORD PTR _wm$[ebp]
  00445	50		 push	 eax
  00446	6a 00		 push	 0
  00448	8b 4d 10	 mov	 ecx, DWORD PTR _pos$[ebp]
  0044b	51		 push	 ecx
  0044c	8b 55 0c	 mov	 edx, DWORD PTR _index$[ebp]
  0044f	52		 push	 edx
  00450	8b 45 f8	 mov	 eax, DWORD PTR _stemp$[ebp]
  00453	50		 push	 eax
  00454	e8 00 00 00 00	 call	 ?getstrstyle@@YAXPADHHHQAUWM_STR@@@Z ; getstrstyle
  00459	83 c4 14	 add	 esp, 20			; 00000014H
$LN13@getstrstyl:

; 640  : 		}
; 641  : 	}
; 642  : 	else {

  0045c	e9 1c 01 00 00	 jmp	 $LN24@getstrstyl
$LN10@getstrstyl:

; 643  : 		sprintf(wm[index].style[pos].str, "%s", str);

  00461	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00464	50		 push	 eax
  00465	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  0046a	69 4d 0c 6c 10
	00 00		 imul	 ecx, DWORD PTR _index$[ebp], 4204
  00471	03 4d 18	 add	 ecx, DWORD PTR _wm$[ebp]
  00474	69 55 10 8c 00
	00 00		 imul	 edx, DWORD PTR _pos$[ebp], 140
  0047b	8d 44 11 10	 lea	 eax, DWORD PTR [ecx+edx+16]
  0047f	50		 push	 eax
  00480	e8 00 00 00 00	 call	 _sprintf
  00485	83 c4 0c	 add	 esp, 12			; 0000000cH

; 644  : 		if (!wm[index].flg) {

  00488	69 45 0c 6c 10
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 4204
  0048f	8b 4d 18	 mov	 ecx, DWORD PTR _wm$[ebp]
  00492	83 3c 01 00	 cmp	 DWORD PTR [ecx+eax], 0
  00496	75 61		 jne	 SHORT $LN22@getstrstyl

; 645  : 			wm[index].flg = TRUE;

  00498	69 45 0c 6c 10
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 4204
  0049f	8b 4d 18	 mov	 ecx, DWORD PTR _wm$[ebp]
  004a2	c7 04 01 01 00
	00 00		 mov	 DWORD PTR [ecx+eax], 1

; 646  : 			wm[index].style[pos].x = 0;

  004a9	69 45 0c 6c 10
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 4204
  004b0	03 45 18	 add	 eax, DWORD PTR _wm$[ebp]
  004b3	69 4d 10 8c 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 140
  004ba	c7 44 08 04 00
	00 00 00	 mov	 DWORD PTR [eax+ecx+4], 0

; 647  : 			wm[index].style[pos].color = 0;

  004c2	69 45 0c 6c 10
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 4204
  004c9	03 45 18	 add	 eax, DWORD PTR _wm$[ebp]
  004cc	69 4d 10 8c 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 140
  004d3	c7 44 08 0c 00
	00 00 00	 mov	 DWORD PTR [eax+ecx+12], 0

; 648  : 			wm[index].style[pos].size = FONT_SIZE1;

  004db	69 45 0c 6c 10
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 4204
  004e2	03 45 18	 add	 eax, DWORD PTR _wm$[ebp]
  004e5	69 4d 10 8c 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 140
  004ec	c7 44 08 08 0e
	00 00 00	 mov	 DWORD PTR [eax+ecx+8], 14 ; 0000000eH

; 649  : 		}
; 650  : 		else {

  004f4	e9 84 00 00 00	 jmp	 $LN24@getstrstyl
$LN22@getstrstyl:

; 651  : 			wm[index].style[pos].size = FONT_SIZE1;

  004f9	69 45 0c 6c 10
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 4204
  00500	03 45 18	 add	 eax, DWORD PTR _wm$[ebp]
  00503	69 4d 10 8c 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 140
  0050a	c7 44 08 08 0e
	00 00 00	 mov	 DWORD PTR [eax+ecx+8], 14 ; 0000000eH

; 652  : 			wm[index].style[pos].x = getTextLength(wm[index].style[pos - 1].str) + wm[index].style[pos - 1].x;

  00512	69 45 0c 6c 10
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 4204
  00519	03 45 18	 add	 eax, DWORD PTR _wm$[ebp]
  0051c	8b 4d 10	 mov	 ecx, DWORD PTR _pos$[ebp]
  0051f	83 e9 01	 sub	 ecx, 1
  00522	69 d1 8c 00 00
	00		 imul	 edx, ecx, 140
  00528	8d 44 10 10	 lea	 eax, DWORD PTR [eax+edx+16]
  0052c	50		 push	 eax
  0052d	e8 00 00 00 00	 call	 ?getTextLength@@YAHPAD@Z ; getTextLength
  00532	83 c4 04	 add	 esp, 4
  00535	69 4d 0c 6c 10
	00 00		 imul	 ecx, DWORD PTR _index$[ebp], 4204
  0053c	03 4d 18	 add	 ecx, DWORD PTR _wm$[ebp]
  0053f	8b 55 10	 mov	 edx, DWORD PTR _pos$[ebp]
  00542	83 ea 01	 sub	 edx, 1
  00545	69 d2 8c 00 00
	00		 imul	 edx, edx, 140
  0054b	03 44 11 04	 add	 eax, DWORD PTR [ecx+edx+4]
  0054f	69 4d 0c 6c 10
	00 00		 imul	 ecx, DWORD PTR _index$[ebp], 4204
  00556	03 4d 18	 add	 ecx, DWORD PTR _wm$[ebp]
  00559	69 55 10 8c 00
	00 00		 imul	 edx, DWORD PTR _pos$[ebp], 140
  00560	89 44 11 04	 mov	 DWORD PTR [ecx+edx+4], eax

; 653  : 			wm[index].style[pos].color = 0;

  00564	69 45 0c 6c 10
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 4204
  0056b	03 45 18	 add	 eax, DWORD PTR _wm$[ebp]
  0056e	69 4d 10 8c 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 140
  00575	c7 44 08 0c 00
	00 00 00	 mov	 DWORD PTR [eax+ecx+12], 0
$LN24@getstrstyl:

; 654  : 		}
; 655  : 	}
; 656  : }

  0057d	52		 push	 edx
  0057e	8b cd		 mov	 ecx, ebp
  00580	50		 push	 eax
  00581	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN32@getstrstyl
  00587	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0058c	58		 pop	 eax
  0058d	5a		 pop	 edx
  0058e	5f		 pop	 edi
  0058f	5e		 pop	 esi
  00590	5b		 pop	 ebx
  00591	81 c4 50 01 00
	00		 add	 esp, 336		; 00000150H
  00597	3b ec		 cmp	 ebp, esp
  00599	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0059e	8b e5		 mov	 esp, ebp
  005a0	5d		 pop	 ebp
  005a1	c3		 ret	 0
  005a2	66 90		 npad	 2
$LN32@getstrstyl:
  005a4	02 00 00 00	 DD	 2
  005a8	00 00 00 00	 DD	 $LN31@getstrstyl
$LN31@getstrstyl:
  005ac	c8 ff ff ff	 DD	 -56			; ffffffc8H
  005b0	03 00 00 00	 DD	 3
  005b4	00 00 00 00	 DD	 $LN29@getstrstyl
  005b8	a4 ff ff ff	 DD	 -92			; ffffffa4H
  005bc	03 00 00 00	 DD	 3
  005c0	00 00 00 00	 DD	 $LN30@getstrstyl
$LN30@getstrstyl:
  005c4	73		 DB	 115			; 00000073H
  005c5	74		 DB	 116			; 00000074H
  005c6	72		 DB	 114			; 00000072H
  005c7	73		 DB	 115			; 00000073H
  005c8	69		 DB	 105			; 00000069H
  005c9	7a		 DB	 122			; 0000007aH
  005ca	65		 DB	 101			; 00000065H
  005cb	00		 DB	 0
$LN29@getstrstyl:
  005cc	73		 DB	 115			; 00000073H
  005cd	74		 DB	 116			; 00000074H
  005ce	72		 DB	 114			; 00000072H
  005cf	6e		 DB	 110			; 0000006eH
  005d0	75		 DB	 117			; 00000075H
  005d1	6d		 DB	 109			; 0000006dH
  005d2	00		 DB	 0
?getstrstyle@@YAXPADHHHQAUWM_STR@@@Z ENDP		; getstrstyle
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?rtrim@@YAXPAD@Z
_TEXT	SEGMENT
_i$ = -8						; size = 4
_str$ = 8						; size = 4
?rtrim@@YAXPAD@Z PROC					; rtrim, COMDAT

; 567  : void rtrim(char *str) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 568  : 	int i;
; 569  : 	for (i = (int)strlen(str) - 1; str[i] == 32 && i >= 0; str[i--] = 0);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _strlen
  00027	83 c4 04	 add	 esp, 4
  0002a	83 e8 01	 sub	 eax, 1
  0002d	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00030	eb 12		 jmp	 SHORT $LN4@rtrim
$LN2@rtrim:
  00032	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00035	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00038	c6 00 00	 mov	 BYTE PTR [eax], 0
  0003b	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0003e	83 e9 01	 sub	 ecx, 1
  00041	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$LN4@rtrim:
  00044	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00047	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  0004a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0004d	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00050	75 08		 jne	 SHORT $LN1@rtrim
  00052	83 7d f8 00	 cmp	 DWORD PTR _i$[ebp], 0
  00056	7c 02		 jl	 SHORT $LN1@rtrim
  00058	eb d8		 jmp	 SHORT $LN2@rtrim
$LN1@rtrim:

; 570  : }

  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00063	3b ec		 cmp	 ebp, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?rtrim@@YAXPAD@Z ENDP					; rtrim
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?ltrim@@YAXPAD@Z
_TEXT	SEGMENT
_ptr$ = -8						; size = 4
_str$ = 8						; size = 4
?ltrim@@YAXPAD@Z PROC					; ltrim, COMDAT

; 561  : void ltrim(char *str) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 562  : 	char *ptr;
; 563  : 	for (ptr = str; *ptr == 32; ptr++);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR _ptr$[ebp], eax
  00024	eb 09		 jmp	 SHORT $LN4@ltrim
$LN2@ltrim:
  00026	8b 45 f8	 mov	 eax, DWORD PTR _ptr$[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 f8	 mov	 DWORD PTR _ptr$[ebp], eax
$LN4@ltrim:
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _ptr$[ebp]
  00032	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00035	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00038	75 02		 jne	 SHORT $LN1@ltrim
  0003a	eb ea		 jmp	 SHORT $LN2@ltrim
$LN1@ltrim:

; 564  : 
; 565  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?ltrim@@YAXPAD@Z ENDP					; ltrim
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?getStringFromIndexWithDelim_body@@YAHPAD0H0H@Z
_TEXT	SEGMENT
_last$1 = -56						; size = 4
_oneByteMode$ = -44					; size = 4
_addlen$ = -32						; size = 4
_length$ = -20						; size = 4
_i$ = -8						; size = 4
_src$ = 8						; size = 4
_delim$ = 12						; size = 4
_index$ = 16						; size = 4
_buf$ = 20						; size = 4
_buflen$ = 24						; size = 4
?getStringFromIndexWithDelim_body@@YAHPAD0H0H@Z PROC	; getStringFromIndexWithDelim_body, COMDAT

; 520  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00012	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 521  : 	int i;
; 522  : 	int length = 0;

  0001e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _length$[ebp], 0

; 523  : 	int addlen = 0;

  00025	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _addlen$[ebp], 0

; 524  : 	int oneByteMode = 0;

  0002c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _oneByteMode$[ebp], 0

; 525  : 
; 526  : 	if (strlen(delim) == 1) {

  00033	8b 45 0c	 mov	 eax, DWORD PTR _delim$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 _strlen
  0003c	83 c4 04	 add	 esp, 4
  0003f	83 f8 01	 cmp	 eax, 1
  00042	75 07		 jne	 SHORT $LN5@getStringF

; 527  : 		oneByteMode = 1;

  00044	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _oneByteMode$[ebp], 1
$LN5@getStringF:

; 528  : 	}
; 529  : 	for (i = 0; i < index; i++) {

  0004b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00052	eb 09		 jmp	 SHORT $LN4@getStringF
$LN2@getStringF:
  00054	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00057	83 c0 01	 add	 eax, 1
  0005a	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@getStringF:
  0005d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00060	3b 45 10	 cmp	 eax, DWORD PTR _index$[ebp]
  00063	0f 8d b9 00 00
	00		 jge	 $LN3@getStringF

; 530  : 		char* last;
; 531  : 		src += addlen;

  00069	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0006c	03 45 e0	 add	 eax, DWORD PTR _addlen$[ebp]
  0006f	89 45 08	 mov	 DWORD PTR _src$[ebp], eax

; 532  : 
; 533  : 		if (oneByteMode) {

  00072	83 7d d4 00	 cmp	 DWORD PTR _oneByteMode$[ebp], 0
  00076	74 21		 je	 SHORT $LN6@getStringF

; 534  : 
; 535  : 			char * ScanOneByte(char *src, char delim);
; 536  : 			last = ScanOneByte(src, delim[0]);

  00078	b8 01 00 00 00	 mov	 eax, 1
  0007d	6b c8 00	 imul	 ecx, eax, 0
  00080	8b 55 0c	 mov	 edx, DWORD PTR _delim$[ebp]
  00083	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00087	50		 push	 eax
  00088	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 ?ScanOneByte@@YAPADPADD@Z ; ScanOneByte
  00091	83 c4 08	 add	 esp, 8
  00094	89 45 c8	 mov	 DWORD PTR _last$1[ebp], eax

; 537  : 		}
; 538  : 		else {

  00097	eb 13		 jmp	 SHORT $LN7@getStringF
$LN6@getStringF:

; 539  : 			last = strstr(src, delim);

  00099	8b 45 0c	 mov	 eax, DWORD PTR _delim$[ebp]
  0009c	50		 push	 eax
  0009d	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 ?strstr@@YAPADQADQBD@Z	; strstr
  000a6	83 c4 08	 add	 esp, 8
  000a9	89 45 c8	 mov	 DWORD PTR _last$1[ebp], eax
$LN7@getStringF:

; 540  : 		}
; 541  : 		if (last == NULL) {

  000ac	83 7d c8 00	 cmp	 DWORD PTR _last$1[ebp], 0
  000b0	75 50		 jne	 SHORT $LN8@getStringF

; 542  : 			void strcpysafe(char* dest, size_t n, const char* src);
; 543  : 			strcpysafe(buf, buflen, src);

  000b2	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  000b5	50		 push	 eax
  000b6	8b 4d 18	 mov	 ecx, DWORD PTR _buflen$[ebp]
  000b9	51		 push	 ecx
  000ba	8b 55 14	 mov	 edx, DWORD PTR _buf$[ebp]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 ?strcpysafe@@YAXPADIPBD@Z ; strcpysafe
  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 544  : 			if (i == index - 1) {

  000c6	8b 45 10	 mov	 eax, DWORD PTR _index$[ebp]
  000c9	83 e8 01	 sub	 eax, 1
  000cc	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  000cf	75 1e		 jne	 SHORT $LN9@getStringF

; 545  : 				if (buf[0] == 0) return FALSE;

  000d1	b8 01 00 00 00	 mov	 eax, 1
  000d6	6b c8 00	 imul	 ecx, eax, 0
  000d9	8b 55 14	 mov	 edx, DWORD PTR _buf$[ebp]
  000dc	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  000e0	85 c0		 test	 eax, eax
  000e2	75 04		 jne	 SHORT $LN10@getStringF
  000e4	33 c0		 xor	 eax, eax
  000e6	eb 6e		 jmp	 SHORT $LN1@getStringF
$LN10@getStringF:

; 546  : 				return TRUE;

  000e8	b8 01 00 00 00	 mov	 eax, 1
  000ed	eb 67		 jmp	 SHORT $LN1@getStringF
$LN9@getStringF:

; 547  : 			}
; 548  : 			buf[0] = 0;

  000ef	b8 01 00 00 00	 mov	 eax, 1
  000f4	6b c8 00	 imul	 ecx, eax, 0
  000f7	8b 55 14	 mov	 edx, DWORD PTR _buf$[ebp]
  000fa	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0

; 549  : 			return FALSE;

  000fe	33 c0		 xor	 eax, eax
  00100	eb 54		 jmp	 SHORT $LN1@getStringF
$LN8@getStringF:

; 550  : 		}
; 551  : 		length = last - src;

  00102	8b 45 c8	 mov	 eax, DWORD PTR _last$1[ebp]
  00105	2b 45 08	 sub	 eax, DWORD PTR _src$[ebp]
  00108	89 45 ec	 mov	 DWORD PTR _length$[ebp], eax

; 552  : 		addlen = length + strlen(delim);

  0010b	8b 45 0c	 mov	 eax, DWORD PTR _delim$[ebp]
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 _strlen
  00114	83 c4 04	 add	 esp, 4
  00117	03 45 ec	 add	 eax, DWORD PTR _length$[ebp]
  0011a	89 45 e0	 mov	 DWORD PTR _addlen$[ebp], eax

; 553  : 	}

  0011d	e9 32 ff ff ff	 jmp	 $LN2@getStringF
$LN3@getStringF:

; 554  : 	void strncpysafe(char* dest, const size_t n,
; 555  : 		const char* src, const int length);
; 556  : 	strncpysafe(buf, buflen, src, length);

  00122	8b 45 ec	 mov	 eax, DWORD PTR _length$[ebp]
  00125	50		 push	 eax
  00126	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  00129	51		 push	 ecx
  0012a	8b 55 18	 mov	 edx, DWORD PTR _buflen$[ebp]
  0012d	52		 push	 edx
  0012e	8b 45 14	 mov	 eax, DWORD PTR _buf$[ebp]
  00131	50		 push	 eax
  00132	e8 00 00 00 00	 call	 ?strncpysafe@@YAXPADIPBDH@Z ; strncpysafe
  00137	83 c4 10	 add	 esp, 16			; 00000010H

; 557  : 	if (buf[0] == 0) return FALSE;

  0013a	b8 01 00 00 00	 mov	 eax, 1
  0013f	6b c8 00	 imul	 ecx, eax, 0
  00142	8b 55 14	 mov	 edx, DWORD PTR _buf$[ebp]
  00145	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00149	85 c0		 test	 eax, eax
  0014b	75 04		 jne	 SHORT $LN11@getStringF
  0014d	33 c0		 xor	 eax, eax
  0014f	eb 05		 jmp	 SHORT $LN1@getStringF
$LN11@getStringF:

; 558  : 	return TRUE;

  00151	b8 01 00 00 00	 mov	 eax, 1
$LN1@getStringF:

; 559  : }

  00156	5f		 pop	 edi
  00157	5e		 pop	 esi
  00158	5b		 pop	 ebx
  00159	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  0015f	3b ec		 cmp	 ebp, esp
  00161	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00166	8b e5		 mov	 esp, ebp
  00168	5d		 pop	 ebp
  00169	c3		 ret	 0
?getStringFromIndexWithDelim_body@@YAHPAD0H0H@Z ENDP	; getStringFromIndexWithDelim_body
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?strcmptail@@YAHPAD0@Z
_TEXT	SEGMENT
_ind2$1 = -56						; size = 4
_ind1$2 = -44						; size = 4
_len2$ = -32						; size = 4
_len1$ = -20						; size = 4
_i$ = -8						; size = 4
_s1$ = 8						; size = 4
_s2$ = 12						; size = 4
?strcmptail@@YAHPAD0@Z PROC				; strcmptail, COMDAT

; 504  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00012	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 505  : 	int i;
; 506  : 	int len1 = strlen(s1);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _s1$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _strlen
  00027	83 c4 04	 add	 esp, 4
  0002a	89 45 ec	 mov	 DWORD PTR _len1$[ebp], eax

; 507  : 	int len2 = strlen(s2);

  0002d	8b 45 0c	 mov	 eax, DWORD PTR _s2$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _strlen
  00036	83 c4 04	 add	 esp, 4
  00039	89 45 e0	 mov	 DWORD PTR _len2$[ebp], eax

; 508  : 
; 509  : 	for (i = 0;; i++) {

  0003c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00043	eb 09		 jmp	 SHORT $LN4@strcmptail
$LN2@strcmptail:
  00045	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00048	83 c0 01	 add	 eax, 1
  0004b	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@strcmptail:

; 510  : 		int ind1 = len1 - 1 - i;

  0004e	8b 45 ec	 mov	 eax, DWORD PTR _len1$[ebp]
  00051	83 e8 01	 sub	 eax, 1
  00054	2b 45 f8	 sub	 eax, DWORD PTR _i$[ebp]
  00057	89 45 d4	 mov	 DWORD PTR _ind1$2[ebp], eax

; 511  : 		int ind2 = len2 - 1 - i;

  0005a	8b 45 e0	 mov	 eax, DWORD PTR _len2$[ebp]
  0005d	83 e8 01	 sub	 eax, 1
  00060	2b 45 f8	 sub	 eax, DWORD PTR _i$[ebp]
  00063	89 45 c8	 mov	 DWORD PTR _ind2$1[ebp], eax

; 512  : 		if (ind1 < 0 || ind2 < 0) return 0;

  00066	83 7d d4 00	 cmp	 DWORD PTR _ind1$2[ebp], 0
  0006a	7c 06		 jl	 SHORT $LN6@strcmptail
  0006c	83 7d c8 00	 cmp	 DWORD PTR _ind2$1[ebp], 0
  00070	7d 04		 jge	 SHORT $LN5@strcmptail
$LN6@strcmptail:
  00072	33 c0		 xor	 eax, eax
  00074	eb 1f		 jmp	 SHORT $LN1@strcmptail
$LN5@strcmptail:

; 513  : 		if (s1[ind1] != s2[ind2]) return 1;

  00076	8b 45 08	 mov	 eax, DWORD PTR _s1$[ebp]
  00079	03 45 d4	 add	 eax, DWORD PTR _ind1$2[ebp]
  0007c	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0007f	8b 55 0c	 mov	 edx, DWORD PTR _s2$[ebp]
  00082	03 55 c8	 add	 edx, DWORD PTR _ind2$1[ebp]
  00085	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00088	3b c8		 cmp	 ecx, eax
  0008a	74 07		 je	 SHORT $LN7@strcmptail
  0008c	b8 01 00 00 00	 mov	 eax, 1
  00091	eb 02		 jmp	 SHORT $LN1@strcmptail
$LN7@strcmptail:

; 514  : 	}

  00093	eb b0		 jmp	 SHORT $LN2@strcmptail
$LN1@strcmptail:

; 515  : }

  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx
  00098	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  0009e	3b ec		 cmp	 ebp, esp
  000a0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
?strcmptail@@YAHPAD0@Z ENDP				; strcmptail
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?PutWinText@@YAXHHDHPADHH@Z
_TEXT	SEGMENT
_i$ = -8						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_fontPrio$ = 16						; size = 1
_color$ = 20						; size = 4
_str$ = 24						; size = 4
_hitFlag$ = 28						; size = 4
_index$ = 32						; size = 4
?PutWinText@@YAXHHDHPADHH@Z PROC			; PutWinText, COMDAT

; 659  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 660  : 	int i = 0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 661  : 	for (; i<30; i++) {

  00025	eb 09		 jmp	 SHORT $LN4@PutWinText
$LN2@PutWinText:
  00027	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0002a	83 c0 01	 add	 eax, 1
  0002d	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@PutWinText:
  00030	83 7d f8 1e	 cmp	 DWORD PTR _i$[ebp], 30	; 0000001eH
  00034	0f 8d 9b 00 00
	00		 jge	 $LN1@PutWinText

; 662  : 		if (*wmstr[index].style[i].str)

  0003a	69 45 20 6c 10
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 4204
  00041	69 4d f8 8c 00
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 140
  00048	8d 94 08 04 00
	00 00		 lea	 edx, DWORD PTR ?wmstr@@3PAUWM_STR@@A[eax+ecx+4]
  0004f	b8 01 00 00 00	 mov	 eax, 1
  00054	6b c8 00	 imul	 ecx, eax, 0
  00057	0f be 54 0a 0c	 movsx	 edx, BYTE PTR [edx+ecx+12]
  0005c	85 d2		 test	 edx, edx
  0005e	74 70		 je	 SHORT $LN5@PutWinText

; 663  : 			StockFontBufferExt(x + wmstr[index].style[i].x, y, fontPrio, wmstr[index].style[i].color,

  00060	69 45 20 6c 10
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 4204
  00067	69 4d f8 8c 00
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 140
  0006e	8b 94 08 08 00
	00 00		 mov	 edx, DWORD PTR ?wmstr@@3PAUWM_STR@@A[eax+ecx+8]
  00075	52		 push	 edx
  00076	8b 45 1c	 mov	 eax, DWORD PTR _hitFlag$[ebp]
  00079	50		 push	 eax
  0007a	69 4d 20 6c 10
	00 00		 imul	 ecx, DWORD PTR _index$[ebp], 4204
  00081	69 55 f8 8c 00
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 140
  00088	8d 84 11 10 00
	00 00		 lea	 eax, DWORD PTR ?wmstr@@3PAUWM_STR@@A[ecx+edx+16]
  0008f	50		 push	 eax
  00090	69 4d 20 6c 10
	00 00		 imul	 ecx, DWORD PTR _index$[ebp], 4204
  00097	69 55 f8 8c 00
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 140
  0009e	8b 84 11 0c 00
	00 00		 mov	 eax, DWORD PTR ?wmstr@@3PAUWM_STR@@A[ecx+edx+12]
  000a5	50		 push	 eax
  000a6	0f b6 4d 10	 movzx	 ecx, BYTE PTR _fontPrio$[ebp]
  000aa	51		 push	 ecx
  000ab	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  000ae	52		 push	 edx
  000af	69 45 20 6c 10
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 4204
  000b6	69 4d f8 8c 00
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 140
  000bd	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  000c0	03 94 08 04 00
	00 00		 add	 edx, DWORD PTR ?wmstr@@3PAUWM_STR@@A[eax+ecx+4]
  000c7	52		 push	 edx
  000c8	e8 00 00 00 00	 call	 ?StockFontBufferExt@@YAHHHDHPADHH@Z ; StockFontBufferExt
  000cd	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN5@PutWinText:

; 664  : 				wmstr[index].style[i].str, hitFlag, wmstr[index].style[i].size);
; 665  : 	}

  000d0	e9 52 ff ff ff	 jmp	 $LN2@PutWinText
$LN1@PutWinText:

; 666  : }

  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx
  000d8	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000de	3b ec		 cmp	 ebp, esp
  000e0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
?PutWinText@@YAXHHDHPADHH@Z ENDP			; PutWinText
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?getStrSplitNew@@YAXQAY0BAA@D@Z
_TEXT	SEGMENT
_i$ = -8						; size = 4
_str$ = 8						; size = 4
?getStrSplitNew@@YAXQAY0BAA@D@Z PROC			; getStrSplitNew, COMDAT

; 778  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 779  : 	memset(wmstr, 0, sizeof(WM_STR) * 25);

  0001e	68 8c 9a 01 00	 push	 105100			; 00019a8cH
  00023	6a 00		 push	 0
  00025	68 00 00 00 00	 push	 OFFSET ?wmstr@@3PAUWM_STR@@A ; wmstr
  0002a	e8 00 00 00 00	 call	 _memset
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 780  : 	int i = 0;

  00032	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 781  : 
; 782  : 	for (i; i<25; i++) {

  00039	eb 09		 jmp	 SHORT $LN4@getStrSpli
$LN2@getStrSpli:
  0003b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0003e	83 c0 01	 add	 eax, 1
  00041	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@getStrSpli:
  00044	83 7d f8 19	 cmp	 DWORD PTR _i$[ebp], 25	; 00000019H
  00048	7d 3a		 jge	 SHORT $LN1@getStrSpli

; 783  : 		if (str[i][0]) {

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0004d	c1 e0 08	 shl	 eax, 8
  00050	03 45 08	 add	 eax, DWORD PTR _str$[ebp]
  00053	b9 01 00 00 00	 mov	 ecx, 1
  00058	6b d1 00	 imul	 edx, ecx, 0
  0005b	0f be 04 10	 movsx	 eax, BYTE PTR [eax+edx]
  0005f	85 c0		 test	 eax, eax
  00061	74 1f		 je	 SHORT $LN5@getStrSpli

; 784  : 			getstrstyle(str[i], i, 0, FALSE, wmstr);

  00063	68 00 00 00 00	 push	 OFFSET ?wmstr@@3PAUWM_STR@@A ; wmstr
  00068	6a 00		 push	 0
  0006a	6a 00		 push	 0
  0006c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0006f	50		 push	 eax
  00070	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00073	c1 e1 08	 shl	 ecx, 8
  00076	03 4d 08	 add	 ecx, DWORD PTR _str$[ebp]
  00079	51		 push	 ecx
  0007a	e8 00 00 00 00	 call	 ?getstrstyle@@YAXPADHHHQAUWM_STR@@@Z ; getstrstyle
  0007f	83 c4 14	 add	 esp, 20			; 00000014H
$LN5@getStrSpli:

; 785  : 		}
; 786  : 	}

  00082	eb b7		 jmp	 SHORT $LN2@getStrSpli
$LN1@getStrSpli:

; 787  : }

  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
?getStrSplitNew@@YAXQAY0BAA@D@Z ENDP			; getStrSplitNew
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?util_mkstring@@YAHPAD0@Z
_TEXT	SEGMENT
_len$ = -65520						; size = 4
_t1$ = -65508						; size = 65500
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_value$ = 12						; size = 4
?util_mkstring@@YAHPAD0@Z PROC				; util_mkstring, COMDAT

; 468  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 f4 05 01 00	 mov	 eax, 67060		; 000105f4H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8d bd 0c fa fe
	ff		 lea	 edi, DWORD PTR [ebp-67060]
  00016	b9 7d 41 00 00	 mov	 ecx, 16765		; 0000417dH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 469  :   char t1[SLICE_SIZE];
; 470  :   //printf("动态密钥4：%s\n",PersonalKey);
; 471  :   util_256to64_shl(t1, value, strlen(value), DEFAULTTABLE, PersonalKey);

  0002c	68 00 00 00 00	 push	 OFFSET ?PersonalKey@@3PADA ; PersonalKey
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@CPNIKEEC@0123456789ABCDEFGHIJKLMNOPQRSTUV@
  00036	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _strlen
  0003f	83 c4 04	 add	 esp, 4
  00042	50		 push	 eax
  00043	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  00046	51		 push	 ecx
  00047	8d 95 1c 00 ff
	ff		 lea	 edx, DWORD PTR _t1$[ebp]
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 ?util_256to64_shl@@YAHPAD0H00@Z ; util_256to64_shl
  00053	83 c4 14	 add	 esp, 20			; 00000014H

; 472  :   strcat(buffer, ";");	// It's important to append a SEPARATOR between fields

  00056	68 00 00 00 00	 push	 OFFSET ??_C@_01ICJEACDI@?$DL?$AA@
  0005b	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 _strcat
  00064	83 c4 08	 add	 esp, 8

; 473  :   strcat(buffer, t1);

  00067	8d 85 1c 00 ff
	ff		 lea	 eax, DWORD PTR _t1$[ebp]
  0006d	50		 push	 eax
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 _strcat
  00077	83 c4 08	 add	 esp, 8

; 474  : 
; 475  :   //JL 2016.8.25
; 476  :   //hook string编码
; 477  :   int len = strlen(value);

  0007a	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _strlen
  00083	83 c4 04	 add	 esp, 4
  00086	89 85 10 00 ff
	ff		 mov	 DWORD PTR _len$[ebp], eax

; 478  :   JL_combineString_SEND(value, len);

  0008c	8b 85 10 00 ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
  00092	50		 push	 eax
  00093	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  00096	51		 push	 ecx
  00097	e8 00 00 00 00	 call	 ?JL_combineString_SEND@@YAXPADH@Z ; JL_combineString_SEND
  0009c	83 c4 08	 add	 esp, 8

; 479  : 
; 480  :   return len ;

  0009f	8b 85 10 00 ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]

; 481  : }

  000a5	52		 push	 edx
  000a6	8b cd		 mov	 ecx, ebp
  000a8	50		 push	 eax
  000a9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@util_mkstr
  000af	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000b4	58		 pop	 eax
  000b5	5a		 pop	 edx
  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx
  000b9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000bc	33 cd		 xor	 ecx, ebp
  000be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c3	81 c4 f4 05 01
	00		 add	 esp, 67060		; 000105f4H
  000c9	3b ec		 cmp	 ebp, esp
  000cb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
$LN5@util_mkstr:
  000d4	01 00 00 00	 DD	 1
  000d8	00 00 00 00	 DD	 $LN4@util_mkstr
$LN4@util_mkstr:
  000dc	1c 00 ff ff	 DD	 -65508			; ffff001cH
  000e0	dc ff 00 00	 DD	 65500			; 0000ffdcH
  000e4	00 00 00 00	 DD	 $LN3@util_mkstr
$LN3@util_mkstr:
  000e8	74		 DB	 116			; 00000074H
  000e9	31		 DB	 49			; 00000031H
  000ea	00		 DB	 0
?util_mkstring@@YAHPAD0@Z ENDP				; util_mkstring
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?util_destring@@YAHHPAD@Z
_TEXT	SEGMENT
_len$ = -8						; size = 4
_sliceno$ = 8						; size = 4
_value$ = 12						; size = 4
?util_destring@@YAHHPAD@Z PROC				; util_destring, COMDAT

; 443  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 444  : 
; 445  : 	//printf("动态密钥3：%s\n",PersonalKey);
; 446  : 	util_shr_64to256(value, MesgSlice[sliceno], DEFAULTTABLE, PersonalKey);

  0001e	68 00 00 00 00	 push	 OFFSET ?PersonalKey@@3PADA ; PersonalKey
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@CPNIKEEC@0123456789ABCDEFGHIJKLMNOPQRSTUV@
  00028	8b 45 08	 mov	 eax, DWORD PTR _sliceno$[ebp]
  0002b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?MesgSlice@@3PAPADA ; MesgSlice
  00031	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00034	52		 push	 edx
  00035	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?util_shr_64to256@@YAHPAD000@Z ; util_shr_64to256
  0003e	83 c4 10	 add	 esp, 16			; 00000010H

; 447  : 	extern int g_服务器;
; 448  : 	if (g_服务器 == SERVER_台服){

  00041	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_服务器@@3HA, 1 ; g_服务器
  00048	75 10		 jne	 SHORT $LN2@util_destr

; 449  : 		BIG52GBK(value);

  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  0004d	e8 00 00 00 00	 call	 ?BIG52GBK@@YIXPAD@Z	; BIG52GBK

; 450  : 		GBK2GB(value);

  00052	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  00055	e8 00 00 00 00	 call	 ?GBK2GB@@YIXPAD@Z	; GBK2GB
$LN2@util_destr:

; 451  : 	}
; 452  : 
; 453  : 
; 454  : 	//JL 2016.8.23
; 455  : 	//hook string解码
; 456  : 	int len = strlen(value);

  0005a	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _strlen
  00063	83 c4 04	 add	 esp, 4
  00066	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 457  : 	JL_combineString_RECV(value, len);

  00069	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  00070	51		 push	 ecx
  00071	e8 00 00 00 00	 call	 ?JL_combineString_RECV@@YAXPADH@Z ; JL_combineString_RECV
  00076	83 c4 08	 add	 esp, 8

; 458  : 
; 459  : 	return len; 

  00079	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]

; 460  : }

  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00085	3b ec		 cmp	 ebp, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
?util_destring@@YAHHPAD@Z ENDP				; util_destring
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?util_mkint@@YAHPADH@Z
_TEXT	SEGMENT
_t3$ = -4128						; size = 4096
_t2$ = -24						; size = 4
_t1$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_value$ = 12						; size = 4
?util_mkint@@YAHPADH@Z PROC				; util_mkint, COMDAT

; 419  : int util_mkint(char *buffer, int value){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 24 16 00 00	 mov	 eax, 5668		; 00001624H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8d bd dc e9 ff
	ff		 lea	 edi, DWORD PTR [ebp-5668]
  00016	b9 89 05 00 00	 mov	 ecx, 1417		; 00000589H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 420  :   int t1, t2;
; 421  :   char t3[4096];
; 422  :   util_swapint(&t1, &value, "3142");

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_04FJNJEMEN@3142?$AA@
  00031	8d 45 0c	 lea	 eax, DWORD PTR _value$[ebp]
  00034	50		 push	 eax
  00035	8d 4d f4	 lea	 ecx, DWORD PTR _t1$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ?util_swapint@@YAXPAH0PAD@Z ; util_swapint
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 423  :   t2 = t1 ^ 0xffffffff;

  00041	8b 45 f4	 mov	 eax, DWORD PTR _t1$[ebp]
  00044	83 f0 ff	 xor	 eax, -1
  00047	89 45 e8	 mov	 DWORD PTR _t2$[ebp], eax

; 424  : 
; 425  :   //printf("动态密钥2：%s\n",PersonalKey);
; 426  :   util_256to64_shr(t3, (char *) &t2, sizeof(int), DEFAULTTABLE, PersonalKey);

  0004a	68 00 00 00 00	 push	 OFFSET ?PersonalKey@@3PADA ; PersonalKey
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@CPNIKEEC@0123456789ABCDEFGHIJKLMNOPQRSTUV@
  00054	6a 04		 push	 4
  00056	8d 45 e8	 lea	 eax, DWORD PTR _t2$[ebp]
  00059	50		 push	 eax
  0005a	8d 8d e0 ef ff
	ff		 lea	 ecx, DWORD PTR _t3$[ebp]
  00060	51		 push	 ecx
  00061	e8 00 00 00 00	 call	 ?util_256to64_shr@@YAHPAD0H00@Z ; util_256to64_shr
  00066	83 c4 14	 add	 esp, 20			; 00000014H

; 427  :   strcat(buffer, ";");	// It's important to append a SEPARATOR between fields

  00069	68 00 00 00 00	 push	 OFFSET ??_C@_01ICJEACDI@?$DL?$AA@
  0006e	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 _strcat
  00077	83 c4 08	 add	 esp, 8

; 428  :   strcat(buffer, t3);

  0007a	8d 85 e0 ef ff
	ff		 lea	 eax, DWORD PTR _t3$[ebp]
  00080	50		 push	 eax
  00081	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00084	51		 push	 ecx
  00085	e8 00 00 00 00	 call	 _strcat
  0008a	83 c4 08	 add	 esp, 8

; 429  : 
; 430  :   //JL 2016.8.25
; 431  :   JL_combineInt_SEND(value);

  0008d	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ?JL_combineInt_SEND@@YAXH@Z ; JL_combineInt_SEND
  00096	83 c4 04	 add	 esp, 4

; 432  : 
; 433  :   return value;

  00099	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]

; 434  : }

  0009c	52		 push	 edx
  0009d	8b cd		 mov	 ecx, ebp
  0009f	50		 push	 eax
  000a0	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@util_mkint
  000a6	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000ab	58		 pop	 eax
  000ac	5a		 pop	 edx
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b3	33 cd		 xor	 ecx, ebp
  000b5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ba	81 c4 24 16 00
	00		 add	 esp, 5668		; 00001624H
  000c0	3b ec		 cmp	 ebp, esp
  000c2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
  000cb	90		 npad	 1
$LN7@util_mkint:
  000cc	03 00 00 00	 DD	 3
  000d0	00 00 00 00	 DD	 $LN6@util_mkint
$LN6@util_mkint:
  000d4	f4 ff ff ff	 DD	 -12			; fffffff4H
  000d8	04 00 00 00	 DD	 4
  000dc	00 00 00 00	 DD	 $LN3@util_mkint
  000e0	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000e4	04 00 00 00	 DD	 4
  000e8	00 00 00 00	 DD	 $LN4@util_mkint
  000ec	e0 ef ff ff	 DD	 -4128			; ffffefe0H
  000f0	00 10 00 00	 DD	 4096			; 00001000H
  000f4	00 00 00 00	 DD	 $LN5@util_mkint
$LN5@util_mkint:
  000f8	74		 DB	 116			; 00000074H
  000f9	33		 DB	 51			; 00000033H
  000fa	00		 DB	 0
$LN4@util_mkint:
  000fb	74		 DB	 116			; 00000074H
  000fc	32		 DB	 50			; 00000032H
  000fd	00		 DB	 0
$LN3@util_mkint:
  000fe	74		 DB	 116			; 00000074H
  000ff	31		 DB	 49			; 00000031H
  00100	00		 DB	 0
?util_mkint@@YAHPADH@Z ENDP				; util_mkint
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?util_deint@@YAHHPAH@Z
_TEXT	SEGMENT
_addr$ = -4140						; size = 4
_t3$ = -4128						; size = 4096
_t2$ = -24						; size = 4
_t1$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_sliceno$ = 8						; size = 4
_value$ = 12						; size = 4
?util_deint@@YAHHPAH@Z PROC				; util_deint, COMDAT

; 394  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 30 16 00 00	 mov	 eax, 5680		; 00001630H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8d bd d0 e9 ff
	ff		 lea	 edi, DWORD PTR [ebp-5680]
  00016	b9 8c 05 00 00	 mov	 ecx, 1420		; 0000058cH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 395  :   int *t1, t2;
; 396  :   char t3[4096];
; 397  :   int addr;
; 398  :   __asm
; 399  :   {
; 400  : 	  push dword ptr[ebp + 4];

  0002c	ff 75 04	 push	 DWORD PTR [ebp+4]

; 401  : 	  pop addr;

  0002f	8f 85 d4 ef ff
	ff		 pop	 DWORD PTR _addr$[ebp]

; 402  :   }
; 403  :   //printf("动态密钥1：%s\n",PersonalKey);
; 404  :   util_shl_64to256(t3, MesgSlice[sliceno], DEFAULTTABLE, PersonalKey);

  00035	68 00 00 00 00	 push	 OFFSET ?PersonalKey@@3PADA ; PersonalKey
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@CPNIKEEC@0123456789ABCDEFGHIJKLMNOPQRSTUV@
  0003f	8b 45 08	 mov	 eax, DWORD PTR _sliceno$[ebp]
  00042	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?MesgSlice@@3PAPADA ; MesgSlice
  00048	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0004b	52		 push	 edx
  0004c	8d 85 e0 ef ff
	ff		 lea	 eax, DWORD PTR _t3$[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ?util_shl_64to256@@YAHPAD000@Z ; util_shl_64to256
  00058	83 c4 10	 add	 esp, 16			; 00000010H

; 405  :   t1 = (int *) t3;

  0005b	8d 85 e0 ef ff
	ff		 lea	 eax, DWORD PTR _t3$[ebp]
  00061	89 45 f4	 mov	 DWORD PTR _t1$[ebp], eax

; 406  :   t2 = *t1 ^ 0xffffffff;

  00064	8b 45 f4	 mov	 eax, DWORD PTR _t1$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	83 f1 ff	 xor	 ecx, -1
  0006c	89 4d e8	 mov	 DWORD PTR _t2$[ebp], ecx

; 407  :   util_swapint(value, &t2, "2413");

  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_04EMLHGGGF@2413?$AA@
  00074	8d 45 e8	 lea	 eax, DWORD PTR _t2$[ebp]
  00077	50		 push	 eax
  00078	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  0007b	51		 push	 ecx
  0007c	e8 00 00 00 00	 call	 ?util_swapint@@YAXPAH0PAD@Z ; util_swapint
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH

; 408  : 
; 409  :   //JL 2016.8.23
; 410  :   //hook 整数解码
; 411  :   JL_combineInt_RECV(*value, addr);

  00084	8b 85 d4 ef ff
	ff		 mov	 eax, DWORD PTR _addr$[ebp]
  0008a	50		 push	 eax
  0008b	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  0008e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00090	52		 push	 edx
  00091	e8 00 00 00 00	 call	 ?JL_combineInt_RECV@@YAXHH@Z ; JL_combineInt_RECV
  00096	83 c4 08	 add	 esp, 8

; 412  : 
; 413  : 
; 414  : 
; 415  :   return *value;

  00099	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  0009c	8b 00		 mov	 eax, DWORD PTR [eax]

; 416  : }

  0009e	52		 push	 edx
  0009f	8b cd		 mov	 ecx, ebp
  000a1	50		 push	 eax
  000a2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@util_deint
  000a8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000ad	58		 pop	 eax
  000ae	5a		 pop	 edx
  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx
  000b2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b5	33 cd		 xor	 ecx, ebp
  000b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bc	81 c4 30 16 00
	00		 add	 esp, 5680		; 00001630H
  000c2	3b ec		 cmp	 ebp, esp
  000c4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
  000cd	0f 1f 00	 npad	 3
$LN7@util_deint:
  000d0	03 00 00 00	 DD	 3
  000d4	00 00 00 00	 DD	 $LN6@util_deint
$LN6@util_deint:
  000d8	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000dc	04 00 00 00	 DD	 4
  000e0	00 00 00 00	 DD	 $LN3@util_deint
  000e4	e0 ef ff ff	 DD	 -4128			; ffffefe0H
  000e8	00 10 00 00	 DD	 4096			; 00001000H
  000ec	00 00 00 00	 DD	 $LN4@util_deint
  000f0	d4 ef ff ff	 DD	 -4140			; ffffefd4H
  000f4	04 00 00 00	 DD	 4
  000f8	00 00 00 00	 DD	 $LN5@util_deint
$LN5@util_deint:
  000fc	61		 DB	 97			; 00000061H
  000fd	64		 DB	 100			; 00000064H
  000fe	64		 DB	 100			; 00000064H
  000ff	72		 DB	 114			; 00000072H
  00100	00		 DB	 0
$LN4@util_deint:
  00101	74		 DB	 116			; 00000074H
  00102	33		 DB	 51			; 00000033H
  00103	00		 DB	 0
$LN3@util_deint:
  00104	74		 DB	 116			; 00000074H
  00105	32		 DB	 50			; 00000032H
  00106	00		 DB	 0
?util_deint@@YAHHPAH@Z ENDP				; util_deint
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?util_shlstring@@YAXPAD0H@Z
_TEXT	SEGMENT
_ptr$ = -8						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_offs$ = 16						; size = 4
?util_shlstring@@YAXPAD0H@Z PROC			; util_shlstring, COMDAT

; 381  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 382  :   char *ptr;
; 383  :   if (!dst || !src || (strlen(src)<1)) return;

  0001e	83 7d 08 00	 cmp	 DWORD PTR _dst$[ebp], 0
  00022	74 17		 je	 SHORT $LN3@util_shlst
  00024	83 7d 0c 00	 cmp	 DWORD PTR _src$[ebp], 0
  00028	74 11		 je	 SHORT $LN3@util_shlst
  0002a	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _strlen
  00033	83 c4 04	 add	 esp, 4
  00036	83 f8 01	 cmp	 eax, 1
  00039	73 02		 jae	 SHORT $LN2@util_shlst
$LN3@util_shlst:
  0003b	eb 62		 jmp	 SHORT $LN1@util_shlst
$LN2@util_shlst:

; 384  :   
; 385  :   offs = offs % strlen(src);

  0003d	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _strlen
  00046	83 c4 04	 add	 esp, 4
  00049	8b c8		 mov	 ecx, eax
  0004b	8b 45 10	 mov	 eax, DWORD PTR _offs$[ebp]
  0004e	33 d2		 xor	 edx, edx
  00050	f7 f1		 div	 ecx
  00052	89 55 10	 mov	 DWORD PTR _offs$[ebp], edx

; 386  :   ptr = src+offs;

  00055	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00058	03 45 10	 add	 eax, DWORD PTR _offs$[ebp]
  0005b	89 45 f8	 mov	 DWORD PTR _ptr$[ebp], eax

; 387  :   strcpy(dst, ptr);

  0005e	8b 45 f8	 mov	 eax, DWORD PTR _ptr$[ebp]
  00061	50		 push	 eax
  00062	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 _strcpy
  0006b	83 c4 08	 add	 esp, 8

; 388  :   strncat(dst, src, offs);

  0006e	8b f4		 mov	 esi, esp
  00070	8b 45 10	 mov	 eax, DWORD PTR _offs$[ebp]
  00073	50		 push	 eax
  00074	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00077	51		 push	 ecx
  00078	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  0007b	52		 push	 edx
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncat
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH
  00085	3b f4		 cmp	 esi, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 389  :   dst[strlen(src)]='\0';

  0008c	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 _strlen
  00095	83 c4 04	 add	 esp, 4
  00098	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0009b	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0
$LN1@util_shlst:

; 390  : }

  0009f	5f		 pop	 edi
  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx
  000a2	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000a8	3b ec		 cmp	 ebp, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
?util_shlstring@@YAXPAD0H@Z ENDP			; util_shlstring
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?util_shrstring@@YAXPAD0H@Z
_TEXT	SEGMENT
_len$ = -20						; size = 4
_ptr$ = -8						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_offs$ = 16						; size = 4
?util_shrstring@@YAXPAD0H@Z PROC			; util_shrstring, COMDAT

; 365  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 366  :   char *ptr;
; 367  :   int len = strlen(src);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _strlen
  00027	83 c4 04	 add	 esp, 4
  0002a	89 45 ec	 mov	 DWORD PTR _len$[ebp], eax

; 368  :   if (!dst || !src || (strlen(src)<1)) return;

  0002d	83 7d 08 00	 cmp	 DWORD PTR _dst$[ebp], 0
  00031	74 17		 je	 SHORT $LN3@util_shrst
  00033	83 7d 0c 00	 cmp	 DWORD PTR _src$[ebp], 0
  00037	74 11		 je	 SHORT $LN3@util_shrst
  00039	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _strlen
  00042	83 c4 04	 add	 esp, 4
  00045	83 f8 01	 cmp	 eax, 1
  00048	73 02		 jae	 SHORT $LN2@util_shrst
$LN3@util_shrst:
  0004a	eb 72		 jmp	 SHORT $LN1@util_shrst
$LN2@util_shrst:

; 369  :   
; 370  :   offs = strlen(src) - (offs % strlen(src));

  0004c	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _strlen
  00055	83 c4 04	 add	 esp, 4
  00058	8b f0		 mov	 esi, eax
  0005a	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 _strlen
  00063	83 c4 04	 add	 esp, 4
  00066	8b c8		 mov	 ecx, eax
  00068	8b 45 10	 mov	 eax, DWORD PTR _offs$[ebp]
  0006b	33 d2		 xor	 edx, edx
  0006d	f7 f1		 div	 ecx
  0006f	2b f2		 sub	 esi, edx
  00071	89 75 10	 mov	 DWORD PTR _offs$[ebp], esi

; 371  :   ptr = src+offs;

  00074	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00077	03 45 10	 add	 eax, DWORD PTR _offs$[ebp]
  0007a	89 45 f8	 mov	 DWORD PTR _ptr$[ebp], eax

; 372  :   strcpy(dst, ptr);

  0007d	8b 45 f8	 mov	 eax, DWORD PTR _ptr$[ebp]
  00080	50		 push	 eax
  00081	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00084	51		 push	 ecx
  00085	e8 00 00 00 00	 call	 _strcpy
  0008a	83 c4 08	 add	 esp, 8

; 373  :   strncat(dst, src, offs);

  0008d	8b f4		 mov	 esi, esp
  0008f	8b 45 10	 mov	 eax, DWORD PTR _offs$[ebp]
  00092	50		 push	 eax
  00093	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00096	51		 push	 ecx
  00097	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  0009a	52		 push	 edx
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncat
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a4	3b f4		 cmp	 esi, esp
  000a6	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 374  :   dst[strlen(src)]='\0';

  000ab	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 _strlen
  000b4	83 c4 04	 add	 esp, 4
  000b7	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000ba	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0
$LN1@util_shrst:

; 375  : }

  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi
  000c0	5b		 pop	 ebx
  000c1	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000c7	3b ec		 cmp	 ebp, esp
  000c9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
?util_shrstring@@YAXPAD0H@Z ENDP			; util_shrstring
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?util_xorstring@@YAXPAD0@Z
_TEXT	SEGMENT
_i$ = -8						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
?util_xorstring@@YAXPAD0@Z PROC				; util_xorstring, COMDAT

; 356  : void util_xorstring(char *dst, char *src){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 357  :   unsigned int i;
; 358  :   
; 359  :   for (i=0; i<strlen(src); i++) dst[i]=src[i]^255;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00025	eb 09		 jmp	 SHORT $LN4@util_xorst
$LN2@util_xorst:
  00027	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0002a	83 c0 01	 add	 eax, 1
  0002d	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@util_xorst:
  00030	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _strlen
  00039	83 c4 04	 add	 esp, 4
  0003c	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  0003f	73 19		 jae	 SHORT $LN3@util_xorst
  00041	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00044	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00047	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0004a	81 f1 ff 00 00
	00		 xor	 ecx, 255		; 000000ffH
  00050	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  00053	03 55 f8	 add	 edx, DWORD PTR _i$[ebp]
  00056	88 0a		 mov	 BYTE PTR [edx], cl
  00058	eb cd		 jmp	 SHORT $LN2@util_xorst
$LN3@util_xorst:

; 360  :   dst[i]='\0';

  0005a	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  0005d	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00060	c6 00 00	 mov	 BYTE PTR [eax], 0

; 361  : }

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?util_xorstring@@YAXPAD0@Z ENDP				; util_xorstring
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?util_swapint@@YAXPAH0PAD@Z
_TEXT	SEGMENT
_i$ = -32						; size = 4
_qtr$ = -20						; size = 4
_ptr$ = -8						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_rule$ = 16						; size = 4
?util_swapint@@YAXPAH0PAD@Z PROC			; util_swapint, COMDAT

; 346  : void util_swapint(int *dst, int *src, char *rule){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 347  :   char *ptr, *qtr;
; 348  :   int i;
; 349  : 
; 350  :   ptr = (char *) src;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR _ptr$[ebp], eax

; 351  :   qtr = (char *) dst;

  00024	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00027	89 45 ec	 mov	 DWORD PTR _qtr$[ebp], eax

; 352  :   for (i=0; i<4; i++) qtr[rule[i]-'1']=ptr[i];

  0002a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00031	eb 09		 jmp	 SHORT $LN4@util_swapi
$LN2@util_swapi:
  00033	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  00036	83 c0 01	 add	 eax, 1
  00039	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax
$LN4@util_swapi:
  0003c	83 7d e0 04	 cmp	 DWORD PTR _i$[ebp], 4
  00040	7d 1a		 jge	 SHORT $LN1@util_swapi
  00042	8b 45 10	 mov	 eax, DWORD PTR _rule$[ebp]
  00045	03 45 e0	 add	 eax, DWORD PTR _i$[ebp]
  00048	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0004b	8b 55 f8	 mov	 edx, DWORD PTR _ptr$[ebp]
  0004e	03 55 e0	 add	 edx, DWORD PTR _i$[ebp]
  00051	8b 45 ec	 mov	 eax, DWORD PTR _qtr$[ebp]
  00054	8a 12		 mov	 dl, BYTE PTR [edx]
  00056	88 54 08 cf	 mov	 BYTE PTR [eax+ecx-49], dl
  0005a	eb d7		 jmp	 SHORT $LN2@util_swapi
$LN1@util_swapi:

; 353  : }

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?util_swapint@@YAXPAH0PAD@Z ENDP			; util_swapint
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?util_shr_64to256@@YAHPAD000@Z
_TEXT	SEGMENT
_c$ = -77						; size = 1
_ptr$ = -68						; size = 4
_k$ = -56						; size = 4
_j$ = -44						; size = 4
_i$ = -32						; size = 4
_dwcounter$ = -20					; size = 4
_dw$ = -8						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_table$ = 16						; size = 4
_key$ = 20						; size = 4
?util_shr_64to256@@YAHPAD000@Z PROC			; util_shr_64to256, COMDAT

; 309  : int util_shr_64to256(char *dst, char *src, char *table, char *key){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd ec fe ff
	ff		 lea	 edi, DWORD PTR [ebp-276]
  00012	b9 45 00 00 00	 mov	 ecx, 69			; 00000045H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 310  :   unsigned int dw,dwcounter,i,j,k;
; 311  :   char *ptr = NULL;

  0001e	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _ptr$[ebp], 0

; 312  : 
; 313  :   if (!key || (strlen(key)<1)) return 0;	// must have key

  00025	83 7d 14 00	 cmp	 DWORD PTR _key$[ebp], 0
  00029	74 11		 je	 SHORT $LN9@util_shr_6
  0002b	8b 45 14	 mov	 eax, DWORD PTR _key$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _strlen
  00034	83 c4 04	 add	 esp, 4
  00037	83 f8 01	 cmp	 eax, 1
  0003a	73 07		 jae	 SHORT $LN8@util_shr_6
$LN9@util_shr_6:
  0003c	33 c0		 xor	 eax, eax
  0003e	e9 a8 01 00 00	 jmp	 $LN1@util_shr_6
$LN8@util_shr_6:

; 314  : 
; 315  :   dw=0;

  00043	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dw$[ebp], 0

; 316  :   dwcounter=0;

  0004a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _dwcounter$[ebp], 0

; 317  :   j=0;

  00051	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0

; 318  :   if (!dst || !src || !table) return 0;

  00058	83 7d 08 00	 cmp	 DWORD PTR _dst$[ebp], 0
  0005c	74 0c		 je	 SHORT $LN11@util_shr_6
  0005e	83 7d 0c 00	 cmp	 DWORD PTR _src$[ebp], 0
  00062	74 06		 je	 SHORT $LN11@util_shr_6
  00064	83 7d 10 00	 cmp	 DWORD PTR _table$[ebp], 0
  00068	75 07		 jne	 SHORT $LN10@util_shr_6
$LN11@util_shr_6:
  0006a	33 c0		 xor	 eax, eax
  0006c	e9 7a 01 00 00	 jmp	 $LN1@util_shr_6
$LN10@util_shr_6:

; 319  :   char c;
; 320  :   for (i=0; i<strlen(src); i++) {

  00071	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00078	eb 09		 jmp	 SHORT $LN4@util_shr_6
$LN2@util_shr_6:
  0007a	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  0007d	83 c0 01	 add	 eax, 1
  00080	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax
$LN4@util_shr_6:
  00083	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _strlen
  0008c	83 c4 04	 add	 esp, 4
  0008f	39 45 e0	 cmp	 DWORD PTR _i$[ebp], eax
  00092	0f 83 28 01 00
	00		 jae	 $LN3@util_shr_6

; 321  : 	  c = src[i];

  00098	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0009b	03 45 e0	 add	 eax, DWORD PTR _i$[ebp]
  0009e	8a 08		 mov	 cl, BYTE PTR [eax]
  000a0	88 4d b3	 mov	 BYTE PTR _c$[ebp], cl

; 322  : 	  for( k = 0; k < strlen(table); k++){

  000a3	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  000aa	eb 09		 jmp	 SHORT $LN7@util_shr_6
$LN5@util_shr_6:
  000ac	8b 45 c8	 mov	 eax, DWORD PTR _k$[ebp]
  000af	83 c0 01	 add	 eax, 1
  000b2	89 45 c8	 mov	 DWORD PTR _k$[ebp], eax
$LN7@util_shr_6:
  000b5	8b 45 10	 mov	 eax, DWORD PTR _table$[ebp]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 _strlen
  000be	83 c4 04	 add	 esp, 4
  000c1	39 45 c8	 cmp	 DWORD PTR _k$[ebp], eax
  000c4	73 1e		 jae	 SHORT $LN6@util_shr_6

; 323  : 		  if( table[k] == c){

  000c6	8b 45 10	 mov	 eax, DWORD PTR _table$[ebp]
  000c9	03 45 c8	 add	 eax, DWORD PTR _k$[ebp]
  000cc	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000cf	0f be 55 b3	 movsx	 edx, BYTE PTR _c$[ebp]
  000d3	3b ca		 cmp	 ecx, edx
  000d5	75 0b		 jne	 SHORT $LN12@util_shr_6

; 324  : 			  ptr = table+k;

  000d7	8b 45 10	 mov	 eax, DWORD PTR _table$[ebp]
  000da	03 45 c8	 add	 eax, DWORD PTR _k$[ebp]
  000dd	89 45 bc	 mov	 DWORD PTR _ptr$[ebp], eax

; 325  : 			  break;

  000e0	eb 02		 jmp	 SHORT $LN6@util_shr_6
$LN12@util_shr_6:

; 326  : 		  }
; 327  : 	  }

  000e2	eb c8		 jmp	 SHORT $LN5@util_shr_6
$LN6@util_shr_6:

; 328  :     if (!ptr) return 0;

  000e4	83 7d bc 00	 cmp	 DWORD PTR _ptr$[ebp], 0
  000e8	75 07		 jne	 SHORT $LN13@util_shr_6
  000ea	33 c0		 xor	 eax, eax
  000ec	e9 fa 00 00 00	 jmp	 $LN1@util_shr_6
$LN13@util_shr_6:

; 329  :     if (i%4) {

  000f1	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  000f4	33 d2		 xor	 edx, edx
  000f6	b9 04 00 00 00	 mov	 ecx, 4
  000fb	f7 f1		 div	 ecx
  000fd	85 d2		 test	 edx, edx
  000ff	74 7d		 je	 SHORT $LN14@util_shr_6

; 330  :       dw = ((((unsigned int)(ptr-table) & 0x3f) + key[j]) % 64)

  00101	8b 45 bc	 mov	 eax, DWORD PTR _ptr$[ebp]
  00104	2b 45 10	 sub	 eax, DWORD PTR _table$[ebp]
  00107	83 e0 3f	 and	 eax, 63			; 0000003fH
  0010a	8b 4d 14	 mov	 ecx, DWORD PTR _key$[ebp]
  0010d	03 4d d4	 add	 ecx, DWORD PTR _j$[ebp]
  00110	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00113	03 c2		 add	 eax, edx
  00115	33 d2		 xor	 edx, edx
  00117	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0011c	f7 f1		 div	 ecx
  0011e	8b f2		 mov	 esi, edx
  00120	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  00123	33 d2		 xor	 edx, edx
  00125	b9 04 00 00 00	 mov	 ecx, 4
  0012a	f7 f1		 div	 ecx
  0012c	b9 04 00 00 00	 mov	 ecx, 4
  00131	2b ca		 sub	 ecx, edx
  00133	d1 e1		 shl	 ecx, 1
  00135	d3 e6		 shl	 esi, cl
  00137	0b 75 f8	 or	 esi, DWORD PTR _dw$[ebp]
  0013a	89 75 f8	 mov	 DWORD PTR _dw$[ebp], esi

; 331  :            << ((4-(i%4))<<1) | dw;
; 332  :       j++;  if (!key[j]) j=0;

  0013d	8b 45 d4	 mov	 eax, DWORD PTR _j$[ebp]
  00140	83 c0 01	 add	 eax, 1
  00143	89 45 d4	 mov	 DWORD PTR _j$[ebp], eax
  00146	8b 45 14	 mov	 eax, DWORD PTR _key$[ebp]
  00149	03 45 d4	 add	 eax, DWORD PTR _j$[ebp]
  0014c	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0014f	85 c9		 test	 ecx, ecx
  00151	75 07		 jne	 SHORT $LN16@util_shr_6
  00153	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
$LN16@util_shr_6:

; 333  :       dst[ dwcounter++ ] = dw & 0xff;

  0015a	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  0015d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00162	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00165	03 4d ec	 add	 ecx, DWORD PTR _dwcounter$[ebp]
  00168	88 01		 mov	 BYTE PTR [ecx], al
  0016a	8b 55 ec	 mov	 edx, DWORD PTR _dwcounter$[ebp]
  0016d	83 c2 01	 add	 edx, 1
  00170	89 55 ec	 mov	 DWORD PTR _dwcounter$[ebp], edx

; 334  :       dw = dw >> 8;

  00173	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  00176	c1 e8 08	 shr	 eax, 8
  00179	89 45 f8	 mov	 DWORD PTR _dw$[ebp], eax

; 335  :     } else {

  0017c	eb 3d		 jmp	 SHORT $LN15@util_shr_6
$LN14@util_shr_6:

; 336  :       dw = (((unsigned int)(ptr-table) & 0x3f) + key[j]) % 64;

  0017e	8b 45 bc	 mov	 eax, DWORD PTR _ptr$[ebp]
  00181	2b 45 10	 sub	 eax, DWORD PTR _table$[ebp]
  00184	83 e0 3f	 and	 eax, 63			; 0000003fH
  00187	8b 4d 14	 mov	 ecx, DWORD PTR _key$[ebp]
  0018a	03 4d d4	 add	 ecx, DWORD PTR _j$[ebp]
  0018d	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00190	03 c2		 add	 eax, edx
  00192	33 d2		 xor	 edx, edx
  00194	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00199	f7 f1		 div	 ecx
  0019b	89 55 f8	 mov	 DWORD PTR _dw$[ebp], edx

; 337  :       j++;  if (!key[j]) j=0;

  0019e	8b 45 d4	 mov	 eax, DWORD PTR _j$[ebp]
  001a1	83 c0 01	 add	 eax, 1
  001a4	89 45 d4	 mov	 DWORD PTR _j$[ebp], eax
  001a7	8b 45 14	 mov	 eax, DWORD PTR _key$[ebp]
  001aa	03 45 d4	 add	 eax, DWORD PTR _j$[ebp]
  001ad	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001b0	85 c9		 test	 ecx, ecx
  001b2	75 07		 jne	 SHORT $LN15@util_shr_6
  001b4	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
$LN15@util_shr_6:

; 338  :     }
; 339  :   }

  001bb	e9 ba fe ff ff	 jmp	 $LN2@util_shr_6
$LN3@util_shr_6:

; 340  :   if (dw) dst[ dwcounter++ ] = dw & 0xff;

  001c0	83 7d f8 00	 cmp	 DWORD PTR _dw$[ebp], 0
  001c4	74 19		 je	 SHORT $LN18@util_shr_6
  001c6	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  001c9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001ce	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  001d1	03 4d ec	 add	 ecx, DWORD PTR _dwcounter$[ebp]
  001d4	88 01		 mov	 BYTE PTR [ecx], al
  001d6	8b 55 ec	 mov	 edx, DWORD PTR _dwcounter$[ebp]
  001d9	83 c2 01	 add	 edx, 1
  001dc	89 55 ec	 mov	 DWORD PTR _dwcounter$[ebp], edx
$LN18@util_shr_6:

; 341  :   dst[ dwcounter ] = '\0';

  001df	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  001e2	03 45 ec	 add	 eax, DWORD PTR _dwcounter$[ebp]
  001e5	c6 00 00	 mov	 BYTE PTR [eax], 0

; 342  :   return dwcounter;

  001e8	8b 45 ec	 mov	 eax, DWORD PTR _dwcounter$[ebp]
$LN1@util_shr_6:

; 343  : }

  001eb	5f		 pop	 edi
  001ec	5e		 pop	 esi
  001ed	5b		 pop	 ebx
  001ee	81 c4 14 01 00
	00		 add	 esp, 276		; 00000114H
  001f4	3b ec		 cmp	 ebp, esp
  001f6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001fb	8b e5		 mov	 esp, ebp
  001fd	5d		 pop	 ebp
  001fe	c3		 ret	 0
?util_shr_64to256@@YAHPAD000@Z ENDP			; util_shr_64to256
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?util_256to64_shl@@YAHPAD0H00@Z
_TEXT	SEGMENT
_j$ = -44						; size = 4
_i$ = -32						; size = 4
_dwcounter$ = -20					; size = 4
_dw$ = -8						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_len$ = 16						; size = 4
_table$ = 20						; size = 4
_key$ = 24						; size = 4
?util_256to64_shl@@YAHPAD0H00@Z PROC			; util_256to64_shl, COMDAT

; 283  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 284  :   unsigned int dw,dwcounter;
; 285  :   int i, j;
; 286  : 
; 287  :   if (!dst || !src || !table || !key) return 0;

  0001e	83 7d 08 00	 cmp	 DWORD PTR _dst$[ebp], 0
  00022	74 12		 je	 SHORT $LN6@util_256to
  00024	83 7d 0c 00	 cmp	 DWORD PTR _src$[ebp], 0
  00028	74 0c		 je	 SHORT $LN6@util_256to
  0002a	83 7d 14 00	 cmp	 DWORD PTR _table$[ebp], 0
  0002e	74 06		 je	 SHORT $LN6@util_256to
  00030	83 7d 18 00	 cmp	 DWORD PTR _key$[ebp], 0
  00034	75 07		 jne	 SHORT $LN5@util_256to
$LN6@util_256to:
  00036	33 c0		 xor	 eax, eax
  00038	e9 7b 01 00 00	 jmp	 $LN1@util_256to
$LN5@util_256to:

; 288  :   if (strlen(key)<1) return 0;	// key can't be empty.

  0003d	8b 45 18	 mov	 eax, DWORD PTR _key$[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _strlen
  00046	83 c4 04	 add	 esp, 4
  00049	83 f8 01	 cmp	 eax, 1
  0004c	73 07		 jae	 SHORT $LN7@util_256to
  0004e	33 c0		 xor	 eax, eax
  00050	e9 63 01 00 00	 jmp	 $LN1@util_256to
$LN7@util_256to:

; 289  :   dw=0;

  00055	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dw$[ebp], 0

; 290  :   dwcounter=0;

  0005c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _dwcounter$[ebp], 0

; 291  :   j=0;

  00063	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0

; 292  :   for (i=0; i<len; i++) {

  0006a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00071	eb 09		 jmp	 SHORT $LN4@util_256to
$LN2@util_256to:
  00073	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  00076	83 c0 01	 add	 eax, 1
  00079	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax
$LN4@util_256to:
  0007c	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  0007f	3b 45 10	 cmp	 eax, DWORD PTR _len$[ebp]
  00082	0f 8d ed 00 00
	00		 jge	 $LN3@util_256to

; 293  :     dw = ( ((unsigned int)src[i] & 0xff) << ((i%3)<<1) ) | dw;

  00088	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0008b	03 45 e0	 add	 eax, DWORD PTR _i$[ebp]
  0008e	0f be 30	 movsx	 esi, BYTE PTR [eax]
  00091	81 e6 ff 00 00
	00		 and	 esi, 255		; 000000ffH
  00097	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  0009a	99		 cdq
  0009b	b9 03 00 00 00	 mov	 ecx, 3
  000a0	f7 f9		 idiv	 ecx
  000a2	d1 e2		 shl	 edx, 1
  000a4	8b ca		 mov	 ecx, edx
  000a6	d3 e6		 shl	 esi, cl
  000a8	0b 75 f8	 or	 esi, DWORD PTR _dw$[ebp]
  000ab	89 75 f8	 mov	 DWORD PTR _dw$[ebp], esi

; 294  :     dst[ dwcounter++ ] = table[ ((dw & 0x3f) + 64 - key[j]) % 64 ];	// check!

  000ae	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  000b1	83 e0 3f	 and	 eax, 63			; 0000003fH
  000b4	83 c0 40	 add	 eax, 64			; 00000040H
  000b7	8b 4d 18	 mov	 ecx, DWORD PTR _key$[ebp]
  000ba	03 4d d4	 add	 ecx, DWORD PTR _j$[ebp]
  000bd	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000c0	2b c2		 sub	 eax, edx
  000c2	33 d2		 xor	 edx, edx
  000c4	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000c9	f7 f1		 div	 ecx
  000cb	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  000ce	03 45 ec	 add	 eax, DWORD PTR _dwcounter$[ebp]
  000d1	8b 4d 14	 mov	 ecx, DWORD PTR _table$[ebp]
  000d4	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  000d7	88 10		 mov	 BYTE PTR [eax], dl
  000d9	8b 45 ec	 mov	 eax, DWORD PTR _dwcounter$[ebp]
  000dc	83 c0 01	 add	 eax, 1
  000df	89 45 ec	 mov	 DWORD PTR _dwcounter$[ebp], eax

; 295  :     j++;  if (!key[j]) j=0;

  000e2	8b 45 d4	 mov	 eax, DWORD PTR _j$[ebp]
  000e5	83 c0 01	 add	 eax, 1
  000e8	89 45 d4	 mov	 DWORD PTR _j$[ebp], eax
  000eb	8b 45 18	 mov	 eax, DWORD PTR _key$[ebp]
  000ee	03 45 d4	 add	 eax, DWORD PTR _j$[ebp]
  000f1	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000f4	85 c9		 test	 ecx, ecx
  000f6	75 07		 jne	 SHORT $LN8@util_256to
  000f8	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
$LN8@util_256to:

; 296  :     dw = ( dw >> 6 );

  000ff	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  00102	c1 e8 06	 shr	 eax, 6
  00105	89 45 f8	 mov	 DWORD PTR _dw$[ebp], eax

; 297  :     if (i%3==2) {

  00108	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  0010b	99		 cdq
  0010c	b9 03 00 00 00	 mov	 ecx, 3
  00111	f7 f9		 idiv	 ecx
  00113	83 fa 02	 cmp	 edx, 2
  00116	75 58		 jne	 SHORT $LN9@util_256to

; 298  :       dst[ dwcounter++ ] = table[ ((dw & 0x3f) + 64 - key[j]) % 64 ];	// check!

  00118	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  0011b	83 e0 3f	 and	 eax, 63			; 0000003fH
  0011e	83 c0 40	 add	 eax, 64			; 00000040H
  00121	8b 4d 18	 mov	 ecx, DWORD PTR _key$[ebp]
  00124	03 4d d4	 add	 ecx, DWORD PTR _j$[ebp]
  00127	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0012a	2b c2		 sub	 eax, edx
  0012c	33 d2		 xor	 edx, edx
  0012e	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00133	f7 f1		 div	 ecx
  00135	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00138	03 45 ec	 add	 eax, DWORD PTR _dwcounter$[ebp]
  0013b	8b 4d 14	 mov	 ecx, DWORD PTR _table$[ebp]
  0013e	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  00141	88 10		 mov	 BYTE PTR [eax], dl
  00143	8b 45 ec	 mov	 eax, DWORD PTR _dwcounter$[ebp]
  00146	83 c0 01	 add	 eax, 1
  00149	89 45 ec	 mov	 DWORD PTR _dwcounter$[ebp], eax

; 299  :       j++;  if (!key[j]) j=0;

  0014c	8b 45 d4	 mov	 eax, DWORD PTR _j$[ebp]
  0014f	83 c0 01	 add	 eax, 1
  00152	89 45 d4	 mov	 DWORD PTR _j$[ebp], eax
  00155	8b 45 18	 mov	 eax, DWORD PTR _key$[ebp]
  00158	03 45 d4	 add	 eax, DWORD PTR _j$[ebp]
  0015b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0015e	85 c9		 test	 ecx, ecx
  00160	75 07		 jne	 SHORT $LN10@util_256to
  00162	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
$LN10@util_256to:

; 300  :       dw = 0;

  00169	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dw$[ebp], 0
$LN9@util_256to:

; 301  :     }
; 302  :   }

  00170	e9 fe fe ff ff	 jmp	 $LN2@util_256to
$LN3@util_256to:

; 303  :   if (dw) dst[ dwcounter++ ] = table[ (dw + 64 - key[j]) % 64 ];	// check!

  00175	83 7d f8 00	 cmp	 DWORD PTR _dw$[ebp], 0
  00179	74 31		 je	 SHORT $LN11@util_256to
  0017b	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  0017e	83 c0 40	 add	 eax, 64			; 00000040H
  00181	8b 4d 18	 mov	 ecx, DWORD PTR _key$[ebp]
  00184	03 4d d4	 add	 ecx, DWORD PTR _j$[ebp]
  00187	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0018a	2b c2		 sub	 eax, edx
  0018c	33 d2		 xor	 edx, edx
  0018e	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00193	f7 f1		 div	 ecx
  00195	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00198	03 45 ec	 add	 eax, DWORD PTR _dwcounter$[ebp]
  0019b	8b 4d 14	 mov	 ecx, DWORD PTR _table$[ebp]
  0019e	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  001a1	88 10		 mov	 BYTE PTR [eax], dl
  001a3	8b 45 ec	 mov	 eax, DWORD PTR _dwcounter$[ebp]
  001a6	83 c0 01	 add	 eax, 1
  001a9	89 45 ec	 mov	 DWORD PTR _dwcounter$[ebp], eax
$LN11@util_256to:

; 304  :   dst[ dwcounter ] = '\0';

  001ac	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  001af	03 45 ec	 add	 eax, DWORD PTR _dwcounter$[ebp]
  001b2	c6 00 00	 mov	 BYTE PTR [eax], 0

; 305  :   return dwcounter;

  001b5	8b 45 ec	 mov	 eax, DWORD PTR _dwcounter$[ebp]
$LN1@util_256to:

; 306  : }

  001b8	5f		 pop	 edi
  001b9	5e		 pop	 esi
  001ba	5b		 pop	 ebx
  001bb	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  001c1	3b ec		 cmp	 ebp, esp
  001c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c8	8b e5		 mov	 esp, ebp
  001ca	5d		 pop	 ebp
  001cb	c3		 ret	 0
?util_256to64_shl@@YAHPAD0H00@Z ENDP			; util_256to64_shl
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?util_shl_64to256@@YAHPAD000@Z
_TEXT	SEGMENT
_c$ = -77						; size = 1
_ptr$ = -68						; size = 4
_k$ = -56						; size = 4
_j$ = -44						; size = 4
_i$ = -32						; size = 4
_dwcounter$ = -20					; size = 4
_dw$ = -8						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_table$ = 16						; size = 4
_key$ = 20						; size = 4
?util_shl_64to256@@YAHPAD000@Z PROC			; util_shl_64to256, COMDAT

; 243  : int util_shl_64to256(char *dst, char *src, char *table, char *key){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd ec fe ff
	ff		 lea	 edi, DWORD PTR [ebp-276]
  00012	b9 45 00 00 00	 mov	 ecx, 69			; 00000045H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 244  :   unsigned int dw,dwcounter,i,j,k;
; 245  :   char *ptr = NULL;

  0001e	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _ptr$[ebp], 0

; 246  : 
; 247  :   if (!key || (strlen(key)<1)) return 0;	// must have key

  00025	83 7d 14 00	 cmp	 DWORD PTR _key$[ebp], 0
  00029	74 11		 je	 SHORT $LN9@util_shl_6
  0002b	8b 45 14	 mov	 eax, DWORD PTR _key$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _strlen
  00034	83 c4 04	 add	 esp, 4
  00037	83 f8 01	 cmp	 eax, 1
  0003a	73 07		 jae	 SHORT $LN8@util_shl_6
$LN9@util_shl_6:
  0003c	33 c0		 xor	 eax, eax
  0003e	e9 b2 01 00 00	 jmp	 $LN1@util_shl_6
$LN8@util_shl_6:

; 248  : 
; 249  :   dw=0;

  00043	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dw$[ebp], 0

; 250  :   dwcounter=0;

  0004a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _dwcounter$[ebp], 0

; 251  :   j=0;

  00051	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0

; 252  :   if (!dst || !src || !table) return 0;

  00058	83 7d 08 00	 cmp	 DWORD PTR _dst$[ebp], 0
  0005c	74 0c		 je	 SHORT $LN11@util_shl_6
  0005e	83 7d 0c 00	 cmp	 DWORD PTR _src$[ebp], 0
  00062	74 06		 je	 SHORT $LN11@util_shl_6
  00064	83 7d 10 00	 cmp	 DWORD PTR _table$[ebp], 0
  00068	75 07		 jne	 SHORT $LN10@util_shl_6
$LN11@util_shl_6:
  0006a	33 c0		 xor	 eax, eax
  0006c	e9 84 01 00 00	 jmp	 $LN1@util_shl_6
$LN10@util_shl_6:

; 253  :   char c;
; 254  :   for (i=0; i<strlen(src); i++) {

  00071	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00078	eb 09		 jmp	 SHORT $LN4@util_shl_6
$LN2@util_shl_6:
  0007a	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  0007d	83 c0 01	 add	 eax, 1
  00080	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax
$LN4@util_shl_6:
  00083	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _strlen
  0008c	83 c4 04	 add	 esp, 4
  0008f	39 45 e0	 cmp	 DWORD PTR _i$[ebp], eax
  00092	0f 83 32 01 00
	00		 jae	 $LN3@util_shl_6

; 255  : 	  c = src[i];

  00098	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0009b	03 45 e0	 add	 eax, DWORD PTR _i$[ebp]
  0009e	8a 08		 mov	 cl, BYTE PTR [eax]
  000a0	88 4d b3	 mov	 BYTE PTR _c$[ebp], cl

; 256  : 	  for( k = 0; k < strlen(table); k++){

  000a3	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  000aa	eb 09		 jmp	 SHORT $LN7@util_shl_6
$LN5@util_shl_6:
  000ac	8b 45 c8	 mov	 eax, DWORD PTR _k$[ebp]
  000af	83 c0 01	 add	 eax, 1
  000b2	89 45 c8	 mov	 DWORD PTR _k$[ebp], eax
$LN7@util_shl_6:
  000b5	8b 45 10	 mov	 eax, DWORD PTR _table$[ebp]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 _strlen
  000be	83 c4 04	 add	 esp, 4
  000c1	39 45 c8	 cmp	 DWORD PTR _k$[ebp], eax
  000c4	73 1e		 jae	 SHORT $LN6@util_shl_6

; 257  : 		  if( table[k] == c){

  000c6	8b 45 10	 mov	 eax, DWORD PTR _table$[ebp]
  000c9	03 45 c8	 add	 eax, DWORD PTR _k$[ebp]
  000cc	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000cf	0f be 55 b3	 movsx	 edx, BYTE PTR _c$[ebp]
  000d3	3b ca		 cmp	 ecx, edx
  000d5	75 0b		 jne	 SHORT $LN12@util_shl_6

; 258  : 			  ptr = table+k;

  000d7	8b 45 10	 mov	 eax, DWORD PTR _table$[ebp]
  000da	03 45 c8	 add	 eax, DWORD PTR _k$[ebp]
  000dd	89 45 bc	 mov	 DWORD PTR _ptr$[ebp], eax

; 259  : 			  break;

  000e0	eb 02		 jmp	 SHORT $LN6@util_shl_6
$LN12@util_shl_6:

; 260  : 		  }
; 261  : 	  }

  000e2	eb c8		 jmp	 SHORT $LN5@util_shl_6
$LN6@util_shl_6:

; 262  :     if (!ptr) return 0;

  000e4	83 7d bc 00	 cmp	 DWORD PTR _ptr$[ebp], 0
  000e8	75 07		 jne	 SHORT $LN13@util_shl_6
  000ea	33 c0		 xor	 eax, eax
  000ec	e9 04 01 00 00	 jmp	 $LN1@util_shl_6
$LN13@util_shl_6:

; 263  :     if (i%4) {

  000f1	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  000f4	33 d2		 xor	 edx, edx
  000f6	b9 04 00 00 00	 mov	 ecx, 4
  000fb	f7 f1		 div	 ecx
  000fd	85 d2		 test	 edx, edx
  000ff	0f 84 80 00 00
	00		 je	 $LN14@util_shl_6

; 264  :       // check!
; 265  :       dw = ((((unsigned int)(ptr-table) & 0x3f) + 64 - key[j]) % 64)

  00105	8b 45 bc	 mov	 eax, DWORD PTR _ptr$[ebp]
  00108	2b 45 10	 sub	 eax, DWORD PTR _table$[ebp]
  0010b	83 e0 3f	 and	 eax, 63			; 0000003fH
  0010e	83 c0 40	 add	 eax, 64			; 00000040H
  00111	8b 4d 14	 mov	 ecx, DWORD PTR _key$[ebp]
  00114	03 4d d4	 add	 ecx, DWORD PTR _j$[ebp]
  00117	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0011a	2b c2		 sub	 eax, edx
  0011c	33 d2		 xor	 edx, edx
  0011e	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00123	f7 f1		 div	 ecx
  00125	8b f2		 mov	 esi, edx
  00127	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  0012a	33 d2		 xor	 edx, edx
  0012c	b9 04 00 00 00	 mov	 ecx, 4
  00131	f7 f1		 div	 ecx
  00133	b9 04 00 00 00	 mov	 ecx, 4
  00138	2b ca		 sub	 ecx, edx
  0013a	d1 e1		 shl	 ecx, 1
  0013c	d3 e6		 shl	 esi, cl
  0013e	0b 75 f8	 or	 esi, DWORD PTR _dw$[ebp]
  00141	89 75 f8	 mov	 DWORD PTR _dw$[ebp], esi

; 266  :            << ((4-(i%4))<<1) | dw;
; 267  :       j++;  if (!key[j]) j=0;

  00144	8b 45 d4	 mov	 eax, DWORD PTR _j$[ebp]
  00147	83 c0 01	 add	 eax, 1
  0014a	89 45 d4	 mov	 DWORD PTR _j$[ebp], eax
  0014d	8b 45 14	 mov	 eax, DWORD PTR _key$[ebp]
  00150	03 45 d4	 add	 eax, DWORD PTR _j$[ebp]
  00153	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00156	85 c9		 test	 ecx, ecx
  00158	75 07		 jne	 SHORT $LN16@util_shl_6
  0015a	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
$LN16@util_shl_6:

; 268  :       dst[ dwcounter++ ] = dw & 0xff;

  00161	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  00164	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00169	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0016c	03 4d ec	 add	 ecx, DWORD PTR _dwcounter$[ebp]
  0016f	88 01		 mov	 BYTE PTR [ecx], al
  00171	8b 55 ec	 mov	 edx, DWORD PTR _dwcounter$[ebp]
  00174	83 c2 01	 add	 edx, 1
  00177	89 55 ec	 mov	 DWORD PTR _dwcounter$[ebp], edx

; 269  :       dw = dw >> 8;

  0017a	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  0017d	c1 e8 08	 shr	 eax, 8
  00180	89 45 f8	 mov	 DWORD PTR _dw$[ebp], eax

; 270  :     } else {

  00183	eb 40		 jmp	 SHORT $LN15@util_shl_6
$LN14@util_shl_6:

; 271  :       // check!
; 272  :       dw = (((unsigned int)(ptr-table) & 0x3f) + 64 - key[j]) % 64;

  00185	8b 45 bc	 mov	 eax, DWORD PTR _ptr$[ebp]
  00188	2b 45 10	 sub	 eax, DWORD PTR _table$[ebp]
  0018b	83 e0 3f	 and	 eax, 63			; 0000003fH
  0018e	83 c0 40	 add	 eax, 64			; 00000040H
  00191	8b 4d 14	 mov	 ecx, DWORD PTR _key$[ebp]
  00194	03 4d d4	 add	 ecx, DWORD PTR _j$[ebp]
  00197	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0019a	2b c2		 sub	 eax, edx
  0019c	33 d2		 xor	 edx, edx
  0019e	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  001a3	f7 f1		 div	 ecx
  001a5	89 55 f8	 mov	 DWORD PTR _dw$[ebp], edx

; 273  :       j++;  if (!key[j]) j=0;

  001a8	8b 45 d4	 mov	 eax, DWORD PTR _j$[ebp]
  001ab	83 c0 01	 add	 eax, 1
  001ae	89 45 d4	 mov	 DWORD PTR _j$[ebp], eax
  001b1	8b 45 14	 mov	 eax, DWORD PTR _key$[ebp]
  001b4	03 45 d4	 add	 eax, DWORD PTR _j$[ebp]
  001b7	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001ba	85 c9		 test	 ecx, ecx
  001bc	75 07		 jne	 SHORT $LN15@util_shl_6
  001be	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
$LN15@util_shl_6:

; 274  :     }
; 275  :   }

  001c5	e9 b0 fe ff ff	 jmp	 $LN2@util_shl_6
$LN3@util_shl_6:

; 276  :   if (dw) dst[ dwcounter++ ] = dw & 0xff;

  001ca	83 7d f8 00	 cmp	 DWORD PTR _dw$[ebp], 0
  001ce	74 19		 je	 SHORT $LN18@util_shl_6
  001d0	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  001d3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001d8	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  001db	03 4d ec	 add	 ecx, DWORD PTR _dwcounter$[ebp]
  001de	88 01		 mov	 BYTE PTR [ecx], al
  001e0	8b 55 ec	 mov	 edx, DWORD PTR _dwcounter$[ebp]
  001e3	83 c2 01	 add	 edx, 1
  001e6	89 55 ec	 mov	 DWORD PTR _dwcounter$[ebp], edx
$LN18@util_shl_6:

; 277  :   dst[ dwcounter ] = '\0';

  001e9	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  001ec	03 45 ec	 add	 eax, DWORD PTR _dwcounter$[ebp]
  001ef	c6 00 00	 mov	 BYTE PTR [eax], 0

; 278  :   return dwcounter;

  001f2	8b 45 ec	 mov	 eax, DWORD PTR _dwcounter$[ebp]
$LN1@util_shl_6:

; 279  : }

  001f5	5f		 pop	 edi
  001f6	5e		 pop	 esi
  001f7	5b		 pop	 ebx
  001f8	81 c4 14 01 00
	00		 add	 esp, 276		; 00000114H
  001fe	3b ec		 cmp	 ebp, esp
  00200	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00205	8b e5		 mov	 esp, ebp
  00207	5d		 pop	 ebp
  00208	c3		 ret	 0
?util_shl_64to256@@YAHPAD000@Z ENDP			; util_shl_64to256
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?util_256to64_shr@@YAHPAD0H00@Z
_TEXT	SEGMENT
_i$ = -44						; size = 4
_j$ = -32						; size = 4
_dwcounter$ = -20					; size = 4
_dw$ = -8						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_len$ = 16						; size = 4
_table$ = 20						; size = 4
_key$ = 24						; size = 4
?util_256to64_shr@@YAHPAD0H00@Z PROC			; util_256to64_shr, COMDAT

; 217  : int util_256to64_shr(char *dst, char *src, int len, char *table, char *key){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 218  :   unsigned int dw,dwcounter,j;
; 219  :   int i;
; 220  : 
; 221  :   if (!dst || !src || !table || !key) return 0;

  0001e	83 7d 08 00	 cmp	 DWORD PTR _dst$[ebp], 0
  00022	74 12		 je	 SHORT $LN6@util_256to
  00024	83 7d 0c 00	 cmp	 DWORD PTR _src$[ebp], 0
  00028	74 0c		 je	 SHORT $LN6@util_256to
  0002a	83 7d 14 00	 cmp	 DWORD PTR _table$[ebp], 0
  0002e	74 06		 je	 SHORT $LN6@util_256to
  00030	83 7d 18 00	 cmp	 DWORD PTR _key$[ebp], 0
  00034	75 07		 jne	 SHORT $LN5@util_256to
$LN6@util_256to:
  00036	33 c0		 xor	 eax, eax
  00038	e9 70 01 00 00	 jmp	 $LN1@util_256to
$LN5@util_256to:

; 222  :   if (strlen(key)<1) return 0;	// key can't be empty.

  0003d	8b 45 18	 mov	 eax, DWORD PTR _key$[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _strlen
  00046	83 c4 04	 add	 esp, 4
  00049	83 f8 01	 cmp	 eax, 1
  0004c	73 07		 jae	 SHORT $LN7@util_256to
  0004e	33 c0		 xor	 eax, eax
  00050	e9 58 01 00 00	 jmp	 $LN1@util_256to
$LN7@util_256to:

; 223  :   dw=0;

  00055	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dw$[ebp], 0

; 224  :   dwcounter=0;

  0005c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _dwcounter$[ebp], 0

; 225  :   j=0;

  00063	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0

; 226  :   for (i=0; i<len; i++) {

  0006a	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00071	eb 09		 jmp	 SHORT $LN4@util_256to
$LN2@util_256to:
  00073	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00076	83 c0 01	 add	 eax, 1
  00079	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@util_256to:
  0007c	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  0007f	3b 45 10	 cmp	 eax, DWORD PTR _len$[ebp]
  00082	0f 8d e7 00 00
	00		 jge	 $LN3@util_256to

; 227  :     dw = ( ((unsigned int)src[i] & 0xff) << ((i%3)<<1) ) | dw;

  00088	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0008b	03 45 d4	 add	 eax, DWORD PTR _i$[ebp]
  0008e	0f be 30	 movsx	 esi, BYTE PTR [eax]
  00091	81 e6 ff 00 00
	00		 and	 esi, 255		; 000000ffH
  00097	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  0009a	99		 cdq
  0009b	b9 03 00 00 00	 mov	 ecx, 3
  000a0	f7 f9		 idiv	 ecx
  000a2	d1 e2		 shl	 edx, 1
  000a4	8b ca		 mov	 ecx, edx
  000a6	d3 e6		 shl	 esi, cl
  000a8	0b 75 f8	 or	 esi, DWORD PTR _dw$[ebp]
  000ab	89 75 f8	 mov	 DWORD PTR _dw$[ebp], esi

; 228  :     dst[ dwcounter++ ] = table[ ((dw & 0x3f) + key[j]) % 64 ];	// check!

  000ae	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  000b1	83 e0 3f	 and	 eax, 63			; 0000003fH
  000b4	8b 4d 18	 mov	 ecx, DWORD PTR _key$[ebp]
  000b7	03 4d e0	 add	 ecx, DWORD PTR _j$[ebp]
  000ba	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000bd	03 c2		 add	 eax, edx
  000bf	33 d2		 xor	 edx, edx
  000c1	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000c6	f7 f1		 div	 ecx
  000c8	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  000cb	03 45 ec	 add	 eax, DWORD PTR _dwcounter$[ebp]
  000ce	8b 4d 14	 mov	 ecx, DWORD PTR _table$[ebp]
  000d1	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  000d4	88 10		 mov	 BYTE PTR [eax], dl
  000d6	8b 45 ec	 mov	 eax, DWORD PTR _dwcounter$[ebp]
  000d9	83 c0 01	 add	 eax, 1
  000dc	89 45 ec	 mov	 DWORD PTR _dwcounter$[ebp], eax

; 229  :     j++;  if (!key[j]) j=0;

  000df	8b 45 e0	 mov	 eax, DWORD PTR _j$[ebp]
  000e2	83 c0 01	 add	 eax, 1
  000e5	89 45 e0	 mov	 DWORD PTR _j$[ebp], eax
  000e8	8b 45 18	 mov	 eax, DWORD PTR _key$[ebp]
  000eb	03 45 e0	 add	 eax, DWORD PTR _j$[ebp]
  000ee	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000f1	85 c9		 test	 ecx, ecx
  000f3	75 07		 jne	 SHORT $LN8@util_256to
  000f5	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
$LN8@util_256to:

; 230  :     dw = ( dw >> 6 );

  000fc	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  000ff	c1 e8 06	 shr	 eax, 6
  00102	89 45 f8	 mov	 DWORD PTR _dw$[ebp], eax

; 231  :     if (i%3==2) {

  00105	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00108	99		 cdq
  00109	b9 03 00 00 00	 mov	 ecx, 3
  0010e	f7 f9		 idiv	 ecx
  00110	83 fa 02	 cmp	 edx, 2
  00113	75 55		 jne	 SHORT $LN9@util_256to

; 232  :       dst[ dwcounter++ ] = table[ ((dw & 0x3f) + key[j]) % 64 ];// check!

  00115	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  00118	83 e0 3f	 and	 eax, 63			; 0000003fH
  0011b	8b 4d 18	 mov	 ecx, DWORD PTR _key$[ebp]
  0011e	03 4d e0	 add	 ecx, DWORD PTR _j$[ebp]
  00121	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00124	03 c2		 add	 eax, edx
  00126	33 d2		 xor	 edx, edx
  00128	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0012d	f7 f1		 div	 ecx
  0012f	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00132	03 45 ec	 add	 eax, DWORD PTR _dwcounter$[ebp]
  00135	8b 4d 14	 mov	 ecx, DWORD PTR _table$[ebp]
  00138	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  0013b	88 10		 mov	 BYTE PTR [eax], dl
  0013d	8b 45 ec	 mov	 eax, DWORD PTR _dwcounter$[ebp]
  00140	83 c0 01	 add	 eax, 1
  00143	89 45 ec	 mov	 DWORD PTR _dwcounter$[ebp], eax

; 233  :       j++;  if (!key[j]) j=0;

  00146	8b 45 e0	 mov	 eax, DWORD PTR _j$[ebp]
  00149	83 c0 01	 add	 eax, 1
  0014c	89 45 e0	 mov	 DWORD PTR _j$[ebp], eax
  0014f	8b 45 18	 mov	 eax, DWORD PTR _key$[ebp]
  00152	03 45 e0	 add	 eax, DWORD PTR _j$[ebp]
  00155	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00158	85 c9		 test	 ecx, ecx
  0015a	75 07		 jne	 SHORT $LN10@util_256to
  0015c	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
$LN10@util_256to:

; 234  :       dw = 0;

  00163	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dw$[ebp], 0
$LN9@util_256to:

; 235  :     }
; 236  :   }

  0016a	e9 04 ff ff ff	 jmp	 $LN2@util_256to
$LN3@util_256to:

; 237  :   if (dw) dst[ dwcounter++ ] = table[ (dw + key[j]) % 64 ];	// check!

  0016f	83 7d f8 00	 cmp	 DWORD PTR _dw$[ebp], 0
  00173	74 2c		 je	 SHORT $LN11@util_256to
  00175	8b 45 18	 mov	 eax, DWORD PTR _key$[ebp]
  00178	03 45 e0	 add	 eax, DWORD PTR _j$[ebp]
  0017b	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0017e	03 45 f8	 add	 eax, DWORD PTR _dw$[ebp]
  00181	33 d2		 xor	 edx, edx
  00183	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00188	f7 f1		 div	 ecx
  0018a	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  0018d	03 45 ec	 add	 eax, DWORD PTR _dwcounter$[ebp]
  00190	8b 4d 14	 mov	 ecx, DWORD PTR _table$[ebp]
  00193	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  00196	88 10		 mov	 BYTE PTR [eax], dl
  00198	8b 45 ec	 mov	 eax, DWORD PTR _dwcounter$[ebp]
  0019b	83 c0 01	 add	 eax, 1
  0019e	89 45 ec	 mov	 DWORD PTR _dwcounter$[ebp], eax
$LN11@util_256to:

; 238  :   dst[ dwcounter ] = '\0';

  001a1	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  001a4	03 45 ec	 add	 eax, DWORD PTR _dwcounter$[ebp]
  001a7	c6 00 00	 mov	 BYTE PTR [eax], 0

; 239  :   return dwcounter;

  001aa	8b 45 ec	 mov	 eax, DWORD PTR _dwcounter$[ebp]
$LN1@util_256to:

; 240  : }

  001ad	5f		 pop	 edi
  001ae	5e		 pop	 esi
  001af	5b		 pop	 ebx
  001b0	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  001b6	3b ec		 cmp	 ebp, esp
  001b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001bd	8b e5		 mov	 esp, ebp
  001bf	5d		 pop	 ebp
  001c0	c3		 ret	 0
?util_256to64_shr@@YAHPAD0H00@Z ENDP			; util_256to64_shr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?util_64to256@@YAHPAD00@Z
_TEXT	SEGMENT
_c$ = -65						; size = 1
_ptr$ = -56						; size = 4
_j$ = -44						; size = 4
_i$ = -32						; size = 4
_dwcounter$ = -20					; size = 4
_dw$ = -8						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_table$ = 16						; size = 4
?util_64to256@@YAHPAD00@Z PROC				; util_64to256, COMDAT

; 185  : int util_64to256(char *dst, char *src, char *table){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 186  :   unsigned int dw,dwcounter;
; 187  :   unsigned int i, j;
; 188  :   char *ptr = NULL;

  0001e	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _ptr$[ebp], 0

; 189  : 
; 190  :   dw=0;

  00025	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dw$[ebp], 0

; 191  :   dwcounter=0;

  0002c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _dwcounter$[ebp], 0

; 192  :   if (!dst || !src || !table) return 0;

  00033	83 7d 08 00	 cmp	 DWORD PTR _dst$[ebp], 0
  00037	74 0c		 je	 SHORT $LN9@util_64to2
  00039	83 7d 0c 00	 cmp	 DWORD PTR _src$[ebp], 0
  0003d	74 06		 je	 SHORT $LN9@util_64to2
  0003f	83 7d 10 00	 cmp	 DWORD PTR _table$[ebp], 0
  00043	75 07		 jne	 SHORT $LN8@util_64to2
$LN9@util_64to2:
  00045	33 c0		 xor	 eax, eax
  00047	e9 16 01 00 00	 jmp	 $LN1@util_64to2
$LN8@util_64to2:

; 193  :   char c;
; 194  :   for (i=0; i<strlen(src); i++) {

  0004c	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00053	eb 09		 jmp	 SHORT $LN4@util_64to2
$LN2@util_64to2:
  00055	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  00058	83 c0 01	 add	 eax, 1
  0005b	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax
$LN4@util_64to2:
  0005e	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 _strlen
  00067	83 c4 04	 add	 esp, 4
  0006a	39 45 e0	 cmp	 DWORD PTR _i$[ebp], eax
  0006d	0f 83 c4 00 00
	00		 jae	 $LN3@util_64to2

; 195  : 	  c = src[i];

  00073	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00076	03 45 e0	 add	 eax, DWORD PTR _i$[ebp]
  00079	8a 08		 mov	 cl, BYTE PTR [eax]
  0007b	88 4d bf	 mov	 BYTE PTR _c$[ebp], cl

; 196  : 	  for( j = 0; j < strlen(table); j++){

  0007e	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00085	eb 09		 jmp	 SHORT $LN7@util_64to2
$LN5@util_64to2:
  00087	8b 45 d4	 mov	 eax, DWORD PTR _j$[ebp]
  0008a	83 c0 01	 add	 eax, 1
  0008d	89 45 d4	 mov	 DWORD PTR _j$[ebp], eax
$LN7@util_64to2:
  00090	8b 45 10	 mov	 eax, DWORD PTR _table$[ebp]
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 _strlen
  00099	83 c4 04	 add	 esp, 4
  0009c	39 45 d4	 cmp	 DWORD PTR _j$[ebp], eax
  0009f	73 1e		 jae	 SHORT $LN6@util_64to2

; 197  : 		  if( table[j] == c){

  000a1	8b 45 10	 mov	 eax, DWORD PTR _table$[ebp]
  000a4	03 45 d4	 add	 eax, DWORD PTR _j$[ebp]
  000a7	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000aa	0f be 55 bf	 movsx	 edx, BYTE PTR _c$[ebp]
  000ae	3b ca		 cmp	 ecx, edx
  000b0	75 0b		 jne	 SHORT $LN10@util_64to2

; 198  : 			  ptr = table+j;

  000b2	8b 45 10	 mov	 eax, DWORD PTR _table$[ebp]
  000b5	03 45 d4	 add	 eax, DWORD PTR _j$[ebp]
  000b8	89 45 c8	 mov	 DWORD PTR _ptr$[ebp], eax

; 199  : 			  break;

  000bb	eb 02		 jmp	 SHORT $LN6@util_64to2
$LN10@util_64to2:

; 200  : 		  }
; 201  : 	  }

  000bd	eb c8		 jmp	 SHORT $LN5@util_64to2
$LN6@util_64to2:

; 202  :     if (!ptr) return 0;

  000bf	83 7d c8 00	 cmp	 DWORD PTR _ptr$[ebp], 0
  000c3	75 07		 jne	 SHORT $LN11@util_64to2
  000c5	33 c0		 xor	 eax, eax
  000c7	e9 96 00 00 00	 jmp	 $LN1@util_64to2
$LN11@util_64to2:

; 203  :     if (i%4) {

  000cc	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  000cf	33 d2		 xor	 edx, edx
  000d1	b9 04 00 00 00	 mov	 ecx, 4
  000d6	f7 f1		 div	 ecx
  000d8	85 d2		 test	 edx, edx
  000da	74 4a		 je	 SHORT $LN12@util_64to2

; 204  :       dw = ((unsigned int)(ptr-table) & 0x3f) << ((4-(i%4))<<1) | dw;

  000dc	8b 75 c8	 mov	 esi, DWORD PTR _ptr$[ebp]
  000df	2b 75 10	 sub	 esi, DWORD PTR _table$[ebp]
  000e2	83 e6 3f	 and	 esi, 63			; 0000003fH
  000e5	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  000e8	33 d2		 xor	 edx, edx
  000ea	b9 04 00 00 00	 mov	 ecx, 4
  000ef	f7 f1		 div	 ecx
  000f1	b9 04 00 00 00	 mov	 ecx, 4
  000f6	2b ca		 sub	 ecx, edx
  000f8	d1 e1		 shl	 ecx, 1
  000fa	d3 e6		 shl	 esi, cl
  000fc	0b 75 f8	 or	 esi, DWORD PTR _dw$[ebp]
  000ff	89 75 f8	 mov	 DWORD PTR _dw$[ebp], esi

; 205  :       dst[ dwcounter++ ] = dw & 0xff;

  00102	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  00105	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0010a	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0010d	03 4d ec	 add	 ecx, DWORD PTR _dwcounter$[ebp]
  00110	88 01		 mov	 BYTE PTR [ecx], al
  00112	8b 55 ec	 mov	 edx, DWORD PTR _dwcounter$[ebp]
  00115	83 c2 01	 add	 edx, 1
  00118	89 55 ec	 mov	 DWORD PTR _dwcounter$[ebp], edx

; 206  :       dw = dw >> 8;

  0011b	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  0011e	c1 e8 08	 shr	 eax, 8
  00121	89 45 f8	 mov	 DWORD PTR _dw$[ebp], eax

; 207  :     } else {

  00124	eb 0c		 jmp	 SHORT $LN13@util_64to2
$LN12@util_64to2:

; 208  :       dw = (unsigned int)(ptr-table) & 0x3f;

  00126	8b 45 c8	 mov	 eax, DWORD PTR _ptr$[ebp]
  00129	2b 45 10	 sub	 eax, DWORD PTR _table$[ebp]
  0012c	83 e0 3f	 and	 eax, 63			; 0000003fH
  0012f	89 45 f8	 mov	 DWORD PTR _dw$[ebp], eax
$LN13@util_64to2:

; 209  :     }
; 210  :   }

  00132	e9 1e ff ff ff	 jmp	 $LN2@util_64to2
$LN3@util_64to2:

; 211  :   if (dw) dst[ dwcounter++ ] = dw & 0xff;

  00137	83 7d f8 00	 cmp	 DWORD PTR _dw$[ebp], 0
  0013b	74 19		 je	 SHORT $LN14@util_64to2
  0013d	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  00140	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00145	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00148	03 4d ec	 add	 ecx, DWORD PTR _dwcounter$[ebp]
  0014b	88 01		 mov	 BYTE PTR [ecx], al
  0014d	8b 55 ec	 mov	 edx, DWORD PTR _dwcounter$[ebp]
  00150	83 c2 01	 add	 edx, 1
  00153	89 55 ec	 mov	 DWORD PTR _dwcounter$[ebp], edx
$LN14@util_64to2:

; 212  :   dst[ dwcounter ] = '\0';

  00156	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00159	03 45 ec	 add	 eax, DWORD PTR _dwcounter$[ebp]
  0015c	c6 00 00	 mov	 BYTE PTR [eax], 0

; 213  :   return dwcounter;

  0015f	8b 45 ec	 mov	 eax, DWORD PTR _dwcounter$[ebp]
$LN1@util_64to2:

; 214  : }

  00162	5f		 pop	 edi
  00163	5e		 pop	 esi
  00164	5b		 pop	 ebx
  00165	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  0016b	3b ec		 cmp	 ebp, esp
  0016d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00172	8b e5		 mov	 esp, ebp
  00174	5d		 pop	 ebp
  00175	c3		 ret	 0
?util_64to256@@YAHPAD00@Z ENDP				; util_64to256
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?util_256to64@@YAHPAD0H0@Z
_TEXT	SEGMENT
_i$ = -32						; size = 4
_dwcounter$ = -20					; size = 4
_dw$ = -8						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_len$ = 16						; size = 4
_table$ = 20						; size = 4
?util_256to64@@YAHPAD0H0@Z PROC				; util_256to64, COMDAT

; 163  : int util_256to64(char *dst, char *src, int len, char *table){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 164  :   unsigned int dw,dwcounter;
; 165  :   int i;
; 166  : 
; 167  :   if (!dst || !src || !table) return 0;

  0001e	83 7d 08 00	 cmp	 DWORD PTR _dst$[ebp], 0
  00022	74 0c		 je	 SHORT $LN6@util_256to
  00024	83 7d 0c 00	 cmp	 DWORD PTR _src$[ebp], 0
  00028	74 06		 je	 SHORT $LN6@util_256to
  0002a	83 7d 14 00	 cmp	 DWORD PTR _table$[ebp], 0
  0002e	75 07		 jne	 SHORT $LN5@util_256to
$LN6@util_256to:
  00030	33 c0		 xor	 eax, eax
  00032	e9 dc 00 00 00	 jmp	 $LN1@util_256to
$LN5@util_256to:

; 168  :   dw=0;

  00037	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dw$[ebp], 0

; 169  :   dwcounter=0;

  0003e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _dwcounter$[ebp], 0

; 170  :   for (i=0; i<len; i++) {

  00045	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0004c	eb 09		 jmp	 SHORT $LN4@util_256to
$LN2@util_256to:
  0004e	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  00051	83 c0 01	 add	 eax, 1
  00054	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax
$LN4@util_256to:
  00057	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  0005a	3b 45 10	 cmp	 eax, DWORD PTR _len$[ebp]
  0005d	0f 8d 85 00 00
	00		 jge	 $LN3@util_256to

; 171  :     dw = ( ((unsigned int)src[i] & 0xff) << ((i%3)<<1) ) | dw;

  00063	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00066	03 45 e0	 add	 eax, DWORD PTR _i$[ebp]
  00069	0f be 30	 movsx	 esi, BYTE PTR [eax]
  0006c	81 e6 ff 00 00
	00		 and	 esi, 255		; 000000ffH
  00072	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  00075	99		 cdq
  00076	b9 03 00 00 00	 mov	 ecx, 3
  0007b	f7 f9		 idiv	 ecx
  0007d	d1 e2		 shl	 edx, 1
  0007f	8b ca		 mov	 ecx, edx
  00081	d3 e6		 shl	 esi, cl
  00083	0b 75 f8	 or	 esi, DWORD PTR _dw$[ebp]
  00086	89 75 f8	 mov	 DWORD PTR _dw$[ebp], esi

; 172  :     dst[ dwcounter++ ] = table[ dw & 0x3f ];

  00089	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  0008c	83 e0 3f	 and	 eax, 63			; 0000003fH
  0008f	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00092	03 4d ec	 add	 ecx, DWORD PTR _dwcounter$[ebp]
  00095	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  00098	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  0009b	88 01		 mov	 BYTE PTR [ecx], al
  0009d	8b 4d ec	 mov	 ecx, DWORD PTR _dwcounter$[ebp]
  000a0	83 c1 01	 add	 ecx, 1
  000a3	89 4d ec	 mov	 DWORD PTR _dwcounter$[ebp], ecx

; 173  :     dw = ( dw >> 6 );

  000a6	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  000a9	c1 e8 06	 shr	 eax, 6
  000ac	89 45 f8	 mov	 DWORD PTR _dw$[ebp], eax

; 174  :     if (i%3==2) {

  000af	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  000b2	99		 cdq
  000b3	b9 03 00 00 00	 mov	 ecx, 3
  000b8	f7 f9		 idiv	 ecx
  000ba	83 fa 02	 cmp	 edx, 2
  000bd	75 24		 jne	 SHORT $LN7@util_256to

; 175  :       dst[ dwcounter++ ] = table[ dw & 0x3f ];

  000bf	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  000c2	83 e0 3f	 and	 eax, 63			; 0000003fH
  000c5	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000c8	03 4d ec	 add	 ecx, DWORD PTR _dwcounter$[ebp]
  000cb	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  000ce	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  000d1	88 01		 mov	 BYTE PTR [ecx], al
  000d3	8b 4d ec	 mov	 ecx, DWORD PTR _dwcounter$[ebp]
  000d6	83 c1 01	 add	 ecx, 1
  000d9	89 4d ec	 mov	 DWORD PTR _dwcounter$[ebp], ecx

; 176  :       dw = 0;

  000dc	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dw$[ebp], 0
$LN7@util_256to:

; 177  :     }
; 178  :   }

  000e3	e9 66 ff ff ff	 jmp	 $LN2@util_256to
$LN3@util_256to:

; 179  :   if (dw) dst[ dwcounter++ ] = table[ dw ];

  000e8	83 7d f8 00	 cmp	 DWORD PTR _dw$[ebp], 0
  000ec	74 19		 je	 SHORT $LN8@util_256to
  000ee	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  000f1	03 45 ec	 add	 eax, DWORD PTR _dwcounter$[ebp]
  000f4	8b 4d 14	 mov	 ecx, DWORD PTR _table$[ebp]
  000f7	03 4d f8	 add	 ecx, DWORD PTR _dw$[ebp]
  000fa	8a 11		 mov	 dl, BYTE PTR [ecx]
  000fc	88 10		 mov	 BYTE PTR [eax], dl
  000fe	8b 45 ec	 mov	 eax, DWORD PTR _dwcounter$[ebp]
  00101	83 c0 01	 add	 eax, 1
  00104	89 45 ec	 mov	 DWORD PTR _dwcounter$[ebp], eax
$LN8@util_256to:

; 180  :   dst[ dwcounter ] = '\0';

  00107	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  0010a	03 45 ec	 add	 eax, DWORD PTR _dwcounter$[ebp]
  0010d	c6 00 00	 mov	 BYTE PTR [eax], 0

; 181  :   return dwcounter;

  00110	8b 45 ec	 mov	 eax, DWORD PTR _dwcounter$[ebp]
$LN1@util_256to:

; 182  : }

  00113	5f		 pop	 edi
  00114	5e		 pop	 esi
  00115	5b		 pop	 ebx
  00116	8b e5		 mov	 esp, ebp
  00118	5d		 pop	 ebp
  00119	c3		 ret	 0
?util_256to64@@YAHPAD0H0@Z ENDP				; util_256to64
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?util_SendMesg@@YAXHHPAD@Z
_TEXT	SEGMENT
_addr$ = -120028					; size = 4
_t2$ = -120016						; size = 60000
_t1$ = -60008						; size = 60000
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_func$ = 12						; size = 4
_buffer$ = 16						; size = 4
?util_SendMesg@@YAXHHPAD@Z PROC				; util_SendMesg, COMDAT

; 136  : void util_SendMesg(int fd, int func, char *buffer){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 e0 da 01 00	 mov	 eax, 121568		; 0001dae0H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8d bd 20 25 fe
	ff		 lea	 edi, DWORD PTR [ebp-121568]
  00016	b9 b8 76 00 00	 mov	 ecx, 30392		; 000076b8H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 137  : 	char t1[60000], t2[60000];
; 138  :   int addr = 0;

  0002c	c7 85 24 2b fe
	ff 00 00 00 00	 mov	 DWORD PTR _addr$[ebp], 0

; 139  :   __asm
; 140  :   {
; 141  : 	  push dword ptr [ebp + 4];

  00036	ff 75 04	 push	 DWORD PTR [ebp+4]

; 142  : 	  pop addr;

  00039	8f 85 24 2b fe
	ff		 pop	 DWORD PTR _addr$[ebp]

; 143  : 
; 144  :   }
; 145  :   JL_combinePacket_SEND(func, addr);

  0003f	8b 85 24 2b fe
	ff		 mov	 eax, DWORD PTR _addr$[ebp]
  00045	50		 push	 eax
  00046	8b 4d 0c	 mov	 ecx, DWORD PTR _func$[ebp]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ?JL_combinePacket_SEND@@YAXHH@Z ; JL_combinePacket_SEND
  0004f	83 c4 08	 add	 esp, 8

; 146  :   sprintf(t1, "&;%d%s;#;", func + 13, buffer);

  00052	8b 45 10	 mov	 eax, DWORD PTR _buffer$[ebp]
  00055	50		 push	 eax
  00056	8b 4d 0c	 mov	 ecx, DWORD PTR _func$[ebp]
  00059	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0005c	51		 push	 ecx
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_09PELNNIGO@?$CG?$DL?$CFd?$CFs?$DL?$CD?$DL?$AA@
  00062	8d 95 98 15 ff
	ff		 lea	 edx, DWORD PTR _t1$[ebp]
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 _sprintf
  0006e	83 c4 10	 add	 esp, 16			; 00000010H

; 147  : #if 0
; 148  : 	if( lssproto_writelogfilename[0] != '\0' ){
; 149  : 		FILE *wfp = fopen( lssproto_writelogfilename , "a+" );
; 150  : 		if(wfp){
; 151  : 			fprintf( wfp , "送出：\t%s\n", t1 );
; 152  : 			fclose(wfp);
; 153  : 		}
; 154  : 	}
; 155  : #endif
; 156  :   util_EncodeMessage(t2, t1);

  00071	8d 85 98 15 ff
	ff		 lea	 eax, DWORD PTR _t1$[ebp]
  00077	50		 push	 eax
  00078	8d 8d 30 2b fe
	ff		 lea	 ecx, DWORD PTR _t2$[ebp]
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 ?util_EncodeMessage@@YAXPAD0@Z ; util_EncodeMessage
  00084	83 c4 08	 add	 esp, 8

; 157  : #ifdef __STONEAGE
; 158  :   lssproto_Send(fd, t2);

  00087	8d 85 30 2b fe
	ff		 lea	 eax, DWORD PTR _t2$[ebp]
  0008d	50		 push	 eax
  0008e	8b 4d 08	 mov	 ecx, DWORD PTR _fd$[ebp]
  00091	51		 push	 ecx
  00092	e8 00 00 00 00	 call	 ?lssproto_Send@@YAXHPAD@Z ; lssproto_Send
  00097	83 c4 08	 add	 esp, 8

; 159  : #endif
; 160  : }

  0009a	52		 push	 edx
  0009b	8b cd		 mov	 ecx, ebp
  0009d	50		 push	 eax
  0009e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@util_SendM
  000a4	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000a9	58		 pop	 eax
  000aa	5a		 pop	 edx
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	5b		 pop	 ebx
  000ae	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b1	33 cd		 xor	 ecx, ebp
  000b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b8	81 c4 e0 da 01
	00		 add	 esp, 121568		; 0001dae0H
  000be	3b ec		 cmp	 ebp, esp
  000c0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
  000c9	0f 1f 00	 npad	 3
$LN6@util_SendM:
  000cc	02 00 00 00	 DD	 2
  000d0	00 00 00 00	 DD	 $LN5@util_SendM
$LN5@util_SendM:
  000d4	98 15 ff ff	 DD	 -60008			; ffff1598H
  000d8	60 ea 00 00	 DD	 60000			; 0000ea60H
  000dc	00 00 00 00	 DD	 $LN3@util_SendM
  000e0	30 2b fe ff	 DD	 -120016			; fffe2b30H
  000e4	60 ea 00 00	 DD	 60000			; 0000ea60H
  000e8	00 00 00 00	 DD	 $LN4@util_SendM
$LN4@util_SendM:
  000ec	74		 DB	 116			; 00000074H
  000ed	32		 DB	 50			; 00000032H
  000ee	00		 DB	 0
$LN3@util_SendM:
  000ef	74		 DB	 116			; 00000074H
  000f0	31		 DB	 49			; 00000031H
  000f1	00		 DB	 0
?util_SendMesg@@YAXHHPAD@Z ENDP				; util_SendMesg
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?util_DiscardMessage@@YAXXZ
_TEXT	SEGMENT
?util_DiscardMessage@@YAXXZ PROC			; util_DiscardMessage, COMDAT

; 131  : void util_DiscardMessage(void){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 132  : 	SliceCount=0;

  0001e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?SliceCount@@3HA, 0 ; SliceCount

; 133  : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?util_DiscardMessage@@YAXXZ ENDP			; util_DiscardMessage
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?util_GetFunctionFromSlice@@YAHPAH0@Z
_TEXT	SEGMENT
_i$ = -16404						; size = 4
_t1$ = -16392						; size = 16384
__$ArrayPad$ = -4					; size = 4
_func$ = 8						; size = 4
_fieldcount$ = 12					; size = 4
?util_GetFunctionFromSlice@@YAHPAH0@Z PROC		; util_GetFunctionFromSlice, COMDAT

; 117  : int util_GetFunctionFromSlice(int *func, int *fieldcount){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 18 46 00 00	 mov	 eax, 17944		; 00004618H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8d bd e8 b9 ff
	ff		 lea	 edi, DWORD PTR [ebp-17944]
  00016	b9 86 11 00 00	 mov	 ecx, 4486		; 00001186H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 118  :   char t1[16384];
; 119  :   int i;
; 120  :   strcpy(t1, MesgSlice[1]);

  0002c	b8 04 00 00 00	 mov	 eax, 4
  00031	c1 e0 00	 shl	 eax, 0
  00034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?MesgSlice@@3PAPADA ; MesgSlice
  0003a	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0003d	52		 push	 edx
  0003e	8d 85 f8 bf ff
	ff		 lea	 eax, DWORD PTR _t1$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _strcpy
  0004a	83 c4 08	 add	 esp, 8

; 121  :   *func = atoi(t1) - 23;

  0004d	8b f4		 mov	 esi, esp
  0004f	8d 85 f8 bf ff
	ff		 lea	 eax, DWORD PTR _t1$[ebp]
  00055	50		 push	 eax
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0005c	83 c4 04	 add	 esp, 4
  0005f	3b f4		 cmp	 esi, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	83 e8 17	 sub	 eax, 23			; 00000017H
  00069	8b 4d 08	 mov	 ecx, DWORD PTR _func$[ebp]
  0006c	89 01		 mov	 DWORD PTR [ecx], eax

; 122  :   for (i=0; i<SLICE_MAX; i++)

  0006e	c7 85 ec bf ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00078	eb 0f		 jmp	 SHORT $LN4@util_GetFu
$LN2@util_GetFu:
  0007a	8b 85 ec bf ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00080	83 c0 01	 add	 eax, 1
  00083	89 85 ec bf ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN4@util_GetFu:
  00089	83 bd ec bf ff
	ff 14		 cmp	 DWORD PTR _i$[ebp], 20	; 00000014H
  00090	7d 38		 jge	 SHORT $LN3@util_GetFu

; 123  :     if (strcmp(MesgSlice[i], DEFAULTFUNCEND)==0) {

  00092	68 00 00 00 00	 push	 OFFSET ??_C@_01IPJKGB@?$CD?$AA@
  00097	8b 85 ec bf ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0009d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?MesgSlice@@3PAPADA ; MesgSlice
  000a3	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 _strcmp
  000ac	83 c4 08	 add	 esp, 8
  000af	85 c0		 test	 eax, eax
  000b1	75 15		 jne	 SHORT $LN5@util_GetFu

; 124  :       *fieldcount=i-2;

  000b3	8b 85 ec bf ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000b9	83 e8 02	 sub	 eax, 2
  000bc	8b 4d 0c	 mov	 ecx, DWORD PTR _fieldcount$[ebp]
  000bf	89 01		 mov	 DWORD PTR [ecx], eax

; 125  :       return 1;

  000c1	b8 01 00 00 00	 mov	 eax, 1
  000c6	eb 04		 jmp	 SHORT $LN1@util_GetFu
$LN5@util_GetFu:

; 126  :     }

  000c8	eb b0		 jmp	 SHORT $LN2@util_GetFu
$LN3@util_GetFu:

; 127  : 
; 128  :   return 0;

  000ca	33 c0		 xor	 eax, eax
$LN1@util_GetFu:

; 129  : }

  000cc	52		 push	 edx
  000cd	8b cd		 mov	 ecx, ebp
  000cf	50		 push	 eax
  000d0	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@util_GetFu
  000d6	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000db	58		 pop	 eax
  000dc	5a		 pop	 edx
  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx
  000e0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e3	33 cd		 xor	 ecx, ebp
  000e5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ea	81 c4 18 46 00
	00		 add	 esp, 17944		; 00004618H
  000f0	3b ec		 cmp	 ebp, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
  000fb	90		 npad	 1
$LN9@util_GetFu:
  000fc	01 00 00 00	 DD	 1
  00100	00 00 00 00	 DD	 $LN8@util_GetFu
$LN8@util_GetFu:
  00104	f8 bf ff ff	 DD	 -16392			; ffffbff8H
  00108	00 40 00 00	 DD	 16384			; 00004000H
  0010c	00 00 00 00	 DD	 $LN7@util_GetFu
$LN7@util_GetFu:
  00110	74		 DB	 116			; 00000074H
  00111	31		 DB	 49			; 00000031H
  00112	00		 DB	 0
?util_GetFunctionFromSlice@@YAHPAH0@Z ENDP		; util_GetFunctionFromSlice
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?util_DecodeMessage@@YAXPAD0@Z
_TEXT	SEGMENT
$T1 = -75300						; size = 4
_tz$ = -73752						; size = 65500
_t4$ = -8244						; size = 4096
_t3$ = -4140						; size = 4096
_t2$ = -36						; size = 4
_t1$ = -24						; size = 4
_rn$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
?util_DecodeMessage@@YAXPAD0@Z PROC			; util_DecodeMessage, COMDAT

; 95   : void util_DecodeMessage(char *dst, char *src){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 28 26 01 00	 mov	 eax, 75304		; 00012628H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8d bd d8 d9 fe
	ff		 lea	 edi, DWORD PTR [ebp-75304]
  00016	b9 8a 49 00 00	 mov	 ecx, 18826		; 0000498aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 96   : #define INTCODESIZE	(sizeof(int)*8+5)/6
; 97   :   int rn;
; 98   :   int *t1, t2;
; 99   :   char t3[4096], t4[4096];
; 100  :   char tz[65500];
; 101  : 
; 102  :   if( src[strlen(src)-1] == '\n')

  0002c	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 _strlen
  00035	83 c4 04	 add	 esp, 4
  00038	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  0003b	0f be 54 01 ff	 movsx	 edx, BYTE PTR [ecx+eax-1]
  00040	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00043	75 14		 jne	 SHORT $LN2@util_Decod

; 103  : 	src[strlen(src)-1] = 0;

  00045	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _strlen
  0004e	83 c4 04	 add	 esp, 4
  00051	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00054	c6 44 01 ff 00	 mov	 BYTE PTR [ecx+eax-1], 0
$LN2@util_Decod:

; 104  :   util_xorstring(tz, src);

  00059	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0005c	50		 push	 eax
  0005d	8d 8d e8 df fe
	ff		 lea	 ecx, DWORD PTR _tz$[ebp]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 ?util_xorstring@@YAXPAD0@Z ; util_xorstring
  00069	83 c4 08	 add	 esp, 8

; 105  : 
; 106  :   rn=INTCODESIZE;

  0006c	c7 45 f4 06 00
	00 00		 mov	 DWORD PTR _rn$[ebp], 6

; 107  :   strncpy(t4, tz, INTCODESIZE);

  00073	8b f4		 mov	 esi, esp
  00075	6a 06		 push	 6
  00077	8d 85 e8 df fe
	ff		 lea	 eax, DWORD PTR _tz$[ebp]
  0007d	50		 push	 eax
  0007e	8d 8d cc df ff
	ff		 lea	 ecx, DWORD PTR _t4$[ebp]
  00084	51		 push	 ecx
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncpy
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008e	3b f4		 cmp	 esi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 108  :   t4[INTCODESIZE] = '\0';

  00095	b8 01 00 00 00	 mov	 eax, 1
  0009a	6b c8 06	 imul	 ecx, eax, 6
  0009d	89 8d dc d9 fe
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  000a3	81 bd dc d9 fe
	ff 00 10 00 00	 cmp	 DWORD PTR $T1[ebp], 4096 ; 00001000H
  000ad	73 02		 jae	 SHORT $LN4@util_Decod
  000af	eb 05		 jmp	 SHORT $LN5@util_Decod
$LN4@util_Decod:
  000b1	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN5@util_Decod:
  000b6	8b 95 dc d9 fe
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  000bc	c6 84 15 cc df
	ff ff 00	 mov	 BYTE PTR _t4$[ebp+edx], 0

; 109  :   util_64to256(t3, t4, DEFAULTTABLE);

  000c4	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@CPNIKEEC@0123456789ABCDEFGHIJKLMNOPQRSTUV@
  000c9	8d 85 cc df ff
	ff		 lea	 eax, DWORD PTR _t4$[ebp]
  000cf	50		 push	 eax
  000d0	8d 8d d4 ef ff
	ff		 lea	 ecx, DWORD PTR _t3$[ebp]
  000d6	51		 push	 ecx
  000d7	e8 00 00 00 00	 call	 ?util_64to256@@YAHPAD00@Z ; util_64to256
  000dc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 110  :   t1 = (int *) t3;

  000df	8d 85 d4 ef ff
	ff		 lea	 eax, DWORD PTR _t3$[ebp]
  000e5	89 45 e8	 mov	 DWORD PTR _t1$[ebp], eax

; 111  :   t2 = *t1 ^ 0xffffffff;

  000e8	8b 45 e8	 mov	 eax, DWORD PTR _t1$[ebp]
  000eb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ed	83 f1 ff	 xor	 ecx, -1
  000f0	89 4d dc	 mov	 DWORD PTR _t2$[ebp], ecx

; 112  :   util_swapint(&rn, &t2, "3142");

  000f3	68 00 00 00 00	 push	 OFFSET ??_C@_04FJNJEMEN@3142?$AA@
  000f8	8d 45 dc	 lea	 eax, DWORD PTR _t2$[ebp]
  000fb	50		 push	 eax
  000fc	8d 4d f4	 lea	 ecx, DWORD PTR _rn$[ebp]
  000ff	51		 push	 ecx
  00100	e8 00 00 00 00	 call	 ?util_swapint@@YAXPAH0PAD@Z ; util_swapint
  00105	83 c4 0c	 add	 esp, 12			; 0000000cH

; 113  :   util_shrstring(dst, tz + INTCODESIZE, rn);

  00108	8b 45 f4	 mov	 eax, DWORD PTR _rn$[ebp]
  0010b	50		 push	 eax
  0010c	8d 8d ee df fe
	ff		 lea	 ecx, DWORD PTR _tz$[ebp+6]
  00112	51		 push	 ecx
  00113	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  00116	52		 push	 edx
  00117	e8 00 00 00 00	 call	 ?util_shrstring@@YAXPAD0H@Z ; util_shrstring
  0011c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@util_Decod:

; 114  : }

  0011f	52		 push	 edx
  00120	8b cd		 mov	 ecx, ebp
  00122	50		 push	 eax
  00123	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@util_Decod
  00129	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0012e	58		 pop	 eax
  0012f	5a		 pop	 edx
  00130	5f		 pop	 edi
  00131	5e		 pop	 esi
  00132	5b		 pop	 ebx
  00133	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00136	33 cd		 xor	 ecx, ebp
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	81 c4 28 26 01
	00		 add	 esp, 75304		; 00012628H
  00143	3b ec		 cmp	 ebp, esp
  00145	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c3		 ret	 0
  0014e	66 90		 npad	 2
$LN12@util_Decod:
  00150	05 00 00 00	 DD	 5
  00154	00 00 00 00	 DD	 $LN11@util_Decod
$LN11@util_Decod:
  00158	f4 ff ff ff	 DD	 -12			; fffffff4H
  0015c	04 00 00 00	 DD	 4
  00160	00 00 00 00	 DD	 $LN6@util_Decod
  00164	dc ff ff ff	 DD	 -36			; ffffffdcH
  00168	04 00 00 00	 DD	 4
  0016c	00 00 00 00	 DD	 $LN7@util_Decod
  00170	d4 ef ff ff	 DD	 -4140			; ffffefd4H
  00174	00 10 00 00	 DD	 4096			; 00001000H
  00178	00 00 00 00	 DD	 $LN8@util_Decod
  0017c	cc df ff ff	 DD	 -8244			; ffffdfccH
  00180	00 10 00 00	 DD	 4096			; 00001000H
  00184	00 00 00 00	 DD	 $LN9@util_Decod
  00188	e8 df fe ff	 DD	 -73752			; fffedfe8H
  0018c	dc ff 00 00	 DD	 65500			; 0000ffdcH
  00190	00 00 00 00	 DD	 $LN10@util_Decod
$LN10@util_Decod:
  00194	74		 DB	 116			; 00000074H
  00195	7a		 DB	 122			; 0000007aH
  00196	00		 DB	 0
$LN9@util_Decod:
  00197	74		 DB	 116			; 00000074H
  00198	34		 DB	 52			; 00000034H
  00199	00		 DB	 0
$LN8@util_Decod:
  0019a	74		 DB	 116			; 00000074H
  0019b	33		 DB	 51			; 00000033H
  0019c	00		 DB	 0
$LN7@util_Decod:
  0019d	74		 DB	 116			; 00000074H
  0019e	32		 DB	 50			; 00000032H
  0019f	00		 DB	 0
$LN6@util_Decod:
  001a0	72		 DB	 114			; 00000072H
  001a1	6e		 DB	 110			; 0000006eH
  001a2	00		 DB	 0
?util_DecodeMessage@@YAXPAD0@Z ENDP			; util_DecodeMessage
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?util_EncodeMessage@@YAXPAD0@Z
_TEXT	SEGMENT
_tz$ = -131052						; size = 65500
_t3$ = -65544						; size = 65500
_t2$ = -36						; size = 4
_t1$ = -24						; size = 4
_rn$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
?util_EncodeMessage@@YAXPAD0@Z PROC			; util_EncodeMessage, COMDAT

; 81   : void util_EncodeMessage(char *dst, char *src){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 f0 05 02 00	 mov	 eax, 132592		; 000205f0H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8d bd 10 fa fd
	ff		 lea	 edi, DWORD PTR [ebp-132592]
  00016	b9 7c 81 00 00	 mov	 ecx, 33148		; 0000817cH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 82   :   int rn = rand()%99;

  0002c	8b f4		 mov	 esi, esp
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  00034	3b f4		 cmp	 esi, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	99		 cdq
  0003c	b9 63 00 00 00	 mov	 ecx, 99			; 00000063H
  00041	f7 f9		 idiv	 ecx
  00043	89 55 f4	 mov	 DWORD PTR _rn$[ebp], edx

; 83   :   int t1, t2;
; 84   :   char t3[65500], tz[65500];
; 85   :   util_swapint(&t1, &rn, "2413");

  00046	68 00 00 00 00	 push	 OFFSET ??_C@_04EMLHGGGF@2413?$AA@
  0004b	8d 45 f4	 lea	 eax, DWORD PTR _rn$[ebp]
  0004e	50		 push	 eax
  0004f	8d 4d e8	 lea	 ecx, DWORD PTR _t1$[ebp]
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 ?util_swapint@@YAXPAH0PAD@Z ; util_swapint
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH

; 86   :   t2 = t1 ^ 0xffffffff;

  0005b	8b 45 e8	 mov	 eax, DWORD PTR _t1$[ebp]
  0005e	83 f0 ff	 xor	 eax, -1
  00061	89 45 dc	 mov	 DWORD PTR _t2$[ebp], eax

; 87   :   util_256to64(tz, (char *) &t2, sizeof(int), DEFAULTTABLE);

  00064	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@CPNIKEEC@0123456789ABCDEFGHIJKLMNOPQRSTUV@
  00069	6a 04		 push	 4
  0006b	8d 45 dc	 lea	 eax, DWORD PTR _t2$[ebp]
  0006e	50		 push	 eax
  0006f	8d 8d 14 00 fe
	ff		 lea	 ecx, DWORD PTR _tz$[ebp]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 ?util_256to64@@YAHPAD0H0@Z ; util_256to64
  0007b	83 c4 10	 add	 esp, 16			; 00000010H

; 88   :   
; 89   :   util_shlstring(t3, src, rn);

  0007e	8b 45 f4	 mov	 eax, DWORD PTR _rn$[ebp]
  00081	50		 push	 eax
  00082	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00085	51		 push	 ecx
  00086	8d 95 f8 ff fe
	ff		 lea	 edx, DWORD PTR _t3$[ebp]
  0008c	52		 push	 edx
  0008d	e8 00 00 00 00	 call	 ?util_shlstring@@YAXPAD0H@Z ; util_shlstring
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH

; 90   :   strcat(tz, t3);

  00095	8d 85 f8 ff fe
	ff		 lea	 eax, DWORD PTR _t3$[ebp]
  0009b	50		 push	 eax
  0009c	8d 8d 14 00 fe
	ff		 lea	 ecx, DWORD PTR _tz$[ebp]
  000a2	51		 push	 ecx
  000a3	e8 00 00 00 00	 call	 _strcat
  000a8	83 c4 08	 add	 esp, 8

; 91   :   util_xorstring(dst, tz);

  000ab	8d 85 14 00 fe
	ff		 lea	 eax, DWORD PTR _tz$[ebp]
  000b1	50		 push	 eax
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000b5	51		 push	 ecx
  000b6	e8 00 00 00 00	 call	 ?util_xorstring@@YAXPAD0@Z ; util_xorstring
  000bb	83 c4 08	 add	 esp, 8

; 92   : }

  000be	52		 push	 edx
  000bf	8b cd		 mov	 ecx, ebp
  000c1	50		 push	 eax
  000c2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@util_Encod
  000c8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000cd	58		 pop	 eax
  000ce	5a		 pop	 edx
  000cf	5f		 pop	 edi
  000d0	5e		 pop	 esi
  000d1	5b		 pop	 ebx
  000d2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d5	33 cd		 xor	 ecx, ebp
  000d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000dc	81 c4 f0 05 02
	00		 add	 esp, 132592		; 000205f0H
  000e2	3b ec		 cmp	 ebp, esp
  000e4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c3		 ret	 0
  000ed	0f 1f 00	 npad	 3
$LN9@util_Encod:
  000f0	05 00 00 00	 DD	 5
  000f4	00 00 00 00	 DD	 $LN8@util_Encod
$LN8@util_Encod:
  000f8	f4 ff ff ff	 DD	 -12			; fffffff4H
  000fc	04 00 00 00	 DD	 4
  00100	00 00 00 00	 DD	 $LN3@util_Encod
  00104	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00108	04 00 00 00	 DD	 4
  0010c	00 00 00 00	 DD	 $LN4@util_Encod
  00110	dc ff ff ff	 DD	 -36			; ffffffdcH
  00114	04 00 00 00	 DD	 4
  00118	00 00 00 00	 DD	 $LN5@util_Encod
  0011c	f8 ff fe ff	 DD	 -65544			; fffefff8H
  00120	dc ff 00 00	 DD	 65500			; 0000ffdcH
  00124	00 00 00 00	 DD	 $LN6@util_Encod
  00128	14 00 fe ff	 DD	 -131052			; fffe0014H
  0012c	dc ff 00 00	 DD	 65500			; 0000ffdcH
  00130	00 00 00 00	 DD	 $LN7@util_Encod
$LN7@util_Encod:
  00134	74		 DB	 116			; 00000074H
  00135	7a		 DB	 122			; 0000007aH
  00136	00		 DB	 0
$LN6@util_Encod:
  00137	74		 DB	 116			; 00000074H
  00138	33		 DB	 51			; 00000033H
  00139	00		 DB	 0
$LN5@util_Encod:
  0013a	74		 DB	 116			; 00000074H
  0013b	32		 DB	 50			; 00000032H
  0013c	00		 DB	 0
$LN4@util_Encod:
  0013d	74		 DB	 116			; 00000074H
  0013e	31		 DB	 49			; 00000031H
  0013f	00		 DB	 0
$LN3@util_Encod:
  00140	72		 DB	 114			; 00000072H
  00141	6e		 DB	 110			; 0000006eH
  00142	00		 DB	 0
?util_EncodeMessage@@YAXPAD0@Z ENDP			; util_EncodeMessage
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?util_SplitMessage@@YAXPAD0@Z
_TEXT	SEGMENT
_head$1 = -20						; size = 4
_ptr$2 = -8						; size = 4
_source$ = 8						; size = 4
_separator$ = 12					; size = 4
?util_SplitMessage@@YAXPAD0@Z PROC			; util_SplitMessage, COMDAT

; 59   : void util_SplitMessage(char *source, char *separator){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 60   :   if (source && separator) {	// NULL input is invalid.

  0001e	83 7d 08 00	 cmp	 DWORD PTR _source$[ebp], 0
  00022	0f 84 98 00 00
	00		 je	 $LN1@util_Split
  00028	83 7d 0c 00	 cmp	 DWORD PTR _separator$[ebp], 0
  0002c	0f 84 8e 00 00
	00		 je	 $LN1@util_Split

; 61   :     char *ptr;
; 62   :     char *head = source;

  00032	8b 45 08	 mov	 eax, DWORD PTR _source$[ebp]
  00035	89 45 ec	 mov	 DWORD PTR _head$1[ebp], eax
$LN2@util_Split:

; 63   :     
; 64   :     while ((ptr = (char *) strstr(head, separator)) && (SliceCount<=SLICE_MAX)) {

  00038	8b 45 0c	 mov	 eax, DWORD PTR _separator$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _head$1[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 ?strstr@@YAPADQADQBD@Z	; strstr
  00045	83 c4 08	 add	 esp, 8
  00048	89 45 f8	 mov	 DWORD PTR _ptr$2[ebp], eax
  0004b	83 7d f8 00	 cmp	 DWORD PTR _ptr$2[ebp], 0
  0004f	74 5f		 je	 SHORT $LN3@util_Split
  00051	83 3d 00 00 00
	00 14		 cmp	 DWORD PTR ?SliceCount@@3HA, 20 ; SliceCount, 00000014H
  00058	7f 56		 jg	 SHORT $LN3@util_Split

; 65   :       ptr[0] = '\0';

  0005a	b8 01 00 00 00	 mov	 eax, 1
  0005f	6b c8 00	 imul	 ecx, eax, 0
  00062	8b 55 f8	 mov	 edx, DWORD PTR _ptr$2[ebp]
  00065	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0

; 66   :       if (strlen(head)<SLICE_SIZE) {	// discard slices too large

  00069	8b 45 ec	 mov	 eax, DWORD PTR _head$1[ebp]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 _strlen
  00072	83 c4 04	 add	 esp, 4
  00075	3d dc ff 00 00	 cmp	 eax, 65500		; 0000ffdcH
  0007a	73 29		 jae	 SHORT $LN5@util_Split

; 67   :         strcpy(MesgSlice[SliceCount], head);

  0007c	8b 45 ec	 mov	 eax, DWORD PTR _head$1[ebp]
  0007f	50		 push	 eax
  00080	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?SliceCount@@3HA ; SliceCount
  00086	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?MesgSlice@@3PAPADA ; MesgSlice
  0008c	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 _strcpy
  00095	83 c4 08	 add	 esp, 8

; 68   :         SliceCount++;

  00098	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SliceCount@@3HA ; SliceCount
  0009d	83 c0 01	 add	 eax, 1
  000a0	a3 00 00 00 00	 mov	 DWORD PTR ?SliceCount@@3HA, eax ; SliceCount
$LN5@util_Split:

; 69   :       }
; 70   :       head = ptr+1;

  000a5	8b 45 f8	 mov	 eax, DWORD PTR _ptr$2[ebp]
  000a8	83 c0 01	 add	 eax, 1
  000ab	89 45 ec	 mov	 DWORD PTR _head$1[ebp], eax

; 71   :     }

  000ae	eb 88		 jmp	 SHORT $LN2@util_Split
$LN3@util_Split:

; 72   :     strcpy(source, head);	// remove splited slices

  000b0	8b 45 ec	 mov	 eax, DWORD PTR _head$1[ebp]
  000b3	50		 push	 eax
  000b4	8b 4d 08	 mov	 ecx, DWORD PTR _source$[ebp]
  000b7	51		 push	 ecx
  000b8	e8 00 00 00 00	 call	 _strcpy
  000bd	83 c4 08	 add	 esp, 8
$LN1@util_Split:

; 73   :   }
; 74   : }

  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi
  000c2	5b		 pop	 ebx
  000c3	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000c9	3b ec		 cmp	 ebp, esp
  000cb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
?util_SplitMessage@@YAXPAD0@Z ENDP			; util_SplitMessage
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?util_Release@@YAXXZ
_TEXT	SEGMENT
_i$ = -8						; size = 4
?util_Release@@YAXXZ PROC				; util_Release, COMDAT

; 484  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 485  :   int i;
; 486  :   
; 487  : 	if(MesgSlice){

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?MesgSlice@@3PAPADA, 0 ; MesgSlice
  00025	74 60		 je	 SHORT $LN1@util_Relea

; 488  : 		for(i=0;i<SLICE_MAX;i++){

  00027	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002e	eb 09		 jmp	 SHORT $LN4@util_Relea
$LN2@util_Relea:
  00030	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00033	83 c0 01	 add	 eax, 1
  00036	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@util_Relea:
  00039	83 7d f8 14	 cmp	 DWORD PTR _i$[ebp], 20	; 00000014H
  0003d	7d 30		 jge	 SHORT $LN3@util_Relea

; 489  : 			if(MesgSlice[i]){

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00042	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?MesgSlice@@3PAPADA ; MesgSlice
  00048	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  0004c	74 1f		 je	 SHORT $LN6@util_Relea

; 490  : 				FREE(MesgSlice[i]);

  0004e	8b f4		 mov	 esi, esp
  00050	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?MesgSlice@@3PAPADA ; MesgSlice
  00059	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0005c	52		 push	 edx
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00063	83 c4 04	 add	 esp, 4
  00066	3b f4		 cmp	 esi, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@util_Relea:

; 491  : #ifdef  _STONDEBUG_
; 492  : 				g_iMallocCount--;
; 493  : #endif
; 494  : 			}
; 495  : 		}

  0006d	eb c1		 jmp	 SHORT $LN2@util_Relea
$LN3@util_Relea:

; 496  : 		FREE(MesgSlice);

  0006f	8b f4		 mov	 esi, esp
  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR ?MesgSlice@@3PAPADA ; MesgSlice
  00076	50		 push	 eax
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0007d	83 c4 04	 add	 esp, 4
  00080	3b f4		 cmp	 esi, esp
  00082	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@util_Relea:

; 497  : #ifdef  _STONDEBUG_
; 498  : 		g_iMallocCount--;
; 499  : #endif
; 500  : 	}
; 501  : }

  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00090	3b ec		 cmp	 ebp, esp
  00092	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
?util_Release@@YAXXZ ENDP				; util_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\newproto\autil.cpp
;	COMDAT ?util_Init@@YAXXZ
_TEXT	SEGMENT
_i$ = -8						; size = 4
?util_Init@@YAXXZ PROC					; util_Init, COMDAT

; 38   : void util_Init(void){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 39   :   int i;
; 40   :   MesgSlice = (char **) MALLOC(sizeof(char *) * SLICE_MAX);

  0001e	8b f4		 mov	 esi, esp
  00020	6a 50		 push	 80			; 00000050H
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00028	83 c4 04	 add	 esp, 4
  0002b	3b f4		 cmp	 esi, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00032	a3 00 00 00 00	 mov	 DWORD PTR ?MesgSlice@@3PAPADA, eax ; MesgSlice

; 41   : #ifdef  _STONDEBUG_
; 42   : 	g_iMallocCount++;
; 43   : #endif
; 44   :   for (i=0; i<SLICE_MAX; i++){

  00037	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0003e	eb 09		 jmp	 SHORT $LN4@util_Init
$LN2@util_Init:
  00040	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00043	83 c0 01	 add	 eax, 1
  00046	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@util_Init:
  00049	83 7d f8 14	 cmp	 DWORD PTR _i$[ebp], 20	; 00000014H
  0004d	7d 25		 jge	 SHORT $LN3@util_Init

; 45   :     MesgSlice[i] = (char *) MALLOC(SLICE_SIZE);

  0004f	8b f4		 mov	 esi, esp
  00051	68 dc ff 00 00	 push	 65500			; 0000ffdcH
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0005c	83 c4 04	 add	 esp, 4
  0005f	3b f4		 cmp	 esi, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00069	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?MesgSlice@@3PAPADA ; MesgSlice
  0006f	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 46   : #ifdef  _STONDEBUG_
; 47   : 		g_iMallocCount++;
; 48   : #endif
; 49   : 	}

  00072	eb cc		 jmp	 SHORT $LN2@util_Init
$LN3@util_Init:

; 50   :   SliceCount = 0;

  00074	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?SliceCount@@3HA, 0 ; SliceCount

; 51   : }

  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00087	3b ec		 cmp	 ebp, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
?util_Init@@YAXXZ ENDP					; util_Init
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

  0001e	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
  00023	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00026	89 45 ec	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00029	8b 45 ec	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0002c	50		 push	 eax
  0002d	6a 00		 push	 0
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 __vsprintf_l
  0003c	83 c4 10	 add	 esp, 16			; 00000010H
  0003f	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

  00042	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 1788 : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  0001e	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00029	52		 push	 edx
  0002a	6a ff		 push	 -1
  0002c	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 __vsnprintf_l
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -208						; size = 4
__Result$ = -8						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1386 :     int const _Result = __stdio_common_vsprintf(

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  0002f	50		 push	 eax
  00030	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00039	8b 10		 mov	 edx, DWORD PTR [eax]
  0003b	83 ca 01	 or	 edx, 1
  0003e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00041	50		 push	 eax
  00042	52		 push	 edx
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  00049	83 c4 1c	 add	 esp, 28			; 0000001cH
  0004c	3b f4		 cmp	 esi, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00056	83 7d f8 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0005a	7d 0c		 jge	 SHORT $LN3@vsnprintf_
  0005c	c7 85 30 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv74[ebp], -1
  00066	eb 09		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00068	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]
  0006b	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  00071	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv74[ebp]

; 1391 : }

  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00080	3b ec		 cmp	 ebp, esp
  00082	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 144  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
;	COMDAT ?strstr@@YAPADQADQBD@Z
_TEXT	SEGMENT
__String$ = 8						; size = 4
__SubString$ = 12					; size = 4
?strstr@@YAPADQADQBD@Z PROC				; strstr, COMDAT

; 536  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 537  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 0c	 mov	 eax, DWORD PTR __SubString$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR __String$[ebp]
  00027	51		 push	 ecx
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strstr
  0002e	83 c4 08	 add	 esp, 8
  00031	3b f4		 cmp	 esi, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 538  :     }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?strstr@@YAPADQADQBD@Z ENDP				; strstr
_TEXT	ENDS
END
