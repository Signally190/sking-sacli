; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Administrator\Desktop\????? ??\????? ??\Client Source Code\Wgs\Common.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?gmgroup@@3PAUgamegroup@@A			; gmgroup
PUBLIC	?dwServer@@3KA					; dwServer
PUBLIC	?iWGS@@3HA					; iWGS
PUBLIC	?szWGS@@3PADA					; szWGS
PUBLIC	?wWGS@@3GA					; wWGS
PUBLIC	?szCSIP@@3PADA					; szCSIP
PUBLIC	?wCS@@3GA					; wCS
PUBLIC	?szError@@3PADA					; szError
PUBLIC	?szPid@@3PADA					; szPid
PUBLIC	?szAnnouncement@@3PADA				; szAnnouncement
PUBLIC	?szPlain@@3PADA					; szPlain
PUBLIC	?szCipher@@3PADA				; szCipher
PUBLIC	?P_Key@@3PADA					; P_Key
PUBLIC	?P_Key1@@3PADA					; P_Key1
_BSS	SEGMENT
?dwServer@@3KA DD 01H DUP (?)				; dwServer
?iWGS@@3HA DD	01H DUP (?)				; iWGS
?szCSIP@@3PADA DB 07dH DUP (?)				; szCSIP
	ALIGN	4

?wCS@@3GA DW	01H DUP (?)				; wCS
	ALIGN	4

?szError@@3PADA DB 0400H DUP (?)			; szError
?szPid@@3PADA DB 0aH DUP (?)				; szPid
	ALIGN	4

?szAnnouncement@@3PADA DB 0400H DUP (?)			; szAnnouncement
?szPlain@@3PADA DB 050H DUP (?)				; szPlain
?szCipher@@3PADA DB 050H DUP (?)			; szCipher
?P_Key@@3PADA DB 08H DUP (?)				; P_Key
?P_Key1@@3PADA DB 0100H DUP (?)				; P_Key1
_BSS	ENDS
_DATA	SEGMENT
?gmgroup@@3PAUgamegroup@@A DB 031H			; gmgroup
	DB	0eH
	DB	00H
	DB	'ABC', 00H
	ORG $+57
	ORG $+1152
?szWGS@@3PADA DB '210.64.97.28', 00H			; szWGS
	ORG $+3
?wWGS@@3GA DW	032cdH					; wWGS
_DATA	ENDS
PUBLIC	?GetIP_PORT@@YAHPAUParameter@@@Z		; GetIP_PORT
PUBLIC	?GetEncrypt@@YAXPAUParameter@@@Z		; GetEncrypt
PUBLIC	?PKey_Init@@YAXXZ				; PKey_Init
PUBLIC	?ipAddressAnalyze@@YAXXZ			; ipAddressAnalyze
PUBLIC	?ReadWGSMessage@@YAHPADAAH@Z			; ReadWGSMessage
PUBLIC	?DoHellow@@YAXXZ				; DoHellow
PUBLIC	?DoSKey@@YAXXZ					; DoSKey
PUBLIC	?SetTestServer@@YAXXZ				; SetTestServer
PUBLIC	??$strcat_s@$0HP@@@YAHAAY0HP@DPBD@Z		; strcat_s<127>
PUBLIC	??_C@_04JFFKLGJF@?$CF02X?$AA@			; `string'
PUBLIC	??_C@_07LDMIILLH@8904001?$AA@			; `string'
PUBLIC	??_C@_03BBKEAIF@?$DP?$DP?$DP?$AA@		; `string'
PUBLIC	??_C@_05HDEIOAAC@?$DP?$DP?S?$NO?$DP?$AA@	; `string'
PUBLIC	??_C@_09PFCHIMEP@127?40?40?41?$AA@		; `string'
PUBLIC	??_C@_05PKCEPLOA@?$DP?$DP?l?i?$DP?$AA@		; `string'
PUBLIC	??_C@_04DIMBHGPH@7001?$AA@			; `string'
PUBLIC	??_C@_0BA@KLCEACOB@114?4215?4158?4113?$AA@	; `string'
PUBLIC	??_C@_05IHCJPDPG@?$DP?$DP?l?$KD?$DP?$AA@	; `string'
PUBLIC	??_C@_0O@KGEINEL@192?4168?40?4104?$AA@		; `string'
PUBLIC	??_C@_05HIFDGNPO@?$DP?$DP?$NP?$LC?$DP?$AA@	; `string'
PUBLIC	??_C@_0BD@PJBIDGKH@my?4gamma7happy?4com?$AA@	; `string'
PUBLIC	??_C@_05JOIAEPMB@?$DP?$DP?$NO?L?$DP?$AA@	; `string'
PUBLIC	??_C@_05MBDEGLCK@ERROR?$AA@			; `string'
PUBLIC	??_C@_09NGJPPDAN@?t?x?c?$LH?$PL?y?c?w?$DP?$AA@	; `string'
PUBLIC	??_C@_0BP@JBCHKPGG@Software?2Waei?2?$OA?$LE?P?o?$DP?S?$NL?25?400?4000?$AA@ ; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3?$AA@			; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memset:PROC
EXTRN	__imp__strcat_s:PROC
EXTRN	__imp__strtok_s:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__strncpy:PROC
EXTRN	__imp__lstrcpyA@8:PROC
EXTRN	__imp__lstrcatA@8:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	__imp__RegOpenKeyExA@20:PROC
EXTRN	__imp__srand:PROC
EXTRN	__imp__rand:PROC
EXTRN	__imp__atoi:PROC
EXTRN	__imp__CoUninitialize@0:PROC
EXTRN	__imp__CoInitialize@4:PROC
EXTRN	__imp___time64:PROC
EXTRN	?AddParamForFormat@@YAXPADHK@Z:PROC		; AddParamForFormat
EXTRN	?AddParamForFormat@@YAXDK@Z:PROC		; AddParamForFormat
EXTRN	?GetString@@YAPADAAHPAD@Z:PROC			; GetString
EXTRN	?AnalyzeMessage@@YAKPADH@Z:PROC			; AnalyzeMessage
EXTRN	?ReleaseMessHeadParam@@YAPAUParameter@@XZ:PROC	; ReleaseMessHeadParam
EXTRN	?RemoveMessHead@@YAXXZ:PROC			; RemoveMessHead
EXTRN	?ReleaseMessList@@YAXXZ:PROC			; ReleaseMessList
EXTRN	?GetCafeNumber@@YAKXZ:PROC			; GetCafeNumber
EXTRN	?appendWriteBuf@@YAHHPADH@Z:PROC		; appendWriteBuf
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	?RET_OK@@3KB:DWORD				; RET_OK
EXTRN	?messHead@@3PAUMessNode@@A:DWORD		; messHead
EXTRN	?iEncrypt@@3HA:DWORD				; iEncrypt
EXTRN	?idKey@@3USTR_BUFFER@@A:BYTE			; idKey
EXTRN	?passwd@@3USTR_BUFFER@@A:BYTE			; passwd
EXTRN	?gmsv@@3PAUgameserver@@A:BYTE			; gmsv
EXTRN	?nGroup@@3HA:DWORD				; nGroup
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3?$AA@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3?$AA@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JBCHKPGG@Software?2Waei?2?$OA?$LE?P?o?$DP?S?$NL?25?400?4000?$AA@
CONST	SEGMENT
??_C@_0BP@JBCHKPGG@Software?2Waei?2?$OA?$LE?P?o?$DP?S?$NL?25?400?4000?$AA@ DB 'S'
	DB	'oftware\Waei\', 0e0H, 0b4H, 0d0H, 0efH, '?', 0d3H, 0dbH, '\5.'
	DB	'00.000', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09NGJPPDAN@?t?x?c?$LH?$PL?y?c?w?$DP?$AA@
CONST	SEGMENT
??_C@_09NGJPPDAN@?t?x?c?$LH?$PL?y?c?w?$DP?$AA@ DB 0f4H, 0f8H, 0e3H, 0b7H, 0fbH
	DB	0f9H, 0e3H, 0f7H, '?', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MBDEGLCK@ERROR?$AA@
CONST	SEGMENT
??_C@_05MBDEGLCK@ERROR?$AA@ DB 'ERROR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JOIAEPMB@?$DP?$DP?$NO?L?$DP?$AA@
CONST	SEGMENT
??_C@_05JOIAEPMB@?$DP?$DP?$NO?L?$DP?$AA@ DB '??', 0deH, 0ccH, '?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJBIDGKH@my?4gamma7happy?4com?$AA@
CONST	SEGMENT
??_C@_0BD@PJBIDGKH@my?4gamma7happy?4com?$AA@ DB 'my.gamma7happy.com', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05HIFDGNPO@?$DP?$DP?$NP?$LC?$DP?$AA@
CONST	SEGMENT
??_C@_05HIFDGNPO@?$DP?$DP?$NP?$LC?$DP?$AA@ DB '??', 0dfH, 0b2H, '?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KGEINEL@192?4168?40?4104?$AA@
CONST	SEGMENT
??_C@_0O@KGEINEL@192?4168?40?4104?$AA@ DB '192.168.0.104', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05IHCJPDPG@?$DP?$DP?l?$KD?$DP?$AA@
CONST	SEGMENT
??_C@_05IHCJPDPG@?$DP?$DP?l?$KD?$DP?$AA@ DB '??', 0ecH, 0a3H, '?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KLCEACOB@114?4215?4158?4113?$AA@
CONST	SEGMENT
??_C@_0BA@KLCEACOB@114?4215?4158?4113?$AA@ DB '114.215.158.113', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04DIMBHGPH@7001?$AA@
CONST	SEGMENT
??_C@_04DIMBHGPH@7001?$AA@ DB '7001', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PKCEPLOA@?$DP?$DP?l?i?$DP?$AA@
CONST	SEGMENT
??_C@_05PKCEPLOA@?$DP?$DP?l?i?$DP?$AA@ DB '??', 0ecH, 0e9H, '?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PFCHIMEP@127?40?40?41?$AA@
CONST	SEGMENT
??_C@_09PFCHIMEP@127?40?40?41?$AA@ DB '127.0.0.1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05HDEIOAAC@?$DP?$DP?S?$NO?$DP?$AA@
CONST	SEGMENT
??_C@_05HDEIOAAC@?$DP?$DP?S?$NO?$DP?$AA@ DB '??', 0d3H, 0deH, '?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03BBKEAIF@?$DP?$DP?$DP?$AA@
CONST	SEGMENT
??_C@_03BBKEAIF@?$DP?$DP?$DP?$AA@ DB '???', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LDMIILLH@8904001?$AA@
CONST	SEGMENT
??_C@_07LDMIILLH@8904001?$AA@ DB '8904001', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JFFKLGJF@?$CF02X?$AA@
CONST	SEGMENT
??_C@_04JFFKLGJF@?$CF02X?$AA@ DB '%02X', 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
;	COMDAT ??$strcat_s@$0HP@@@YAHAAY0HP@DPBD@Z
_TEXT	SEGMENT
__Destination$ = 8					; size = 4
__Source$ = 12						; size = 4
??$strcat_s@$0HP@@@YAHAAY0HP@DPBD@Z PROC		; strcat_s<127>, COMDAT

; 82   :     )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 78   : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 0c	 mov	 eax, DWORD PTR __Source$[ebp]
  00023	50		 push	 eax
  00024	6a 7f		 push	 127			; 0000007fH
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __Destination$[ebp]
  00029	51		 push	 ecx
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strcat_s
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH
  00033	3b f4		 cmp	 esi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
??$strcat_s@$0HP@@@YAHAAY0HP@DPBD@Z ENDP		; strcat_s<127>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\wgs\common.cpp
;	COMDAT ?SetTestServer@@YAXXZ
_TEXT	SEGMENT
_hr$ = -8						; size = 4
?SetTestServer@@YAXXZ PROC				; SetTestServer, COMDAT

; 211  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 212  : 	ZeroMemory(gmsv, sizeof(gameserver)*MAX_GMSV);

  0001e	68 00 96 00 00	 push	 38400			; 00009600H
  00023	6a 00		 push	 0
  00025	68 00 00 00 00	 push	 OFFSET ?gmsv@@3PAUgameserver@@A
  0002a	e8 00 00 00 00	 call	 _memset
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 213  : 	ZeroMemory(gmgroup, sizeof(gamegroup)*MAX_GMGROUP);

  00032	68 c0 04 00 00	 push	 1216			; 000004c0H
  00037	6a 00		 push	 0
  00039	68 00 00 00 00	 push	 OFFSET ?gmgroup@@3PAUgamegroup@@A
  0003e	e8 00 00 00 00	 call	 _memset
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH

; 214  : 
; 215  : 	nGroup = 2;

  00046	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?nGroup@@3HA, 2 ; nGroup

; 216  : 	strcpy( gmgroup[0].name, "测试区");

  00050	68 00 00 00 00	 push	 OFFSET ??_C@_03BBKEAIF@?$DP?$DP?$DP?$AA@
  00055	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  0005a	6b c8 00	 imul	 ecx, eax, 0
  0005d	81 c1 03 00 00
	00		 add	 ecx, OFFSET ?gmgroup@@3PAUgamegroup@@A+3
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 _strcpy
  00069	83 c4 08	 add	 esp, 8

; 217  : 	gmgroup[0].num = 2;

  0006c	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  00071	6b c8 00	 imul	 ecx, eax, 0
  00074	c6 81 01 00 00
	00 02		 mov	 BYTE PTR ?gmgroup@@3PAUgamegroup@@A[ecx+1], 2

; 218  : 	gmgroup[0].startindex = 0;

  0007b	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  00080	6b c8 00	 imul	 ecx, eax, 0
  00083	c6 81 02 00 00
	00 00		 mov	 BYTE PTR ?gmgroup@@3PAUgamegroup@@A[ecx+2], 0

; 219  : 	gmgroup[0].used = 1;

  0008a	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  0008f	6b c8 00	 imul	 ecx, eax, 0
  00092	c6 81 00 00 00
	00 01		 mov	 BYTE PTR ?gmgroup@@3PAUgamegroup@@A[ecx], 1

; 220  : 	strcpy( gmgroup[1].name, "测试大区");

  00099	68 00 00 00 00	 push	 OFFSET ??_C@_05HDEIOAAC@?$DP?$DP?S?$NO?$DP?$AA@
  0009e	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  000a3	c1 e0 00	 shl	 eax, 0
  000a6	05 03 00 00 00	 add	 eax, OFFSET ?gmgroup@@3PAUgamegroup@@A+3
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _strcpy
  000b1	83 c4 08	 add	 esp, 8

; 221  : 	gmgroup[1].num = 2;

  000b4	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  000b9	c1 e0 00	 shl	 eax, 0
  000bc	c6 80 01 00 00
	00 02		 mov	 BYTE PTR ?gmgroup@@3PAUgamegroup@@A[eax+1], 2

; 222  : 	gmgroup[1].startindex = 2;

  000c3	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  000c8	c1 e0 00	 shl	 eax, 0
  000cb	c6 80 02 00 00
	00 02		 mov	 BYTE PTR ?gmgroup@@3PAUgamegroup@@A[eax+2], 2

; 223  : 	gmgroup[1].used = 1;

  000d2	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  000d7	c1 e0 00	 shl	 eax, 0
  000da	c6 80 00 00 00
	00 01		 mov	 BYTE PTR ?gmgroup@@3PAUgamegroup@@A[eax], 1

; 224  : 
; 225  : 	strcpy( gmsv[0].ipaddr, "127.0.0.1");

  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_09PFCHIMEP@127?40?40?41?$AA@
  000e6	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  000eb	6b c8 00	 imul	 ecx, eax, 0
  000ee	81 c1 01 00 00
	00		 add	 ecx, OFFSET ?gmsv@@3PAUgameserver@@A+1
  000f4	51		 push	 ecx
  000f5	e8 00 00 00 00	 call	 _strcpy
  000fa	83 c4 08	 add	 esp, 8

; 226  : 	strcpy( gmsv[0].name, "测试一线");

  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_05PKCEPLOA@?$DP?$DP?l?i?$DP?$AA@
  00102	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00107	6b c8 00	 imul	 ecx, eax, 0
  0010a	81 c1 c0 00 00
	00		 add	 ecx, OFFSET ?gmsv@@3PAUgameserver@@A+192
  00110	51		 push	 ecx
  00111	e8 00 00 00 00	 call	 _strcpy
  00116	83 c4 08	 add	 esp, 8

; 227  : 	strcpy( gmsv[0].port, "7001");

  00119	68 00 00 00 00	 push	 OFFSET ??_C@_04DIMBHGPH@7001?$AA@
  0011e	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00123	6b c8 00	 imul	 ecx, eax, 0
  00126	81 c1 80 00 00
	00		 add	 ecx, OFFSET ?gmsv@@3PAUgameserver@@A+128
  0012c	51		 push	 ecx
  0012d	e8 00 00 00 00	 call	 _strcpy
  00132	83 c4 08	 add	 esp, 8

; 228  : 	gmsv[0].used = '1';

  00135	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  0013a	6b c8 00	 imul	 ecx, eax, 0
  0013d	c6 81 00 00 00
	00 31		 mov	 BYTE PTR ?gmsv@@3PAUgameserver@@A[ecx], 49 ; 00000031H

; 229  : 
; 230  : 	strcpy( gmsv[1].ipaddr, "114.215.158.113");

  00144	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@KLCEACOB@114?4215?4158?4113?$AA@
  00149	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  0014e	c1 e0 00	 shl	 eax, 0
  00151	05 01 00 00 00	 add	 eax, OFFSET ?gmsv@@3PAUgameserver@@A+1
  00156	50		 push	 eax
  00157	e8 00 00 00 00	 call	 _strcpy
  0015c	83 c4 08	 add	 esp, 8

; 231  : 	strcpy( gmsv[1].name, "测试二线");

  0015f	68 00 00 00 00	 push	 OFFSET ??_C@_05IHCJPDPG@?$DP?$DP?l?$KD?$DP?$AA@
  00164	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00169	c1 e0 00	 shl	 eax, 0
  0016c	05 c0 00 00 00	 add	 eax, OFFSET ?gmsv@@3PAUgameserver@@A+192
  00171	50		 push	 eax
  00172	e8 00 00 00 00	 call	 _strcpy
  00177	83 c4 08	 add	 esp, 8

; 232  : 	strcpy( gmsv[1].port, "7001");

  0017a	68 00 00 00 00	 push	 OFFSET ??_C@_04DIMBHGPH@7001?$AA@
  0017f	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00184	c1 e0 00	 shl	 eax, 0
  00187	05 80 00 00 00	 add	 eax, OFFSET ?gmsv@@3PAUgameserver@@A+128
  0018c	50		 push	 eax
  0018d	e8 00 00 00 00	 call	 _strcpy
  00192	83 c4 08	 add	 esp, 8

; 233  : 	gmsv[1].used = '1';

  00195	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  0019a	c1 e0 00	 shl	 eax, 0
  0019d	c6 80 00 00 00
	00 31		 mov	 BYTE PTR ?gmsv@@3PAUgameserver@@A[eax], 49 ; 00000031H

; 234  : 
; 235  : 	strcpy( gmsv[2].ipaddr, "192.168.0.104");

  001a4	68 00 00 00 00	 push	 OFFSET ??_C@_0O@KGEINEL@192?4168?40?4104?$AA@
  001a9	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  001ae	d1 e0		 shl	 eax, 1
  001b0	05 01 00 00 00	 add	 eax, OFFSET ?gmsv@@3PAUgameserver@@A+1
  001b5	50		 push	 eax
  001b6	e8 00 00 00 00	 call	 _strcpy
  001bb	83 c4 08	 add	 esp, 8

; 236  : 	strcpy( gmsv[2].name, "测试三线");

  001be	68 00 00 00 00	 push	 OFFSET ??_C@_05HIFDGNPO@?$DP?$DP?$NP?$LC?$DP?$AA@
  001c3	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  001c8	d1 e0		 shl	 eax, 1
  001ca	05 c0 00 00 00	 add	 eax, OFFSET ?gmsv@@3PAUgameserver@@A+192
  001cf	50		 push	 eax
  001d0	e8 00 00 00 00	 call	 _strcpy
  001d5	83 c4 08	 add	 esp, 8

; 237  : 	strcpy( gmsv[2].port, "7001");

  001d8	68 00 00 00 00	 push	 OFFSET ??_C@_04DIMBHGPH@7001?$AA@
  001dd	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  001e2	d1 e0		 shl	 eax, 1
  001e4	05 80 00 00 00	 add	 eax, OFFSET ?gmsv@@3PAUgameserver@@A+128
  001e9	50		 push	 eax
  001ea	e8 00 00 00 00	 call	 _strcpy
  001ef	83 c4 08	 add	 esp, 8

; 238  : 	gmsv[2].used = '1';

  001f2	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  001f7	d1 e0		 shl	 eax, 1
  001f9	c6 80 00 00 00
	00 31		 mov	 BYTE PTR ?gmsv@@3PAUgameserver@@A[eax], 49 ; 00000031H

; 239  : 
; 240  : 	strcpy( gmsv[3].ipaddr, "my.gamma7happy.com");

  00200	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@PJBIDGKH@my?4gamma7happy?4com?$AA@
  00205	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  0020a	6b c8 03	 imul	 ecx, eax, 3
  0020d	81 c1 01 00 00
	00		 add	 ecx, OFFSET ?gmsv@@3PAUgameserver@@A+1
  00213	51		 push	 ecx
  00214	e8 00 00 00 00	 call	 _strcpy
  00219	83 c4 08	 add	 esp, 8

; 241  : 	strcpy( gmsv[3].name, "测试四线");

  0021c	68 00 00 00 00	 push	 OFFSET ??_C@_05JOIAEPMB@?$DP?$DP?$NO?L?$DP?$AA@
  00221	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00226	6b c8 03	 imul	 ecx, eax, 3
  00229	81 c1 c0 00 00
	00		 add	 ecx, OFFSET ?gmsv@@3PAUgameserver@@A+192
  0022f	51		 push	 ecx
  00230	e8 00 00 00 00	 call	 _strcpy
  00235	83 c4 08	 add	 esp, 8

; 242  : 	strcpy( gmsv[3].port, "7001");

  00238	68 00 00 00 00	 push	 OFFSET ??_C@_04DIMBHGPH@7001?$AA@
  0023d	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00242	6b c8 03	 imul	 ecx, eax, 3
  00245	81 c1 80 00 00
	00		 add	 ecx, OFFSET ?gmsv@@3PAUgameserver@@A+128
  0024b	51		 push	 ecx
  0024c	e8 00 00 00 00	 call	 _strcpy
  00251	83 c4 08	 add	 esp, 8

; 243  : 	gmsv[3].used = '1';

  00254	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00259	6b c8 03	 imul	 ecx, eax, 3
  0025c	c6 81 00 00 00
	00 31		 mov	 BYTE PTR ?gmsv@@3PAUgameserver@@A[ecx], 49 ; 00000031H

; 244  : 
; 245  : 	HRESULT hr = ::CoInitialize(NULL);

  00263	8b f4		 mov	 esi, esp
  00265	6a 00		 push	 0
  00267	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoInitialize@4
  0026d	3b f4		 cmp	 esi, esp
  0026f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00274	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 246  : 	if (FAILED(hr))

  00277	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0027b	7d 1f		 jge	 SHORT $LN2@SetTestSer

; 247  : 	{
; 248  : 		MessageBoxA(NULL, "初始化失败", "ERROR", MB_OK);

  0027d	8b f4		 mov	 esi, esp
  0027f	6a 00		 push	 0
  00281	68 00 00 00 00	 push	 OFFSET ??_C@_05MBDEGLCK@ERROR?$AA@
  00286	68 00 00 00 00	 push	 OFFSET ??_C@_09NGJPPDAN@?t?x?c?$LH?$PL?y?c?w?$DP?$AA@
  0028b	6a 00		 push	 0
  0028d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  00293	3b f4		 cmp	 esi, esp
  00295	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 249  : 		return;

  0029a	eb 0f		 jmp	 SHORT $LN1@SetTestSer
$LN2@SetTestSer:

; 250  : 	}
; 251  : 	::CoUninitialize();

  0029c	8b f4		 mov	 esi, esp
  0029e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoUninitialize@0
  002a4	3b f4		 cmp	 esi, esp
  002a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@SetTestSer:

; 252  : 
; 253  : }

  002ab	5f		 pop	 edi
  002ac	5e		 pop	 esi
  002ad	5b		 pop	 ebx
  002ae	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  002b4	3b ec		 cmp	 ebp, esp
  002b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002bb	8b e5		 mov	 esp, ebp
  002bd	5d		 pop	 ebp
  002be	c3		 ret	 0
?SetTestServer@@YAXXZ ENDP				; SetTestServer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\wgs\common.cpp
;	COMDAT ?DoSKey@@YAXXZ
_TEXT	SEGMENT
_lpstr$ = -20						; size = 4
_iLen$ = -8						; size = 4
?DoSKey@@YAXXZ PROC					; DoSKey, COMDAT

; 172  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 173  : 	int iLen;
; 174  : 	AddParamForFormat(M_SKEY,FORMAT_START);

  0001e	6a 01		 push	 1
  00020	6a 53		 push	 83			; 00000053H
  00022	e8 00 00 00 00	 call	 ?AddParamForFormat@@YAXDK@Z ; AddParamForFormat
  00027	83 c4 08	 add	 esp, 8

; 175  : 	PKey_Init();

  0002a	e8 00 00 00 00	 call	 ?PKey_Init@@YAXXZ	; PKey_Init

; 176  : 	AddParamForFormat(P_Key1,32,FORMAT_FINISH);

  0002f	6a 02		 push	 2
  00031	6a 20		 push	 32			; 00000020H
  00033	68 00 00 00 00	 push	 OFFSET ?P_Key1@@3PADA	; P_Key1
  00038	e8 00 00 00 00	 call	 ?AddParamForFormat@@YAXPADHK@Z ; AddParamForFormat
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 177  : 	LPTSTR lpstr=GetString(iLen,SZ_ECB);

  00040	68 00 00 00 00	 push	 OFFSET ??_C@_07LDMIILLH@8904001?$AA@
  00045	8d 45 f8	 lea	 eax, DWORD PTR _iLen$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 ?GetString@@YAPADAAHPAD@Z ; GetString
  0004e	83 c4 08	 add	 esp, 8
  00051	89 45 ec	 mov	 DWORD PTR _lpstr$[ebp], eax

; 178  : 	appendWriteBuf(NULL,lpstr,iLen);

  00054	8b 45 f8	 mov	 eax, DWORD PTR _iLen$[ebp]
  00057	50		 push	 eax
  00058	8b 4d ec	 mov	 ecx, DWORD PTR _lpstr$[ebp]
  0005b	51		 push	 ecx
  0005c	6a 00		 push	 0
  0005e	e8 00 00 00 00	 call	 ?appendWriteBuf@@YAHHPADH@Z ; appendWriteBuf
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH

; 179  : }

  00066	52		 push	 edx
  00067	8b cd		 mov	 ecx, ebp
  00069	50		 push	 eax
  0006a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@DoSKey
  00070	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00075	58		 pop	 eax
  00076	5a		 pop	 edx
  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00080	3b ec		 cmp	 ebp, esp
  00082	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
  0008b	90		 npad	 1
$LN5@DoSKey:
  0008c	01 00 00 00	 DD	 1
  00090	00 00 00 00	 DD	 $LN4@DoSKey
$LN4@DoSKey:
  00094	f8 ff ff ff	 DD	 -8			; fffffff8H
  00098	04 00 00 00	 DD	 4
  0009c	00 00 00 00	 DD	 $LN3@DoSKey
$LN3@DoSKey:
  000a0	69		 DB	 105			; 00000069H
  000a1	4c		 DB	 76			; 0000004cH
  000a2	65		 DB	 101			; 00000065H
  000a3	6e		 DB	 110			; 0000006eH
  000a4	00		 DB	 0
?DoSKey@@YAXXZ ENDP					; DoSKey
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\wgs\common.cpp
;	COMDAT ?DoHellow@@YAXXZ
_TEXT	SEGMENT
_lpstr$ = -20						; size = 4
_iLen$ = -8						; size = 4
?DoHellow@@YAXXZ PROC					; DoHellow, COMDAT

; 162  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 163  : 	AddParamForFormat(M_HELO2,FORMAT_START);

  0001e	6a 01		 push	 1
  00020	6a 4a		 push	 74			; 0000004aH
  00022	e8 00 00 00 00	 call	 ?AddParamForFormat@@YAXDK@Z ; AddParamForFormat
  00027	83 c4 08	 add	 esp, 8

; 164  : 	AddParamForFormat(idKey.buffer,idKey.cnt,NULL);

  0002a	6a 00		 push	 0
  0002c	0f b6 05 07 01
	00 00		 movzx	 eax, BYTE PTR ?idKey@@3USTR_BUFFER@@A+263
  00033	50		 push	 eax
  00034	68 00 00 00 00	 push	 OFFSET ?idKey@@3USTR_BUFFER@@A ; idKey
  00039	e8 00 00 00 00	 call	 ?AddParamForFormat@@YAXPADHK@Z ; AddParamForFormat
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 165  : 	AddParamForFormat(passwd.buffer,passwd.cnt,FORMAT_FINISH);

  00041	6a 02		 push	 2
  00043	0f b6 05 07 01
	00 00		 movzx	 eax, BYTE PTR ?passwd@@3USTR_BUFFER@@A+263
  0004a	50		 push	 eax
  0004b	68 00 00 00 00	 push	 OFFSET ?passwd@@3USTR_BUFFER@@A ; passwd
  00050	e8 00 00 00 00	 call	 ?AddParamForFormat@@YAXPADHK@Z ; AddParamForFormat
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH

; 166  : 	int iLen;
; 167  : 	LPTSTR lpstr=GetString(iLen,P_Key);

  00058	68 00 00 00 00	 push	 OFFSET ?P_Key@@3PADA	; P_Key
  0005d	8d 45 f8	 lea	 eax, DWORD PTR _iLen$[ebp]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ?GetString@@YAPADAAHPAD@Z ; GetString
  00066	83 c4 08	 add	 esp, 8
  00069	89 45 ec	 mov	 DWORD PTR _lpstr$[ebp], eax

; 168  : 	appendWriteBuf(NULL,lpstr,iLen);

  0006c	8b 45 f8	 mov	 eax, DWORD PTR _iLen$[ebp]
  0006f	50		 push	 eax
  00070	8b 4d ec	 mov	 ecx, DWORD PTR _lpstr$[ebp]
  00073	51		 push	 ecx
  00074	6a 00		 push	 0
  00076	e8 00 00 00 00	 call	 ?appendWriteBuf@@YAHHPADH@Z ; appendWriteBuf
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 169  : }

  0007e	52		 push	 edx
  0007f	8b cd		 mov	 ecx, ebp
  00081	50		 push	 eax
  00082	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@DoHellow
  00088	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0008d	58		 pop	 eax
  0008e	5a		 pop	 edx
  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx
  00092	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00098	3b ec		 cmp	 ebp, esp
  0009a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
  000a3	90		 npad	 1
$LN5@DoHellow:
  000a4	01 00 00 00	 DD	 1
  000a8	00 00 00 00	 DD	 $LN4@DoHellow
$LN4@DoHellow:
  000ac	f8 ff ff ff	 DD	 -8			; fffffff8H
  000b0	04 00 00 00	 DD	 4
  000b4	00 00 00 00	 DD	 $LN3@DoHellow
$LN3@DoHellow:
  000b8	69		 DB	 105			; 00000069H
  000b9	4c		 DB	 76			; 0000004cH
  000ba	65		 DB	 101			; 00000065H
  000bb	6e		 DB	 110			; 0000006eH
  000bc	00		 DB	 0
?DoHellow@@YAXXZ ENDP					; DoHellow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\wgs\common.cpp
;	COMDAT ?ReadWGSMessage@@YAHPADAAH@Z
_TEXT	SEGMENT
_param$ = -20						; size = 4
_cMessage$ = -5						; size = 1
_lpstr$ = 8						; size = 4
_iStrLen$ = 12						; size = 4
?ReadWGSMessage@@YAHPADAAH@Z PROC			; ReadWGSMessage, COMDAT

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 57   : 	TCHAR cMessage=0;

  0001e	c6 45 fb 00	 mov	 BYTE PTR _cMessage$[ebp], 0

; 58   : 	Parameter *param;
; 59   : 	if(RET_OK==AnalyzeMessage(lpstr,iStrLen)){

  00022	8b 45 0c	 mov	 eax, DWORD PTR _iStrLen$[ebp]
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	51		 push	 ecx
  00028	8b 55 08	 mov	 edx, DWORD PTR _lpstr$[ebp]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ?AnalyzeMessage@@YAKPADH@Z ; AnalyzeMessage
  00031	83 c4 08	 add	 esp, 8
  00034	39 05 00 00 00
	00		 cmp	 DWORD PTR ?RET_OK@@3KB, eax ; RET_OK
  0003a	0f 85 e1 01 00
	00		 jne	 $LN6@ReadWGSMes

; 60   : 		if(WGS==dwServer){

  00040	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?dwServer@@3KA, 1 ; dwServer
  00047	0f 85 e9 00 00
	00		 jne	 $LN4@ReadWGSMes
$LN2@ReadWGSMes:

; 61   : 			while(messHead){

  0004d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?messHead@@3PAUMessNode@@A, 0 ; messHead
  00054	0f 84 d7 00 00
	00		 je	 $LN3@ReadWGSMes

; 62   : 				cMessage=*messHead->param->lpstrParam;

  0005a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?messHead@@3PAUMessNode@@A ; messHead
  0005f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00062	8b 11		 mov	 edx, DWORD PTR [ecx]
  00064	8a 02		 mov	 al, BYTE PTR [edx]
  00066	88 45 fb	 mov	 BYTE PTR _cMessage$[ebp], al

; 63   : 				param=ReleaseMessHeadParam();

  00069	e8 00 00 00 00	 call	 ?ReleaseMessHeadParam@@YAPAUParameter@@XZ ; ReleaseMessHeadParam
  0006e	89 45 ec	 mov	 DWORD PTR _param$[ebp], eax

; 64   : 				if(M_REDI==cMessage){

  00071	0f be 45 fb	 movsx	 eax, BYTE PTR _cMessage$[ebp]
  00075	83 f8 52	 cmp	 eax, 82			; 00000052H
  00078	75 24		 jne	 SHORT $LN10@ReadWGSMes

; 65   : 					if(GetIP_PORT(param)){

  0007a	8b 45 ec	 mov	 eax, DWORD PTR _param$[ebp]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ?GetIP_PORT@@YAHPAUParameter@@@Z ; GetIP_PORT
  00083	83 c4 04	 add	 esp, 4
  00086	85 c0		 test	 eax, eax
  00088	74 0f		 je	 SHORT $LN12@ReadWGSMes

; 66   : 						iWGS=2;

  0008a	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?iWGS@@3HA, 2	; iWGS

; 67   : 						ReleaseMessList();

  00094	e8 00 00 00 00	 call	 ?ReleaseMessList@@YAXXZ	; ReleaseMessList
$LN12@ReadWGSMes:

; 68   : 					}

  00099	e9 89 00 00 00	 jmp	 $LN11@ReadWGSMes
$LN10@ReadWGSMes:

; 69   : 				}else if(M_PKEY==cMessage){

  0009e	0f be 45 fb	 movsx	 eax, BYTE PTR _cMessage$[ebp]
  000a2	83 f8 54	 cmp	 eax, 84			; 00000054H
  000a5	75 36		 jne	 SHORT $LN13@ReadWGSMes

; 70   : 					iEncrypt=E_ECB;

  000a7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?iEncrypt@@3HA, 1 ; iEncrypt

; 71   : 					dwServer=CS;

  000b1	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 2 ; dwServer

; 72   : 					GetEncrypt(param);

  000bb	8b 45 ec	 mov	 eax, DWORD PTR _param$[ebp]
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 ?GetEncrypt@@YAXPAUParameter@@@Z ; GetEncrypt
  000c4	83 c4 04	 add	 esp, 4

; 73   : 					PKey_Init();

  000c7	e8 00 00 00 00	 call	 ?PKey_Init@@YAXXZ	; PKey_Init

; 74   : 					iWGS=4;

  000cc	c7 05 00 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?iWGS@@3HA, 4	; iWGS

; 75   : 					ReleaseMessList();

  000d6	e8 00 00 00 00	 call	 ?ReleaseMessList@@YAXXZ	; ReleaseMessList
  000db	eb 4a		 jmp	 SHORT $LN11@ReadWGSMes
$LN13@ReadWGSMes:

; 76   : 				}else if(M_ERRO==cMessage){

  000dd	0f be 45 fb	 movsx	 eax, BYTE PTR _cMessage$[ebp]
  000e1	83 f8 45	 cmp	 eax, 69			; 00000045H
  000e4	75 41		 jne	 SHORT $LN11@ReadWGSMes

; 77   : 					iWGS=9;

  000e6	c7 05 00 00 00
	00 09 00 00 00	 mov	 DWORD PTR ?iWGS@@3HA, 9	; iWGS

; 78   : 					if(messHead->param && messHead->param->lpstrParam)

  000f0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?messHead@@3PAUMessNode@@A ; messHead
  000f5	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000f9	74 2c		 je	 SHORT $LN11@ReadWGSMes
  000fb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?messHead@@3PAUMessNode@@A ; messHead
  00100	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00103	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00106	74 1f		 je	 SHORT $LN11@ReadWGSMes

; 79   : 						lstrcpy(szError,messHead->param->lpstrParam);

  00108	a1 00 00 00 00	 mov	 eax, DWORD PTR ?messHead@@3PAUMessNode@@A ; messHead
  0010d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00110	8b f4		 mov	 esi, esp
  00112	8b 11		 mov	 edx, DWORD PTR [ecx]
  00114	52		 push	 edx
  00115	68 00 00 00 00	 push	 OFFSET ?szError@@3PADA	; szError
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8
  00120	3b f4		 cmp	 esi, esp
  00122	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN11@ReadWGSMes:

; 80   : 				}
; 81   : 				RemoveMessHead();

  00127	e8 00 00 00 00	 call	 ?RemoveMessHead@@YAXXZ	; RemoveMessHead

; 82   : 			}

  0012c	e9 1c ff ff ff	 jmp	 $LN2@ReadWGSMes
$LN3@ReadWGSMes:

; 83   : 		}else{

  00131	e9 e9 00 00 00	 jmp	 $LN9@ReadWGSMes
$LN4@ReadWGSMes:

; 84   : 			while(messHead){

  00136	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?messHead@@3PAUMessNode@@A, 0 ; messHead
  0013d	0f 84 dc 00 00
	00		 je	 $LN9@ReadWGSMes

; 85   : 				cMessage=*messHead->param->lpstrParam;

  00143	a1 00 00 00 00	 mov	 eax, DWORD PTR ?messHead@@3PAUMessNode@@A ; messHead
  00148	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0014b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0014d	8a 02		 mov	 al, BYTE PTR [edx]
  0014f	88 45 fb	 mov	 BYTE PTR _cMessage$[ebp], al

; 86   : 				param=ReleaseMessHeadParam();

  00152	e8 00 00 00 00	 call	 ?ReleaseMessHeadParam@@YAPAUParameter@@XZ ; ReleaseMessHeadParam
  00157	89 45 ec	 mov	 DWORD PTR _param$[ebp], eax

; 87   : 				if(M_PKEY==cMessage){

  0015a	0f be 45 fb	 movsx	 eax, BYTE PTR _cMessage$[ebp]
  0015e	83 f8 54	 cmp	 eax, 84			; 00000054H
  00161	75 25		 jne	 SHORT $LN17@ReadWGSMes

; 88   : 					iEncrypt=E_ECB;

  00163	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?iEncrypt@@3HA, 1 ; iEncrypt

; 89   : 					GetEncrypt(param);

  0016d	8b 45 ec	 mov	 eax, DWORD PTR _param$[ebp]
  00170	50		 push	 eax
  00171	e8 00 00 00 00	 call	 ?GetEncrypt@@YAXPAUParameter@@@Z ; GetEncrypt
  00176	83 c4 04	 add	 esp, 4

; 90   : 					iWGS=4;

  00179	c7 05 00 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?iWGS@@3HA, 4	; iWGS
  00183	e9 8d 00 00 00	 jmp	 $LN18@ReadWGSMes
$LN17@ReadWGSMes:

; 91   : 				}else if(M_CONT==cMessage){

  00188	0f be 45 fb	 movsx	 eax, BYTE PTR _cMessage$[ebp]
  0018c	83 f8 55	 cmp	 eax, 85			; 00000055H
  0018f	75 0c		 jne	 SHORT $LN19@ReadWGSMes

; 92   : 					iWGS=6;

  00191	c7 05 00 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?iWGS@@3HA, 6	; iWGS
  0019b	eb 78		 jmp	 SHORT $LN18@ReadWGSMes
$LN19@ReadWGSMes:

; 93   : 				}else if(M_GOTO==cMessage){

  0019d	0f be 45 fb	 movsx	 eax, BYTE PTR _cMessage$[ebp]
  001a1	83 f8 47	 cmp	 eax, 71			; 00000047H
  001a4	75 20		 jne	 SHORT $LN21@ReadWGSMes

; 94   : 					iWGS=8;

  001a6	c7 05 00 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?iWGS@@3HA, 8	; iWGS

; 95   : 					iEncrypt=E_NO;

  001b0	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?iEncrypt@@3HA, 2 ; iEncrypt

; 96   : 					ipAddressAnalyze();

  001ba	e8 00 00 00 00	 call	 ?ipAddressAnalyze@@YAXXZ ; ipAddressAnalyze

; 97   : 					ReleaseMessList();

  001bf	e8 00 00 00 00	 call	 ?ReleaseMessList@@YAXXZ	; ReleaseMessList
  001c4	eb 4f		 jmp	 SHORT $LN18@ReadWGSMes
$LN21@ReadWGSMes:

; 98   : 				}else if(M_ERRO==cMessage){

  001c6	0f be 45 fb	 movsx	 eax, BYTE PTR _cMessage$[ebp]
  001ca	83 f8 45	 cmp	 eax, 69			; 00000045H
  001cd	75 46		 jne	 SHORT $LN18@ReadWGSMes

; 99   : 					iWGS=9;

  001cf	c7 05 00 00 00
	00 09 00 00 00	 mov	 DWORD PTR ?iWGS@@3HA, 9	; iWGS

; 100  : 					if(messHead->param && messHead->param->lpstrParam)

  001d9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?messHead@@3PAUMessNode@@A ; messHead
  001de	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  001e2	74 2c		 je	 SHORT $LN24@ReadWGSMes
  001e4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?messHead@@3PAUMessNode@@A ; messHead
  001e9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001ec	83 39 00	 cmp	 DWORD PTR [ecx], 0
  001ef	74 1f		 je	 SHORT $LN24@ReadWGSMes

; 101  : 						lstrcpy(szError,messHead->param->lpstrParam);

  001f1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?messHead@@3PAUMessNode@@A ; messHead
  001f6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001f9	8b f4		 mov	 esi, esp
  001fb	8b 11		 mov	 edx, DWORD PTR [ecx]
  001fd	52		 push	 edx
  001fe	68 00 00 00 00	 push	 OFFSET ?szError@@3PADA	; szError
  00203	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8
  00209	3b f4		 cmp	 esi, esp
  0020b	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN24@ReadWGSMes:

; 102  : 					ReleaseMessList();

  00210	e8 00 00 00 00	 call	 ?ReleaseMessList@@YAXXZ	; ReleaseMessList
$LN18@ReadWGSMes:

; 103  : 				}
; 104  : 				RemoveMessHead();

  00215	e8 00 00 00 00	 call	 ?RemoveMessHead@@YAXXZ	; RemoveMessHead

; 105  : 			}

  0021a	e9 17 ff ff ff	 jmp	 $LN4@ReadWGSMes
$LN9@ReadWGSMes:

; 106  : 		}
; 107  : 	}else

  0021f	eb 04		 jmp	 SHORT $LN7@ReadWGSMes
$LN6@ReadWGSMes:

; 108  : 		return FALSE;

  00221	33 c0		 xor	 eax, eax
  00223	eb 0e		 jmp	 SHORT $LN1@ReadWGSMes
$LN7@ReadWGSMes:

; 109  : 	iStrLen=0;

  00225	8b 45 0c	 mov	 eax, DWORD PTR _iStrLen$[ebp]
  00228	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 110  : 	return TRUE;

  0022e	b8 01 00 00 00	 mov	 eax, 1
$LN1@ReadWGSMes:

; 111  : }

  00233	5f		 pop	 edi
  00234	5e		 pop	 esi
  00235	5b		 pop	 ebx
  00236	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0023c	3b ec		 cmp	 ebp, esp
  0023e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00243	8b e5		 mov	 esp, ebp
  00245	5d		 pop	 ebp
  00246	c3		 ret	 0
?ReadWGSMessage@@YAHPADAAH@Z ENDP			; ReadWGSMessage
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\wgs\common.cpp
;	COMDAT ?ipAddressAnalyze@@YAXXZ
_TEXT	SEGMENT
$T1 = -420						; size = 4
_sss$2 = -216						; size = 4
_sss$3 = -204						; size = 4
_j$4 = -192						; size = 4
_i$5 = -180						; size = 4
_hkey$ = -168						; size = 4
_param$ = -156						; size = 4
_dwCafeKey$ = -144					; size = 4
_lpstrTemp$ = -132					; size = 4
_indexgm$ = -120					; size = 4
_nGroup1$ = -108					; size = 4
_dwResult$ = -96					; size = 4
_dwID$ = -84						; size = 4
_dwLevel$ = -72						; size = 4
_szIP$ = -60						; size = 50
__$ArrayPad$ = -4					; size = 4
?ipAddressAnalyze@@YAXXZ PROC				; ipAddressAnalyze, COMDAT

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 01 00
	00		 sub	 esp, 424		; 000001a8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 58 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-424]
  00012	b9 6a 00 00 00	 mov	 ecx, 106		; 0000006aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 257  : 	char szIP[50];
; 258  : 	DWORD dwLevel = 0;

  00028	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _dwLevel$[ebp], 0

; 259  : 	DWORD dwID, dwResult;
; 260  : 	int nGroup1, indexgm;
; 261  : 	LPSTR lpstrTemp;
; 262  : 	DWORD dwCafeKey = GetCafeNumber();

  0002f	e8 00 00 00 00	 call	 ?GetCafeNumber@@YAKXZ	; GetCafeNumber
  00034	89 85 70 ff ff
	ff		 mov	 DWORD PTR _dwCafeKey$[ebp], eax

; 263  : 	Parameter *param = messHead->param;

  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?messHead@@3PAUMessNode@@A ; messHead
  0003f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00042	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _param$[ebp], ecx

; 264  : 	HKEY		hkey;
; 265  : 	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Software\\Waei\\石器时代\\5.00.000", 0, KEY_READ, &hkey) == ERROR_SUCCESS) {

  00048	8b f4		 mov	 esi, esp
  0004a	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _hkey$[ebp]
  00050	50		 push	 eax
  00051	68 19 00 02 00	 push	 131097			; 00020019H
  00056	6a 00		 push	 0
  00058	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@JBCHKPGG@Software?2Waei?2?$OA?$LE?P?o?$DP?S?$NL?25?400?4000?$AA@
  0005d	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00068	3b f4		 cmp	 esi, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	85 c0		 test	 eax, eax
  00071	75 25		 jne	 SHORT $LN8@ipAddressA

; 266  : 		dwCafeKey |= 0x02;

  00073	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _dwCafeKey$[ebp]
  00079	83 c8 02	 or	 eax, 2
  0007c	89 85 70 ff ff
	ff		 mov	 DWORD PTR _dwCafeKey$[ebp], eax

; 267  : 		RegCloseKey(hkey);

  00082	8b f4		 mov	 esi, esp
  00084	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _hkey$[ebp]
  0008a	50		 push	 eax
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  00091	3b f4		 cmp	 esi, esp
  00093	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN8@ipAddressA:

; 268  : 	}
; 269  : 	if (param && param->lpstrParam) {

  00098	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR _param$[ebp], 0
  0009f	0f 84 4e 04 00
	00		 je	 $LN30@ipAddressA
  000a5	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _param$[ebp]
  000ab	83 38 00	 cmp	 DWORD PTR [eax], 0
  000ae	0f 84 3f 04 00
	00		 je	 $LN30@ipAddressA

; 270  : 		nGroup = 0;//

  000b4	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?nGroup@@3HA, 0 ; nGroup

; 271  : 		indexgm = 0;

  000be	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _indexgm$[ebp], 0

; 272  : 		ZeroMemory(gmsv, sizeof(gameserver)*MAX_GMSV);

  000c5	68 00 96 00 00	 push	 38400			; 00009600H
  000ca	6a 00		 push	 0
  000cc	68 00 00 00 00	 push	 OFFSET ?gmsv@@3PAUgameserver@@A
  000d1	e8 00 00 00 00	 call	 _memset
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 273  : 		ZeroMemory(gmgroup, sizeof(gamegroup)*MAX_GMGROUP);

  000d9	68 c0 04 00 00	 push	 1216			; 000004c0H
  000de	6a 00		 push	 0
  000e0	68 00 00 00 00	 push	 OFFSET ?gmgroup@@3PAUgamegroup@@A
  000e5	e8 00 00 00 00	 call	 _memset
  000ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 274  : 		nGroup1 = atoi(param->lpstrParam);

  000ed	8b f4		 mov	 esi, esp
  000ef	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _param$[ebp]
  000f5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f7	51		 push	 ecx
  000f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  000fe	83 c4 04	 add	 esp, 4
  00101	3b f4		 cmp	 esi, esp
  00103	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00108	89 45 94	 mov	 DWORD PTR _nGroup1$[ebp], eax

; 275  : 		if (nGroup1 > MAX_GMGROUP)

  0010b	83 7d 94 13	 cmp	 DWORD PTR _nGroup1$[ebp], 19 ; 00000013H
  0010f	7e 07		 jle	 SHORT $LN10@ipAddressA

; 276  : 			nGroup1 = MAX_GMGROUP;

  00111	c7 45 94 13 00
	00 00		 mov	 DWORD PTR _nGroup1$[ebp], 19 ; 00000013H
$LN10@ipAddressA:

; 277  : 		param = ReleaseMessHeadParam();

  00118	e8 00 00 00 00	 call	 ?ReleaseMessHeadParam@@YAPAUParameter@@XZ ; ReleaseMessHeadParam
  0011d	89 85 64 ff ff
	ff		 mov	 DWORD PTR _param$[ebp], eax

; 278  : 
; 279  : #ifdef _SHOW_COUNT						// WON ADD 秀服务器流量
; 280  : 		if (param && param->lpstrParam) {
; 281  : 			param = ReleaseMessHeadParam();
; 282  : 		}
; 283  : #endif
; 284  : 
; 285  : 		for (int i = 0; i < nGroup1; i++) {

  00123	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$5[ebp], 0
  0012d	eb 0f		 jmp	 SHORT $LN4@ipAddressA
$LN2@ipAddressA:
  0012f	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _i$5[ebp]
  00135	83 c0 01	 add	 eax, 1
  00138	89 85 4c ff ff
	ff		 mov	 DWORD PTR _i$5[ebp], eax
$LN4@ipAddressA:
  0013e	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _i$5[ebp]
  00144	3b 45 94	 cmp	 eax, DWORD PTR _nGroup1$[ebp]
  00147	0f 8d 41 03 00
	00		 jge	 $LN3@ipAddressA

; 286  : 			if (param && param->lpstrParam) {

  0014d	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR _param$[ebp], 0
  00154	74 5f		 je	 SHORT $LN11@ipAddressA
  00156	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _param$[ebp]
  0015c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0015f	74 54		 je	 SHORT $LN11@ipAddressA

; 287  : 				dwID = atoi(param->lpstrParam);

  00161	8b f4		 mov	 esi, esp
  00163	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _param$[ebp]
  00169	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016b	51		 push	 ecx
  0016c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00172	83 c4 04	 add	 esp, 4
  00175	3b f4		 cmp	 esi, esp
  00177	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0017c	89 45 ac	 mov	 DWORD PTR _dwID$[ebp], eax

; 288  : 				param = ReleaseMessHeadParam();

  0017f	e8 00 00 00 00	 call	 ?ReleaseMessHeadParam@@YAPAUParameter@@XZ ; ReleaseMessHeadParam
  00184	89 85 64 ff ff
	ff		 mov	 DWORD PTR _param$[ebp], eax

; 289  : 				dwResult = dwID & dwCafeKey;

  0018a	8b 45 ac	 mov	 eax, DWORD PTR _dwID$[ebp]
  0018d	23 85 70 ff ff
	ff		 and	 eax, DWORD PTR _dwCafeKey$[ebp]
  00193	89 45 a0	 mov	 DWORD PTR _dwResult$[ebp], eax

; 290  : 				dwLevel = 1;				//可以选

  00196	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR _dwLevel$[ebp], 1

; 291  : 				if (dwCafeKey) {

  0019d	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR _dwCafeKey$[ebp], 0
  001a4	74 02		 je	 SHORT $LN12@ipAddressA

; 292  : 					// 只要有小地球就可以看到所有星系
; 293  : 					/*if(dwID){
; 294  : 					if( 0 == dwResult)
; 295  : 					dwLevel = 0;	//看不到
; 296  : 					}*/
; 297  : 				}
; 298  : 				else {

  001a6	eb 0d		 jmp	 SHORT $LN11@ipAddressA
$LN12@ipAddressA:

; 299  : 					if (dwID) {

  001a8	83 7d ac 00	 cmp	 DWORD PTR _dwID$[ebp], 0
  001ac	74 07		 je	 SHORT $LN11@ipAddressA

; 300  : 						dwLevel = 0;//看不到						

  001ae	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _dwLevel$[ebp], 0
$LN11@ipAddressA:

; 301  : 					}
; 302  : #ifdef _8_TEST
; 303  : 					if (dwID == 2)
; 304  : 						dwLevel = 1;
; 305  : 					else
; 306  : 						dwLevel = 0;
; 307  : #endif
; 308  : 				}
; 309  : 				/*
; 310  : 				dwLevel = 1;	//可以选
; 311  : 				if( 0 == dwResult){
; 312  : 				if( dwID > 1)
; 313  : 				dwLevel = 2;	//只能看不能选
; 314  : 				else if( 1 == dwID)
; 315  : 				dwLevel = 0;	//看不到
; 316  : 				}
; 317  : 				*/
; 318  : 			}
; 319  : 			if (param && param->lpstrParam) {

  001b5	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR _param$[ebp], 0
  001bc	74 3d		 je	 SHORT $LN15@ipAddressA
  001be	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _param$[ebp]
  001c4	83 38 00	 cmp	 DWORD PTR [eax], 0
  001c7	74 32		 je	 SHORT $LN15@ipAddressA

; 320  : 				if (dwLevel)

  001c9	83 7d b8 00	 cmp	 DWORD PTR _dwLevel$[ebp], 0
  001cd	74 21		 je	 SHORT $LN16@ipAddressA

; 321  : 					strcpy(gmgroup[nGroup].name, param->lpstrParam);

  001cf	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _param$[ebp]
  001d5	8b 08		 mov	 ecx, DWORD PTR [eax]
  001d7	51		 push	 ecx
  001d8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?nGroup@@3HA ; nGroup
  001de	c1 e2 06	 shl	 edx, 6
  001e1	81 c2 03 00 00
	00		 add	 edx, OFFSET ?gmgroup@@3PAUgamegroup@@A+3
  001e7	52		 push	 edx
  001e8	e8 00 00 00 00	 call	 _strcpy
  001ed	83 c4 08	 add	 esp, 8
$LN16@ipAddressA:

; 322  : 				param = ReleaseMessHeadParam();

  001f0	e8 00 00 00 00	 call	 ?ReleaseMessHeadParam@@YAPAUParameter@@XZ ; ReleaseMessHeadParam
  001f5	89 85 64 ff ff
	ff		 mov	 DWORD PTR _param$[ebp], eax
$LN15@ipAddressA:

; 323  : 			}
; 324  : 			if (param && param->lpstrParam) {

  001fb	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR _param$[ebp], 0
  00202	74 40		 je	 SHORT $LN17@ipAddressA
  00204	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _param$[ebp]
  0020a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0020d	74 35		 je	 SHORT $LN17@ipAddressA

; 325  : 				gmgroup[nGroup].num = atoi(param->lpstrParam);

  0020f	8b f4		 mov	 esi, esp
  00211	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _param$[ebp]
  00217	8b 08		 mov	 ecx, DWORD PTR [eax]
  00219	51		 push	 ecx
  0021a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00220	83 c4 04	 add	 esp, 4
  00223	3b f4		 cmp	 esi, esp
  00225	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0022a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?nGroup@@3HA ; nGroup
  00230	c1 e2 06	 shl	 edx, 6
  00233	88 82 01 00 00
	00		 mov	 BYTE PTR ?gmgroup@@3PAUgamegroup@@A[edx+1], al

; 326  : 				param = ReleaseMessHeadParam();

  00239	e8 00 00 00 00	 call	 ?ReleaseMessHeadParam@@YAPAUParameter@@XZ ; ReleaseMessHeadParam
  0023e	89 85 64 ff ff
	ff		 mov	 DWORD PTR _param$[ebp], eax
$LN17@ipAddressA:

; 327  : 			}
; 328  : 			if (param && param->lpstrParam) {

  00244	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR _param$[ebp], 0
  0024b	0f 84 38 02 00
	00		 je	 $LN18@ipAddressA
  00251	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _param$[ebp]
  00257	83 38 00	 cmp	 DWORD PTR [eax], 0
  0025a	0f 84 29 02 00
	00		 je	 $LN18@ipAddressA

; 329  : 				strcpy(szIP, param->lpstrParam);

  00260	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _param$[ebp]
  00266	8b 08		 mov	 ecx, DWORD PTR [eax]
  00268	51		 push	 ecx
  00269	8d 55 c4	 lea	 edx, DWORD PTR _szIP$[ebp]
  0026c	52		 push	 edx
  0026d	e8 00 00 00 00	 call	 _strcpy
  00272	83 c4 08	 add	 esp, 8

; 330  : 				param = ReleaseMessHeadParam();

  00275	e8 00 00 00 00	 call	 ?ReleaseMessHeadParam@@YAPAUParameter@@XZ ; ReleaseMessHeadParam
  0027a	89 85 64 ff ff
	ff		 mov	 DWORD PTR _param$[ebp], eax

; 331  : 				gmgroup[nGroup].startindex = indexgm;

  00280	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nGroup@@3HA ; nGroup
  00285	c1 e0 06	 shl	 eax, 6
  00288	8a 4d 88	 mov	 cl, BYTE PTR _indexgm$[ebp]
  0028b	88 88 02 00 00
	00		 mov	 BYTE PTR ?gmgroup@@3PAUgamegroup@@A[eax+2], cl

; 332  : 
; 333  : #ifdef _SHOW_COUNT						// WON ADD 秀服务器流量
; 334  : 				if (param && param->lpstrParam) {
; 335  : 					param = ReleaseMessHeadParam();
; 336  : 				}
; 337  : #endif
; 338  : 
; 339  : 
; 340  : 				for (int j = 0; j<gmgroup[nGroup].num && indexgm < MAX_GMSV; j++, indexgm++) {

  00291	c7 85 40 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$4[ebp], 0
  0029b	eb 18		 jmp	 SHORT $LN7@ipAddressA
$LN5@ipAddressA:
  0029d	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _j$4[ebp]
  002a3	83 c0 01	 add	 eax, 1
  002a6	89 85 40 ff ff
	ff		 mov	 DWORD PTR _j$4[ebp], eax
  002ac	8b 4d 88	 mov	 ecx, DWORD PTR _indexgm$[ebp]
  002af	83 c1 01	 add	 ecx, 1
  002b2	89 4d 88	 mov	 DWORD PTR _indexgm$[ebp], ecx
$LN7@ipAddressA:
  002b5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nGroup@@3HA ; nGroup
  002ba	c1 e0 06	 shl	 eax, 6
  002bd	0f be 88 01 00
	00 00		 movsx	 ecx, BYTE PTR ?gmgroup@@3PAUgamegroup@@A[eax+1]
  002c4	39 8d 40 ff ff
	ff		 cmp	 DWORD PTR _j$4[ebp], ecx
  002ca	0f 8d 95 01 00
	00		 jge	 $LN6@ipAddressA
  002d0	81 7d 88 96 00
	00 00		 cmp	 DWORD PTR _indexgm$[ebp], 150 ; 00000096H
  002d7	0f 8d 88 01 00
	00		 jge	 $LN6@ipAddressA

; 341  : 					if (param && param->lpstrParam) {

  002dd	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR _param$[ebp], 0
  002e4	74 3a		 je	 SHORT $LN19@ipAddressA
  002e6	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _param$[ebp]
  002ec	83 38 00	 cmp	 DWORD PTR [eax], 0
  002ef	74 2f		 je	 SHORT $LN19@ipAddressA

; 342  : 						if (dwLevel)

  002f1	83 7d b8 00	 cmp	 DWORD PTR _dwLevel$[ebp], 0
  002f5	74 1e		 je	 SHORT $LN20@ipAddressA

; 343  : 							strcpy(gmsv[indexgm].name, param->lpstrParam);

  002f7	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _param$[ebp]
  002fd	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ff	51		 push	 ecx
  00300	8b 55 88	 mov	 edx, DWORD PTR _indexgm$[ebp]
  00303	c1 e2 08	 shl	 edx, 8
  00306	81 c2 c0 00 00
	00		 add	 edx, OFFSET ?gmsv@@3PAUgameserver@@A+192
  0030c	52		 push	 edx
  0030d	e8 00 00 00 00	 call	 _strcpy
  00312	83 c4 08	 add	 esp, 8
$LN20@ipAddressA:

; 344  : 						param = ReleaseMessHeadParam();

  00315	e8 00 00 00 00	 call	 ?ReleaseMessHeadParam@@YAPAUParameter@@XZ ; ReleaseMessHeadParam
  0031a	89 85 64 ff ff
	ff		 mov	 DWORD PTR _param$[ebp], eax
$LN19@ipAddressA:

; 345  : 					}
; 346  : 					if (param && param->lpstrParam) {

  00320	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR _param$[ebp], 0
  00327	0f 84 33 01 00
	00		 je	 $LN21@ipAddressA
  0032d	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _param$[ebp]
  00333	83 38 00	 cmp	 DWORD PTR [eax], 0
  00336	0f 84 24 01 00
	00		 je	 $LN21@ipAddressA

; 347  : 						if (dwLevel) {

  0033c	83 7d b8 00	 cmp	 DWORD PTR _dwLevel$[ebp], 0
  00340	0f 84 0f 01 00
	00		 je	 $LN22@ipAddressA

; 348  : 							char *sss;
; 349  : 							if (lpstrTemp = strtok_s(param->lpstrParam, ":", &sss)) {

  00346	8b f4		 mov	 esi, esp
  00348	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _sss$3[ebp]
  0034e	50		 push	 eax
  0034f	68 00 00 00 00	 push	 OFFSET ??_C@_01JLIPDDHJ@?3?$AA@
  00354	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _param$[ebp]
  0035a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0035c	52		 push	 edx
  0035d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtok_s
  00363	83 c4 0c	 add	 esp, 12			; 0000000cH
  00366	3b f4		 cmp	 esi, esp
  00368	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0036d	89 85 7c ff ff
	ff		 mov	 DWORD PTR _lpstrTemp$[ebp], eax
  00373	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR _lpstrTemp$[ebp], 0
  0037a	0f 84 d5 00 00
	00		 je	 $LN22@ipAddressA

; 350  : 								if (szIP[0]) {	//同一group在同一C class的范围

  00380	b8 01 00 00 00	 mov	 eax, 1
  00385	6b c8 00	 imul	 ecx, eax, 0
  00388	0f be 54 0d c4	 movsx	 edx, BYTE PTR _szIP$[ebp+ecx]
  0038d	85 d2		 test	 edx, edx
  0038f	74 50		 je	 SHORT $LN24@ipAddressA

; 351  : 									strcpy(gmsv[indexgm].ipaddr, szIP);

  00391	8d 45 c4	 lea	 eax, DWORD PTR _szIP$[ebp]
  00394	50		 push	 eax
  00395	8b 4d 88	 mov	 ecx, DWORD PTR _indexgm$[ebp]
  00398	c1 e1 08	 shl	 ecx, 8
  0039b	81 c1 01 00 00
	00		 add	 ecx, OFFSET ?gmsv@@3PAUgameserver@@A+1
  003a1	51		 push	 ecx
  003a2	e8 00 00 00 00	 call	 _strcpy
  003a7	83 c4 08	 add	 esp, 8

; 352  : 									strcat_s(gmsv[indexgm].ipaddr, ".");

  003aa	68 00 00 00 00	 push	 OFFSET ??_C@_01LFCBOECM@?4?$AA@
  003af	8b 45 88	 mov	 eax, DWORD PTR _indexgm$[ebp]
  003b2	c1 e0 08	 shl	 eax, 8
  003b5	05 01 00 00 00	 add	 eax, OFFSET ?gmsv@@3PAUgameserver@@A+1
  003ba	50		 push	 eax
  003bb	e8 00 00 00 00	 call	 ??$strcat_s@$0HP@@@YAHAAY0HP@DPBD@Z ; strcat_s<127>
  003c0	83 c4 08	 add	 esp, 8

; 353  : 									strcat_s(gmsv[indexgm].ipaddr, lpstrTemp);

  003c3	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _lpstrTemp$[ebp]
  003c9	50		 push	 eax
  003ca	8b 4d 88	 mov	 ecx, DWORD PTR _indexgm$[ebp]
  003cd	c1 e1 08	 shl	 ecx, 8
  003d0	81 c1 01 00 00
	00		 add	 ecx, OFFSET ?gmsv@@3PAUgameserver@@A+1
  003d6	51		 push	 ecx
  003d7	e8 00 00 00 00	 call	 ??$strcat_s@$0HP@@@YAHAAY0HP@DPBD@Z ; strcat_s<127>
  003dc	83 c4 08	 add	 esp, 8

; 354  : 								}
; 355  : 								else			//Copy 完整的IP address

  003df	eb 1c		 jmp	 SHORT $LN25@ipAddressA
$LN24@ipAddressA:

; 356  : 									strcpy(gmsv[indexgm].ipaddr, lpstrTemp);

  003e1	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _lpstrTemp$[ebp]
  003e7	50		 push	 eax
  003e8	8b 4d 88	 mov	 ecx, DWORD PTR _indexgm$[ebp]
  003eb	c1 e1 08	 shl	 ecx, 8
  003ee	81 c1 01 00 00
	00		 add	 ecx, OFFSET ?gmsv@@3PAUgameserver@@A+1
  003f4	51		 push	 ecx
  003f5	e8 00 00 00 00	 call	 _strcpy
  003fa	83 c4 08	 add	 esp, 8
$LN25@ipAddressA:

; 357  : 								char *sss;
; 358  : 								if (lpstrTemp = strtok_s(NULL, ":", &sss)) {

  003fd	8b f4		 mov	 esi, esp
  003ff	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _sss$2[ebp]
  00405	50		 push	 eax
  00406	68 00 00 00 00	 push	 OFFSET ??_C@_01JLIPDDHJ@?3?$AA@
  0040b	6a 00		 push	 0
  0040d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtok_s
  00413	83 c4 0c	 add	 esp, 12			; 0000000cH
  00416	3b f4		 cmp	 esi, esp
  00418	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0041d	89 85 7c ff ff
	ff		 mov	 DWORD PTR _lpstrTemp$[ebp], eax
  00423	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR _lpstrTemp$[ebp], 0
  0042a	74 29		 je	 SHORT $LN22@ipAddressA

; 359  : 									strcpy(gmsv[indexgm].port, lpstrTemp);

  0042c	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _lpstrTemp$[ebp]
  00432	50		 push	 eax
  00433	8b 4d 88	 mov	 ecx, DWORD PTR _indexgm$[ebp]
  00436	c1 e1 08	 shl	 ecx, 8
  00439	81 c1 80 00 00
	00		 add	 ecx, OFFSET ?gmsv@@3PAUgameserver@@A+128
  0043f	51		 push	 ecx
  00440	e8 00 00 00 00	 call	 _strcpy
  00445	83 c4 08	 add	 esp, 8

; 360  : 									gmsv[indexgm].used = '1';

  00448	8b 45 88	 mov	 eax, DWORD PTR _indexgm$[ebp]
  0044b	c1 e0 08	 shl	 eax, 8
  0044e	c6 80 00 00 00
	00 31		 mov	 BYTE PTR ?gmsv@@3PAUgameserver@@A[eax], 49 ; 00000031H
$LN22@ipAddressA:

; 361  : 								}
; 362  : 							}
; 363  : 						}
; 364  : 						param = ReleaseMessHeadParam();

  00455	e8 00 00 00 00	 call	 ?ReleaseMessHeadParam@@YAPAUParameter@@XZ ; ReleaseMessHeadParam
  0045a	89 85 64 ff ff
	ff		 mov	 DWORD PTR _param$[ebp], eax
$LN21@ipAddressA:

; 365  : 					}
; 366  : #ifdef _SHOW_COUNT						// WON ADD 秀服务器流量
; 367  : 					if (param && param->lpstrParam) {
; 368  : 						strcpy(gmsv[indexgm].count, param->lpstrParam);
; 369  : 						param = ReleaseMessHeadParam();
; 370  : 					}
; 371  : #endif
; 372  : 				}

  00460	e9 38 fe ff ff	 jmp	 $LN5@ipAddressA
$LN6@ipAddressA:

; 373  : 				if (dwLevel) {

  00465	83 7d b8 00	 cmp	 DWORD PTR _dwLevel$[ebp], 0
  00469	74 1e		 je	 SHORT $LN18@ipAddressA

; 374  : 					gmgroup[nGroup].used = (char)dwLevel;

  0046b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nGroup@@3HA ; nGroup
  00470	c1 e0 06	 shl	 eax, 6
  00473	8a 4d b8	 mov	 cl, BYTE PTR _dwLevel$[ebp]
  00476	88 88 00 00 00
	00		 mov	 BYTE PTR ?gmgroup@@3PAUgamegroup@@A[eax], cl

; 375  : 					nGroup++;

  0047c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nGroup@@3HA ; nGroup
  00481	83 c0 01	 add	 eax, 1
  00484	a3 00 00 00 00	 mov	 DWORD PTR ?nGroup@@3HA, eax ; nGroup
$LN18@ipAddressA:

; 376  : 				}
; 377  : 			}
; 378  : 		}

  00489	e9 a1 fc ff ff	 jmp	 $LN2@ipAddressA
$LN3@ipAddressA:

; 379  : 		if (param && param->lpstrParam) {

  0048e	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR _param$[ebp], 0
  00495	74 2e		 je	 SHORT $LN28@ipAddressA
  00497	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _param$[ebp]
  0049d	83 38 00	 cmp	 DWORD PTR [eax], 0
  004a0	74 23		 je	 SHORT $LN28@ipAddressA

; 380  : 			strcpy(szAnnouncement, param->lpstrParam);

  004a2	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _param$[ebp]
  004a8	8b 08		 mov	 ecx, DWORD PTR [eax]
  004aa	51		 push	 ecx
  004ab	68 00 00 00 00	 push	 OFFSET ?szAnnouncement@@3PADA ; szAnnouncement
  004b0	e8 00 00 00 00	 call	 _strcpy
  004b5	83 c4 08	 add	 esp, 8

; 381  : 			param = ReleaseMessHeadParam();

  004b8	e8 00 00 00 00	 call	 ?ReleaseMessHeadParam@@YAPAUParameter@@XZ ; ReleaseMessHeadParam
  004bd	89 85 64 ff ff
	ff		 mov	 DWORD PTR _param$[ebp], eax

; 382  : 		}
; 383  : 		else

  004c3	eb 2e		 jmp	 SHORT $LN30@ipAddressA
$LN28@ipAddressA:

; 384  : 			szAnnouncement[0] = '\0';

  004c5	b8 01 00 00 00	 mov	 eax, 1
  004ca	6b c8 00	 imul	 ecx, eax, 0
  004cd	89 8d 5c fe ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  004d3	81 bd 5c fe ff
	ff 00 04 00 00	 cmp	 DWORD PTR $T1[ebp], 1024 ; 00000400H
  004dd	73 02		 jae	 SHORT $LN31@ipAddressA
  004df	eb 05		 jmp	 SHORT $LN32@ipAddressA
$LN31@ipAddressA:
  004e1	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN32@ipAddressA:
  004e6	8b 95 5c fe ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  004ec	c6 82 00 00 00
	00 00		 mov	 BYTE PTR ?szAnnouncement@@3PADA[edx], 0
$LN30@ipAddressA:

; 385  : 	}
; 386  : }

  004f3	52		 push	 edx
  004f4	8b cd		 mov	 ecx, ebp
  004f6	50		 push	 eax
  004f7	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN38@ipAddressA
  004fd	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00502	58		 pop	 eax
  00503	5a		 pop	 edx
  00504	5f		 pop	 edi
  00505	5e		 pop	 esi
  00506	5b		 pop	 ebx
  00507	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0050a	33 cd		 xor	 ecx, ebp
  0050c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00511	81 c4 a8 01 00
	00		 add	 esp, 424		; 000001a8H
  00517	3b ec		 cmp	 ebp, esp
  00519	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0051e	8b e5		 mov	 esp, ebp
  00520	5d		 pop	 ebp
  00521	c3		 ret	 0
  00522	66 90		 npad	 2
$LN38@ipAddressA:
  00524	04 00 00 00	 DD	 4
  00528	00 00 00 00	 DD	 $LN37@ipAddressA
$LN37@ipAddressA:
  0052c	c4 ff ff ff	 DD	 -60			; ffffffc4H
  00530	32 00 00 00	 DD	 50			; 00000032H
  00534	00 00 00 00	 DD	 $LN33@ipAddressA
  00538	58 ff ff ff	 DD	 -168			; ffffff58H
  0053c	04 00 00 00	 DD	 4
  00540	00 00 00 00	 DD	 $LN34@ipAddressA
  00544	34 ff ff ff	 DD	 -204			; ffffff34H
  00548	04 00 00 00	 DD	 4
  0054c	00 00 00 00	 DD	 $LN35@ipAddressA
  00550	28 ff ff ff	 DD	 -216			; ffffff28H
  00554	04 00 00 00	 DD	 4
  00558	00 00 00 00	 DD	 $LN36@ipAddressA
$LN36@ipAddressA:
  0055c	73		 DB	 115			; 00000073H
  0055d	73		 DB	 115			; 00000073H
  0055e	73		 DB	 115			; 00000073H
  0055f	00		 DB	 0
$LN35@ipAddressA:
  00560	73		 DB	 115			; 00000073H
  00561	73		 DB	 115			; 00000073H
  00562	73		 DB	 115			; 00000073H
  00563	00		 DB	 0
$LN34@ipAddressA:
  00564	68		 DB	 104			; 00000068H
  00565	6b		 DB	 107			; 0000006bH
  00566	65		 DB	 101			; 00000065H
  00567	79		 DB	 121			; 00000079H
  00568	00		 DB	 0
$LN33@ipAddressA:
  00569	73		 DB	 115			; 00000073H
  0056a	7a		 DB	 122			; 0000007aH
  0056b	49		 DB	 73			; 00000049H
  0056c	50		 DB	 80			; 00000050H
  0056d	00		 DB	 0
?ipAddressAnalyze@@YAXXZ ENDP				; ipAddressAnalyze
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\wgs\common.cpp
;	COMDAT ?PKey_Init@@YAXXZ
_TEXT	SEGMENT
tv75 = -276						; size = 4
$T1 = -268						; size = 4
$T2 = -256						; size = 4
_i$ = -52						; size = 4
_szTemp1$ = -40						; size = 3
_szTemp$ = -28						; size = 17
__$ArrayPad$ = -4					; size = 4
?PKey_Init@@YAXXZ PROC					; PKey_Init, COMDAT

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd ec fe ff
	ff		 lea	 edi, DWORD PTR [ebp-276]
  00012	b9 45 00 00 00	 mov	 ecx, 69			; 00000045H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 141  : 	TCHAR szTemp[17],szTemp1[3];
; 142  : 	srand((unsigned)time(NULL));

  00028	6a 00		 push	 0
  0002a	e8 00 00 00 00	 call	 _time
  0002f	83 c4 04	 add	 esp, 4
  00032	8b f4		 mov	 esi, esp
  00034	50		 push	 eax
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__srand
  0003b	83 c4 04	 add	 esp, 4
  0003e	3b f4		 cmp	 esi, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 143  : 	int i;
; 144  : 	for(i=0;i<7;i++)

  00045	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0004c	eb 09		 jmp	 SHORT $LN4@PKey_Init
$LN2@PKey_Init:
  0004e	8b 45 cc	 mov	 eax, DWORD PTR _i$[ebp]
  00051	83 c0 01	 add	 eax, 1
  00054	89 45 cc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@PKey_Init:
  00057	83 7d cc 07	 cmp	 DWORD PTR _i$[ebp], 7
  0005b	7d 41		 jge	 SHORT $LN3@PKey_Init

; 145  : 		szTemp[i]=P_Key[i]=rand()%256;

  0005d	8b f4		 mov	 esi, esp
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  00065	3b f4		 cmp	 esi, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006c	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  00071	79 07		 jns	 SHORT $LN20@PKey_Init
  00073	48		 dec	 eax
  00074	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  00079	40		 inc	 eax
$LN20@PKey_Init:
  0007a	89 85 ec fe ff
	ff		 mov	 DWORD PTR tv75[ebp], eax
  00080	8b 45 cc	 mov	 eax, DWORD PTR _i$[ebp]
  00083	8a 8d ec fe ff
	ff		 mov	 cl, BYTE PTR tv75[ebp]
  00089	88 88 00 00 00
	00		 mov	 BYTE PTR ?P_Key@@3PADA[eax], cl
  0008f	8b 55 cc	 mov	 edx, DWORD PTR _i$[ebp]
  00092	8a 85 ec fe ff
	ff		 mov	 al, BYTE PTR tv75[ebp]
  00098	88 44 15 e4	 mov	 BYTE PTR _szTemp$[ebp+edx], al
  0009c	eb b0		 jmp	 SHORT $LN2@PKey_Init
$LN3@PKey_Init:

; 146  : 	P_Key[7]='\0';

  0009e	b8 01 00 00 00	 mov	 eax, 1
  000a3	6b c8 07	 imul	 ecx, eax, 7
  000a6	89 8d 00 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  000ac	83 bd 00 ff ff
	ff 08		 cmp	 DWORD PTR $T2[ebp], 8
  000b3	73 02		 jae	 SHORT $LN12@PKey_Init
  000b5	eb 05		 jmp	 SHORT $LN13@PKey_Init
$LN12@PKey_Init:
  000b7	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN13@PKey_Init:
  000bc	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR $T2[ebp]
  000c2	c6 82 00 00 00
	00 00		 mov	 BYTE PTR ?P_Key@@3PADA[edx], 0

; 147  : 	for(i=7;i<16;i++)

  000c9	c7 45 cc 07 00
	00 00		 mov	 DWORD PTR _i$[ebp], 7
  000d0	eb 09		 jmp	 SHORT $LN7@PKey_Init
$LN5@PKey_Init:
  000d2	8b 45 cc	 mov	 eax, DWORD PTR _i$[ebp]
  000d5	83 c0 01	 add	 eax, 1
  000d8	89 45 cc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@PKey_Init:
  000db	83 7d cc 10	 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  000df	7d 26		 jge	 SHORT $LN6@PKey_Init

; 148  : 		szTemp[i]=rand()%256;

  000e1	8b f4		 mov	 esi, esp
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  000e9	3b f4		 cmp	 esi, esp
  000eb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f0	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  000f5	79 07		 jns	 SHORT $LN21@PKey_Init
  000f7	48		 dec	 eax
  000f8	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  000fd	40		 inc	 eax
$LN21@PKey_Init:
  000fe	8b 4d cc	 mov	 ecx, DWORD PTR _i$[ebp]
  00101	88 44 0d e4	 mov	 BYTE PTR _szTemp$[ebp+ecx], al
  00105	eb cb		 jmp	 SHORT $LN5@PKey_Init
$LN6@PKey_Init:

; 149  : 	P_Key1[0]='\0';

  00107	b8 01 00 00 00	 mov	 eax, 1
  0010c	6b c8 00	 imul	 ecx, eax, 0
  0010f	89 8d f4 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00115	81 bd f4 fe ff
	ff 00 01 00 00	 cmp	 DWORD PTR $T1[ebp], 256	; 00000100H
  0011f	73 02		 jae	 SHORT $LN14@PKey_Init
  00121	eb 05		 jmp	 SHORT $LN15@PKey_Init
$LN14@PKey_Init:
  00123	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN15@PKey_Init:
  00128	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  0012e	c6 82 00 00 00
	00 00		 mov	 BYTE PTR ?P_Key1@@3PADA[edx], 0

; 150  : 	for(i=0;i<16;i++){

  00135	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0013c	eb 09		 jmp	 SHORT $LN10@PKey_Init
$LN8@PKey_Init:
  0013e	8b 45 cc	 mov	 eax, DWORD PTR _i$[ebp]
  00141	83 c0 01	 add	 eax, 1
  00144	89 45 cc	 mov	 DWORD PTR _i$[ebp], eax
$LN10@PKey_Init:
  00147	83 7d cc 10	 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  0014b	7d 43		 jge	 SHORT $LN11@PKey_Init

; 151  : 		wsprintf(szTemp1,"%02X",(unsigned char)~szTemp[i]);

  0014d	8b 45 cc	 mov	 eax, DWORD PTR _i$[ebp]
  00150	0f be 4c 05 e4	 movsx	 ecx, BYTE PTR _szTemp$[ebp+eax]
  00155	f7 d1		 not	 ecx
  00157	0f b6 d1	 movzx	 edx, cl
  0015a	8b f4		 mov	 esi, esp
  0015c	52		 push	 edx
  0015d	68 00 00 00 00	 push	 OFFSET ??_C@_04JFFKLGJF@?$CF02X?$AA@
  00162	8d 45 d8	 lea	 eax, DWORD PTR _szTemp1$[ebp]
  00165	50		 push	 eax
  00166	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0016c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0016f	3b f4		 cmp	 esi, esp
  00171	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 152  : 		lstrcat(P_Key1,szTemp1);

  00176	8b f4		 mov	 esi, esp
  00178	8d 45 d8	 lea	 eax, DWORD PTR _szTemp1$[ebp]
  0017b	50		 push	 eax
  0017c	68 00 00 00 00	 push	 OFFSET ?P_Key1@@3PADA	; P_Key1
  00181	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcatA@8
  00187	3b f4		 cmp	 esi, esp
  00189	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 153  : 	}

  0018e	eb ae		 jmp	 SHORT $LN8@PKey_Init
$LN11@PKey_Init:

; 154  : }

  00190	52		 push	 edx
  00191	8b cd		 mov	 ecx, ebp
  00193	50		 push	 eax
  00194	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@PKey_Init
  0019a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0019f	58		 pop	 eax
  001a0	5a		 pop	 edx
  001a1	5f		 pop	 edi
  001a2	5e		 pop	 esi
  001a3	5b		 pop	 ebx
  001a4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a7	33 cd		 xor	 ecx, ebp
  001a9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ae	81 c4 14 01 00
	00		 add	 esp, 276		; 00000114H
  001b4	3b ec		 cmp	 ebp, esp
  001b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001bb	8b e5		 mov	 esp, ebp
  001bd	5d		 pop	 ebp
  001be	c3		 ret	 0
  001bf	90		 npad	 1
$LN19@PKey_Init:
  001c0	02 00 00 00	 DD	 2
  001c4	00 00 00 00	 DD	 $LN18@PKey_Init
$LN18@PKey_Init:
  001c8	e4 ff ff ff	 DD	 -28			; ffffffe4H
  001cc	11 00 00 00	 DD	 17			; 00000011H
  001d0	00 00 00 00	 DD	 $LN16@PKey_Init
  001d4	d8 ff ff ff	 DD	 -40			; ffffffd8H
  001d8	03 00 00 00	 DD	 3
  001dc	00 00 00 00	 DD	 $LN17@PKey_Init
$LN17@PKey_Init:
  001e0	73		 DB	 115			; 00000073H
  001e1	7a		 DB	 122			; 0000007aH
  001e2	54		 DB	 84			; 00000054H
  001e3	65		 DB	 101			; 00000065H
  001e4	6d		 DB	 109			; 0000006dH
  001e5	70		 DB	 112			; 00000070H
  001e6	31		 DB	 49			; 00000031H
  001e7	00		 DB	 0
$LN16@PKey_Init:
  001e8	73		 DB	 115			; 00000073H
  001e9	7a		 DB	 122			; 0000007aH
  001ea	54		 DB	 84			; 00000054H
  001eb	65		 DB	 101			; 00000065H
  001ec	6d		 DB	 109			; 0000006dH
  001ed	70		 DB	 112			; 00000070H
  001ee	00		 DB	 0
?PKey_Init@@YAXXZ ENDP					; PKey_Init
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\wgs\common.cpp
;	COMDAT ?GetEncrypt@@YAXPAUParameter@@@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_iLen$2 = -8						; size = 4
_param$ = 8						; size = 4
?GetEncrypt@@YAXPAUParameter@@@Z PROC			; GetEncrypt, COMDAT

; 129  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 130  : 	if(param && param->lpstrParam){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _param$[ebp], 0
  00022	74 7e		 je	 SHORT $LN3@GetEncrypt
  00024	8b 45 08	 mov	 eax, DWORD PTR _param$[ebp]
  00027	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002a	74 76		 je	 SHORT $LN3@GetEncrypt

; 131  : 		int iLen=strlen(param->lpstrParam);

  0002c	8b 45 08	 mov	 eax, DWORD PTR _param$[ebp]
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _strlen
  00037	83 c4 04	 add	 esp, 4
  0003a	89 45 f8	 mov	 DWORD PTR _iLen$2[ebp], eax

; 132  : 		iLen>>=1;

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _iLen$2[ebp]
  00040	d1 f8		 sar	 eax, 1
  00042	89 45 f8	 mov	 DWORD PTR _iLen$2[ebp], eax

; 133  : 		strncpy(szPlain,param->lpstrParam,iLen);

  00045	8b f4		 mov	 esi, esp
  00047	8b 45 f8	 mov	 eax, DWORD PTR _iLen$2[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _param$[ebp]
  0004e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00050	52		 push	 edx
  00051	68 00 00 00 00	 push	 OFFSET ?szPlain@@3PADA	; szPlain
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncpy
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005f	3b f4		 cmp	 esi, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 134  : 		szPlain[iLen]='\0';

  00066	8b 45 f8	 mov	 eax, DWORD PTR _iLen$2[ebp]
  00069	89 85 2c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  0006f	83 bd 2c ff ff
	ff 50		 cmp	 DWORD PTR $T1[ebp], 80	; 00000050H
  00076	73 02		 jae	 SHORT $LN4@GetEncrypt
  00078	eb 05		 jmp	 SHORT $LN5@GetEncrypt
$LN4@GetEncrypt:
  0007a	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN5@GetEncrypt:
  0007f	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  00085	c6 81 00 00 00
	00 00		 mov	 BYTE PTR ?szPlain@@3PADA[ecx], 0

; 135  : 		strcpy(szCipher,param->lpstrParam+iLen);

  0008c	8b 45 08	 mov	 eax, DWORD PTR _param$[ebp]
  0008f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00091	03 4d f8	 add	 ecx, DWORD PTR _iLen$2[ebp]
  00094	51		 push	 ecx
  00095	68 00 00 00 00	 push	 OFFSET ?szCipher@@3PADA	; szCipher
  0009a	e8 00 00 00 00	 call	 _strcpy
  0009f	83 c4 08	 add	 esp, 8
$LN3@GetEncrypt:

; 136  : 	}
; 137  : }

  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	5b		 pop	 ebx
  000a5	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000ab	3b ec		 cmp	 ebp, esp
  000ad	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
?GetEncrypt@@YAXPAUParameter@@@Z ENDP			; GetEncrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\wgs\common.cpp
;	COMDAT ?GetIP_PORT@@YAHPAUParameter@@@Z
_TEXT	SEGMENT
_param$ = 8						; size = 4
?GetIP_PORT@@YAHPAUParameter@@@Z PROC			; GetIP_PORT, COMDAT

; 114  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 115  : 	if((param)&&(param->lpstrParam)){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _param$[ebp], 0
  00022	0f 84 91 00 00
	00		 je	 $LN2@GetIP_PORT
  00028	8b 45 08	 mov	 eax, DWORD PTR _param$[ebp]
  0002b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002e	0f 84 85 00 00
	00		 je	 $LN2@GetIP_PORT

; 116  : 		lstrcpy(szCSIP,param->lpstrParam);

  00034	8b f4		 mov	 esi, esp
  00036	8b 45 08	 mov	 eax, DWORD PTR _param$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	51		 push	 ecx
  0003c	68 00 00 00 00	 push	 OFFSET ?szCSIP@@3PADA	; szCSIP
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8
  00047	3b f4		 cmp	 esi, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 117  : 		if((param=ReleaseMessHeadParam())&&(param->lpstrParam)){

  0004e	e8 00 00 00 00	 call	 ?ReleaseMessHeadParam@@YAPAUParameter@@XZ ; ReleaseMessHeadParam
  00053	89 45 08	 mov	 DWORD PTR _param$[ebp], eax
  00056	83 7d 08 00	 cmp	 DWORD PTR _param$[ebp], 0
  0005a	74 5d		 je	 SHORT $LN2@GetIP_PORT
  0005c	8b 45 08	 mov	 eax, DWORD PTR _param$[ebp]
  0005f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00062	74 55		 je	 SHORT $LN2@GetIP_PORT

; 118  : 			wCS=(WORD)atoi(param->lpstrParam);

  00064	8b f4		 mov	 esi, esp
  00066	8b 45 08	 mov	 eax, DWORD PTR _param$[ebp]
  00069	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006b	51		 push	 ecx
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00072	83 c4 04	 add	 esp, 4
  00075	3b f4		 cmp	 esi, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	66 a3 00 00 00
	00		 mov	 WORD PTR ?wCS@@3GA, ax	; wCS

; 119  : 			if((param=ReleaseMessHeadParam())&&(param->lpstrParam)){

  00082	e8 00 00 00 00	 call	 ?ReleaseMessHeadParam@@YAPAUParameter@@XZ ; ReleaseMessHeadParam
  00087	89 45 08	 mov	 DWORD PTR _param$[ebp], eax
  0008a	83 7d 08 00	 cmp	 DWORD PTR _param$[ebp], 0
  0008e	74 29		 je	 SHORT $LN2@GetIP_PORT
  00090	8b 45 08	 mov	 eax, DWORD PTR _param$[ebp]
  00093	83 38 00	 cmp	 DWORD PTR [eax], 0
  00096	74 21		 je	 SHORT $LN2@GetIP_PORT

; 120  : 				lstrcpy(szPid,param->lpstrParam);

  00098	8b f4		 mov	 esi, esp
  0009a	8b 45 08	 mov	 eax, DWORD PTR _param$[ebp]
  0009d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009f	51		 push	 ecx
  000a0	68 00 00 00 00	 push	 OFFSET ?szPid@@3PADA	; szPid
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8
  000ab	3b f4		 cmp	 esi, esp
  000ad	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 121  : 				return TRUE;

  000b2	b8 01 00 00 00	 mov	 eax, 1
  000b7	eb 02		 jmp	 SHORT $LN1@GetIP_PORT
$LN2@GetIP_PORT:

; 122  : 			}
; 123  : 		}
; 124  : 	}
; 125  : 	return FALSE;

  000b9	33 c0		 xor	 eax, eax
$LN1@GetIP_PORT:

; 126  : }

  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx
  000be	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000c4	3b ec		 cmp	 ebp, esp
  000c6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
?GetIP_PORT@@YAHPAUParameter@@@Z ENDP			; GetIP_PORT
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
;	COMDAT _time
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC						; COMDAT

; 534  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 535  :             return _time64(_Time);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  00023	50		 push	 eax
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
  0002a	83 c4 04	 add	 esp, 4
  0002d	3b f4		 cmp	 esi, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 536  :         }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
END
