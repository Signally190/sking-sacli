; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Administrator\Desktop\????? ??\????? ??\Client Source Code\system\netproc.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?newCharStatus@@3FA				; newCharStatus
PUBLIC	?charLoginStatus@@3FA				; charLoginStatus
PUBLIC	?charLogoutStatus@@3FA				; charLogoutStatus
PUBLIC	?ERROR_MESSAGE@@3HA				; ERROR_MESSAGE
PUBLIC	?netproc_sending@@3HA				; netproc_sending
PUBLIC	?start_time@@3KA				; start_time
PUBLIC	?c_temp@@3PADA					; c_temp
PUBLIC	?connectServerCounter@@3HA			; connectServerCounter
PUBLIC	?AdvanceSkill@@3PAHA				; AdvanceSkill
PUBLIC	?AssitSkill@@3PAHA				; AssitSkill
PUBLIC	?BattleSkill@@3PAHA				; BattleSkill
PUBLIC	?登录错误提示@@3PADA				; 登录错误提示
PUBLIC	?sin_server@@3Usockaddr_in@@A			; sin_server
PUBLIC	?pCommand@@3PADA				; pCommand
PUBLIC	?dwDiceTimer@@3KA				; dwDiceTimer
PUBLIC	?gStr光环@@3PADA				; gStr光环
PUBLIC	?hPing@@3PAXA					; hPing
PUBLIC	?dwPingID@@3KA					; dwPingID
PUBLIC	?dwPingTime@@3KA				; dwPingTime
PUBLIC	?dwPingState@@3KA				; dwPingState
PUBLIC	?bNewServer@@3HA				; bNewServer
PUBLIC	?iWrote@@3HA					; iWrote
PUBLIC	?iRead@@3HA					; iRead
PUBLIC	?sockRaw@@3IA					; sockRaw
PUBLIC	?selectServerIndex@@3FA				; selectServerIndex
PUBLIC	?clientLoginStatus@@3FA				; clientLoginStatus
PUBLIC	?charListStatus@@3FA				; charListStatus
PUBLIC	?charDelStatus@@3FA				; charDelStatus
PUBLIC	?gamestate_chooseserver_name@@3PADA		; gamestate_chooseserver_name
PUBLIC	?gamestate_login_charname@@3PADA		; gamestate_login_charname
PUBLIC	?gamestate_deletechar_charname@@3PADA		; gamestate_deletechar_charname
PUBLIC	?netprocErrmsg@@3PADA				; netprocErrmsg
_BSS	SEGMENT
?newCharStatus@@3FA DW 01H DUP (?)			; newCharStatus
	ALIGN	4

?charLoginStatus@@3FA DW 01H DUP (?)			; charLoginStatus
	ALIGN	4

?charLogoutStatus@@3FA DW 01H DUP (?)			; charLogoutStatus
	ALIGN	4

?ERROR_MESSAGE@@3HA DD 01H DUP (?)			; ERROR_MESSAGE
?netproc_sending@@3HA DD 01H DUP (?)			; netproc_sending
?start_time@@3KA DD 01H DUP (?)				; start_time
?c_temp@@3PADA DB 0400H DUP (?)				; c_temp
?connectServerCounter@@3HA DD 01H DUP (?)		; connectServerCounter
?登录错误提示@@3PADA DB 0200H DUP (?)			; 登录错误提示
?sin_server@@3Usockaddr_in@@A DB 010H DUP (?)		; sin_server
?count@?1??connectServer@@YAHXZ@4HA DD 01H DUP (?)	; `connectServer'::`2'::count
?pCommand@@3PADA DD 01H DUP (?)				; pCommand
?dwDiceTimer@@3KA DD 01H DUP (?)			; dwDiceTimer
?gStr光环@@3PADA DB 064H DUP (?)			; gStr光环
?hPing@@3PAXA DD 01H DUP (?)				; hPing
?dwPingID@@3KA DD 01H DUP (?)				; dwPingID
?dwPingTime@@3KA DD 01H DUP (?)				; dwPingTime
?dwPingState@@3KA DD 01H DUP (?)			; dwPingState
?bNewServer@@3HA DD 01H DUP (?)				; bNewServer
?iWrote@@3HA DD	01H DUP (?)				; iWrote
?iRead@@3HA DD	01H DUP (?)				; iRead
?clientLoginStatus@@3FA DW 01H DUP (?)			; clientLoginStatus
	ALIGN	4

?charListStatus@@3FA DW 01H DUP (?)			; charListStatus
	ALIGN	4

?charDelStatus@@3FA DW 01H DUP (?)			; charDelStatus
	ALIGN	4

?gamestate_chooseserver_name@@3PADA DB 080H DUP (?)	; gamestate_chooseserver_name
?gamestate_login_charname@@3PADA DB 080H DUP (?)	; gamestate_login_charname
?gamestate_deletechar_charname@@3PADA DB 080H DUP (?)	; gamestate_deletechar_charname
?netprocErrmsg@@3PADA DB 0400H DUP (?)			; netprocErrmsg
_BSS	ENDS
_DATA	SEGMENT
?AdvanceSkill@@3PAHA DD 0ffffffffH			; AdvanceSkill
	ORG $+76
?AssitSkill@@3PAHA DD 0ffffffffH			; AssitSkill
	ORG $+76
?BattleSkill@@3PAHA DD 0ffffffffH			; BattleSkill
	ORG $+76
?ridePetTable@@3PAUtagRidePetTable@@A DD 018a88H	; ridePetTable
	DD	0186a0H
	DD	018800H
	DD	00H
	DD	018a89H
	DD	0186a5H
	DD	018800H
	DD	00H
	DD	018a8aH
	DD	0186aaH
	DD	018800H
	DD	00H
	DD	018a8bH
	DD	0186afH
	DD	018800H
	DD	00H
	DD	018a8cH
	DD	0186a0H
	DD	0187e9H
	DD	00H
	DD	018a8dH
	DD	0186a5H
	DD	0187e7H
	DD	00H
	DD	018a8eH
	DD	0186aaH
	DD	0187eaH
	DD	00H
	DD	018a8fH
	DD	0186afH
	DD	0187e8H
	DD	00H
	DD	018a90H
	DD	01895cH
	DD	018814H
	DD	00H
	DD	018a91H
	DD	018961H
	DD	018815H
	DD	00H
	DD	018e65H
	DD	018961H
	DD	018cc8H
	DD	00H
	DD	018e5aH
	DD	018961H
	DD	018c9cH
	DD	00H
	DD	018a92H
	DD	0186b4H
	DD	01882cH
	DD	00H
	DD	018a93H
	DD	0186b9H
	DD	01882cH
	DD	00H
	DD	018a94H
	DD	0186beH
	DD	01882cH
	DD	00H
	DD	018a95H
	DD	0186c3H
	DD	01882cH
	DD	00H
	DD	018a96H
	DD	0186b4H
	DD	0187e8H
	DD	00H
	DD	018a97H
	DD	0186b9H
	DD	0187e9H
	DD	00H
	DD	018a98H
	DD	0186beH
	DD	0187e7H
	DD	00H
	DD	018a99H
	DD	0186c3H
	DD	0187eaH
	DD	00H
	DD	018a9aH
	DD	018966H
	DD	018814H
	DD	00H
	DD	018a9bH
	DD	01896bH
	DD	018815H
	DD	00H
	DD	018e64H
	DD	01896bH
	DD	018cc8H
	DD	00H
	DD	018e62H
	DD	01896bH
	DD	018c9cH
	DD	00H
	DD	018a9cH
	DD	0186c8H
	DD	0187ffH
	DD	00H
	DD	018a9dH
	DD	0186cdH
	DD	0187ffH
	DD	00H
	DD	018a9eH
	DD	0186d2H
	DD	0187ffH
	DD	00H
	DD	018a9fH
	DD	0186d7H
	DD	0187ffH
	DD	00H
	DD	018aa0H
	DD	0186c8H
	DD	0187e8H
	DD	00H
	DD	018aa1H
	DD	0186cdH
	DD	0187eaH
	DD	00H
	DD	018aa2H
	DD	0186d2H
	DD	0187e7H
	DD	00H
	DD	018aa3H
	DD	0186d7H
	DD	0187e9H
	DD	00H
	DD	018aa4H
	DD	018970H
	DD	018814H
	DD	00H
	DD	018aa5H
	DD	018975H
	DD	018815H
	DD	00H
	DD	018e4dH
	DD	018975H
	DD	018cc8H
	DD	00H
	DD	018e57H
	DD	018975H
	DD	018c9cH
	DD	00H
	DD	018aa6H
	DD	0186dcH
	DD	018801H
	DD	00H
	DD	018aa7H
	DD	0186e1H
	DD	018801H
	DD	00H
	DD	018aa8H
	DD	0186e6H
	DD	018801H
	DD	00H
	DD	018aa9H
	DD	0186ebH
	DD	018801H
	DD	00H
	DD	018aaaH
	DD	0186dcH
	DD	0187e9H
	DD	00H
	DD	018aabH
	DD	0186e1H
	DD	0187e7H
	DD	00H
	DD	018aacH
	DD	0186e6H
	DD	0187eaH
	DD	00H
	DD	018aadH
	DD	0186ebH
	DD	0187e8H
	DD	00H
	DD	018aaeH
	DD	01897aH
	DD	018814H
	DD	00H
	DD	018aafH
	DD	01897fH
	DD	018815H
	DD	00H
	DD	018e4eH
	DD	01897fH
	DD	018cc8H
	DD	00H
	DD	018e58H
	DD	01897fH
	DD	018c9cH
	DD	00H
	DD	018ab0H
	DD	0186f0H
	DD	01882cH
	DD	00H
	DD	018ab1H
	DD	0186f5H
	DD	01882cH
	DD	00H
	DD	018ab2H
	DD	0186faH
	DD	01882cH
	DD	00H
	DD	018ab3H
	DD	0186ffH
	DD	01882cH
	DD	00H
	DD	018ab4H
	DD	0186f0H
	DD	0187e8H
	DD	00H
	DD	018ab5H
	DD	0186f5H
	DD	0187e7H
	DD	00H
	DD	018ab6H
	DD	0186faH
	DD	0187eaH
	DD	00H
	DD	018ab7H
	DD	0186ffH
	DD	0187e9H
	DD	00H
	DD	018ab8H
	DD	018984H
	DD	018814H
	DD	00H
	DD	018ab9H
	DD	018989H
	DD	018815H
	DD	00H
	DD	018e55H
	DD	018989H
	DD	018cc8H
	DD	00H
	DD	018e60H
	DD	018989H
	DD	018c9cH
	DD	00H
	DD	018abaH
	DD	018704H
	DD	018801H
	DD	00H
	DD	018abbH
	DD	018709H
	DD	018801H
	DD	00H
	DD	018abcH
	DD	01870eH
	DD	018801H
	DD	00H
	DD	018abdH
	DD	018713H
	DD	018801H
	DD	00H
	DD	018abeH
	DD	018704H
	DD	0187e9H
	DD	00H
	DD	018abfH
	DD	018709H
	DD	0187e8H
	DD	00H
	DD	018ac0H
	DD	01870eH
	DD	0187eaH
	DD	00H
	DD	018ac1H
	DD	018713H
	DD	0187e7H
	DD	00H
	DD	018ac2H
	DD	01898eH
	DD	018814H
	DD	00H
	DD	018ac3H
	DD	018993H
	DD	018815H
	DD	00H
	DD	018e56H
	DD	018993H
	DD	018cc8H
	DD	00H
	DD	018e61H
	DD	018993H
	DD	018c9cH
	DD	00H
	DD	018ac4H
	DD	018718H
	DD	018802H
	DD	00H
	DD	018ac5H
	DD	01871dH
	DD	018802H
	DD	00H
	DD	018ac6H
	DD	018722H
	DD	018802H
	DD	00H
	DD	018ac7H
	DD	018727H
	DD	018802H
	DD	00H
	DD	018ac8H
	DD	018718H
	DD	0187e7H
	DD	00H
	DD	018ac9H
	DD	01871dH
	DD	0187eaH
	DD	00H
	DD	018acaH
	DD	018722H
	DD	0187e8H
	DD	00H
	DD	018acbH
	DD	018727H
	DD	0187e9H
	DD	00H
	DD	018accH
	DD	018998H
	DD	018814H
	DD	00H
	DD	018acdH
	DD	01899dH
	DD	018815H
	DD	00H
	DD	018e4fH
	DD	01899dH
	DD	018cc8H
	DD	00H
	DD	018e59H
	DD	01899dH
	DD	018c9cH
	DD	00H
	DD	018aceH
	DD	01872cH
	DD	018802H
	DD	00H
	DD	018acfH
	DD	018731H
	DD	018802H
	DD	00H
	DD	018ad0H
	DD	018736H
	DD	018802H
	DD	00H
	DD	018ad1H
	DD	01873bH
	DD	018802H
	DD	00H
	DD	018ad2H
	DD	01872cH
	DD	0187e7H
	DD	00H
	DD	018ad3H
	DD	018731H
	DD	0187e9H
	DD	00H
	DD	018ad4H
	DD	018736H
	DD	0187eaH
	DD	00H
	DD	018ad5H
	DD	01873bH
	DD	0187e8H
	DD	00H
	DD	018ad6H
	DD	0189a2H
	DD	018814H
	DD	00H
	DD	018ad7H
	DD	0189a7H
	DD	018815H
	DD	00H
	DD	018e50H
	DD	0189a7H
	DD	018cc8H
	DD	00H
	DD	018e5bH
	DD	0189a7H
	DD	018c9cH
	DD	00H
	DD	018ad8H
	DD	018740H
	DD	018800H
	DD	00H
	DD	018ad9H
	DD	018745H
	DD	018800H
	DD	00H
	DD	018adaH
	DD	01874aH
	DD	018800H
	DD	00H
	DD	018adbH
	DD	01874fH
	DD	018800H
	DD	00H
	DD	018adcH
	DD	018740H
	DD	0187eaH
	DD	00H
	DD	018addH
	DD	018745H
	DD	0187e9H
	DD	00H
	DD	018adeH
	DD	01874aH
	DD	0187e7H
	DD	00H
	DD	018adfH
	DD	01874fH
	DD	0187e8H
	DD	00H
	DD	018ae0H
	DD	0189acH
	DD	018814H
	DD	00H
	DD	018ae1H
	DD	0189b1H
	DD	018815H
	DD	00H
	DD	018e52H
	DD	0189b1H
	DD	018cc8H
	DD	00H
	DD	018e5dH
	DD	0189b1H
	DD	018c9cH
	DD	00H
	DD	018ae2H
	DD	018754H
	DD	0187ffH
	DD	00H
	DD	018ae3H
	DD	018759H
	DD	0187ffH
	DD	00H
	DD	018ae4H
	DD	01875eH
	DD	0187ffH
	DD	00H
	DD	018ae5H
	DD	018763H
	DD	0187ffH
	DD	00H
	DD	018ae6H
	DD	018754H
	DD	0187e8H
	DD	00H
	DD	018ae7H
	DD	018759H
	DD	0187eaH
	DD	00H
	DD	018ae8H
	DD	01875eH
	DD	0187e9H
	DD	00H
	DD	018ae9H
	DD	018763H
	DD	0187e7H
	DD	00H
	DD	018aeaH
	DD	0189b6H
	DD	018814H
	DD	00H
	DD	018aebH
	DD	0189bbH
	DD	018815H
	DD	00H
	DD	018e51H
	DD	0189bbH
	DD	018cc8H
	DD	00H
	DD	018e5cH
	DD	0189bbH
	DD	018c9cH
	DD	00H
	DD	018aecH
	DD	018768H
	DD	018801H
	DD	00H
	DD	018aedH
	DD	01876dH
	DD	018801H
	DD	00H
	DD	018aeeH
	DD	018772H
	DD	018801H
	DD	00H
	DD	018aefH
	DD	018777H
	DD	018801H
	DD	00H
	DD	018af0H
	DD	018768H
	DD	0187e9H
	DD	00H
	DD	018af1H
	DD	01876dH
	DD	0187e8H
	DD	00H
	DD	018af2H
	DD	018772H
	DD	0187e7H
	DD	00H
	DD	018af3H
	DD	018777H
	DD	0187eaH
	DD	00H
	DD	018af4H
	DD	0189c0H
	DD	018814H
	DD	00H
	DD	018af5H
	DD	0189c5H
	DD	018815H
	DD	00H
	DD	018e54H
	DD	0189c5H
	DD	018cc8H
	DD	00H
	DD	018e5fH
	DD	0189c5H
	DD	018c9cH
	DD	00H
	DD	018af6H
	DD	01877cH
	DD	01882cH
	DD	00H
	DD	018af7H
	DD	018781H
	DD	01882cH
	DD	00H
	DD	018af8H
	DD	018786H
	DD	01882cH
	DD	00H
	DD	018af9H
	DD	01878bH
	DD	01882cH
	DD	00H
	DD	018afaH
	DD	01877cH
	DD	0187eaH
	DD	00H
	DD	018afbH
	DD	018781H
	DD	0187e7H
	DD	00H
	DD	018afcH
	DD	018786H
	DD	0187e9H
	DD	00H
	DD	018afdH
	DD	01878bH
	DD	0187e8H
	DD	00H
	DD	018afeH
	DD	0189caH
	DD	018814H
	DD	00H
	DD	018affH
	DD	0189cfH
	DD	018815H
	DD	00H
	DD	018e53H
	DD	0189cfH
	DD	018cc8H
	DD	00H
	DD	018e5eH
	DD	0189cfH
	DD	018c9cH
	DD	00H
	DD	018b3bH
	DD	018b39H
	DD	018b3aH
	DD	00H
	DD	018b3bH
	DD	018b3aH
	DD	018b39H
	DD	00H
?RideCodeMode@@3PAUtagRideCodeMode@@A DD 018816H	; RideCodeMode
	DD	01H
	DD	018806H
	DD	02H
	DD	01880aH
	DD	04H
	DD	0187b7H
	DD	08H
	DD	0187c0H
	DD	010H
	DD	0187bbH
	DD	020H
	DD	0187faH
	DD	040H
	DD	0187d6H
	DD	080H
	DD	018814H
	DD	0100H
	DD	018815H
	DD	0200H
	DD	018c9cH
	DD	0800H
	DD	018cc8H
	DD	0400H
	DD	018812H
	DD	01000H
	DD	018811H
	DD	02000H
	DD	018a28H
	DD	04000H
	DD	018a2bH
	DD	08000H
	DD	018f30H
	DD	010000H
	DD	018f31H
	DD	020000H
	DD	018f68H
	DD	040000H
	DD	0187fcH
	DD	080000H
	DD	0187d3H
	DD	0100000H
	DD	018fa9H
	DD	0200000H
	DD	018faaH
	DD	0400000H
	DD	018a09H
	DD	0800000H
	DD	018a0aH
	DD	01000000H
	DD	019394H
	DD	02000000H
	DD	0187b2H
	DD	04000000H
?RideNoList@@3PAUtagRideNoList@@A DD 018bb9H		; RideNoList
	DD	018bbaH
	DD	018bbbH
	DD	018bbcH
	DD	018bbdH
	DD	018bbeH
	DD	018bbfH
	DD	018bc0H
	DD	018a90H
	DD	018a91H
	DD	018e5aH
	DD	018e65H
	DD	018849H
	DD	018844H
	DD	01885dH
	DD	018ee5H
	DD	018f0dH
	DD	018f19H
	DD	018f76H
	ORG $+32
	DD	018bc1H
	DD	018bc2H
	DD	018bc3H
	DD	018bc4H
	DD	018bc5H
	DD	018bc6H
	DD	018bc7H
	DD	018bc8H
	DD	018a9aH
	DD	018a9bH
	DD	018e62H
	DD	018e64H
	DD	018849H
	DD	018844H
	DD	01885dH
	DD	018ee6H
	DD	018f0eH
	DD	018f1aH
	DD	018f77H
	ORG $+32
	DD	018bc9H
	DD	018bcaH
	DD	018bcbH
	DD	018bccH
	DD	018bcdH
	DD	018bceH
	DD	018bcfH
	DD	018bd0H
	DD	018aa4H
	DD	018aa5H
	DD	018e57H
	DD	018e4dH
	DD	018849H
	DD	018844H
	DD	01885dH
	DD	018ee7H
	DD	018f0fH
	DD	018f1bH
	DD	018f78H
	ORG $+32
	DD	018bd1H
	DD	018bd2H
	DD	018bd3H
	DD	018bd4H
	DD	018bd5H
	DD	018bd6H
	DD	018bd7H
	DD	018bd8H
	DD	018aaeH
	DD	018aafH
	DD	018e58H
	DD	018e4eH
	DD	018849H
	DD	018844H
	DD	01885dH
	DD	018ee8H
	DD	018f10H
	DD	018f1cH
	DD	018f79H
	ORG $+32
	DD	018bd9H
	DD	018bdaH
	DD	018bdbH
	DD	018bdcH
	DD	018bddH
	DD	018bdeH
	DD	018bdfH
	DD	018be0H
	DD	018ab8H
	DD	018ab9H
	DD	018e60H
	DD	018e55H
	DD	018849H
	DD	018844H
	DD	01885dH
	DD	018ee9H
	DD	018f11H
	DD	018f1dH
	DD	018f7aH
	ORG $+32
	DD	018be1H
	DD	018be2H
	DD	018be3H
	DD	018be4H
	DD	018be5H
	DD	018be6H
	DD	018be7H
	DD	018be8H
	DD	018ac2H
	DD	018ac3H
	DD	018e61H
	DD	018e56H
	DD	018849H
	DD	018844H
	DD	01885dH
	DD	018eeaH
	DD	018f12H
	DD	018f1eH
	DD	018f7bH
	ORG $+32
	DD	018be9H
	DD	018beaH
	DD	018bebH
	DD	018becH
	DD	018bedH
	DD	018beeH
	DD	018befH
	DD	018bf0H
	DD	018accH
	DD	018acdH
	DD	018e59H
	DD	018e4fH
	DD	018849H
	DD	018844H
	DD	01885dH
	DD	018eebH
	DD	018f13H
	DD	018f1fH
	DD	018f7cH
	ORG $+32
	DD	018bf1H
	DD	018bf2H
	DD	018bf3H
	DD	018bf4H
	DD	018bf5H
	DD	018bf6H
	DD	018bf7H
	DD	018bf8H
	DD	018ad6H
	DD	018ad7H
	DD	018e5bH
	DD	018e50H
	DD	018849H
	DD	018844H
	DD	01885dH
	DD	018eecH
	DD	018f14H
	DD	018f20H
	DD	018f7dH
	ORG $+32
	DD	018bf9H
	DD	018bfaH
	DD	018bfbH
	DD	018bfcH
	DD	018bfdH
	DD	018bfeH
	DD	018bffH
	DD	018c00H
	DD	018ae0H
	DD	018ae1H
	DD	018e5dH
	DD	018e52H
	DD	018849H
	DD	018844H
	DD	01885dH
	DD	018eedH
	DD	018f15H
	DD	018f21H
	DD	018f7eH
	ORG $+32
	DD	018c01H
	DD	018c02H
	DD	018c03H
	DD	018c04H
	DD	018c05H
	DD	018c06H
	DD	018c07H
	DD	018c08H
	DD	018aeaH
	DD	018aebH
	DD	018e5cH
	DD	018e51H
	DD	018849H
	DD	018844H
	DD	01885dH
	DD	018eeeH
	DD	018f16H
	DD	018f22H
	DD	018f7fH
	ORG $+32
	DD	018c09H
	DD	018c0aH
	DD	018c0bH
	DD	018c0cH
	DD	018c0dH
	DD	018c0eH
	DD	018c0fH
	DD	018c10H
	DD	018af4H
	DD	018af5H
	DD	018e5fH
	DD	018e54H
	DD	018849H
	DD	018844H
	DD	01885dH
	DD	018eefH
	DD	018f17H
	DD	018f23H
	DD	018f80H
	ORG $+32
	DD	018c11H
	DD	018c12H
	DD	018c13H
	DD	018c14H
	DD	018c15H
	DD	018c16H
	DD	018c17H
	DD	018c18H
	DD	018afeH
	DD	018affH
	DD	018e5eH
	DD	018e53H
	DD	018849H
	DD	018844H
	DD	01885dH
	DD	018ef0H
	DD	018f18H
	DD	018f24H
	DD	018f81H
	ORG $+32
?RPlistMode@@3PAUtagRidePetList@@A DD 0186a0H		; RPlistMode
	DD	00H
	DD	0186a5H
	DD	00H
	DD	0186aaH
	DD	00H
	DD	0186afH
	DD	00H
	DD	0186b4H
	DD	01H
	DD	0186b9H
	DD	01H
	DD	0186beH
	DD	01H
	DD	0186c3H
	DD	01H
	DD	0186c8H
	DD	02H
	DD	0186cdH
	DD	02H
	DD	0186d2H
	DD	02H
	DD	0186d7H
	DD	02H
	DD	0186dcH
	DD	03H
	DD	0186e1H
	DD	03H
	DD	0186e6H
	DD	03H
	DD	0186ebH
	DD	03H
	DD	0186f0H
	DD	04H
	DD	0186f5H
	DD	04H
	DD	0186faH
	DD	04H
	DD	0186ffH
	DD	04H
	DD	018704H
	DD	05H
	DD	018709H
	DD	05H
	DD	01870eH
	DD	05H
	DD	018713H
	DD	05H
	DD	018718H
	DD	06H
	DD	01871dH
	DD	06H
	DD	018722H
	DD	06H
	DD	018727H
	DD	06H
	DD	01872cH
	DD	07H
	DD	018731H
	DD	07H
	DD	018736H
	DD	07H
	DD	01873bH
	DD	07H
	DD	018740H
	DD	08H
	DD	018745H
	DD	08H
	DD	01874aH
	DD	08H
	DD	01874fH
	DD	08H
	DD	018754H
	DD	09H
	DD	018759H
	DD	09H
	DD	01875eH
	DD	09H
	DD	018763H
	DD	09H
	DD	018768H
	DD	0aH
	DD	01876dH
	DD	0aH
	DD	018772H
	DD	0aH
	DD	018777H
	DD	0aH
	DD	01877cH
	DD	0bH
	DD	018781H
	DD	0bH
	DD	018786H
	DD	0bH
	DD	01878bH
	DD	0bH
?sockRaw@@3IA DD 0ffffffffH				; sockRaw
?selectServerIndex@@3FA DW 0ffffH			; selectServerIndex
	ORG $+2
?Channel@?1??SaveChatData@@YAXPADD_N@Z@4PAGA DW 08H	; `SaveChatData'::`2'::Channel
	DW	040H
	DW	080H
	DW	0100H
	DW	0400H
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	___local_stdio_scanf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_printf
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	__vsscanf_l
PUBLIC	_sscanf
PUBLIC	?strstr@@YAPADQADQBD@Z				; strstr
PUBLIC	?initConnectServer@@YAXXZ			; initConnectServer
PUBLIC	?ConnectWGS@@YAHXZ				; ConnectWGS
PUBLIC	?connectServer@@YAHXZ				; connectServer
PUBLIC	?charListStart@@YAXXZ				; charListStart
PUBLIC	?charListProc@@YAHXZ				; charListProc
PUBLIC	?charLoginStart@@YAXXZ				; charLoginStart
PUBLIC	?charLoginProc@@YAHXZ				; charLoginProc
PUBLIC	?createNewCharStart@@YAXXZ			; createNewCharStart
PUBLIC	?createNewCharProc@@YAHXZ			; createNewCharProc
PUBLIC	?charLogoutStart@@YAXXZ				; charLogoutStart
PUBLIC	?charLogoutProc@@YAHXZ				; charLogoutProc
PUBLIC	?walkSendForServer@@YAXHHPAD@Z			; walkSendForServer
PUBLIC	?noChecksumWalkSendForServer@@YAXHHPAD@Z	; noChecksumWalkSendForServer
PUBLIC	?chatStrSendForServer@@YAXPADH@Z		; chatStrSendForServer
PUBLIC	?delCharStart@@YAXXZ				; delCharStart
PUBLIC	?delCharProc@@YAHXZ				; delCharProc
PUBLIC	?lssproto_DENGON_recv@@YAXPADHH@Z		; lssproto_DENGON_recv
PUBLIC	?lssproto_XYD_recv@@YAXHHHH@Z			; lssproto_XYD_recv
PUBLIC	?lssproto_EV_recv@@YAXHHH@Z			; lssproto_EV_recv
PUBLIC	?lssproto_EN_recv@@YAXHHH@Z			; lssproto_EN_recv
PUBLIC	?lssproto_RS_recv@@YAXHPAD@Z			; lssproto_RS_recv
PUBLIC	?lssproto_RD_recv@@YAXHPAD@Z			; lssproto_RD_recv
PUBLIC	?lssproto_B_recv@@YAXHPAD@Z			; lssproto_B_recv
PUBLIC	?lssproto_I_recv@@YAXHPAD@Z			; lssproto_I_recv
PUBLIC	?lssproto_SI_recv@@YAXHHH@Z			; lssproto_SI_recv
PUBLIC	?lssproto_MSG_recv@@YAXHHPADH@Z			; lssproto_MSG_recv
PUBLIC	?lssproto_PME_recv@@YAXHHHHHHHHPAD@Z		; lssproto_PME_recv
PUBLIC	?lssproto_AB_recv@@YAXHPAD@Z			; lssproto_AB_recv
PUBLIC	?lssproto_ABI_recv@@YAXHHPAD@Z			; lssproto_ABI_recv
PUBLIC	?lssproto_TK_recv@@YAXHHPADH@Z			; lssproto_TK_recv
PUBLIC	?lssproto_MC_recv@@YAXHHHHHHHHHPAD@Z		; lssproto_MC_recv
PUBLIC	?lssproto_M_recv@@YAXHHHHHHPAD@Z		; lssproto_M_recv
PUBLIC	?lssproto_C_recv@@YAXHPAD@Z			; lssproto_C_recv
PUBLIC	?lssproto_CA_recv@@YAXHPAD@Z			; lssproto_CA_recv
PUBLIC	?lssproto_CD_recv@@YAXHPAD@Z			; lssproto_CD_recv
PUBLIC	?lssproto_R_recv@@YAXHPAD@Z			; lssproto_R_recv
PUBLIC	?lssproto_S_recv@@YAXHPAD@Z			; lssproto_S_recv
PUBLIC	?lssproto_D_recv@@YAXHHHHPAD@Z			; lssproto_D_recv
PUBLIC	?lssproto_FS_recv@@YAXHH@Z			; lssproto_FS_recv
PUBLIC	?lssproto_HL_recv@@YAXHH@Z			; lssproto_HL_recv
PUBLIC	?lssproto_PR_recv@@YAXHHH@Z			; lssproto_PR_recv
PUBLIC	?lssproto_KS_recv@@YAXHHH@Z			; lssproto_KS_recv
PUBLIC	?lssproto_SPET_recv@@YAXHHH@Z			; lssproto_SPET_recv
PUBLIC	?lssproto_PS_recv@@YAXHHHHH@Z			; lssproto_PS_recv
PUBLIC	?lssproto_SKUP_recv@@YAXHH@Z			; lssproto_SKUP_recv
PUBLIC	?lssproto_WN_recv@@YAXHHHHHPAD@Z		; lssproto_WN_recv
PUBLIC	?lssproto_EF_recv@@YAXHHHPAD@Z			; lssproto_EF_recv
PUBLIC	?lssproto_SE_recv@@YAXHHHHH@Z			; lssproto_SE_recv
PUBLIC	?lssproto_ClientLogin_recv@@YAXHPAD@Z		; lssproto_ClientLogin_recv
PUBLIC	?lssproto_CreateNewChar_recv@@YAXHPAD0@Z	; lssproto_CreateNewChar_recv
PUBLIC	?lssproto_CharDelete_recv@@YAXHPAD0@Z		; lssproto_CharDelete_recv
PUBLIC	?lssproto_CharLogin_recv@@YAXHPAD0@Z		; lssproto_CharLogin_recv
PUBLIC	?lssproto_CharList_recv@@YAXHPAD0@Z		; lssproto_CharList_recv
PUBLIC	?lssproto_CharLogout_recv@@YAXHPAD0@Z		; lssproto_CharLogout_recv
PUBLIC	?lssproto_ProcGet_recv@@YAXHPAD@Z		; lssproto_ProcGet_recv
PUBLIC	?lssproto_PlayerNumGet_recv@@YAXHHH@Z		; lssproto_PlayerNumGet_recv
PUBLIC	?lssproto_Echo_recv@@YAXHPAD@Z			; lssproto_Echo_recv
PUBLIC	?lssproto_NU_recv@@YAXHH@Z			; lssproto_NU_recv
PUBLIC	?lssproto_FM_recv@@YAXHPAD@Z			; lssproto_FM_recv
PUBLIC	?lssproto_WO_recv@@YAXHH@Z			; lssproto_WO_recv
PUBLIC	?lssproto_IC_recv@@YAXHHH@Z			; lssproto_IC_recv
PUBLIC	?lssproto_NC_recv@@YAXHH@Z			; lssproto_NC_recv
PUBLIC	?lssproto_PETST_recv@@YAXHHH@Z			; lssproto_PETST_recv
PUBLIC	?lssproto_STREET_VENDOR_recv@@YAXHPAD@Z		; lssproto_STREET_VENDOR_recv
PUBLIC	?lssproto_JOBDAILY_recv@@YAXHPAD@Z		; lssproto_JOBDAILY_recv
PUBLIC	?lssproto_TEACHER_SYSTEM_recv@@YAXHPAD@Z	; lssproto_TEACHER_SYSTEM_recv
PUBLIC	?lssproto_S2_recv@@YAXHPAD@Z			; lssproto_S2_recv
PUBLIC	?lssproto_Firework_recv@@YAXHHHH@Z		; lssproto_Firework_recv
PUBLIC	?SortSkill@@YAXXZ				; SortSkill
PUBLIC	?SaveChatData@@YAXPADD_N@Z			; SaveChatData
PUBLIC	?LogToRecvdata2@@YAXPAD@Z			; LogToRecvdata2
PUBLIC	?PingFunc@@YGKPAX@Z				; PingFunc
PUBLIC	?lssproto_W_recv@@YAXHHHH@Z			; lssproto_W_recv
PUBLIC	?lssproto_IS_recv@@YAXHPAD@Z			; lssproto_IS_recv
PUBLIC	?lssproto_ACI_recv@@YAXHPAD@Z			; lssproto_ACI_recv
PUBLIC	?checksum@@YAGPAGH@Z				; checksum
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0N@OFOPBFLC@recvdata?4txt?$AA@		; `string'
PUBLIC	??_C@_02DPNLHKJD@a?$CL?$AA@			; `string'
PUBLIC	??_C@_0L@INAHAGEI@?b?$KF?S?p?$KD?$LK?7?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@JAKPHLLB@?Y?i?$NL?v?$DP?z?$LMsocket?n?$NMTCP?$KB?$KD?$AA@ ; `string'
PUBLIC	??_C@_03GMCCICCK@WGS?$AA@			; `string'
PUBLIC	??_C@_0BO@BHPEJLIB@?Y?i?$NL?v?$DP?T?p?$NO?C?$NM?W?P?o?n?$NM?$KD?I?$KD?P?j?H?v?G?$KB?$KD?$CI?$CFs?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BI@CKHMFIAG@?Y?i?$NL?v?$DP?c?$LH?$DP?z?$LM?$NO?C?$NM?W?P?o?n?$NM?$DP?o?H?$KB?$KD?$AA@ ; `string'
PUBLIC	??_C@_0O@KDOBPHMN@?$DP?V?X?$DP?Z?$LB?q?W?$DP?$PL?$LP?$KB?$KD?$AA@ ; `string'
PUBLIC	??_C@_0CG@KEAEOGKH@?$LN?$LK?E?f?$LP?$KB?$MA?L?A?v?5?G?O?$LE?C?$MA?$LK?5?G?v?$MA?g?5?A?$KB?$LA?K?5?A?$NP?$MA?T@ ; `string'
PUBLIC	??_C@_02ODPEBLOD@CS?$AA@			; `string'
PUBLIC	??_C@_0BC@PMNBOGBM@?$NO?C?$NM?W?P?o?$DP?o?H?$DP?$DP?l?$KL?S?p?$KB?$KD?$AA@ ; `string'
PUBLIC	??_C@_0N@LCBBLLOI@www?493sa?4com?$AA@		; `string'
PUBLIC	??_C@_0BB@KFDLBKA@?$NO?C?$NM?W?P?o?Y?$KD?$DP?$NM?t?o?a?$DP?$KB?$KD?$AA@ ; `string'
PUBLIC	??_C@_0BA@NDJIOBBC@?$OA?$LE?P?o?$DP?S?$NL?w?z?$NM?b?$NM?t?T?R?$AA@ ; `string'
PUBLIC	??_C@_05DAOAAINN@login?$AA@			; `string'
PUBLIC	??_C@_09BACHGGGK@f?$DLencor1c?$AA@		; `string'
PUBLIC	??_C@_08DDDJOECK@19761101?$AA@			; `string'
PUBLIC	??_C@_02MFDMBIJM@ok?$AA@			; `string'
PUBLIC	??_C@_06ENLDJGGB@cancle?$AA@			; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_0BC@OCCGLCLB@?$DP?v?$KC?l?Q?Z?$KK?x?z?$DP?$DP?l?$KL?S?p?$KB?$KD?$AA@ ; `string'
PUBLIC	??_C@_06ODACHPEO@failed?$AA@			; `string'
PUBLIC	??_C@_0L@LHCHIOPJ@successful?$AA@		; `string'
PUBLIC	??_C@_0N@OGLBPKPL@OUTOFSERVICE?$AA@		; `string'
PUBLIC	??_C@_0O@ENFKOFGC@CHANGE_GALAXY?$AA@		; `string'
PUBLIC	??_C@_03NOBDJFIO@301?$AA@			; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0BA@JFEMHLAM@?T?t?l?$PN?$DP?W?b?$DP?$DP?l?$KL?S?p?$KB?$KD?$AA@ ; `string'
PUBLIC	??_C@_0BA@KHEOLEJA@?T?t?u?s?$DP?W?b?$DP?$DP?l?$KL?S?p?$KB?$KD?$AA@ ; `string'
PUBLIC	??_C@_01NBENCBCI@?$CK?$AA@			; `string'
PUBLIC	??_C@_0M@OMPDAMON@data?$FL1?$FN?3?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_03BBKEAIF@?$DP?$DP?$DP?$AA@		; `string'
PUBLIC	??_C@_0N@GGCIJCKF@?$DP?$DP?$DP?5name?5?$DP?$DP?$DP?$AA@ ; `string'
PUBLIC	??_C@_0N@HKHEIDPM@?$DP?$DP?$DP?5memo?5?$DP?$DP?$DP?$AA@ ; `string'
PUBLIC	??_C@_08PFECBJKL@?$CFd?5Stone?$AA@		; `string'
PUBLIC	??_C@_04BKLDHGDD@P?$HM?$CFs?$AA@		; `string'
PUBLIC	??_C@_0BE@BFJFDKGC@?r?$KG?V?$LF?$NO?E?i?D?L?$KL?c?R?$NM?t?o?a?$DP?$KD?$KB?$AA@ ; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	??_C@_03IKGEINEE@?$CFs?5?$AA@			; `string'
PUBLIC	??_C@_0L@BFDNBDBG@P?$HM?1tell?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_07JGJAFNNL@P?$HM?1FM?$CFs?$AA@		; `string'
PUBLIC	??_C@_0N@INHGBDFL@P?$HM?1OCC?$CFs?$KD?$LK?$CFs?$AA@ ; `string'
PUBLIC	??_C@_08KCFIPDCG@T?$HM?$CFs?$KD?$LK?$CFs?$AA@	; `string'
PUBLIC	??_C@_08IPPAKAEL@P?$HM?1WD?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_08NGKGAKGM@P?$HM?1XQ?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_02HIIGDGEP@TK?$AA@			; `string'
PUBLIC	??_C@_02OGAFBLMB@TE?$AA@			; `string'
PUBLIC	??_C@_0BH@DFPJGLLL@?$OA?w?X?$KB?V?$PN?t?$LI?c?x?$DP?p?$LG?$KD?$LC?$KD?$LA?$KD?$LA?$OA?$LE?$DP?$AA@ ; `string'
PUBLIC	??_C@_0BB@JFAECEMN@?l?Q?Z?$KK?p?$KE?m?B?$DP?$DP?l?$KL?S?p?$KB?$KD?$AA@ ; `string'
PUBLIC	??_C@_0BB@ILDAKNL@?l?Q?Z?$KK?$NO?$PL?p?$LG?$DP?$DP?l?$KL?S?p?$KB?$KD?$AA@ ; `string'
PUBLIC	??_C@_0BK@NFKFNKL@?$NM?z?$DP?J?$KL?p?i?n?$KE?v?R?t?$LI?q?$PN?$PN?$KI?$DP?a?$LM?c?w?$DP?$KD?$KB?$AA@ ; `string'
PUBLIC	??_C@_08EOJECCGN@?$CFX?$HM?$CFX?$HM?$CFX?$AA@	; `string'
PUBLIC	??_C@_05HMDCACKA@?$CFX?$HM?$CFX?$AA@		; `string'
PUBLIC	??_C@_03ILJCGOLJ@?6?$CFs?$AA@			; `string'
PUBLIC	??_C@_0BE@MGOKMGBK@?b?$KF?S?p?$CFs?a?j?$DP?n?$NM?$DP?Z?$KK?$DP?K?l?$KD?$KB?$AA@ ; `string'
PUBLIC	??_C@_0BB@JIMIMFE@?b?$KF?S?p?$CFs?a?j?$DP?n?$NM?$DP?K?l?$KD?$KB?$AA@ ; `string'
PUBLIC	??_C@_05OAJDDNFL@?c?w?$DP?$KD?$KB?$AA@		; `string'
PUBLIC	??_C@_01CPLAODJH@S?$AA@				; `string'
PUBLIC	??_C@_01BIAFAFID@F?$AA@				; `string'
PUBLIC	??_C@_01CKDDGHAB@D?$AA@				; `string'
PUBLIC	??_C@_01GFHCPBMG@C?$AA@				; `string'
PUBLIC	??_C@_01LELAEKIP@J?$AA@				; `string'
PUBLIC	??_C@_01OCOKONAJ@L?$AA@				; `string'
PUBLIC	??_C@_01HMGJMAIH@B?$AA@				; `string'
PUBLIC	??_C@_01BBODEMC@G?$AA@				; `string'
PUBLIC	??_C@_01JPJNBJEM@I?$AA@				; `string'
PUBLIC	??_C@_01GAPBHFFA@T?$AA@				; `string'
PUBLIC	??_C@_01DGKLNCNG@R?$AA@				; `string'
PUBLIC	??_C@_01EJNLAFE@P?$AA@				; `string'
PUBLIC	??_C@_06BCPILJJG@CHANGE?$AA@			; `string'
PUBLIC	??_C@_0BG@JGFFJBEF@chat?2?$CF02d?$CF02d?$CF02d?4TXT?$AA@ ; `string'
PUBLIC	??_C@_01MCMALHOG@a?$AA@				; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0O@PEDECIPG@?X?$NP?$DP?$DP?V?y?$DP?$DP?$DP?j?s?$DP?$DP?$AA@ ; `string'
PUBLIC	??_C@_04DIIKDPIA@FAME?$AA@			; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fflush:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp____stdio_common_vsscanf:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__strstr:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__strncpy:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__GetCurrentProcessId@0:PROC
EXTRN	__imp__CreateThread@24:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__lstrcpyA@8:PROC
EXTRN	__imp__lstrcatA@8:PROC
EXTRN	__imp__lstrlenA@4:PROC
EXTRN	__imp__atoi:PROC
EXTRN	___WSAFDIsSet@8:PROC
EXTRN	_closesocket@4:PROC
EXTRN	_connect@12:PROC
EXTRN	_ioctlsocket@12:PROC
EXTRN	_htons@4:PROC
EXTRN	_inet_addr@4:PROC
EXTRN	_recv@16:PROC
EXTRN	_recvfrom@24:PROC
EXTRN	_select@20:PROC
EXTRN	_sendto@24:PROC
EXTRN	_setsockopt@20:PROC
EXTRN	_socket@12:PROC
EXTRN	_gethostbyname@4:PROC
EXTRN	_WSAGetLastError@0:PROC
EXTRN	__imp___localtime64:PROC
EXTRN	__imp___time64:PROC
EXTRN	?TimeGetTime@@YAIXZ:PROC			; TimeGetTime
EXTRN	?PaletteChange@@YAXHH@Z:PROC			; PaletteChange
EXTRN	?ChangeProc@@YAXH@Z:PROC			; ChangeProc
EXTRN	?warpEffectProc@@YAXXZ:PROC			; warpEffectProc
EXTRN	?JL_SetFastFightFlag@@YAX_N@Z:PROC		; JL_SetFastFightFlag
EXTRN	?JL_锁定人物@@YAX_N@Z:PROC			; JL_锁定人物
EXTRN	?JL_关闭特效_回记录点@@YAXXZ:PROC		; JL_关闭特效_回记录点
EXTRN	?sunday@@YAPADPAD0@Z:PROC			; sunday
EXTRN	?DeathAction@@YAXPAUaction@@@Z:PROC		; DeathAction
EXTRN	?DeathAllAction@@YAXXZ:PROC			; DeathAllAction
EXTRN	?StockChatBufferLine@@YAXPADEH@Z:PROC		; StockChatBufferLine
EXTRN	?StockChatBufferLineExt@@YAXPADEHH@Z:PROC	; StockChatBufferLineExt
EXTRN	?getServerInfo@@YAHHPADPAF@Z:PROC		; getServerInfo
EXTRN	?initNet@@YAHXZ:PROC				; initNet
EXTRN	?cleanupNetwork@@YAXXZ:PROC			; cleanupNetwork
EXTRN	?lssproto_W2_send@@YAXHHHPAD@Z:PROC		; lssproto_W2_send
EXTRN	?lssproto_TK_send@@YAXHHHPADHH@Z:PROC		; lssproto_TK_send
EXTRN	?lssproto_AC_send@@YAXHHHH@Z:PROC		; lssproto_AC_send
EXTRN	?lssproto_SP_send@@YAXHHHH@Z:PROC		; lssproto_SP_send
EXTRN	?lssproto_ClientLogin_send@@YAXHPAD0@Z:PROC	; lssproto_ClientLogin_send
EXTRN	?lssproto_CreateNewChar_send@@YAXHHPADHHHHHHHHHHH@Z:PROC ; lssproto_CreateNewChar_send
EXTRN	?lssproto_CharDelete_send@@YAXHPAD@Z:PROC	; lssproto_CharDelete_send
EXTRN	?lssproto_CharLogin_send@@YAXHPAD@Z:PROC	; lssproto_CharLogin_send
EXTRN	?lssproto_CharList_send@@YAXH@Z:PROC		; lssproto_CharList_send
EXTRN	?lssproto_CharLogout_send@@YAXHH@Z:PROC		; lssproto_CharLogout_send
EXTRN	?lssproto_MA_send@@YAXHHHH@Z:PROC		; lssproto_MA_send
EXTRN	?lssproto_CHATROOM_send@@YAXHPAD@Z:PROC		; lssproto_CHATROOM_send
EXTRN	?old_lssproto_W_send@@YAXHHHPAD@Z:PROC		; old_lssproto_W_send
EXTRN	?old_lssproto_w_send@@YAXHHHPAD@Z:PROC		; old_lssproto_w_send
EXTRN	?old_lssproto_TK_send@@YAXHHHPADHH@Z:PROC	; old_lssproto_TK_send
EXTRN	?old_lssproto_AC_send@@YAXHHHH@Z:PROC		; old_lssproto_AC_send
EXTRN	?old_lssproto_SP_send@@YAXHHHH@Z:PROC		; old_lssproto_SP_send
EXTRN	?old_lssproto_ClientLogin_send@@YAXHPAD0@Z:PROC	; old_lssproto_ClientLogin_send
EXTRN	?old_lssproto_CreateNewChar_send@@YAXHHPADHHHHHHHHHHH@Z:PROC ; old_lssproto_CreateNewChar_send
EXTRN	?old_lssproto_CharDelete_send@@YAXHPAD@Z:PROC	; old_lssproto_CharDelete_send
EXTRN	?old_lssproto_CharLogin_send@@YAXHPAD@Z:PROC	; old_lssproto_CharLogin_send
EXTRN	?old_lssproto_CharList_send@@YAXH@Z:PROC	; old_lssproto_CharList_send
EXTRN	?old_lssproto_CharLogout_send@@YAXH@Z:PROC	; old_lssproto_CharLogout_send
EXTRN	?saveUserSetting@@YAHXZ:PROC			; saveUserSetting
EXTRN	?createPc@@YAXHHHH@Z:PROC			; createPc
EXTRN	?resetPc@@YAXXZ:PROC				; resetPc
EXTRN	?setPcWarpPoint@@YAXHH@Z:PROC			; setPcWarpPoint
EXTRN	?setPcPoint@@YAXXZ:PROC				; setPcPoint
EXTRN	?setPcGraNo@@YAXHH@Z:PROC			; setPcGraNo
EXTRN	?setPcId@@YAXH@Z:PROC				; setPcId
EXTRN	?setPcDir@@YAXH@Z:PROC				; setPcDir
EXTRN	?setPcAction@@YAXH@Z:PROC			; setPcAction
EXTRN	?setPcParam@@YAXPAD0H0HHHHHHHH@Z:PROC		; setPcParam
EXTRN	?updataPcAct@@YAXXZ:PROC			; updataPcAct
EXTRN	?setPcLeader@@YAXXZ:PROC			; setPcLeader
EXTRN	?setPcParty@@YAXXZ:PROC				; setPcParty
EXTRN	?changePcAct@@YAXHHHHHHH@Z:PROC			; changePcAct
EXTRN	?setPcFukidashi@@YAXI@Z:PROC			; setPcFukidashi
EXTRN	?setPcNameColor@@YAXH@Z:PROC			; setPcNameColor
EXTRN	?clearPartyParam@@YAXXZ:PROC			; clearPartyParam
EXTRN	?clearPtActPartyParam@@YAXXZ:PROC		; clearPtActPartyParam
EXTRN	?setCharacterList@@YAHPAD0@Z:PROC		; setCharacterList
EXTRN	?resetCharacterList@@YAHH@Z:PROC		; resetCharacterList
EXTRN	?swapItem@@YAXHH@Z:PROC				; swapItem
EXTRN	?getStringToken@@YAHPADDHH0@Z:PROC		; getStringToken
EXTRN	?getIntegerToken@@YAHPADDH@Z:PROC		; getIntegerToken
EXTRN	?a62toi@@YAHPAD@Z:PROC				; a62toi
EXTRN	?getInteger62Token@@YAHPADDH@Z:PROC		; getInteger62Token
EXTRN	?makeStringFromEscaped@@YAPADPAD@Z:PROC		; makeStringFromEscaped
EXTRN	?makeEscapeString@@YAPADPAD0H@Z:PROC		; makeEscapeString
EXTRN	?resetMap@@YAXXZ:PROC				; resetMap
EXTRN	?createMap@@YAXHHH@Z:PROC			; createMap
EXTRN	?writeMap@@YAHHHHHHPAG00@Z:PROC			; writeMap
EXTRN	?setMap@@YAXHHH@Z:PROC				; setMap
EXTRN	?mapCheckSum@@YAHHHHHHHHH@Z:PROC		; mapCheckSum
EXTRN	?redrawMap@@YAXXZ:PROC				; redrawMap
EXTRN	?updateMapArea@@YAXXZ:PROC			; updateMapArea
EXTRN	?goFrontPartyCharacter@@YAXHHH@Z:PROC		; goFrontPartyCharacter
EXTRN	?initMapEffect@@YAXH@Z:PROC			; initMapEffect
EXTRN	?setNpcNotice@@YAXPAUaction@@H@Z:PROC		; setNpcNotice
EXTRN	?changeCharAct@@YAXPAUaction@@HHHHHHH@Z:PROC	; changeCharAct
EXTRN	?setCharLeader@@YAXPAUaction@@@Z:PROC		; setCharLeader
EXTRN	?setCharParty@@YAXPAUaction@@@Z:PROC		; setCharParty
EXTRN	?delCharParty@@YAXPAUaction@@@Z:PROC		; delCharParty
EXTRN	?setCharMind@@YAXPAUaction@@H@Z:PROC		; setCharMind
EXTRN	?setCharFukidashi@@YAXPAUaction@@I@Z:PROC	; setCharFukidashi
EXTRN	?setCharNameColor@@YAXPAUaction@@H@Z:PROC	; setCharNameColor
EXTRN	?setNpcCharObj@@YAXHHHHHPAD00H0HHHHHHHH@Z:PROC	; setNpcCharObj
EXTRN	?setReturnPetObj@@YAHHHHHHPAD0HHHHH@Z:PROC	; setReturnPetObj
EXTRN	?setItemCharObj@@YAXHHHHHHPAD@Z:PROC		; setItemCharObj
EXTRN	?setMoneyCharObj@@YAXHHHHHHPAD@Z:PROC		; setMoneyCharObj
EXTRN	?delCharObj@@YAXH@Z:PROC			; delCharObj
EXTRN	?resetCharObj@@YAXXZ:PROC			; resetCharObj
EXTRN	?getCharObjAct@@YAPAUaction@@H@Z:PROC		; getCharObjAct
EXTRN	?createPetAction@@YAPAUaction@@HHHHHHH@Z:PROC	; createPetAction
EXTRN	?TradeTalk@@YAXPAD@Z:PROC			; TradeTalk
EXTRN	?SaveMailHistory@@YAHH@Z:PROC			; SaveMailHistory
EXTRN	?CheckMailNoReadFlag@@YAHXZ:PROC		; CheckMailNoReadFlag
EXTRN	?DeathLetterAction@@YAXXZ:PROC			; DeathLetterAction
EXTRN	?BankmanInit@@YAXPAD@Z:PROC			; BankmanInit
EXTRN	?InitSelectChar@@YAXPADH@Z:PROC			; InitSelectChar
EXTRN	?openServerWindow@@YAXHHHHPAD@Z:PROC		; openServerWindow
EXTRN	?RealTimeToSATime@@YAXPAUtagLSTIME@@@Z:PROC	; RealTimeToSATime
EXTRN	?getLSTime@@YA?AW4LSTIME_SECTION@@PAUtagLSTIME@@@Z:PROC ; getLSTime
EXTRN	?play_se@@YAHHHH@Z:PROC				; play_se
EXTRN	?DoHellow@@YAXXZ:PROC				; DoHellow
EXTRN	?DoSKey@@YAXXZ:PROC				; DoSKey
EXTRN	?ecb_crypt@@YAHPAD0II@Z:PROC			; ecb_crypt
EXTRN	__imp__VMProtectBegin@4:PROC
EXTRN	__imp__VMProtectEnd@0:PROC
EXTRN	?initFamilyList@@YAXPAD@Z:PROC			; initFamilyList
EXTRN	?initFamilyDetail@@YAXPAD@Z:PROC		; initFamilyDetail
EXTRN	?initJoinChannel2WN@@YAXPAD@Z:PROC		; initJoinChannel2WN
EXTRN	?initFamilyTaxWN@@YAXPAD@Z:PROC			; initFamilyTaxWN
EXTRN	?initFamilyLeaderChange@@YAXPAD@Z:PROC		; initFamilyLeaderChange
EXTRN	?StreetVendorWndfunc@@YAX_NPAD@Z:PROC		; StreetVendorWndfunc
EXTRN	?StreetVendorBuyWndfunc@@YAXPAD@Z:PROC		; StreetVendorBuyWndfunc
EXTRN	?TeacherSystemWndfunc@@YAXHPAD@Z:PROC		; TeacherSystemWndfunc
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
EXTRN	?ProcNo@@3IA:DWORD				; ProcNo
EXTRN	?SubProcNo@@3IA:DWORD				; SubProcNo
EXTRN	?palNo@@3HA:DWORD				; palNo
EXTRN	?palTime@@3HA:DWORD				; palTime
EXTRN	?PersonalKey@@3PADA:BYTE			; PersonalKey
EXTRN	?NowMaxVoice@@3HA:DWORD				; NowMaxVoice
EXTRN	?sockfd@@3IA:DWORD				; sockfd
EXTRN	?server_choosed@@3HA:DWORD			; server_choosed
EXTRN	?init_net@@3HA:DWORD				; init_net
EXTRN	?disconnectServerFlag@@3HA:DWORD		; disconnectServerFlag
EXTRN	?oldDisconnectServerFlag@@3HA:DWORD		; oldDisconnectServerFlag
EXTRN	?SendCount@@3HA:DWORD				; SendCount
EXTRN	?sPetStatFlag@@3HA:DWORD			; sPetStatFlag
EXTRN	?pc@@3UPC@@A:BYTE				; pc
EXTRN	?selectPcNo@@3FA:WORD				; selectPcNo
EXTRN	?prSendFlag@@3FA:WORD				; prSendFlag
EXTRN	?jbSendFlag@@3FA:WORD				; jbSendFlag
EXTRN	?duelSendFlag@@3FA:WORD				; duelSendFlag
EXTRN	?helpFlag@@3FA:WORD				; helpFlag
EXTRN	?tradeStatus@@3FA:WORD				; tradeStatus
EXTRN	?magic@@3PAUMAGIC@@A:BYTE			; magic
EXTRN	?pet@@3PAUPET@@A:BYTE				; pet
EXTRN	?party@@3PAUPARTY@@A:BYTE			; party
EXTRN	?partyModeFlag@@3FA:WORD			; partyModeFlag
EXTRN	?addressBook@@3PAUADDRESS_BOOK@@A:BYTE		; addressBook
EXTRN	?battleResultMsg@@3UBATTLE_RESULT_MSG@@A:BYTE	; battleResultMsg
EXTRN	?petSkill@@3PAY06UPET_SKILL@@A:BYTE		; petSkill
EXTRN	?newCharacterName@@3PADA:BYTE			; newCharacterName
EXTRN	?newCharacterGraNo@@3HA:DWORD			; newCharacterGraNo
EXTRN	?newCharacterFaceGraNo@@3HA:DWORD		; newCharacterFaceGraNo
EXTRN	?newCharacterVit@@3HA:DWORD			; newCharacterVit
EXTRN	?newCharacterStr@@3HA:DWORD			; newCharacterStr
EXTRN	?newCharacterTgh@@3HA:DWORD			; newCharacterTgh
EXTRN	?newCharacterDex@@3HA:DWORD			; newCharacterDex
EXTRN	?newCharacterEarth@@3HA:DWORD			; newCharacterEarth
EXTRN	?newCharacterWater@@3HA:DWORD			; newCharacterWater
EXTRN	?newCharacterFire@@3HA:DWORD			; newCharacterFire
EXTRN	?newCharacterWind@@3HA:DWORD			; newCharacterWind
EXTRN	?newCharacterHomeTown@@3HA:DWORD		; newCharacterHomeTown
EXTRN	?profession_skill@@3PAUPROFESSION_SKILL@@A:BYTE	; profession_skill
EXTRN	?nowFloorName@@3PADA:BYTE			; nowFloorName
EXTRN	?nowFloor@@3HA:DWORD				; nowFloor
EXTRN	?nowFloorGxSize@@3HA:DWORD			; nowFloorGxSize
EXTRN	?nowFloorGySize@@3HA:DWORD			; nowFloorGySize
EXTRN	?nowGx@@3HA:DWORD				; nowGx
EXTRN	?nowGy@@3HA:DWORD				; nowGy
EXTRN	?nextGx@@3HA:DWORD				; nextGx
EXTRN	?nextGy@@3HA:DWORD				; nextGy
EXTRN	?mapEmptyFlag@@3HA:DWORD			; mapEmptyFlag
EXTRN	?nowEncountPercentage@@3FA:WORD			; nowEncountPercentage
EXTRN	?nowEncountExtra@@3FA:WORD			; nowEncountExtra
EXTRN	?minEncountPercentage@@3FA:WORD			; minEncountPercentage
EXTRN	?maxEncountPercentage@@3FA:WORD			; maxEncountPercentage
EXTRN	?sendEnFlag@@3FA:WORD				; sendEnFlag
EXTRN	?encountNowFlag@@3FA:WORD			; encountNowFlag
EXTRN	?eventWarpSendFlag@@3FA:WORD			; eventWarpSendFlag
EXTRN	?eventWarpSendId@@3FA:WORD			; eventWarpSendId
EXTRN	?eventEnemySendFlag@@3FA:WORD			; eventEnemySendFlag
EXTRN	?eventEnemySendId@@3FA:WORD			; eventEnemySendId
EXTRN	?eventEnemyFlag@@3FA:WORD			; eventEnemyFlag
EXTRN	?loginFlag@@3HA:DWORD				; loginFlag
EXTRN	?vsLookFlag@@3FA:WORD				; vsLookFlag
EXTRN	?floorChangeFlag@@3HA:DWORD			; floorChangeFlag
EXTRN	?warpEffectFlag@@3HA:DWORD			; warpEffectFlag
EXTRN	?warpEffectStart@@3HA:DWORD			; warpEffectStart
EXTRN	?warpEffectOk@@3HA:DWORD			; warpEffectOk
EXTRN	?transmigrationEffectFlag@@3HA:DWORD		; transmigrationEffectFlag
EXTRN	?transEffectPaletteStatus@@3HA:DWORD		; transEffectPaletteStatus
EXTRN	?mapEffectRainLevel@@3FA:WORD			; mapEffectRainLevel
EXTRN	?mapEffectSnowLevel@@3FA:WORD			; mapEffectSnowLevel
EXTRN	?mapEffectKamiFubukiLevel@@3FA:WORD		; mapEffectKamiFubukiLevel
EXTRN	?mapEffectHalloween@@3HA:DWORD			; mapEffectHalloween
EXTRN	?BattleCmdBak@@3PAY0BAAA@DA:BYTE		; BattleCmdBak
EXTRN	?BattleCmdReadPointer@@3HA:DWORD		; BattleCmdReadPointer
EXTRN	?BattleCmdWritePointer@@3HA:DWORD		; BattleCmdWritePointer
EXTRN	?BattleStatusBak@@3PAY0BAAA@DA:BYTE		; BattleStatusBak
EXTRN	?BattleStatusReadPointer@@3HA:DWORD		; BattleStatusReadPointer
EXTRN	?BattleStatusWritePointer@@3HA:DWORD		; BattleStatusWritePointer
EXTRN	?BattleMyNo@@3HA:DWORD				; BattleMyNo
EXTRN	?BattleMyMp@@3HA:DWORD				; BattleMyMp
EXTRN	?BattleEscFlag@@3HA:DWORD			; BattleEscFlag
EXTRN	?BattlePetStMenCnt@@3HA:DWORD			; BattlePetStMenCnt
EXTRN	?battlePetNoBak@@3HA:DWORD			; battlePetNoBak
EXTRN	?BattleBpFlag@@3HA:DWORD			; BattleBpFlag
EXTRN	?BattleAnimFlag@@3HA:DWORD			; BattleAnimFlag
EXTRN	?BattleTurnReceiveFlag@@3HA:DWORD		; BattleTurnReceiveFlag
EXTRN	?BattleCliTurnNo@@3HA:DWORD			; BattleCliTurnNo
EXTRN	?BattleSvTurnNo@@3HA:DWORD			; BattleSvTurnNo
EXTRN	?EncountFlag@@3HA:DWORD				; EncountFlag
EXTRN	?NoHelpFlag@@3HA:DWORD				; NoHelpFlag
EXTRN	?NoCastFlag@@3HA:DWORD				; NoCastFlag
EXTRN	?DuelFlag@@3HA:DWORD				; DuelFlag
EXTRN	?BattleMapNo@@3HA:DWORD				; BattleMapNo
EXTRN	?MenuToggleFlag@@3IA:DWORD			; MenuToggleFlag
EXTRN	?StatusUpPoint@@3HA:DWORD			; StatusUpPoint
EXTRN	?BattlePetReceiveFlag@@3HA:DWORD		; BattlePetReceiveFlag
EXTRN	?StandbyPetSendFlag@@3HA:DWORD			; StandbyPetSendFlag
EXTRN	?BattlePetReceivePetNo@@3HA:DWORD		; BattlePetReceivePetNo
EXTRN	?MailHistory@@3PAUMAIL_HISTORY@@A:BYTE		; MailHistory
EXTRN	?mailHistoryWndPageNo@@3HA:DWORD		; mailHistoryWndPageNo
EXTRN	?mailHistoryWndSelectNo@@3HA:DWORD		; mailHistoryWndSelectNo
EXTRN	?MapWmdFlagBak@@3HA:DWORD			; MapWmdFlagBak
EXTRN	?ItemMixRecvFlag@@3HA:DWORD			; ItemMixRecvFlag
EXTRN	?TalkMode@@3HA:DWORD				; TalkMode
EXTRN	?secretName@@3PADA:BYTE				; secretName
EXTRN	?logOutFlag@@3HA:DWORD				; logOutFlag
EXTRN	?MsgCooltime@@3IA:DWORD				; MsgCooltime
EXTRN	?SaTime@@3UtagLSTIME@@A:BYTE			; SaTime
EXTRN	?serverTime@@3JA:DWORD				; serverTime
EXTRN	?FirstTime@@3JA:DWORD				; FirstTime
EXTRN	?SaTimeZoneNo@@3HA:DWORD			; SaTimeZoneNo
EXTRN	?TimeZonePalChangeFlag@@3HA:DWORD		; TimeZonePalChangeFlag
EXTRN	?angelFlag@@3HA:DWORD				; angelFlag
EXTRN	?angelMsg@@3PADA:BYTE				; angelMsg
EXTRN	?drawTimeAnimeFlag@@3FA:WORD			; drawTimeAnimeFlag
EXTRN	?mailLamp@@3FA:WORD				; mailLamp
EXTRN	?serverAliveTime@@3PAUtm@@A:DWORD		; serverAliveTime
EXTRN	?serverAliveLongTime@@3_JA:QWORD		; serverAliveLongTime
EXTRN	?dwServer@@3KA:DWORD				; dwServer
EXTRN	?iWGS@@3HA:DWORD				; iWGS
EXTRN	?szWGS@@3PADA:BYTE				; szWGS
EXTRN	?wWGS@@3GA:WORD					; wWGS
EXTRN	?szCSIP@@3PADA:BYTE				; szCSIP
EXTRN	?wCS@@3GA:WORD					; wCS
EXTRN	?PcLanded@@3ULanded@@A:BYTE			; PcLanded
EXTRN	?szUser@@3PADA:BYTE				; szUser
EXTRN	?szPassword@@3PADA:BYTE				; szPassword
EXTRN	?iEncrypt@@3HA:DWORD				; iEncrypt
EXTRN	?NoDelay@@3HA:DWORD				; NoDelay
EXTRN	?g_服务器@@3HA:DWORD				; g_服务器
EXTRN	?itemWndMaxBag@@3HA:DWORD			; itemWndMaxBag
EXTRN	?g_bFastFight@@3HA:DWORD			; g_bFastFight
EXTRN	?g_flag_FastFight@@3HA:DWORD			; g_flag_FastFight
EXTRN	?g_bFastFight@@3HA:DWORD			; g_bFastFight
EXTRN	?m_bt@@3_NA:BYTE				; m_bt
EXTRN	?sStreetVendorBtn@@3FA:WORD			; sStreetVendorBtn
EXTRN	?sStreetVendorBuyBtn@@3FA:WORD			; sStreetVendorBuyBtn
EXTRN	?jobdaily@@3PAUJOBDAILY@@A:BYTE			; jobdaily
EXTRN	?JobdailyGetFlag@@3HA:DWORD			; JobdailyGetFlag
EXTRN	?JobdailyGetMax@@3HA:DWORD			; JobdailyGetMax
EXTRN	?sTeacherSystemBtn@@3FA:WORD			; sTeacherSystemBtn
EXTRN	?公告数量@@3HA:DWORD				; 公告数量
EXTRN	?公告内容@@3PADA:BYTE				; 公告内容
EXTRN	?公告颜色@@3HA:DWORD				; 公告颜色
EXTRN	?公告时间@@3HA:DWORD				; 公告时间
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?pFile@?1??SaveChatData@@YAXPADD_N@Z@4PAPAU_iobuf@@A DD 05H DUP (?) ; `SaveChatData'::`2'::pFile
?szFileName@?1??SaveChatData@@YAXPADD_N@Z@4PADA DB 0100H DUP (?) ; `SaveChatData'::`2'::szFileName
?nowTime@?1??SaveChatData@@YAXPADD_N@Z@4PAUtm@@A DD 01H DUP (?) ; `SaveChatData'::`2'::nowTime
	ALIGN	8

?longTime@?1??SaveChatData@@YAXPADD_N@Z@4_JA DQ 01H DUP (?) ; `SaveChatData'::`2'::longTime
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_04DIIKDPIA@FAME?$AA@
CONST	SEGMENT
??_C@_04DIIKDPIA@FAME?$AA@ DB 'FAME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PEDECIPG@?X?$NP?$DP?$DP?V?y?$DP?$DP?$DP?j?s?$DP?$DP?$AA@
CONST	SEGMENT
??_C@_0O@PEDECIPG@?X?$NP?$DP?$DP?V?y?$DP?$DP?$DP?j?s?$DP?$DP?$AA@ DB 0d8H
	DB	0dfH, '??', 0d6H, 0f9H, '???', 0eaH, 0f3H, '??', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01MCMALHOG@a?$AA@
CONST	SEGMENT
??_C@_01MCMALHOG@a?$AA@ DB 'a', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JGFFJBEF@chat?2?$CF02d?$CF02d?$CF02d?4TXT?$AA@
CONST	SEGMENT
??_C@_0BG@JGFFJBEF@chat?2?$CF02d?$CF02d?$CF02d?4TXT?$AA@ DB 'chat\%02d%02'
	DB	'd%02d.TXT', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06BCPILJJG@CHANGE?$AA@
CONST	SEGMENT
??_C@_06BCPILJJG@CHANGE?$AA@ DB 'CHANGE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01EJNLAFE@P?$AA@
CONST	SEGMENT
??_C@_01EJNLAFE@P?$AA@ DB 'P', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01DGKLNCNG@R?$AA@
CONST	SEGMENT
??_C@_01DGKLNCNG@R?$AA@ DB 'R', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01GAPBHFFA@T?$AA@
CONST	SEGMENT
??_C@_01GAPBHFFA@T?$AA@ DB 'T', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JPJNBJEM@I?$AA@
CONST	SEGMENT
??_C@_01JPJNBJEM@I?$AA@ DB 'I', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BBODEMC@G?$AA@
CONST	SEGMENT
??_C@_01BBODEMC@G?$AA@ DB 'G', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HMGJMAIH@B?$AA@
CONST	SEGMENT
??_C@_01HMGJMAIH@B?$AA@ DB 'B', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OCOKONAJ@L?$AA@
CONST	SEGMENT
??_C@_01OCOKONAJ@L?$AA@ DB 'L', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LELAEKIP@J?$AA@
CONST	SEGMENT
??_C@_01LELAEKIP@J?$AA@ DB 'J', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT
??_C@_01GFHCPBMG@C?$AA@ DB 'C', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CKDDGHAB@D?$AA@
CONST	SEGMENT
??_C@_01CKDDGHAB@D?$AA@ DB 'D', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BIAFAFID@F?$AA@
CONST	SEGMENT
??_C@_01BIAFAFID@F?$AA@ DB 'F', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CPLAODJH@S?$AA@
CONST	SEGMENT
??_C@_01CPLAODJH@S?$AA@ DB 'S', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OAJDDNFL@?c?w?$DP?$KD?$KB?$AA@
CONST	SEGMENT
??_C@_05OAJDDNFL@?c?w?$DP?$KD?$KB?$AA@ DB 0e3H, 0f7H, '?', 0a3H, 0a1H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JIMIMFE@?b?$KF?S?p?$CFs?a?j?$DP?n?$NM?$DP?K?l?$KD?$KB?$AA@
CONST	SEGMENT
??_C@_0BB@JIMIMFE@?b?$KF?S?p?$CFs?a?j?$DP?n?$NM?$DP?K?l?$KD?$KB?$AA@ DB 0e2H
	DB	0a5H, 0d3H, 0f0H, '%s', 0e1H, 0eaH, '?', 0eeH, 0dcH, '?', 0cbH
	DB	0ecH, 0a3H, 0a1H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MGOKMGBK@?b?$KF?S?p?$CFs?a?j?$DP?n?$NM?$DP?Z?$KK?$DP?K?l?$KD?$KB?$AA@
CONST	SEGMENT
??_C@_0BE@MGOKMGBK@?b?$KF?S?p?$CFs?a?j?$DP?n?$NM?$DP?Z?$KK?$DP?K?l?$KD?$KB?$AA@ DB 0e2H
	DB	0a5H, 0d3H, 0f0H, '%s', 0e1H, 0eaH, '?', 0eeH, 0dcH, '?', 0daH
	DB	0aaH, '?', 0cbH, 0ecH, 0a3H, 0a1H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03ILJCGOLJ@?6?$CFs?$AA@
CONST	SEGMENT
??_C@_03ILJCGOLJ@?6?$CFs?$AA@ DB 0aH, '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HMDCACKA@?$CFX?$HM?$CFX?$AA@
CONST	SEGMENT
??_C@_05HMDCACKA@?$CFX?$HM?$CFX?$AA@ DB '%X|%X', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EOJECCGN@?$CFX?$HM?$CFX?$HM?$CFX?$AA@
CONST	SEGMENT
??_C@_08EOJECCGN@?$CFX?$HM?$CFX?$HM?$CFX?$AA@ DB '%X|%X|%X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NFKFNKL@?$NM?z?$DP?J?$KL?p?i?n?$KE?v?R?t?$LI?q?$PN?$PN?$KI?$DP?a?$LM?c?w?$DP?$KD?$KB?$AA@
CONST	SEGMENT
??_C@_0BK@NFKFNKL@?$NM?z?$DP?J?$KL?p?i?n?$KE?v?R?t?$LI?q?$PN?$PN?$KI?$DP?a?$LM?c?w?$DP?$KD?$KB?$AA@ DB 0dcH
	DB	0faH, '?', 0caH, 0abH, 0f0H, 0e9H, 0eeH, 0a4H, 0f6H, 0d2H, 0f4H
	DB	0b8H, 0f1H, 0fdH, 0fdH, 0a8H, '?', 0e1H, 0bcH, 0e3H, 0f7H, '?', 0a3H
	DB	0a1H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ILDAKNL@?l?Q?Z?$KK?$NO?$PL?p?$LG?$DP?$DP?l?$KL?S?p?$KB?$KD?$AA@
CONST	SEGMENT
??_C@_0BB@ILDAKNL@?l?Q?Z?$KK?$NO?$PL?p?$LG?$DP?$DP?l?$KL?S?p?$KB?$KD?$AA@ DB 0ecH
	DB	0d1H, 0daH, 0aaH, 0deH, 0fbH, 0f0H, 0b6H, '??', 0ecH, 0abH, 0d3H
	DB	0f0H, 0a1H, 0a3H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JFAECEMN@?l?Q?Z?$KK?p?$KE?m?B?$DP?$DP?l?$KL?S?p?$KB?$KD?$AA@
CONST	SEGMENT
??_C@_0BB@JFAECEMN@?l?Q?Z?$KK?p?$KE?m?B?$DP?$DP?l?$KL?S?p?$KB?$KD?$AA@ DB 0ecH
	DB	0d1H, 0daH, 0aaH, 0f0H, 0a4H, 0edH, 0c2H, '??', 0ecH, 0abH, 0d3H
	DB	0f0H, 0a1H, 0a3H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DFPJGLLL@?$OA?w?X?$KB?V?$PN?t?$LI?c?x?$DP?p?$LG?$KD?$LC?$KD?$LA?$KD?$LA?$OA?$LE?$DP?$AA@
CONST	SEGMENT
??_C@_0BH@DFPJGLLL@?$OA?w?X?$KB?V?$PN?t?$LI?c?x?$DP?p?$LG?$KD?$LC?$KD?$LA?$KD?$LA?$OA?$LE?$DP?$AA@ DB 0e0H
	DB	0f7H, 0d8H, 0a1H, 0d6H, 0fdH, 0f4H, 0b8H, 0e3H, 0f8H, '?', 0f0H
	DB	0b6H, 0a3H, 0b2H, 0a3H, 0b0H, 0a3H, 0b0H, 0e0H, 0b4H, '?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02OGAFBLMB@TE?$AA@
CONST	SEGMENT
??_C@_02OGAFBLMB@TE?$AA@ DB 'TE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIIGDGEP@TK?$AA@
CONST	SEGMENT
??_C@_02HIIGDGEP@TK?$AA@ DB 'TK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08NGKGAKGM@P?$HM?1XQ?5?$CFs?$AA@
CONST	SEGMENT
??_C@_08NGKGAKGM@P?$HM?1XQ?5?$CFs?$AA@ DB 'P|/XQ %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08IPPAKAEL@P?$HM?1WD?5?$CFs?$AA@
CONST	SEGMENT
??_C@_08IPPAKAEL@P?$HM?1WD?5?$CFs?$AA@ DB 'P|/WD %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KCFIPDCG@T?$HM?$CFs?$KD?$LK?$CFs?$AA@
CONST	SEGMENT
??_C@_08KCFIPDCG@T?$HM?$CFs?$KD?$LK?$CFs?$AA@ DB 'T|%s', 0a3H, 0baH, '%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@INHGBDFL@P?$HM?1OCC?$CFs?$KD?$LK?$CFs?$AA@
CONST	SEGMENT
??_C@_0N@INHGBDFL@P?$HM?1OCC?$CFs?$KD?$LK?$CFs?$AA@ DB 'P|/OCC%s', 0a3H, 0baH
	DB	'%s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07JGJAFNNL@P?$HM?1FM?$CFs?$AA@
CONST	SEGMENT
??_C@_07JGJAFNNL@P?$HM?1FM?$CFs?$AA@ DB 'P|/FM%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BFDNBDBG@P?$HM?1tell?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0L@BFDNBDBG@P?$HM?1tell?5?$CFs?$AA@ DB 'P|/tell %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03IKGEINEE@?$CFs?5?$AA@
CONST	SEGMENT
??_C@_03IKGEINEE@?$CFs?5?$AA@ DB '%s ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BFJFDKGC@?r?$KG?V?$LF?$NO?E?i?D?L?$KL?c?R?$NM?t?o?a?$DP?$KD?$KB?$AA@
CONST	SEGMENT
??_C@_0BE@BFJFDKGC@?r?$KG?V?$LF?$NO?E?i?D?L?$KL?c?R?$NM?t?o?a?$DP?$KD?$KB?$AA@ DB 0f2H
	DB	0a6H, 0d6H, 0b5H, 0deH, 0c5H, 0e9H, 0c4H, 0ccH, 0abH, 0e3H, 0d2H
	DB	0dcH, 0f4H, 0efH, 0e1H, '?', 0a3H, 0a1H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04BKLDHGDD@P?$HM?$CFs?$AA@
CONST	SEGMENT
??_C@_04BKLDHGDD@P?$HM?$CFs?$AA@ DB 'P|%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PFECBJKL@?$CFd?5Stone?$AA@
CONST	SEGMENT
??_C@_08PFECBJKL@?$CFd?5Stone?$AA@ DB '%d Stone', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HKHEIDPM@?$DP?$DP?$DP?5memo?5?$DP?$DP?$DP?$AA@
CONST	SEGMENT
??_C@_0N@HKHEIDPM@?$DP?$DP?$DP?5memo?5?$DP?$DP?$DP?$AA@ DB '??? memo ???', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GGCIJCKF@?$DP?$DP?$DP?5name?5?$DP?$DP?$DP?$AA@
CONST	SEGMENT
??_C@_0N@GGCIJCKF@?$DP?$DP?$DP?5name?5?$DP?$DP?$DP?$AA@ DB '??? name ???', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03BBKEAIF@?$DP?$DP?$DP?$AA@
CONST	SEGMENT
??_C@_03BBKEAIF@?$DP?$DP?$DP?$AA@ DB '???', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OMPDAMON@data?$FL1?$FN?3?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0M@OMPDAMON@data?$FL1?$FN?3?$CFs?6?$AA@ DB 'data[1]:%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01NBENCBCI@?$CK?$AA@
CONST	SEGMENT
??_C@_01NBENCBCI@?$CK?$AA@ DB '*', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KHEOLEJA@?T?t?u?s?$DP?W?b?$DP?$DP?l?$KL?S?p?$KB?$KD?$AA@
CONST	SEGMENT
??_C@_0BA@KHEOLEJA@?T?t?u?s?$DP?W?b?$DP?$DP?l?$KL?S?p?$KB?$KD?$AA@ DB 0d4H
	DB	0f4H, 0f5H, 0f3H, '?', 0d7H, 0e2H, '??', 0ecH, 0abH, 0d3H, 0f0H
	DB	0a1H, 0a3H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFEMHLAM@?T?t?l?$PN?$DP?W?b?$DP?$DP?l?$KL?S?p?$KB?$KD?$AA@
CONST	SEGMENT
??_C@_0BA@JFEMHLAM@?T?t?l?$PN?$DP?W?b?$DP?$DP?l?$KL?S?p?$KB?$KD?$AA@ DB 0d4H
	DB	0f4H, 0ecH, 0fdH, '?', 0d7H, 0e2H, '??', 0ecH, 0abH, 0d3H, 0f0H
	DB	0a1H, 0a3H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03NOBDJFIO@301?$AA@
CONST	SEGMENT
??_C@_03NOBDJFIO@301?$AA@ DB '301', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ENFKOFGC@CHANGE_GALAXY?$AA@
CONST	SEGMENT
??_C@_0O@ENFKOFGC@CHANGE_GALAXY?$AA@ DB 'CHANGE_GALAXY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OGLBPKPL@OUTOFSERVICE?$AA@
CONST	SEGMENT
??_C@_0N@OGLBPKPL@OUTOFSERVICE?$AA@ DB 'OUTOFSERVICE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LHCHIOPJ@successful?$AA@
CONST	SEGMENT
??_C@_0L@LHCHIOPJ@successful?$AA@ DB 'successful', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06ODACHPEO@failed?$AA@
CONST	SEGMENT
??_C@_06ODACHPEO@failed?$AA@ DB 'failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OCCGLCLB@?$DP?v?$KC?l?Q?Z?$KK?x?z?$DP?$DP?l?$KL?S?p?$KB?$KD?$AA@
CONST	SEGMENT
??_C@_0BC@OCCGLCLB@?$DP?v?$KC?l?Q?Z?$KK?x?z?$DP?$DP?l?$KL?S?p?$KB?$KD?$AA@ DB '?'
	DB	0f6H, 0a2H, 0ecH, 0d1H, 0daH, 0aaH, 0f8H, 0faH, '??', 0ecH, 0abH
	DB	0d3H, 0f0H, 0a1H, 0a3H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06ENLDJGGB@cancle?$AA@
CONST	SEGMENT
??_C@_06ENLDJGGB@cancle?$AA@ DB 'cancle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02MFDMBIJM@ok?$AA@
CONST	SEGMENT
??_C@_02MFDMBIJM@ok?$AA@ DB 'ok', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08DDDJOECK@19761101?$AA@
CONST	SEGMENT
??_C@_08DDDJOECK@19761101?$AA@ DB '19761101', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BACHGGGK@f?$DLencor1c?$AA@
CONST	SEGMENT
??_C@_09BACHGGGK@f?$DLencor1c?$AA@ DB 'f;encor1c', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DAOAAINN@login?$AA@
CONST	SEGMENT
??_C@_05DAOAAINN@login?$AA@ DB 'login', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NDJIOBBC@?$OA?$LE?P?o?$DP?S?$NL?w?z?$NM?b?$NM?t?T?R?$AA@
CONST	SEGMENT
??_C@_0BA@NDJIOBBC@?$OA?$LE?P?o?$DP?S?$NL?w?z?$NM?b?$NM?t?T?R?$AA@ DB 0e0H
	DB	0b4H, 0d0H, 0efH, '?', 0d3H, 0dbH, 0f7H, 0faH, 0dcH, 0e2H, 0dcH
	DB	0f4H, 0d4H, 0d2H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KFDLBKA@?$NO?C?$NM?W?P?o?Y?$KD?$DP?$NM?t?o?a?$DP?$KB?$KD?$AA@
CONST	SEGMENT
??_C@_0BB@KFDLBKA@?$NO?C?$NM?W?P?o?Y?$KD?$DP?$NM?t?o?a?$DP?$KB?$KD?$AA@ DB 0deH
	DB	0c3H, 0dcH, 0d7H, 0d0H, 0efH, 0d9H, 0a3H, '?', 0dcH, 0f4H, 0efH
	DB	0e1H, '?', 0a1H, 0a3H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LCBBLLOI@www?493sa?4com?$AA@
CONST	SEGMENT
??_C@_0N@LCBBLLOI@www?493sa?4com?$AA@ DB 'www.93sa.com', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PMNBOGBM@?$NO?C?$NM?W?P?o?$DP?o?H?$DP?$DP?l?$KL?S?p?$KB?$KD?$AA@
CONST	SEGMENT
??_C@_0BC@PMNBOGBM@?$NO?C?$NM?W?P?o?$DP?o?H?$DP?$DP?l?$KL?S?p?$KB?$KD?$AA@ DB 0deH
	DB	0c3H, 0dcH, 0d7H, 0d0H, 0efH, '?', 0efH, 0c8H, '??', 0ecH, 0abH
	DB	0d3H, 0f0H, 0a1H, 0a3H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02ODPEBLOD@CS?$AA@
CONST	SEGMENT
??_C@_02ODPEBLOD@CS?$AA@ DB 'CS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KEAEOGKH@?$LN?$LK?E?f?$LP?$KB?$MA?L?A?v?5?G?O?$LE?C?$MA?$LK?5?G?v?$MA?g?5?A?$KB?$LA?K?5?A?$NP?$MA?T@
CONST	SEGMENT
??_C@_0CG@KEAEOGKH@?$LN?$LK?E?f?$LP?$KB?$MA?L?A?v?5?G?O?$LE?C?$MA?$LK?5?G?v?$MA?g?5?A?$KB?$LA?K?5?A?$NP?$MA?T@ DB 0bdH
	DB	0baH, 0c5H, 0e6H, 0bfH, 0a1H, 0c0H, 0ccH, 0c1H, 0f6H, ' ', 0c7H
	DB	0cfH, 0b4H, 0c3H, 0c0H, 0baH, ' ', 0c7H, 0f6H, 0c0H, 0e7H, ' ', 0c1H
	DB	0a1H, 0b0H, 0cbH, ' ', 0c1H, 0dfH, 0c0H, 0d4H, 0b4H, 0cfH, 0b4H
	DB	0d9H, '.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KDOBPHMN@?$DP?V?X?$DP?Z?$LB?q?W?$DP?$PL?$LP?$KB?$KD?$AA@
CONST	SEGMENT
??_C@_0O@KDOBPHMN@?$DP?V?X?$DP?Z?$LB?q?W?$DP?$PL?$LP?$KB?$KD?$AA@ DB '?', 0d6H
	DB	0d8H, '?', 0daH, 0b1H, 0f1H, 0d7H, '?', 0fbH, 0bfH, 0a1H, 0a3H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CKHMFIAG@?Y?i?$NL?v?$DP?c?$LH?$DP?z?$LM?$NO?C?$NM?W?P?o?n?$NM?$DP?o?H?$KB?$KD?$AA@
CONST	SEGMENT
??_C@_0BI@CKHMFIAG@?Y?i?$NL?v?$DP?c?$LH?$DP?z?$LM?$NO?C?$NM?W?P?o?n?$NM?$DP?o?H?$KB?$KD?$AA@ DB 0d9H
	DB	0e9H, 0dbH, 0f6H, '?', 0e3H, 0b7H, '?', 0faH, 0bcH, 0deH, 0c3H
	DB	0dcH, 0d7H, 0d0H, 0efH, 0eeH, 0dcH, '?', 0efH, 0c8H, 0a1H, 0a3H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BHPEJLIB@?Y?i?$NL?v?$DP?T?p?$NO?C?$NM?W?P?o?n?$NM?$KD?I?$KD?P?j?H?v?G?$KB?$KD?$CI?$CFs?$CJ?$AA@
CONST	SEGMENT
??_C@_0BO@BHPEJLIB@?Y?i?$NL?v?$DP?T?p?$NO?C?$NM?W?P?o?n?$NM?$KD?I?$KD?P?j?H?v?G?$KB?$KD?$CI?$CFs?$CJ?$AA@ DB 0d9H
	DB	0e9H, 0dbH, 0f6H, '?', 0d4H, 0f0H, 0deH, 0c3H, 0dcH, 0d7H, 0d0H
	DB	0efH, 0eeH, 0dcH, 0a3H, 0c9H, 0a3H, 0d0H, 0eaH, 0c8H, 0f6H, 0c7H
	DB	0a1H, 0a3H, '(%s)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GMCCICCK@WGS?$AA@
CONST	SEGMENT
??_C@_03GMCCICCK@WGS?$AA@ DB 'WGS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JAKPHLLB@?Y?i?$NL?v?$DP?z?$LMsocket?n?$NMTCP?$KB?$KD?$AA@
CONST	SEGMENT
??_C@_0BF@JAKPHLLB@?Y?i?$NL?v?$DP?z?$LMsocket?n?$NMTCP?$KB?$KD?$AA@ DB 0d9H
	DB	0e9H, 0dbH, 0f6H, '?', 0faH, 0bcH, 'socket', 0eeH, 0dcH, 'TCP', 0a1H
	DB	0a3H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@INAHAGEI@?b?$KF?S?p?$KD?$LK?7?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0L@INAHAGEI@?b?$KF?S?p?$KD?$LK?7?$CFs?6?$AA@ DB 0e2H, 0a5H, 0d3H, 0f0H
	DB	0a3H, 0baH, 09H, '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPNLHKJD@a?$CL?$AA@
CONST	SEGMENT
??_C@_02DPNLHKJD@a?$CL?$AA@ DB 'a+', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OFOPBFLC@recvdata?4txt?$AA@
CONST	SEGMENT
??_C@_0N@OFOPBFLC@recvdata?4txt?$AA@ DB 'recvdata.txt', 00H ; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?checksum@@YAGPAGH@Z
_TEXT	SEGMENT
_cksum$ = -8						; size = 4
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
?checksum@@YAGPAGH@Z PROC				; checksum, COMDAT

; 4310 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 4311 : 	unsigned long cksum=0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cksum$[ebp], 0
$LN2@checksum:

; 4312 : 	while( size > 1){

  00025	83 7d 0c 01	 cmp	 DWORD PTR _size$[ebp], 1
  00029	7e 20		 jle	 SHORT $LN3@checksum

; 4313 : 		cksum += *buffer++;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  0002e	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00031	03 4d f8	 add	 ecx, DWORD PTR _cksum$[ebp]
  00034	89 4d f8	 mov	 DWORD PTR _cksum$[ebp], ecx
  00037	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  0003a	83 c2 02	 add	 edx, 2
  0003d	89 55 08	 mov	 DWORD PTR _buffer$[ebp], edx

; 4314 : 		size -=sizeof(USHORT);

  00040	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00043	83 e8 02	 sub	 eax, 2
  00046	89 45 0c	 mov	 DWORD PTR _size$[ebp], eax

; 4315 : 	}

  00049	eb da		 jmp	 SHORT $LN2@checksum
$LN3@checksum:

; 4316 : 	if ( size)

  0004b	83 7d 0c 00	 cmp	 DWORD PTR _size$[ebp], 0
  0004f	74 0c		 je	 SHORT $LN4@checksum

; 4317 : 		cksum += *(UCHAR*)buffer;

  00051	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00054	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00057	03 4d f8	 add	 ecx, DWORD PTR _cksum$[ebp]
  0005a	89 4d f8	 mov	 DWORD PTR _cksum$[ebp], ecx
$LN4@checksum:

; 4318 : 	cksum = (cksum >> 16) + (cksum & 0xffff);

  0005d	8b 45 f8	 mov	 eax, DWORD PTR _cksum$[ebp]
  00060	c1 e8 10	 shr	 eax, 16			; 00000010H
  00063	8b 4d f8	 mov	 ecx, DWORD PTR _cksum$[ebp]
  00066	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0006c	03 c1		 add	 eax, ecx
  0006e	89 45 f8	 mov	 DWORD PTR _cksum$[ebp], eax

; 4319 : 	cksum += (cksum >>16);

  00071	8b 45 f8	 mov	 eax, DWORD PTR _cksum$[ebp]
  00074	c1 e8 10	 shr	 eax, 16			; 00000010H
  00077	03 45 f8	 add	 eax, DWORD PTR _cksum$[ebp]
  0007a	89 45 f8	 mov	 DWORD PTR _cksum$[ebp], eax

; 4320 : 	return (USHORT)(~cksum);

  0007d	8b 45 f8	 mov	 eax, DWORD PTR _cksum$[ebp]
  00080	f7 d0		 not	 eax

; 4321 : }

  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?checksum@@YAGPAGH@Z ENDP				; checksum
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_ACI_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_ACI_recv@@YAXHPAD@Z PROC			; lssproto_ACI_recv, COMDAT

; 4174 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 4175 : 
; 4176 : }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?lssproto_ACI_recv@@YAXHPAD@Z ENDP			; lssproto_ACI_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_IS_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_cdata$ = 12						; size = 4
?lssproto_IS_recv@@YAXHPAD@Z PROC			; lssproto_IS_recv, COMDAT

; 3775 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3776 : }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?lssproto_IS_recv@@YAXHPAD@Z ENDP			; lssproto_IS_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_W_recv@@YAXHHHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_id$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
?lssproto_W_recv@@YAXHHHH@Z PROC			; lssproto_W_recv, COMDAT

; 2578 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2579 : 	// ??????Re???????????
; 2580 : 	// ??????????????????????
; 2581 : }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?lssproto_W_recv@@YAXHHHH@Z ENDP			; lssproto_W_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?PingFunc@@YGKPAX@Z
_TEXT	SEGMENT
_iphdrlen$1 = -2196					; size = 2
_iphdr$2 = -2184					; size = 4
_seq_no$ = -2172					; size = 2
_recvbuf$ = -2160					; size = 1024
_icmp_data$ = -1128					; size = 1024
_icmp_hdr$ = -96					; size = 4
_timeout$ = -84						; size = 4
_fromlen$ = -72						; size = 4
_datasize$ = -60					; size = 4
_dest$ = -48						; size = 16
_from$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
_param$ = 8						; size = 4
?PingFunc@@YGKPAX@Z PROC				; PingFunc, COMDAT

; 4326 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 58 0c 00
	00		 sub	 esp, 3160		; 00000c58H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd a8 f3 ff
	ff		 lea	 edi, DWORD PTR [ebp-3160]
  00012	b9 16 03 00 00	 mov	 ecx, 790		; 00000316H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4327 : 	struct sockaddr_in from;
; 4328 : 	struct sockaddr_in dest;
; 4329 : 	int datasize;
; 4330 : 	int fromlen = sizeof(from);

  00028	c7 45 b8 10 00
	00 00		 mov	 DWORD PTR _fromlen$[ebp], 16 ; 00000010H

; 4331 : 	int timeout = 1000;

  0002f	c7 45 ac e8 03
	00 00		 mov	 DWORD PTR _timeout$[ebp], 1000 ; 000003e8H

; 4332 : 	IcmpHeader *icmp_hdr;
; 4333 : 
; 4334 : 	char icmp_data[MAX_PACKET];
; 4335 : 	char recvbuf[MAX_PACKET];
; 4336 : 	USHORT seq_no = 0;

  00036	33 c0		 xor	 eax, eax
  00038	66 89 85 84 f7
	ff ff		 mov	 WORD PTR _seq_no$[ebp], ax

; 4337 : 
; 4338 : 	ZeroMemory( &dest, sizeof(dest));

  0003f	6a 10		 push	 16			; 00000010H
  00041	6a 00		 push	 0
  00043	8d 45 d0	 lea	 eax, DWORD PTR _dest$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _memset
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4339 : 	memcpy( &(dest.sin_addr), (void*)param, 4);

  0004f	6a 04		 push	 4
  00051	8b 45 08	 mov	 eax, DWORD PTR _param$[ebp]
  00054	50		 push	 eax
  00055	8d 4d d4	 lea	 ecx, DWORD PTR _dest$[ebp+4]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 _memcpy
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4340 : 	dest.sin_family = AF_INET;

  00061	b8 02 00 00 00	 mov	 eax, 2
  00066	66 89 45 d0	 mov	 WORD PTR _dest$[ebp], ax

; 4341 : 	if ( sockRaw != INVALID_SOCKET){

  0006a	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?sockRaw@@3IA, -1 ; sockRaw
  00071	74 15		 je	 SHORT $LN6@PingFunc

; 4342 : 		closesocket( sockRaw);

  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockRaw@@3IA ; sockRaw
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 _closesocket@4

; 4343 : 		sockRaw = INVALID_SOCKET;

  0007e	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?sockRaw@@3IA, -1 ; sockRaw
$LN6@PingFunc:

; 4344 : 	}
; 4345 : 	sockRaw = socket( AF_INET, SOCK_RAW, IPPROTO_ICMP);

  00088	6a 01		 push	 1
  0008a	6a 03		 push	 3
  0008c	6a 02		 push	 2
  0008e	e8 00 00 00 00	 call	 _socket@12
  00093	a3 00 00 00 00	 mov	 DWORD PTR ?sockRaw@@3IA, eax ; sockRaw

; 4346 : 	if ( sockRaw != INVALID_SOCKET){

  00098	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?sockRaw@@3IA, -1 ; sockRaw
  0009f	0f 84 ea 02 00
	00		 je	 $LN7@PingFunc

; 4347 : 		iRead = setsockopt( sockRaw, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout, sizeof(timeout));

  000a5	6a 04		 push	 4
  000a7	8d 45 ac	 lea	 eax, DWORD PTR _timeout$[ebp]
  000aa	50		 push	 eax
  000ab	68 06 10 00 00	 push	 4102			; 00001006H
  000b0	68 ff ff 00 00	 push	 65535			; 0000ffffH
  000b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockRaw@@3IA ; sockRaw
  000bb	51		 push	 ecx
  000bc	e8 00 00 00 00	 call	 _setsockopt@20
  000c1	a3 00 00 00 00	 mov	 DWORD PTR ?iRead@@3HA, eax ; iRead

; 4348 : 		if ( iRead != SOCKET_ERROR){

  000c6	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?iRead@@3HA, -1 ; iRead
  000cd	0f 84 bc 02 00
	00		 je	 $LN7@PingFunc

; 4349 : 			timeout = 1000;

  000d3	c7 45 ac e8 03
	00 00		 mov	 DWORD PTR _timeout$[ebp], 1000 ; 000003e8H

; 4350 : 			iRead = setsockopt( sockRaw, SOL_SOCKET, SO_SNDTIMEO, (char*)&timeout, sizeof(timeout));

  000da	6a 04		 push	 4
  000dc	8d 45 ac	 lea	 eax, DWORD PTR _timeout$[ebp]
  000df	50		 push	 eax
  000e0	68 05 10 00 00	 push	 4101			; 00001005H
  000e5	68 ff ff 00 00	 push	 65535			; 0000ffffH
  000ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockRaw@@3IA ; sockRaw
  000f0	51		 push	 ecx
  000f1	e8 00 00 00 00	 call	 _setsockopt@20
  000f6	a3 00 00 00 00	 mov	 DWORD PTR ?iRead@@3HA, eax ; iRead

; 4351 : 			if ( iRead != SOCKET_ERROR){

  000fb	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?iRead@@3HA, -1 ; iRead
  00102	0f 84 87 02 00
	00		 je	 $LN7@PingFunc

; 4352 : 				datasize = DEF_PACKET_SIZE + sizeof(IcmpHeader);  

  00108	c7 45 c4 2c 00
	00 00		 mov	 DWORD PTR _datasize$[ebp], 44 ; 0000002cH

; 4353 : 
; 4354 : 				icmp_hdr = (IcmpHeader*)icmp_data;

  0010f	8d 85 98 fb ff
	ff		 lea	 eax, DWORD PTR _icmp_data$[ebp]
  00115	89 45 a0	 mov	 DWORD PTR _icmp_hdr$[ebp], eax

; 4355 : 				icmp_hdr->i_type = ICMP_ECHO;

  00118	8b 45 a0	 mov	 eax, DWORD PTR _icmp_hdr$[ebp]
  0011b	c6 00 08	 mov	 BYTE PTR [eax], 8

; 4356 : 				icmp_hdr->i_code = 0;

  0011e	8b 45 a0	 mov	 eax, DWORD PTR _icmp_hdr$[ebp]
  00121	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 4357 : 				icmp_hdr->i_id = (USHORT)GetCurrentProcessId();

  00125	8b f4		 mov	 esi, esp
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0
  0012d	3b f4		 cmp	 esi, esp
  0012f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00134	8b 4d a0	 mov	 ecx, DWORD PTR _icmp_hdr$[ebp]
  00137	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 4358 : 				icmp_hdr->i_cksum = 0;

  0013b	33 c0		 xor	 eax, eax
  0013d	8b 4d a0	 mov	 ecx, DWORD PTR _icmp_hdr$[ebp]
  00140	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 4359 : 				icmp_hdr->i_seq = 0;

  00144	33 c0		 xor	 eax, eax
  00146	8b 4d a0	 mov	 ecx, DWORD PTR _icmp_hdr$[ebp]
  00149	66 89 41 06	 mov	 WORD PTR [ecx+6], ax

; 4360 : 				memset( icmp_data+sizeof(IcmpHeader), 'E', datasize - sizeof(IcmpHeader));

  0014d	8b 45 c4	 mov	 eax, DWORD PTR _datasize$[ebp]
  00150	83 e8 0c	 sub	 eax, 12			; 0000000cH
  00153	50		 push	 eax
  00154	6a 45		 push	 69			; 00000045H
  00156	8d 8d a4 fb ff
	ff		 lea	 ecx, DWORD PTR _icmp_data$[ebp+12]
  0015c	51		 push	 ecx
  0015d	e8 00 00 00 00	 call	 _memset
  00162	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@PingFunc:

; 4361 : 				while( 1){

  00165	b8 01 00 00 00	 mov	 eax, 1
  0016a	85 c0		 test	 eax, eax
  0016c	0f 84 1d 02 00
	00		 je	 $LN7@PingFunc

; 4362 : 			//		dwPingState = 0;
; 4363 : 					((IcmpHeader*)icmp_data)->i_cksum = 0;

  00172	33 c0		 xor	 eax, eax
  00174	66 89 85 9a fb
	ff ff		 mov	 WORD PTR _icmp_data$[ebp+2], ax

; 4364 : 					((IcmpHeader*)icmp_data)->timestamp = GetTickCount();

  0017b	8b f4		 mov	 esi, esp
  0017d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00183	3b f4		 cmp	 esi, esp
  00185	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0018a	89 85 a0 fb ff
	ff		 mov	 DWORD PTR _icmp_data$[ebp+8], eax

; 4365 : 					
; 4366 : 					((IcmpHeader*)icmp_data)->i_seq = seq_no;

  00190	66 8b 85 84 f7
	ff ff		 mov	 ax, WORD PTR _seq_no$[ebp]
  00197	66 89 85 9e fb
	ff ff		 mov	 WORD PTR _icmp_data$[ebp+6], ax

; 4367 : 					((IcmpHeader*)icmp_data)->i_cksum = checksum( (USHORT*)icmp_data, datasize);

  0019e	8b 45 c4	 mov	 eax, DWORD PTR _datasize$[ebp]
  001a1	50		 push	 eax
  001a2	8d 8d 98 fb ff
	ff		 lea	 ecx, DWORD PTR _icmp_data$[ebp]
  001a8	51		 push	 ecx
  001a9	e8 00 00 00 00	 call	 ?checksum@@YAGPAGH@Z	; checksum
  001ae	83 c4 08	 add	 esp, 8
  001b1	66 89 85 9a fb
	ff ff		 mov	 WORD PTR _icmp_data$[ebp+2], ax

; 4368 : 					
; 4369 : 					iWrote = sendto( sockRaw, icmp_data, datasize, 0, (struct sockaddr*)&dest, sizeof(struct sockaddr));

  001b8	6a 10		 push	 16			; 00000010H
  001ba	8d 45 d0	 lea	 eax, DWORD PTR _dest$[ebp]
  001bd	50		 push	 eax
  001be	6a 00		 push	 0
  001c0	8b 4d c4	 mov	 ecx, DWORD PTR _datasize$[ebp]
  001c3	51		 push	 ecx
  001c4	8d 95 98 fb ff
	ff		 lea	 edx, DWORD PTR _icmp_data$[ebp]
  001ca	52		 push	 edx
  001cb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockRaw@@3IA ; sockRaw
  001d0	50		 push	 eax
  001d1	e8 00 00 00 00	 call	 _sendto@24
  001d6	a3 00 00 00 00	 mov	 DWORD PTR ?iWrote@@3HA, eax ; iWrote

; 4370 : 					if ( iWrote == SOCKET_ERROR){

  001db	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?iWrote@@3HA, -1 ; iWrote
  001e2	75 2f		 jne	 SHORT $LN10@PingFunc

; 4371 : 						if ( WSAGetLastError() == WSAETIMEDOUT){

  001e4	e8 00 00 00 00	 call	 _WSAGetLastError@0
  001e9	3d 4c 27 00 00	 cmp	 eax, 10060		; 0000274cH
  001ee	75 0f		 jne	 SHORT $LN11@PingFunc

; 4372 : 							dwPingTime = -1;

  001f0	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?dwPingTime@@3KA, -1 ; dwPingTime

; 4373 : 							continue;

  001fa	e9 66 ff ff ff	 jmp	 $LN2@PingFunc
$LN11@PingFunc:

; 4374 : 						}
; 4375 : 						dwPingState = 0x40000000 | WSAGetLastError();

  001ff	e8 00 00 00 00	 call	 _WSAGetLastError@0
  00204	0d 00 00 00 40	 or	 eax, 1073741824		; 40000000H
  00209	a3 00 00 00 00	 mov	 DWORD PTR ?dwPingState@@3KA, eax ; dwPingState

; 4376 : 						continue;

  0020e	e9 52 ff ff ff	 jmp	 $LN2@PingFunc
$LN10@PingFunc:

; 4377 : 					}
; 4378 : 					if ( iWrote < datasize)

  00213	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iWrote@@3HA ; iWrote
  00218	3b 45 c4	 cmp	 eax, DWORD PTR _datasize$[ebp]
  0021b	7d 0a		 jge	 SHORT $LN4@PingFunc

; 4379 : 						dwPingState = 0x04000000;//len error

  0021d	c7 05 00 00 00
	00 00 00 00 04	 mov	 DWORD PTR ?dwPingState@@3KA, 67108864 ; dwPingState, 04000000H
$LN4@PingFunc:

; 4380 : 					while( 1){

  00227	b8 01 00 00 00	 mov	 eax, 1
  0022c	85 c0		 test	 eax, eax
  0022e	0f 84 26 01 00
	00		 je	 $LN5@PingFunc

; 4381 : 						iRead = recvfrom( sockRaw, recvbuf, MAX_PACKET, 0, (struct sockaddr*)&from, &fromlen);

  00234	8d 45 b8	 lea	 eax, DWORD PTR _fromlen$[ebp]
  00237	50		 push	 eax
  00238	8d 4d e8	 lea	 ecx, DWORD PTR _from$[ebp]
  0023b	51		 push	 ecx
  0023c	6a 00		 push	 0
  0023e	68 00 04 00 00	 push	 1024			; 00000400H
  00243	8d 95 90 f7 ff
	ff		 lea	 edx, DWORD PTR _recvbuf$[ebp]
  00249	52		 push	 edx
  0024a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockRaw@@3IA ; sockRaw
  0024f	50		 push	 eax
  00250	e8 00 00 00 00	 call	 _recvfrom@24
  00255	a3 00 00 00 00	 mov	 DWORD PTR ?iRead@@3HA, eax ; iRead

; 4382 : 						if ( iRead == SOCKET_ERROR){

  0025a	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?iRead@@3HA, -1 ; iRead
  00261	75 2c		 jne	 SHORT $LN13@PingFunc

; 4383 : 							if ( WSAGetLastError() == WSAETIMEDOUT){

  00263	e8 00 00 00 00	 call	 _WSAGetLastError@0
  00268	3d 4c 27 00 00	 cmp	 eax, 10060		; 0000274cH
  0026d	75 0f		 jne	 SHORT $LN14@PingFunc

; 4384 : 								dwPingTime = -1;

  0026f	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?dwPingTime@@3KA, -1 ; dwPingTime

; 4385 : 								break;

  00279	e9 dc 00 00 00	 jmp	 $LN5@PingFunc
$LN14@PingFunc:

; 4386 : 							}
; 4387 : 							dwPingState = 0x40000000 | WSAGetLastError();

  0027e	e8 00 00 00 00	 call	 _WSAGetLastError@0
  00283	0d 00 00 00 40	 or	 eax, 1073741824		; 40000000H
  00288	a3 00 00 00 00	 mov	 DWORD PTR ?dwPingState@@3KA, eax ; dwPingState

; 4388 : 							continue;

  0028d	eb 98		 jmp	 SHORT $LN4@PingFunc
$LN13@PingFunc:

; 4389 : 						}
; 4390 : 						IpHeader *iphdr;
; 4391 : 						unsigned short iphdrlen;
; 4392 : 						iphdr = (IpHeader *)recvbuf;

  0028f	8d 85 90 f7 ff
	ff		 lea	 eax, DWORD PTR _recvbuf$[ebp]
  00295	89 85 78 f7 ff
	ff		 mov	 DWORD PTR _iphdr$2[ebp], eax

; 4393 : 						iphdrlen = iphdr->h_len * 4 ; // number of 32-bit words *4 = bytes

  0029b	8b 85 78 f7 ff
	ff		 mov	 eax, DWORD PTR _iphdr$2[ebp]
  002a1	8b 08		 mov	 ecx, DWORD PTR [eax]
  002a3	83 e1 0f	 and	 ecx, 15			; 0000000fH
  002a6	c1 e1 02	 shl	 ecx, 2
  002a9	66 89 8d 6c f7
	ff ff		 mov	 WORD PTR _iphdrlen$1[ebp], cx

; 4394 : 						if ( iRead < iphdrlen + ICMP_MIN)

  002b0	0f b7 85 6c f7
	ff ff		 movzx	 eax, WORD PTR _iphdrlen$1[ebp]
  002b7	83 c0 08	 add	 eax, 8
  002ba	39 05 00 00 00
	00		 cmp	 DWORD PTR ?iRead@@3HA, eax ; iRead
  002c0	7d 0a		 jge	 SHORT $LN15@PingFunc

; 4395 : 							dwPingState = 0x08000000;//len error

  002c2	c7 05 00 00 00
	00 00 00 00 08	 mov	 DWORD PTR ?dwPingState@@3KA, 134217728 ; dwPingState, 08000000H
$LN15@PingFunc:

; 4396 : 						icmp_hdr = (IcmpHeader*)(recvbuf + iphdrlen);

  002cc	0f b7 85 6c f7
	ff ff		 movzx	 eax, WORD PTR _iphdrlen$1[ebp]
  002d3	8d 8c 05 90 f7
	ff ff		 lea	 ecx, DWORD PTR _recvbuf$[ebp+eax]
  002da	89 4d a0	 mov	 DWORD PTR _icmp_hdr$[ebp], ecx

; 4397 : 						if ( icmp_hdr->i_type != ICMP_ECHOREPLY){

  002dd	8b 45 a0	 mov	 eax, DWORD PTR _icmp_hdr$[ebp]
  002e0	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  002e3	85 c9		 test	 ecx, ecx
  002e5	74 0f		 je	 SHORT $LN16@PingFunc

; 4398 : 							dwPingState = 0x10000000;//non-echo type recvd

  002e7	c7 05 00 00 00
	00 00 00 00 10	 mov	 DWORD PTR ?dwPingState@@3KA, 268435456 ; dwPingState, 10000000H

; 4399 : 							continue;

  002f1	e9 31 ff ff ff	 jmp	 $LN4@PingFunc
$LN16@PingFunc:

; 4400 : 						}
; 4401 : 						if ( icmp_hdr->i_seq != seq_no)

  002f6	8b 45 a0	 mov	 eax, DWORD PTR _icmp_hdr$[ebp]
  002f9	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  002fd	0f b7 95 84 f7
	ff ff		 movzx	 edx, WORD PTR _seq_no$[ebp]
  00304	3b ca		 cmp	 ecx, edx
  00306	74 05		 je	 SHORT $LN17@PingFunc

; 4402 : 							continue;

  00308	e9 1a ff ff ff	 jmp	 $LN4@PingFunc
$LN17@PingFunc:

; 4403 : 						if ( icmp_hdr->i_id != (USHORT)GetCurrentProcessId()){

  0030d	8b 45 a0	 mov	 eax, DWORD PTR _icmp_hdr$[ebp]
  00310	0f b7 70 04	 movzx	 esi, WORD PTR [eax+4]
  00314	8b fc		 mov	 edi, esp
  00316	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0
  0031c	3b fc		 cmp	 edi, esp
  0031e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00323	0f b7 c8	 movzx	 ecx, ax
  00326	3b f1		 cmp	 esi, ecx
  00328	74 0f		 je	 SHORT $LN18@PingFunc

; 4404 : 							dwPingState = 0x20000000;//someone else's packet!

  0032a	c7 05 00 00 00
	00 00 00 00 20	 mov	 DWORD PTR ?dwPingState@@3KA, 536870912 ; dwPingState, 20000000H

; 4405 : 							continue;

  00334	e9 ee fe ff ff	 jmp	 $LN4@PingFunc
$LN18@PingFunc:

; 4406 : 						}
; 4407 : 						dwPingTime = GetTickCount()-icmp_hdr->timestamp;

  00339	8b f4		 mov	 esi, esp
  0033b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00341	3b f4		 cmp	 esi, esp
  00343	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00348	8b 4d a0	 mov	 ecx, DWORD PTR _icmp_hdr$[ebp]
  0034b	2b 41 08	 sub	 eax, DWORD PTR [ecx+8]
  0034e	a3 00 00 00 00	 mov	 DWORD PTR ?dwPingTime@@3KA, eax ; dwPingTime

; 4408 : 						break;

  00353	eb 05		 jmp	 SHORT $LN5@PingFunc

; 4409 : 					}

  00355	e9 cd fe ff ff	 jmp	 $LN4@PingFunc
$LN5@PingFunc:

; 4410 : 					seq_no++;

  0035a	66 8b 85 84 f7
	ff ff		 mov	 ax, WORD PTR _seq_no$[ebp]
  00361	66 83 c0 01	 add	 ax, 1
  00365	66 89 85 84 f7
	ff ff		 mov	 WORD PTR _seq_no$[ebp], ax

; 4411 : 					dwPingState = 0x80000000;

  0036c	c7 05 00 00 00
	00 00 00 00 80	 mov	 DWORD PTR ?dwPingState@@3KA, -2147483648 ; dwPingState, 80000000H

; 4412 : 					Sleep( 3000);

  00376	8b f4		 mov	 esi, esp
  00378	68 b8 0b 00 00	 push	 3000			; 00000bb8H
  0037d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
  00383	3b f4		 cmp	 esi, esp
  00385	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 4413 : 				}

  0038a	e9 d6 fd ff ff	 jmp	 $LN2@PingFunc
$LN7@PingFunc:

; 4414 : 			}
; 4415 : 		}
; 4416 : 	}
; 4417 : 	return 0;

  0038f	33 c0		 xor	 eax, eax

; 4418 : }

  00391	52		 push	 edx
  00392	8b cd		 mov	 ecx, ebp
  00394	50		 push	 eax
  00395	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN32@PingFunc
  0039b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  003a0	58		 pop	 eax
  003a1	5a		 pop	 edx
  003a2	5f		 pop	 edi
  003a3	5e		 pop	 esi
  003a4	5b		 pop	 ebx
  003a5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003a8	33 cd		 xor	 ecx, ebp
  003aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003af	81 c4 58 0c 00
	00		 add	 esp, 3160		; 00000c58H
  003b5	3b ec		 cmp	 ebp, esp
  003b7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003bc	8b e5		 mov	 esp, ebp
  003be	5d		 pop	 ebp
  003bf	c2 04 00	 ret	 4
  003c2	66 90		 npad	 2
$LN32@PingFunc:
  003c4	06 00 00 00	 DD	 6
  003c8	00 00 00 00	 DD	 $LN31@PingFunc
$LN31@PingFunc:
  003cc	e8 ff ff ff	 DD	 -24			; ffffffe8H
  003d0	10 00 00 00	 DD	 16			; 00000010H
  003d4	00 00 00 00	 DD	 $LN25@PingFunc
  003d8	d0 ff ff ff	 DD	 -48			; ffffffd0H
  003dc	10 00 00 00	 DD	 16			; 00000010H
  003e0	00 00 00 00	 DD	 $LN26@PingFunc
  003e4	b8 ff ff ff	 DD	 -72			; ffffffb8H
  003e8	04 00 00 00	 DD	 4
  003ec	00 00 00 00	 DD	 $LN27@PingFunc
  003f0	ac ff ff ff	 DD	 -84			; ffffffacH
  003f4	04 00 00 00	 DD	 4
  003f8	00 00 00 00	 DD	 $LN28@PingFunc
  003fc	98 fb ff ff	 DD	 -1128			; fffffb98H
  00400	00 04 00 00	 DD	 1024			; 00000400H
  00404	00 00 00 00	 DD	 $LN29@PingFunc
  00408	90 f7 ff ff	 DD	 -2160			; fffff790H
  0040c	00 04 00 00	 DD	 1024			; 00000400H
  00410	00 00 00 00	 DD	 $LN30@PingFunc
$LN30@PingFunc:
  00414	72		 DB	 114			; 00000072H
  00415	65		 DB	 101			; 00000065H
  00416	63		 DB	 99			; 00000063H
  00417	76		 DB	 118			; 00000076H
  00418	62		 DB	 98			; 00000062H
  00419	75		 DB	 117			; 00000075H
  0041a	66		 DB	 102			; 00000066H
  0041b	00		 DB	 0
$LN29@PingFunc:
  0041c	69		 DB	 105			; 00000069H
  0041d	63		 DB	 99			; 00000063H
  0041e	6d		 DB	 109			; 0000006dH
  0041f	70		 DB	 112			; 00000070H
  00420	5f		 DB	 95			; 0000005fH
  00421	64		 DB	 100			; 00000064H
  00422	61		 DB	 97			; 00000061H
  00423	74		 DB	 116			; 00000074H
  00424	61		 DB	 97			; 00000061H
  00425	00		 DB	 0
$LN28@PingFunc:
  00426	74		 DB	 116			; 00000074H
  00427	69		 DB	 105			; 00000069H
  00428	6d		 DB	 109			; 0000006dH
  00429	65		 DB	 101			; 00000065H
  0042a	6f		 DB	 111			; 0000006fH
  0042b	75		 DB	 117			; 00000075H
  0042c	74		 DB	 116			; 00000074H
  0042d	00		 DB	 0
$LN27@PingFunc:
  0042e	66		 DB	 102			; 00000066H
  0042f	72		 DB	 114			; 00000072H
  00430	6f		 DB	 111			; 0000006fH
  00431	6d		 DB	 109			; 0000006dH
  00432	6c		 DB	 108			; 0000006cH
  00433	65		 DB	 101			; 00000065H
  00434	6e		 DB	 110			; 0000006eH
  00435	00		 DB	 0
$LN26@PingFunc:
  00436	64		 DB	 100			; 00000064H
  00437	65		 DB	 101			; 00000065H
  00438	73		 DB	 115			; 00000073H
  00439	74		 DB	 116			; 00000074H
  0043a	00		 DB	 0
$LN25@PingFunc:
  0043b	66		 DB	 102			; 00000066H
  0043c	72		 DB	 114			; 00000072H
  0043d	6f		 DB	 111			; 0000006fH
  0043e	6d		 DB	 109			; 0000006dH
  0043f	00		 DB	 0
?PingFunc@@YGKPAX@Z ENDP				; PingFunc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?LogToRecvdata2@@YAXPAD@Z
_TEXT	SEGMENT
_rfp$1 = -276						; size = 4
_lssproto_readlogfilename$ = -264			; size = 256
__$ArrayPad$ = -4					; size = 4
_data$ = 8						; size = 4
?LogToRecvdata2@@YAXPAD@Z PROC				; LogToRecvdata2, COMDAT

; 156  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 01 00
	00		 sub	 esp, 472		; 000001d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-472]
  00012	b9 76 00 00 00	 mov	 ecx, 118		; 00000076H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 157  : 	//printf("收到：\t%s\n", data);
; 158  : 	char lssproto_readlogfilename[256] = "recvdata.txt";

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_0N@OFOPBFLC@recvdata?4txt?$AA@
  0002d	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _lssproto_readlogfilename$[ebp], eax
  00033	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0N@OFOPBFLC@recvdata?4txt?$AA@+4
  00039	89 8d fc fe ff
	ff		 mov	 DWORD PTR _lssproto_readlogfilename$[ebp+4], ecx
  0003f	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ??_C@_0N@OFOPBFLC@recvdata?4txt?$AA@+8
  00045	89 95 00 ff ff
	ff		 mov	 DWORD PTR _lssproto_readlogfilename$[ebp+8], edx
  0004b	a0 0c 00 00 00	 mov	 al, BYTE PTR ??_C@_0N@OFOPBFLC@recvdata?4txt?$AA@+12
  00050	88 85 04 ff ff
	ff		 mov	 BYTE PTR _lssproto_readlogfilename$[ebp+12], al
  00056	68 f3 00 00 00	 push	 243			; 000000f3H
  0005b	6a 00		 push	 0
  0005d	8d 85 05 ff ff
	ff		 lea	 eax, DWORD PTR _lssproto_readlogfilename$[ebp+13]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _memset
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 159  : 
; 160  : 	if (lssproto_readlogfilename[0] != '\0')

  0006c	b8 01 00 00 00	 mov	 eax, 1
  00071	6b c8 00	 imul	 ecx, eax, 0
  00074	0f be 94 0d f8
	fe ff ff	 movsx	 edx, BYTE PTR _lssproto_readlogfilename$[ebp+ecx]
  0007c	85 d2		 test	 edx, edx
  0007e	74 5e		 je	 SHORT $LN1@LogToRecvd

; 161  : 	{
; 162  : 		FILE *rfp;
; 163  : 		rfp = fopen(lssproto_readlogfilename, "a+");

  00080	8b f4		 mov	 esi, esp
  00082	68 00 00 00 00	 push	 OFFSET ??_C@_02DPNLHKJD@a?$CL?$AA@
  00087	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _lssproto_readlogfilename$[ebp]
  0008d	50		 push	 eax
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00094	83 c4 08	 add	 esp, 8
  00097	3b f4		 cmp	 esi, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009e	89 85 ec fe ff
	ff		 mov	 DWORD PTR _rfp$1[ebp], eax

; 164  : 		if (rfp)

  000a4	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _rfp$1[ebp], 0
  000ab	74 31		 je	 SHORT $LN1@LogToRecvd

; 165  : 		{
; 166  : 			fprintf(rfp, "收到：\t%s\n", data);

  000ad	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  000b0	50		 push	 eax
  000b1	68 00 00 00 00	 push	 OFFSET ??_C@_0L@INAHAGEI@?b?$KF?S?p?$KD?$LK?7?$CFs?6?$AA@
  000b6	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _rfp$1[ebp]
  000bc	51		 push	 ecx
  000bd	e8 00 00 00 00	 call	 _fprintf
  000c2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 167  : 			fclose(rfp);

  000c5	8b f4		 mov	 esi, esp
  000c7	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _rfp$1[ebp]
  000cd	50		 push	 eax
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  000d4	83 c4 04	 add	 esp, 4
  000d7	3b f4		 cmp	 esi, esp
  000d9	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@LogToRecvd:

; 168  : 		}
; 169  : 	}
; 170  : }

  000de	52		 push	 edx
  000df	8b cd		 mov	 ecx, ebp
  000e1	50		 push	 eax
  000e2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@LogToRecvd
  000e8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000ed	58		 pop	 eax
  000ee	5a		 pop	 edx
  000ef	5f		 pop	 edi
  000f0	5e		 pop	 esi
  000f1	5b		 pop	 ebx
  000f2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f5	33 cd		 xor	 ecx, ebp
  000f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fc	81 c4 d8 01 00
	00		 add	 esp, 472		; 000001d8H
  00102	3b ec		 cmp	 ebp, esp
  00104	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c3		 ret	 0
  0010d	0f 1f 00	 npad	 3
$LN7@LogToRecvd:
  00110	01 00 00 00	 DD	 1
  00114	00 00 00 00	 DD	 $LN6@LogToRecvd
$LN6@LogToRecvd:
  00118	f8 fe ff ff	 DD	 -264			; fffffef8H
  0011c	00 01 00 00	 DD	 256			; 00000100H
  00120	00 00 00 00	 DD	 $LN5@LogToRecvd
$LN5@LogToRecvd:
  00124	6c		 DB	 108			; 0000006cH
  00125	73		 DB	 115			; 00000073H
  00126	73		 DB	 115			; 00000073H
  00127	70		 DB	 112			; 00000070H
  00128	72		 DB	 114			; 00000072H
  00129	6f		 DB	 111			; 0000006fH
  0012a	74		 DB	 116			; 00000074H
  0012b	6f		 DB	 111			; 0000006fH
  0012c	5f		 DB	 95			; 0000005fH
  0012d	72		 DB	 114			; 00000072H
  0012e	65		 DB	 101			; 00000065H
  0012f	61		 DB	 97			; 00000061H
  00130	64		 DB	 100			; 00000064H
  00131	6c		 DB	 108			; 0000006cH
  00132	6f		 DB	 111			; 0000006fH
  00133	67		 DB	 103			; 00000067H
  00134	66		 DB	 102			; 00000066H
  00135	69		 DB	 105			; 00000069H
  00136	6c		 DB	 108			; 0000006cH
  00137	65		 DB	 101			; 00000065H
  00138	6e		 DB	 110			; 0000006eH
  00139	61		 DB	 97			; 00000061H
  0013a	6d		 DB	 109			; 0000006dH
  0013b	65		 DB	 101			; 00000065H
  0013c	00		 DB	 0
?LogToRecvdata2@@YAXPAD@Z ENDP				; LogToRecvdata2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?SaveChatData@@YAXPADD_N@Z
_TEXT	SEGMENT
_len$1 = -40						; size = 4
_len$2 = -28						; size = 4
_ChannelType$ = -16					; size = 5
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_KindOfChannel$ = 12					; size = 1
_bCloseFile$ = 16					; size = 1
?SaveChatData@@YAXPADD_N@Z PROC				; SaveChatData, COMDAT

; 4458 : void SaveChatData(char *msg,char KindOfChannel,bool bCloseFile){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 14 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-236]
  00012	b9 3b 00 00 00	 mov	 ecx, 59			; 0000003bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4459 : 	static FILE *pFile[5];
; 4460 : 	static char szFileName[256];
; 4461 : 	static struct tm *nowTime;
; 4462 : 	static time_t longTime;
; 4463 : 	static unsigned short Channel[] = {
; 4464 : 		PC_ETCFLAG_CHAT_MODE, //队伍频道开关
; 4465 : 		PC_ETCFLAG_CHAT_TELL,	//密语频道开关
; 4466 : 		PC_ETCFLAG_CHAT_FM,		//家族频道开关
; 4467 : 		PC_ETCFLAG_CHAT_OCC,	//职业频道开关
; 4468 : 		PC_ETCFLAG_CHAT_CHAT	//聊天室开关
; 4469 : 	};
; 4470 : 	char ChannelType[] = {'T','M','F','O','R'};

  00028	c6 45 f0 54	 mov	 BYTE PTR _ChannelType$[ebp], 84 ; 00000054H
  0002c	c6 45 f1 4d	 mov	 BYTE PTR _ChannelType$[ebp+1], 77 ; 0000004dH
  00030	c6 45 f2 46	 mov	 BYTE PTR _ChannelType$[ebp+2], 70 ; 00000046H
  00034	c6 45 f3 4f	 mov	 BYTE PTR _ChannelType$[ebp+3], 79 ; 0000004fH
  00038	c6 45 f4 52	 mov	 BYTE PTR _ChannelType$[ebp+4], 82 ; 00000052H

; 4471 : 
; 4472 : 	//JL 重写保存chat聊天记录
; 4473 : 	if ((pc.etcFlag & PC_ETCFLAG_CHAT_SAVE) && !bCloseFile) 

  0003c	0f b7 05 a8 00
	00 00		 movzx	 eax, WORD PTR ?pc@@3UPC@@A+168
  00043	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00048	0f 84 c5 01 00
	00		 je	 $LN2@SaveChatDa
  0004e	0f b6 45 10	 movzx	 eax, BYTE PTR _bCloseFile$[ebp]
  00052	85 c0		 test	 eax, eax
  00054	0f 85 b9 01 00
	00		 jne	 $LN2@SaveChatDa

; 4474 : 	{
; 4475 : 		time(&longTime);

  0005a	68 00 00 00 00	 push	 OFFSET ?longTime@?1??SaveChatData@@YAXPADD_N@Z@4_JA
  0005f	e8 00 00 00 00	 call	 _time
  00064	83 c4 04	 add	 esp, 4

; 4476 : 		nowTime = localtime(&longTime);

  00067	68 00 00 00 00	 push	 OFFSET ?longTime@?1??SaveChatData@@YAXPADD_N@Z@4_JA
  0006c	e8 00 00 00 00	 call	 _localtime
  00071	83 c4 04	 add	 esp, 4
  00074	a3 00 00 00 00	 mov	 DWORD PTR ?nowTime@?1??SaveChatData@@YAXPADD_N@Z@4PAUtm@@A, eax

; 4477 : 
; 4478 : 		if (pFile[0] == NULL) 

  00079	b8 04 00 00 00	 mov	 eax, 4
  0007e	6b c8 00	 imul	 ecx, eax, 0
  00081	83 b9 00 00 00
	00 00		 cmp	 DWORD PTR ?pFile@?1??SaveChatData@@YAXPADD_N@Z@4PAPAU_iobuf@@A[ecx], 0
  00088	0f 85 f6 00 00
	00		 jne	 $LN4@SaveChatDa

; 4479 : 		{
; 4480 : 			sprintf(szFileName, "chat\\%02d%02d%02d.TXT", (nowTime->tm_year % 100), nowTime->tm_mon + 1, nowTime->tm_mday);

  0008e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nowTime@?1??SaveChatData@@YAXPADD_N@Z@4PAUtm@@A
  00093	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00096	51		 push	 ecx
  00097	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?nowTime@?1??SaveChatData@@YAXPADD_N@Z@4PAUtm@@A
  0009d	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000a0	83 c0 01	 add	 eax, 1
  000a3	50		 push	 eax
  000a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nowTime@?1??SaveChatData@@YAXPADD_N@Z@4PAUtm@@A
  000aa	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  000ad	99		 cdq
  000ae	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000b3	f7 f9		 idiv	 ecx
  000b5	52		 push	 edx
  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@JGFFJBEF@chat?2?$CF02d?$CF02d?$CF02d?4TXT?$AA@
  000bb	68 00 00 00 00	 push	 OFFSET ?szFileName@?1??SaveChatData@@YAXPADD_N@Z@4PADA
  000c0	e8 00 00 00 00	 call	 _sprintf
  000c5	83 c4 14	 add	 esp, 20			; 00000014H

; 4481 : 			pFile[0] = fopen(szFileName, "a");

  000c8	8b f4		 mov	 esi, esp
  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_01MCMALHOG@a?$AA@
  000cf	68 00 00 00 00	 push	 OFFSET ?szFileName@?1??SaveChatData@@YAXPADD_N@Z@4PADA
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  000da	83 c4 08	 add	 esp, 8
  000dd	3b f4		 cmp	 esi, esp
  000df	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e4	b9 04 00 00 00	 mov	 ecx, 4
  000e9	6b d1 00	 imul	 edx, ecx, 0
  000ec	89 82 00 00 00
	00		 mov	 DWORD PTR ?pFile@?1??SaveChatData@@YAXPADD_N@Z@4PAPAU_iobuf@@A[edx], eax

; 4482 : 			int len = lstrlen(msg);

  000f2	8b f4		 mov	 esi, esp
  000f4	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  000f7	50		 push	 eax
  000f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  000fe	3b f4		 cmp	 esi, esp
  00100	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00105	89 45 e4	 mov	 DWORD PTR _len$2[ebp], eax

; 4483 : 			fwrite(msg, 1, len, pFile[0]);

  00108	b8 04 00 00 00	 mov	 eax, 4
  0010d	6b c8 00	 imul	 ecx, eax, 0
  00110	8b f4		 mov	 esi, esp
  00112	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?pFile@?1??SaveChatData@@YAXPADD_N@Z@4PAPAU_iobuf@@A[ecx]
  00118	52		 push	 edx
  00119	8b 45 e4	 mov	 eax, DWORD PTR _len$2[ebp]
  0011c	50		 push	 eax
  0011d	6a 01		 push	 1
  0011f	8b 4d 08	 mov	 ecx, DWORD PTR _msg$[ebp]
  00122	51		 push	 ecx
  00123	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  00129	83 c4 10	 add	 esp, 16			; 00000010H
  0012c	3b f4		 cmp	 esi, esp
  0012e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 4484 : 			fwrite("\n", 1, 1, pFile[0]);

  00133	b8 04 00 00 00	 mov	 eax, 4
  00138	6b c8 00	 imul	 ecx, eax, 0
  0013b	8b f4		 mov	 esi, esp
  0013d	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?pFile@?1??SaveChatData@@YAXPADD_N@Z@4PAPAU_iobuf@@A[ecx]
  00143	52		 push	 edx
  00144	6a 01		 push	 1
  00146	6a 01		 push	 1
  00148	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  0014d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  00153	83 c4 10	 add	 esp, 16			; 00000010H
  00156	3b f4		 cmp	 esi, esp
  00158	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 4485 : 			fflush(pFile[0]);

  0015d	b8 04 00 00 00	 mov	 eax, 4
  00162	6b c8 00	 imul	 ecx, eax, 0
  00165	8b f4		 mov	 esi, esp
  00167	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?pFile@?1??SaveChatData@@YAXPADD_N@Z@4PAPAU_iobuf@@A[ecx]
  0016d	52		 push	 edx
  0016e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush
  00174	83 c4 04	 add	 esp, 4
  00177	3b f4		 cmp	 esi, esp
  00179	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 4486 : 			__asm nop;

  0017e	90		 npad	 1

; 4487 : 		}
; 4488 : 		else 

  0017f	e9 8d 00 00 00	 jmp	 $LN5@SaveChatDa
$LN4@SaveChatDa:

; 4489 : 		{
; 4490 : 			int len = lstrlen(msg);

  00184	8b f4		 mov	 esi, esp
  00186	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  00189	50		 push	 eax
  0018a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  00190	3b f4		 cmp	 esi, esp
  00192	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00197	89 45 d8	 mov	 DWORD PTR _len$1[ebp], eax

; 4491 : 			fwrite(msg, 1, len, pFile[0]);

  0019a	b8 04 00 00 00	 mov	 eax, 4
  0019f	6b c8 00	 imul	 ecx, eax, 0
  001a2	8b f4		 mov	 esi, esp
  001a4	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?pFile@?1??SaveChatData@@YAXPADD_N@Z@4PAPAU_iobuf@@A[ecx]
  001aa	52		 push	 edx
  001ab	8b 45 d8	 mov	 eax, DWORD PTR _len$1[ebp]
  001ae	50		 push	 eax
  001af	6a 01		 push	 1
  001b1	8b 4d 08	 mov	 ecx, DWORD PTR _msg$[ebp]
  001b4	51		 push	 ecx
  001b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  001bb	83 c4 10	 add	 esp, 16			; 00000010H
  001be	3b f4		 cmp	 esi, esp
  001c0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 4492 : 			fwrite("\n", 1, 1, pFile[0]);

  001c5	b8 04 00 00 00	 mov	 eax, 4
  001ca	6b c8 00	 imul	 ecx, eax, 0
  001cd	8b f4		 mov	 esi, esp
  001cf	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?pFile@?1??SaveChatData@@YAXPADD_N@Z@4PAPAU_iobuf@@A[ecx]
  001d5	52		 push	 edx
  001d6	6a 01		 push	 1
  001d8	6a 01		 push	 1
  001da	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  001df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  001e5	83 c4 10	 add	 esp, 16			; 00000010H
  001e8	3b f4		 cmp	 esi, esp
  001ea	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 4493 : 			fflush(pFile[0]);

  001ef	b8 04 00 00 00	 mov	 eax, 4
  001f4	6b c8 00	 imul	 ecx, eax, 0
  001f7	8b f4		 mov	 esi, esp
  001f9	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?pFile@?1??SaveChatData@@YAXPADD_N@Z@4PAPAU_iobuf@@A[ecx]
  001ff	52		 push	 edx
  00200	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush
  00206	83 c4 04	 add	 esp, 4
  00209	3b f4		 cmp	 esi, esp
  0020b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 4494 : 			__asm nop;

  00210	90		 npad	 1
$LN5@SaveChatDa:

; 4495 : 		}

  00211	eb 04		 jmp	 SHORT $LN3@SaveChatDa
$LN2@SaveChatDa:

; 4496 : 
; 4497 : 	}
; 4498 : 	else bCloseFile = 1;

  00213	c6 45 10 01	 mov	 BYTE PTR _bCloseFile$[ebp], 1
$LN3@SaveChatDa:

; 4499 : 
; 4500 : 	if (bCloseFile) {

  00217	0f b6 45 10	 movzx	 eax, BYTE PTR _bCloseFile$[ebp]
  0021b	85 c0		 test	 eax, eax
  0021d	74 44		 je	 SHORT $LN1@SaveChatDa

; 4501 : 		if (pFile[0] != NULL)

  0021f	b8 04 00 00 00	 mov	 eax, 4
  00224	6b c8 00	 imul	 ecx, eax, 0
  00227	83 b9 00 00 00
	00 00		 cmp	 DWORD PTR ?pFile@?1??SaveChatData@@YAXPADD_N@Z@4PAPAU_iobuf@@A[ecx], 0
  0022e	74 33		 je	 SHORT $LN1@SaveChatDa

; 4502 : 		{
; 4503 : 			fclose(pFile[0]);

  00230	b8 04 00 00 00	 mov	 eax, 4
  00235	6b c8 00	 imul	 ecx, eax, 0
  00238	8b f4		 mov	 esi, esp
  0023a	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?pFile@?1??SaveChatData@@YAXPADD_N@Z@4PAPAU_iobuf@@A[ecx]
  00240	52		 push	 edx
  00241	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00247	83 c4 04	 add	 esp, 4
  0024a	3b f4		 cmp	 esi, esp
  0024c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 4504 : 			pFile[0] = 0;

  00251	b8 04 00 00 00	 mov	 eax, 4
  00256	6b c8 00	 imul	 ecx, eax, 0
  00259	c7 81 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pFile@?1??SaveChatData@@YAXPADD_N@Z@4PAPAU_iobuf@@A[ecx], 0
$LN1@SaveChatDa:

; 4505 : 		}
; 4506 : 	}
; 4507 : 
; 4508 : 	// 储存对话内容选项开启
; 4509 : 	//if ((pc.etcFlag & PC_ETCFLAG_CHAT_SAVE) && !bCloseFile){
; 4510 : 	//	time(&longTime);
; 4511 : 	//	nowTime = localtime(&longTime);
; 4512 : 	//	for (int i=0;i<5;i++){
; 4513 : 	//		if (pc.etcFlag & Channel[i]){
; 4514 : 	//			if (pFile[i] == NULL){
; 4515 : 	//				sprintf(szFileName,"chat\\%c%02d%02d%02d.TXT",ChannelType[i],(nowTime->tm_year % 100),nowTime->tm_mon+1,nowTime->tm_mday);
; 4516 : 	//				if ((pFile[i] = fopen(szFileName,"a")) == NULL) continue;
; 4517 : 	//				int n =fwrite(msg, lstrlen(msg), lstrlen(msg), pFile[i]);
; 4518 : 	//				__asm nop;
; 4519 : 	//			}
; 4520 : 	//		}
; 4521 : 	//		else{
; 4522 : 	//			if (pFile[i] != NULL) fclose(pFile[i]);
; 4523 : 	//		}
; 4524 : 	//	}
; 4525 : 	//	for (int i=0;i<5;i++){
; 4526 : 	//		if (KindOfChannel == ChannelType[i]){
; 4527 : 	//			if (pFile[i] != NULL) fprintf(pFile[i],"[%02d:%02d:%02d]%s\n",nowTime->tm_hour,nowTime->tm_min,nowTime->tm_sec,msg);
; 4528 : 	//		}
; 4529 : 	//	}
; 4530 : 	//}
; 4531 : 	//else bCloseFile = 1;
; 4532 : 
; 4533 : 	//if (bCloseFile){
; 4534 : 	//	for (int i=0;i<5;i++)
; 4535 : 	//		if (pFile[i] != NULL) fclose(pFile[i]);
; 4536 : 	//}
; 4537 : }

  00263	52		 push	 edx
  00264	8b cd		 mov	 ecx, ebp
  00266	50		 push	 eax
  00267	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@SaveChatDa
  0026d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00272	58		 pop	 eax
  00273	5a		 pop	 edx
  00274	5f		 pop	 edi
  00275	5e		 pop	 esi
  00276	5b		 pop	 ebx
  00277	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0027a	33 cd		 xor	 ecx, ebp
  0027c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00281	81 c4 ec 00 00
	00		 add	 esp, 236		; 000000ecH
  00287	3b ec		 cmp	 ebp, esp
  00289	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0028e	8b e5		 mov	 esp, ebp
  00290	5d		 pop	 ebp
  00291	c3		 ret	 0
  00292	66 90		 npad	 2
$LN11@SaveChatDa:
  00294	01 00 00 00	 DD	 1
  00298	00 00 00 00	 DD	 $LN10@SaveChatDa
$LN10@SaveChatDa:
  0029c	f0 ff ff ff	 DD	 -16			; fffffff0H
  002a0	05 00 00 00	 DD	 5
  002a4	00 00 00 00	 DD	 $LN9@SaveChatDa
$LN9@SaveChatDa:
  002a8	43		 DB	 67			; 00000043H
  002a9	68		 DB	 104			; 00000068H
  002aa	61		 DB	 97			; 00000061H
  002ab	6e		 DB	 110			; 0000006eH
  002ac	6e		 DB	 110			; 0000006eH
  002ad	65		 DB	 101			; 00000065H
  002ae	6c		 DB	 108			; 0000006cH
  002af	54		 DB	 84			; 00000054H
  002b0	79		 DB	 121			; 00000079H
  002b1	70		 DB	 112			; 00000070H
  002b2	65		 DB	 101			; 00000065H
  002b3	00		 DB	 0
?SaveChatData@@YAXPADD_N@Z ENDP				; SaveChatData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?SortSkill@@YAXXZ
_TEXT	SEGMENT
tv78 = -256						; size = 4
_i$1 = -56						; size = 4
_i$2 = -44						; size = 4
_count3$ = -32						; size = 4
_count2$ = -20						; size = 4
_count1$ = -8						; size = 4
?SortSkill@@YAXXZ PROC					; SortSkill, COMDAT

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 00 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-256]
  00012	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 117  : 	int count1 = 0, count2 = 0, count3 = 0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count1$[ebp], 0
  00025	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _count2$[ebp], 0
  0002c	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _count3$[ebp], 0

; 118  : 
; 119  : 	for (int i = 0; i < 20; i++)

  00033	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  0003a	eb 09		 jmp	 SHORT $LN4@SortSkill
$LN2@SortSkill:
  0003c	8b 45 d4	 mov	 eax, DWORD PTR _i$2[ebp]
  0003f	83 c0 01	 add	 eax, 1
  00042	89 45 d4	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@SortSkill:
  00045	83 7d d4 14	 cmp	 DWORD PTR _i$2[ebp], 20	; 00000014H
  00049	7d 2c		 jge	 SHORT $LN3@SortSkill

; 120  : 	{
; 121  : 		AdvanceSkill[i] = -1;

  0004b	8b 45 d4	 mov	 eax, DWORD PTR _i$2[ebp]
  0004e	c7 04 85 00 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR ?AdvanceSkill@@3PAHA[eax*4], -1

; 122  : 		AssitSkill[i] = -1;		

  00059	8b 45 d4	 mov	 eax, DWORD PTR _i$2[ebp]
  0005c	c7 04 85 00 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR ?AssitSkill@@3PAHA[eax*4], -1

; 123  : 		BattleSkill[i] = -1;

  00067	8b 45 d4	 mov	 eax, DWORD PTR _i$2[ebp]
  0006a	c7 04 85 00 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR ?BattleSkill@@3PAHA[eax*4], -1

; 124  : 	}

  00075	eb c5		 jmp	 SHORT $LN2@SortSkill
$LN3@SortSkill:

; 125  : 	for (int i = 0; i < 26; i++)

  00077	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0007e	eb 09		 jmp	 SHORT $LN7@SortSkill
$LN5@SortSkill:
  00080	8b 45 c8	 mov	 eax, DWORD PTR _i$1[ebp]
  00083	83 c0 01	 add	 eax, 1
  00086	89 45 c8	 mov	 DWORD PTR _i$1[ebp], eax
$LN7@SortSkill:
  00089	83 7d c8 1a	 cmp	 DWORD PTR _i$1[ebp], 26	; 0000001aH
  0008d	7d 7c		 jge	 SHORT $LN1@SortSkill

; 126  : 	{
; 127  : 		switch (profession_skill[i].kind)

  0008f	69 45 c8 c0 00
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 192
  00096	0f bf 88 06 00
	00 00		 movsx	 ecx, WORD PTR ?profession_skill@@3PAUPROFESSION_SKILL@@A[eax+6]
  0009d	89 8d 00 ff ff
	ff		 mov	 DWORD PTR tv78[ebp], ecx
  000a3	83 bd 00 ff ff
	ff 01		 cmp	 DWORD PTR tv78[ebp], 1
  000aa	74 14		 je	 SHORT $LN10@SortSkill
  000ac	83 bd 00 ff ff
	ff 02		 cmp	 DWORD PTR tv78[ebp], 2
  000b3	74 23		 je	 SHORT $LN11@SortSkill
  000b5	83 bd 00 ff ff
	ff 03		 cmp	 DWORD PTR tv78[ebp], 3
  000bc	74 32		 je	 SHORT $LN12@SortSkill
  000be	eb 46		 jmp	 SHORT $LN8@SortSkill
$LN10@SortSkill:

; 128  : 		{
; 129  : 		case 1: // 战斗技能
; 130  : 			BattleSkill[count1] = i;

  000c0	8b 45 f8	 mov	 eax, DWORD PTR _count1$[ebp]
  000c3	8b 4d c8	 mov	 ecx, DWORD PTR _i$1[ebp]
  000c6	89 0c 85 00 00
	00 00		 mov	 DWORD PTR ?BattleSkill@@3PAHA[eax*4], ecx

; 131  : 			count1++;

  000cd	8b 45 f8	 mov	 eax, DWORD PTR _count1$[ebp]
  000d0	83 c0 01	 add	 eax, 1
  000d3	89 45 f8	 mov	 DWORD PTR _count1$[ebp], eax

; 132  : 			break;

  000d6	eb 2e		 jmp	 SHORT $LN8@SortSkill
$LN11@SortSkill:

; 133  : 		case 2: // 辅助
; 134  : 			AssitSkill[count2] = i;

  000d8	8b 45 ec	 mov	 eax, DWORD PTR _count2$[ebp]
  000db	8b 4d c8	 mov	 ecx, DWORD PTR _i$1[ebp]
  000de	89 0c 85 00 00
	00 00		 mov	 DWORD PTR ?AssitSkill@@3PAHA[eax*4], ecx

; 135  : 			count2++;

  000e5	8b 45 ec	 mov	 eax, DWORD PTR _count2$[ebp]
  000e8	83 c0 01	 add	 eax, 1
  000eb	89 45 ec	 mov	 DWORD PTR _count2$[ebp], eax

; 136  : 			break;

  000ee	eb 16		 jmp	 SHORT $LN8@SortSkill
$LN12@SortSkill:

; 137  : 		case 3: // 进阶
; 138  : 			AdvanceSkill[count3] = i;

  000f0	8b 45 e0	 mov	 eax, DWORD PTR _count3$[ebp]
  000f3	8b 4d c8	 mov	 ecx, DWORD PTR _i$1[ebp]
  000f6	89 0c 85 00 00
	00 00		 mov	 DWORD PTR ?AdvanceSkill@@3PAHA[eax*4], ecx

; 139  : 			count3++;

  000fd	8b 45 e0	 mov	 eax, DWORD PTR _count3$[ebp]
  00100	83 c0 01	 add	 eax, 1
  00103	89 45 e0	 mov	 DWORD PTR _count3$[ebp], eax
$LN8@SortSkill:

; 140  : 			break;
; 141  : 		}
; 142  : 	}

  00106	e9 75 ff ff ff	 jmp	 $LN5@SortSkill
$LN1@SortSkill:

; 143  : }

  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx
  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c3		 ret	 0
?SortSkill@@YAXXZ ENDP					; SortSkill
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_Firework_recv@@YAXHHHH@Z
_TEXT	SEGMENT
_pAct$ = -8						; size = 4
_fd$ = 8						; size = 4
_nCharaindex$ = 12					; size = 4
_nType$ = 16						; size = 4
_nActionNum$ = 20					; size = 4
?lssproto_Firework_recv@@YAXHHHH@Z PROC			; lssproto_Firework_recv, COMDAT

; 4672 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 4673 : 	ACTION	*pAct;
; 4674 : 
; 4675 : 	if (pc.id == nCharaindex)

  0001e	a1 08 00 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+8
  00023	3b 45 0c	 cmp	 eax, DWORD PTR _nCharaindex$[ebp]
  00026	75 1c		 jne	 SHORT $LN2@lssproto_F

; 4676 : 		changePcAct(0, 0, 0, 51, nType, nActionNum, 0);

  00028	6a 00		 push	 0
  0002a	8b 45 14	 mov	 eax, DWORD PTR _nActionNum$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 10	 mov	 ecx, DWORD PTR _nType$[ebp]
  00031	51		 push	 ecx
  00032	6a 33		 push	 51			; 00000033H
  00034	6a 00		 push	 0
  00036	6a 00		 push	 0
  00038	6a 00		 push	 0
  0003a	e8 00 00 00 00	 call	 ?changePcAct@@YAXHHHHHHH@Z ; changePcAct
  0003f	83 c4 1c	 add	 esp, 28			; 0000001cH

; 4677 : 	else

  00042	eb 2d		 jmp	 SHORT $LN1@lssproto_F
$LN2@lssproto_F:

; 4678 : 	{
; 4679 : 		pAct = getCharObjAct(nCharaindex);

  00044	8b 45 0c	 mov	 eax, DWORD PTR _nCharaindex$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?getCharObjAct@@YAPAUaction@@H@Z ; getCharObjAct
  0004d	83 c4 04	 add	 esp, 4
  00050	89 45 f8	 mov	 DWORD PTR _pAct$[ebp], eax

; 4680 : 		changeCharAct(pAct, 0, 0, 0, 51, nType, nActionNum, 0);

  00053	6a 00		 push	 0
  00055	8b 45 14	 mov	 eax, DWORD PTR _nActionNum$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR _nType$[ebp]
  0005c	51		 push	 ecx
  0005d	6a 33		 push	 51			; 00000033H
  0005f	6a 00		 push	 0
  00061	6a 00		 push	 0
  00063	6a 00		 push	 0
  00065	8b 55 f8	 mov	 edx, DWORD PTR _pAct$[ebp]
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 ?changeCharAct@@YAXPAUaction@@HHHHHHH@Z ; changeCharAct
  0006e	83 c4 20	 add	 esp, 32			; 00000020H
$LN1@lssproto_F:

; 4681 : 	
; 4682 : 	}
; 4683 : }

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0007a	3b ec		 cmp	 ebp, esp
  0007c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
?lssproto_Firework_recv@@YAXHHHH@Z ENDP			; lssproto_Firework_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_S2_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_szMessage$ = -24					; size = 16
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_S2_recv@@YAXHPAD@Z PROC			; lssproto_S2_recv, COMDAT

; 4654 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4655 : 	char szMessage[16];
; 4656 : 
; 4657 : 	getStringToken(data,'|',1,sizeof(szMessage) - 1,szMessage);

  00028	8d 45 e8	 lea	 eax, DWORD PTR _szMessage$[ebp]
  0002b	50		 push	 eax
  0002c	6a 0f		 push	 15			; 0000000fH
  0002e	6a 01		 push	 1
  00030	6a 7c		 push	 124			; 0000007cH
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0003b	83 c4 14	 add	 esp, 20			; 00000014H

; 4658 : 
; 4659 : #ifdef _NEW_MANOR_LAW
; 4660 : 	if (strcmp(szMessage,"FAME") == 0){

  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_04DIIKDPIA@FAME?$AA@
  00043	8d 45 e8	 lea	 eax, DWORD PTR _szMessage$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _strcmp
  0004c	83 c4 08	 add	 esp, 8
  0004f	85 c0		 test	 eax, eax
  00051	75 31		 jne	 SHORT $LN1@lssproto_S

; 4661 : 		getStringToken(data,'|',2,sizeof(szMessage) - 1,szMessage);

  00053	8d 45 e8	 lea	 eax, DWORD PTR _szMessage$[ebp]
  00056	50		 push	 eax
  00057	6a 0f		 push	 15			; 0000000fH
  00059	6a 02		 push	 2
  0005b	6a 7c		 push	 124			; 0000007cH
  0005d	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00060	51		 push	 ecx
  00061	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00066	83 c4 14	 add	 esp, 20			; 00000014H

; 4662 : 		pc.fame = atoi(szMessage);

  00069	8b f4		 mov	 esi, esp
  0006b	8d 45 e8	 lea	 eax, DWORD PTR _szMessage$[ebp]
  0006e	50		 push	 eax
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00075	83 c4 04	 add	 esp, 4
  00078	3b f4		 cmp	 esi, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	a3 64 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+100, eax
$LN1@lssproto_S:

; 4663 : 	}
; 4664 : #endif
; 4665 : 
; 4666 : 
; 4667 : }

  00084	52		 push	 edx
  00085	8b cd		 mov	 ecx, ebp
  00087	50		 push	 eax
  00088	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@lssproto_S
  0008e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00093	58		 pop	 eax
  00094	5a		 pop	 edx
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx
  00098	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009b	33 cd		 xor	 ecx, ebp
  0009d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a2	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  000a8	3b ec		 cmp	 ebp, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
  000b3	90		 npad	 1
$LN6@lssproto_S:
  000b4	01 00 00 00	 DD	 1
  000b8	00 00 00 00	 DD	 $LN5@lssproto_S
$LN5@lssproto_S:
  000bc	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000c0	10 00 00 00	 DD	 16			; 00000010H
  000c4	00 00 00 00	 DD	 $LN4@lssproto_S
$LN4@lssproto_S:
  000c8	73		 DB	 115			; 00000073H
  000c9	7a		 DB	 122			; 0000007aH
  000ca	4d		 DB	 77			; 0000004dH
  000cb	65		 DB	 101			; 00000065H
  000cc	73		 DB	 115			; 00000073H
  000cd	73		 DB	 115			; 00000073H
  000ce	61		 DB	 97			; 00000061H
  000cf	67		 DB	 103			; 00000067H
  000d0	65		 DB	 101			; 00000065H
  000d1	00		 DB	 0
?lssproto_S2_recv@@YAXHPAD@Z ENDP			; lssproto_S2_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_TEACHER_SYSTEM_recv@@YAXHPAD@Z
_TEXT	SEGMENT
tv72 = -224						; size = 4
_szMessage$ = -24					; size = 16
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_TEACHER_SYSTEM_recv@@YAXHPAD@Z PROC		; lssproto_TEACHER_SYSTEM_recv, COMDAT

; 4625 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00012	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4626 : 	char szMessage[16];
; 4627 : 
; 4628 : 	getStringToken(data,'|',1,sizeof(szMessage) - 1,szMessage);

  00028	8d 45 e8	 lea	 eax, DWORD PTR _szMessage$[ebp]
  0002b	50		 push	 eax
  0002c	6a 0f		 push	 15			; 0000000fH
  0002e	6a 01		 push	 1
  00030	6a 7c		 push	 124			; 0000007cH
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0003b	83 c4 14	 add	 esp, 20			; 00000014H

; 4629 : 	switch (szMessage[0]){

  0003e	b8 01 00 00 00	 mov	 eax, 1
  00043	6b c8 00	 imul	 ecx, eax, 0
  00046	0f be 54 0d e8	 movsx	 edx, BYTE PTR _szMessage$[ebp+ecx]
  0004b	89 95 20 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
  00051	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00057	83 e8 41	 sub	 eax, 65			; 00000041H
  0005a	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
  00060	83 bd 20 ff ff
	ff 15		 cmp	 DWORD PTR tv72[ebp], 21	; 00000015H
  00067	77 70		 ja	 SHORT $LN1@lssproto_T
  00069	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv72[ebp]
  0006f	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN9@lssproto_T[ecx]
  00076	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN13@lssproto_T[edx*4]
$LN4@lssproto_T:

; 4630 : 		// 显示说明
; 4631 : 		case 'M':sTeacherSystemBtn = 1;break;

  0007d	b8 01 00 00 00	 mov	 eax, 1
  00082	66 a3 00 00 00
	00		 mov	 WORD PTR ?sTeacherSystemBtn@@3FA, ax ; sTeacherSystemBtn
  00088	eb 4f		 jmp	 SHORT $LN1@lssproto_T
$LN5@lssproto_T:

; 4632 : 		// 询问是否要对方当你的导师
; 4633 : 		case 'C':
; 4634 : 			sTeacherSystemBtn = 2;

  0008a	b8 02 00 00 00	 mov	 eax, 2
  0008f	66 a3 00 00 00
	00		 mov	 WORD PTR ?sTeacherSystemBtn@@3FA, ax ; sTeacherSystemBtn

; 4635 : 			TeacherSystemWndfunc(0,data);

  00095	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00098	50		 push	 eax
  00099	6a 00		 push	 0
  0009b	e8 00 00 00 00	 call	 ?TeacherSystemWndfunc@@YAXHPAD@Z ; TeacherSystemWndfunc
  000a0	83 c4 08	 add	 esp, 8

; 4636 : 			break;

  000a3	eb 34		 jmp	 SHORT $LN1@lssproto_T
$LN6@lssproto_T:

; 4637 : 		// 超过一人,询问要找谁当导师
; 4638 : 		case 'A':
; 4639 : 			sTeacherSystemBtn = 3;

  000a5	b8 03 00 00 00	 mov	 eax, 3
  000aa	66 a3 00 00 00
	00		 mov	 WORD PTR ?sTeacherSystemBtn@@3FA, ax ; sTeacherSystemBtn

; 4640 : 			TeacherSystemWndfunc(1,data);

  000b0	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  000b3	50		 push	 eax
  000b4	6a 01		 push	 1
  000b6	e8 00 00 00 00	 call	 ?TeacherSystemWndfunc@@YAXHPAD@Z ; TeacherSystemWndfunc
  000bb	83 c4 08	 add	 esp, 8

; 4641 : 			break;

  000be	eb 19		 jmp	 SHORT $LN1@lssproto_T
$LN7@lssproto_T:

; 4642 : 		// 显示导师资料
; 4643 : 		case 'V':
; 4644 : 			sTeacherSystemBtn = 4;

  000c0	b8 04 00 00 00	 mov	 eax, 4
  000c5	66 a3 00 00 00
	00		 mov	 WORD PTR ?sTeacherSystemBtn@@3FA, ax ; sTeacherSystemBtn

; 4645 : 			TeacherSystemWndfunc(2,data);

  000cb	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  000ce	50		 push	 eax
  000cf	6a 02		 push	 2
  000d1	e8 00 00 00 00	 call	 ?TeacherSystemWndfunc@@YAXHPAD@Z ; TeacherSystemWndfunc
  000d6	83 c4 08	 add	 esp, 8
$LN1@lssproto_T:

; 4646 : 			break;
; 4647 : 
; 4648 : 	}	
; 4649 : }

  000d9	52		 push	 edx
  000da	8b cd		 mov	 ecx, ebp
  000dc	50		 push	 eax
  000dd	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@lssproto_T
  000e3	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000e8	58		 pop	 eax
  000e9	5a		 pop	 edx
  000ea	5f		 pop	 edi
  000eb	5e		 pop	 esi
  000ec	5b		 pop	 ebx
  000ed	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f0	33 cd		 xor	 ecx, ebp
  000f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f7	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  000fd	3b ec		 cmp	 ebp, esp
  000ff	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
$LN12@lssproto_T:
  00108	01 00 00 00	 DD	 1
  0010c	00 00 00 00	 DD	 $LN11@lssproto_T
$LN11@lssproto_T:
  00110	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00114	10 00 00 00	 DD	 16			; 00000010H
  00118	00 00 00 00	 DD	 $LN10@lssproto_T
$LN10@lssproto_T:
  0011c	73		 DB	 115			; 00000073H
  0011d	7a		 DB	 122			; 0000007aH
  0011e	4d		 DB	 77			; 0000004dH
  0011f	65		 DB	 101			; 00000065H
  00120	73		 DB	 115			; 00000073H
  00121	73		 DB	 115			; 00000073H
  00122	61		 DB	 97			; 00000061H
  00123	67		 DB	 103			; 00000067H
  00124	65		 DB	 101			; 00000065H
  00125	00		 DB	 0
  00126	66 90		 npad	 2
$LN13@lssproto_T:
  00128	00 00 00 00	 DD	 $LN6@lssproto_T
  0012c	00 00 00 00	 DD	 $LN5@lssproto_T
  00130	00 00 00 00	 DD	 $LN4@lssproto_T
  00134	00 00 00 00	 DD	 $LN7@lssproto_T
  00138	00 00 00 00	 DD	 $LN1@lssproto_T
$LN9@lssproto_T:
  0013c	00		 DB	 0
  0013d	04		 DB	 4
  0013e	01		 DB	 1
  0013f	04		 DB	 4
  00140	04		 DB	 4
  00141	04		 DB	 4
  00142	04		 DB	 4
  00143	04		 DB	 4
  00144	04		 DB	 4
  00145	04		 DB	 4
  00146	04		 DB	 4
  00147	04		 DB	 4
  00148	02		 DB	 2
  00149	04		 DB	 4
  0014a	04		 DB	 4
  0014b	04		 DB	 4
  0014c	04		 DB	 4
  0014d	04		 DB	 4
  0014e	04		 DB	 4
  0014f	04		 DB	 4
  00150	04		 DB	 4
  00151	03		 DB	 3
?lssproto_TEACHER_SYSTEM_recv@@YAXHPAD@Z ENDP		; lssproto_TEACHER_SYSTEM_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_JOBDAILY_recv@@YAXHPAD@Z
_TEXT	SEGMENT
tv87 = -932						; size = 4
$T1 = -924						; size = 4
$T2 = -912						; size = 4
$T3 = -900						; size = 4
$T4 = -888						; size = 4
_perdata$ = -492					; size = 200
_getdata$ = -284					; size = 250
_j$ = -24						; size = 4
_i$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_JOBDAILY_recv@@YAXHPAD@Z PROC			; lssproto_JOBDAILY_recv, COMDAT

; 4584 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 03 00
	00		 sub	 esp, 932		; 000003a4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 5c fc ff
	ff		 lea	 edi, DWORD PTR [ebp-932]
  00012	b9 e9 00 00 00	 mov	 ecx, 233		; 000000e9H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4585 : 	//解读资料
; 4586 : 	int  i=1,j=1;

  00028	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  0002f	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _j$[ebp], 1

; 4587 : 	char getdata[250];
; 4588 : 	char perdata[200];
; 4589 : 
; 4590 : 	//StockChatBufferLine(data,FONT_PAL_RED); 
; 4591 : 
; 4592 : 	memset(jobdaily,0,sizeof(jobdaily));

  00036	68 20 fd 00 00	 push	 64800			; 0000fd20H
  0003b	6a 00		 push	 0
  0003d	68 00 00 00 00	 push	 OFFSET ?jobdaily@@3PAUJOBDAILY@@A ; jobdaily
  00042	e8 00 00 00 00	 call	 _memset
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4593 : 	getdata[0] = '\0';

  0004a	b8 01 00 00 00	 mov	 eax, 1
  0004f	6b c8 00	 imul	 ecx, eax, 0
  00052	89 8d 88 fc ff
	ff		 mov	 DWORD PTR $T4[ebp], ecx
  00058	81 bd 88 fc ff
	ff fa 00 00 00	 cmp	 DWORD PTR $T4[ebp], 250	; 000000faH
  00062	73 02		 jae	 SHORT $LN15@lssproto_J
  00064	eb 05		 jmp	 SHORT $LN16@lssproto_J
$LN15@lssproto_J:
  00066	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN16@lssproto_J:
  0006b	8b 95 88 fc ff
	ff		 mov	 edx, DWORD PTR $T4[ebp]
  00071	c6 84 15 e4 fe
	ff ff 00	 mov	 BYTE PTR _getdata$[ebp+edx], 0

; 4594 : 	perdata[0] = '\0';

  00079	b8 01 00 00 00	 mov	 eax, 1
  0007e	6b c8 00	 imul	 ecx, eax, 0
  00081	89 8d 7c fc ff
	ff		 mov	 DWORD PTR $T3[ebp], ecx
  00087	81 bd 7c fc ff
	ff c8 00 00 00	 cmp	 DWORD PTR $T3[ebp], 200	; 000000c8H
  00091	73 02		 jae	 SHORT $LN17@lssproto_J
  00093	eb 05		 jmp	 SHORT $LN18@lssproto_J
$LN17@lssproto_J:
  00095	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN18@lssproto_J:
  0009a	8b 95 7c fc ff
	ff		 mov	 edx, DWORD PTR $T3[ebp]
  000a0	c6 84 15 14 fe
	ff ff 00	 mov	 BYTE PTR _perdata$[ebp+edx], 0
$LN2@lssproto_J:

; 4595 : 	while(getStringToken(data,'#',i,sizeof(getdata) - 1,getdata)!=1){

  000a8	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _getdata$[ebp]
  000ae	50		 push	 eax
  000af	68 f9 00 00 00	 push	 249			; 000000f9H
  000b4	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  000b7	51		 push	 ecx
  000b8	6a 23		 push	 35			; 00000023H
  000ba	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  000c3	83 c4 14	 add	 esp, 20			; 00000014H
  000c6	83 f8 01	 cmp	 eax, 1
  000c9	0f 84 57 01 00
	00		 je	 $LN3@lssproto_J
$LN4@lssproto_J:

; 4596 : 		while(getStringToken(getdata,'|',j,sizeof(perdata) - 1,perdata)!=1){

  000cf	8d 85 14 fe ff
	ff		 lea	 eax, DWORD PTR _perdata$[ebp]
  000d5	50		 push	 eax
  000d6	68 c7 00 00 00	 push	 199			; 000000c7H
  000db	8b 4d e8	 mov	 ecx, DWORD PTR _j$[ebp]
  000de	51		 push	 ecx
  000df	6a 7c		 push	 124			; 0000007cH
  000e1	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR _getdata$[ebp]
  000e7	52		 push	 edx
  000e8	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  000ed	83 c4 14	 add	 esp, 20			; 00000014H
  000f0	83 f8 01	 cmp	 eax, 1
  000f3	0f 84 e9 00 00
	00		 je	 $LN5@lssproto_J

; 4597 : 			switch (j){

  000f9	8b 45 e8	 mov	 eax, DWORD PTR _j$[ebp]
  000fc	89 85 5c fc ff
	ff		 mov	 DWORD PTR tv87[ebp], eax
  00102	83 bd 5c fc ff
	ff 01		 cmp	 DWORD PTR tv87[ebp], 1
  00109	74 14		 je	 SHORT $LN8@lssproto_J
  0010b	83 bd 5c fc ff
	ff 02		 cmp	 DWORD PTR tv87[ebp], 2
  00112	74 38		 je	 SHORT $LN9@lssproto_J
  00114	83 bd 5c fc ff
	ff 03		 cmp	 DWORD PTR tv87[ebp], 3
  0011b	74 53		 je	 SHORT $LN10@lssproto_J
  0011d	eb 75		 jmp	 SHORT $LN11@lssproto_J
$LN8@lssproto_J:

; 4598 : 			case 1: jobdaily[i-1].JobId = atoi(perdata);break;

  0011f	8b f4		 mov	 esi, esp
  00121	8d 85 14 fe ff
	ff		 lea	 eax, DWORD PTR _perdata$[ebp]
  00127	50		 push	 eax
  00128	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0012e	83 c4 04	 add	 esp, 4
  00131	3b f4		 cmp	 esi, esp
  00133	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00138	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0013b	83 e9 01	 sub	 ecx, 1
  0013e	69 d1 d8 00 00
	00		 imul	 edx, ecx, 216
  00144	89 82 00 00 00
	00		 mov	 DWORD PTR ?jobdaily@@3PAUJOBDAILY@@A[edx], eax
  0014a	eb 59		 jmp	 SHORT $LN6@lssproto_J
$LN9@lssproto_J:

; 4599 : 			case 2: strcpy(jobdaily[i-1].explain,perdata); break;

  0014c	8d 85 14 fe ff
	ff		 lea	 eax, DWORD PTR _perdata$[ebp]
  00152	50		 push	 eax
  00153	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00156	83 e9 01	 sub	 ecx, 1
  00159	69 d1 d8 00 00
	00		 imul	 edx, ecx, 216
  0015f	81 c2 04 00 00
	00		 add	 edx, OFFSET ?jobdaily@@3PAUJOBDAILY@@A+4
  00165	52		 push	 edx
  00166	e8 00 00 00 00	 call	 _strcpy
  0016b	83 c4 08	 add	 esp, 8
  0016e	eb 35		 jmp	 SHORT $LN6@lssproto_J
$LN10@lssproto_J:

; 4600 : 			case 3: strcpy(jobdaily[i-1].state,perdata); break;

  00170	8d 85 14 fe ff
	ff		 lea	 eax, DWORD PTR _perdata$[ebp]
  00176	50		 push	 eax
  00177	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0017a	83 e9 01	 sub	 ecx, 1
  0017d	69 d1 d8 00 00
	00		 imul	 edx, ecx, 216
  00183	81 c2 cc 00 00
	00		 add	 edx, OFFSET ?jobdaily@@3PAUJOBDAILY@@A+204
  00189	52		 push	 edx
  0018a	e8 00 00 00 00	 call	 _strcpy
  0018f	83 c4 08	 add	 esp, 8
  00192	eb 11		 jmp	 SHORT $LN6@lssproto_J
$LN11@lssproto_J:

; 4601 : 			default: StockChatBufferLine("每笔资料内参数有错误",FONT_PAL_RED); break;

  00194	6a 00		 push	 0
  00196	6a 06		 push	 6
  00198	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PEDECIPG@?X?$NP?$DP?$DP?V?y?$DP?$DP?$DP?j?s?$DP?$DP?$AA@
  0019d	e8 00 00 00 00	 call	 ?StockChatBufferLine@@YAXPADEH@Z ; StockChatBufferLine
  001a2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@lssproto_J:

; 4602 : 			}
; 4603 : 			perdata[0] = '\0';

  001a5	b8 01 00 00 00	 mov	 eax, 1
  001aa	6b c8 00	 imul	 ecx, eax, 0
  001ad	89 8d 70 fc ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  001b3	81 bd 70 fc ff
	ff c8 00 00 00	 cmp	 DWORD PTR $T2[ebp], 200	; 000000c8H
  001bd	73 02		 jae	 SHORT $LN19@lssproto_J
  001bf	eb 05		 jmp	 SHORT $LN20@lssproto_J
$LN19@lssproto_J:
  001c1	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN20@lssproto_J:
  001c6	8b 95 70 fc ff
	ff		 mov	 edx, DWORD PTR $T2[ebp]
  001cc	c6 84 15 14 fe
	ff ff 00	 mov	 BYTE PTR _perdata$[ebp+edx], 0

; 4604 : 			j++;

  001d4	8b 45 e8	 mov	 eax, DWORD PTR _j$[ebp]
  001d7	83 c0 01	 add	 eax, 1
  001da	89 45 e8	 mov	 DWORD PTR _j$[ebp], eax

; 4605 : 		}

  001dd	e9 ed fe ff ff	 jmp	 $LN4@lssproto_J
$LN5@lssproto_J:

; 4606 : 		getdata[0] = '\0';

  001e2	b8 01 00 00 00	 mov	 eax, 1
  001e7	6b c8 00	 imul	 ecx, eax, 0
  001ea	89 8d 64 fc ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  001f0	81 bd 64 fc ff
	ff fa 00 00 00	 cmp	 DWORD PTR $T1[ebp], 250	; 000000faH
  001fa	73 02		 jae	 SHORT $LN21@lssproto_J
  001fc	eb 05		 jmp	 SHORT $LN22@lssproto_J
$LN21@lssproto_J:
  001fe	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN22@lssproto_J:
  00203	8b 95 64 fc ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  00209	c6 84 15 e4 fe
	ff ff 00	 mov	 BYTE PTR _getdata$[ebp+edx], 0

; 4607 : 		j=1;

  00211	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _j$[ebp], 1

; 4608 : 		i++;

  00218	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0021b	83 c0 01	 add	 eax, 1
  0021e	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax

; 4609 : 	}

  00221	e9 82 fe ff ff	 jmp	 $LN2@lssproto_J
$LN3@lssproto_J:

; 4610 : 	if (i>1){ 

  00226	83 7d f4 01	 cmp	 DWORD PTR _i$[ebp], 1
  0022a	7e 17		 jle	 SHORT $LN12@lssproto_J

; 4611 : 		JobdailyGetFlag = TRUE;

  0022c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?JobdailyGetFlag@@3HA, 1 ; JobdailyGetFlag

; 4612 : 		JobdailyGetMax= i-2;

  00236	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00239	83 e8 02	 sub	 eax, 2
  0023c	a3 00 00 00 00	 mov	 DWORD PTR ?JobdailyGetMax@@3HA, eax ; JobdailyGetMax

; 4613 : 	}else{

  00241	eb 14		 jmp	 SHORT $LN14@lssproto_J
$LN12@lssproto_J:

; 4614 : 		JobdailyGetFlag = FALSE;

  00243	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?JobdailyGetFlag@@3HA, 0 ; JobdailyGetFlag

; 4615 : 		JobdailyGetMax = -1;

  0024d	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?JobdailyGetMax@@3HA, -1 ; JobdailyGetMax
$LN14@lssproto_J:

; 4616 : 	}
; 4617 : }

  00257	52		 push	 edx
  00258	8b cd		 mov	 ecx, ebp
  0025a	50		 push	 eax
  0025b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN26@lssproto_J
  00261	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00266	58		 pop	 eax
  00267	5a		 pop	 edx
  00268	5f		 pop	 edi
  00269	5e		 pop	 esi
  0026a	5b		 pop	 ebx
  0026b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0026e	33 cd		 xor	 ecx, ebp
  00270	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00275	81 c4 a4 03 00
	00		 add	 esp, 932		; 000003a4H
  0027b	3b ec		 cmp	 ebp, esp
  0027d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00282	8b e5		 mov	 esp, ebp
  00284	5d		 pop	 ebp
  00285	c3		 ret	 0
  00286	66 90		 npad	 2
$LN26@lssproto_J:
  00288	02 00 00 00	 DD	 2
  0028c	00 00 00 00	 DD	 $LN25@lssproto_J
$LN25@lssproto_J:
  00290	e4 fe ff ff	 DD	 -284			; fffffee4H
  00294	fa 00 00 00	 DD	 250			; 000000faH
  00298	00 00 00 00	 DD	 $LN23@lssproto_J
  0029c	14 fe ff ff	 DD	 -492			; fffffe14H
  002a0	c8 00 00 00	 DD	 200			; 000000c8H
  002a4	00 00 00 00	 DD	 $LN24@lssproto_J
$LN24@lssproto_J:
  002a8	70		 DB	 112			; 00000070H
  002a9	65		 DB	 101			; 00000065H
  002aa	72		 DB	 114			; 00000072H
  002ab	64		 DB	 100			; 00000064H
  002ac	61		 DB	 97			; 00000061H
  002ad	74		 DB	 116			; 00000074H
  002ae	61		 DB	 97			; 00000061H
  002af	00		 DB	 0
$LN23@lssproto_J:
  002b0	67		 DB	 103			; 00000067H
  002b1	65		 DB	 101			; 00000065H
  002b2	74		 DB	 116			; 00000074H
  002b3	64		 DB	 100			; 00000064H
  002b4	61		 DB	 97			; 00000061H
  002b5	74		 DB	 116			; 00000074H
  002b6	61		 DB	 97			; 00000061H
  002b7	00		 DB	 0
?lssproto_JOBDAILY_recv@@YAXHPAD@Z ENDP			; lssproto_JOBDAILY_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_STREET_VENDOR_recv@@YAXHPAD@Z
_TEXT	SEGMENT
tv72 = -240						; size = 4
_szMessage$ = -40					; size = 32
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_STREET_VENDOR_recv@@YAXHPAD@Z PROC		; lssproto_STREET_VENDOR_recv, COMDAT

; 4547 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4548 : 	char szMessage[32];
; 4549 : 
; 4550 : 	getStringToken(data,'|',1,sizeof(szMessage) - 1,szMessage);

  00028	8d 45 d8	 lea	 eax, DWORD PTR _szMessage$[ebp]
  0002b	50		 push	 eax
  0002c	6a 1f		 push	 31			; 0000001fH
  0002e	6a 01		 push	 1
  00030	6a 7c		 push	 124			; 0000007cH
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0003b	83 c4 14	 add	 esp, 20			; 00000014H

; 4551 : 	switch (szMessage[0]){

  0003e	b8 01 00 00 00	 mov	 eax, 1
  00043	6b c8 00	 imul	 ecx, eax, 0
  00046	0f be 54 0d d8	 movsx	 edx, BYTE PTR _szMessage$[ebp+ecx]
  0004b	89 95 10 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
  00051	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00057	83 e8 42	 sub	 eax, 66			; 00000042H
  0005a	89 85 10 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
  00060	83 bd 10 ff ff
	ff 11		 cmp	 DWORD PTR tv72[ebp], 17	; 00000011H
  00067	77 75		 ja	 SHORT $LN1@lssproto_S
  00069	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR tv72[ebp]
  0006f	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN10@lssproto_S[ecx]
  00076	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN14@lssproto_S[edx*4]
$LN4@lssproto_S:

; 4552 : 		// 开新摆摊介面
; 4553 : 		case 'O':
; 4554 : 			sStreetVendorBtn = 1;

  0007d	b8 01 00 00 00	 mov	 eax, 1
  00082	66 a3 00 00 00
	00		 mov	 WORD PTR ?sStreetVendorBtn@@3FA, ax ; sStreetVendorBtn

; 4555 : 			pc.iOnStreetVendor = 1;

  00088	c7 05 b8 a1 00
	00 01 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+41400, 1

; 4556 : 			break;

  00092	eb 4a		 jmp	 SHORT $LN1@lssproto_S
$LN5@lssproto_S:

; 4557 : 		// 设定摆摊内容
; 4558 : 		case 'S':
; 4559 : 			sStreetVendorBtn = 3;

  00094	b8 03 00 00 00	 mov	 eax, 3
  00099	66 a3 00 00 00
	00		 mov	 WORD PTR ?sStreetVendorBtn@@3FA, ax ; sStreetVendorBtn

; 4560 : 			StreetVendorWndfunc(false,data);

  0009f	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  000a2	50		 push	 eax
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 ?StreetVendorWndfunc@@YAX_NPAD@Z ; StreetVendorWndfunc
  000aa	83 c4 08	 add	 esp, 8

; 4561 : 			break;

  000ad	eb 2f		 jmp	 SHORT $LN1@lssproto_S
$LN6@lssproto_S:

; 4562 : 		// server送来的卖方贩卖内容
; 4563 : 		case 'B':
; 4564 : 			sStreetVendorBuyBtn = 1;

  000af	b8 01 00 00 00	 mov	 eax, 1
  000b4	66 a3 00 00 00
	00		 mov	 WORD PTR ?sStreetVendorBuyBtn@@3FA, ax ; sStreetVendorBuyBtn

; 4565 : 			StreetVendorBuyWndfunc(data);

  000ba	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 ?StreetVendorBuyWndfunc@@YAXPAD@Z ; StreetVendorBuyWndfunc
  000c3	83 c4 04	 add	 esp, 4

; 4566 : 			break;

  000c6	eb 16		 jmp	 SHORT $LN1@lssproto_S
$LN7@lssproto_S:

; 4567 : 		// server 送来关闭视窗
; 4568 : 		case 'C':
; 4569 : 			sStreetVendorBuyBtn = 0;

  000c8	33 c0		 xor	 eax, eax
  000ca	66 a3 00 00 00
	00		 mov	 WORD PTR ?sStreetVendorBuyBtn@@3FA, ax ; sStreetVendorBuyBtn

; 4570 : 			break;

  000d0	eb 0c		 jmp	 SHORT $LN1@lssproto_S
$LN8@lssproto_S:

; 4571 : 		// server 送来的单笔贩卖物详细资料
; 4572 : 		case 'D':
; 4573 : 			StreetVendorBuyWndfunc(data);

  000d2	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 ?StreetVendorBuyWndfunc@@YAXPAD@Z ; StreetVendorBuyWndfunc
  000db	83 c4 04	 add	 esp, 4
$LN1@lssproto_S:

; 4574 : 			break;
; 4575 : 	}
; 4576 : }

  000de	52		 push	 edx
  000df	8b cd		 mov	 ecx, ebp
  000e1	50		 push	 eax
  000e2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@lssproto_S
  000e8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000ed	58		 pop	 eax
  000ee	5a		 pop	 edx
  000ef	5f		 pop	 edi
  000f0	5e		 pop	 esi
  000f1	5b		 pop	 ebx
  000f2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f5	33 cd		 xor	 ecx, ebp
  000f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fc	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00102	3b ec		 cmp	 ebp, esp
  00104	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c3		 ret	 0
  0010d	0f 1f 00	 npad	 3
$LN13@lssproto_S:
  00110	01 00 00 00	 DD	 1
  00114	00 00 00 00	 DD	 $LN12@lssproto_S
$LN12@lssproto_S:
  00118	d8 ff ff ff	 DD	 -40			; ffffffd8H
  0011c	20 00 00 00	 DD	 32			; 00000020H
  00120	00 00 00 00	 DD	 $LN11@lssproto_S
$LN11@lssproto_S:
  00124	73		 DB	 115			; 00000073H
  00125	7a		 DB	 122			; 0000007aH
  00126	4d		 DB	 77			; 0000004dH
  00127	65		 DB	 101			; 00000065H
  00128	73		 DB	 115			; 00000073H
  00129	73		 DB	 115			; 00000073H
  0012a	61		 DB	 97			; 00000061H
  0012b	67		 DB	 103			; 00000067H
  0012c	65		 DB	 101			; 00000065H
  0012d	00		 DB	 0
  0012e	66 90		 npad	 2
$LN14@lssproto_S:
  00130	00 00 00 00	 DD	 $LN6@lssproto_S
  00134	00 00 00 00	 DD	 $LN7@lssproto_S
  00138	00 00 00 00	 DD	 $LN8@lssproto_S
  0013c	00 00 00 00	 DD	 $LN4@lssproto_S
  00140	00 00 00 00	 DD	 $LN5@lssproto_S
  00144	00 00 00 00	 DD	 $LN1@lssproto_S
$LN10@lssproto_S:
  00148	00		 DB	 0
  00149	01		 DB	 1
  0014a	02		 DB	 2
  0014b	05		 DB	 5
  0014c	05		 DB	 5
  0014d	05		 DB	 5
  0014e	05		 DB	 5
  0014f	05		 DB	 5
  00150	05		 DB	 5
  00151	05		 DB	 5
  00152	05		 DB	 5
  00153	05		 DB	 5
  00154	05		 DB	 5
  00155	03		 DB	 3
  00156	05		 DB	 5
  00157	05		 DB	 5
  00158	05		 DB	 5
  00159	04		 DB	 4
?lssproto_STREET_VENDOR_recv@@YAXHPAD@Z ENDP		; lssproto_STREET_VENDOR_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_PETST_recv@@YAXHHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_petarray$ = 12						; size = 4
_result$ = 16						; size = 4
?lssproto_PETST_recv@@YAXHHH@Z PROC			; lssproto_PETST_recv, COMDAT

; 3899 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3900 : 	if ( petarray < 0 || petarray >= 5 ) return;

  0001e	83 7d 0c 00	 cmp	 DWORD PTR _petarray$[ebp], 0
  00022	7c 06		 jl	 SHORT $LN3@lssproto_P
  00024	83 7d 0c 05	 cmp	 DWORD PTR _petarray$[ebp], 5
  00028	7c 02		 jl	 SHORT $LN2@lssproto_P
$LN3@lssproto_P:
  0002a	eb 50		 jmp	 SHORT $LN1@lssproto_P
$LN2@lssproto_P:

; 3901 : 	pc.selectPetNo[ petarray] = result;

  0002c	8b 45 0c	 mov	 eax, DWORD PTR _petarray$[ebp]
  0002f	66 8b 4d 10	 mov	 cx, WORD PTR _result$[ebp]
  00033	66 89 0c 45 ac
	00 00 00	 mov	 WORD PTR ?pc@@3UPC@@A[eax*2+172], cx

; 3902 : 	BattlePetStMenCnt--;

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BattlePetStMenCnt@@3HA ; BattlePetStMenCnt
  00040	83 e8 01	 sub	 eax, 1
  00043	a3 00 00 00 00	 mov	 DWORD PTR ?BattlePetStMenCnt@@3HA, eax ; BattlePetStMenCnt

; 3903 : 	if ( BattlePetStMenCnt < 0 ) BattlePetStMenCnt = 0;

  00048	79 0a		 jns	 SHORT $LN4@lssproto_P
  0004a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BattlePetStMenCnt@@3HA, 0 ; BattlePetStMenCnt
$LN4@lssproto_P:

; 3904 : 	if ( BattlePetStMenCnt > 等待宠数量) BattlePetStMenCnt = 等待宠数量;

  00054	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR ?BattlePetStMenCnt@@3HA, 5 ; BattlePetStMenCnt
  0005b	7e 0a		 jle	 SHORT $LN5@lssproto_P
  0005d	c7 05 00 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?BattlePetStMenCnt@@3HA, 5 ; BattlePetStMenCnt
$LN5@lssproto_P:

; 3905 : 	if ( pc.battlePetNo == petarray )

  00067	0f bf 05 aa 00
	00 00		 movsx	 eax, WORD PTR ?pc@@3UPC@@A+170
  0006e	3b 45 0c	 cmp	 eax, DWORD PTR _petarray$[ebp]
  00071	75 09		 jne	 SHORT $LN1@lssproto_P

; 3906 : 		pc.battlePetNo = -1;

  00073	83 c8 ff	 or	 eax, -1
  00076	66 a3 aa 00 00
	00		 mov	 WORD PTR ?pc@@3UPC@@A+170, ax
$LN1@lssproto_P:

; 3907 : }

  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
?lssproto_PETST_recv@@YAXHHH@Z ENDP			; lssproto_PETST_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_NC_recv@@YAXHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_flg$ = 12						; size = 4
?lssproto_NC_recv@@YAXHH@Z PROC				; lssproto_NC_recv, COMDAT

; 4449 : {  

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 4450 : 	if (flg==1 )

  0001e	83 7d 0c 01	 cmp	 DWORD PTR _flg$[ebp], 1
  00022	75 0c		 jne	 SHORT $LN2@lssproto_N

; 4451 : 		NoCastFlag=TRUE;

  00024	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?NoCastFlag@@3HA, 1 ; NoCastFlag

; 4452 :     else 

  0002e	eb 0a		 jmp	 SHORT $LN1@lssproto_N
$LN2@lssproto_N:

; 4453 : 		NoCastFlag=FALSE;

  00030	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?NoCastFlag@@3HA, 0 ; NoCastFlag
$LN1@lssproto_N:

; 4454 : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?lssproto_NC_recv@@YAXHH@Z ENDP				; lssproto_NC_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_IC_recv@@YAXHHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
?lssproto_IC_recv@@YAXHHH@Z PROC			; lssproto_IC_recv, COMDAT

; 4424 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 4425 : 	m_bt = true; setCharMind( pc.ptAct, SPR_cracker);	

  0001e	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?m_bt@@3_NA, 1	; m_bt
  00025	68 19 8c 01 00	 push	 101401			; 00018c19H
  0002a	a1 ec 50 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+20716
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ?setCharMind@@YAXPAUaction@@H@Z ; setCharMind
  00035	83 c4 08	 add	 esp, 8

; 4426 : 	m_bt = false;

  00038	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?m_bt@@3_NA, 0	; m_bt

; 4427 : }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00048	3b ec		 cmp	 ebp, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
?lssproto_IC_recv@@YAXHHH@Z ENDP			; lssproto_IC_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_WO_recv@@YAXHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_effect$ = 12						; size = 4
?lssproto_WO_recv@@YAXHH@Z PROC				; lssproto_WO_recv, COMDAT

; 4100 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 4101 : 	return;

  0001e	eb 2e		 jmp	 SHORT $LN1@lssproto_W

; 4102 : 	// ???????
; 4103 : 	if ( effect == 0 )

  00020	83 7d 0c 00	 cmp	 DWORD PTR _effect$[ebp], 0
  00024	75 28		 jne	 SHORT $LN1@lssproto_W

; 4104 : 	{
; 4105 : 		// ????????
; 4106 : 		transmigrationEffectFlag = 1;

  00026	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?transmigrationEffectFlag@@3HA, 1 ; transmigrationEffectFlag

; 4107 : 		// ?????????????
; 4108 : 		transEffectPaletteStatus = 1;

  00030	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?transEffectPaletteStatus@@3HA, 1 ; transEffectPaletteStatus

; 4109 : 		// ????????
; 4110 : 		palNo = 15;

  0003a	c7 05 00 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?palNo@@3HA, 15 ; palNo, 0000000fH

; 4111 : 		palTime = 300;

  00044	c7 05 00 00 00
	00 2c 01 00 00	 mov	 DWORD PTR ?palTime@@3HA, 300 ; palTime, 0000012cH
$LN1@lssproto_W:

; 4112 : 	}
; 4113 : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?lssproto_WO_recv@@YAXHH@Z ENDP				; lssproto_WO_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_FM_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_FMType3$ = -1560					; size = 512
_FMType2$ = -1040					; size = 512
_FMType1$ = -520					; size = 512
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_FM_recv@@YAXHPAD@Z PROC			; lssproto_FM_recv, COMDAT

; 4186 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 1c 09 00
	00		 sub	 esp, 2332		; 0000091cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e4 f6 ff
	ff		 lea	 edi, DWORD PTR [ebp-2332]
  00012	b9 47 02 00 00	 mov	 ecx, 583		; 00000247H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4187 : 	char FMType1[512];
; 4188 : 	char FMType2[512];
; 4189 : 	char FMType3[512];
; 4190 : 	
; 4191 : 	getStringToken(data, '|', 1, sizeof( FMType1 ) - 1, FMType1 );

  00028	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _FMType1$[ebp]
  0002e	50		 push	 eax
  0002f	68 ff 01 00 00	 push	 511			; 000001ffH
  00034	6a 01		 push	 1
  00036	6a 7c		 push	 124			; 0000007cH
  00038	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00041	83 c4 14	 add	 esp, 20			; 00000014H

; 4192 : 	//makeStringFromEscaped( FMType1 );
; 4193 : 	getStringToken(data, '|', 2, sizeof( FMType2 ) - 1, FMType2 );

  00044	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _FMType2$[ebp]
  0004a	50		 push	 eax
  0004b	68 ff 01 00 00	 push	 511			; 000001ffH
  00050	6a 02		 push	 2
  00052	6a 7c		 push	 124			; 0000007cH
  00054	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00057	51		 push	 ecx
  00058	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0005d	83 c4 14	 add	 esp, 20			; 00000014H

; 4194 : 	//makeStringFromEscaped( FMType2 );
; 4195 : 
; 4196 : 	if ( strcmp(FMType1,"S") ==0 )

  00060	68 00 00 00 00	 push	 OFFSET ??_C@_01CPLAODJH@S?$AA@
  00065	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _FMType1$[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 _strcmp
  00071	83 c4 08	 add	 esp, 8
  00074	85 c0		 test	 eax, eax
  00076	75 4d		 jne	 SHORT $LN2@lssproto_F

; 4197 : 	{
; 4198 : 		if ( strcmp(FMType2,"F") ==0) // 家族列表

  00078	68 00 00 00 00	 push	 OFFSET ??_C@_01BIAFAFID@F?$AA@
  0007d	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _FMType2$[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 _strcmp
  00089	83 c4 08	 add	 esp, 8
  0008c	85 c0		 test	 eax, eax
  0008e	75 0c		 jne	 SHORT $LN4@lssproto_F

; 4199 : 		{
; 4200 : 			initFamilyList(data );

  00090	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 ?initFamilyList@@YAXPAD@Z ; initFamilyList
  00099	83 c4 04	 add	 esp, 4
$LN4@lssproto_F:

; 4201 : 
; 4202 : 		}
; 4203 : 		if ( strcmp(FMType2,"D") ==0) // 家族详细

  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_01CKDDGHAB@D?$AA@
  000a1	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _FMType2$[ebp]
  000a7	50		 push	 eax
  000a8	e8 00 00 00 00	 call	 _strcmp
  000ad	83 c4 08	 add	 esp, 8
  000b0	85 c0		 test	 eax, eax
  000b2	75 0c		 jne	 SHORT $LN5@lssproto_F

; 4204 : 		{
; 4205 : 			initFamilyDetail(data );

  000b4	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 ?initFamilyDetail@@YAXPAD@Z ; initFamilyDetail
  000bd	83 c4 04	 add	 esp, 4
$LN5@lssproto_F:

; 4206 : 
; 4207 : 		}
; 4208 : 
; 4209 : 	}

  000c0	e9 cb 01 00 00	 jmp	 $LN1@lssproto_F
$LN2@lssproto_F:

; 4210 : 	else if ( strcmp(FMType1,"C") ==0 )

  000c5	68 00 00 00 00	 push	 OFFSET ??_C@_01GFHCPBMG@C?$AA@
  000ca	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _FMType1$[ebp]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 _strcmp
  000d6	83 c4 08	 add	 esp, 8
  000d9	85 c0		 test	 eax, eax
  000db	0f 85 8e 00 00
	00		 jne	 $LN6@lssproto_F

; 4211 : 	{
; 4212 : 		if ( strcmp(FMType2,"J") ==0) // 加入频道

  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_01LELAEKIP@J?$AA@
  000e6	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _FMType2$[ebp]
  000ec	50		 push	 eax
  000ed	e8 00 00 00 00	 call	 _strcmp
  000f2	83 c4 08	 add	 esp, 8
  000f5	85 c0		 test	 eax, eax
  000f7	75 4d		 jne	 SHORT $LN8@lssproto_F

; 4213 : 		{
; 4214 : 			getStringToken(data, '|', 3, sizeof( FMType3 ) - 1, FMType3 );

  000f9	8d 85 e8 f9 ff
	ff		 lea	 eax, DWORD PTR _FMType3$[ebp]
  000ff	50		 push	 eax
  00100	68 ff 01 00 00	 push	 511			; 000001ffH
  00105	6a 03		 push	 3
  00107	6a 7c		 push	 124			; 0000007cH
  00109	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0010c	51		 push	 ecx
  0010d	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00112	83 c4 14	 add	 esp, 20			; 00000014H

; 4215 : 			pc.channel = atoi( FMType3 );

  00115	8b f4		 mov	 esi, esp
  00117	8d 85 e8 f9 ff
	ff		 lea	 eax, DWORD PTR _FMType3$[ebp]
  0011d	50		 push	 eax
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00124	83 c4 04	 add	 esp, 4
  00127	3b f4		 cmp	 esi, esp
  00129	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012e	a3 0c 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20748, eax

; 4216 : 			if ( pc.channel != -1 )

  00133	83 3d 0c 51 00
	00 ff		 cmp	 DWORD PTR ?pc@@3UPC@@A+20748, -1
  0013a	74 0a		 je	 SHORT $LN8@lssproto_F

; 4217 : 				pc.quickChannel = pc.channel;

  0013c	a1 0c 51 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+20748
  00141	a3 10 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20752, eax
$LN8@lssproto_F:

; 4218 : 		}
; 4219 : 		if ( strcmp(FMType2,"L") ==0) // 频道列表

  00146	68 00 00 00 00	 push	 OFFSET ??_C@_01OCOKONAJ@L?$AA@
  0014b	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _FMType2$[ebp]
  00151	50		 push	 eax
  00152	e8 00 00 00 00	 call	 _strcmp
  00157	83 c4 08	 add	 esp, 8
  0015a	85 c0		 test	 eax, eax
  0015c	75 0c		 jne	 SHORT $LN10@lssproto_F

; 4220 : 		{
; 4221 : 			initJoinChannel2WN(data );

  0015e	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00161	50		 push	 eax
  00162	e8 00 00 00 00	 call	 ?initJoinChannel2WN@@YAXPAD@Z ; initJoinChannel2WN
  00167	83 c4 04	 add	 esp, 4
$LN10@lssproto_F:

; 4222 : 
; 4223 : 		}
; 4224 : 	}

  0016a	e9 21 01 00 00	 jmp	 $LN1@lssproto_F
$LN6@lssproto_F:

; 4225 : 	else if ( strcmp(FMType1,"B") ==0 )

  0016f	68 00 00 00 00	 push	 OFFSET ??_C@_01HMGJMAIH@B?$AA@
  00174	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _FMType1$[ebp]
  0017a	50		 push	 eax
  0017b	e8 00 00 00 00	 call	 _strcmp
  00180	83 c4 08	 add	 esp, 8
  00183	85 c0		 test	 eax, eax
  00185	75 61		 jne	 SHORT $LN11@lssproto_F

; 4226 : 	{
; 4227 : 
; 4228 : 		//MenuToggleFlag = JOY_CTRL_B;
; 4229 : 		if ( strcmp(FMType2,"G") ==0)

  00187	68 00 00 00 00	 push	 OFFSET ??_C@_01BBODEMC@G?$AA@
  0018c	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _FMType2$[ebp]
  00192	50		 push	 eax
  00193	e8 00 00 00 00	 call	 _strcmp
  00198	83 c4 08	 add	 esp, 8
  0019b	85 c0		 test	 eax, eax
  0019d	75 0c		 jne	 SHORT $LN13@lssproto_F

; 4230 : 		{
; 4231 : 			//getStringToken(data, '|', 3, sizeof( FMType3 ) - 1, FMType3 );
; 4232 : 			BankmanInit(data );

  0019f	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  001a2	50		 push	 eax
  001a3	e8 00 00 00 00	 call	 ?BankmanInit@@YAXPAD@Z	; BankmanInit
  001a8	83 c4 04	 add	 esp, 4
$LN13@lssproto_F:

; 4233 : 		}
; 4234 : 		if ( strcmp(FMType2,"I") ==0)

  001ab	68 00 00 00 00	 push	 OFFSET ??_C@_01JPJNBJEM@I?$AA@
  001b0	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _FMType2$[ebp]
  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 _strcmp
  001bc	83 c4 08	 add	 esp, 8

; 4235 : 		{
; 4236 : 			//getStringToken(data, '|', 3, sizeof( FMType3 ) - 1, FMType3 );
; 4237 : 			//ItemmanInit(data );
; 4238 : 			//initItemman(data );
; 4239 : 		}
; 4240 : 		if ( strcmp(FMType2,"T") ==0)

  001bf	68 00 00 00 00	 push	 OFFSET ??_C@_01GAPBHFFA@T?$AA@
  001c4	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _FMType2$[ebp]
  001ca	50		 push	 eax
  001cb	e8 00 00 00 00	 call	 _strcmp
  001d0	83 c4 08	 add	 esp, 8
  001d3	85 c0		 test	 eax, eax
  001d5	75 0c		 jne	 SHORT $LN15@lssproto_F

; 4241 : 		{
; 4242 : 			initFamilyTaxWN(data );

  001d7	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  001da	50		 push	 eax
  001db	e8 00 00 00 00	 call	 ?initFamilyTaxWN@@YAXPAD@Z ; initFamilyTaxWN
  001e0	83 c4 04	 add	 esp, 4
$LN15@lssproto_F:

; 4243 : 		}
; 4244 : 
; 4245 : 
; 4246 : 	}

  001e3	e9 a8 00 00 00	 jmp	 $LN1@lssproto_F
$LN11@lssproto_F:

; 4247 : 	else if ( strcmp(FMType1,"R") ==0 )

  001e8	68 00 00 00 00	 push	 OFFSET ??_C@_01DGKLNCNG@R?$AA@
  001ed	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _FMType1$[ebp]
  001f3	50		 push	 eax
  001f4	e8 00 00 00 00	 call	 _strcmp
  001f9	83 c4 08	 add	 esp, 8
  001fc	85 c0		 test	 eax, eax
  001fe	75 54		 jne	 SHORT $LN16@lssproto_F

; 4248 : 	{
; 4249 : 		if ( strcmp(FMType2,"P") ==0) // ride Pet

  00200	68 00 00 00 00	 push	 OFFSET ??_C@_01EJNLAFE@P?$AA@
  00205	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _FMType2$[ebp]
  0020b	50		 push	 eax
  0020c	e8 00 00 00 00	 call	 _strcmp
  00211	83 c4 08	 add	 esp, 8
  00214	85 c0		 test	 eax, eax
  00216	75 3a		 jne	 SHORT $LN18@lssproto_F

; 4250 : 		{
; 4251 : 			//initFamilyList(data );
; 4252 : 			getStringToken(data, '|', 3, sizeof( FMType3 ) - 1, FMType3 );

  00218	8d 85 e8 f9 ff
	ff		 lea	 eax, DWORD PTR _FMType3$[ebp]
  0021e	50		 push	 eax
  0021f	68 ff 01 00 00	 push	 511			; 000001ffH
  00224	6a 03		 push	 3
  00226	6a 7c		 push	 124			; 0000007cH
  00228	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0022b	51		 push	 ecx
  0022c	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00231	83 c4 14	 add	 esp, 20			; 00000014H

; 4253 : 			pc.ridePetNo = atoi( FMType3 );

  00234	8b f4		 mov	 esi, esp
  00236	8d 85 e8 f9 ff
	ff		 lea	 eax, DWORD PTR _FMType3$[ebp]
  0023c	50		 push	 eax
  0023d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00243	83 c4 04	 add	 esp, 4
  00246	3b f4		 cmp	 esi, esp
  00248	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0024d	a3 18 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20760, eax
$LN18@lssproto_F:

; 4254 : 
; 4255 : 		}
; 4256 : 
; 4257 : 	}

  00252	eb 3c		 jmp	 SHORT $LN1@lssproto_F
$LN16@lssproto_F:

; 4258 : 	else if ( strcmp(FMType1,"L") ==0 )	// 族长功能

  00254	68 00 00 00 00	 push	 OFFSET ??_C@_01OCOKONAJ@L?$AA@
  00259	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _FMType1$[ebp]
  0025f	50		 push	 eax
  00260	e8 00 00 00 00	 call	 _strcmp
  00265	83 c4 08	 add	 esp, 8
  00268	85 c0		 test	 eax, eax
  0026a	75 24		 jne	 SHORT $LN1@lssproto_F

; 4259 : 	{
; 4260 : 		if ( strcmp(FMType2,"CHANGE") ==0)

  0026c	68 00 00 00 00	 push	 OFFSET ??_C@_06BCPILJJG@CHANGE?$AA@
  00271	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _FMType2$[ebp]
  00277	50		 push	 eax
  00278	e8 00 00 00 00	 call	 _strcmp
  0027d	83 c4 08	 add	 esp, 8
  00280	85 c0		 test	 eax, eax
  00282	75 0c		 jne	 SHORT $LN1@lssproto_F

; 4261 : 		{
; 4262 : 			initFamilyLeaderChange(data );

  00284	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00287	50		 push	 eax
  00288	e8 00 00 00 00	 call	 ?initFamilyLeaderChange@@YAXPAD@Z ; initFamilyLeaderChange
  0028d	83 c4 04	 add	 esp, 4
$LN1@lssproto_F:

; 4263 : 		}
; 4264 : 	}
; 4265 : 
; 4266 : }

  00290	52		 push	 edx
  00291	8b cd		 mov	 ecx, ebp
  00293	50		 push	 eax
  00294	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN26@lssproto_F
  0029a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0029f	58		 pop	 eax
  002a0	5a		 pop	 edx
  002a1	5f		 pop	 edi
  002a2	5e		 pop	 esi
  002a3	5b		 pop	 ebx
  002a4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a7	33 cd		 xor	 ecx, ebp
  002a9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ae	81 c4 1c 09 00
	00		 add	 esp, 2332		; 0000091cH
  002b4	3b ec		 cmp	 ebp, esp
  002b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002bb	8b e5		 mov	 esp, ebp
  002bd	5d		 pop	 ebp
  002be	c3		 ret	 0
  002bf	90		 npad	 1
$LN26@lssproto_F:
  002c0	03 00 00 00	 DD	 3
  002c4	00 00 00 00	 DD	 $LN25@lssproto_F
$LN25@lssproto_F:
  002c8	f8 fd ff ff	 DD	 -520			; fffffdf8H
  002cc	00 02 00 00	 DD	 512			; 00000200H
  002d0	00 00 00 00	 DD	 $LN22@lssproto_F
  002d4	f0 fb ff ff	 DD	 -1040			; fffffbf0H
  002d8	00 02 00 00	 DD	 512			; 00000200H
  002dc	00 00 00 00	 DD	 $LN23@lssproto_F
  002e0	e8 f9 ff ff	 DD	 -1560			; fffff9e8H
  002e4	00 02 00 00	 DD	 512			; 00000200H
  002e8	00 00 00 00	 DD	 $LN24@lssproto_F
$LN24@lssproto_F:
  002ec	46		 DB	 70			; 00000046H
  002ed	4d		 DB	 77			; 0000004dH
  002ee	54		 DB	 84			; 00000054H
  002ef	79		 DB	 121			; 00000079H
  002f0	70		 DB	 112			; 00000070H
  002f1	65		 DB	 101			; 00000065H
  002f2	33		 DB	 51			; 00000033H
  002f3	00		 DB	 0
$LN23@lssproto_F:
  002f4	46		 DB	 70			; 00000046H
  002f5	4d		 DB	 77			; 0000004dH
  002f6	54		 DB	 84			; 00000054H
  002f7	79		 DB	 121			; 00000079H
  002f8	70		 DB	 112			; 00000070H
  002f9	65		 DB	 101			; 00000065H
  002fa	32		 DB	 50			; 00000032H
  002fb	00		 DB	 0
$LN22@lssproto_F:
  002fc	46		 DB	 70			; 00000046H
  002fd	4d		 DB	 77			; 0000004dH
  002fe	54		 DB	 84			; 00000054H
  002ff	79		 DB	 121			; 00000079H
  00300	70		 DB	 112			; 00000070H
  00301	65		 DB	 101			; 00000065H
  00302	31		 DB	 49			; 00000031H
  00303	00		 DB	 0
?lssproto_FM_recv@@YAXHPAD@Z ENDP			; lssproto_FM_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_NU_recv@@YAXHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_AddCount$ = 12						; size = 4
?lssproto_NU_recv@@YAXHH@Z PROC				; lssproto_NU_recv, COMDAT

; 4132 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 4133 : 	//JL 2016.11.13  90号包，走路步数
; 4134 : 	return;

  0001e	eb 22		 jmp	 SHORT $LN1@lssproto_N

; 4135 : 
; 4136 : 
; 4137 : 	if ( AddCount < 0 )

  00020	83 7d 0c 00	 cmp	 DWORD PTR _AddCount$[ebp], 0
  00024	7d 0f		 jge	 SHORT $LN2@lssproto_N

; 4138 : 		SendCount += AddCount;

  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SendCount@@3HA ; SendCount
  0002b	03 45 0c	 add	 eax, DWORD PTR _AddCount$[ebp]
  0002e	a3 00 00 00 00	 mov	 DWORD PTR ?SendCount@@3HA, eax ; SendCount

; 4139 : 	else

  00033	eb 0d		 jmp	 SHORT $LN1@lssproto_N
$LN2@lssproto_N:

; 4140 : 		SendCount += AddCount;

  00035	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SendCount@@3HA ; SendCount
  0003a	03 45 0c	 add	 eax, DWORD PTR _AddCount$[ebp]
  0003d	a3 00 00 00 00	 mov	 DWORD PTR ?SendCount@@3HA, eax ; SendCount
$LN1@lssproto_N:

; 4141 : }

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?lssproto_NU_recv@@YAXHH@Z ENDP				; lssproto_NU_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_Echo_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_test$ = 12						; size = 4
?lssproto_Echo_recv@@YAXHPAD@Z PROC			; lssproto_Echo_recv, COMDAT

; 4117 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 4118 : #if 1
; 4119 : #ifdef  _STONDEBUG__MSG
; 4120 : 
; 4121 : 	// ???T??瑗x
; 4122 : 	time( &serverAliveLongTime );
; 4123 : 	serverAliveTime = localtime( &serverAliveLongTime );
; 4124 : 
; 4125 : #endif
; 4126 : #endif
; 4127 : }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?lssproto_Echo_recv@@YAXHPAD@Z ENDP			; lssproto_Echo_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_PlayerNumGet_recv@@YAXHHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_logincount$ = 12					; size = 4
_player$ = 16						; size = 4
?lssproto_PlayerNumGet_recv@@YAXHHH@Z PROC		; lssproto_PlayerNumGet_recv, COMDAT

; 4146 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 4147 : }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?lssproto_PlayerNumGet_recv@@YAXHHH@Z ENDP		; lssproto_PlayerNumGet_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_ProcGet_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_ProcGet_recv@@YAXHPAD@Z PROC			; lssproto_ProcGet_recv, COMDAT

; 4151 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 4152 : }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?lssproto_ProcGet_recv@@YAXHPAD@Z ENDP			; lssproto_ProcGet_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_CharLogout_recv@@YAXHPAD0@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_result$ = 12						; size = 4
_data$ = 16						; size = 4
?lssproto_CharLogout_recv@@YAXHPAD0@Z PROC		; lssproto_CharLogout_recv, COMDAT

; 853  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 854  : 	if (netproc_sending == NETPROC_SENDING)

  0001e	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?netproc_sending@@3HA, 1 ; netproc_sending
  00025	75 2a		 jne	 SHORT $LN1@lssproto_C

; 855  : 	{
; 856  : 		netproc_sending = NETPROC_RECEIVED;

  00027	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 2 ; netproc_sending

; 857  : 		if (strcmp(result, SUCCESSFULSTR) == 0)

  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LHCHIOPJ@successful?$AA@
  00036	8b 45 0c	 mov	 eax, DWORD PTR _result$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _strcmp
  0003f	83 c4 08	 add	 esp, 8
  00042	85 c0		 test	 eax, eax
  00044	75 0b		 jne	 SHORT $LN1@lssproto_C

; 858  : 			charLogoutStatus = 1;

  00046	b8 01 00 00 00	 mov	 eax, 1
  0004b	66 a3 00 00 00
	00		 mov	 WORD PTR ?charLogoutStatus@@3FA, ax ; charLogoutStatus
$LN1@lssproto_C:

; 859  : 	}
; 860  : }

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?lssproto_CharLogout_recv@@YAXHPAD0@Z ENDP		; lssproto_CharLogout_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_CharList_recv@@YAXHPAD0@Z
_TEXT	SEGMENT
_i$1 = -2076						; size = 4
_opt$2 = -2064						; size = 1024
_nm$3 = -1032						; size = 1024
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_result$ = 12						; size = 4
_data$ = 16						; size = 4
?lssproto_CharList_recv@@YAXHPAD0@Z PROC		; lssproto_CharList_recv, COMDAT

; 696  : void lssproto_CharList_recv(int fd, char *result, char *data){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e0 0b 00
	00		 sub	 esp, 3040		; 00000be0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 20 f4 ff
	ff		 lea	 edi, DWORD PTR [ebp-3040]
  00012	b9 f8 02 00 00	 mov	 ecx, 760		; 000002f8H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 697  : 
; 698  : 	if(strcmp(result,"failed")==0) {

  00028	68 00 00 00 00	 push	 OFFSET ??_C@_06ODACHPEO@failed?$AA@
  0002d	8b 45 0c	 mov	 eax, DWORD PTR _result$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _strcmp
  00036	83 c4 08	 add	 esp, 8
  00039	85 c0		 test	 eax, eax
  0003b	75 0f		 jne	 SHORT $LN5@lssproto_C

; 699  : #ifdef _NB_断线自动重连
; 700  : 		PcLanded.登陆延时时间 = TimeGetTime()+2000;

  0003d	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00042	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  00047	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax
$LN5@lssproto_C:

; 701  : #endif
; 702  : 	}
; 703  : 	if (netproc_sending == NETPROC_SENDING){

  0004c	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?netproc_sending@@3HA, 1 ; netproc_sending
  00053	0f 85 44 01 00
	00		 jne	 $LN1@lssproto_C

; 704  : 		char nm[1024], opt[1024];
; 705  : 		int i;
; 706  : 		netproc_sending = NETPROC_RECEIVED;

  00059	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 2 ; netproc_sending

; 707  : 		if (strcmp(result, SUCCESSFULSTR) != 0){

  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LHCHIOPJ@successful?$AA@
  00068	8b 45 0c	 mov	 eax, DWORD PTR _result$[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 _strcmp
  00071	83 c4 08	 add	 esp, 8
  00074	85 c0		 test	 eax, eax
  00076	74 65		 je	 SHORT $LN7@lssproto_C

; 708  : 			if (strcmp(data, "OUTOFSERVICE") == 0)

  00078	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OGLBPKPL@OUTOFSERVICE?$AA@
  0007d	8b 45 10	 mov	 eax, DWORD PTR _data$[ebp]
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 _strcmp
  00086	83 c4 08	 add	 esp, 8
  00089	85 c0		 test	 eax, eax
  0008b	75 0b		 jne	 SHORT $LN8@lssproto_C

; 709  : 				charListStatus = 2;

  0008d	b8 02 00 00 00	 mov	 eax, 2
  00092	66 a3 00 00 00
	00		 mov	 WORD PTR ?charListStatus@@3FA, ax ; charListStatus
$LN8@lssproto_C:

; 710  : #ifdef _CHANGEGALAXY
; 711  : 			if (strcmp(data, "CHANGE_GALAXY") == 0)

  00098	68 00 00 00 00	 push	 OFFSET ??_C@_0O@ENFKOFGC@CHANGE_GALAXY?$AA@
  0009d	8b 45 10	 mov	 eax, DWORD PTR _data$[ebp]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 _strcmp
  000a6	83 c4 08	 add	 esp, 8
  000a9	85 c0		 test	 eax, eax
  000ab	75 0b		 jne	 SHORT $LN9@lssproto_C

; 712  : 				charListStatus = 3;

  000ad	b8 03 00 00 00	 mov	 eax, 3
  000b2	66 a3 00 00 00
	00		 mov	 WORD PTR ?charListStatus@@3FA, ax ; charListStatus
$LN9@lssproto_C:

; 713  : #endif
; 714  : #ifdef _ERROR301
; 715  : 			if (strcmp(data, "301") == 0)

  000b8	68 00 00 00 00	 push	 OFFSET ??_C@_03NOBDJFIO@301?$AA@
  000bd	8b 45 10	 mov	 eax, DWORD PTR _data$[ebp]
  000c0	50		 push	 eax
  000c1	e8 00 00 00 00	 call	 _strcmp
  000c6	83 c4 08	 add	 esp, 8
  000c9	85 c0		 test	 eax, eax
  000cb	75 0b		 jne	 SHORT $LN10@lssproto_C

; 716  : 				charListStatus = 4;

  000cd	b8 04 00 00 00	 mov	 eax, 4
  000d2	66 a3 00 00 00
	00		 mov	 WORD PTR ?charListStatus@@3FA, ax ; charListStatus
$LN10@lssproto_C:

; 717  : #endif
; 718  : 			return;

  000d8	e9 c0 00 00 00	 jmp	 $LN1@lssproto_C
$LN7@lssproto_C:

; 719  : 		}
; 720  : 		charListStatus = 1;

  000dd	b8 01 00 00 00	 mov	 eax, 1
  000e2	66 a3 00 00 00
	00		 mov	 WORD PTR ?charListStatus@@3FA, ax ; charListStatus

; 721  : 		for (i = 0; i < MAXCHARACTER; i++){

  000e8	c7 85 e4 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$1[ebp], 0
  000f2	eb 0f		 jmp	 SHORT $LN4@lssproto_C
$LN2@lssproto_C:
  000f4	8b 85 e4 f7 ff
	ff		 mov	 eax, DWORD PTR _i$1[ebp]
  000fa	83 c0 01	 add	 eax, 1
  000fd	89 85 e4 f7 ff
	ff		 mov	 DWORD PTR _i$1[ebp], eax
$LN4@lssproto_C:
  00103	83 bd e4 f7 ff
	ff 02		 cmp	 DWORD PTR _i$1[ebp], 2
  0010a	0f 8d 8d 00 00
	00		 jge	 $LN1@lssproto_C

; 722  : 			strcpy(nm, "");

  00110	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00115	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _nm$3[ebp]
  0011b	50		 push	 eax
  0011c	e8 00 00 00 00	 call	 _strcpy
  00121	83 c4 08	 add	 esp, 8

; 723  : 			strcpy(opt, "");

  00124	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00129	8d 85 f0 f7 ff
	ff		 lea	 eax, DWORD PTR _opt$2[ebp]
  0012f	50		 push	 eax
  00130	e8 00 00 00 00	 call	 _strcpy
  00135	83 c4 08	 add	 esp, 8

; 724  : 			getStringToken(data, '|', i * 2 + 1, sizeof(nm) - 1 , nm);

  00138	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _nm$3[ebp]
  0013e	50		 push	 eax
  0013f	68 ff 03 00 00	 push	 1023			; 000003ffH
  00144	8b 8d e4 f7 ff
	ff		 mov	 ecx, DWORD PTR _i$1[ebp]
  0014a	8d 54 09 01	 lea	 edx, DWORD PTR [ecx+ecx+1]
  0014e	52		 push	 edx
  0014f	6a 7c		 push	 124			; 0000007cH
  00151	8b 45 10	 mov	 eax, DWORD PTR _data$[ebp]
  00154	50		 push	 eax
  00155	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0015a	83 c4 14	 add	 esp, 20			; 00000014H

; 725  : 			getStringToken(data, '|', i * 2 + 2, sizeof(opt) - 1, opt);

  0015d	8d 85 f0 f7 ff
	ff		 lea	 eax, DWORD PTR _opt$2[ebp]
  00163	50		 push	 eax
  00164	68 ff 03 00 00	 push	 1023			; 000003ffH
  00169	8b 8d e4 f7 ff
	ff		 mov	 ecx, DWORD PTR _i$1[ebp]
  0016f	8d 54 09 02	 lea	 edx, DWORD PTR [ecx+ecx+2]
  00173	52		 push	 edx
  00174	6a 7c		 push	 124			; 0000007cH
  00176	8b 45 10	 mov	 eax, DWORD PTR _data$[ebp]
  00179	50		 push	 eax
  0017a	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0017f	83 c4 14	 add	 esp, 20			; 00000014H

; 726  : 			setCharacterList(nm, opt);

  00182	8d 85 f0 f7 ff
	ff		 lea	 eax, DWORD PTR _opt$2[ebp]
  00188	50		 push	 eax
  00189	8d 8d f8 fb ff
	ff		 lea	 ecx, DWORD PTR _nm$3[ebp]
  0018f	51		 push	 ecx
  00190	e8 00 00 00 00	 call	 ?setCharacterList@@YAHPAD0@Z ; setCharacterList
  00195	83 c4 08	 add	 esp, 8

; 727  : 		}

  00198	e9 57 ff ff ff	 jmp	 $LN2@lssproto_C
$LN1@lssproto_C:

; 728  : 	}
; 729  : }

  0019d	52		 push	 edx
  0019e	8b cd		 mov	 ecx, ebp
  001a0	50		 push	 eax
  001a1	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@lssproto_C
  001a7	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001ac	58		 pop	 eax
  001ad	5a		 pop	 edx
  001ae	5f		 pop	 edi
  001af	5e		 pop	 esi
  001b0	5b		 pop	 ebx
  001b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b4	33 cd		 xor	 ecx, ebp
  001b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001bb	81 c4 e0 0b 00
	00		 add	 esp, 3040		; 00000be0H
  001c1	3b ec		 cmp	 ebp, esp
  001c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c8	8b e5		 mov	 esp, ebp
  001ca	5d		 pop	 ebp
  001cb	c3		 ret	 0
$LN15@lssproto_C:
  001cc	02 00 00 00	 DD	 2
  001d0	00 00 00 00	 DD	 $LN14@lssproto_C
$LN14@lssproto_C:
  001d4	f8 fb ff ff	 DD	 -1032			; fffffbf8H
  001d8	00 04 00 00	 DD	 1024			; 00000400H
  001dc	00 00 00 00	 DD	 $LN12@lssproto_C
  001e0	f0 f7 ff ff	 DD	 -2064			; fffff7f0H
  001e4	00 04 00 00	 DD	 1024			; 00000400H
  001e8	00 00 00 00	 DD	 $LN13@lssproto_C
$LN13@lssproto_C:
  001ec	6f		 DB	 111			; 0000006fH
  001ed	70		 DB	 112			; 00000070H
  001ee	74		 DB	 116			; 00000074H
  001ef	00		 DB	 0
$LN12@lssproto_C:
  001f0	6e		 DB	 110			; 0000006eH
  001f1	6d		 DB	 109			; 0000006dH
  001f2	00		 DB	 0
?lssproto_CharList_recv@@YAXHPAD0@Z ENDP		; lssproto_CharList_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_CharLogin_recv@@YAXHPAD0@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_result$ = 12						; size = 4
_data$ = 16						; size = 4
?lssproto_CharLogin_recv@@YAXHPAD0@Z PROC		; lssproto_CharLogin_recv, COMDAT

; 801  : void lssproto_CharLogin_recv(int fd, char* result, char* data){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 802  : 	if (netproc_sending == NETPROC_SENDING){

  0001e	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?netproc_sending@@3HA, 1 ; netproc_sending
  00025	0f 85 ae 00 00
	00		 jne	 $LN1@lssproto_C

; 803  : 		netproc_sending = NETPROC_RECEIVED;

  0002b	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 2 ; netproc_sending

; 804  : #ifdef __NEW_CLIENT
; 805  : 		if (strcmp(result, SUCCESSFULSTR) == 0 && !hPing)

  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LHCHIOPJ@successful?$AA@
  0003a	8b 45 0c	 mov	 eax, DWORD PTR _result$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _strcmp
  00043	83 c4 08	 add	 esp, 8
  00046	85 c0		 test	 eax, eax
  00048	75 3d		 jne	 SHORT $LN3@lssproto_C
  0004a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?hPing@@3PAXA, 0 ; hPing
  00051	75 34		 jne	 SHORT $LN3@lssproto_C

; 806  : #else
; 807  : 		if (strcmp(result, SUCCESSFULSTR) == 0)
; 808  : #endif
; 809  : 		{
; 810  : 			charLoginStatus = 1;

  00053	b8 01 00 00 00	 mov	 eax, 1
  00058	66 a3 00 00 00
	00		 mov	 WORD PTR ?charLoginStatus@@3FA, ax ; charLoginStatus

; 811  : #ifdef __NEW_CLIENT
; 812  : 			hPing = CreateThread(NULL, 0, PingFunc, &sin_server.sin_addr, 0, &dwPingID);

  0005e	8b f4		 mov	 esi, esp
  00060	68 00 00 00 00	 push	 OFFSET ?dwPingID@@3KA	; dwPingID
  00065	6a 00		 push	 0
  00067	68 04 00 00 00	 push	 OFFSET ?sin_server@@3Usockaddr_in@@A+4
  0006c	68 00 00 00 00	 push	 OFFSET ?PingFunc@@YGKPAX@Z ; PingFunc
  00071	6a 00		 push	 0
  00073	6a 00		 push	 0
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateThread@24
  0007b	3b f4		 cmp	 esi, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	a3 00 00 00 00	 mov	 DWORD PTR ?hPing@@3PAXA, eax ; hPing
$LN3@lssproto_C:

; 813  : #endif
; 814  : 		}
; 815  : 
; 816  : #ifdef _NEW_WGS_MSG				// WON ADD WGS的新视窗
; 817  : 		if (strcmp(result, "failed" ) == 0 && !hPing)

  00087	68 00 00 00 00	 push	 OFFSET ??_C@_06ODACHPEO@failed?$AA@
  0008c	8b 45 0c	 mov	 eax, DWORD PTR _result$[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 _strcmp
  00095	83 c4 08	 add	 esp, 8
  00098	85 c0		 test	 eax, eax
  0009a	75 24		 jne	 SHORT $LN4@lssproto_C
  0009c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?hPing@@3PAXA, 0 ; hPing
  000a3	75 1b		 jne	 SHORT $LN4@lssproto_C

; 818  : 			ERROR_MESSAGE = atoi(data);

  000a5	8b f4		 mov	 esi, esp
  000a7	8b 45 10	 mov	 eax, DWORD PTR _data$[ebp]
  000aa	50		 push	 eax
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  000b1	83 c4 04	 add	 esp, 4
  000b4	3b f4		 cmp	 esi, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bb	a3 00 00 00 00	 mov	 DWORD PTR ?ERROR_MESSAGE@@3HA, eax ; ERROR_MESSAGE
$LN4@lssproto_C:

; 819  : #endif
; 820  : 
; 821  : #ifdef _ANGEL_SUMMON
; 822  : 		angelFlag = FALSE;

  000c0	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?angelFlag@@3HA, 0 ; angelFlag

; 823  : 		angelMsg[0] = NULL;

  000ca	b8 01 00 00 00	 mov	 eax, 1
  000cf	6b c8 00	 imul	 ecx, eax, 0
  000d2	c6 81 00 00 00
	00 00		 mov	 BYTE PTR ?angelMsg@@3PADA[ecx], 0
$LN1@lssproto_C:

; 824  : #endif
; 825  : 	}
; 826  : }

  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi
  000db	5b		 pop	 ebx
  000dc	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000e2	3b ec		 cmp	 ebp, esp
  000e4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c3		 ret	 0
?lssproto_CharLogin_recv@@YAXHPAD0@Z ENDP		; lssproto_CharLogin_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_CharDelete_recv@@YAXHPAD0@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_result$ = 12						; size = 4
_data$ = 16						; size = 4
?lssproto_CharDelete_recv@@YAXHPAD0@Z PROC		; lssproto_CharDelete_recv, COMDAT

; 3160 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3161 : 	if ( netproc_sending == NETPROC_SENDING )

  0001e	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?netproc_sending@@3HA, 1 ; netproc_sending
  00025	75 2a		 jne	 SHORT $LN1@lssproto_C

; 3162 : 	{
; 3163 : 		netproc_sending = NETPROC_RECEIVED;

  00027	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 2 ; netproc_sending

; 3164 : 		if ( strcmp( result, SUCCESSFULSTR ) == 0 )

  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LHCHIOPJ@successful?$AA@
  00036	8b 45 0c	 mov	 eax, DWORD PTR _result$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _strcmp
  0003f	83 c4 08	 add	 esp, 8
  00042	85 c0		 test	 eax, eax
  00044	75 0b		 jne	 SHORT $LN1@lssproto_C

; 3165 : 		{
; 3166 : 			charDelStatus = 1;

  00046	b8 01 00 00 00	 mov	 eax, 1
  0004b	66 a3 00 00 00
	00		 mov	 WORD PTR ?charDelStatus@@3FA, ax ; charDelStatus
$LN1@lssproto_C:

; 3167 :     	}
; 3168 :     }
; 3169 : }

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?lssproto_CharDelete_recv@@YAXHPAD0@Z ENDP		; lssproto_CharDelete_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_CreateNewChar_recv@@YAXHPAD0@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_result$ = 12						; size = 4
_data$ = 16						; size = 4
?lssproto_CreateNewChar_recv@@YAXHPAD0@Z PROC		; lssproto_CreateNewChar_recv, COMDAT

; 3101 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3102 : 	if ( netproc_sending == NETPROC_SENDING )

  0001e	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?netproc_sending@@3HA, 1 ; netproc_sending
  00025	75 2a		 jne	 SHORT $LN1@lssproto_C

; 3103 : 	{
; 3104 : 		netproc_sending = NETPROC_RECEIVED;

  00027	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 2 ; netproc_sending

; 3105 : 
; 3106 : 		if ( strcmp( result, SUCCESSFULSTR ) == 0 )

  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LHCHIOPJ@successful?$AA@
  00036	8b 45 0c	 mov	 eax, DWORD PTR _result$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _strcmp
  0003f	83 c4 08	 add	 esp, 8
  00042	85 c0		 test	 eax, eax
  00044	75 0b		 jne	 SHORT $LN1@lssproto_C

; 3107 : 		{
; 3108 : 			newCharStatus = 1;

  00046	b8 01 00 00 00	 mov	 eax, 1
  0004b	66 a3 00 00 00
	00		 mov	 WORD PTR ?newCharStatus@@3FA, ax ; newCharStatus
$LN1@lssproto_C:

; 3109 : 		}
; 3110 :     }
; 3111 : }

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?lssproto_CreateNewChar_recv@@YAXHPAD0@Z ENDP		; lssproto_CreateNewChar_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_ClientLogin_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_result$ = 12						; size = 4
?lssproto_ClientLogin_recv@@YAXHPAD@Z PROC		; lssproto_ClientLogin_recv, COMDAT

; 638  : void lssproto_ClientLogin_recv(int fd, char *result){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 639  : 	if (netproc_sending == NETPROC_SENDING){

  0001e	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?netproc_sending@@3HA, 1 ; netproc_sending
  00025	0f 85 a2 00 00
	00		 jne	 $LN1@lssproto_C

; 640  : 		netproc_sending = NETPROC_RECEIVED;	

  0002b	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 2 ; netproc_sending

; 641  : 		if (strcmp(result, OKSTR) == 0){

  00035	68 00 00 00 00	 push	 OFFSET ??_C@_02MFDMBIJM@ok?$AA@
  0003a	8b 45 0c	 mov	 eax, DWORD PTR _result$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _strcmp
  00043	83 c4 08	 add	 esp, 8
  00046	85 c0		 test	 eax, eax
  00048	75 2c		 jne	 SHORT $LN3@lssproto_C

; 642  : 			clientLoginStatus = 1;

  0004a	b8 01 00 00 00	 mov	 eax, 1
  0004f	66 a3 00 00 00
	00		 mov	 WORD PTR ?clientLoginStatus@@3FA, ax ; clientLoginStatus

; 643  : 			time(&serverAliveLongTime);

  00055	68 00 00 00 00	 push	 OFFSET ?serverAliveLongTime@@3_JA ; serverAliveLongTime
  0005a	e8 00 00 00 00	 call	 _time
  0005f	83 c4 04	 add	 esp, 4

; 644  : 			serverAliveTime = localtime(&serverAliveLongTime);

  00062	68 00 00 00 00	 push	 OFFSET ?serverAliveLongTime@@3_JA ; serverAliveLongTime
  00067	e8 00 00 00 00	 call	 _localtime
  0006c	83 c4 04	 add	 esp, 4
  0006f	a3 00 00 00 00	 mov	 DWORD PTR ?serverAliveTime@@3PAUtm@@A, eax ; serverAliveTime
  00074	eb 57		 jmp	 SHORT $LN1@lssproto_C
$LN3@lssproto_C:

; 645  : 
; 646  : 		}else if(strcmp (result, CANCLE) == 0){

  00076	68 00 00 00 00	 push	 OFFSET ??_C@_06ENLDJGGB@cancle?$AA@
  0007b	8b 45 0c	 mov	 eax, DWORD PTR _result$[ebp]
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 _strcmp
  00084	83 c4 08	 add	 esp, 8
  00087	85 c0		 test	 eax, eax
  00089	75 2c		 jne	 SHORT $LN5@lssproto_C

; 647  : 			cleanupNetwork();

  0008b	e8 00 00 00 00	 call	 ?cleanupNetwork@@YAXXZ	; cleanupNetwork

; 648  : 			PaletteChange(DEF_PAL, 0);

  00090	6a 00		 push	 0
  00092	6a 00		 push	 0
  00094	e8 00 00 00 00	 call	 ?PaletteChange@@YAXHH@Z	; PaletteChange
  00099	83 c4 08	 add	 esp, 8

; 649  : 			ChangeProc( PROC_ID_PASSWORD );

  0009c	6a 01		 push	 1
  0009e	e8 00 00 00 00	 call	 ?ChangeProc@@YAXH@Z	; ChangeProc
  000a3	83 c4 04	 add	 esp, 4

; 650  : 			SubProcNo = 5;

  000a6	c7 05 00 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?SubProcNo@@3IA, 5 ; SubProcNo

; 651  : 			DeathAllAction();

  000b0	e8 00 00 00 00	 call	 ?DeathAllAction@@YAXXZ	; DeathAllAction

; 652  : 		}else{

  000b5	eb 16		 jmp	 SHORT $LN1@lssproto_C
$LN5@lssproto_C:

; 653  : #ifdef _NB_登录错误信息提示
; 654  : 			sprintf(登录错误提示, "%s", result);

  000b7	8b 45 0c	 mov	 eax, DWORD PTR _result$[ebp]
  000ba	50		 push	 eax
  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  000c0	68 00 00 00 00	 push	 OFFSET ?登录错误提示@@3PADA ; 登录错误提示
  000c5	e8 00 00 00 00	 call	 _sprintf
  000ca	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@lssproto_C:

; 655  : #endif
; 656  : 		}
; 657  : 	}
; 658  : }

  000cd	5f		 pop	 edi
  000ce	5e		 pop	 esi
  000cf	5b		 pop	 ebx
  000d0	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000d6	3b ec		 cmp	 ebp, esp
  000d8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
?lssproto_ClientLogin_recv@@YAXHPAD@Z ENDP		; lssproto_ClientLogin_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_SE_recv@@YAXHHHHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_senumber$ = 20						; size = 4
_sw$ = 24						; size = 4
?lssproto_SE_recv@@YAXHHHHH@Z PROC			; lssproto_SE_recv, COMDAT

; 4060 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 4061 : 	// ????????????????雪????
; 4062 : 	if ( logOutFlag )

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  00025	74 02		 je	 SHORT $LN2@lssproto_S

; 4063 : 		return;

  00027	eb 1a		 jmp	 SHORT $LN1@lssproto_S
$LN2@lssproto_S:

; 4064 : 
; 4065 : 	if ( sw )

  00029	83 7d 18 00	 cmp	 DWORD PTR _sw$[ebp], 0
  0002d	74 14		 je	 SHORT $LN1@lssproto_S

; 4066 : 	{
; 4067 : 		play_se( senumber, x, y );

  0002f	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  00032	50		 push	 eax
  00033	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  00036	51		 push	 ecx
  00037	8b 55 14	 mov	 edx, DWORD PTR _senumber$[ebp]
  0003a	52		 push	 edx
  0003b	e8 00 00 00 00	 call	 ?play_se@@YAHHHH@Z	; play_se
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@lssproto_S:

; 4068 : 	}
; 4069 : 	else
; 4070 : 	{
; 4071 : 		// ????????Y????
; 4072 : 	}
; 4073 : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?lssproto_SE_recv@@YAXHHHHH@Z ENDP			; lssproto_SE_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_EF_recv@@YAXHHHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_effect$ = 12						; size = 4
_level$ = 16						; size = 4
_option$ = 20						; size = 4
?lssproto_EF_recv@@YAXHHHPAD@Z PROC			; lssproto_EF_recv, COMDAT

; 3721 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3722 : 	// u??????????
; 3723 : 	if ( effect == 0 )

  0001e	83 7d 0c 00	 cmp	 DWORD PTR _effect$[ebp], 0
  00022	75 2e		 jne	 SHORT $LN2@lssproto_E

; 3724 : 	{
; 3725 : 		mapEffectRainLevel = 0;

  00024	33 c0		 xor	 eax, eax
  00026	66 a3 00 00 00
	00		 mov	 WORD PTR ?mapEffectRainLevel@@3FA, ax ; mapEffectRainLevel

; 3726 : 		mapEffectSnowLevel = 0;

  0002c	33 c0		 xor	 eax, eax
  0002e	66 a3 00 00 00
	00		 mov	 WORD PTR ?mapEffectSnowLevel@@3FA, ax ; mapEffectSnowLevel

; 3727 : 		mapEffectKamiFubukiLevel = 0;

  00034	33 c0		 xor	 eax, eax
  00036	66 a3 00 00 00
	00		 mov	 WORD PTR ?mapEffectKamiFubukiLevel@@3FA, ax ; mapEffectKamiFubukiLevel

; 3728 : #ifdef _HALLOWEEN_EFFECT
; 3729 : 		mapEffectHalloween = 0;

  0003c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?mapEffectHalloween@@3HA, 0 ; mapEffectHalloween

; 3730 : 		initMapEffect(FALSE);

  00046	6a 00		 push	 0
  00048	e8 00 00 00 00	 call	 ?initMapEffect@@YAXH@Z	; initMapEffect
  0004d	83 c4 04	 add	 esp, 4

; 3731 : #endif
; 3732 : 		return;

  00050	eb 46		 jmp	 SHORT $LN1@lssproto_E
$LN2@lssproto_E:

; 3733 : 	}
; 3734 : 	// ???????
; 3735 : 	if ( effect & 1 )

  00052	8b 45 0c	 mov	 eax, DWORD PTR _effect$[ebp]
  00055	83 e0 01	 and	 eax, 1
  00058	74 0a		 je	 SHORT $LN3@lssproto_E

; 3736 : 	{
; 3737 : 		mapEffectRainLevel = level;

  0005a	66 8b 45 10	 mov	 ax, WORD PTR _level$[ebp]
  0005e	66 a3 00 00 00
	00		 mov	 WORD PTR ?mapEffectRainLevel@@3FA, ax ; mapEffectRainLevel
$LN3@lssproto_E:

; 3738 : 	}
; 3739 : 	// D??????
; 3740 : 	if ( effect & 2 )

  00064	8b 45 0c	 mov	 eax, DWORD PTR _effect$[ebp]
  00067	83 e0 02	 and	 eax, 2
  0006a	74 0a		 je	 SHORT $LN4@lssproto_E

; 3741 : 	{
; 3742 : 		mapEffectSnowLevel = level;

  0006c	66 8b 45 10	 mov	 ax, WORD PTR _level$[ebp]
  00070	66 a3 00 00 00
	00		 mov	 WORD PTR ?mapEffectSnowLevel@@3FA, ax ; mapEffectSnowLevel
$LN4@lssproto_E:

; 3743 : 	}
; 3744 : 	// ????
; 3745 : 	if ( effect & 4 )

  00076	8b 45 0c	 mov	 eax, DWORD PTR _effect$[ebp]
  00079	83 e0 04	 and	 eax, 4
  0007c	74 0a		 je	 SHORT $LN5@lssproto_E

; 3746 : 	{
; 3747 : 		mapEffectKamiFubukiLevel = level;

  0007e	66 8b 45 10	 mov	 ax, WORD PTR _level$[ebp]
  00082	66 a3 00 00 00
	00		 mov	 WORD PTR ?mapEffectKamiFubukiLevel@@3FA, ax ; mapEffectKamiFubukiLevel
$LN5@lssproto_E:

; 3748 : 	}
; 3749 : #ifdef _HALLOWEEN_EFFECT
; 3750 : 	if (effect & 8) mapEffectHalloween = level;

  00088	8b 45 0c	 mov	 eax, DWORD PTR _effect$[ebp]
  0008b	83 e0 08	 and	 eax, 8
  0008e	74 08		 je	 SHORT $LN1@lssproto_E
  00090	8b 45 10	 mov	 eax, DWORD PTR _level$[ebp]
  00093	a3 00 00 00 00	 mov	 DWORD PTR ?mapEffectHalloween@@3HA, eax ; mapEffectHalloween
$LN1@lssproto_E:

; 3751 : #endif
; 3752 : // Terry add 2002/01/14
; 3753 : #ifdef __EDEN_DICE
; 3754 : 	// 骰子
; 3755 : 	if (effect == 10) 
; 3756 : 	{
; 3757 : 		pCommand = (char*)MALLOC(strlen(option)+1);
; 3758 : #ifdef  _STONDEBUG_
; 3759 : 		g_iMallocCount++;
; 3760 : #endif
; 3761 : 		if (pCommand != NULL) 
; 3762 : 		{
; 3763 : 			strcpy(pCommand,option);
; 3764 : 			bMapEffectDice = TRUE;
; 3765 : 			dwDiceTimer = TimeGetTime();
; 3766 : 		}
; 3767 : 	}
; 3768 : #endif
; 3769 : // Terry end
; 3770 : }

  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	5b		 pop	 ebx
  0009b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000a1	3b ec		 cmp	 ebp, esp
  000a3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
?lssproto_EF_recv@@YAXHHHPAD@Z ENDP			; lssproto_EF_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_WN_recv@@YAXHHHHHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_windowtype$ = 12					; size = 4
_buttontype$ = 16					; size = 4
_seqno$ = 20						; size = 4
_objindex$ = 24						; size = 4
_data$ = 28						; size = 4
?lssproto_WN_recv@@YAXHHHHHPAD@Z PROC			; lssproto_WN_recv, COMDAT

; 3614 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3615 : 	// ????????????????雪????
; 3616 : 	if ( logOutFlag )

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  00025	74 02		 je	 SHORT $LN2@lssproto_W

; 3617 : 		return;

  00027	eb 51		 jmp	 SHORT $LN1@lssproto_W
$LN2@lssproto_W:

; 3618 : 
; 3619 : 	if( strstr(data,"否则家族在七天之后会消失唷！") ){	

  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@NFKFNKL@?$NM?z?$DP?J?$KL?p?i?n?$KE?v?R?t?$LI?q?$PN?$PN?$KI?$DP?a?$LM?c?w?$DP?$KD?$KB?$AA@
  0002e	8b 45 1c	 mov	 eax, DWORD PTR _data$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ?strstr@@YAPADQADQBD@Z	; strstr
  00037	83 c4 08	 add	 esp, 8
  0003a	85 c0		 test	 eax, eax
  0003c	74 20		 je	 SHORT $LN3@lssproto_W

; 3620 : 		if( TimeGetTime() - MsgCooltime > 300000 )

  0003e	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00043	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?MsgCooltime@@3IA ; MsgCooltime
  00049	3d e0 93 04 00	 cmp	 eax, 300000		; 000493e0H
  0004e	76 0c		 jbe	 SHORT $LN4@lssproto_W

; 3621 : 			MsgCooltime = TimeGetTime();  

  00050	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00055	a3 00 00 00 00	 mov	 DWORD PTR ?MsgCooltime@@3IA, eax ; MsgCooltime

; 3622 : 		else

  0005a	eb 02		 jmp	 SHORT $LN3@lssproto_W
$LN4@lssproto_W:

; 3623 : 			return;

  0005c	eb 1c		 jmp	 SHORT $LN1@lssproto_W
$LN3@lssproto_W:

; 3624 : 	}
; 3625 : 	openServerWindow( windowtype, buttontype, seqno, objindex, data );

  0005e	8b 45 1c	 mov	 eax, DWORD PTR _data$[ebp]
  00061	50		 push	 eax
  00062	8b 4d 18	 mov	 ecx, DWORD PTR _objindex$[ebp]
  00065	51		 push	 ecx
  00066	8b 55 14	 mov	 edx, DWORD PTR _seqno$[ebp]
  00069	52		 push	 edx
  0006a	8b 45 10	 mov	 eax, DWORD PTR _buttontype$[ebp]
  0006d	50		 push	 eax
  0006e	8b 4d 0c	 mov	 ecx, DWORD PTR _windowtype$[ebp]
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 ?openServerWindow@@YAXHHHHPAD@Z ; openServerWindow
  00077	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@lssproto_W:

; 3626 : }

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
?lssproto_WN_recv@@YAXHHHHHPAD@Z ENDP			; lssproto_WN_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_SKUP_recv@@YAXHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_point$ = 12						; size = 4
?lssproto_SKUP_recv@@YAXHH@Z PROC			; lssproto_SKUP_recv, COMDAT

; 3967 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3968 : 	// ????????????觚
; 3969 : 	StatusUpPoint = point;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _point$[ebp]
  00021	a3 00 00 00 00	 mov	 DWORD PTR ?StatusUpPoint@@3HA, eax ; StatusUpPoint

; 3970 : }

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?lssproto_SKUP_recv@@YAXHH@Z ENDP			; lssproto_SKUP_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_PS_recv@@YAXHHHHH@Z
_TEXT	SEGMENT
_moji$ = -264						; size = 256
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_result$ = 12						; size = 4
_havepetindex$ = 16					; size = 4
_havepetskill$ = 20					; size = 4
_toindex$ = 24						; size = 4
?lssproto_PS_recv@@YAXHHHHH@Z PROC			; lssproto_PS_recv, COMDAT

; 4041 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 01 00
	00		 sub	 esp, 460		; 000001ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-460]
  00012	b9 73 00 00 00	 mov	 ecx, 115		; 00000073H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4042 : 	char moji[ 256 ];
; 4043 : 	
; 4044 : 	// ???????
; 4045 : 	ItemMixRecvFlag = FALSE;

  00028	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ItemMixRecvFlag@@3HA, 0 ; ItemMixRecvFlag

; 4046 : 	
; 4047 : 	// 害???
; 4048 : 	if ( result == 0 ){

  00032	83 7d 0c 00	 cmp	 DWORD PTR _result$[ebp], 0
  00036	75 27		 jne	 SHORT $LN1@lssproto_P

; 4049 : 		//???????
; 4050 : 		sprintf( moji,"失败！");

  00038	68 00 00 00 00	 push	 OFFSET ??_C@_05OAJDDNFL@?c?w?$DP?$KD?$KB?$AA@
  0003d	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _moji$[ebp]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 _sprintf
  00049	83 c4 08	 add	 esp, 8

; 4051 : 		// ??????????????????
; 4052 : 		StockChatBufferLine( moji, FONT_PAL_WHITE );

  0004c	6a 00		 push	 0
  0004e	6a 00		 push	 0
  00050	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _moji$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?StockChatBufferLine@@YAXPADEH@Z ; StockChatBufferLine
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@lssproto_P:

; 4053 : 	}
; 4054 : 	
; 4055 : }

  0005f	52		 push	 edx
  00060	8b cd		 mov	 ecx, ebp
  00062	50		 push	 eax
  00063	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@lssproto_P
  00069	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0006e	58		 pop	 eax
  0006f	5a		 pop	 edx
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx
  00073	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00076	33 cd		 xor	 ecx, ebp
  00078	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007d	81 c4 cc 01 00
	00		 add	 esp, 460		; 000001ccH
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
  0008e	66 90		 npad	 2
$LN6@lssproto_P:
  00090	01 00 00 00	 DD	 1
  00094	00 00 00 00	 DD	 $LN5@lssproto_P
$LN5@lssproto_P:
  00098	f8 fe ff ff	 DD	 -264			; fffffef8H
  0009c	00 01 00 00	 DD	 256			; 00000100H
  000a0	00 00 00 00	 DD	 $LN4@lssproto_P
$LN4@lssproto_P:
  000a4	6d		 DB	 109			; 0000006dH
  000a5	6f		 DB	 111			; 0000006fH
  000a6	6a		 DB	 106			; 0000006aH
  000a7	69		 DB	 105			; 00000069H
  000a8	00		 DB	 0
?lssproto_PS_recv@@YAXHHHHH@Z ENDP			; lssproto_PS_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_SPET_recv@@YAXHHH@Z
_TEXT	SEGMENT
_i$ = -20						; size = 4
_cnt$ = -8						; size = 4
_fd$ = 8						; size = 4
_standbypet$ = 12					; size = 4
_result$ = 16						; size = 4
?lssproto_SPET_recv@@YAXHHH@Z PROC			; lssproto_SPET_recv, COMDAT

; 3946 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3947 : 	int cnt = 0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cnt$[ebp], 0

; 3948 : 	int i;
; 3949 : 
; 3950 : 	StandbyPetSendFlag = FALSE;

  00025	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?StandbyPetSendFlag@@3HA, 0 ; StandbyPetSendFlag

; 3951 : 
; 3952 : 	if ( result == TRUE ) { 

  0002f	83 7d 10 01	 cmp	 DWORD PTR _result$[ebp], 1
  00033	75 52		 jne	 SHORT $LN1@lssproto_S

; 3953 : 		pc.standbyPet = standbypet;

  00035	66 8b 45 0c	 mov	 ax, WORD PTR _standbypet$[ebp]
  00039	66 a3 b8 00 00
	00		 mov	 WORD PTR ?pc@@3UPC@@A+184, ax

; 3954 : 		for ( i =0; i <MAX_PET; i++) {

  0003f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00046	eb 09		 jmp	 SHORT $LN4@lssproto_S
$LN2@lssproto_S:
  00048	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  0004b	83 c0 01	 add	 eax, 1
  0004e	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN4@lssproto_S:
  00051	83 7d ec 05	 cmp	 DWORD PTR _i$[ebp], 5
  00055	7d 30		 jge	 SHORT $LN1@lssproto_S

; 3955 : 			if ( standbypet & ( 1 << i) )

  00057	b8 01 00 00 00	 mov	 eax, 1
  0005c	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  0005f	d3 e0		 shl	 eax, cl
  00061	23 45 0c	 and	 eax, DWORD PTR _standbypet$[ebp]
  00064	74 12		 je	 SHORT $LN6@lssproto_S

; 3956 : 				pc.selectPetNo[ i ] = TRUE;

  00066	b8 01 00 00 00	 mov	 eax, 1
  0006b	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  0006e	66 89 04 4d ac
	00 00 00	 mov	 WORD PTR ?pc@@3UPC@@A[ecx*2+172], ax

; 3957 : 			else

  00076	eb 0d		 jmp	 SHORT $LN7@lssproto_S
$LN6@lssproto_S:

; 3958 : 				pc.selectPetNo[ i ] = FALSE;

  00078	33 c0		 xor	 eax, eax
  0007a	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  0007d	66 89 04 4d ac
	00 00 00	 mov	 WORD PTR ?pc@@3UPC@@A[ecx*2+172], ax
$LN7@lssproto_S:

; 3959 : 		}

  00085	eb c1		 jmp	 SHORT $LN2@lssproto_S
$LN1@lssproto_S:

; 3960 : 	}
; 3961 : 
; 3962 : }

  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
?lssproto_SPET_recv@@YAXHHH@Z ENDP			; lssproto_SPET_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_KS_recv@@YAXHHH@Z
_TEXT	SEGMENT
_i$ = -20						; size = 4
_cnt$ = -8						; size = 4
_fd$ = 8						; size = 4
_petarray$ = 12						; size = 4
_result$ = 16						; size = 4
?lssproto_KS_recv@@YAXHHH@Z PROC			; lssproto_KS_recv, COMDAT

; 3912 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3913 : 	int cnt = 0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cnt$[ebp], 0

; 3914 : 	int i;
; 3915 : 
; 3916 : 	BattlePetReceiveFlag = FALSE;

  00025	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BattlePetReceiveFlag@@3HA, 0 ; BattlePetReceiveFlag

; 3917 : 	BattlePetReceivePetNo = -1;

  0002f	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?BattlePetReceivePetNo@@3HA, -1 ; BattlePetReceivePetNo

; 3918 : 	if ( result == TRUE ){ 

  00039	83 7d 10 01	 cmp	 DWORD PTR _result$[ebp], 1
  0003d	0f 85 98 00 00
	00		 jne	 $LN5@lssproto_K

; 3919 : 		battlePetNoBak = -2;

  00043	c7 05 00 00 00
	00 fe ff ff ff	 mov	 DWORD PTR ?battlePetNoBak@@3HA, -2 ; battlePetNoBak, fffffffeH

; 3920 : 		if ( petarray != -1 ){ 

  0004d	83 7d 0c ff	 cmp	 DWORD PTR _petarray$[ebp], -1
  00051	74 7c		 je	 SHORT $LN7@lssproto_K

; 3921 : 			pc.selectPetNo[ petarray ] = TRUE;

  00053	b8 01 00 00 00	 mov	 eax, 1
  00058	8b 4d 0c	 mov	 ecx, DWORD PTR _petarray$[ebp]
  0005b	66 89 04 4d ac
	00 00 00	 mov	 WORD PTR ?pc@@3UPC@@A[ecx*2+172], ax

; 3922 : 			if ( pc.mailPetNo == petarray ) pc.mailPetNo = -1;

  00063	0f bf 05 b6 00
	00 00		 movsx	 eax, WORD PTR ?pc@@3UPC@@A+182
  0006a	3b 45 0c	 cmp	 eax, DWORD PTR _petarray$[ebp]
  0006d	75 09		 jne	 SHORT $LN8@lssproto_K
  0006f	83 c8 ff	 or	 eax, -1
  00072	66 a3 b6 00 00
	00		 mov	 WORD PTR ?pc@@3UPC@@A+182, ax
$LN8@lssproto_K:

; 3923 : 			for ( i = 0 ; i < 5 ; i++ ){

  00078	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0007f	eb 09		 jmp	 SHORT $LN4@lssproto_K
$LN2@lssproto_K:
  00081	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00084	83 c0 01	 add	 eax, 1
  00087	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN4@lssproto_K:
  0008a	83 7d ec 05	 cmp	 DWORD PTR _i$[ebp], 5
  0008e	7d 3f		 jge	 SHORT $LN7@lssproto_K

; 3924 : 				if ( pc.selectPetNo[ i ] == TRUE && i != petarray ) cnt++;

  00090	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00093	0f bf 0c 45 ac
	00 00 00	 movsx	 ecx, WORD PTR ?pc@@3UPC@@A[eax*2+172]
  0009b	83 f9 01	 cmp	 ecx, 1
  0009e	75 11		 jne	 SHORT $LN9@lssproto_K
  000a0	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000a3	3b 45 0c	 cmp	 eax, DWORD PTR _petarray$[ebp]
  000a6	74 09		 je	 SHORT $LN9@lssproto_K
  000a8	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  000ab	83 c0 01	 add	 eax, 1
  000ae	89 45 f8	 mov	 DWORD PTR _cnt$[ebp], eax
$LN9@lssproto_K:

; 3925 : 				if ( cnt >= 等待宠数量){

  000b1	83 7d f8 05	 cmp	 DWORD PTR _cnt$[ebp], 5
  000b5	7c 16		 jl	 SHORT $LN10@lssproto_K

; 3926 : 					pc.selectPetNo[ i ] = FALSE;

  000b7	33 c0		 xor	 eax, eax
  000b9	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  000bc	66 89 04 4d ac
	00 00 00	 mov	 WORD PTR ?pc@@3UPC@@A[ecx*2+172], ax

; 3927 : 					cnt--;

  000c4	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  000c7	83 e8 01	 sub	 eax, 1
  000ca	89 45 f8	 mov	 DWORD PTR _cnt$[ebp], eax
$LN10@lssproto_K:

; 3928 : 				}
; 3929 : 			}

  000cd	eb b2		 jmp	 SHORT $LN2@lssproto_K
$LN7@lssproto_K:

; 3930 : 		}
; 3931 : 		pc.battlePetNo = petarray;

  000cf	66 8b 45 0c	 mov	 ax, WORD PTR _petarray$[ebp]
  000d3	66 a3 aa 00 00
	00		 mov	 WORD PTR ?pc@@3UPC@@A+170, ax

; 3932 : 	}
; 3933 : #ifdef _AFTER_TRADE_PETWAIT_
; 3934 : 	else{

  000d9	eb 2e		 jmp	 SHORT $LN1@lssproto_K
$LN5@lssproto_K:

; 3935 : 		if (tradeStatus==2){

  000db	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?tradeStatus@@3FA ; tradeStatus
  000e2	83 f8 02	 cmp	 eax, 2
  000e5	75 22		 jne	 SHORT $LN1@lssproto_K

; 3936 : 			pc.selectPetNo[petarray] = 0;

  000e7	33 c0		 xor	 eax, eax
  000e9	8b 4d 0c	 mov	 ecx, DWORD PTR _petarray$[ebp]
  000ec	66 89 04 4d ac
	00 00 00	 mov	 WORD PTR ?pc@@3UPC@@A[ecx*2+172], ax

; 3937 : 			if (petarray==pc.battlePetNo)

  000f4	0f bf 05 aa 00
	00 00		 movsx	 eax, WORD PTR ?pc@@3UPC@@A+170
  000fb	39 45 0c	 cmp	 DWORD PTR _petarray$[ebp], eax
  000fe	75 09		 jne	 SHORT $LN1@lssproto_K

; 3938 : 				pc.battlePetNo = -1;

  00100	83 c8 ff	 or	 eax, -1
  00103	66 a3 aa 00 00
	00		 mov	 WORD PTR ?pc@@3UPC@@A+170, ax
$LN1@lssproto_K:

; 3939 : 		}		
; 3940 : 	}
; 3941 : #endif
; 3942 : }

  00109	5f		 pop	 edi
  0010a	5e		 pop	 esi
  0010b	5b		 pop	 ebx
  0010c	8b e5		 mov	 esp, ebp
  0010e	5d		 pop	 ebp
  0010f	c3		 ret	 0
?lssproto_KS_recv@@YAXHHH@Z ENDP			; lssproto_KS_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_PR_recv@@YAXHHH@Z
_TEXT	SEGMENT
_dir$1 = -5						; size = 1
_fd$ = 8						; size = 4
_request$ = 12						; size = 4
_result$ = 16						; size = 4
?lssproto_PR_recv@@YAXHHH@Z PROC			; lssproto_PR_recv, COMDAT

; 3173 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3174 : 	// ????????????????雪????
; 3175 : 	if ( logOutFlag )

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  00025	74 05		 je	 SHORT $LN2@lssproto_P

; 3176 : 		return;

  00027	e9 c6 00 00 00	 jmp	 $LN1@lssproto_P
$LN2@lssproto_P:

; 3177 : 
; 3178 : 	if ( request == 1 && result == 1 )

  0002c	83 7d 0c 01	 cmp	 DWORD PTR _request$[ebp], 1
  00030	75 10		 jne	 SHORT $LN3@lssproto_P
  00032	83 7d 10 01	 cmp	 DWORD PTR _result$[ebp], 1
  00036	75 0a		 jne	 SHORT $LN3@lssproto_P

; 3179 : 	{
; 3180 : 		// M????????V????G??
; 3181 : 		setPcParty();

  00038	e8 00 00 00 00	 call	 ?setPcParty@@YAXXZ	; setPcParty

; 3182 : 	}
; 3183 : 	else

  0003d	e9 a8 00 00 00	 jmp	 $LN4@lssproto_P
$LN3@lssproto_P:

; 3184 : 	if ( request == 0 && result == 1 )

  00042	83 7d 0c 00	 cmp	 DWORD PTR _request$[ebp], 0
  00046	0f 85 9e 00 00
	00		 jne	 $LN4@lssproto_P
  0004c	83 7d 10 01	 cmp	 DWORD PTR _result$[ebp], 1
  00050	0f 85 94 00 00
	00		 jne	 $LN4@lssproto_P

; 3185 : 	{
; 3186 : 		// ??????????
; 3187 : 		//delPcParty();
; 3188 : 		//delPcLeader();
; 3189 : 		partyModeFlag = 0;

  00056	33 c0		 xor	 eax, eax
  00058	66 a3 00 00 00
	00		 mov	 WORD PTR ?partyModeFlag@@3FA, ax ; partyModeFlag

; 3190 : 		clearPartyParam();

  0005e	e8 00 00 00 00	 call	 ?clearPartyParam@@YAXXZ	; clearPartyParam

; 3191 : #ifdef _CHANNEL_MODIFY
; 3192 : 		pc.etcFlag &= ~PC_ETCFLAG_CHAT_MODE;

  00063	0f b7 05 a8 00
	00 00		 movzx	 eax, WORD PTR ?pc@@3UPC@@A+168
  0006a	83 e0 f7	 and	 eax, -9			; fffffff7H
  0006d	66 a3 a8 00 00
	00		 mov	 WORD PTR ?pc@@3UPC@@A+168, ax

; 3193 : 		if (TalkMode == 2) TalkMode = 0;

  00073	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?TalkMode@@3HA, 2 ; TalkMode
  0007a	75 0a		 jne	 SHORT $LN6@lssproto_P
  0007c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?TalkMode@@3HA, 0 ; TalkMode
$LN6@lssproto_P:

; 3194 : #endif
; 3195 : 
; 3196 : 		char dir = (pc.dir+5) % 8;

  00086	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+12
  0008b	83 c0 05	 add	 eax, 5
  0008e	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00093	79 05		 jns	 SHORT $LN10@lssproto_P
  00095	48		 dec	 eax
  00096	83 c8 f8	 or	 eax, -8			; fffffff8H
  00099	40		 inc	 eax
$LN10@lssproto_P:
  0009a	88 45 fb	 mov	 BYTE PTR _dir$1[ebp], al

; 3197 : 		if (bNewServer)

  0009d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bNewServer@@3HA, 0 ; bNewServer
  000a4	74 23		 je	 SHORT $LN7@lssproto_P

; 3198 : 			lssproto_SP_send(sockfd, nextGx, nextGy, dir );

  000a6	0f be 45 fb	 movsx	 eax, BYTE PTR _dir$1[ebp]
  000aa	50		 push	 eax
  000ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nextGy@@3HA ; nextGy
  000b1	51		 push	 ecx
  000b2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?nextGx@@3HA ; nextGx
  000b8	52		 push	 edx
  000b9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 ?lssproto_SP_send@@YAXHHHH@Z ; lssproto_SP_send
  000c4	83 c4 10	 add	 esp, 16			; 00000010H

; 3199 : 		else

  000c7	eb 21		 jmp	 SHORT $LN4@lssproto_P
$LN7@lssproto_P:

; 3200 : 			old_lssproto_SP_send(sockfd, nextGx, nextGy, dir );

  000c9	0f be 45 fb	 movsx	 eax, BYTE PTR _dir$1[ebp]
  000cd	50		 push	 eax
  000ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nextGy@@3HA ; nextGy
  000d4	51		 push	 ecx
  000d5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?nextGx@@3HA ; nextGx
  000db	52		 push	 edx
  000dc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 ?old_lssproto_SP_send@@YAXHHHH@Z ; old_lssproto_SP_send
  000e7	83 c4 10	 add	 esp, 16			; 00000010H
$LN4@lssproto_P:

; 3201 : 	}
; 3202 : 	prSendFlag = 0;

  000ea	33 c0		 xor	 eax, eax
  000ec	66 a3 00 00 00
	00		 mov	 WORD PTR ?prSendFlag@@3FA, ax ; prSendFlag
$LN1@lssproto_P:

; 3203 : }

  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi
  000f4	5b		 pop	 ebx
  000f5	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000fb	3b ec		 cmp	 ebp, esp
  000fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c3		 ret	 0
?lssproto_PR_recv@@YAXHHH@Z ENDP			; lssproto_PR_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_HL_recv@@YAXHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_flg$ = 12						; size = 4
?lssproto_HL_recv@@YAXHH@Z PROC				; lssproto_HL_recv, COMDAT

; 3839 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3840 : 	helpFlag = flg;

  0001e	66 8b 45 0c	 mov	 ax, WORD PTR _flg$[ebp]
  00022	66 a3 00 00 00
	00		 mov	 WORD PTR ?helpFlag@@3FA, ax ; helpFlag

; 3841 : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?lssproto_HL_recv@@YAXHH@Z ENDP				; lssproto_HL_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_FS_recv@@YAXHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_flg$ = 12						; size = 4
?lssproto_FS_recv@@YAXHH@Z PROC				; lssproto_FS_recv, COMDAT

; 3246 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3247 : 	// ????????????????雪????
; 3248 : 	if ( logOutFlag )

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  00025	74 02		 je	 SHORT $LN2@lssproto_F

; 3249 : 		return;

  00027	eb 1a		 jmp	 SHORT $LN1@lssproto_F
$LN2@lssproto_F:

; 3250 : 
; 3251 : 	pc.etcFlag = (unsigned short)flg;

  00029	66 8b 45 0c	 mov	 ax, WORD PTR _flg$[ebp]
  0002d	66 a3 a8 00 00
	00		 mov	 WORD PTR ?pc@@3UPC@@A+168, ax

; 3252 : 	pc.etcFlag &= ~PC_ETCFLAG_JOINT_BTL;	// ??????G???

  00033	0f b7 05 a8 00
	00 00		 movzx	 eax, WORD PTR ?pc@@3UPC@@A+168
  0003a	83 e0 fd	 and	 eax, -3			; fffffffdH
  0003d	66 a3 a8 00 00
	00		 mov	 WORD PTR ?pc@@3UPC@@A+168, ax
$LN1@lssproto_F:

; 3253 : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
?lssproto_FS_recv@@YAXHH@Z ENDP				; lssproto_FS_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_D_recv@@YAXHHHHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_category$ = 12						; size = 4
_dx$ = 16						; size = 4
_dy$ = 20						; size = 4
_data$ = 24						; size = 4
?lssproto_D_recv@@YAXHHHHPAD@Z PROC			; lssproto_D_recv, COMDAT

; 4167 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 4168 : }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?lssproto_D_recv@@YAXHHHHPAD@Z ENDP			; lssproto_D_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_S_recv@@YAXHPAD@Z
_TEXT	SEGMENT
tv68 = -4788						; size = 4
_szData$1 = -3436					; size = 256
_nPetIndex$2 = -3172					; size = 4
_no$3 = -3160						; size = 4
_i$4 = -3148						; size = 4
_count$5 = -3136					; size = 4
_i$6 = -3124						; size = 4
_memo$7 = -3112						; size = 85
_name$8 = -3016						; size = 17
_temp$9 = -2988						; size = 256
_no2$10 = -2724						; size = 4
_no$11 = -2712						; size = 4
_i$12 = -2700						; size = 4
_temp$13 = -2688					; size = 256
_no$14 = -2424						; size = 4
_i$15 = -2412						; size = 4
_mask$16 = -2400					; size = 4
_no2$17 = -2388						; size = 4
_gy$18 = -2376						; size = 4
_gx$19 = -2364						; size = 4
_checkPartyCount$20 = -2352				; size = 4
_i$21 = -2340						; size = 4
_kubun$22 = -2328					; size = 4
_no$23 = -2316						; size = 4
_name$24 = -2304					; size = 256
_ptAct$25 = -2040					; size = 4
_no$26 = -2028						; size = 4
_memo$27 = -2016					; size = 256
_name$28 = -1752					; size = 256
_temp2$29 = -1488					; size = 4
_绑定标志$30 = -1476					; size = 2
_mask$31 = -1464					; size = 4
_i$32 = -1452						; size = 4
_kubun$33 = -1440					; size = 4
_no$34 = -1428						; size = 4
_freeName$35 = -1416					; size = 256
_name$36 = -1152					; size = 256
_familyName$37 = -888					; size = 256
_mask$38 = -624						; size = 4
_kubun$39 = -612					; size = 4
_i$40 = -600						; size = 4
_freeName$41 = -588					; size = 256
_name$42 = -324						; size = 256
_gy$43 = -60						; size = 4
_gx$44 = -48						; size = 4
_maxy$45 = -36						; size = 4
_maxx$46 = -24						; size = 4
_fl$47 = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_S_recv@@YAXHPAD@Z PROC			; lssproto_S_recv, COMDAT

; 880  : void lssproto_S_recv(int fd, char *data){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 b4 12 00 00	 mov	 eax, 4788		; 000012b4H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8d bd 4c ed ff
	ff		 lea	 edi, DWORD PTR [ebp-4788]
  00016	b9 ad 04 00 00	 mov	 ecx, 1197		; 000004adH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 881  : 	if (logOutFlag)

  0002c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  00033	74 05		 je	 SHORT $LN34@lssproto_S

; 882  : 		return;

  00035	e9 dc 31 00 00	 jmp	 $LN1@lssproto_S
$LN34@lssproto_S:

; 883  : 	switch (data[0]){

  0003a	b8 01 00 00 00	 mov	 eax, 1
  0003f	6b c8 00	 imul	 ecx, eax, 0
  00042	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  00045	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00049	89 85 4c ed ff
	ff		 mov	 DWORD PTR tv68[ebp], eax
  0004f	8b 8d 4c ed ff
	ff		 mov	 ecx, DWORD PTR tv68[ebp]
  00055	83 e9 42	 sub	 ecx, 66			; 00000042H
  00058	89 8d 4c ed ff
	ff		 mov	 DWORD PTR tv68[ebp], ecx
  0005e	83 bd 4c ed ff
	ff 16		 cmp	 DWORD PTR tv68[ebp], 22	; 00000016H
  00065	0f 87 ab 31 00
	00		 ja	 $LN1@lssproto_S
  0006b	8b 95 4c ed ff
	ff		 mov	 edx, DWORD PTR tv68[ebp]
  00071	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN260@lssproto_S[edx*4]
$LN35@lssproto_S:

; 884  : 		case 'C':
; 885  : 		{
; 886  : 			int fl, maxx, maxy, gx, gy;
; 887  : 
; 888  : 			floorChangeFlag = TRUE;

  00078	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?floorChangeFlag@@3HA, 1 ; floorChangeFlag

; 889  : 			if (!loginFlag && ProcNo == PROC_GAME){

  00082	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?loginFlag@@3HA, 0 ; loginFlag
  00089	75 55		 jne	 SHORT $LN36@lssproto_S
  0008b	83 3d 00 00 00
	00 09		 cmp	 DWORD PTR ?ProcNo@@3IA, 9 ; ProcNo
  00092	75 4c		 jne	 SHORT $LN36@lssproto_S

; 890  : 				if (!warpEffectFlag){				

  00094	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?warpEffectFlag@@3HA, 0 ; warpEffectFlag
  0009b	75 2a		 jne	 SHORT $LN37@lssproto_S

; 891  : 					SubProcNo = 200;

  0009d	c7 05 00 00 00
	00 c8 00 00 00	 mov	 DWORD PTR ?SubProcNo@@3IA, 200 ; SubProcNo, 000000c8H

; 892  : 					//JLWG 回记录点特效去除
; 893  : 					JL_关闭特效_回记录点();

  000a7	e8 00 00 00 00	 call	 ?JL_关闭特效_回记录点@@YAXXZ ; JL_关闭特效_回记录点

; 894  : 					warpEffectProc();

  000ac	e8 00 00 00 00	 call	 ?warpEffectProc@@YAXXZ	; warpEffectProc

; 895  : 					if (MenuToggleFlag & JOY_CTRL_M)

  000b1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?MenuToggleFlag@@3IA ; MenuToggleFlag
  000b6	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  000bb	74 0a		 je	 SHORT $LN37@lssproto_S

; 896  : 						MapWmdFlagBak = TRUE;

  000bd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?MapWmdFlagBak@@3HA, 1 ; MapWmdFlagBak
$LN37@lssproto_S:

; 897  : 				}
; 898  : 				resetPc();

  000c7	e8 00 00 00 00	 call	 ?resetPc@@YAXXZ		; resetPc

; 899  : 				warpEffectFlag = FALSE;

  000cc	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?warpEffectFlag@@3HA, 0 ; warpEffectFlag

; 900  : 				warpEffectStart = TRUE;

  000d6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?warpEffectStart@@3HA, 1 ; warpEffectStart
$LN36@lssproto_S:

; 901  : 
; 902  : 			}
; 903  : 			data++;

  000e0	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  000e3	83 c0 01	 add	 eax, 1
  000e6	89 45 0c	 mov	 DWORD PTR _data$[ebp], eax

; 904  : 			fl   = getIntegerToken(data, S_DELIM, 1);

  000e9	6a 01		 push	 1
  000eb	6a 7c		 push	 124			; 0000007cH
  000ed	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  000f6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f9	89 45 f4	 mov	 DWORD PTR _fl$47[ebp], eax

; 905  : 			maxx = getIntegerToken(data, S_DELIM, 2);

  000fc	6a 02		 push	 2
  000fe	6a 7c		 push	 124			; 0000007cH
  00100	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00109	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010c	89 45 e8	 mov	 DWORD PTR _maxx$46[ebp], eax

; 906  : 			maxy = getIntegerToken(data, S_DELIM, 3);

  0010f	6a 03		 push	 3
  00111	6a 7c		 push	 124			; 0000007cH
  00113	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00116	50		 push	 eax
  00117	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0011c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011f	89 45 dc	 mov	 DWORD PTR _maxy$45[ebp], eax

; 907  : 			gx   = getIntegerToken(data, S_DELIM, 4);

  00122	6a 04		 push	 4
  00124	6a 7c		 push	 124			; 0000007cH
  00126	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00129	50		 push	 eax
  0012a	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0012f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00132	89 45 d0	 mov	 DWORD PTR _gx$44[ebp], eax

; 908  : 			gy   = getIntegerToken(data, S_DELIM, 5);

  00135	6a 05		 push	 5
  00137	6a 7c		 push	 124			; 0000007cH
  00139	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0013c	50		 push	 eax
  0013d	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00142	83 c4 0c	 add	 esp, 12			; 0000000cH
  00145	89 45 c4	 mov	 DWORD PTR _gy$43[ebp], eax

; 909  : 			setMap(fl, gx, gy);

  00148	8b 45 c4	 mov	 eax, DWORD PTR _gy$43[ebp]
  0014b	50		 push	 eax
  0014c	8b 4d d0	 mov	 ecx, DWORD PTR _gx$44[ebp]
  0014f	51		 push	 ecx
  00150	8b 55 f4	 mov	 edx, DWORD PTR _fl$47[ebp]
  00153	52		 push	 edx
  00154	e8 00 00 00 00	 call	 ?setMap@@YAXHHH@Z	; setMap
  00159	83 c4 0c	 add	 esp, 12			; 0000000cH

; 910  : 			createMap(fl, maxx, maxy);

  0015c	8b 45 dc	 mov	 eax, DWORD PTR _maxy$45[ebp]
  0015f	50		 push	 eax
  00160	8b 4d e8	 mov	 ecx, DWORD PTR _maxx$46[ebp]
  00163	51		 push	 ecx
  00164	8b 55 f4	 mov	 edx, DWORD PTR _fl$47[ebp]
  00167	52		 push	 edx
  00168	e8 00 00 00 00	 call	 ?createMap@@YAXHHH@Z	; createMap
  0016d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 911  : 			nowFloorGxSize = maxx;

  00170	8b 45 e8	 mov	 eax, DWORD PTR _maxx$46[ebp]
  00173	a3 00 00 00 00	 mov	 DWORD PTR ?nowFloorGxSize@@3HA, eax ; nowFloorGxSize

; 912  : 			nowFloorGySize = maxy;

  00178	8b 45 dc	 mov	 eax, DWORD PTR _maxy$45[ebp]
  0017b	a3 00 00 00 00	 mov	 DWORD PTR ?nowFloorGySize@@3HA, eax ; nowFloorGySize

; 913  : 			resetCharObj();

  00180	e8 00 00 00 00	 call	 ?resetCharObj@@YAXXZ	; resetCharObj

; 914  : 			mapEmptyFlag = FALSE;

  00185	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?mapEmptyFlag@@3HA, 0 ; mapEmptyFlag

; 915  : 			nowEncountPercentage = minEncountPercentage;

  0018f	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?minEncountPercentage@@3FA ; minEncountPercentage
  00195	66 a3 00 00 00
	00		 mov	 WORD PTR ?nowEncountPercentage@@3FA, ax ; nowEncountPercentage

; 916  : 			nowEncountExtra = 0;

  0019b	33 c0		 xor	 eax, eax
  0019d	66 a3 00 00 00
	00		 mov	 WORD PTR ?nowEncountExtra@@3FA, ax ; nowEncountExtra

; 917  : 			resetMap();

  001a3	e8 00 00 00 00	 call	 ?resetMap@@YAXXZ	; resetMap

; 918  : 			transmigrationEffectFlag = 0;

  001a8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?transmigrationEffectFlag@@3HA, 0 ; transmigrationEffectFlag

; 919  : 			//JL fix 2017.9.22 切地图时,将组队的act都清0,这样打精灵王以及过地图就不崩了
; 920  : 			clearPtActPartyParam();

  001b2	e8 00 00 00 00	 call	 ?clearPtActPartyParam@@YAXXZ ; clearPtActPartyParam

; 921  :             break;

  001b7	e9 5a 30 00 00	 jmp	 $LN1@lssproto_S
$LN39@lssproto_S:

; 922  : 		}
; 923  : 		case 'D':
; 924  : 			data++;

  001bc	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  001bf	83 c0 01	 add	 eax, 1
  001c2	89 45 0c	 mov	 DWORD PTR _data$[ebp], eax

; 925  : 			setPcId(getIntegerToken(data, S_DELIM, 1));

  001c5	6a 01		 push	 1
  001c7	6a 7c		 push	 124			; 0000007cH
  001c9	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  001d2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d5	50		 push	 eax
  001d6	e8 00 00 00 00	 call	 ?setPcId@@YAXH@Z	; setPcId
  001db	83 c4 04	 add	 esp, 4

; 926  : 			serverTime = getIntegerToken(data, S_DELIM, 2);

  001de	6a 02		 push	 2
  001e0	6a 7c		 push	 124			; 0000007cH
  001e2	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  001e5	50		 push	 eax
  001e6	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  001eb	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ee	a3 00 00 00 00	 mov	 DWORD PTR ?serverTime@@3JA, eax ; serverTime

; 927  : 			FirstTime = TimeGetTime();

  001f3	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  001f8	a3 00 00 00 00	 mov	 DWORD PTR ?FirstTime@@3JA, eax ; FirstTime

; 928  : 			RealTimeToSATime(&SaTime);

  001fd	68 00 00 00 00	 push	 OFFSET ?SaTime@@3UtagLSTIME@@A ; SaTime
  00202	e8 00 00 00 00	 call	 ?RealTimeToSATime@@YAXPAUtagLSTIME@@@Z ; RealTimeToSATime
  00207	83 c4 04	 add	 esp, 4

; 929  : 			SaTimeZoneNo = getLSTime(&SaTime);

  0020a	68 00 00 00 00	 push	 OFFSET ?SaTime@@3UtagLSTIME@@A ; SaTime
  0020f	e8 00 00 00 00	 call	 ?getLSTime@@YA?AW4LSTIME_SECTION@@PAUtagLSTIME@@@Z ; getLSTime
  00214	83 c4 04	 add	 esp, 4
  00217	a3 00 00 00 00	 mov	 DWORD PTR ?SaTimeZoneNo@@3HA, eax ; SaTimeZoneNo

; 930  : 			PaletteChange(SaTimeZoneNo, 0);

  0021c	6a 00		 push	 0
  0021e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SaTimeZoneNo@@3HA ; SaTimeZoneNo
  00223	50		 push	 eax
  00224	e8 00 00 00 00	 call	 ?PaletteChange@@YAXHH@Z	; PaletteChange
  00229	83 c4 08	 add	 esp, 8

; 931  : 			break;

  0022c	e9 e5 2f 00 00	 jmp	 $LN1@lssproto_S
$LN40@lssproto_S:

; 932  : 		//andy_add
; 933  : 		case 'X':
; 934  : 			pc.lowsride = getIntegerToken(data, S_DELIM, 2);

  00231	6a 02		 push	 2
  00233	6a 7c		 push	 124			; 0000007cH
  00235	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00238	50		 push	 eax
  00239	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0023e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00241	a3 20 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20768, eax

; 935  : 			break;

  00246	e9 cb 2f 00 00	 jmp	 $LN1@lssproto_S
$LN41@lssproto_S:

; 936  : 		case 'P':
; 937  : 			{
; 938  : 				char name[256], freeName[256];
; 939  : 				int i, kubun;
; 940  : 				unsigned int mask;
; 941  : 
; 942  : 				data++;

  0024b	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0024e	83 c0 01	 add	 eax, 1
  00251	89 45 0c	 mov	 DWORD PTR _data$[ebp], eax

; 943  : 				kubun = getInteger62Token(data, S_DELIM, 1);

  00254	6a 01		 push	 1
  00256	6a 7c		 push	 124			; 0000007cH
  00258	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0025b	50		 push	 eax
  0025c	e8 00 00 00 00	 call	 ?getInteger62Token@@YAHPADDH@Z ; getInteger62Token
  00261	83 c4 0c	 add	 esp, 12			; 0000000cH
  00264	89 85 9c fd ff
	ff		 mov	 DWORD PTR _kubun$39[ebp], eax

; 944  : 				if (!bNewServer)

  0026a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bNewServer@@3HA, 0 ; bNewServer
  00271	75 0a		 jne	 SHORT $LN42@lssproto_S

; 945  : 					pc.ridePetNo = -1;

  00273	c7 05 18 51 00
	00 ff ff ff ff	 mov	 DWORD PTR ?pc@@3UPC@@A+20760, -1
$LN42@lssproto_S:

; 946  : 				if (kubun == 1)

  0027d	83 bd 9c fd ff
	ff 01		 cmp	 DWORD PTR _kubun$39[ebp], 1
  00284	0f 85 f8 02 00
	00		 jne	 $LN43@lssproto_S

; 947  : 				{
; 948  : 					pc.hp		= getIntegerToken(data, S_DELIM, 2);		// 0x00000002

  0028a	6a 02		 push	 2
  0028c	6a 7c		 push	 124			; 0000007cH
  0028e	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00291	50		 push	 eax
  00292	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00297	83 c4 0c	 add	 esp, 12			; 0000000cH
  0029a	a3 10 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+16, eax

; 949  : 					pc.maxHp	= getIntegerToken(data, S_DELIM, 3);		// 0x00000004

  0029f	6a 03		 push	 3
  002a1	6a 7c		 push	 124			; 0000007cH
  002a3	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  002a6	50		 push	 eax
  002a7	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  002ac	83 c4 0c	 add	 esp, 12			; 0000000cH
  002af	a3 14 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20, eax

; 950  : 					pc.mp		= getIntegerToken(data, S_DELIM, 4);		// 0x00000008

  002b4	6a 04		 push	 4
  002b6	6a 7c		 push	 124			; 0000007cH
  002b8	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  002bb	50		 push	 eax
  002bc	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  002c1	83 c4 0c	 add	 esp, 12			; 0000000cH
  002c4	a3 18 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+24, eax

; 951  : 					pc.maxMp	= getIntegerToken(data, S_DELIM, 5);		// 0x00000010

  002c9	6a 05		 push	 5
  002cb	6a 7c		 push	 124			; 0000007cH
  002cd	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  002d0	50		 push	 eax
  002d1	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  002d6	83 c4 0c	 add	 esp, 12			; 0000000cH
  002d9	a3 1c 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+28, eax

; 952  : 					pc.vital	= getIntegerToken(data, S_DELIM, 6);		// 0x00000020

  002de	6a 06		 push	 6
  002e0	6a 7c		 push	 124			; 0000007cH
  002e2	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  002e5	50		 push	 eax
  002e6	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  002eb	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ee	a3 20 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+32, eax

; 953  : 					pc.str		= getIntegerToken(data, S_DELIM, 7);		// 0x00000040

  002f3	6a 07		 push	 7
  002f5	6a 7c		 push	 124			; 0000007cH
  002f7	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  002fa	50		 push	 eax
  002fb	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00300	83 c4 0c	 add	 esp, 12			; 0000000cH
  00303	a3 24 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+36, eax

; 954  : 					pc.tgh		= getIntegerToken(data, S_DELIM, 8);		// 0x00000080

  00308	6a 08		 push	 8
  0030a	6a 7c		 push	 124			; 0000007cH
  0030c	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0030f	50		 push	 eax
  00310	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00315	83 c4 0c	 add	 esp, 12			; 0000000cH
  00318	a3 28 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+40, eax

; 955  : 					pc.dex		= getIntegerToken(data, S_DELIM, 9);		// 0x00000100

  0031d	6a 09		 push	 9
  0031f	6a 7c		 push	 124			; 0000007cH
  00321	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00324	50		 push	 eax
  00325	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0032a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0032d	a3 2c 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+44, eax

; 956  : 					pc.exp		= getIntegerToken(data, S_DELIM, 10);		// 0x00000200

  00332	6a 0a		 push	 10			; 0000000aH
  00334	6a 7c		 push	 124			; 0000007cH
  00336	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00339	50		 push	 eax
  0033a	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0033f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00342	a3 30 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+48, eax

; 957  : 					pc.maxExp	= getIntegerToken(data, S_DELIM, 11);		// 0x00000400

  00347	6a 0b		 push	 11			; 0000000bH
  00349	6a 7c		 push	 124			; 0000007cH
  0034b	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0034e	50		 push	 eax
  0034f	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00354	83 c4 0c	 add	 esp, 12			; 0000000cH
  00357	a3 34 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+52, eax

; 958  : 					pc.level	= getIntegerToken(data, S_DELIM, 12);		// 0x00000800

  0035c	6a 0c		 push	 12			; 0000000cH
  0035e	6a 7c		 push	 124			; 0000007cH
  00360	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00363	50		 push	 eax
  00364	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00369	83 c4 0c	 add	 esp, 12			; 0000000cH
  0036c	a3 38 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+56, eax

; 959  : 					pc.atk		= getIntegerToken(data, S_DELIM, 13);		// 0x00001000

  00371	6a 0d		 push	 13			; 0000000dH
  00373	6a 7c		 push	 124			; 0000007cH
  00375	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00378	50		 push	 eax
  00379	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0037e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00381	a3 3c 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+60, eax

; 960  : 					pc.def		= getIntegerToken(data, S_DELIM, 14);		// 0x00002000

  00386	6a 0e		 push	 14			; 0000000eH
  00388	6a 7c		 push	 124			; 0000007cH
  0038a	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0038d	50		 push	 eax
  0038e	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00393	83 c4 0c	 add	 esp, 12			; 0000000cH
  00396	a3 40 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+64, eax

; 961  : 					pc.quick	= getIntegerToken(data, S_DELIM, 15);		// 0x00004000

  0039b	6a 0f		 push	 15			; 0000000fH
  0039d	6a 7c		 push	 124			; 0000007cH
  0039f	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  003a2	50		 push	 eax
  003a3	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  003a8	83 c4 0c	 add	 esp, 12			; 0000000cH
  003ab	a3 44 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+68, eax

; 962  : 					pc.charm	= getIntegerToken(data, S_DELIM, 16);		// 0x00008000

  003b0	6a 10		 push	 16			; 00000010H
  003b2	6a 7c		 push	 124			; 0000007cH
  003b4	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  003b7	50		 push	 eax
  003b8	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  003bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  003c0	a3 48 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+72, eax

; 963  : 					pc.luck		= getIntegerToken(data, S_DELIM, 17);		// 0x00010000

  003c5	6a 11		 push	 17			; 00000011H
  003c7	6a 7c		 push	 124			; 0000007cH
  003c9	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  003cc	50		 push	 eax
  003cd	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  003d2	83 c4 0c	 add	 esp, 12			; 0000000cH
  003d5	a3 4c 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+76, eax

; 964  : 					pc.earth	= getIntegerToken(data, S_DELIM, 18);		// 0x00020000

  003da	6a 12		 push	 18			; 00000012H
  003dc	6a 7c		 push	 124			; 0000007cH
  003de	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  003e1	50		 push	 eax
  003e2	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  003e7	83 c4 0c	 add	 esp, 12			; 0000000cH
  003ea	a3 50 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+80, eax

; 965  : 					pc.water	= getIntegerToken(data, S_DELIM, 19);		// 0x00040000

  003ef	6a 13		 push	 19			; 00000013H
  003f1	6a 7c		 push	 124			; 0000007cH
  003f3	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  003f6	50		 push	 eax
  003f7	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  003fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  003ff	a3 54 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+84, eax

; 966  : 					pc.fire		= getIntegerToken(data, S_DELIM, 20);		// 0x00080000

  00404	6a 14		 push	 20			; 00000014H
  00406	6a 7c		 push	 124			; 0000007cH
  00408	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0040b	50		 push	 eax
  0040c	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00411	83 c4 0c	 add	 esp, 12			; 0000000cH
  00414	a3 58 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+88, eax

; 967  : 					pc.wind		= getIntegerToken(data, S_DELIM, 21);		// 0x00100000

  00419	6a 15		 push	 21			; 00000015H
  0041b	6a 7c		 push	 124			; 0000007cH
  0041d	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00420	50		 push	 eax
  00421	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00426	83 c4 0c	 add	 esp, 12			; 0000000cH
  00429	a3 5c 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+92, eax

; 968  : 					pc.gold		= getIntegerToken(data, S_DELIM, 22);		// 0x00200000

  0042e	6a 16		 push	 22			; 00000016H
  00430	6a 7c		 push	 124			; 0000007cH
  00432	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00435	50		 push	 eax
  00436	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0043b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0043e	a3 60 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+96, eax

; 969  : 					pc.titleNo	= getIntegerToken(data, S_DELIM, 23);		// 0x00400000

  00443	6a 17		 push	 23			; 00000017H
  00445	6a 7c		 push	 124			; 0000007cH
  00447	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0044a	50		 push	 eax
  0044b	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00450	83 c4 0c	 add	 esp, 12			; 0000000cH
  00453	a3 68 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+104, eax

; 970  : 					pc.dp		= getIntegerToken(data, S_DELIM, 24);		// 0x00800000

  00458	6a 18		 push	 24			; 00000018H
  0045a	6a 7c		 push	 124			; 0000007cH
  0045c	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0045f	50		 push	 eax
  00460	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00465	83 c4 0c	 add	 esp, 12			; 0000000cH
  00468	a3 6c 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+108, eax

; 971  : 					pc.transmigration = getIntegerToken(data, S_DELIM, 25);// 0x01000000

  0046d	6a 19		 push	 25			; 00000019H
  0046f	6a 7c		 push	 124			; 0000007cH
  00471	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00474	50		 push	 eax
  00475	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0047a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0047d	66 a3 f4 50 00
	00		 mov	 WORD PTR ?pc@@3UPC@@A+20724, ax

; 972  : 					pc.ridePetNo = getIntegerToken(data, S_DELIM, 26);	// 0x02000000

  00483	6a 1a		 push	 26			; 0000001aH
  00485	6a 7c		 push	 124			; 0000007cH
  00487	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0048a	50		 push	 eax
  0048b	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00490	83 c4 0c	 add	 esp, 12			; 0000000cH
  00493	a3 18 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20760, eax

; 973  : 					pc.learnride = getIntegerToken(data, S_DELIM, 27);	// 0x04000000

  00498	6a 1b		 push	 27			; 0000001bH
  0049a	6a 7c		 push	 124			; 0000007cH
  0049c	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0049f	50		 push	 eax
  004a0	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  004a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  004a8	a3 1c 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20764, eax

; 974  : 					pc.baseGraNo = getIntegerToken(data, S_DELIM, 28);	// 0x08000000

  004ad	6a 1c		 push	 28			; 0000001cH
  004af	6a 7c		 push	 124			; 0000007cH
  004b1	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  004b4	50		 push	 eax
  004b5	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  004ba	83 c4 0c	 add	 esp, 12			; 0000000cH
  004bd	a3 50 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20816, eax

; 975  : #ifdef _NEW_RIDEPETS
; 976  : 					pc.lowsride = getIntegerToken(data, S_DELIM, 29);		// 0x08000000

  004c2	6a 1d		 push	 29			; 0000001dH
  004c4	6a 7c		 push	 124			; 0000007cH
  004c6	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  004c9	50		 push	 eax
  004ca	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  004cf	83 c4 0c	 add	 esp, 12			; 0000000cH
  004d2	a3 20 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20768, eax

; 977  : #endif
; 978  : 					getStringToken(data, S_DELIM, 30, sizeof(name) - 1, name);

  004d7	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _name$42[ebp]
  004dd	50		 push	 eax
  004de	68 ff 00 00 00	 push	 255			; 000000ffH
  004e3	6a 1e		 push	 30			; 0000001eH
  004e5	6a 7c		 push	 124			; 0000007cH
  004e7	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  004ea	51		 push	 ecx
  004eb	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  004f0	83 c4 14	 add	 esp, 20			; 00000014H

; 979  : 					makeStringFromEscaped(name);

  004f3	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _name$42[ebp]
  004f9	50		 push	 eax
  004fa	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  004ff	83 c4 04	 add	 esp, 4

; 980  : 					if (strlen(name) <= CHAR_NAME_LEN)

  00502	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _name$42[ebp]
  00508	50		 push	 eax
  00509	e8 00 00 00 00	 call	 _strlen
  0050e	83 c4 04	 add	 esp, 4
  00511	83 f8 10	 cmp	 eax, 16			; 00000010H
  00514	77 14		 ja	 SHORT $LN45@lssproto_S

; 981  : 						strcpy(pc.name, name);

  00516	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _name$42[ebp]
  0051c	50		 push	 eax
  0051d	68 70 00 00 00	 push	 OFFSET ?pc@@3UPC@@A+112
  00522	e8 00 00 00 00	 call	 _strcpy
  00527	83 c4 08	 add	 esp, 8
$LN45@lssproto_S:

; 982  : 					getStringToken(data, S_DELIM, 31, sizeof(freeName) - 1, freeName);

  0052a	8d 85 b4 fd ff
	ff		 lea	 eax, DWORD PTR _freeName$41[ebp]
  00530	50		 push	 eax
  00531	68 ff 00 00 00	 push	 255			; 000000ffH
  00536	6a 1f		 push	 31			; 0000001fH
  00538	6a 7c		 push	 124			; 0000007cH
  0053a	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0053d	51		 push	 ecx
  0053e	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00543	83 c4 14	 add	 esp, 20			; 00000014H

; 983  : 					makeStringFromEscaped(freeName);

  00546	8d 85 b4 fd ff
	ff		 lea	 eax, DWORD PTR _freeName$41[ebp]
  0054c	50		 push	 eax
  0054d	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  00552	83 c4 04	 add	 esp, 4

; 984  : 					if (strlen(freeName) <= CHAR_FREENAME_LEN)

  00555	8d 85 b4 fd ff
	ff		 lea	 eax, DWORD PTR _freeName$41[ebp]
  0055b	50		 push	 eax
  0055c	e8 00 00 00 00	 call	 _strlen
  00561	83 c4 04	 add	 esp, 4
  00564	83 f8 20	 cmp	 eax, 32			; 00000020H
  00567	77 14		 ja	 SHORT $LN46@lssproto_S

; 985  : 						strcpy(pc.freeName, freeName);

  00569	8d 85 b4 fd ff
	ff		 lea	 eax, DWORD PTR _freeName$41[ebp]
  0056f	50		 push	 eax
  00570	68 81 00 00 00	 push	 OFFSET ?pc@@3UPC@@A+129
  00575	e8 00 00 00 00	 call	 _strcpy
  0057a	83 c4 08	 add	 esp, 8
$LN46@lssproto_S:

; 986  : 				}
; 987  : 				else

  0057d	e9 74 07 00 00	 jmp	 $LN44@lssproto_S
$LN43@lssproto_S:

; 988  : 				{
; 989  : 					mask = 2;

  00582	c7 85 90 fd ff
	ff 02 00 00 00	 mov	 DWORD PTR _mask$38[ebp], 2

; 990  : 					i = 2;

  0058c	c7 85 a8 fd ff
	ff 02 00 00 00	 mov	 DWORD PTR _i$40[ebp], 2

; 991  : 					for (; mask > 0; mask <<= 1)

  00596	eb 0e		 jmp	 SHORT $LN6@lssproto_S
$LN4@lssproto_S:
  00598	8b 85 90 fd ff
	ff		 mov	 eax, DWORD PTR _mask$38[ebp]
  0059e	d1 e0		 shl	 eax, 1
  005a0	89 85 90 fd ff
	ff		 mov	 DWORD PTR _mask$38[ebp], eax
$LN6@lssproto_S:
  005a6	83 bd 90 fd ff
	ff 00		 cmp	 DWORD PTR _mask$38[ebp], 0
  005ad	0f 86 43 07 00
	00		 jbe	 $LN44@lssproto_S

; 992  : 					{
; 993  : 						if (kubun & mask)

  005b3	8b 85 9c fd ff
	ff		 mov	 eax, DWORD PTR _kubun$39[ebp]
  005b9	23 85 90 fd ff
	ff		 and	 eax, DWORD PTR _mask$38[ebp]
  005bf	0f 84 2c 07 00
	00		 je	 $LN47@lssproto_S

; 994  : 						{
; 995  : 							if (mask == 0x00000002) // ( 1 << 1 )

  005c5	83 bd 90 fd ff
	ff 02		 cmp	 DWORD PTR _mask$38[ebp], 2
  005cc	75 2e		 jne	 SHORT $LN48@lssproto_S

; 996  : 							{
; 997  : 								pc.hp = getIntegerToken(data, S_DELIM, i);// 0x00000002

  005ce	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  005d4	50		 push	 eax
  005d5	6a 7c		 push	 124			; 0000007cH
  005d7	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  005da	51		 push	 ecx
  005db	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  005e0	83 c4 0c	 add	 esp, 12			; 0000000cH
  005e3	a3 10 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+16, eax

; 998  : 								i++;

  005e8	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  005ee	83 c0 01	 add	 eax, 1
  005f1	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  005f7	e9 f5 06 00 00	 jmp	 $LN47@lssproto_S
$LN48@lssproto_S:

; 999  : 							}
; 1000 : 							else if (mask == 0x00000004) // ( 1 << 2 )

  005fc	83 bd 90 fd ff
	ff 04		 cmp	 DWORD PTR _mask$38[ebp], 4
  00603	75 2e		 jne	 SHORT $LN50@lssproto_S

; 1001 : 							{
; 1002 : 								pc.maxHp = getIntegerToken(data, S_DELIM, i);// 0x00000004

  00605	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  0060b	50		 push	 eax
  0060c	6a 7c		 push	 124			; 0000007cH
  0060e	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00611	51		 push	 ecx
  00612	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00617	83 c4 0c	 add	 esp, 12			; 0000000cH
  0061a	a3 14 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20, eax

; 1003 : 								i++;

  0061f	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00625	83 c0 01	 add	 eax, 1
  00628	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  0062e	e9 be 06 00 00	 jmp	 $LN47@lssproto_S
$LN50@lssproto_S:

; 1004 : 							}
; 1005 : 							else if (mask == 0x00000008)

  00633	83 bd 90 fd ff
	ff 08		 cmp	 DWORD PTR _mask$38[ebp], 8
  0063a	75 2e		 jne	 SHORT $LN52@lssproto_S

; 1006 : 							{
; 1007 : 								pc.mp = getIntegerToken(data, S_DELIM, i);// 0x00000008

  0063c	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00642	50		 push	 eax
  00643	6a 7c		 push	 124			; 0000007cH
  00645	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00648	51		 push	 ecx
  00649	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0064e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00651	a3 18 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+24, eax

; 1008 : 								i++;

  00656	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  0065c	83 c0 01	 add	 eax, 1
  0065f	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  00665	e9 87 06 00 00	 jmp	 $LN47@lssproto_S
$LN52@lssproto_S:

; 1009 : 							}
; 1010 : 							else if (mask == 0x00000010)

  0066a	83 bd 90 fd ff
	ff 10		 cmp	 DWORD PTR _mask$38[ebp], 16 ; 00000010H
  00671	75 2e		 jne	 SHORT $LN54@lssproto_S

; 1011 : 							{
; 1012 : 								pc.maxMp = getIntegerToken(data, S_DELIM, i);// 0x00000010

  00673	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00679	50		 push	 eax
  0067a	6a 7c		 push	 124			; 0000007cH
  0067c	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0067f	51		 push	 ecx
  00680	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00685	83 c4 0c	 add	 esp, 12			; 0000000cH
  00688	a3 1c 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+28, eax

; 1013 : 								i++;

  0068d	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00693	83 c0 01	 add	 eax, 1
  00696	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  0069c	e9 50 06 00 00	 jmp	 $LN47@lssproto_S
$LN54@lssproto_S:

; 1014 : 							}
; 1015 : 							else if (mask == 0x00000020)

  006a1	83 bd 90 fd ff
	ff 20		 cmp	 DWORD PTR _mask$38[ebp], 32 ; 00000020H
  006a8	75 2e		 jne	 SHORT $LN56@lssproto_S

; 1016 : 							{
; 1017 : 								pc.vital = getIntegerToken(data, S_DELIM, i);// 0x00000020

  006aa	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  006b0	50		 push	 eax
  006b1	6a 7c		 push	 124			; 0000007cH
  006b3	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  006b6	51		 push	 ecx
  006b7	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  006bc	83 c4 0c	 add	 esp, 12			; 0000000cH
  006bf	a3 20 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+32, eax

; 1018 : 								i++;

  006c4	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  006ca	83 c0 01	 add	 eax, 1
  006cd	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  006d3	e9 19 06 00 00	 jmp	 $LN47@lssproto_S
$LN56@lssproto_S:

; 1019 : 							}
; 1020 : 							else if (mask == 0x00000040)

  006d8	83 bd 90 fd ff
	ff 40		 cmp	 DWORD PTR _mask$38[ebp], 64 ; 00000040H
  006df	75 2e		 jne	 SHORT $LN58@lssproto_S

; 1021 : 							{
; 1022 : 								pc.str = getIntegerToken(data, S_DELIM, i);// 0x00000040

  006e1	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  006e7	50		 push	 eax
  006e8	6a 7c		 push	 124			; 0000007cH
  006ea	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  006ed	51		 push	 ecx
  006ee	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  006f3	83 c4 0c	 add	 esp, 12			; 0000000cH
  006f6	a3 24 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+36, eax

; 1023 : 								i++;

  006fb	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00701	83 c0 01	 add	 eax, 1
  00704	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  0070a	e9 e2 05 00 00	 jmp	 $LN47@lssproto_S
$LN58@lssproto_S:

; 1024 : 							}
; 1025 : 							else if (mask == 0x00000080)

  0070f	81 bd 90 fd ff
	ff 80 00 00 00	 cmp	 DWORD PTR _mask$38[ebp], 128 ; 00000080H
  00719	75 2e		 jne	 SHORT $LN60@lssproto_S

; 1026 : 							{
; 1027 : 								pc.tgh = getIntegerToken(data, S_DELIM, i);// 0x00000080

  0071b	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00721	50		 push	 eax
  00722	6a 7c		 push	 124			; 0000007cH
  00724	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00727	51		 push	 ecx
  00728	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0072d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00730	a3 28 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+40, eax

; 1028 : 								i++;

  00735	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  0073b	83 c0 01	 add	 eax, 1
  0073e	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  00744	e9 a8 05 00 00	 jmp	 $LN47@lssproto_S
$LN60@lssproto_S:

; 1029 : 							}
; 1030 : 							else if (mask == 0x00000100)

  00749	81 bd 90 fd ff
	ff 00 01 00 00	 cmp	 DWORD PTR _mask$38[ebp], 256 ; 00000100H
  00753	75 2e		 jne	 SHORT $LN62@lssproto_S

; 1031 : 							{
; 1032 : 								pc.dex = getIntegerToken(data, S_DELIM, i);// 0x00000100

  00755	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  0075b	50		 push	 eax
  0075c	6a 7c		 push	 124			; 0000007cH
  0075e	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00761	51		 push	 ecx
  00762	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00767	83 c4 0c	 add	 esp, 12			; 0000000cH
  0076a	a3 2c 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+44, eax

; 1033 : 								i++;

  0076f	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00775	83 c0 01	 add	 eax, 1
  00778	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  0077e	e9 6e 05 00 00	 jmp	 $LN47@lssproto_S
$LN62@lssproto_S:

; 1034 : 							}
; 1035 : 							else if (mask == 0x00000200)

  00783	81 bd 90 fd ff
	ff 00 02 00 00	 cmp	 DWORD PTR _mask$38[ebp], 512 ; 00000200H
  0078d	75 2e		 jne	 SHORT $LN64@lssproto_S

; 1036 : 							{
; 1037 : 								pc.exp = getIntegerToken(data, S_DELIM, i);// 0x00000200

  0078f	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00795	50		 push	 eax
  00796	6a 7c		 push	 124			; 0000007cH
  00798	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0079b	51		 push	 ecx
  0079c	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  007a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  007a4	a3 30 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+48, eax

; 1038 : 								i++;

  007a9	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  007af	83 c0 01	 add	 eax, 1
  007b2	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  007b8	e9 34 05 00 00	 jmp	 $LN47@lssproto_S
$LN64@lssproto_S:

; 1039 : 							}
; 1040 : 							else if (mask == 0x00000400)

  007bd	81 bd 90 fd ff
	ff 00 04 00 00	 cmp	 DWORD PTR _mask$38[ebp], 1024 ; 00000400H
  007c7	75 2e		 jne	 SHORT $LN66@lssproto_S

; 1041 : 							{
; 1042 : 								pc.maxExp = getIntegerToken(data, S_DELIM, i);// 0x00000400

  007c9	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  007cf	50		 push	 eax
  007d0	6a 7c		 push	 124			; 0000007cH
  007d2	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  007d5	51		 push	 ecx
  007d6	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  007db	83 c4 0c	 add	 esp, 12			; 0000000cH
  007de	a3 34 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+52, eax

; 1043 : 								i++;

  007e3	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  007e9	83 c0 01	 add	 eax, 1
  007ec	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  007f2	e9 fa 04 00 00	 jmp	 $LN47@lssproto_S
$LN66@lssproto_S:

; 1044 : 							}
; 1045 : 							else if (mask == 0x00000800)

  007f7	81 bd 90 fd ff
	ff 00 08 00 00	 cmp	 DWORD PTR _mask$38[ebp], 2048 ; 00000800H
  00801	75 2e		 jne	 SHORT $LN68@lssproto_S

; 1046 : 							{
; 1047 : 								pc.level = getIntegerToken(data, S_DELIM, i);// 0x00000800

  00803	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00809	50		 push	 eax
  0080a	6a 7c		 push	 124			; 0000007cH
  0080c	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0080f	51		 push	 ecx
  00810	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00815	83 c4 0c	 add	 esp, 12			; 0000000cH
  00818	a3 38 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+56, eax

; 1048 : 								i++;

  0081d	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00823	83 c0 01	 add	 eax, 1
  00826	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  0082c	e9 c0 04 00 00	 jmp	 $LN47@lssproto_S
$LN68@lssproto_S:

; 1049 : 							}
; 1050 : 							else if (mask == 0x00001000)

  00831	81 bd 90 fd ff
	ff 00 10 00 00	 cmp	 DWORD PTR _mask$38[ebp], 4096 ; 00001000H
  0083b	75 2e		 jne	 SHORT $LN70@lssproto_S

; 1051 : 							{
; 1052 : 								pc.atk = getIntegerToken(data, S_DELIM, i);// 0x00001000

  0083d	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00843	50		 push	 eax
  00844	6a 7c		 push	 124			; 0000007cH
  00846	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00849	51		 push	 ecx
  0084a	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0084f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00852	a3 3c 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+60, eax

; 1053 : 								i++;

  00857	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  0085d	83 c0 01	 add	 eax, 1
  00860	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  00866	e9 86 04 00 00	 jmp	 $LN47@lssproto_S
$LN70@lssproto_S:

; 1054 : 							}
; 1055 : 							else if (mask == 0x00002000)

  0086b	81 bd 90 fd ff
	ff 00 20 00 00	 cmp	 DWORD PTR _mask$38[ebp], 8192 ; 00002000H
  00875	75 2e		 jne	 SHORT $LN72@lssproto_S

; 1056 : 							{
; 1057 : 								pc.def = getIntegerToken(data, S_DELIM, i);// 0x00002000

  00877	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  0087d	50		 push	 eax
  0087e	6a 7c		 push	 124			; 0000007cH
  00880	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00883	51		 push	 ecx
  00884	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00889	83 c4 0c	 add	 esp, 12			; 0000000cH
  0088c	a3 40 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+64, eax

; 1058 : 								i++;

  00891	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00897	83 c0 01	 add	 eax, 1
  0089a	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  008a0	e9 4c 04 00 00	 jmp	 $LN47@lssproto_S
$LN72@lssproto_S:

; 1059 : 							}
; 1060 : 							else if (mask == 0x00004000)

  008a5	81 bd 90 fd ff
	ff 00 40 00 00	 cmp	 DWORD PTR _mask$38[ebp], 16384 ; 00004000H
  008af	75 2e		 jne	 SHORT $LN74@lssproto_S

; 1061 : 							{
; 1062 : 								pc.quick = getIntegerToken(data, S_DELIM, i);// 0x00004000

  008b1	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  008b7	50		 push	 eax
  008b8	6a 7c		 push	 124			; 0000007cH
  008ba	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  008bd	51		 push	 ecx
  008be	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  008c3	83 c4 0c	 add	 esp, 12			; 0000000cH
  008c6	a3 44 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+68, eax

; 1063 : 								i++;

  008cb	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  008d1	83 c0 01	 add	 eax, 1
  008d4	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  008da	e9 12 04 00 00	 jmp	 $LN47@lssproto_S
$LN74@lssproto_S:

; 1064 : 							}
; 1065 : 							else if (mask == 0x00008000)

  008df	81 bd 90 fd ff
	ff 00 80 00 00	 cmp	 DWORD PTR _mask$38[ebp], 32768 ; 00008000H
  008e9	75 2e		 jne	 SHORT $LN76@lssproto_S

; 1066 : 							{
; 1067 : 								pc.charm = getIntegerToken(data, S_DELIM, i);// 0x00008000

  008eb	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  008f1	50		 push	 eax
  008f2	6a 7c		 push	 124			; 0000007cH
  008f4	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  008f7	51		 push	 ecx
  008f8	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  008fd	83 c4 0c	 add	 esp, 12			; 0000000cH
  00900	a3 48 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+72, eax

; 1068 : 								i++;

  00905	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  0090b	83 c0 01	 add	 eax, 1
  0090e	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  00914	e9 d8 03 00 00	 jmp	 $LN47@lssproto_S
$LN76@lssproto_S:

; 1069 : 							}
; 1070 : 							else if (mask == 0x00010000)

  00919	81 bd 90 fd ff
	ff 00 00 01 00	 cmp	 DWORD PTR _mask$38[ebp], 65536 ; 00010000H
  00923	75 2e		 jne	 SHORT $LN78@lssproto_S

; 1071 : 							{
; 1072 : 								pc.luck = getIntegerToken(data, S_DELIM, i);// 0x00010000

  00925	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  0092b	50		 push	 eax
  0092c	6a 7c		 push	 124			; 0000007cH
  0092e	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00931	51		 push	 ecx
  00932	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00937	83 c4 0c	 add	 esp, 12			; 0000000cH
  0093a	a3 4c 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+76, eax

; 1073 : 								i++;

  0093f	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00945	83 c0 01	 add	 eax, 1
  00948	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  0094e	e9 9e 03 00 00	 jmp	 $LN47@lssproto_S
$LN78@lssproto_S:

; 1074 : 							}
; 1075 : 							else if (mask == 0x00020000)

  00953	81 bd 90 fd ff
	ff 00 00 02 00	 cmp	 DWORD PTR _mask$38[ebp], 131072 ; 00020000H
  0095d	75 2e		 jne	 SHORT $LN80@lssproto_S

; 1076 : 							{
; 1077 : 								pc.earth = getIntegerToken(data, S_DELIM, i);// 0x00020000

  0095f	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00965	50		 push	 eax
  00966	6a 7c		 push	 124			; 0000007cH
  00968	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0096b	51		 push	 ecx
  0096c	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00971	83 c4 0c	 add	 esp, 12			; 0000000cH
  00974	a3 50 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+80, eax

; 1078 : 								i++;

  00979	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  0097f	83 c0 01	 add	 eax, 1
  00982	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  00988	e9 64 03 00 00	 jmp	 $LN47@lssproto_S
$LN80@lssproto_S:

; 1079 : 							}
; 1080 : 							else if (mask == 0x00040000)

  0098d	81 bd 90 fd ff
	ff 00 00 04 00	 cmp	 DWORD PTR _mask$38[ebp], 262144 ; 00040000H
  00997	75 2e		 jne	 SHORT $LN82@lssproto_S

; 1081 : 							{
; 1082 : 								pc.water = getIntegerToken(data, S_DELIM, i);// 0x00040000

  00999	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  0099f	50		 push	 eax
  009a0	6a 7c		 push	 124			; 0000007cH
  009a2	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  009a5	51		 push	 ecx
  009a6	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  009ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  009ae	a3 54 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+84, eax

; 1083 : 								i++;

  009b3	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  009b9	83 c0 01	 add	 eax, 1
  009bc	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  009c2	e9 2a 03 00 00	 jmp	 $LN47@lssproto_S
$LN82@lssproto_S:

; 1084 : 							}
; 1085 : 							else if (mask == 0x00080000)

  009c7	81 bd 90 fd ff
	ff 00 00 08 00	 cmp	 DWORD PTR _mask$38[ebp], 524288 ; 00080000H
  009d1	75 2e		 jne	 SHORT $LN84@lssproto_S

; 1086 : 							{
; 1087 : 								pc.fire = getIntegerToken(data, S_DELIM, i);// 0x00080000

  009d3	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  009d9	50		 push	 eax
  009da	6a 7c		 push	 124			; 0000007cH
  009dc	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  009df	51		 push	 ecx
  009e0	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  009e5	83 c4 0c	 add	 esp, 12			; 0000000cH
  009e8	a3 58 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+88, eax

; 1088 : 								i++;

  009ed	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  009f3	83 c0 01	 add	 eax, 1
  009f6	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  009fc	e9 f0 02 00 00	 jmp	 $LN47@lssproto_S
$LN84@lssproto_S:

; 1089 : 							}
; 1090 : 							else if (mask == 0x00100000)

  00a01	81 bd 90 fd ff
	ff 00 00 10 00	 cmp	 DWORD PTR _mask$38[ebp], 1048576 ; 00100000H
  00a0b	75 2e		 jne	 SHORT $LN86@lssproto_S

; 1091 : 							{
; 1092 : 								pc.wind = getIntegerToken(data, S_DELIM, i);// 0x00100000

  00a0d	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00a13	50		 push	 eax
  00a14	6a 7c		 push	 124			; 0000007cH
  00a16	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00a19	51		 push	 ecx
  00a1a	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00a1f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a22	a3 5c 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+92, eax

; 1093 : 								i++;

  00a27	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00a2d	83 c0 01	 add	 eax, 1
  00a30	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  00a36	e9 b6 02 00 00	 jmp	 $LN47@lssproto_S
$LN86@lssproto_S:

; 1094 : 							}
; 1095 : 							else if (mask == 0x00200000)

  00a3b	81 bd 90 fd ff
	ff 00 00 20 00	 cmp	 DWORD PTR _mask$38[ebp], 2097152 ; 00200000H
  00a45	75 2e		 jne	 SHORT $LN88@lssproto_S

; 1096 : 							{
; 1097 : 								pc.gold = getIntegerToken(data, S_DELIM, i);// 0x00200000

  00a47	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00a4d	50		 push	 eax
  00a4e	6a 7c		 push	 124			; 0000007cH
  00a50	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00a53	51		 push	 ecx
  00a54	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00a59	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a5c	a3 60 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+96, eax

; 1098 : 								i++;

  00a61	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00a67	83 c0 01	 add	 eax, 1
  00a6a	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  00a70	e9 7c 02 00 00	 jmp	 $LN47@lssproto_S
$LN88@lssproto_S:

; 1099 : 							}
; 1100 : 							else if (mask == 0x00400000)

  00a75	81 bd 90 fd ff
	ff 00 00 40 00	 cmp	 DWORD PTR _mask$38[ebp], 4194304 ; 00400000H
  00a7f	75 2e		 jne	 SHORT $LN90@lssproto_S

; 1101 : 							{
; 1102 : 								pc.titleNo = getIntegerToken(data, S_DELIM, i);// 0x00400000

  00a81	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00a87	50		 push	 eax
  00a88	6a 7c		 push	 124			; 0000007cH
  00a8a	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00a8d	51		 push	 ecx
  00a8e	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00a93	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a96	a3 68 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+104, eax

; 1103 : 								i++;

  00a9b	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00aa1	83 c0 01	 add	 eax, 1
  00aa4	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  00aaa	e9 42 02 00 00	 jmp	 $LN47@lssproto_S
$LN90@lssproto_S:

; 1104 : 							}
; 1105 : 							else if (mask == 0x00800000)

  00aaf	81 bd 90 fd ff
	ff 00 00 80 00	 cmp	 DWORD PTR _mask$38[ebp], 8388608 ; 00800000H
  00ab9	75 2e		 jne	 SHORT $LN92@lssproto_S

; 1106 : 							{
; 1107 : 								pc.dp = getIntegerToken(data, S_DELIM, i);// 0x00800000

  00abb	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00ac1	50		 push	 eax
  00ac2	6a 7c		 push	 124			; 0000007cH
  00ac4	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00ac7	51		 push	 ecx
  00ac8	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00acd	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ad0	a3 6c 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+108, eax

; 1108 : 								i++;

  00ad5	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00adb	83 c0 01	 add	 eax, 1
  00ade	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  00ae4	e9 08 02 00 00	 jmp	 $LN47@lssproto_S
$LN92@lssproto_S:

; 1109 : 							}
; 1110 : 							else if (mask == 0x01000000)

  00ae9	81 bd 90 fd ff
	ff 00 00 00 01	 cmp	 DWORD PTR _mask$38[ebp], 16777216 ; 01000000H
  00af3	75 2f		 jne	 SHORT $LN94@lssproto_S

; 1111 : 							{
; 1112 : 								pc.transmigration = getIntegerToken(data, S_DELIM, i);// 0x01000000

  00af5	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00afb	50		 push	 eax
  00afc	6a 7c		 push	 124			; 0000007cH
  00afe	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00b01	51		 push	 ecx
  00b02	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00b07	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b0a	66 a3 f4 50 00
	00		 mov	 WORD PTR ?pc@@3UPC@@A+20724, ax

; 1113 : 								i++;

  00b10	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00b16	83 c0 01	 add	 eax, 1
  00b19	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  00b1f	e9 cd 01 00 00	 jmp	 $LN47@lssproto_S
$LN94@lssproto_S:

; 1114 : 							}
; 1115 : 							else if (mask == 0x02000000)

  00b24	81 bd 90 fd ff
	ff 00 00 00 02	 cmp	 DWORD PTR _mask$38[ebp], 33554432 ; 02000000H
  00b2e	75 6c		 jne	 SHORT $LN96@lssproto_S

; 1116 : 							{
; 1117 : 								getStringToken(data, S_DELIM, i, sizeof(name) - 1, name);// 0x01000000

  00b30	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _name$42[ebp]
  00b36	50		 push	 eax
  00b37	68 ff 00 00 00	 push	 255			; 000000ffH
  00b3c	8b 8d a8 fd ff
	ff		 mov	 ecx, DWORD PTR _i$40[ebp]
  00b42	51		 push	 ecx
  00b43	6a 7c		 push	 124			; 0000007cH
  00b45	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  00b48	52		 push	 edx
  00b49	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00b4e	83 c4 14	 add	 esp, 20			; 00000014H

; 1118 : 								makeStringFromEscaped(name);

  00b51	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _name$42[ebp]
  00b57	50		 push	 eax
  00b58	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  00b5d	83 c4 04	 add	 esp, 4

; 1119 : 								if (strlen(name) <= CHAR_NAME_LEN)

  00b60	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _name$42[ebp]
  00b66	50		 push	 eax
  00b67	e8 00 00 00 00	 call	 _strlen
  00b6c	83 c4 04	 add	 esp, 4
  00b6f	83 f8 10	 cmp	 eax, 16			; 00000010H
  00b72	77 14		 ja	 SHORT $LN98@lssproto_S

; 1120 : 									strcpy(pc.name, name);

  00b74	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _name$42[ebp]
  00b7a	50		 push	 eax
  00b7b	68 70 00 00 00	 push	 OFFSET ?pc@@3UPC@@A+112
  00b80	e8 00 00 00 00	 call	 _strcpy
  00b85	83 c4 08	 add	 esp, 8
$LN98@lssproto_S:

; 1121 : 								i++;

  00b88	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00b8e	83 c0 01	 add	 eax, 1
  00b91	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  00b97	e9 55 01 00 00	 jmp	 $LN47@lssproto_S
$LN96@lssproto_S:

; 1122 : 							}
; 1123 : 							else if (mask == 0x04000000)

  00b9c	81 bd 90 fd ff
	ff 00 00 00 04	 cmp	 DWORD PTR _mask$38[ebp], 67108864 ; 04000000H
  00ba6	75 6c		 jne	 SHORT $LN99@lssproto_S

; 1124 : 							{
; 1125 : 								getStringToken(data, S_DELIM, i, sizeof(freeName) - 1, freeName);// 0x02000000

  00ba8	8d 85 b4 fd ff
	ff		 lea	 eax, DWORD PTR _freeName$41[ebp]
  00bae	50		 push	 eax
  00baf	68 ff 00 00 00	 push	 255			; 000000ffH
  00bb4	8b 8d a8 fd ff
	ff		 mov	 ecx, DWORD PTR _i$40[ebp]
  00bba	51		 push	 ecx
  00bbb	6a 7c		 push	 124			; 0000007cH
  00bbd	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  00bc0	52		 push	 edx
  00bc1	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00bc6	83 c4 14	 add	 esp, 20			; 00000014H

; 1126 : 								makeStringFromEscaped(freeName);

  00bc9	8d 85 b4 fd ff
	ff		 lea	 eax, DWORD PTR _freeName$41[ebp]
  00bcf	50		 push	 eax
  00bd0	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  00bd5	83 c4 04	 add	 esp, 4

; 1127 : 								if (strlen(freeName) <= CHAR_FREENAME_LEN)

  00bd8	8d 85 b4 fd ff
	ff		 lea	 eax, DWORD PTR _freeName$41[ebp]
  00bde	50		 push	 eax
  00bdf	e8 00 00 00 00	 call	 _strlen
  00be4	83 c4 04	 add	 esp, 4
  00be7	83 f8 20	 cmp	 eax, 32			; 00000020H
  00bea	77 14		 ja	 SHORT $LN101@lssproto_S

; 1128 : 									strcpy(pc.freeName, freeName);

  00bec	8d 85 b4 fd ff
	ff		 lea	 eax, DWORD PTR _freeName$41[ebp]
  00bf2	50		 push	 eax
  00bf3	68 81 00 00 00	 push	 OFFSET ?pc@@3UPC@@A+129
  00bf8	e8 00 00 00 00	 call	 _strcpy
  00bfd	83 c4 08	 add	 esp, 8
$LN101@lssproto_S:

; 1129 : 								i++;

  00c00	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00c06	83 c0 01	 add	 eax, 1
  00c09	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  00c0f	e9 dd 00 00 00	 jmp	 $LN47@lssproto_S
$LN99@lssproto_S:

; 1130 : 							}
; 1131 : 							else if (mask == 0x08000000) // ( 1 << 27 )

  00c14	81 bd 90 fd ff
	ff 00 00 00 08	 cmp	 DWORD PTR _mask$38[ebp], 134217728 ; 08000000H
  00c1e	75 2e		 jne	 SHORT $LN102@lssproto_S

; 1132 : 							{
; 1133 : 								pc.ridePetNo = getIntegerToken(data, S_DELIM, i);// 0x08000000

  00c20	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00c26	50		 push	 eax
  00c27	6a 7c		 push	 124			; 0000007cH
  00c29	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00c2c	51		 push	 ecx
  00c2d	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00c32	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c35	a3 18 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20760, eax

; 1134 : 								i++;

  00c3a	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00c40	83 c0 01	 add	 eax, 1
  00c43	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  00c49	e9 a3 00 00 00	 jmp	 $LN47@lssproto_S
$LN102@lssproto_S:

; 1135 : 							}
; 1136 : 							else if (mask == 0x10000000) // ( 1 << 28 )

  00c4e	81 bd 90 fd ff
	ff 00 00 00 10	 cmp	 DWORD PTR _mask$38[ebp], 268435456 ; 10000000H
  00c58	75 2b		 jne	 SHORT $LN104@lssproto_S

; 1137 : 							{
; 1138 : 								pc.learnride = getIntegerToken(data, S_DELIM, i);// 0x10000000

  00c5a	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00c60	50		 push	 eax
  00c61	6a 7c		 push	 124			; 0000007cH
  00c63	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00c66	51		 push	 ecx
  00c67	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00c6c	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c6f	a3 1c 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20764, eax

; 1139 : 								i++;

  00c74	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00c7a	83 c0 01	 add	 eax, 1
  00c7d	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  00c83	eb 6c		 jmp	 SHORT $LN47@lssproto_S
$LN104@lssproto_S:

; 1140 : 							}
; 1141 : 							else if (mask == 0x20000000) // ( 1 << 29 )

  00c85	81 bd 90 fd ff
	ff 00 00 00 20	 cmp	 DWORD PTR _mask$38[ebp], 536870912 ; 20000000H
  00c8f	75 2b		 jne	 SHORT $LN106@lssproto_S

; 1142 : 							{
; 1143 : 								pc.baseGraNo = getIntegerToken(data, S_DELIM, i);// 0x20000000

  00c91	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00c97	50		 push	 eax
  00c98	6a 7c		 push	 124			; 0000007cH
  00c9a	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00c9d	51		 push	 ecx
  00c9e	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00ca3	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ca6	a3 50 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20816, eax

; 1144 : 								i++;

  00cab	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00cb1	83 c0 01	 add	 eax, 1
  00cb4	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
  00cba	eb 35		 jmp	 SHORT $LN47@lssproto_S
$LN106@lssproto_S:

; 1145 : 							}
; 1146 : 							else if (mask == 0x40000000) // ( 1 << 30 )

  00cbc	81 bd 90 fd ff
	ff 00 00 00 40	 cmp	 DWORD PTR _mask$38[ebp], 1073741824 ; 40000000H
  00cc6	75 29		 jne	 SHORT $LN47@lssproto_S

; 1147 : 							{
; 1148 : 								pc.skywalker = getIntegerToken(data, S_DELIM, i);// 0x40000000

  00cc8	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00cce	50		 push	 eax
  00ccf	6a 7c		 push	 124			; 0000007cH
  00cd1	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00cd4	51		 push	 ecx
  00cd5	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00cda	83 c4 0c	 add	 esp, 12			; 0000000cH
  00cdd	a3 bc a1 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+41404, eax

; 1149 : 								i++;

  00ce2	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00ce8	83 c0 01	 add	 eax, 1
  00ceb	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
$LN47@lssproto_S:

; 1150 : 							}
; 1151 : 							//else if (mask == 0x80000000 ){ // ( 1 << 31 )
; 1152 : 								//	pc.debugmode = getIntegerToken(data, S_DELIM, i);// 0x80000000
; 1153 : 								//	i++;
; 1154 : 							//}
; 1155 : 						}
; 1156 : 					}

  00cf1	e9 a2 f8 ff ff	 jmp	 $LN4@lssproto_S
$LN44@lssproto_S:

; 1157 : 				}
; 1158 : 				updataPcAct();

  00cf6	e8 00 00 00 00	 call	 ?updataPcAct@@YAXXZ	; updataPcAct

; 1159 : 				if ((pc.status & CHR_STATUS_LEADER) != 0 && party[0].useFlag != 0)

  00cfb	a1 a4 00 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+164
  00d00	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00d05	74 6b		 je	 SHORT $LN109@lssproto_S
  00d07	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  00d0c	6b c8 00	 imul	 ecx, eax, 0
  00d0f	0f bf 91 00 00
	00 00		 movsx	 edx, WORD PTR ?party@@3PAUPARTY@@A[ecx]
  00d16	85 d2		 test	 edx, edx
  00d18	74 58		 je	 SHORT $LN109@lssproto_S

; 1160 : 				{
; 1161 : 					party[0].level = pc.level;

  00d1a	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  00d1f	6b c8 00	 imul	 ecx, eax, 0
  00d22	8b 15 38 00 00
	00		 mov	 edx, DWORD PTR ?pc@@3UPC@@A+56
  00d28	89 91 08 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[ecx+8], edx

; 1162 : 					party[0].maxHp = pc.maxHp;

  00d2e	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  00d33	6b c8 00	 imul	 ecx, eax, 0
  00d36	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?pc@@3UPC@@A+20
  00d3c	89 91 0c 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[ecx+12], edx

; 1163 : 					party[0].hp = pc.hp;

  00d42	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  00d47	6b c8 00	 imul	 ecx, eax, 0
  00d4a	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR ?pc@@3UPC@@A+16
  00d50	89 91 10 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[ecx+16], edx

; 1164 : 					strcpy(party[0].name, pc.name);

  00d56	68 70 00 00 00	 push	 OFFSET ?pc@@3UPC@@A+112
  00d5b	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  00d60	6b c8 00	 imul	 ecx, eax, 0
  00d63	81 c1 18 00 00
	00		 add	 ecx, OFFSET ?party@@3PAUPARTY@@A+24
  00d69	51		 push	 ecx
  00d6a	e8 00 00 00 00	 call	 _strcpy
  00d6f	83 c4 08	 add	 esp, 8
$LN109@lssproto_S:

; 1165 : 				}
; 1166 : 			}
; 1167 : 			if (!bNewServer)

  00d72	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bNewServer@@3HA, 0 ; bNewServer
  00d79	75 0a		 jne	 SHORT $LN110@lssproto_S

; 1168 : 				pc.ridePetNo = -1;

  00d7b	c7 05 18 51 00
	00 ff ff ff ff	 mov	 DWORD PTR ?pc@@3UPC@@A+20760, -1
$LN110@lssproto_S:

; 1169 : 			if ((bNewServer & 0xf000000) == 0xf000000 && sPetStatFlag == 1)

  00d85	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bNewServer@@3HA ; bNewServer
  00d8a	25 00 00 00 0f	 and	 eax, 251658240		; 0f000000H
  00d8f	3d 00 00 00 0f	 cmp	 eax, 251658240		; 0f000000H
  00d94	75 0e		 jne	 SHORT $LN111@lssproto_S
  00d96	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?sPetStatFlag@@3HA, 1 ; sPetStatFlag
  00d9d	75 05		 jne	 SHORT $LN111@lssproto_S

; 1170 : 				saveUserSetting();

  00d9f	e8 00 00 00 00	 call	 ?saveUserSetting@@YAHXZ	; saveUserSetting
$LN111@lssproto_S:

; 1171 : 			break;

  00da4	e9 6d 24 00 00	 jmp	 $LN1@lssproto_S
$LN112@lssproto_S:

; 1172 : 		case 'F':
; 1173 : 			char familyName[256];
; 1174 : 
; 1175 : 			data++;

  00da9	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00dac	83 c0 01	 add	 eax, 1
  00daf	89 45 0c	 mov	 DWORD PTR _data$[ebp], eax

; 1176 : 			getStringToken(data, S_DELIM, 1, sizeof(familyName) - 1, familyName);

  00db2	8d 85 88 fc ff
	ff		 lea	 eax, DWORD PTR _familyName$37[ebp]
  00db8	50		 push	 eax
  00db9	68 ff 00 00 00	 push	 255			; 000000ffH
  00dbe	6a 01		 push	 1
  00dc0	6a 7c		 push	 124			; 0000007cH
  00dc2	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00dc5	51		 push	 ecx
  00dc6	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00dcb	83 c4 14	 add	 esp, 20			; 00000014H

; 1177 : 			makeStringFromEscaped(familyName);

  00dce	8d 85 88 fc ff
	ff		 lea	 eax, DWORD PTR _familyName$37[ebp]
  00dd4	50		 push	 eax
  00dd5	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  00dda	83 c4 04	 add	 esp, 4

; 1178 : 			if (strlen(familyName) <= CHAR_NAME_LEN)

  00ddd	8d 85 88 fc ff
	ff		 lea	 eax, DWORD PTR _familyName$37[ebp]
  00de3	50		 push	 eax
  00de4	e8 00 00 00 00	 call	 _strlen
  00de9	83 c4 04	 add	 esp, 4
  00dec	83 f8 10	 cmp	 eax, 16			; 00000010H
  00def	77 14		 ja	 SHORT $LN113@lssproto_S

; 1179 : 				strcpy(pc.familyName, familyName);

  00df1	8d 85 88 fc ff
	ff		 lea	 eax, DWORD PTR _familyName$37[ebp]
  00df7	50		 push	 eax
  00df8	68 f6 50 00 00	 push	 OFFSET ?pc@@3UPC@@A+20726
  00dfd	e8 00 00 00 00	 call	 _strcpy
  00e02	83 c4 08	 add	 esp, 8
$LN113@lssproto_S:

; 1180 : 			pc.familyleader = getIntegerToken(data, S_DELIM, 2);

  00e05	6a 02		 push	 2
  00e07	6a 7c		 push	 124			; 0000007cH
  00e09	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00e0c	50		 push	 eax
  00e0d	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00e12	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e15	a3 08 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20744, eax

; 1181 : 			pc.channel = getIntegerToken(data, S_DELIM, 3);

  00e1a	6a 03		 push	 3
  00e1c	6a 7c		 push	 124			; 0000007cH
  00e1e	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00e21	50		 push	 eax
  00e22	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00e27	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e2a	a3 0c 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20748, eax

; 1182 : 			pc.familySprite = getIntegerToken(data, S_DELIM, 4);

  00e2f	6a 04		 push	 4
  00e31	6a 7c		 push	 124			; 0000007cH
  00e33	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00e36	50		 push	 eax
  00e37	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00e3c	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e3f	a3 4c 51 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+20812, eax

; 1183 : 			pc.big4fm =	getIntegerToken(data, S_DELIM, 5);

  00e44	6a 05		 push	 5
  00e46	6a 7c		 push	 124			; 0000007cH
  00e48	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00e4b	50		 push	 eax
  00e4c	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00e51	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e54	a3 7c a1 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+41340, eax

; 1184 : #ifdef _CHANNEL_MODIFY
; 1185 : 			if (pc.familyleader == FMMEMBER_NONE)

  00e59	83 3d 08 51 00
	00 ff		 cmp	 DWORD PTR ?pc@@3UPC@@A+20744, -1
  00e60	75 1c		 jne	 SHORT $LN114@lssproto_S

; 1186 : 			{
; 1187 : 				pc.etcFlag &= ~PC_ETCFLAG_CHAT_FM;

  00e62	0f b7 05 a8 00
	00 00		 movzx	 eax, WORD PTR ?pc@@3UPC@@A+168
  00e69	25 7f ff ff ff	 and	 eax, -129		; ffffff7fH
  00e6e	66 a3 a8 00 00
	00		 mov	 WORD PTR ?pc@@3UPC@@A+168, ax

; 1188 : 				TalkMode = 0;

  00e74	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?TalkMode@@3HA, 0 ; TalkMode
$LN114@lssproto_S:

; 1189 : 			}
; 1190 : #endif
; 1191 : 			break;

  00e7e	e9 93 23 00 00	 jmp	 $LN1@lssproto_S
$LN115@lssproto_S:

; 1192 : 		// HP,MP,EXP
; 1193 : 		case 'M':
; 1194 : 			data++;

  00e83	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00e86	83 c0 01	 add	 eax, 1
  00e89	89 45 0c	 mov	 DWORD PTR _data$[ebp], eax

; 1195 : 			pc.hp  = getIntegerToken(data, '|', 1);

  00e8c	6a 01		 push	 1
  00e8e	6a 7c		 push	 124			; 0000007cH
  00e90	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00e93	50		 push	 eax
  00e94	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00e99	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e9c	a3 10 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+16, eax

; 1196 : 			pc.mp  = getIntegerToken(data, '|', 2);

  00ea1	6a 02		 push	 2
  00ea3	6a 7c		 push	 124			; 0000007cH
  00ea5	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00ea8	50		 push	 eax
  00ea9	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00eae	83 c4 0c	 add	 esp, 12			; 0000000cH
  00eb1	a3 18 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+24, eax

; 1197 : 			pc.exp = getIntegerToken(data, '|', 3);

  00eb6	6a 03		 push	 3
  00eb8	6a 7c		 push	 124			; 0000007cH
  00eba	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00ebd	50		 push	 eax
  00ebe	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00ec3	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ec6	a3 30 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+48, eax

; 1198 : 			updataPcAct();

  00ecb	e8 00 00 00 00	 call	 ?updataPcAct@@YAXXZ	; updataPcAct

; 1199 : 			if ((pc.status & CHR_STATUS_LEADER) != 0 && party[0].useFlag != 0)

  00ed0	a1 a4 00 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+164
  00ed5	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00eda	74 27		 je	 SHORT $LN116@lssproto_S
  00edc	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  00ee1	6b c8 00	 imul	 ecx, eax, 0
  00ee4	0f bf 91 00 00
	00 00		 movsx	 edx, WORD PTR ?party@@3PAUPARTY@@A[ecx]
  00eeb	85 d2		 test	 edx, edx
  00eed	74 14		 je	 SHORT $LN116@lssproto_S

; 1200 : 				party[0].hp = pc.hp;

  00eef	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  00ef4	6b c8 00	 imul	 ecx, eax, 0
  00ef7	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR ?pc@@3UPC@@A+16
  00efd	89 91 10 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[ecx+16], edx
$LN116@lssproto_S:

; 1201 : 			break;

  00f03	e9 0e 23 00 00	 jmp	 $LN1@lssproto_S
$LN117@lssproto_S:

; 1202 : 		case 'K':
; 1203 : 			{
; 1204 : 				char name[256], freeName[256];
; 1205 : 				int no, kubun, i;
; 1206 : 				unsigned int mask;
; 1207 : 
; 1208 : 				no = data[1] - '0';

  00f08	b8 01 00 00 00	 mov	 eax, 1
  00f0d	c1 e0 00	 shl	 eax, 0
  00f10	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00f13	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00f17	83 ea 30	 sub	 edx, 48			; 00000030H
  00f1a	89 95 6c fa ff
	ff		 mov	 DWORD PTR _no$34[ebp], edx

; 1209 : 				data += 3;

  00f20	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00f23	83 c0 03	 add	 eax, 3
  00f26	89 45 0c	 mov	 DWORD PTR _data$[ebp], eax

; 1210 : 				kubun = getInteger62Token(data, S_DELIM, 1);

  00f29	6a 01		 push	 1
  00f2b	6a 7c		 push	 124			; 0000007cH
  00f2d	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00f30	50		 push	 eax
  00f31	e8 00 00 00 00	 call	 ?getInteger62Token@@YAHPADDH@Z ; getInteger62Token
  00f36	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f39	89 85 60 fa ff
	ff		 mov	 DWORD PTR _kubun$33[ebp], eax

; 1211 : 				if (kubun == 0){

  00f3f	83 bd 60 fa ff
	ff 00		 cmp	 DWORD PTR _kubun$33[ebp], 0
  00f46	75 6d		 jne	 SHORT $LN118@lssproto_S

; 1212 : 					if (pet[no].useFlag){

  00f48	69 85 6c fa ff
	ff 20 0b 00 00	 imul	 eax, DWORD PTR _no$34[ebp], 2848
  00f52	0f bf 88 76 00
	00 00		 movsx	 ecx, WORD PTR ?pet@@3PAUPET@@A[eax+118]
  00f59	85 c9		 test	 ecx, ecx
  00f5b	74 40		 je	 SHORT $LN119@lssproto_S

; 1213 : 						if (no == pc.battlePetNo)

  00f5d	0f bf 05 aa 00
	00 00		 movsx	 eax, WORD PTR ?pc@@3UPC@@A+170
  00f64	39 85 6c fa ff
	ff		 cmp	 DWORD PTR _no$34[ebp], eax
  00f6a	75 09		 jne	 SHORT $LN120@lssproto_S

; 1214 : 							pc.battlePetNo = -1;

  00f6c	83 c8 ff	 or	 eax, -1
  00f6f	66 a3 aa 00 00
	00		 mov	 WORD PTR ?pc@@3UPC@@A+170, ax
$LN120@lssproto_S:

; 1215 : 						if (no == pc.mailPetNo)

  00f75	0f bf 05 b6 00
	00 00		 movsx	 eax, WORD PTR ?pc@@3UPC@@A+182
  00f7c	39 85 6c fa ff
	ff		 cmp	 DWORD PTR _no$34[ebp], eax
  00f82	75 09		 jne	 SHORT $LN121@lssproto_S

; 1216 : 							pc.mailPetNo = -1;

  00f84	83 c8 ff	 or	 eax, -1
  00f87	66 a3 b6 00 00
	00		 mov	 WORD PTR ?pc@@3UPC@@A+182, ax
$LN121@lssproto_S:

; 1217 : 						pc.selectPetNo[no] = FALSE;

  00f8d	33 c0		 xor	 eax, eax
  00f8f	8b 8d 6c fa ff
	ff		 mov	 ecx, DWORD PTR _no$34[ebp]
  00f95	66 89 04 4d ac
	00 00 00	 mov	 WORD PTR ?pc@@3UPC@@A[ecx*2+172], ax
$LN119@lssproto_S:

; 1218 : 					}
; 1219 : 					pet[no].useFlag = 0;

  00f9d	69 85 6c fa ff
	ff 20 0b 00 00	 imul	 eax, DWORD PTR _no$34[ebp], 2848
  00fa7	33 c9		 xor	 ecx, ecx
  00fa9	66 89 88 76 00
	00 00		 mov	 WORD PTR ?pet@@3PAUPET@@A[eax+118], cx

; 1220 : 					break;

  00fb0	e9 61 22 00 00	 jmp	 $LN1@lssproto_S
$LN118@lssproto_S:

; 1221 : 				}
; 1222 : 				pet[no].useFlag = 1;

  00fb5	69 85 6c fa ff
	ff 20 0b 00 00	 imul	 eax, DWORD PTR _no$34[ebp], 2848
  00fbf	b9 01 00 00 00	 mov	 ecx, 1
  00fc4	66 89 88 76 00
	00 00		 mov	 WORD PTR ?pet@@3PAUPET@@A[eax+118], cx

; 1223 : 				if (kubun == 1){

  00fcb	83 bd 60 fa ff
	ff 01		 cmp	 DWORD PTR _kubun$33[ebp], 1
  00fd2	0f 85 aa 04 00
	00		 jne	 $LN122@lssproto_S

; 1224 : 					pet[no].graNo	= getIntegerToken(data, S_DELIM, 2);		// 0x00000002

  00fd8	6a 02		 push	 2
  00fda	6a 7c		 push	 124			; 0000007cH
  00fdc	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00fdf	50		 push	 eax
  00fe0	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00fe5	83 c4 0c	 add	 esp, 12			; 0000000cH
  00fe8	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  00ff2	89 81 04 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+4], eax

; 1225 : 					pet[no].hp		= getIntegerToken(data, S_DELIM, 3);		// 0x00000004

  00ff8	6a 03		 push	 3
  00ffa	6a 7c		 push	 124			; 0000007cH
  00ffc	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00fff	50		 push	 eax
  01000	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01005	83 c4 0c	 add	 esp, 12			; 0000000cH
  01008	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  01012	89 81 08 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+8], eax

; 1226 : 					pet[no].maxHp	= getIntegerToken(data, S_DELIM, 4);		// 0x00000008

  01018	6a 04		 push	 4
  0101a	6a 7c		 push	 124			; 0000007cH
  0101c	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0101f	50		 push	 eax
  01020	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01025	83 c4 0c	 add	 esp, 12			; 0000000cH
  01028	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  01032	89 81 0c 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+12], eax

; 1227 : 					pet[no].mp		= getIntegerToken(data, S_DELIM, 5);		// 0x00000010

  01038	6a 05		 push	 5
  0103a	6a 7c		 push	 124			; 0000007cH
  0103c	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0103f	50		 push	 eax
  01040	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01045	83 c4 0c	 add	 esp, 12			; 0000000cH
  01048	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  01052	89 81 10 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+16], eax

; 1228 : 					pet[no].maxMp	= getIntegerToken(data, S_DELIM, 6);		// 0x00000020

  01058	6a 06		 push	 6
  0105a	6a 7c		 push	 124			; 0000007cH
  0105c	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0105f	50		 push	 eax
  01060	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01065	83 c4 0c	 add	 esp, 12			; 0000000cH
  01068	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  01072	89 81 14 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+20], eax

; 1229 : 					pet[no].exp		= getIntegerToken(data, S_DELIM, 7);		// 0x00000040

  01078	6a 07		 push	 7
  0107a	6a 7c		 push	 124			; 0000007cH
  0107c	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0107f	50		 push	 eax
  01080	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01085	83 c4 0c	 add	 esp, 12			; 0000000cH
  01088	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  01092	89 81 18 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+24], eax

; 1230 : 					pet[no].maxExp	= getIntegerToken(data, S_DELIM, 8);		// 0x00000080

  01098	6a 08		 push	 8
  0109a	6a 7c		 push	 124			; 0000007cH
  0109c	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0109f	50		 push	 eax
  010a0	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  010a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  010a8	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  010b2	89 81 1c 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+28], eax

; 1231 : 					pet[no].level	= getIntegerToken(data, S_DELIM, 9);		// 0x00000100

  010b8	6a 09		 push	 9
  010ba	6a 7c		 push	 124			; 0000007cH
  010bc	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  010bf	50		 push	 eax
  010c0	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  010c5	83 c4 0c	 add	 esp, 12			; 0000000cH
  010c8	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  010d2	89 81 20 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+32], eax

; 1232 : 					pet[no].atk		= getIntegerToken(data, S_DELIM, 10);		// 0x00000200

  010d8	6a 0a		 push	 10			; 0000000aH
  010da	6a 7c		 push	 124			; 0000007cH
  010dc	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  010df	50		 push	 eax
  010e0	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  010e5	83 c4 0c	 add	 esp, 12			; 0000000cH
  010e8	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  010f2	89 81 24 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+36], eax

; 1233 : 					pet[no].def		= getIntegerToken(data, S_DELIM, 11);		// 0x00000400

  010f8	6a 0b		 push	 11			; 0000000bH
  010fa	6a 7c		 push	 124			; 0000007cH
  010fc	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  010ff	50		 push	 eax
  01100	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01105	83 c4 0c	 add	 esp, 12			; 0000000cH
  01108	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  01112	89 81 28 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+40], eax

; 1234 : 					pet[no].quick	= getIntegerToken(data, S_DELIM, 12);		// 0x00000800

  01118	6a 0c		 push	 12			; 0000000cH
  0111a	6a 7c		 push	 124			; 0000007cH
  0111c	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0111f	50		 push	 eax
  01120	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01125	83 c4 0c	 add	 esp, 12			; 0000000cH
  01128	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  01132	89 81 2c 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+44], eax

; 1235 : 					pet[no].ai		= getIntegerToken(data, S_DELIM, 13);		// 0x00001000

  01138	6a 0d		 push	 13			; 0000000dH
  0113a	6a 7c		 push	 124			; 0000007cH
  0113c	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0113f	50		 push	 eax
  01140	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01145	83 c4 0c	 add	 esp, 12			; 0000000cH
  01148	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  01152	89 81 30 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+48], eax

; 1236 : 					pet[no].earth	= getIntegerToken(data, S_DELIM, 14);		// 0x00002000

  01158	6a 0e		 push	 14			; 0000000eH
  0115a	6a 7c		 push	 124			; 0000007cH
  0115c	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0115f	50		 push	 eax
  01160	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01165	83 c4 0c	 add	 esp, 12			; 0000000cH
  01168	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  01172	89 81 34 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+52], eax

; 1237 : 					pet[no].water	= getIntegerToken(data, S_DELIM, 15);		// 0x00004000

  01178	6a 0f		 push	 15			; 0000000fH
  0117a	6a 7c		 push	 124			; 0000007cH
  0117c	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0117f	50		 push	 eax
  01180	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01185	83 c4 0c	 add	 esp, 12			; 0000000cH
  01188	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  01192	89 81 38 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+56], eax

; 1238 : 					pet[no].fire	= getIntegerToken(data, S_DELIM, 16);		// 0x00008000

  01198	6a 10		 push	 16			; 00000010H
  0119a	6a 7c		 push	 124			; 0000007cH
  0119c	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0119f	50		 push	 eax
  011a0	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  011a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  011a8	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  011b2	89 81 3c 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+60], eax

; 1239 : 					pet[no].wind	= getIntegerToken(data, S_DELIM, 17);		// 0x00010000

  011b8	6a 11		 push	 17			; 00000011H
  011ba	6a 7c		 push	 124			; 0000007cH
  011bc	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  011bf	50		 push	 eax
  011c0	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  011c5	83 c4 0c	 add	 esp, 12			; 0000000cH
  011c8	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  011d2	89 81 40 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+64], eax

; 1240 : 					pet[no].maxSkill= getIntegerToken(data, S_DELIM, 18);		// 0x00020000

  011d8	6a 12		 push	 18			; 00000012H
  011da	6a 7c		 push	 124			; 0000007cH
  011dc	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  011df	50		 push	 eax
  011e0	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  011e5	83 c4 0c	 add	 esp, 12			; 0000000cH
  011e8	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  011f2	89 81 44 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+68], eax

; 1241 : 					pet[no].changeNameFlag = getIntegerToken(data, S_DELIM, 19);// 0x00040000

  011f8	6a 13		 push	 19			; 00000013H
  011fa	6a 7c		 push	 124			; 0000007cH
  011fc	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  011ff	50		 push	 eax
  01200	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01205	83 c4 0c	 add	 esp, 12			; 0000000cH
  01208	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  01212	66 89 81 78 00
	00 00		 mov	 WORD PTR ?pet@@3PAUPET@@A[ecx+120], ax

; 1242 : 					pet[no].trn = getIntegerToken(data , S_DELIM, 20);

  01219	6a 14		 push	 20			; 00000014H
  0121b	6a 7c		 push	 124			; 0000007cH
  0121d	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  01220	50		 push	 eax
  01221	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01226	83 c4 0c	 add	 esp, 12			; 0000000cH
  01229	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  01233	89 81 48 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+72], eax

; 1243 : #ifdef _SHOW_FUSION
; 1244 : 					pet[no].fusion = getIntegerToken(data , S_DELIM, 21);

  01239	6a 15		 push	 21			; 00000015H
  0123b	6a 7c		 push	 124			; 0000007cH
  0123d	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  01240	50		 push	 eax
  01241	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01246	83 c4 0c	 add	 esp, 12			; 0000000cH
  01249	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  01253	89 81 4c 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+76], eax

; 1245 : 					getStringToken(data, S_DELIM, 22, sizeof(name) - 1, name);// 0x00080000

  01259	8d 85 80 fb ff
	ff		 lea	 eax, DWORD PTR _name$36[ebp]
  0125f	50		 push	 eax
  01260	68 ff 00 00 00	 push	 255			; 000000ffH
  01265	6a 16		 push	 22			; 00000016H
  01267	6a 7c		 push	 124			; 0000007cH
  01269	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0126c	51		 push	 ecx
  0126d	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  01272	83 c4 14	 add	 esp, 20			; 00000014H

; 1246 : 					makeStringFromEscaped(name);

  01275	8d 85 80 fb ff
	ff		 lea	 eax, DWORD PTR _name$36[ebp]
  0127b	50		 push	 eax
  0127c	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  01281	83 c4 04	 add	 esp, 4

; 1247 : 					if (strlen(name) <= PET_NAME_LEN)

  01284	8d 85 80 fb ff
	ff		 lea	 eax, DWORD PTR _name$36[ebp]
  0128a	50		 push	 eax
  0128b	e8 00 00 00 00	 call	 _strlen
  01290	83 c4 04	 add	 esp, 4
  01293	83 f8 10	 cmp	 eax, 16			; 00000010H
  01296	77 20		 ja	 SHORT $LN124@lssproto_S

; 1248 : 						strcpy(pet[no].name, name);

  01298	8d 85 80 fb ff
	ff		 lea	 eax, DWORD PTR _name$36[ebp]
  0129e	50		 push	 eax
  0129f	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  012a9	81 c1 54 00 00
	00		 add	 ecx, OFFSET ?pet@@3PAUPET@@A+84
  012af	51		 push	 ecx
  012b0	e8 00 00 00 00	 call	 _strcpy
  012b5	83 c4 08	 add	 esp, 8
$LN124@lssproto_S:

; 1249 : 					getStringToken(data, S_DELIM, 23, sizeof(freeName) - 1, freeName);// 0x00100000

  012b8	8d 85 78 fa ff
	ff		 lea	 eax, DWORD PTR _freeName$35[ebp]
  012be	50		 push	 eax
  012bf	68 ff 00 00 00	 push	 255			; 000000ffH
  012c4	6a 17		 push	 23			; 00000017H
  012c6	6a 7c		 push	 124			; 0000007cH
  012c8	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  012cb	51		 push	 ecx
  012cc	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  012d1	83 c4 14	 add	 esp, 20			; 00000014H

; 1250 : 					makeStringFromEscaped(freeName);

  012d4	8d 85 78 fa ff
	ff		 lea	 eax, DWORD PTR _freeName$35[ebp]
  012da	50		 push	 eax
  012db	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  012e0	83 c4 04	 add	 esp, 4

; 1251 : 					if (strlen(freeName) <= PET_NAME_LEN)

  012e3	8d 85 78 fa ff
	ff		 lea	 eax, DWORD PTR _freeName$35[ebp]
  012e9	50		 push	 eax
  012ea	e8 00 00 00 00	 call	 _strlen
  012ef	83 c4 04	 add	 esp, 4
  012f2	83 f8 10	 cmp	 eax, 16			; 00000010H
  012f5	77 20		 ja	 SHORT $LN125@lssproto_S

; 1252 : 						strcpy(pet[no].freeName, freeName);

  012f7	8d 85 78 fa ff
	ff		 lea	 eax, DWORD PTR _freeName$35[ebp]
  012fd	50		 push	 eax
  012fe	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  01308	81 c1 65 00 00
	00		 add	 ecx, OFFSET ?pet@@3PAUPET@@A+101
  0130e	51		 push	 ecx
  0130f	e8 00 00 00 00	 call	 _strcpy
  01314	83 c4 08	 add	 esp, 8
$LN125@lssproto_S:

; 1253 : #else
; 1254 : 					getStringToken(data, S_DELIM, 21, sizeof(name) - 1, name);// 0x00080000
; 1255 : 					makeStringFromEscaped(name);
; 1256 : 					if (strlen(name) <= PET_NAME_LEN)
; 1257 : 						strcpy(pet[no].name, name);
; 1258 : 					getStringToken(data, S_DELIM, 22, sizeof(freeName) - 1, freeName);// 0x00100000
; 1259 : 					makeStringFromEscaped(freeName);
; 1260 : 					if (strlen(freeName) <= PET_NAME_LEN)
; 1261 : 						strcpy(pet[no].freeName, freeName);
; 1262 : #endif
; 1263 : #ifdef _NB_宠物绑定值
; 1264 : 					char 绑定标志[2];
; 1265 : 					getStringToken(data, S_DELIM, 24, sizeof(绑定标志) - 1, 绑定标志);// 0x00100000

  01317	8d 85 3c fa ff
	ff		 lea	 eax, DWORD PTR _绑定标志$30[ebp]
  0131d	50		 push	 eax
  0131e	6a 01		 push	 1
  01320	6a 18		 push	 24			; 00000018H
  01322	6a 7c		 push	 124			; 0000007cH
  01324	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  01327	51		 push	 ecx
  01328	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0132d	83 c4 14	 add	 esp, 20			; 00000014H

; 1266 : 					makeStringFromEscaped(绑定标志);

  01330	8d 85 3c fa ff
	ff		 lea	 eax, DWORD PTR _绑定标志$30[ebp]
  01336	50		 push	 eax
  01337	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  0133c	83 c4 04	 add	 esp, 4

; 1267 : 					char *temp2 = sunday(绑定标志, "*");

  0133f	68 00 00 00 00	 push	 OFFSET ??_C@_01NBENCBCI@?$CK?$AA@
  01344	8d 85 3c fa ff
	ff		 lea	 eax, DWORD PTR _绑定标志$30[ebp]
  0134a	50		 push	 eax
  0134b	e8 00 00 00 00	 call	 ?sunday@@YAPADPAD0@Z	; sunday
  01350	83 c4 08	 add	 esp, 8
  01353	89 85 30 fa ff
	ff		 mov	 DWORD PTR _temp2$29[ebp], eax

; 1268 : 					if (temp2){

  01359	83 bd 30 fa ff
	ff 00		 cmp	 DWORD PTR _temp2$29[ebp], 0
  01360	74 16		 je	 SHORT $LN126@lssproto_S

; 1269 : 						pet[no].petlock = 1;

  01362	69 85 6c fa ff
	ff 20 0b 00 00	 imul	 eax, DWORD PTR _no$34[ebp], 2848
  0136c	c7 80 e0 0a 00
	00 01 00 00 00	 mov	 DWORD PTR ?pet@@3PAUPET@@A[eax+2784], 1

; 1270 : 					}else{

  01376	eb 14		 jmp	 SHORT $LN127@lssproto_S
$LN126@lssproto_S:

; 1271 : 						pet[no].petlock = 0;

  01378	69 85 6c fa ff
	ff 20 0b 00 00	 imul	 eax, DWORD PTR _no$34[ebp], 2848
  01382	c7 80 e0 0a 00
	00 00 00 00 00	 mov	 DWORD PTR ?pet@@3PAUPET@@A[eax+2784], 0
$LN127@lssproto_S:

; 1272 : 					}
; 1273 : 
; 1274 : #endif
; 1275 : 					pet[no].petindex = getIntegerToken(data , S_DELIM, 25);//索引

  0138c	6a 19		 push	 25			; 00000019H
  0138e	6a 7c		 push	 124			; 0000007cH
  01390	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  01393	50		 push	 eax
  01394	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01399	83 c4 0c	 add	 esp, 12			; 0000000cH
  0139c	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  013a6	89 81 e4 0a 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+2788], eax

; 1276 : 					//printf("data[1]:%s\n",data);
; 1277 : #ifdef _NB_宠物初始值
; 1278 : 					pet[no].initlevel = getIntegerToken(data , S_DELIM, 26);//

  013ac	6a 1a		 push	 26			; 0000001aH
  013ae	6a 7c		 push	 124			; 0000007cH
  013b0	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  013b3	50		 push	 eax
  013b4	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  013b9	83 c4 0c	 add	 esp, 12			; 0000000cH
  013bc	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  013c6	89 81 e8 0a 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+2792], eax

; 1279 : 					pet[no].inithp = getIntegerToken(data , S_DELIM, 27);

  013cc	6a 1b		 push	 27			; 0000001bH
  013ce	6a 7c		 push	 124			; 0000007cH
  013d0	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  013d3	50		 push	 eax
  013d4	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  013d9	83 c4 0c	 add	 esp, 12			; 0000000cH
  013dc	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  013e6	89 81 ec 0a 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+2796], eax

; 1280 : 					pet[no].initatk = getIntegerToken(data , S_DELIM, 28);

  013ec	6a 1c		 push	 28			; 0000001cH
  013ee	6a 7c		 push	 124			; 0000007cH
  013f0	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  013f3	50		 push	 eax
  013f4	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  013f9	83 c4 0c	 add	 esp, 12			; 0000000cH
  013fc	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  01406	89 81 f0 0a 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+2800], eax

; 1281 : 					pet[no].initdef = getIntegerToken(data , S_DELIM, 29);

  0140c	6a 1d		 push	 29			; 0000001dH
  0140e	6a 7c		 push	 124			; 0000007cH
  01410	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  01413	50		 push	 eax
  01414	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01419	83 c4 0c	 add	 esp, 12			; 0000000cH
  0141c	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  01426	89 81 f4 0a 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+2804], eax

; 1282 : 					pet[no].initquick = getIntegerToken(data , S_DELIM, 30);

  0142c	6a 1e		 push	 30			; 0000001eH
  0142e	6a 7c		 push	 124			; 0000007cH
  01430	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  01433	50		 push	 eax
  01434	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01439	83 c4 0c	 add	 esp, 12			; 0000000cH
  0143c	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  01446	89 81 f8 0a 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+2808], eax

; 1283 : 					pet[no].repetnum = getIntegerToken(data , S_DELIM, 39);

  0144c	6a 27		 push	 39			; 00000027H
  0144e	6a 7c		 push	 124			; 0000007cH
  01450	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  01453	50		 push	 eax
  01454	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01459	83 c4 0c	 add	 esp, 12			; 0000000cH
  0145c	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  01466	89 81 fc 0a 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[ecx+2812], eax

; 1284 : 					//printf("data[%d]:%d %d %d %d\n",no,pet[no].inithp,pet[no].initatk,pet[no].initdef,pet[no].initquick);
; 1285 : #endif
; 1286 : 					printf("data[1]:%s\n",data);

  0146c	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0146f	50		 push	 eax
  01470	68 00 00 00 00	 push	 OFFSET ??_C@_0M@OMPDAMON@data?$FL1?$FN?3?$CFs?6?$AA@
  01475	e8 00 00 00 00	 call	 _printf
  0147a	83 c4 08	 add	 esp, 8

; 1287 : 				}else{

  0147d	e9 11 06 00 00	 jmp	 $LN123@lssproto_S
$LN122@lssproto_S:

; 1288 : 					mask = 2;

  01482	c7 85 48 fa ff
	ff 02 00 00 00	 mov	 DWORD PTR _mask$31[ebp], 2

; 1289 : 					i = 2;

  0148c	c7 85 54 fa ff
	ff 02 00 00 00	 mov	 DWORD PTR _i$32[ebp], 2

; 1290 : 					for (; mask > 0; mask <<= 1){

  01496	eb 0e		 jmp	 SHORT $LN9@lssproto_S
$LN7@lssproto_S:
  01498	8b 85 48 fa ff
	ff		 mov	 eax, DWORD PTR _mask$31[ebp]
  0149e	d1 e0		 shl	 eax, 1
  014a0	89 85 48 fa ff
	ff		 mov	 DWORD PTR _mask$31[ebp], eax
$LN9@lssproto_S:
  014a6	83 bd 48 fa ff
	ff 00		 cmp	 DWORD PTR _mask$31[ebp], 0
  014ad	0f 86 e0 05 00
	00		 jbe	 $LN123@lssproto_S

; 1291 : 						if (kubun & mask){

  014b3	8b 85 60 fa ff
	ff		 mov	 eax, DWORD PTR _kubun$33[ebp]
  014b9	23 85 48 fa ff
	ff		 and	 eax, DWORD PTR _mask$31[ebp]
  014bf	0f 84 c9 05 00
	00		 je	 $LN128@lssproto_S

; 1292 : 							if (mask == 0x00000002){

  014c5	83 bd 48 fa ff
	ff 02		 cmp	 DWORD PTR _mask$31[ebp], 2
  014cc	75 39		 jne	 SHORT $LN129@lssproto_S

; 1293 : 								pet[no].graNo = getIntegerToken(data, S_DELIM, i);// 0x00000002

  014ce	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  014d4	50		 push	 eax
  014d5	6a 7c		 push	 124			; 0000007cH
  014d7	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  014da	51		 push	 ecx
  014db	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  014e0	83 c4 0c	 add	 esp, 12			; 0000000cH
  014e3	69 95 6c fa ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _no$34[ebp], 2848
  014ed	89 82 04 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[edx+4], eax

; 1294 : 								i++;

  014f3	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  014f9	83 c0 01	 add	 eax, 1
  014fc	89 85 54 fa ff
	ff		 mov	 DWORD PTR _i$32[ebp], eax
  01502	e9 87 05 00 00	 jmp	 $LN128@lssproto_S
$LN129@lssproto_S:

; 1295 : 							}else if (mask == 0x00000004){

  01507	83 bd 48 fa ff
	ff 04		 cmp	 DWORD PTR _mask$31[ebp], 4
  0150e	75 39		 jne	 SHORT $LN131@lssproto_S

; 1296 : 								pet[no].hp = getIntegerToken(data, S_DELIM, i);// 0x00000004

  01510	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  01516	50		 push	 eax
  01517	6a 7c		 push	 124			; 0000007cH
  01519	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0151c	51		 push	 ecx
  0151d	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01522	83 c4 0c	 add	 esp, 12			; 0000000cH
  01525	69 95 6c fa ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _no$34[ebp], 2848
  0152f	89 82 08 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[edx+8], eax

; 1297 : 								i++;

  01535	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  0153b	83 c0 01	 add	 eax, 1
  0153e	89 85 54 fa ff
	ff		 mov	 DWORD PTR _i$32[ebp], eax
  01544	e9 45 05 00 00	 jmp	 $LN128@lssproto_S
$LN131@lssproto_S:

; 1298 : 							}else if (mask == 0x00000008){

  01549	83 bd 48 fa ff
	ff 08		 cmp	 DWORD PTR _mask$31[ebp], 8
  01550	75 39		 jne	 SHORT $LN133@lssproto_S

; 1299 : 								pet[no].maxHp = getIntegerToken(data, S_DELIM, i);// 0x00000008

  01552	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  01558	50		 push	 eax
  01559	6a 7c		 push	 124			; 0000007cH
  0155b	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0155e	51		 push	 ecx
  0155f	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01564	83 c4 0c	 add	 esp, 12			; 0000000cH
  01567	69 95 6c fa ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _no$34[ebp], 2848
  01571	89 82 0c 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[edx+12], eax

; 1300 : 								i++;

  01577	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  0157d	83 c0 01	 add	 eax, 1
  01580	89 85 54 fa ff
	ff		 mov	 DWORD PTR _i$32[ebp], eax
  01586	e9 03 05 00 00	 jmp	 $LN128@lssproto_S
$LN133@lssproto_S:

; 1301 : 							}else if (mask == 0x00000010){

  0158b	83 bd 48 fa ff
	ff 10		 cmp	 DWORD PTR _mask$31[ebp], 16 ; 00000010H
  01592	75 39		 jne	 SHORT $LN135@lssproto_S

; 1302 : 								pet[no].mp = getIntegerToken(data, S_DELIM, i);// 0x00000010

  01594	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  0159a	50		 push	 eax
  0159b	6a 7c		 push	 124			; 0000007cH
  0159d	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  015a0	51		 push	 ecx
  015a1	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  015a6	83 c4 0c	 add	 esp, 12			; 0000000cH
  015a9	69 95 6c fa ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _no$34[ebp], 2848
  015b3	89 82 10 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[edx+16], eax

; 1303 : 								i++;

  015b9	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  015bf	83 c0 01	 add	 eax, 1
  015c2	89 85 54 fa ff
	ff		 mov	 DWORD PTR _i$32[ebp], eax
  015c8	e9 c1 04 00 00	 jmp	 $LN128@lssproto_S
$LN135@lssproto_S:

; 1304 : 							}else if (mask == 0x00000020){

  015cd	83 bd 48 fa ff
	ff 20		 cmp	 DWORD PTR _mask$31[ebp], 32 ; 00000020H
  015d4	75 39		 jne	 SHORT $LN137@lssproto_S

; 1305 : 								pet[no].maxMp = getIntegerToken(data, S_DELIM, i);// 0x00000020

  015d6	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  015dc	50		 push	 eax
  015dd	6a 7c		 push	 124			; 0000007cH
  015df	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  015e2	51		 push	 ecx
  015e3	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  015e8	83 c4 0c	 add	 esp, 12			; 0000000cH
  015eb	69 95 6c fa ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _no$34[ebp], 2848
  015f5	89 82 14 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[edx+20], eax

; 1306 : 								i++;

  015fb	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  01601	83 c0 01	 add	 eax, 1
  01604	89 85 54 fa ff
	ff		 mov	 DWORD PTR _i$32[ebp], eax
  0160a	e9 7f 04 00 00	 jmp	 $LN128@lssproto_S
$LN137@lssproto_S:

; 1307 : 							}else if (mask == 0x00000040){

  0160f	83 bd 48 fa ff
	ff 40		 cmp	 DWORD PTR _mask$31[ebp], 64 ; 00000040H
  01616	75 39		 jne	 SHORT $LN139@lssproto_S

; 1308 : 								pet[no].exp = getIntegerToken(data, S_DELIM, i);// 0x00000040

  01618	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  0161e	50		 push	 eax
  0161f	6a 7c		 push	 124			; 0000007cH
  01621	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  01624	51		 push	 ecx
  01625	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0162a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0162d	69 95 6c fa ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _no$34[ebp], 2848
  01637	89 82 18 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[edx+24], eax

; 1309 : 								i++;

  0163d	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  01643	83 c0 01	 add	 eax, 1
  01646	89 85 54 fa ff
	ff		 mov	 DWORD PTR _i$32[ebp], eax
  0164c	e9 3d 04 00 00	 jmp	 $LN128@lssproto_S
$LN139@lssproto_S:

; 1310 : 							}else if (mask == 0x00000080){

  01651	81 bd 48 fa ff
	ff 80 00 00 00	 cmp	 DWORD PTR _mask$31[ebp], 128 ; 00000080H
  0165b	75 39		 jne	 SHORT $LN141@lssproto_S

; 1311 : 								pet[no].maxExp = getIntegerToken(data, S_DELIM, i);// 0x00000080

  0165d	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  01663	50		 push	 eax
  01664	6a 7c		 push	 124			; 0000007cH
  01666	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  01669	51		 push	 ecx
  0166a	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0166f	83 c4 0c	 add	 esp, 12			; 0000000cH
  01672	69 95 6c fa ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _no$34[ebp], 2848
  0167c	89 82 1c 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[edx+28], eax

; 1312 : 								i++;

  01682	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  01688	83 c0 01	 add	 eax, 1
  0168b	89 85 54 fa ff
	ff		 mov	 DWORD PTR _i$32[ebp], eax
  01691	e9 f8 03 00 00	 jmp	 $LN128@lssproto_S
$LN141@lssproto_S:

; 1313 : 							}else if (mask == 0x00000100){

  01696	81 bd 48 fa ff
	ff 00 01 00 00	 cmp	 DWORD PTR _mask$31[ebp], 256 ; 00000100H
  016a0	75 39		 jne	 SHORT $LN143@lssproto_S

; 1314 : 								pet[no].level = getIntegerToken(data, S_DELIM, i);// 0x00000100

  016a2	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  016a8	50		 push	 eax
  016a9	6a 7c		 push	 124			; 0000007cH
  016ab	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  016ae	51		 push	 ecx
  016af	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  016b4	83 c4 0c	 add	 esp, 12			; 0000000cH
  016b7	69 95 6c fa ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _no$34[ebp], 2848
  016c1	89 82 20 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[edx+32], eax

; 1315 : 								i++;

  016c7	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  016cd	83 c0 01	 add	 eax, 1
  016d0	89 85 54 fa ff
	ff		 mov	 DWORD PTR _i$32[ebp], eax
  016d6	e9 b3 03 00 00	 jmp	 $LN128@lssproto_S
$LN143@lssproto_S:

; 1316 : 							}else if (mask == 0x00000200){

  016db	81 bd 48 fa ff
	ff 00 02 00 00	 cmp	 DWORD PTR _mask$31[ebp], 512 ; 00000200H
  016e5	75 39		 jne	 SHORT $LN145@lssproto_S

; 1317 : 								pet[no].atk = getIntegerToken(data, S_DELIM, i);// 0x00000200

  016e7	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  016ed	50		 push	 eax
  016ee	6a 7c		 push	 124			; 0000007cH
  016f0	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  016f3	51		 push	 ecx
  016f4	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  016f9	83 c4 0c	 add	 esp, 12			; 0000000cH
  016fc	69 95 6c fa ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _no$34[ebp], 2848
  01706	89 82 24 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[edx+36], eax

; 1318 : 								i++;

  0170c	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  01712	83 c0 01	 add	 eax, 1
  01715	89 85 54 fa ff
	ff		 mov	 DWORD PTR _i$32[ebp], eax
  0171b	e9 6e 03 00 00	 jmp	 $LN128@lssproto_S
$LN145@lssproto_S:

; 1319 : 							}else if (mask == 0x00000400){

  01720	81 bd 48 fa ff
	ff 00 04 00 00	 cmp	 DWORD PTR _mask$31[ebp], 1024 ; 00000400H
  0172a	75 39		 jne	 SHORT $LN147@lssproto_S

; 1320 : 								pet[no].def = getIntegerToken(data, S_DELIM, i);// 0x00000400

  0172c	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  01732	50		 push	 eax
  01733	6a 7c		 push	 124			; 0000007cH
  01735	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  01738	51		 push	 ecx
  01739	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0173e	83 c4 0c	 add	 esp, 12			; 0000000cH
  01741	69 95 6c fa ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _no$34[ebp], 2848
  0174b	89 82 28 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[edx+40], eax

; 1321 : 								i++;

  01751	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  01757	83 c0 01	 add	 eax, 1
  0175a	89 85 54 fa ff
	ff		 mov	 DWORD PTR _i$32[ebp], eax
  01760	e9 29 03 00 00	 jmp	 $LN128@lssproto_S
$LN147@lssproto_S:

; 1322 : 							}else if (mask == 0x00000800){

  01765	81 bd 48 fa ff
	ff 00 08 00 00	 cmp	 DWORD PTR _mask$31[ebp], 2048 ; 00000800H
  0176f	75 39		 jne	 SHORT $LN149@lssproto_S

; 1323 : 								pet[no].quick = getIntegerToken(data, S_DELIM, i);// 0x00000800

  01771	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  01777	50		 push	 eax
  01778	6a 7c		 push	 124			; 0000007cH
  0177a	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0177d	51		 push	 ecx
  0177e	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01783	83 c4 0c	 add	 esp, 12			; 0000000cH
  01786	69 95 6c fa ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _no$34[ebp], 2848
  01790	89 82 2c 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[edx+44], eax

; 1324 : 								i++;

  01796	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  0179c	83 c0 01	 add	 eax, 1
  0179f	89 85 54 fa ff
	ff		 mov	 DWORD PTR _i$32[ebp], eax
  017a5	e9 e4 02 00 00	 jmp	 $LN128@lssproto_S
$LN149@lssproto_S:

; 1325 : 							}else if (mask == 0x00001000 ){

  017aa	81 bd 48 fa ff
	ff 00 10 00 00	 cmp	 DWORD PTR _mask$31[ebp], 4096 ; 00001000H
  017b4	75 39		 jne	 SHORT $LN151@lssproto_S

; 1326 : 								pet[no].ai = getIntegerToken(data, S_DELIM, i);// 0x00001000

  017b6	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  017bc	50		 push	 eax
  017bd	6a 7c		 push	 124			; 0000007cH
  017bf	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  017c2	51		 push	 ecx
  017c3	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  017c8	83 c4 0c	 add	 esp, 12			; 0000000cH
  017cb	69 95 6c fa ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _no$34[ebp], 2848
  017d5	89 82 30 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[edx+48], eax

; 1327 : 								i++;

  017db	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  017e1	83 c0 01	 add	 eax, 1
  017e4	89 85 54 fa ff
	ff		 mov	 DWORD PTR _i$32[ebp], eax
  017ea	e9 9f 02 00 00	 jmp	 $LN128@lssproto_S
$LN151@lssproto_S:

; 1328 : 							}else if (mask == 0x00002000){

  017ef	81 bd 48 fa ff
	ff 00 20 00 00	 cmp	 DWORD PTR _mask$31[ebp], 8192 ; 00002000H
  017f9	75 39		 jne	 SHORT $LN153@lssproto_S

; 1329 : 								pet[no].earth = getIntegerToken(data, S_DELIM, i);// 0x00002000

  017fb	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  01801	50		 push	 eax
  01802	6a 7c		 push	 124			; 0000007cH
  01804	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  01807	51		 push	 ecx
  01808	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0180d	83 c4 0c	 add	 esp, 12			; 0000000cH
  01810	69 95 6c fa ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _no$34[ebp], 2848
  0181a	89 82 34 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[edx+52], eax

; 1330 : 								i++;

  01820	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  01826	83 c0 01	 add	 eax, 1
  01829	89 85 54 fa ff
	ff		 mov	 DWORD PTR _i$32[ebp], eax
  0182f	e9 5a 02 00 00	 jmp	 $LN128@lssproto_S
$LN153@lssproto_S:

; 1331 : 							}else if (mask == 0x00004000 ){

  01834	81 bd 48 fa ff
	ff 00 40 00 00	 cmp	 DWORD PTR _mask$31[ebp], 16384 ; 00004000H
  0183e	75 39		 jne	 SHORT $LN155@lssproto_S

; 1332 : 								pet[no].water = getIntegerToken(data, S_DELIM, i);// 0x00004000

  01840	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  01846	50		 push	 eax
  01847	6a 7c		 push	 124			; 0000007cH
  01849	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0184c	51		 push	 ecx
  0184d	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01852	83 c4 0c	 add	 esp, 12			; 0000000cH
  01855	69 95 6c fa ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _no$34[ebp], 2848
  0185f	89 82 38 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[edx+56], eax

; 1333 : 								i++;

  01865	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  0186b	83 c0 01	 add	 eax, 1
  0186e	89 85 54 fa ff
	ff		 mov	 DWORD PTR _i$32[ebp], eax
  01874	e9 15 02 00 00	 jmp	 $LN128@lssproto_S
$LN155@lssproto_S:

; 1334 : 							}else if (mask == 0x00008000){

  01879	81 bd 48 fa ff
	ff 00 80 00 00	 cmp	 DWORD PTR _mask$31[ebp], 32768 ; 00008000H
  01883	75 39		 jne	 SHORT $LN157@lssproto_S

; 1335 : 								pet[no].fire = getIntegerToken(data, S_DELIM, i);// 0x00008000

  01885	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  0188b	50		 push	 eax
  0188c	6a 7c		 push	 124			; 0000007cH
  0188e	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  01891	51		 push	 ecx
  01892	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01897	83 c4 0c	 add	 esp, 12			; 0000000cH
  0189a	69 95 6c fa ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _no$34[ebp], 2848
  018a4	89 82 3c 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[edx+60], eax

; 1336 : 								i++;

  018aa	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  018b0	83 c0 01	 add	 eax, 1
  018b3	89 85 54 fa ff
	ff		 mov	 DWORD PTR _i$32[ebp], eax
  018b9	e9 d0 01 00 00	 jmp	 $LN128@lssproto_S
$LN157@lssproto_S:

; 1337 : 							}else if (mask == 0x00010000){

  018be	81 bd 48 fa ff
	ff 00 00 01 00	 cmp	 DWORD PTR _mask$31[ebp], 65536 ; 00010000H
  018c8	75 39		 jne	 SHORT $LN159@lssproto_S

; 1338 : 								pet[no].wind = getIntegerToken(data, S_DELIM, i);// 0x00010000

  018ca	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  018d0	50		 push	 eax
  018d1	6a 7c		 push	 124			; 0000007cH
  018d3	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  018d6	51		 push	 ecx
  018d7	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  018dc	83 c4 0c	 add	 esp, 12			; 0000000cH
  018df	69 95 6c fa ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _no$34[ebp], 2848
  018e9	89 82 40 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[edx+64], eax

; 1339 : 								i++;

  018ef	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  018f5	83 c0 01	 add	 eax, 1
  018f8	89 85 54 fa ff
	ff		 mov	 DWORD PTR _i$32[ebp], eax
  018fe	e9 8b 01 00 00	 jmp	 $LN128@lssproto_S
$LN159@lssproto_S:

; 1340 : 							}else if (mask == 0x00020000){

  01903	81 bd 48 fa ff
	ff 00 00 02 00	 cmp	 DWORD PTR _mask$31[ebp], 131072 ; 00020000H
  0190d	75 39		 jne	 SHORT $LN161@lssproto_S

; 1341 : 								pet[no].maxSkill = getIntegerToken(data, S_DELIM, i);// 0x00020000

  0190f	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  01915	50		 push	 eax
  01916	6a 7c		 push	 124			; 0000007cH
  01918	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0191b	51		 push	 ecx
  0191c	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01921	83 c4 0c	 add	 esp, 12			; 0000000cH
  01924	69 95 6c fa ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _no$34[ebp], 2848
  0192e	89 82 44 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[edx+68], eax

; 1342 : 								i++;

  01934	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  0193a	83 c0 01	 add	 eax, 1
  0193d	89 85 54 fa ff
	ff		 mov	 DWORD PTR _i$32[ebp], eax
  01943	e9 46 01 00 00	 jmp	 $LN128@lssproto_S
$LN161@lssproto_S:

; 1343 : 							}else if (mask == 0x00040000){

  01948	81 bd 48 fa ff
	ff 00 00 04 00	 cmp	 DWORD PTR _mask$31[ebp], 262144 ; 00040000H
  01952	75 3a		 jne	 SHORT $LN163@lssproto_S

; 1344 : 								pet[no].changeNameFlag = getIntegerToken(data, S_DELIM, i);// 0x00040000

  01954	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  0195a	50		 push	 eax
  0195b	6a 7c		 push	 124			; 0000007cH
  0195d	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  01960	51		 push	 ecx
  01961	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01966	83 c4 0c	 add	 esp, 12			; 0000000cH
  01969	69 95 6c fa ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _no$34[ebp], 2848
  01973	66 89 82 78 00
	00 00		 mov	 WORD PTR ?pet@@3PAUPET@@A[edx+120], ax

; 1345 : 								i++;

  0197a	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  01980	83 c0 01	 add	 eax, 1
  01983	89 85 54 fa ff
	ff		 mov	 DWORD PTR _i$32[ebp], eax
  01989	e9 00 01 00 00	 jmp	 $LN128@lssproto_S
$LN163@lssproto_S:

; 1346 : 							}else if (mask == 0x00080000){

  0198e	81 bd 48 fa ff
	ff 00 00 08 00	 cmp	 DWORD PTR _mask$31[ebp], 524288 ; 00080000H
  01998	75 75		 jne	 SHORT $LN165@lssproto_S

; 1347 : 								getStringToken(data, S_DELIM, i, sizeof(name) - 1, name);// 0x00080000

  0199a	8d 85 80 fb ff
	ff		 lea	 eax, DWORD PTR _name$36[ebp]
  019a0	50		 push	 eax
  019a1	68 ff 00 00 00	 push	 255			; 000000ffH
  019a6	8b 8d 54 fa ff
	ff		 mov	 ecx, DWORD PTR _i$32[ebp]
  019ac	51		 push	 ecx
  019ad	6a 7c		 push	 124			; 0000007cH
  019af	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  019b2	52		 push	 edx
  019b3	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  019b8	83 c4 14	 add	 esp, 20			; 00000014H

; 1348 : 								makeStringFromEscaped(name);

  019bb	8d 85 80 fb ff
	ff		 lea	 eax, DWORD PTR _name$36[ebp]
  019c1	50		 push	 eax
  019c2	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  019c7	83 c4 04	 add	 esp, 4

; 1349 : 								if (strlen(name) <= PET_NAME_LEN)

  019ca	8d 85 80 fb ff
	ff		 lea	 eax, DWORD PTR _name$36[ebp]
  019d0	50		 push	 eax
  019d1	e8 00 00 00 00	 call	 _strlen
  019d6	83 c4 04	 add	 esp, 4
  019d9	83 f8 10	 cmp	 eax, 16			; 00000010H
  019dc	77 20		 ja	 SHORT $LN167@lssproto_S

; 1350 : 									strcpy(pet[no].name, name);

  019de	8d 85 80 fb ff
	ff		 lea	 eax, DWORD PTR _name$36[ebp]
  019e4	50		 push	 eax
  019e5	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  019ef	81 c1 54 00 00
	00		 add	 ecx, OFFSET ?pet@@3PAUPET@@A+84
  019f5	51		 push	 ecx
  019f6	e8 00 00 00 00	 call	 _strcpy
  019fb	83 c4 08	 add	 esp, 8
$LN167@lssproto_S:

; 1351 : 								i++;

  019fe	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  01a04	83 c0 01	 add	 eax, 1
  01a07	89 85 54 fa ff
	ff		 mov	 DWORD PTR _i$32[ebp], eax
  01a0d	eb 7f		 jmp	 SHORT $LN128@lssproto_S
$LN165@lssproto_S:

; 1352 : 							}else if (mask == 0x00100000){

  01a0f	81 bd 48 fa ff
	ff 00 00 10 00	 cmp	 DWORD PTR _mask$31[ebp], 1048576 ; 00100000H
  01a19	75 73		 jne	 SHORT $LN128@lssproto_S

; 1353 : 								getStringToken(data, S_DELIM, i, sizeof(freeName) - 1, freeName);// 0x00100000

  01a1b	8d 85 78 fa ff
	ff		 lea	 eax, DWORD PTR _freeName$35[ebp]
  01a21	50		 push	 eax
  01a22	68 ff 00 00 00	 push	 255			; 000000ffH
  01a27	8b 8d 54 fa ff
	ff		 mov	 ecx, DWORD PTR _i$32[ebp]
  01a2d	51		 push	 ecx
  01a2e	6a 7c		 push	 124			; 0000007cH
  01a30	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  01a33	52		 push	 edx
  01a34	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  01a39	83 c4 14	 add	 esp, 20			; 00000014H

; 1354 : 								makeStringFromEscaped(freeName);

  01a3c	8d 85 78 fa ff
	ff		 lea	 eax, DWORD PTR _freeName$35[ebp]
  01a42	50		 push	 eax
  01a43	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  01a48	83 c4 04	 add	 esp, 4

; 1355 : 								if (strlen(freeName) <= PET_NAME_LEN)

  01a4b	8d 85 78 fa ff
	ff		 lea	 eax, DWORD PTR _freeName$35[ebp]
  01a51	50		 push	 eax
  01a52	e8 00 00 00 00	 call	 _strlen
  01a57	83 c4 04	 add	 esp, 4
  01a5a	83 f8 10	 cmp	 eax, 16			; 00000010H
  01a5d	77 20		 ja	 SHORT $LN169@lssproto_S

; 1356 : 									strcpy(pet[no].freeName, freeName);

  01a5f	8d 85 78 fa ff
	ff		 lea	 eax, DWORD PTR _freeName$35[ebp]
  01a65	50		 push	 eax
  01a66	69 8d 6c fa ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _no$34[ebp], 2848
  01a70	81 c1 65 00 00
	00		 add	 ecx, OFFSET ?pet@@3PAUPET@@A+101
  01a76	51		 push	 ecx
  01a77	e8 00 00 00 00	 call	 _strcpy
  01a7c	83 c4 08	 add	 esp, 8
$LN169@lssproto_S:

; 1357 : 								i++;

  01a7f	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$32[ebp]
  01a85	83 c0 01	 add	 eax, 1
  01a88	89 85 54 fa ff
	ff		 mov	 DWORD PTR _i$32[ebp], eax
$LN128@lssproto_S:

; 1358 : 							}
; 1359 : 							//printf("petdata[2]:%s\n",data);
; 1360 : 						}
; 1361 : 					}

  01a8e	e9 05 fa ff ff	 jmp	 $LN7@lssproto_S
$LN123@lssproto_S:

; 1362 : 				}
; 1363 : 
; 1364 : 			}
; 1365 : 			break;

  01a93	e9 7e 17 00 00	 jmp	 $LN1@lssproto_S
$LN170@lssproto_S:

; 1366 : 		case 'E':
; 1367 : 			{
; 1368 : 				data++;

  01a98	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  01a9b	83 c0 01	 add	 eax, 1
  01a9e	89 45 0c	 mov	 DWORD PTR _data$[ebp], eax

; 1369 : 				minEncountPercentage = getIntegerToken(data, S_DELIM, 1);

  01aa1	6a 01		 push	 1
  01aa3	6a 7c		 push	 124			; 0000007cH
  01aa5	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  01aa8	50		 push	 eax
  01aa9	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01aae	83 c4 0c	 add	 esp, 12			; 0000000cH
  01ab1	66 a3 00 00 00
	00		 mov	 WORD PTR ?minEncountPercentage@@3FA, ax ; minEncountPercentage

; 1370 : 				maxEncountPercentage = getIntegerToken(data, S_DELIM, 2);

  01ab7	6a 02		 push	 2
  01ab9	6a 7c		 push	 124			; 0000007cH
  01abb	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  01abe	50		 push	 eax
  01abf	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01ac4	83 c4 0c	 add	 esp, 12			; 0000000cH
  01ac7	66 a3 00 00 00
	00		 mov	 WORD PTR ?maxEncountPercentage@@3FA, ax ; maxEncountPercentage

; 1371 : 				nowEncountPercentage = minEncountPercentage;

  01acd	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?minEncountPercentage@@3FA ; minEncountPercentage
  01ad3	66 a3 00 00 00
	00		 mov	 WORD PTR ?nowEncountPercentage@@3FA, ax ; nowEncountPercentage

; 1372 : 			}
; 1373 : 			break;

  01ad9	e9 38 17 00 00	 jmp	 $LN1@lssproto_S
$LN171@lssproto_S:

; 1374 : 		case 'J':
; 1375 : 			{
; 1376 : 				char name[256], memo[256];
; 1377 : 				int no;
; 1378 : 
; 1379 : 				no = data[1] - '0';

  01ade	b8 01 00 00 00	 mov	 eax, 1
  01ae3	c1 e0 00	 shl	 eax, 0
  01ae6	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  01ae9	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01aed	83 ea 30	 sub	 edx, 48			; 00000030H
  01af0	89 95 14 f8 ff
	ff		 mov	 DWORD PTR _no$26[ebp], edx

; 1380 : 				data += 3;

  01af6	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  01af9	83 c0 03	 add	 eax, 3
  01afc	89 45 0c	 mov	 DWORD PTR _data$[ebp], eax

; 1381 : 				magic[no].useFlag = getIntegerToken(data, S_DELIM, 1);

  01aff	6a 01		 push	 1
  01b01	6a 7c		 push	 124			; 0000007cH
  01b03	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  01b06	50		 push	 eax
  01b07	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01b0c	83 c4 0c	 add	 esp, 12			; 0000000cH
  01b0f	6b 8d 14 f8 ff
	ff 70		 imul	 ecx, DWORD PTR _no$26[ebp], 112
  01b16	66 89 81 00 00
	00 00		 mov	 WORD PTR ?magic@@3PAUMAGIC@@A[ecx], ax

; 1382 : 				if (magic[no].useFlag == 0)

  01b1d	6b 85 14 f8 ff
	ff 70		 imul	 eax, DWORD PTR _no$26[ebp], 112
  01b24	0f bf 88 00 00
	00 00		 movsx	 ecx, WORD PTR ?magic@@3PAUMAGIC@@A[eax]
  01b2b	85 c9		 test	 ecx, ecx
  01b2d	75 05		 jne	 SHORT $LN172@lssproto_S

; 1383 : 					break;

  01b2f	e9 e2 16 00 00	 jmp	 $LN1@lssproto_S
$LN172@lssproto_S:

; 1384 : 				magic[no].mp		= getIntegerToken(data, S_DELIM, 2);

  01b34	6a 02		 push	 2
  01b36	6a 7c		 push	 124			; 0000007cH
  01b38	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  01b3b	50		 push	 eax
  01b3c	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01b41	83 c4 0c	 add	 esp, 12			; 0000000cH
  01b44	6b 8d 14 f8 ff
	ff 70		 imul	 ecx, DWORD PTR _no$26[ebp], 112
  01b4b	89 81 04 00 00
	00		 mov	 DWORD PTR ?magic@@3PAUMAGIC@@A[ecx+4], eax

; 1385 : 				magic[no].field		= getIntegerToken(data, S_DELIM, 3);

  01b51	6a 03		 push	 3
  01b53	6a 7c		 push	 124			; 0000007cH
  01b55	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  01b58	50		 push	 eax
  01b59	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01b5e	83 c4 0c	 add	 esp, 12			; 0000000cH
  01b61	6b 8d 14 f8 ff
	ff 70		 imul	 ecx, DWORD PTR _no$26[ebp], 112
  01b68	66 89 81 08 00
	00 00		 mov	 WORD PTR ?magic@@3PAUMAGIC@@A[ecx+8], ax

; 1386 : 				magic[no].target	= getIntegerToken(data, S_DELIM, 4);

  01b6f	6a 04		 push	 4
  01b71	6a 7c		 push	 124			; 0000007cH
  01b73	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  01b76	50		 push	 eax
  01b77	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01b7c	83 c4 0c	 add	 esp, 12			; 0000000cH
  01b7f	6b 8d 14 f8 ff
	ff 70		 imul	 ecx, DWORD PTR _no$26[ebp], 112
  01b86	66 89 81 0a 00
	00 00		 mov	 WORD PTR ?magic@@3PAUMAGIC@@A[ecx+10], ax

; 1387 : 				if (magic[no].target >= 100)

  01b8d	6b 85 14 f8 ff
	ff 70		 imul	 eax, DWORD PTR _no$26[ebp], 112
  01b94	0f bf 88 0a 00
	00 00		 movsx	 ecx, WORD PTR ?magic@@3PAUMAGIC@@A[eax+10]
  01b9b	83 f9 64	 cmp	 ecx, 100		; 00000064H
  01b9e	7c 39		 jl	 SHORT $LN173@lssproto_S

; 1388 : 				{
; 1389 : 					magic[no].target %= 100;

  01ba0	6b 85 14 f8 ff
	ff 70		 imul	 eax, DWORD PTR _no$26[ebp], 112
  01ba7	0f bf 80 0a 00
	00 00		 movsx	 eax, WORD PTR ?magic@@3PAUMAGIC@@A[eax+10]
  01bae	99		 cdq
  01baf	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  01bb4	f7 f9		 idiv	 ecx
  01bb6	6b 85 14 f8 ff
	ff 70		 imul	 eax, DWORD PTR _no$26[ebp], 112
  01bbd	66 89 90 0a 00
	00 00		 mov	 WORD PTR ?magic@@3PAUMAGIC@@A[eax+10], dx

; 1390 : 					magic[no].deadTargetFlag = 1;

  01bc4	6b 85 14 f8 ff
	ff 70		 imul	 eax, DWORD PTR _no$26[ebp], 112
  01bcb	b9 01 00 00 00	 mov	 ecx, 1
  01bd0	66 89 88 0c 00
	00 00		 mov	 WORD PTR ?magic@@3PAUMAGIC@@A[eax+12], cx

; 1391 : 				}
; 1392 : 				else

  01bd7	eb 10		 jmp	 SHORT $LN174@lssproto_S
$LN173@lssproto_S:

; 1393 : 					magic[no].deadTargetFlag = 0;

  01bd9	6b 85 14 f8 ff
	ff 70		 imul	 eax, DWORD PTR _no$26[ebp], 112
  01be0	33 c9		 xor	 ecx, ecx
  01be2	66 89 88 0c 00
	00 00		 mov	 WORD PTR ?magic@@3PAUMAGIC@@A[eax+12], cx
$LN174@lssproto_S:

; 1394 : 				getStringToken(data, S_DELIM, 5, sizeof(name) - 1, name);

  01be9	8d 85 28 f9 ff
	ff		 lea	 eax, DWORD PTR _name$28[ebp]
  01bef	50		 push	 eax
  01bf0	68 ff 00 00 00	 push	 255			; 000000ffH
  01bf5	6a 05		 push	 5
  01bf7	6a 7c		 push	 124			; 0000007cH
  01bf9	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  01bfc	51		 push	 ecx
  01bfd	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  01c02	83 c4 14	 add	 esp, 20			; 00000014H

; 1395 : 				makeStringFromEscaped(name);

  01c05	8d 85 28 f9 ff
	ff		 lea	 eax, DWORD PTR _name$28[ebp]
  01c0b	50		 push	 eax
  01c0c	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  01c11	83 c4 04	 add	 esp, 4

; 1396 : 				if (strlen(name) <= sizeof(magic[no].name) - 1)

  01c14	8d 85 28 f9 ff
	ff		 lea	 eax, DWORD PTR _name$28[ebp]
  01c1a	50		 push	 eax
  01c1b	e8 00 00 00 00	 call	 _strlen
  01c20	83 c4 04	 add	 esp, 4
  01c23	83 f8 18	 cmp	 eax, 24			; 00000018H
  01c26	77 1d		 ja	 SHORT $LN175@lssproto_S

; 1397 : 					strcpy(magic[no].name, name);

  01c28	8d 85 28 f9 ff
	ff		 lea	 eax, DWORD PTR _name$28[ebp]
  01c2e	50		 push	 eax
  01c2f	6b 8d 14 f8 ff
	ff 70		 imul	 ecx, DWORD PTR _no$26[ebp], 112
  01c36	81 c1 0e 00 00
	00		 add	 ecx, OFFSET ?magic@@3PAUMAGIC@@A+14
  01c3c	51		 push	 ecx
  01c3d	e8 00 00 00 00	 call	 _strcpy
  01c42	83 c4 08	 add	 esp, 8
$LN175@lssproto_S:

; 1398 : 				getStringToken(data, S_DELIM, 6, sizeof(memo) - 1, memo);

  01c45	8d 85 20 f8 ff
	ff		 lea	 eax, DWORD PTR _memo$27[ebp]
  01c4b	50		 push	 eax
  01c4c	68 ff 00 00 00	 push	 255			; 000000ffH
  01c51	6a 06		 push	 6
  01c53	6a 7c		 push	 124			; 0000007cH
  01c55	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  01c58	51		 push	 ecx
  01c59	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  01c5e	83 c4 14	 add	 esp, 20			; 00000014H

; 1399 : 				makeStringFromEscaped(memo);

  01c61	8d 85 20 f8 ff
	ff		 lea	 eax, DWORD PTR _memo$27[ebp]
  01c67	50		 push	 eax
  01c68	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  01c6d	83 c4 04	 add	 esp, 4

; 1400 : 				if (strlen(memo) <= sizeof(magic[no].memo) - 1)

  01c70	8d 85 20 f8 ff
	ff		 lea	 eax, DWORD PTR _memo$27[ebp]
  01c76	50		 push	 eax
  01c77	e8 00 00 00 00	 call	 _strlen
  01c7c	83 c4 04	 add	 esp, 4
  01c7f	83 f8 48	 cmp	 eax, 72			; 00000048H
  01c82	77 1d		 ja	 SHORT $LN176@lssproto_S

; 1401 : 					strcpy(magic[no].memo, memo);

  01c84	8d 85 20 f8 ff
	ff		 lea	 eax, DWORD PTR _memo$27[ebp]
  01c8a	50		 push	 eax
  01c8b	6b 8d 14 f8 ff
	ff 70		 imul	 ecx, DWORD PTR _no$26[ebp], 112
  01c92	81 c1 27 00 00
	00		 add	 ecx, OFFSET ?magic@@3PAUMAGIC@@A+39
  01c98	51		 push	 ecx
  01c99	e8 00 00 00 00	 call	 _strcpy
  01c9e	83 c4 08	 add	 esp, 8
$LN176@lssproto_S:

; 1402 : 			}
; 1403 : 			break;

  01ca1	e9 70 15 00 00	 jmp	 $LN1@lssproto_S
$LN177@lssproto_S:

; 1404 : 		case 'N':
; 1405 : 			{
; 1406 : 				ACTION *ptAct;
; 1407 : 				char name[256];
; 1408 : 				int no, kubun, i, checkPartyCount, gx, gy, no2;
; 1409 : 				unsigned int mask;
; 1410 : 				
; 1411 : 				no = data[1] - '0';

  01ca6	b8 01 00 00 00	 mov	 eax, 1
  01cab	c1 e0 00	 shl	 eax, 0
  01cae	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  01cb1	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01cb5	83 ea 30	 sub	 edx, 48			; 00000030H
  01cb8	89 95 f4 f6 ff
	ff		 mov	 DWORD PTR _no$23[ebp], edx

; 1412 : 				data += 3;

  01cbe	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  01cc1	83 c0 03	 add	 eax, 3
  01cc4	89 45 0c	 mov	 DWORD PTR _data$[ebp], eax

; 1413 : 				kubun = getInteger62Token(data, S_DELIM, 1);

  01cc7	6a 01		 push	 1
  01cc9	6a 7c		 push	 124			; 0000007cH
  01ccb	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  01cce	50		 push	 eax
  01ccf	e8 00 00 00 00	 call	 ?getInteger62Token@@YAHPADDH@Z ; getInteger62Token
  01cd4	83 c4 0c	 add	 esp, 12			; 0000000cH
  01cd7	89 85 e8 f6 ff
	ff		 mov	 DWORD PTR _kubun$22[ebp], eax

; 1414 : 				if (kubun == 0)

  01cdd	83 bd e8 f6 ff
	ff 00		 cmp	 DWORD PTR _kubun$22[ebp], 0
  01ce4	0f 85 c8 01 00
	00		 jne	 $LN178@lssproto_S

; 1415 : 				{
; 1416 : 					if (party[no].useFlag != 0 && party[no].id != pc.id)

  01cea	6b 85 f4 f6 ff
	ff 30		 imul	 eax, DWORD PTR _no$23[ebp], 48
  01cf1	0f bf 88 00 00
	00 00		 movsx	 ecx, WORD PTR ?party@@3PAUPARTY@@A[eax]
  01cf8	85 c9		 test	 ecx, ecx
  01cfa	74 49		 je	 SHORT $LN179@lssproto_S
  01cfc	6b 85 f4 f6 ff
	ff 30		 imul	 eax, DWORD PTR _no$23[ebp], 48
  01d03	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR ?party@@3PAUPARTY@@A[eax+4]
  01d09	3b 0d 08 00 00
	00		 cmp	 ecx, DWORD PTR ?pc@@3UPC@@A+8
  01d0f	74 34		 je	 SHORT $LN179@lssproto_S

; 1417 : 					{
; 1418 : 						ptAct = getCharObjAct(party[no].id);

  01d11	6b 85 f4 f6 ff
	ff 30		 imul	 eax, DWORD PTR _no$23[ebp], 48
  01d18	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR ?party@@3PAUPARTY@@A[eax+4]
  01d1e	51		 push	 ecx
  01d1f	e8 00 00 00 00	 call	 ?getCharObjAct@@YAPAUaction@@H@Z ; getCharObjAct
  01d24	83 c4 04	 add	 esp, 4
  01d27	89 85 08 f8 ff
	ff		 mov	 DWORD PTR _ptAct$25[ebp], eax

; 1419 : 						if (ptAct != NULL)

  01d2d	83 bd 08 f8 ff
	ff 00		 cmp	 DWORD PTR _ptAct$25[ebp], 0
  01d34	74 0f		 je	 SHORT $LN179@lssproto_S

; 1420 : 							delCharParty(ptAct);

  01d36	8b 85 08 f8 ff
	ff		 mov	 eax, DWORD PTR _ptAct$25[ebp]
  01d3c	50		 push	 eax
  01d3d	e8 00 00 00 00	 call	 ?delCharParty@@YAXPAUaction@@@Z ; delCharParty
  01d42	83 c4 04	 add	 esp, 4
$LN179@lssproto_S:

; 1421 : 					}
; 1422 : 					gx = -1;

  01d45	c7 85 c4 f6 ff
	ff ff ff ff ff	 mov	 DWORD PTR _gx$19[ebp], -1

; 1423 : 					gy = -1;

  01d4f	c7 85 b8 f6 ff
	ff ff ff ff ff	 mov	 DWORD PTR _gy$18[ebp], -1

; 1424 : 					if (party[no].ptAct != NULL)

  01d59	6b 85 f4 f6 ff
	ff 30		 imul	 eax, DWORD PTR _no$23[ebp], 48
  01d60	83 b8 2c 00 00
	00 00		 cmp	 DWORD PTR ?party@@3PAUPARTY@@A[eax+44], 0
  01d67	74 32		 je	 SHORT $LN181@lssproto_S

; 1425 : 					{
; 1426 : 						gx = party[no].ptAct->nextGx;

  01d69	6b 85 f4 f6 ff
	ff 30		 imul	 eax, DWORD PTR _no$23[ebp], 48
  01d70	8b 88 2c 00 00
	00		 mov	 ecx, DWORD PTR ?party@@3PAUPARTY@@A[eax+44]
  01d76	8b 91 bc 00 00
	00		 mov	 edx, DWORD PTR [ecx+188]
  01d7c	89 95 c4 f6 ff
	ff		 mov	 DWORD PTR _gx$19[ebp], edx

; 1427 : 						gy = party[no].ptAct->nextGy;

  01d82	6b 85 f4 f6 ff
	ff 30		 imul	 eax, DWORD PTR _no$23[ebp], 48
  01d89	8b 88 2c 00 00
	00		 mov	 ecx, DWORD PTR ?party@@3PAUPARTY@@A[eax+44]
  01d8f	8b 91 c0 00 00
	00		 mov	 edx, DWORD PTR [ecx+192]
  01d95	89 95 b8 f6 ff
	ff		 mov	 DWORD PTR _gy$18[ebp], edx
$LN181@lssproto_S:

; 1428 : 					}
; 1429 : 					party[no].useFlag = 0;

  01d9b	6b 85 f4 f6 ff
	ff 30		 imul	 eax, DWORD PTR _no$23[ebp], 48
  01da2	33 c9		 xor	 ecx, ecx
  01da4	66 89 88 00 00
	00 00		 mov	 WORD PTR ?party@@3PAUPARTY@@A[eax], cx

; 1430 : 					party[no].ptAct	= NULL;

  01dab	6b 85 f4 f6 ff
	ff 30		 imul	 eax, DWORD PTR _no$23[ebp], 48
  01db2	c7 80 2c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?party@@3PAUPARTY@@A[eax+44], 0

; 1431 : 					checkPartyCount = 0;

  01dbc	c7 85 d0 f6 ff
	ff 00 00 00 00	 mov	 DWORD PTR _checkPartyCount$20[ebp], 0

; 1432 : 					no2 = -1;

  01dc6	c7 85 ac f6 ff
	ff ff ff ff ff	 mov	 DWORD PTR _no2$17[ebp], -1

; 1433 : 					for (i = 0; i < MAX_PARTY; i++)

  01dd0	c7 85 dc f6 ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$21[ebp], 0
  01dda	eb 0f		 jmp	 SHORT $LN12@lssproto_S
$LN10@lssproto_S:
  01ddc	8b 85 dc f6 ff
	ff		 mov	 eax, DWORD PTR _i$21[ebp]
  01de2	83 c0 01	 add	 eax, 1
  01de5	89 85 dc f6 ff
	ff		 mov	 DWORD PTR _i$21[ebp], eax
$LN12@lssproto_S:
  01deb	83 bd dc f6 ff
	ff 05		 cmp	 DWORD PTR _i$21[ebp], 5
  01df2	7d 46		 jge	 SHORT $LN11@lssproto_S

; 1434 : 					{
; 1435 : 						if (party[i].useFlag != 0)

  01df4	6b 85 dc f6 ff
	ff 30		 imul	 eax, DWORD PTR _i$21[ebp], 48
  01dfb	0f bf 88 00 00
	00 00		 movsx	 ecx, WORD PTR ?party@@3PAUPARTY@@A[eax]
  01e02	85 c9		 test	 ecx, ecx
  01e04	74 32		 je	 SHORT $LN182@lssproto_S

; 1436 : 						{
; 1437 : 							checkPartyCount++;

  01e06	8b 85 d0 f6 ff
	ff		 mov	 eax, DWORD PTR _checkPartyCount$20[ebp]
  01e0c	83 c0 01	 add	 eax, 1
  01e0f	89 85 d0 f6 ff
	ff		 mov	 DWORD PTR _checkPartyCount$20[ebp], eax

; 1438 : 							if (no2 == -1 && i > no)

  01e15	83 bd ac f6 ff
	ff ff		 cmp	 DWORD PTR _no2$17[ebp], -1
  01e1c	75 1a		 jne	 SHORT $LN182@lssproto_S
  01e1e	8b 85 dc f6 ff
	ff		 mov	 eax, DWORD PTR _i$21[ebp]
  01e24	3b 85 f4 f6 ff
	ff		 cmp	 eax, DWORD PTR _no$23[ebp]
  01e2a	7e 0c		 jle	 SHORT $LN182@lssproto_S

; 1439 : 								no2 = i;

  01e2c	8b 85 dc f6 ff
	ff		 mov	 eax, DWORD PTR _i$21[ebp]
  01e32	89 85 ac f6 ff
	ff		 mov	 DWORD PTR _no2$17[ebp], eax
$LN182@lssproto_S:

; 1440 : 						}
; 1441 : 					}

  01e38	eb a2		 jmp	 SHORT $LN10@lssproto_S
$LN11@lssproto_S:

; 1442 : 					if (checkPartyCount <= 1)

  01e3a	83 bd d0 f6 ff
	ff 01		 cmp	 DWORD PTR _checkPartyCount$20[ebp], 1
  01e41	7f 32		 jg	 SHORT $LN184@lssproto_S

; 1443 : 					{
; 1444 : 						partyModeFlag = 0;

  01e43	33 c0		 xor	 eax, eax
  01e45	66 a3 00 00 00
	00		 mov	 WORD PTR ?partyModeFlag@@3FA, ax ; partyModeFlag

; 1445 : 						clearPartyParam();

  01e4b	e8 00 00 00 00	 call	 ?clearPartyParam@@YAXXZ	; clearPartyParam

; 1446 : #ifdef _CHANNEL_MODIFY
; 1447 : 						pc.etcFlag &= ~PC_ETCFLAG_CHAT_MODE;

  01e50	0f b7 05 a8 00
	00 00		 movzx	 eax, WORD PTR ?pc@@3UPC@@A+168
  01e57	83 e0 f7	 and	 eax, -9			; fffffff7H
  01e5a	66 a3 a8 00 00
	00		 mov	 WORD PTR ?pc@@3UPC@@A+168, ax

; 1448 : 						if (TalkMode == 2)

  01e60	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?TalkMode@@3HA, 2 ; TalkMode
  01e67	75 0a		 jne	 SHORT $LN186@lssproto_S

; 1449 : 							TalkMode = 0;

  01e69	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?TalkMode@@3HA, 0 ; TalkMode
$LN186@lssproto_S:

; 1450 : #endif
; 1451 : 					}
; 1452 : 					else

  01e73	eb 38		 jmp	 SHORT $LN185@lssproto_S
$LN184@lssproto_S:

; 1453 : 					{
; 1454 : 						if (no2 >= 0 || gx >= 0 || gy >= 0)

  01e75	83 bd ac f6 ff
	ff 00		 cmp	 DWORD PTR _no2$17[ebp], 0
  01e7c	7d 12		 jge	 SHORT $LN188@lssproto_S
  01e7e	83 bd c4 f6 ff
	ff 00		 cmp	 DWORD PTR _gx$19[ebp], 0
  01e85	7d 09		 jge	 SHORT $LN188@lssproto_S
  01e87	83 bd b8 f6 ff
	ff 00		 cmp	 DWORD PTR _gy$18[ebp], 0
  01e8e	7c 1d		 jl	 SHORT $LN185@lssproto_S
$LN188@lssproto_S:

; 1455 : 							goFrontPartyCharacter(no2, gx, gy);

  01e90	8b 85 b8 f6 ff
	ff		 mov	 eax, DWORD PTR _gy$18[ebp]
  01e96	50		 push	 eax
  01e97	8b 8d c4 f6 ff
	ff		 mov	 ecx, DWORD PTR _gx$19[ebp]
  01e9d	51		 push	 ecx
  01e9e	8b 95 ac f6 ff
	ff		 mov	 edx, DWORD PTR _no2$17[ebp]
  01ea4	52		 push	 edx
  01ea5	e8 00 00 00 00	 call	 ?goFrontPartyCharacter@@YAXHHH@Z ; goFrontPartyCharacter
  01eaa	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN185@lssproto_S:

; 1456 : 					}
; 1457 : 					break;

  01ead	e9 64 13 00 00	 jmp	 $LN1@lssproto_S
$LN178@lssproto_S:

; 1458 : 				}
; 1459 : 				partyModeFlag = 1;

  01eb2	b8 01 00 00 00	 mov	 eax, 1
  01eb7	66 a3 00 00 00
	00		 mov	 WORD PTR ?partyModeFlag@@3FA, ax ; partyModeFlag

; 1460 : 				prSendFlag = 0;

  01ebd	33 c0		 xor	 eax, eax
  01ebf	66 a3 00 00 00
	00		 mov	 WORD PTR ?prSendFlag@@3FA, ax ; prSendFlag

; 1461 : 				party[no].useFlag = 1;

  01ec5	6b 85 f4 f6 ff
	ff 30		 imul	 eax, DWORD PTR _no$23[ebp], 48
  01ecc	b9 01 00 00 00	 mov	 ecx, 1
  01ed1	66 89 88 00 00
	00 00		 mov	 WORD PTR ?party@@3PAUPARTY@@A[eax], cx

; 1462 : 				
; 1463 : 				if (kubun == 1)

  01ed8	83 bd e8 f6 ff
	ff 01		 cmp	 DWORD PTR _kubun$22[ebp], 1
  01edf	0f 85 0e 01 00
	00		 jne	 $LN189@lssproto_S

; 1464 : 				{
; 1465 : 					party[no].id		= getIntegerToken(data, S_DELIM, 2);	// 0x00000002

  01ee5	6a 02		 push	 2
  01ee7	6a 7c		 push	 124			; 0000007cH
  01ee9	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  01eec	50		 push	 eax
  01eed	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01ef2	83 c4 0c	 add	 esp, 12			; 0000000cH
  01ef5	6b 8d f4 f6 ff
	ff 30		 imul	 ecx, DWORD PTR _no$23[ebp], 48
  01efc	89 81 04 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[ecx+4], eax

; 1466 : 					party[no].level		= getIntegerToken(data, S_DELIM, 3);	// 0x00000004

  01f02	6a 03		 push	 3
  01f04	6a 7c		 push	 124			; 0000007cH
  01f06	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  01f09	50		 push	 eax
  01f0a	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01f0f	83 c4 0c	 add	 esp, 12			; 0000000cH
  01f12	6b 8d f4 f6 ff
	ff 30		 imul	 ecx, DWORD PTR _no$23[ebp], 48
  01f19	89 81 08 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[ecx+8], eax

; 1467 : 					party[no].maxHp		= getIntegerToken(data, S_DELIM, 4);	// 0x00000008

  01f1f	6a 04		 push	 4
  01f21	6a 7c		 push	 124			; 0000007cH
  01f23	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  01f26	50		 push	 eax
  01f27	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01f2c	83 c4 0c	 add	 esp, 12			; 0000000cH
  01f2f	6b 8d f4 f6 ff
	ff 30		 imul	 ecx, DWORD PTR _no$23[ebp], 48
  01f36	89 81 0c 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[ecx+12], eax

; 1468 : 					party[no].hp		= getIntegerToken(data, S_DELIM, 5);	// 0x00000010

  01f3c	6a 05		 push	 5
  01f3e	6a 7c		 push	 124			; 0000007cH
  01f40	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  01f43	50		 push	 eax
  01f44	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01f49	83 c4 0c	 add	 esp, 12			; 0000000cH
  01f4c	6b 8d f4 f6 ff
	ff 30		 imul	 ecx, DWORD PTR _no$23[ebp], 48
  01f53	89 81 10 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[ecx+16], eax

; 1469 : 					party[no].mp		= getIntegerToken(data, S_DELIM, 6);	// 0x00000020

  01f59	6a 06		 push	 6
  01f5b	6a 7c		 push	 124			; 0000007cH
  01f5d	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  01f60	50		 push	 eax
  01f61	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  01f66	83 c4 0c	 add	 esp, 12			; 0000000cH
  01f69	6b 8d f4 f6 ff
	ff 30		 imul	 ecx, DWORD PTR _no$23[ebp], 48
  01f70	89 81 14 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[ecx+20], eax

; 1470 : 					getStringToken(data, S_DELIM, 7, sizeof(name) - 1, name);	// 0x00000040

  01f76	8d 85 00 f7 ff
	ff		 lea	 eax, DWORD PTR _name$24[ebp]
  01f7c	50		 push	 eax
  01f7d	68 ff 00 00 00	 push	 255			; 000000ffH
  01f82	6a 07		 push	 7
  01f84	6a 7c		 push	 124			; 0000007cH
  01f86	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  01f89	51		 push	 ecx
  01f8a	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  01f8f	83 c4 14	 add	 esp, 20			; 00000014H

; 1471 : 					makeStringFromEscaped(name);

  01f92	8d 85 00 f7 ff
	ff		 lea	 eax, DWORD PTR _name$24[ebp]
  01f98	50		 push	 eax
  01f99	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  01f9e	83 c4 04	 add	 esp, 4

; 1472 : 					if (strlen(name) <= sizeof(party[no].name) - 1)

  01fa1	8d 85 00 f7 ff
	ff		 lea	 eax, DWORD PTR _name$24[ebp]
  01fa7	50		 push	 eax
  01fa8	e8 00 00 00 00	 call	 _strlen
  01fad	83 c4 04	 add	 esp, 4
  01fb0	83 f8 10	 cmp	 eax, 16			; 00000010H
  01fb3	77 1f		 ja	 SHORT $LN191@lssproto_S

; 1473 : 						strcpy(party[no].name, name);

  01fb5	8d 85 00 f7 ff
	ff		 lea	 eax, DWORD PTR _name$24[ebp]
  01fbb	50		 push	 eax
  01fbc	6b 8d f4 f6 ff
	ff 30		 imul	 ecx, DWORD PTR _no$23[ebp], 48
  01fc3	81 c1 18 00 00
	00		 add	 ecx, OFFSET ?party@@3PAUPARTY@@A+24
  01fc9	51		 push	 ecx
  01fca	e8 00 00 00 00	 call	 _strcpy
  01fcf	83 c4 08	 add	 esp, 8

; 1474 : 					else

  01fd2	eb 1a		 jmp	 SHORT $LN192@lssproto_S
$LN191@lssproto_S:

; 1475 : 						strcpy(party[no].name, "???");

  01fd4	68 00 00 00 00	 push	 OFFSET ??_C@_03BBKEAIF@?$DP?$DP?$DP?$AA@
  01fd9	6b 85 f4 f6 ff
	ff 30		 imul	 eax, DWORD PTR _no$23[ebp], 48
  01fe0	05 18 00 00 00	 add	 eax, OFFSET ?party@@3PAUPARTY@@A+24
  01fe5	50		 push	 eax
  01fe6	e8 00 00 00 00	 call	 _strcpy
  01feb	83 c4 08	 add	 esp, 8
$LN192@lssproto_S:

; 1476 : 				}
; 1477 : 				else

  01fee	e9 1c 02 00 00	 jmp	 $LN190@lssproto_S
$LN189@lssproto_S:

; 1478 : 				{
; 1479 : 					mask = 2;

  01ff3	c7 85 a0 f6 ff
	ff 02 00 00 00	 mov	 DWORD PTR _mask$16[ebp], 2

; 1480 : 					i = 2;

  01ffd	c7 85 dc f6 ff
	ff 02 00 00 00	 mov	 DWORD PTR _i$21[ebp], 2

; 1481 : 					for (; mask > 0; mask <<= 1)

  02007	eb 0e		 jmp	 SHORT $LN15@lssproto_S
$LN13@lssproto_S:
  02009	8b 85 a0 f6 ff
	ff		 mov	 eax, DWORD PTR _mask$16[ebp]
  0200f	d1 e0		 shl	 eax, 1
  02011	89 85 a0 f6 ff
	ff		 mov	 DWORD PTR _mask$16[ebp], eax
$LN15@lssproto_S:
  02017	83 bd a0 f6 ff
	ff 00		 cmp	 DWORD PTR _mask$16[ebp], 0
  0201e	0f 86 eb 01 00
	00		 jbe	 $LN190@lssproto_S

; 1482 : 					{
; 1483 : 						if (kubun & mask)

  02024	8b 85 e8 f6 ff
	ff		 mov	 eax, DWORD PTR _kubun$22[ebp]
  0202a	23 85 a0 f6 ff
	ff		 and	 eax, DWORD PTR _mask$16[ebp]
  02030	0f 84 d4 01 00
	00		 je	 $LN193@lssproto_S

; 1484 : 						{
; 1485 : 							if (mask == 0x00000002)

  02036	83 bd a0 f6 ff
	ff 02		 cmp	 DWORD PTR _mask$16[ebp], 2
  0203d	75 36		 jne	 SHORT $LN194@lssproto_S

; 1486 : 							{
; 1487 : 								party[no].id = getIntegerToken(data, S_DELIM, i);// 0x00000002

  0203f	8b 85 dc f6 ff
	ff		 mov	 eax, DWORD PTR _i$21[ebp]
  02045	50		 push	 eax
  02046	6a 7c		 push	 124			; 0000007cH
  02048	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0204b	51		 push	 ecx
  0204c	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  02051	83 c4 0c	 add	 esp, 12			; 0000000cH
  02054	6b 95 f4 f6 ff
	ff 30		 imul	 edx, DWORD PTR _no$23[ebp], 48
  0205b	89 82 04 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[edx+4], eax

; 1488 : 								i++;

  02061	8b 85 dc f6 ff
	ff		 mov	 eax, DWORD PTR _i$21[ebp]
  02067	83 c0 01	 add	 eax, 1
  0206a	89 85 dc f6 ff
	ff		 mov	 DWORD PTR _i$21[ebp], eax
  02070	e9 95 01 00 00	 jmp	 $LN193@lssproto_S
$LN194@lssproto_S:

; 1489 : 							}
; 1490 : 							else if (mask == 0x00000004)

  02075	83 bd a0 f6 ff
	ff 04		 cmp	 DWORD PTR _mask$16[ebp], 4
  0207c	75 36		 jne	 SHORT $LN196@lssproto_S

; 1491 : 							{
; 1492 : 								party[no].level = getIntegerToken(data, S_DELIM, i);// 0x00000004

  0207e	8b 85 dc f6 ff
	ff		 mov	 eax, DWORD PTR _i$21[ebp]
  02084	50		 push	 eax
  02085	6a 7c		 push	 124			; 0000007cH
  02087	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0208a	51		 push	 ecx
  0208b	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  02090	83 c4 0c	 add	 esp, 12			; 0000000cH
  02093	6b 95 f4 f6 ff
	ff 30		 imul	 edx, DWORD PTR _no$23[ebp], 48
  0209a	89 82 08 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[edx+8], eax

; 1493 : 								i++;

  020a0	8b 85 dc f6 ff
	ff		 mov	 eax, DWORD PTR _i$21[ebp]
  020a6	83 c0 01	 add	 eax, 1
  020a9	89 85 dc f6 ff
	ff		 mov	 DWORD PTR _i$21[ebp], eax
  020af	e9 56 01 00 00	 jmp	 $LN193@lssproto_S
$LN196@lssproto_S:

; 1494 : 							}
; 1495 : 							else if (mask == 0x00000008)

  020b4	83 bd a0 f6 ff
	ff 08		 cmp	 DWORD PTR _mask$16[ebp], 8
  020bb	75 36		 jne	 SHORT $LN198@lssproto_S

; 1496 : 							{
; 1497 : 								party[no].maxHp = getIntegerToken(data, S_DELIM, i);// 0x00000008

  020bd	8b 85 dc f6 ff
	ff		 mov	 eax, DWORD PTR _i$21[ebp]
  020c3	50		 push	 eax
  020c4	6a 7c		 push	 124			; 0000007cH
  020c6	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  020c9	51		 push	 ecx
  020ca	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  020cf	83 c4 0c	 add	 esp, 12			; 0000000cH
  020d2	6b 95 f4 f6 ff
	ff 30		 imul	 edx, DWORD PTR _no$23[ebp], 48
  020d9	89 82 0c 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[edx+12], eax

; 1498 : 								i++;

  020df	8b 85 dc f6 ff
	ff		 mov	 eax, DWORD PTR _i$21[ebp]
  020e5	83 c0 01	 add	 eax, 1
  020e8	89 85 dc f6 ff
	ff		 mov	 DWORD PTR _i$21[ebp], eax
  020ee	e9 17 01 00 00	 jmp	 $LN193@lssproto_S
$LN198@lssproto_S:

; 1499 : 							}
; 1500 : 							else if (mask == 0x00000010)

  020f3	83 bd a0 f6 ff
	ff 10		 cmp	 DWORD PTR _mask$16[ebp], 16 ; 00000010H
  020fa	75 36		 jne	 SHORT $LN200@lssproto_S

; 1501 : 							{
; 1502 : 								party[no].hp = getIntegerToken(data, S_DELIM, i);// 0x00000010

  020fc	8b 85 dc f6 ff
	ff		 mov	 eax, DWORD PTR _i$21[ebp]
  02102	50		 push	 eax
  02103	6a 7c		 push	 124			; 0000007cH
  02105	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  02108	51		 push	 ecx
  02109	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0210e	83 c4 0c	 add	 esp, 12			; 0000000cH
  02111	6b 95 f4 f6 ff
	ff 30		 imul	 edx, DWORD PTR _no$23[ebp], 48
  02118	89 82 10 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[edx+16], eax

; 1503 : 								i++;

  0211e	8b 85 dc f6 ff
	ff		 mov	 eax, DWORD PTR _i$21[ebp]
  02124	83 c0 01	 add	 eax, 1
  02127	89 85 dc f6 ff
	ff		 mov	 DWORD PTR _i$21[ebp], eax
  0212d	e9 d8 00 00 00	 jmp	 $LN193@lssproto_S
$LN200@lssproto_S:

; 1504 : 							}
; 1505 : 							else if (mask == 0x00000020)

  02132	83 bd a0 f6 ff
	ff 20		 cmp	 DWORD PTR _mask$16[ebp], 32 ; 00000020H
  02139	75 36		 jne	 SHORT $LN202@lssproto_S

; 1506 : 							{
; 1507 : 								party[no].mp = getIntegerToken(data, S_DELIM, i);// 0x00000020

  0213b	8b 85 dc f6 ff
	ff		 mov	 eax, DWORD PTR _i$21[ebp]
  02141	50		 push	 eax
  02142	6a 7c		 push	 124			; 0000007cH
  02144	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  02147	51		 push	 ecx
  02148	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0214d	83 c4 0c	 add	 esp, 12			; 0000000cH
  02150	6b 95 f4 f6 ff
	ff 30		 imul	 edx, DWORD PTR _no$23[ebp], 48
  02157	89 82 14 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[edx+20], eax

; 1508 : 								i++;

  0215d	8b 85 dc f6 ff
	ff		 mov	 eax, DWORD PTR _i$21[ebp]
  02163	83 c0 01	 add	 eax, 1
  02166	89 85 dc f6 ff
	ff		 mov	 DWORD PTR _i$21[ebp], eax
  0216c	e9 99 00 00 00	 jmp	 $LN193@lssproto_S
$LN202@lssproto_S:

; 1509 : 							}
; 1510 : 							else if (mask == 0x00000040)

  02171	83 bd a0 f6 ff
	ff 40		 cmp	 DWORD PTR _mask$16[ebp], 64 ; 00000040H
  02178	0f 85 8c 00 00
	00		 jne	 $LN193@lssproto_S

; 1511 : 							{
; 1512 : 								getStringToken(data, S_DELIM, i, sizeof(name) - 1, name);// 0x00000040

  0217e	8d 85 00 f7 ff
	ff		 lea	 eax, DWORD PTR _name$24[ebp]
  02184	50		 push	 eax
  02185	68 ff 00 00 00	 push	 255			; 000000ffH
  0218a	8b 8d dc f6 ff
	ff		 mov	 ecx, DWORD PTR _i$21[ebp]
  02190	51		 push	 ecx
  02191	6a 7c		 push	 124			; 0000007cH
  02193	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  02196	52		 push	 edx
  02197	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0219c	83 c4 14	 add	 esp, 20			; 00000014H

; 1513 : 								makeStringFromEscaped(name);

  0219f	8d 85 00 f7 ff
	ff		 lea	 eax, DWORD PTR _name$24[ebp]
  021a5	50		 push	 eax
  021a6	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  021ab	83 c4 04	 add	 esp, 4

; 1514 : 								if (strlen(name) <= sizeof(party[no].name) - 1)

  021ae	8d 85 00 f7 ff
	ff		 lea	 eax, DWORD PTR _name$24[ebp]
  021b4	50		 push	 eax
  021b5	e8 00 00 00 00	 call	 _strlen
  021ba	83 c4 04	 add	 esp, 4
  021bd	83 f8 10	 cmp	 eax, 16			; 00000010H
  021c0	77 1f		 ja	 SHORT $LN205@lssproto_S

; 1515 : 									strcpy(party[no].name, name);

  021c2	8d 85 00 f7 ff
	ff		 lea	 eax, DWORD PTR _name$24[ebp]
  021c8	50		 push	 eax
  021c9	6b 8d f4 f6 ff
	ff 30		 imul	 ecx, DWORD PTR _no$23[ebp], 48
  021d0	81 c1 18 00 00
	00		 add	 ecx, OFFSET ?party@@3PAUPARTY@@A+24
  021d6	51		 push	 ecx
  021d7	e8 00 00 00 00	 call	 _strcpy
  021dc	83 c4 08	 add	 esp, 8

; 1516 : 								else

  021df	eb 1a		 jmp	 SHORT $LN206@lssproto_S
$LN205@lssproto_S:

; 1517 : 									strcpy(party[no].name, "???");

  021e1	68 00 00 00 00	 push	 OFFSET ??_C@_03BBKEAIF@?$DP?$DP?$DP?$AA@
  021e6	6b 85 f4 f6 ff
	ff 30		 imul	 eax, DWORD PTR _no$23[ebp], 48
  021ed	05 18 00 00 00	 add	 eax, OFFSET ?party@@3PAUPARTY@@A+24
  021f2	50		 push	 eax
  021f3	e8 00 00 00 00	 call	 _strcpy
  021f8	83 c4 08	 add	 esp, 8
$LN206@lssproto_S:

; 1518 : 								i++;

  021fb	8b 85 dc f6 ff
	ff		 mov	 eax, DWORD PTR _i$21[ebp]
  02201	83 c0 01	 add	 eax, 1
  02204	89 85 dc f6 ff
	ff		 mov	 DWORD PTR _i$21[ebp], eax
$LN193@lssproto_S:

; 1519 : 							}
; 1520 : 						}
; 1521 : 					}

  0220a	e9 fa fd ff ff	 jmp	 $LN13@lssproto_S
$LN190@lssproto_S:

; 1522 : 				}
; 1523 : 				if (party[no].id != pc.id)

  0220f	6b 85 f4 f6 ff
	ff 30		 imul	 eax, DWORD PTR _no$23[ebp], 48
  02216	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR ?party@@3PAUPARTY@@A[eax+4]
  0221c	3b 0d 08 00 00
	00		 cmp	 ecx, DWORD PTR ?pc@@3UPC@@A+8
  02222	74 74		 je	 SHORT $LN207@lssproto_S

; 1524 : 				{
; 1525 : 					ptAct = getCharObjAct(party[no].id);

  02224	6b 85 f4 f6 ff
	ff 30		 imul	 eax, DWORD PTR _no$23[ebp], 48
  0222b	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR ?party@@3PAUPARTY@@A[eax+4]
  02231	51		 push	 ecx
  02232	e8 00 00 00 00	 call	 ?getCharObjAct@@YAPAUaction@@H@Z ; getCharObjAct
  02237	83 c4 04	 add	 esp, 4
  0223a	89 85 08 f8 ff
	ff		 mov	 DWORD PTR _ptAct$25[ebp], eax

; 1526 : 					if (ptAct != NULL)

  02240	83 bd 08 f8 ff
	ff 00		 cmp	 DWORD PTR _ptAct$25[ebp], 0
  02247	74 3c		 je	 SHORT $LN209@lssproto_S

; 1527 : 					{
; 1528 : 						party[no].ptAct = ptAct;

  02249	6b 85 f4 f6 ff
	ff 30		 imul	 eax, DWORD PTR _no$23[ebp], 48
  02250	8b 8d 08 f8 ff
	ff		 mov	 ecx, DWORD PTR _ptAct$25[ebp]
  02256	89 88 2c 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[eax+44], ecx

; 1529 : 						setCharParty(ptAct);

  0225c	8b 85 08 f8 ff
	ff		 mov	 eax, DWORD PTR _ptAct$25[ebp]
  02262	50		 push	 eax
  02263	e8 00 00 00 00	 call	 ?setCharParty@@YAXPAUaction@@@Z ; setCharParty
  02268	83 c4 04	 add	 esp, 4

; 1530 : 						// NPC???????
; 1531 : 						if (no == 0)

  0226b	83 bd f4 f6 ff
	ff 00		 cmp	 DWORD PTR _no$23[ebp], 0
  02272	75 0f		 jne	 SHORT $LN211@lssproto_S

; 1532 : 							setCharLeader(ptAct);

  02274	8b 85 08 f8 ff
	ff		 mov	 eax, DWORD PTR _ptAct$25[ebp]
  0227a	50		 push	 eax
  0227b	e8 00 00 00 00	 call	 ?setCharLeader@@YAXPAUaction@@@Z ; setCharLeader
  02280	83 c4 04	 add	 esp, 4
$LN211@lssproto_S:

; 1533 : 					}
; 1534 : 					else

  02283	eb 11		 jmp	 SHORT $LN210@lssproto_S
$LN209@lssproto_S:

; 1535 : 						party[no].ptAct = NULL;

  02285	6b 85 f4 f6 ff
	ff 30		 imul	 eax, DWORD PTR _no$23[ebp], 48
  0228c	c7 80 2c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?party@@3PAUPARTY@@A[eax+44], 0
$LN210@lssproto_S:

; 1536 : 				}
; 1537 : 				else

  02296	eb 26		 jmp	 SHORT $LN208@lssproto_S
$LN207@lssproto_S:

; 1538 : 				{
; 1539 : 					party[no].ptAct = pc.ptAct;

  02298	6b 85 f4 f6 ff
	ff 30		 imul	 eax, DWORD PTR _no$23[ebp], 48
  0229f	8b 0d ec 50 00
	00		 mov	 ecx, DWORD PTR ?pc@@3UPC@@A+20716
  022a5	89 88 2c 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[eax+44], ecx

; 1540 : 					setPcParty();

  022ab	e8 00 00 00 00	 call	 ?setPcParty@@YAXXZ	; setPcParty

; 1541 : 					// PC???????
; 1542 : 					if (no == 0)

  022b0	83 bd f4 f6 ff
	ff 00		 cmp	 DWORD PTR _no$23[ebp], 0
  022b7	75 05		 jne	 SHORT $LN208@lssproto_S

; 1543 : 						setPcLeader();

  022b9	e8 00 00 00 00	 call	 ?setPcLeader@@YAXXZ	; setPcLeader
$LN208@lssproto_S:

; 1544 : 				}
; 1545 : 			}
; 1546 : 			break;

  022be	e9 53 0f 00 00	 jmp	 $LN1@lssproto_S
$LN213@lssproto_S:

; 1547 : 		case 'I':
; 1548 : 			{
; 1549 : 				int i, no;
; 1550 : 				char temp[256];
; 1551 : 				
; 1552 : 				data++;

  022c3	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  022c6	83 c0 01	 add	 eax, 1
  022c9	89 45 0c	 mov	 DWORD PTR _data$[ebp], eax

; 1553 : 				for (i = 0; i < MAX_ITEM; i++)

  022cc	c7 85 94 f6 ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$15[ebp], 0
  022d6	eb 0f		 jmp	 SHORT $LN18@lssproto_S
$LN16@lssproto_S:
  022d8	8b 85 94 f6 ff
	ff		 mov	 eax, DWORD PTR _i$15[ebp]
  022de	83 c0 01	 add	 eax, 1
  022e1	89 85 94 f6 ff
	ff		 mov	 DWORD PTR _i$15[ebp], eax
$LN18@lssproto_S:
  022e7	83 bd 94 f6 ff
	ff 36		 cmp	 DWORD PTR _i$15[ebp], 54 ; 00000036H
  022ee	0f 8d 65 04 00
	00		 jge	 $LN17@lssproto_S

; 1554 : 				{
; 1555 : #ifdef _PET_ITEM
; 1556 : 
; 1557 : 					//CC Fix
; 1558 : 					extern int g_服务器;
; 1559 : 					if (g_服务器 == SERVER_台服)

  022f4	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_服务器@@3HA, 1 ; g_服务器
  022fb	75 11		 jne	 SHORT $LN214@lssproto_S

; 1560 : 					{
; 1561 : 						no = i * 16;

  022fd	8b 85 94 f6 ff
	ff		 mov	 eax, DWORD PTR _i$15[ebp]
  02303	c1 e0 04	 shl	 eax, 4
  02306	89 85 88 f6 ff
	ff		 mov	 DWORD PTR _no$14[ebp], eax

; 1562 : 					}
; 1563 : 					else

  0230c	eb 0d		 jmp	 SHORT $LN215@lssproto_S
$LN214@lssproto_S:

; 1564 : 					{
; 1565 : 						no = i * 14;

  0230e	6b 85 94 f6 ff
	ff 0e		 imul	 eax, DWORD PTR _i$15[ebp], 14
  02315	89 85 88 f6 ff
	ff		 mov	 DWORD PTR _no$14[ebp], eax
$LN215@lssproto_S:

; 1566 : 					}
; 1567 : 					
; 1568 : 					//old
; 1569 : 					//no = i * 13;
; 1570 : #else
; 1571 : #ifdef _ITEM_PILENUMS
; 1572 : #ifdef _ALCHEMIST //#ifdef _ITEMSET7_TXT
; 1573 : 					no = i * 12;
; 1574 : #else
; 1575 : 
; 1576 : 					no = i * 11;
; 1577 : 
; 1578 : #endif//_ALCHEMIST
; 1579 : #else
; 1580 : 
; 1581 : 					no = i * 10;
; 1582 : 
; 1583 : #endif//_ITEM_PILENUMS
; 1584 : #endif//_PET_ITEM
; 1585 : 					getStringToken(data, '|', no + 1, sizeof(temp) - 1 , temp);

  0231b	8d 85 80 f5 ff
	ff		 lea	 eax, DWORD PTR _temp$13[ebp]
  02321	50		 push	 eax
  02322	68 ff 00 00 00	 push	 255			; 000000ffH
  02327	8b 8d 88 f6 ff
	ff		 mov	 ecx, DWORD PTR _no$14[ebp]
  0232d	83 c1 01	 add	 ecx, 1
  02330	51		 push	 ecx
  02331	6a 7c		 push	 124			; 0000007cH
  02333	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  02336	52		 push	 edx
  02337	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0233c	83 c4 14	 add	 esp, 20			; 00000014H

; 1586 : 					makeStringFromEscaped(temp);

  0233f	8d 85 80 f5 ff
	ff		 lea	 eax, DWORD PTR _temp$13[ebp]
  02345	50		 push	 eax
  02346	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  0234b	83 c4 04	 add	 esp, 4

; 1587 : 					if (strlen(temp) == 0 )

  0234e	8d 85 80 f5 ff
	ff		 lea	 eax, DWORD PTR _temp$13[ebp]
  02354	50		 push	 eax
  02355	e8 00 00 00 00	 call	 _strlen
  0235a	83 c4 04	 add	 esp, 4
  0235d	85 c0		 test	 eax, eax
  0235f	75 18		 jne	 SHORT $LN216@lssproto_S

; 1588 : 					{
; 1589 : 						pc.item[i].useFlag = 0;

  02361	69 85 94 f6 ff
	ff 7c 01 00 00	 imul	 eax, DWORD PTR _i$15[ebp], 380
  0236b	33 c9		 xor	 ecx, ecx
  0236d	66 89 88 a0 01
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A[eax+416], cx

; 1590 : 						continue;

  02374	e9 5f ff ff ff	 jmp	 $LN16@lssproto_S
$LN216@lssproto_S:

; 1591 : 					}
; 1592 : 					pc.item[i].useFlag = 1;

  02379	69 85 94 f6 ff
	ff 7c 01 00 00	 imul	 eax, DWORD PTR _i$15[ebp], 380
  02383	b9 01 00 00 00	 mov	 ecx, 1
  02388	66 89 88 a0 01
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A[eax+416], cx

; 1593 : 					if (strlen(temp) <= ITEM_NAME_LEN)

  0238f	8d 85 80 f5 ff
	ff		 lea	 eax, DWORD PTR _temp$13[ebp]
  02395	50		 push	 eax
  02396	e8 00 00 00 00	 call	 _strlen
  0239b	83 c4 04	 add	 esp, 4
  0239e	83 f8 1c	 cmp	 eax, 28			; 0000001cH
  023a1	77 20		 ja	 SHORT $LN217@lssproto_S

; 1594 : 						strcpy(pc.item[i].name, temp);

  023a3	8d 85 80 f5 ff
	ff		 lea	 eax, DWORD PTR _temp$13[ebp]
  023a9	50		 push	 eax
  023aa	69 8d 94 f6 ff
	ff 7c 01 00 00	 imul	 ecx, DWORD PTR _i$15[ebp], 380
  023b4	81 c1 aa 01 00
	00		 add	 ecx, OFFSET ?pc@@3UPC@@A+426
  023ba	51		 push	 ecx
  023bb	e8 00 00 00 00	 call	 _strcpy
  023c0	83 c4 08	 add	 esp, 8
$LN217@lssproto_S:

; 1595 : 					getStringToken(data, '|', no + 2, sizeof(temp) - 1, temp);

  023c3	8d 85 80 f5 ff
	ff		 lea	 eax, DWORD PTR _temp$13[ebp]
  023c9	50		 push	 eax
  023ca	68 ff 00 00 00	 push	 255			; 000000ffH
  023cf	8b 8d 88 f6 ff
	ff		 mov	 ecx, DWORD PTR _no$14[ebp]
  023d5	83 c1 02	 add	 ecx, 2
  023d8	51		 push	 ecx
  023d9	6a 7c		 push	 124			; 0000007cH
  023db	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  023de	52		 push	 edx
  023df	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  023e4	83 c4 14	 add	 esp, 20			; 00000014H

; 1596 : 					makeStringFromEscaped(temp);

  023e7	8d 85 80 f5 ff
	ff		 lea	 eax, DWORD PTR _temp$13[ebp]
  023ed	50		 push	 eax
  023ee	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  023f3	83 c4 04	 add	 esp, 4

; 1597 : 					if (strlen(temp) <= ITEM_NAME2_LEN)

  023f6	8d 85 80 f5 ff
	ff		 lea	 eax, DWORD PTR _temp$13[ebp]
  023fc	50		 push	 eax
  023fd	e8 00 00 00 00	 call	 _strlen
  02402	83 c4 04	 add	 esp, 4
  02405	83 f8 10	 cmp	 eax, 16			; 00000010H
  02408	77 20		 ja	 SHORT $LN218@lssproto_S

; 1598 : 						strcpy(pc.item[i].name2, temp);

  0240a	8d 85 80 f5 ff
	ff		 lea	 eax, DWORD PTR _temp$13[ebp]
  02410	50		 push	 eax
  02411	69 8d 94 f6 ff
	ff 7c 01 00 00	 imul	 ecx, DWORD PTR _i$15[ebp], 380
  0241b	81 c1 c7 01 00
	00		 add	 ecx, OFFSET ?pc@@3UPC@@A+455
  02421	51		 push	 ecx
  02422	e8 00 00 00 00	 call	 _strcpy
  02427	83 c4 08	 add	 esp, 8
$LN218@lssproto_S:

; 1599 : 					pc.item[i].color = getIntegerToken(data, '|', no + 3);

  0242a	8b 85 88 f6 ff
	ff		 mov	 eax, DWORD PTR _no$14[ebp]
  02430	83 c0 03	 add	 eax, 3
  02433	50		 push	 eax
  02434	6a 7c		 push	 124			; 0000007cH
  02436	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  02439	51		 push	 ecx
  0243a	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0243f	83 c4 0c	 add	 esp, 12			; 0000000cH
  02442	69 95 94 f6 ff
	ff 7c 01 00 00	 imul	 edx, DWORD PTR _i$15[ebp], 380
  0244c	89 82 c4 00 00
	00		 mov	 DWORD PTR ?pc@@3UPC@@A[edx+196], eax

; 1600 : 					if (pc.item[i].color < 0)

  02452	69 85 94 f6 ff
	ff 7c 01 00 00	 imul	 eax, DWORD PTR _i$15[ebp], 380
  0245c	83 b8 c4 00 00
	00 00		 cmp	 DWORD PTR ?pc@@3UPC@@A[eax+196], 0
  02463	7d 14		 jge	 SHORT $LN219@lssproto_S

; 1601 : 						pc.item[i].color = 0;

  02465	69 85 94 f6 ff
	ff 7c 01 00 00	 imul	 eax, DWORD PTR _i$15[ebp], 380
  0246f	c7 80 c4 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A[eax+196], 0
$LN219@lssproto_S:

; 1602 : 					getStringToken(data, '|', no + 4, sizeof(temp) - 1, temp);

  02479	8d 85 80 f5 ff
	ff		 lea	 eax, DWORD PTR _temp$13[ebp]
  0247f	50		 push	 eax
  02480	68 ff 00 00 00	 push	 255			; 000000ffH
  02485	8b 8d 88 f6 ff
	ff		 mov	 ecx, DWORD PTR _no$14[ebp]
  0248b	83 c1 04	 add	 ecx, 4
  0248e	51		 push	 ecx
  0248f	6a 7c		 push	 124			; 0000007cH
  02491	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  02494	52		 push	 edx
  02495	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0249a	83 c4 14	 add	 esp, 20			; 00000014H

; 1603 : 					makeStringFromEscaped(temp);

  0249d	8d 85 80 f5 ff
	ff		 lea	 eax, DWORD PTR _temp$13[ebp]
  024a3	50		 push	 eax
  024a4	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  024a9	83 c4 04	 add	 esp, 4

; 1604 : 					if (strlen(temp) <= ITEM_MEMO_LEN)

  024ac	8d 85 80 f5 ff
	ff		 lea	 eax, DWORD PTR _temp$13[ebp]
  024b2	50		 push	 eax
  024b3	e8 00 00 00 00	 call	 _strlen
  024b8	83 c4 04	 add	 esp, 4
  024bb	83 f8 54	 cmp	 eax, 84			; 00000054H
  024be	77 20		 ja	 SHORT $LN220@lssproto_S

; 1605 : 						strcpy(pc.item[i].memo, temp);

  024c0	8d 85 80 f5 ff
	ff		 lea	 eax, DWORD PTR _temp$13[ebp]
  024c6	50		 push	 eax
  024c7	69 8d 94 f6 ff
	ff 7c 01 00 00	 imul	 ecx, DWORD PTR _i$15[ebp], 380
  024d1	81 c1 d8 01 00
	00		 add	 ecx, OFFSET ?pc@@3UPC@@A+472
  024d7	51		 push	 ecx
  024d8	e8 00 00 00 00	 call	 _strcpy
  024dd	83 c4 08	 add	 esp, 8
$LN220@lssproto_S:

; 1606 : 					pc.item[i].graNo = getIntegerToken(data, '|', no + 5);

  024e0	8b 85 88 f6 ff
	ff		 mov	 eax, DWORD PTR _no$14[ebp]
  024e6	83 c0 05	 add	 eax, 5
  024e9	50		 push	 eax
  024ea	6a 7c		 push	 124			; 0000007cH
  024ec	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  024ef	51		 push	 ecx
  024f0	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  024f5	83 c4 0c	 add	 esp, 12			; 0000000cH
  024f8	69 95 94 f6 ff
	ff 7c 01 00 00	 imul	 edx, DWORD PTR _i$15[ebp], 380
  02502	89 82 c8 00 00
	00		 mov	 DWORD PTR ?pc@@3UPC@@A[edx+200], eax

; 1607 : 					pc.item[i].field = getIntegerToken(data, '|', no + 6);

  02508	8b 85 88 f6 ff
	ff		 mov	 eax, DWORD PTR _no$14[ebp]
  0250e	83 c0 06	 add	 eax, 6
  02511	50		 push	 eax
  02512	6a 7c		 push	 124			; 0000007cH
  02514	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  02517	51		 push	 ecx
  02518	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0251d	83 c4 0c	 add	 esp, 12			; 0000000cH
  02520	69 95 94 f6 ff
	ff 7c 01 00 00	 imul	 edx, DWORD PTR _i$15[ebp], 380
  0252a	66 89 82 a2 01
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A[edx+418], ax

; 1608 : 					pc.item[i].target = getIntegerToken(data, '|', no + 7);

  02531	8b 85 88 f6 ff
	ff		 mov	 eax, DWORD PTR _no$14[ebp]
  02537	83 c0 07	 add	 eax, 7
  0253a	50		 push	 eax
  0253b	6a 7c		 push	 124			; 0000007cH
  0253d	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  02540	51		 push	 ecx
  02541	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  02546	83 c4 0c	 add	 esp, 12			; 0000000cH
  02549	69 95 94 f6 ff
	ff 7c 01 00 00	 imul	 edx, DWORD PTR _i$15[ebp], 380
  02553	66 89 82 a4 01
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A[edx+420], ax

; 1609 : 					if (pc.item[i].target >= 100)

  0255a	69 85 94 f6 ff
	ff 7c 01 00 00	 imul	 eax, DWORD PTR _i$15[ebp], 380
  02564	0f bf 88 a4 01
	00 00		 movsx	 ecx, WORD PTR ?pc@@3UPC@@A[eax+420]
  0256b	83 f9 64	 cmp	 ecx, 100		; 00000064H
  0256e	7c 42		 jl	 SHORT $LN221@lssproto_S

; 1610 : 					{
; 1611 : 						pc.item[i].target %= 100;

  02570	69 85 94 f6 ff
	ff 7c 01 00 00	 imul	 eax, DWORD PTR _i$15[ebp], 380
  0257a	0f bf 80 a4 01
	00 00		 movsx	 eax, WORD PTR ?pc@@3UPC@@A[eax+420]
  02581	99		 cdq
  02582	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  02587	f7 f9		 idiv	 ecx
  02589	69 85 94 f6 ff
	ff 7c 01 00 00	 imul	 eax, DWORD PTR _i$15[ebp], 380
  02593	66 89 90 a4 01
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A[eax+420], dx

; 1612 : 						pc.item[i].deadTargetFlag = 1;

  0259a	69 85 94 f6 ff
	ff 7c 01 00 00	 imul	 eax, DWORD PTR _i$15[ebp], 380
  025a4	b9 01 00 00 00	 mov	 ecx, 1
  025a9	66 89 88 a6 01
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A[eax+422], cx

; 1613 : 					}
; 1614 : 					else

  025b0	eb 13		 jmp	 SHORT $LN222@lssproto_S
$LN221@lssproto_S:

; 1615 : 						pc.item[i].deadTargetFlag = 0;

  025b2	69 85 94 f6 ff
	ff 7c 01 00 00	 imul	 eax, DWORD PTR _i$15[ebp], 380
  025bc	33 c9		 xor	 ecx, ecx
  025be	66 89 88 a6 01
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A[eax+422], cx
$LN222@lssproto_S:

; 1616 : 					pc.item[i].level = getIntegerToken(data, '|', no + 8);

  025c5	8b 85 88 f6 ff
	ff		 mov	 eax, DWORD PTR _no$14[ebp]
  025cb	83 c0 08	 add	 eax, 8
  025ce	50		 push	 eax
  025cf	6a 7c		 push	 124			; 0000007cH
  025d1	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  025d4	51		 push	 ecx
  025d5	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  025da	83 c4 0c	 add	 esp, 12			; 0000000cH
  025dd	69 95 94 f6 ff
	ff 7c 01 00 00	 imul	 edx, DWORD PTR _i$15[ebp], 380
  025e7	89 82 cc 00 00
	00		 mov	 DWORD PTR ?pc@@3UPC@@A[edx+204], eax

; 1617 : 					pc.item[i].sendFlag = getIntegerToken(data, '|', no + 9);

  025ed	8b 85 88 f6 ff
	ff		 mov	 eax, DWORD PTR _no$14[ebp]
  025f3	83 c0 09	 add	 eax, 9
  025f6	50		 push	 eax
  025f7	6a 7c		 push	 124			; 0000007cH
  025f9	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  025fc	51		 push	 ecx
  025fd	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  02602	83 c4 0c	 add	 esp, 12			; 0000000cH
  02605	69 95 94 f6 ff
	ff 7c 01 00 00	 imul	 edx, DWORD PTR _i$15[ebp], 380
  0260f	66 89 82 a8 01
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A[edx+424], ax

; 1618 : 
; 1619 : 					// 显示物品耐久度
; 1620 : 					getStringToken(data, '|', no + 10, sizeof(temp) - 1, temp);

  02616	8d 85 80 f5 ff
	ff		 lea	 eax, DWORD PTR _temp$13[ebp]
  0261c	50		 push	 eax
  0261d	68 ff 00 00 00	 push	 255			; 000000ffH
  02622	8b 8d 88 f6 ff
	ff		 mov	 ecx, DWORD PTR _no$14[ebp]
  02628	83 c1 0a	 add	 ecx, 10			; 0000000aH
  0262b	51		 push	 ecx
  0262c	6a 7c		 push	 124			; 0000007cH
  0262e	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  02631	52		 push	 edx
  02632	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  02637	83 c4 14	 add	 esp, 20			; 00000014H

; 1621 : 					makeStringFromEscaped(temp);

  0263a	8d 85 80 f5 ff
	ff		 lea	 eax, DWORD PTR _temp$13[ebp]
  02640	50		 push	 eax
  02641	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  02646	83 c4 04	 add	 esp, 4

; 1622 : 					if (strlen(temp) <= 16)

  02649	8d 85 80 f5 ff
	ff		 lea	 eax, DWORD PTR _temp$13[ebp]
  0264f	50		 push	 eax
  02650	e8 00 00 00 00	 call	 _strlen
  02655	83 c4 04	 add	 esp, 4
  02658	83 f8 10	 cmp	 eax, 16			; 00000010H
  0265b	77 20		 ja	 SHORT $LN223@lssproto_S

; 1623 : 						strcpy(pc.item[i].damage, temp);

  0265d	8d 85 80 f5 ff
	ff		 lea	 eax, DWORD PTR _temp$13[ebp]
  02663	50		 push	 eax
  02664	69 8d 94 f6 ff
	ff 7c 01 00 00	 imul	 ecx, DWORD PTR _i$15[ebp], 380
  0266e	81 c1 2d 02 00
	00		 add	 ecx, OFFSET ?pc@@3UPC@@A+557
  02674	51		 push	 ecx
  02675	e8 00 00 00 00	 call	 _strcpy
  0267a	83 c4 08	 add	 esp, 8
$LN223@lssproto_S:

; 1624 : #ifdef _ITEM_PILENUMS
; 1625 : 					getStringToken(data, '|', no + 11, sizeof(temp) - 1, temp);

  0267d	8d 85 80 f5 ff
	ff		 lea	 eax, DWORD PTR _temp$13[ebp]
  02683	50		 push	 eax
  02684	68 ff 00 00 00	 push	 255			; 000000ffH
  02689	8b 8d 88 f6 ff
	ff		 mov	 ecx, DWORD PTR _no$14[ebp]
  0268f	83 c1 0b	 add	 ecx, 11			; 0000000bH
  02692	51		 push	 ecx
  02693	6a 7c		 push	 124			; 0000007cH
  02695	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  02698	52		 push	 edx
  02699	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0269e	83 c4 14	 add	 esp, 20			; 00000014H

; 1626 : 					makeStringFromEscaped(temp);

  026a1	8d 85 80 f5 ff
	ff		 lea	 eax, DWORD PTR _temp$13[ebp]
  026a7	50		 push	 eax
  026a8	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  026ad	83 c4 04	 add	 esp, 4

; 1627 : 					pc.item[i].pile = atoi(temp);

  026b0	8b f4		 mov	 esi, esp
  026b2	8d 85 80 f5 ff
	ff		 lea	 eax, DWORD PTR _temp$13[ebp]
  026b8	50		 push	 eax
  026b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  026bf	83 c4 04	 add	 esp, 4
  026c2	3b f4		 cmp	 esi, esp
  026c4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  026c9	69 8d 94 f6 ff
	ff 7c 01 00 00	 imul	 ecx, DWORD PTR _i$15[ebp], 380
  026d3	89 81 d0 00 00
	00		 mov	 DWORD PTR ?pc@@3UPC@@A[ecx+208], eax

; 1628 : #endif
; 1629 : #ifdef _ALCHEMIST //_ITEMSET7_TXT
; 1630 : 					getStringToken(data, '|', no + 12, sizeof(temp) - 1, temp);

  026d9	8d 85 80 f5 ff
	ff		 lea	 eax, DWORD PTR _temp$13[ebp]
  026df	50		 push	 eax
  026e0	68 ff 00 00 00	 push	 255			; 000000ffH
  026e5	8b 8d 88 f6 ff
	ff		 mov	 ecx, DWORD PTR _no$14[ebp]
  026eb	83 c1 0c	 add	 ecx, 12			; 0000000cH
  026ee	51		 push	 ecx
  026ef	6a 7c		 push	 124			; 0000007cH
  026f1	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  026f4	52		 push	 edx
  026f5	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  026fa	83 c4 14	 add	 esp, 20			; 00000014H

; 1631 : 					makeStringFromEscaped(temp);

  026fd	8d 85 80 f5 ff
	ff		 lea	 eax, DWORD PTR _temp$13[ebp]
  02703	50		 push	 eax
  02704	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  02709	83 c4 04	 add	 esp, 4

; 1632 : 					strcpy(pc.item[i].alch, temp);

  0270c	8d 85 80 f5 ff
	ff		 lea	 eax, DWORD PTR _temp$13[ebp]
  02712	50		 push	 eax
  02713	69 8d 94 f6 ff
	ff 7c 01 00 00	 imul	 ecx, DWORD PTR _i$15[ebp], 380
  0271d	81 c1 d4 00 00
	00		 add	 ecx, OFFSET ?pc@@3UPC@@A+212
  02723	51		 push	 ecx
  02724	e8 00 00 00 00	 call	 _strcpy
  02729	83 c4 08	 add	 esp, 8

; 1633 : #endif
; 1634 : #ifdef _PET_ITEM
; 1635 : 					pc.item[i].type = getIntegerToken(data, '|', no + 13);

  0272c	8b 85 88 f6 ff
	ff		 mov	 eax, DWORD PTR _no$14[ebp]
  02732	83 c0 0d	 add	 eax, 13			; 0000000dH
  02735	50		 push	 eax
  02736	6a 7c		 push	 124			; 0000007cH
  02738	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0273b	51		 push	 ecx
  0273c	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  02741	83 c4 0c	 add	 esp, 12			; 0000000cH
  02744	69 95 94 f6 ff
	ff 7c 01 00 00	 imul	 edx, DWORD PTR _i$15[ebp], 380
  0274e	88 82 3d 02 00
	00		 mov	 BYTE PTR ?pc@@3UPC@@A[edx+573], al

; 1636 : #endif
; 1637 : 
; 1638 : 				}

  02754	e9 7f fb ff ff	 jmp	 $LN16@lssproto_S
$LN17@lssproto_S:

; 1639 : 			}
; 1640 : 			break;

  02759	e9 b8 0a 00 00	 jmp	 $LN1@lssproto_S
$LN224@lssproto_S:

; 1641 : 		//接收到的宠物技能
; 1642 : 		case 'W':
; 1643 : 			{
; 1644 : 				int i, no, no2;
; 1645 : 				char temp[256];
; 1646 : 
; 1647 : 				no = data[1] - '0';

  0275e	b8 01 00 00 00	 mov	 eax, 1
  02763	c1 e0 00	 shl	 eax, 0
  02766	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  02769	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  0276d	83 ea 30	 sub	 edx, 48			; 00000030H
  02770	89 95 68 f5 ff
	ff		 mov	 DWORD PTR _no$11[ebp], edx

; 1648 : 				data += 3;

  02776	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  02779	83 c0 03	 add	 eax, 3
  0277c	89 45 0c	 mov	 DWORD PTR _data$[ebp], eax

; 1649 : 				for (i = 0; i < MAX_SKILL; i++)

  0277f	c7 85 74 f5 ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$12[ebp], 0
  02789	eb 0f		 jmp	 SHORT $LN21@lssproto_S
$LN19@lssproto_S:
  0278b	8b 85 74 f5 ff
	ff		 mov	 eax, DWORD PTR _i$12[ebp]
  02791	83 c0 01	 add	 eax, 1
  02794	89 85 74 f5 ff
	ff		 mov	 DWORD PTR _i$12[ebp], eax
$LN21@lssproto_S:
  0279a	83 bd 74 f5 ff
	ff 07		 cmp	 DWORD PTR _i$12[ebp], 7
  027a1	7d 1d		 jge	 SHORT $LN20@lssproto_S

; 1650 : 					petSkill[no][i].useFlag = 0;

  027a3	69 85 68 f5 ff
	ff e6 02 00 00	 imul	 eax, DWORD PTR _no$11[ebp], 742
  027ad	6b 8d 74 f5 ff
	ff 6a		 imul	 ecx, DWORD PTR _i$12[ebp], 106
  027b4	33 d2		 xor	 edx, edx
  027b6	66 89 94 08 00
	00 00 00	 mov	 WORD PTR ?petSkill@@3PAY06UPET_SKILL@@A[eax+ecx], dx
  027be	eb cb		 jmp	 SHORT $LN19@lssproto_S
$LN20@lssproto_S:

; 1651 : 				for (i = 0; i < MAX_SKILL; i++)

  027c0	c7 85 74 f5 ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$12[ebp], 0
  027ca	eb 0f		 jmp	 SHORT $LN24@lssproto_S
$LN22@lssproto_S:
  027cc	8b 85 74 f5 ff
	ff		 mov	 eax, DWORD PTR _i$12[ebp]
  027d2	83 c0 01	 add	 eax, 1
  027d5	89 85 74 f5 ff
	ff		 mov	 DWORD PTR _i$12[ebp], eax
$LN24@lssproto_S:
  027db	83 bd 74 f5 ff
	ff 07		 cmp	 DWORD PTR _i$12[ebp], 7
  027e2	0f 8d 06 02 00
	00		 jge	 $LN23@lssproto_S

; 1652 : 				{
; 1653 : 					no2 = i * 5;

  027e8	6b 85 74 f5 ff
	ff 05		 imul	 eax, DWORD PTR _i$12[ebp], 5
  027ef	89 85 5c f5 ff
	ff		 mov	 DWORD PTR _no2$10[ebp], eax

; 1654 : 					getStringToken(data, '|', no2 + 4, sizeof(temp) - 1, temp);

  027f5	8d 85 54 f4 ff
	ff		 lea	 eax, DWORD PTR _temp$9[ebp]
  027fb	50		 push	 eax
  027fc	68 ff 00 00 00	 push	 255			; 000000ffH
  02801	8b 8d 5c f5 ff
	ff		 mov	 ecx, DWORD PTR _no2$10[ebp]
  02807	83 c1 04	 add	 ecx, 4
  0280a	51		 push	 ecx
  0280b	6a 7c		 push	 124			; 0000007cH
  0280d	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  02810	52		 push	 edx
  02811	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  02816	83 c4 14	 add	 esp, 20			; 00000014H

; 1655 : 					makeStringFromEscaped(temp);

  02819	8d 85 54 f4 ff
	ff		 lea	 eax, DWORD PTR _temp$9[ebp]
  0281f	50		 push	 eax
  02820	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  02825	83 c4 04	 add	 esp, 4

; 1656 : 					if (strlen(temp) == 0)

  02828	8d 85 54 f4 ff
	ff		 lea	 eax, DWORD PTR _temp$9[ebp]
  0282e	50		 push	 eax
  0282f	e8 00 00 00 00	 call	 _strlen
  02834	83 c4 04	 add	 esp, 4
  02837	85 c0		 test	 eax, eax
  02839	75 02		 jne	 SHORT $LN225@lssproto_S

; 1657 : 						continue;

  0283b	eb 8f		 jmp	 SHORT $LN22@lssproto_S
$LN225@lssproto_S:

; 1658 : 					petSkill[no][i].useFlag = 1;

  0283d	69 85 68 f5 ff
	ff e6 02 00 00	 imul	 eax, DWORD PTR _no$11[ebp], 742
  02847	6b 8d 74 f5 ff
	ff 6a		 imul	 ecx, DWORD PTR _i$12[ebp], 106
  0284e	ba 01 00 00 00	 mov	 edx, 1
  02853	66 89 94 08 00
	00 00 00	 mov	 WORD PTR ?petSkill@@3PAY06UPET_SKILL@@A[eax+ecx], dx

; 1659 : 					if (strlen(temp) <= SKILL_NAME_LEN)

  0285b	8d 85 54 f4 ff
	ff		 lea	 eax, DWORD PTR _temp$9[ebp]
  02861	50		 push	 eax
  02862	e8 00 00 00 00	 call	 _strlen
  02867	83 c4 04	 add	 esp, 4
  0286a	83 f8 18	 cmp	 eax, 24			; 00000018H
  0286d	77 2a		 ja	 SHORT $LN226@lssproto_S

; 1660 : 						strcpy(petSkill[no][i].name, temp);

  0286f	8d 85 54 f4 ff
	ff		 lea	 eax, DWORD PTR _temp$9[ebp]
  02875	50		 push	 eax
  02876	69 8d 68 f5 ff
	ff e6 02 00 00	 imul	 ecx, DWORD PTR _no$11[ebp], 742
  02880	6b 95 74 f5 ff
	ff 6a		 imul	 edx, DWORD PTR _i$12[ebp], 106
  02887	8d 84 11 08 00
	00 00		 lea	 eax, DWORD PTR ?petSkill@@3PAY06UPET_SKILL@@A[ecx+edx+8]
  0288e	50		 push	 eax
  0288f	e8 00 00 00 00	 call	 _strcpy
  02894	83 c4 08	 add	 esp, 8

; 1661 : 					else

  02897	eb 26		 jmp	 SHORT $LN227@lssproto_S
$LN226@lssproto_S:

; 1662 : 						strcpy(petSkill[no][i].name, "??? name ???");

  02899	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGCIJCKF@?$DP?$DP?$DP?5name?5?$DP?$DP?$DP?$AA@
  0289e	69 85 68 f5 ff
	ff e6 02 00 00	 imul	 eax, DWORD PTR _no$11[ebp], 742
  028a8	6b 8d 74 f5 ff
	ff 6a		 imul	 ecx, DWORD PTR _i$12[ebp], 106
  028af	8d 94 08 08 00
	00 00		 lea	 edx, DWORD PTR ?petSkill@@3PAY06UPET_SKILL@@A[eax+ecx+8]
  028b6	52		 push	 edx
  028b7	e8 00 00 00 00	 call	 _strcpy
  028bc	83 c4 08	 add	 esp, 8
$LN227@lssproto_S:

; 1663 : 					petSkill[no][i].skillId = getIntegerToken(data, '|', no2 + 1);

  028bf	8b 85 5c f5 ff
	ff		 mov	 eax, DWORD PTR _no2$10[ebp]
  028c5	83 c0 01	 add	 eax, 1
  028c8	50		 push	 eax
  028c9	6a 7c		 push	 124			; 0000007cH
  028cb	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  028ce	51		 push	 ecx
  028cf	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  028d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  028d7	69 95 68 f5 ff
	ff e6 02 00 00	 imul	 edx, DWORD PTR _no$11[ebp], 742
  028e1	6b 8d 74 f5 ff
	ff 6a		 imul	 ecx, DWORD PTR _i$12[ebp], 106
  028e8	66 89 84 0a 02
	00 00 00	 mov	 WORD PTR ?petSkill@@3PAY06UPET_SKILL@@A[edx+ecx+2], ax

; 1664 : 					petSkill[no][i].field = getIntegerToken(data, '|', no2 + 2);

  028f0	8b 85 5c f5 ff
	ff		 mov	 eax, DWORD PTR _no2$10[ebp]
  028f6	83 c0 02	 add	 eax, 2
  028f9	50		 push	 eax
  028fa	6a 7c		 push	 124			; 0000007cH
  028fc	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  028ff	51		 push	 ecx
  02900	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  02905	83 c4 0c	 add	 esp, 12			; 0000000cH
  02908	69 95 68 f5 ff
	ff e6 02 00 00	 imul	 edx, DWORD PTR _no$11[ebp], 742
  02912	6b 8d 74 f5 ff
	ff 6a		 imul	 ecx, DWORD PTR _i$12[ebp], 106
  02919	66 89 84 0a 04
	00 00 00	 mov	 WORD PTR ?petSkill@@3PAY06UPET_SKILL@@A[edx+ecx+4], ax

; 1665 : 					petSkill[no][i].target = getIntegerToken(data, '|', no2 + 3);

  02921	8b 85 5c f5 ff
	ff		 mov	 eax, DWORD PTR _no2$10[ebp]
  02927	83 c0 03	 add	 eax, 3
  0292a	50		 push	 eax
  0292b	6a 7c		 push	 124			; 0000007cH
  0292d	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  02930	51		 push	 ecx
  02931	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  02936	83 c4 0c	 add	 esp, 12			; 0000000cH
  02939	69 95 68 f5 ff
	ff e6 02 00 00	 imul	 edx, DWORD PTR _no$11[ebp], 742
  02943	6b 8d 74 f5 ff
	ff 6a		 imul	 ecx, DWORD PTR _i$12[ebp], 106
  0294a	66 89 84 0a 06
	00 00 00	 mov	 WORD PTR ?petSkill@@3PAY06UPET_SKILL@@A[edx+ecx+6], ax

; 1666 : 					getStringToken(data, '|', no2 + 5, sizeof(temp) - 1, temp);

  02952	8d 85 54 f4 ff
	ff		 lea	 eax, DWORD PTR _temp$9[ebp]
  02958	50		 push	 eax
  02959	68 ff 00 00 00	 push	 255			; 000000ffH
  0295e	8b 8d 5c f5 ff
	ff		 mov	 ecx, DWORD PTR _no2$10[ebp]
  02964	83 c1 05	 add	 ecx, 5
  02967	51		 push	 ecx
  02968	6a 7c		 push	 124			; 0000007cH
  0296a	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  0296d	52		 push	 edx
  0296e	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  02973	83 c4 14	 add	 esp, 20			; 00000014H

; 1667 : 					makeStringFromEscaped(temp);

  02976	8d 85 54 f4 ff
	ff		 lea	 eax, DWORD PTR _temp$9[ebp]
  0297c	50		 push	 eax
  0297d	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  02982	83 c4 04	 add	 esp, 4

; 1668 : 					if (strlen(temp) <= SKILL_MEMO_LEN)

  02985	8d 85 54 f4 ff
	ff		 lea	 eax, DWORD PTR _temp$9[ebp]
  0298b	50		 push	 eax
  0298c	e8 00 00 00 00	 call	 _strlen
  02991	83 c4 04	 add	 esp, 4
  02994	83 f8 48	 cmp	 eax, 72			; 00000048H
  02997	77 2a		 ja	 SHORT $LN228@lssproto_S

; 1669 : 						strcpy(petSkill[no][i].memo, temp);

  02999	8d 85 54 f4 ff
	ff		 lea	 eax, DWORD PTR _temp$9[ebp]
  0299f	50		 push	 eax
  029a0	69 8d 68 f5 ff
	ff e6 02 00 00	 imul	 ecx, DWORD PTR _no$11[ebp], 742
  029aa	6b 95 74 f5 ff
	ff 6a		 imul	 edx, DWORD PTR _i$12[ebp], 106
  029b1	8d 84 11 21 00
	00 00		 lea	 eax, DWORD PTR ?petSkill@@3PAY06UPET_SKILL@@A[ecx+edx+33]
  029b8	50		 push	 eax
  029b9	e8 00 00 00 00	 call	 _strcpy
  029be	83 c4 08	 add	 esp, 8

; 1670 : 					else

  029c1	eb 26		 jmp	 SHORT $LN229@lssproto_S
$LN228@lssproto_S:

; 1671 : 						strcpy(petSkill[no][i].memo, "??? memo ???");

  029c3	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HKHEIDPM@?$DP?$DP?$DP?5memo?5?$DP?$DP?$DP?$AA@
  029c8	69 85 68 f5 ff
	ff e6 02 00 00	 imul	 eax, DWORD PTR _no$11[ebp], 742
  029d2	6b 8d 74 f5 ff
	ff 6a		 imul	 ecx, DWORD PTR _i$12[ebp], 106
  029d9	8d 94 08 21 00
	00 00		 lea	 edx, DWORD PTR ?petSkill@@3PAY06UPET_SKILL@@A[eax+ecx+33]
  029e0	52		 push	 edx
  029e1	e8 00 00 00 00	 call	 _strcpy
  029e6	83 c4 08	 add	 esp, 8
$LN229@lssproto_S:

; 1672 : 				}

  029e9	e9 de fd ff ff	 jmp	 $LN22@lssproto_S
$LN23@lssproto_S:

; 1673 : 			}
; 1674 : 		break;

  029ee	e9 23 08 00 00	 jmp	 $LN1@lssproto_S
$LN230@lssproto_S:

; 1675 : #ifdef _CHAR_PROFESSION			// WON ADD 人物职业
; 1676 : 		case 'S':
; 1677 : 			{
; 1678 : 				char name[CHAR_NAME_LEN + 1];
; 1679 : 				char memo[PROFESSION_MEMO_LEN + 1];
; 1680 : 				int i, count = 0;

  029f3	c7 85 c0 f3 ff
	ff 00 00 00 00	 mov	 DWORD PTR _count$5[ebp], 0

; 1681 : 				
; 1682 : 				data++;

  029fd	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  02a00	83 c0 01	 add	 eax, 1
  02a03	89 45 0c	 mov	 DWORD PTR _data$[ebp], eax

; 1683 : 				for (i = 0; i < MAX_PROFESSION_SKILL; i++)

  02a06	c7 85 cc f3 ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$6[ebp], 0
  02a10	eb 0f		 jmp	 SHORT $LN27@lssproto_S
$LN25@lssproto_S:
  02a12	8b 85 cc f3 ff
	ff		 mov	 eax, DWORD PTR _i$6[ebp]
  02a18	83 c0 01	 add	 eax, 1
  02a1b	89 85 cc f3 ff
	ff		 mov	 DWORD PTR _i$6[ebp], eax
$LN27@lssproto_S:
  02a21	83 bd cc f3 ff
	ff 1a		 cmp	 DWORD PTR _i$6[ebp], 26	; 0000001aH
  02a28	7d 28		 jge	 SHORT $LN26@lssproto_S

; 1684 : 				{
; 1685 : 					profession_skill[i].useFlag = 0;

  02a2a	69 85 cc f3 ff
	ff c0 00 00 00	 imul	 eax, DWORD PTR _i$6[ebp], 192
  02a34	33 c9		 xor	 ecx, ecx
  02a36	66 89 88 00 00
	00 00		 mov	 WORD PTR ?profession_skill@@3PAUPROFESSION_SKILL@@A[eax], cx

; 1686 : 					profession_skill[i].kind = 0;

  02a3d	69 85 cc f3 ff
	ff c0 00 00 00	 imul	 eax, DWORD PTR _i$6[ebp], 192
  02a47	33 c9		 xor	 ecx, ecx
  02a49	66 89 88 06 00
	00 00		 mov	 WORD PTR ?profession_skill@@3PAUPROFESSION_SKILL@@A[eax+6], cx

; 1687 : 				}

  02a50	eb c0		 jmp	 SHORT $LN25@lssproto_S
$LN26@lssproto_S:

; 1688 : 				for (i = 0; i < MAX_PROFESSION_SKILL; i++)

  02a52	c7 85 cc f3 ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$6[ebp], 0
  02a5c	eb 0f		 jmp	 SHORT $LN30@lssproto_S
$LN28@lssproto_S:
  02a5e	8b 85 cc f3 ff
	ff		 mov	 eax, DWORD PTR _i$6[ebp]
  02a64	83 c0 01	 add	 eax, 1
  02a67	89 85 cc f3 ff
	ff		 mov	 DWORD PTR _i$6[ebp], eax
$LN30@lssproto_S:
  02a6d	83 bd cc f3 ff
	ff 1a		 cmp	 DWORD PTR _i$6[ebp], 26	; 0000001aH
  02a74	0f 8d 1c 02 00
	00		 jge	 $LN29@lssproto_S

; 1689 : 				{
; 1690 : 					count = i * 9;

  02a7a	6b 85 cc f3 ff
	ff 09		 imul	 eax, DWORD PTR _i$6[ebp], 9
  02a81	89 85 c0 f3 ff
	ff		 mov	 DWORD PTR _count$5[ebp], eax

; 1691 : 					profession_skill[i].useFlag  =  getIntegerToken(data, S_DELIM, 1 + count);

  02a87	8b 85 c0 f3 ff
	ff		 mov	 eax, DWORD PTR _count$5[ebp]
  02a8d	83 c0 01	 add	 eax, 1
  02a90	50		 push	 eax
  02a91	6a 7c		 push	 124			; 0000007cH
  02a93	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  02a96	51		 push	 ecx
  02a97	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  02a9c	83 c4 0c	 add	 esp, 12			; 0000000cH
  02a9f	69 95 cc f3 ff
	ff c0 00 00 00	 imul	 edx, DWORD PTR _i$6[ebp], 192
  02aa9	66 89 82 00 00
	00 00		 mov	 WORD PTR ?profession_skill@@3PAUPROFESSION_SKILL@@A[edx], ax

; 1692 : 					profession_skill[i].skillId  =  getIntegerToken(data, S_DELIM, 2 + count);

  02ab0	8b 85 c0 f3 ff
	ff		 mov	 eax, DWORD PTR _count$5[ebp]
  02ab6	83 c0 02	 add	 eax, 2
  02ab9	50		 push	 eax
  02aba	6a 7c		 push	 124			; 0000007cH
  02abc	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  02abf	51		 push	 ecx
  02ac0	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  02ac5	83 c4 0c	 add	 esp, 12			; 0000000cH
  02ac8	69 95 cc f3 ff
	ff c0 00 00 00	 imul	 edx, DWORD PTR _i$6[ebp], 192
  02ad2	66 89 82 02 00
	00 00		 mov	 WORD PTR ?profession_skill@@3PAUPROFESSION_SKILL@@A[edx+2], ax

; 1693 : 					profession_skill[i].target   =  getIntegerToken(data, S_DELIM, 3 + count);

  02ad9	8b 85 c0 f3 ff
	ff		 mov	 eax, DWORD PTR _count$5[ebp]
  02adf	83 c0 03	 add	 eax, 3
  02ae2	50		 push	 eax
  02ae3	6a 7c		 push	 124			; 0000007cH
  02ae5	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  02ae8	51		 push	 ecx
  02ae9	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  02aee	83 c4 0c	 add	 esp, 12			; 0000000cH
  02af1	69 95 cc f3 ff
	ff c0 00 00 00	 imul	 edx, DWORD PTR _i$6[ebp], 192
  02afb	66 89 82 04 00
	00 00		 mov	 WORD PTR ?profession_skill@@3PAUPROFESSION_SKILL@@A[edx+4], ax

; 1694 : 					profession_skill[i].kind	 =  getIntegerToken(data, S_DELIM, 4 + count);

  02b02	8b 85 c0 f3 ff
	ff		 mov	 eax, DWORD PTR _count$5[ebp]
  02b08	83 c0 04	 add	 eax, 4
  02b0b	50		 push	 eax
  02b0c	6a 7c		 push	 124			; 0000007cH
  02b0e	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  02b11	51		 push	 ecx
  02b12	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  02b17	83 c4 0c	 add	 esp, 12			; 0000000cH
  02b1a	69 95 cc f3 ff
	ff c0 00 00 00	 imul	 edx, DWORD PTR _i$6[ebp], 192
  02b24	66 89 82 06 00
	00 00		 mov	 WORD PTR ?profession_skill@@3PAUPROFESSION_SKILL@@A[edx+6], ax

; 1695 : 					profession_skill[i].icon	 =  getIntegerToken(data, S_DELIM, 5 + count);

  02b2b	8b 85 c0 f3 ff
	ff		 mov	 eax, DWORD PTR _count$5[ebp]
  02b31	83 c0 05	 add	 eax, 5
  02b34	50		 push	 eax
  02b35	6a 7c		 push	 124			; 0000007cH
  02b37	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  02b3a	51		 push	 ecx
  02b3b	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  02b40	83 c4 0c	 add	 esp, 12			; 0000000cH
  02b43	69 95 cc f3 ff
	ff c0 00 00 00	 imul	 edx, DWORD PTR _i$6[ebp], 192
  02b4d	89 82 b4 00 00
	00		 mov	 DWORD PTR ?profession_skill@@3PAUPROFESSION_SKILL@@A[edx+180], eax

; 1696 : 					profession_skill[i].costmp	 =  getIntegerToken(data, S_DELIM, 6 + count);

  02b53	8b 85 c0 f3 ff
	ff		 mov	 eax, DWORD PTR _count$5[ebp]
  02b59	83 c0 06	 add	 eax, 6
  02b5c	50		 push	 eax
  02b5d	6a 7c		 push	 124			; 0000007cH
  02b5f	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  02b62	51		 push	 ecx
  02b63	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  02b68	83 c4 0c	 add	 esp, 12			; 0000000cH
  02b6b	69 95 cc f3 ff
	ff c0 00 00 00	 imul	 edx, DWORD PTR _i$6[ebp], 192
  02b75	89 82 b8 00 00
	00		 mov	 DWORD PTR ?profession_skill@@3PAUPROFESSION_SKILL@@A[edx+184], eax

; 1697 : 					profession_skill[i].skill_level = getIntegerToken(data, S_DELIM, 7 + count);

  02b7b	8b 85 c0 f3 ff
	ff		 mov	 eax, DWORD PTR _count$5[ebp]
  02b81	83 c0 07	 add	 eax, 7
  02b84	50		 push	 eax
  02b85	6a 7c		 push	 124			; 0000007cH
  02b87	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  02b8a	51		 push	 ecx
  02b8b	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  02b90	83 c4 0c	 add	 esp, 12			; 0000000cH
  02b93	69 95 cc f3 ff
	ff c0 00 00 00	 imul	 edx, DWORD PTR _i$6[ebp], 192
  02b9d	89 82 bc 00 00
	00		 mov	 DWORD PTR ?profession_skill@@3PAUPROFESSION_SKILL@@A[edx+188], eax

; 1698 : 					memset(name, 0, sizeof(name));

  02ba3	6a 11		 push	 17			; 00000011H
  02ba5	6a 00		 push	 0
  02ba7	8d 85 38 f4 ff
	ff		 lea	 eax, DWORD PTR _name$8[ebp]
  02bad	50		 push	 eax
  02bae	e8 00 00 00 00	 call	 _memset
  02bb3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1699 : 					getStringToken(data, S_DELIM, 8 + count, sizeof(name) - 1, name);

  02bb6	8d 85 38 f4 ff
	ff		 lea	 eax, DWORD PTR _name$8[ebp]
  02bbc	50		 push	 eax
  02bbd	6a 10		 push	 16			; 00000010H
  02bbf	8b 8d c0 f3 ff
	ff		 mov	 ecx, DWORD PTR _count$5[ebp]
  02bc5	83 c1 08	 add	 ecx, 8
  02bc8	51		 push	 ecx
  02bc9	6a 7c		 push	 124			; 0000007cH
  02bcb	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  02bce	52		 push	 edx
  02bcf	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  02bd4	83 c4 14	 add	 esp, 20			; 00000014H

; 1700 : 					makeStringFromEscaped(name);

  02bd7	8d 85 38 f4 ff
	ff		 lea	 eax, DWORD PTR _name$8[ebp]
  02bdd	50		 push	 eax
  02bde	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  02be3	83 c4 04	 add	 esp, 4

; 1701 : 					if (strlen(name) <= CHAR_NAME_LEN)

  02be6	8d 85 38 f4 ff
	ff		 lea	 eax, DWORD PTR _name$8[ebp]
  02bec	50		 push	 eax
  02bed	e8 00 00 00 00	 call	 _strlen
  02bf2	83 c4 04	 add	 esp, 4
  02bf5	83 f8 10	 cmp	 eax, 16			; 00000010H
  02bf8	77 20		 ja	 SHORT $LN231@lssproto_S

; 1702 : 						strcpy(profession_skill[i].name, name);

  02bfa	8d 85 38 f4 ff
	ff		 lea	 eax, DWORD PTR _name$8[ebp]
  02c00	50		 push	 eax
  02c01	69 8d cc f3 ff
	ff c0 00 00 00	 imul	 ecx, DWORD PTR _i$6[ebp], 192
  02c0b	81 c1 08 00 00
	00		 add	 ecx, OFFSET ?profession_skill@@3PAUPROFESSION_SKILL@@A+8
  02c11	51		 push	 ecx
  02c12	e8 00 00 00 00	 call	 _strcpy
  02c17	83 c4 08	 add	 esp, 8
$LN231@lssproto_S:

; 1703 : 					memset(memo, 0, sizeof(memo));

  02c1a	6a 55		 push	 85			; 00000055H
  02c1c	6a 00		 push	 0
  02c1e	8d 85 d8 f3 ff
	ff		 lea	 eax, DWORD PTR _memo$7[ebp]
  02c24	50		 push	 eax
  02c25	e8 00 00 00 00	 call	 _memset
  02c2a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1704 : 					getStringToken(data, S_DELIM, 9 + count, sizeof(memo) - 1, memo);

  02c2d	8d 85 d8 f3 ff
	ff		 lea	 eax, DWORD PTR _memo$7[ebp]
  02c33	50		 push	 eax
  02c34	6a 54		 push	 84			; 00000054H
  02c36	8b 8d c0 f3 ff
	ff		 mov	 ecx, DWORD PTR _count$5[ebp]
  02c3c	83 c1 09	 add	 ecx, 9
  02c3f	51		 push	 ecx
  02c40	6a 7c		 push	 124			; 0000007cH
  02c42	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  02c45	52		 push	 edx
  02c46	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  02c4b	83 c4 14	 add	 esp, 20			; 00000014H

; 1705 : 					makeStringFromEscaped(memo);

  02c4e	8d 85 d8 f3 ff
	ff		 lea	 eax, DWORD PTR _memo$7[ebp]
  02c54	50		 push	 eax
  02c55	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  02c5a	83 c4 04	 add	 esp, 4

; 1706 : 					if (strlen(memo) <= PROFESSION_MEMO_LEN)

  02c5d	8d 85 d8 f3 ff
	ff		 lea	 eax, DWORD PTR _memo$7[ebp]
  02c63	50		 push	 eax
  02c64	e8 00 00 00 00	 call	 _strlen
  02c69	83 c4 04	 add	 esp, 4
  02c6c	83 f8 54	 cmp	 eax, 84			; 00000054H
  02c6f	77 20		 ja	 SHORT $LN232@lssproto_S

; 1707 : 						strcpy(profession_skill[i].memo, memo);

  02c71	8d 85 d8 f3 ff
	ff		 lea	 eax, DWORD PTR _memo$7[ebp]
  02c77	50		 push	 eax
  02c78	69 8d cc f3 ff
	ff c0 00 00 00	 imul	 ecx, DWORD PTR _i$6[ebp], 192
  02c82	81 c1 5d 00 00
	00		 add	 ecx, OFFSET ?profession_skill@@3PAUPROFESSION_SKILL@@A+93
  02c88	51		 push	 ecx
  02c89	e8 00 00 00 00	 call	 _strcpy
  02c8e	83 c4 08	 add	 esp, 8
$LN232@lssproto_S:

; 1708 : 				}

  02c91	e9 c8 fd ff ff	 jmp	 $LN28@lssproto_S
$LN29@lssproto_S:

; 1709 : #ifdef _SKILLSORT
; 1710 : 				SortSkill();

  02c96	e8 00 00 00 00	 call	 ?SortSkill@@YAXXZ	; SortSkill

; 1711 : #endif
; 1712 : 			}
; 1713 : 		break;

  02c9b	e9 76 05 00 00	 jmp	 $LN1@lssproto_S
$LN233@lssproto_S:

; 1714 : #endif
; 1715 : #ifdef _PET_ITEM
; 1716 : 		case 'B':
; 1717 : 			{
; 1718 : 				int i, no, nPetIndex;
; 1719 : 				char szData[256];
; 1720 : 
; 1721 : 				nPetIndex = data[1] - '0';

  02ca0	b8 01 00 00 00	 mov	 eax, 1
  02ca5	c1 e0 00	 shl	 eax, 0
  02ca8	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  02cab	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  02caf	83 ea 30	 sub	 edx, 48			; 00000030H
  02cb2	89 95 9c f3 ff
	ff		 mov	 DWORD PTR _nPetIndex$2[ebp], edx

; 1722 : 				data += 2;

  02cb8	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  02cbb	83 c0 02	 add	 eax, 2
  02cbe	89 45 0c	 mov	 DWORD PTR _data$[ebp], eax

; 1723 : 				for (i = 0; i < MAX_PET_ITEM; i++)

  02cc1	c7 85 b4 f3 ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$4[ebp], 0
  02ccb	eb 0f		 jmp	 SHORT $LN33@lssproto_S
$LN31@lssproto_S:
  02ccd	8b 85 b4 f3 ff
	ff		 mov	 eax, DWORD PTR _i$4[ebp]
  02cd3	83 c0 01	 add	 eax, 1
  02cd6	89 85 b4 f3 ff
	ff		 mov	 DWORD PTR _i$4[ebp], eax
$LN33@lssproto_S:
  02cdc	83 bd b4 f3 ff
	ff 07		 cmp	 DWORD PTR _i$4[ebp], 7
  02ce3	0f 8d 16 05 00
	00		 jge	 $LN32@lssproto_S

; 1724 : 				{
; 1725 : 				//	no = i * 13;
; 1726 : 					no = i * 14;	//修复不显示宠物胸甲宠装

  02ce9	6b 85 b4 f3 ff
	ff 0e		 imul	 eax, DWORD PTR _i$4[ebp], 14
  02cf0	89 85 a8 f3 ff
	ff		 mov	 DWORD PTR _no$3[ebp], eax

; 1727 : 					getStringToken(data, '|', no + 1, sizeof(szData) - 1, szData);

  02cf6	8d 85 94 f2 ff
	ff		 lea	 eax, DWORD PTR _szData$1[ebp]
  02cfc	50		 push	 eax
  02cfd	68 ff 00 00 00	 push	 255			; 000000ffH
  02d02	8b 8d a8 f3 ff
	ff		 mov	 ecx, DWORD PTR _no$3[ebp]
  02d08	83 c1 01	 add	 ecx, 1
  02d0b	51		 push	 ecx
  02d0c	6a 7c		 push	 124			; 0000007cH
  02d0e	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  02d11	52		 push	 edx
  02d12	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  02d17	83 c4 14	 add	 esp, 20			; 00000014H

; 1728 : 					makeStringFromEscaped(szData);

  02d1a	8d 85 94 f2 ff
	ff		 lea	 eax, DWORD PTR _szData$1[ebp]
  02d20	50		 push	 eax
  02d21	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  02d26	83 c4 04	 add	 esp, 4

; 1729 : 					if (strlen(szData) == 0)	// 没道具

  02d29	8d 85 94 f2 ff
	ff		 lea	 eax, DWORD PTR _szData$1[ebp]
  02d2f	50		 push	 eax
  02d30	e8 00 00 00 00	 call	 _strlen
  02d35	83 c4 04	 add	 esp, 4
  02d38	85 c0		 test	 eax, eax
  02d3a	75 30		 jne	 SHORT $LN234@lssproto_S

; 1730 : 					{
; 1731 : 						memset(&pet[nPetIndex].item[i], 0, sizeof(pet[nPetIndex].item[i]));

  02d3c	68 7c 01 00 00	 push	 380			; 0000017cH
  02d41	6a 00		 push	 0
  02d43	69 85 9c f3 ff
	ff 20 0b 00 00	 imul	 eax, DWORD PTR _nPetIndex$2[ebp], 2848
  02d4d	69 8d b4 f3 ff
	ff 7c 01 00 00	 imul	 ecx, DWORD PTR _i$4[ebp], 380
  02d57	8d 94 08 7c 00
	00 00		 lea	 edx, DWORD PTR ?pet@@3PAUPET@@A[eax+ecx+124]
  02d5e	52		 push	 edx
  02d5f	e8 00 00 00 00	 call	 _memset
  02d64	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1732 : 						continue;

  02d67	e9 61 ff ff ff	 jmp	 $LN31@lssproto_S
$LN234@lssproto_S:

; 1733 : 					}
; 1734 : 					pet[nPetIndex].item[i].useFlag = 1;

  02d6c	69 85 9c f3 ff
	ff 20 0b 00 00	 imul	 eax, DWORD PTR _nPetIndex$2[ebp], 2848
  02d76	69 8d b4 f3 ff
	ff 7c 01 00 00	 imul	 ecx, DWORD PTR _i$4[ebp], 380
  02d80	ba 01 00 00 00	 mov	 edx, 1
  02d85	66 89 94 08 58
	01 00 00	 mov	 WORD PTR ?pet@@3PAUPET@@A[eax+ecx+344], dx

; 1735 : 					if (strlen(szData) <= ITEM_NAME_LEN)

  02d8d	8d 85 94 f2 ff
	ff		 lea	 eax, DWORD PTR _szData$1[ebp]
  02d93	50		 push	 eax
  02d94	e8 00 00 00 00	 call	 _strlen
  02d99	83 c4 04	 add	 esp, 4
  02d9c	83 f8 1c	 cmp	 eax, 28			; 0000001cH
  02d9f	77 2b		 ja	 SHORT $LN235@lssproto_S

; 1736 : 						strcpy(pet[nPetIndex].item[i].name, szData);

  02da1	8d 85 94 f2 ff
	ff		 lea	 eax, DWORD PTR _szData$1[ebp]
  02da7	50		 push	 eax
  02da8	69 8d 9c f3 ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _nPetIndex$2[ebp], 2848
  02db2	69 95 b4 f3 ff
	ff 7c 01 00 00	 imul	 edx, DWORD PTR _i$4[ebp], 380
  02dbc	8d 84 11 62 01
	00 00		 lea	 eax, DWORD PTR ?pet@@3PAUPET@@A[ecx+edx+354]
  02dc3	50		 push	 eax
  02dc4	e8 00 00 00 00	 call	 _strcpy
  02dc9	83 c4 08	 add	 esp, 8
$LN235@lssproto_S:

; 1737 : 					getStringToken(data, '|', no + 2, sizeof(szData) - 1, szData);

  02dcc	8d 85 94 f2 ff
	ff		 lea	 eax, DWORD PTR _szData$1[ebp]
  02dd2	50		 push	 eax
  02dd3	68 ff 00 00 00	 push	 255			; 000000ffH
  02dd8	8b 8d a8 f3 ff
	ff		 mov	 ecx, DWORD PTR _no$3[ebp]
  02dde	83 c1 02	 add	 ecx, 2
  02de1	51		 push	 ecx
  02de2	6a 7c		 push	 124			; 0000007cH
  02de4	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  02de7	52		 push	 edx
  02de8	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  02ded	83 c4 14	 add	 esp, 20			; 00000014H

; 1738 : 					makeStringFromEscaped(szData);

  02df0	8d 85 94 f2 ff
	ff		 lea	 eax, DWORD PTR _szData$1[ebp]
  02df6	50		 push	 eax
  02df7	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  02dfc	83 c4 04	 add	 esp, 4

; 1739 : 					if (strlen(szData) <= ITEM_NAME2_LEN)

  02dff	8d 85 94 f2 ff
	ff		 lea	 eax, DWORD PTR _szData$1[ebp]
  02e05	50		 push	 eax
  02e06	e8 00 00 00 00	 call	 _strlen
  02e0b	83 c4 04	 add	 esp, 4
  02e0e	83 f8 10	 cmp	 eax, 16			; 00000010H
  02e11	77 2b		 ja	 SHORT $LN236@lssproto_S

; 1740 : 						strcpy(pet[nPetIndex].item[i].name2, szData);

  02e13	8d 85 94 f2 ff
	ff		 lea	 eax, DWORD PTR _szData$1[ebp]
  02e19	50		 push	 eax
  02e1a	69 8d 9c f3 ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _nPetIndex$2[ebp], 2848
  02e24	69 95 b4 f3 ff
	ff 7c 01 00 00	 imul	 edx, DWORD PTR _i$4[ebp], 380
  02e2e	8d 84 11 7f 01
	00 00		 lea	 eax, DWORD PTR ?pet@@3PAUPET@@A[ecx+edx+383]
  02e35	50		 push	 eax
  02e36	e8 00 00 00 00	 call	 _strcpy
  02e3b	83 c4 08	 add	 esp, 8
$LN236@lssproto_S:

; 1741 : 					pet[nPetIndex].item[i].color		= getIntegerToken(data, '|', no + 3);

  02e3e	8b 85 a8 f3 ff
	ff		 mov	 eax, DWORD PTR _no$3[ebp]
  02e44	83 c0 03	 add	 eax, 3
  02e47	50		 push	 eax
  02e48	6a 7c		 push	 124			; 0000007cH
  02e4a	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  02e4d	51		 push	 ecx
  02e4e	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  02e53	83 c4 0c	 add	 esp, 12			; 0000000cH
  02e56	69 95 9c f3 ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _nPetIndex$2[ebp], 2848
  02e60	69 8d b4 f3 ff
	ff 7c 01 00 00	 imul	 ecx, DWORD PTR _i$4[ebp], 380
  02e6a	89 84 0a 7c 00
	00 00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[edx+ecx+124], eax

; 1742 : 					if (pet[nPetIndex].item[i].color < 0)

  02e71	69 85 9c f3 ff
	ff 20 0b 00 00	 imul	 eax, DWORD PTR _nPetIndex$2[ebp], 2848
  02e7b	69 8d b4 f3 ff
	ff 7c 01 00 00	 imul	 ecx, DWORD PTR _i$4[ebp], 380
  02e85	83 bc 08 7c 00
	00 00 00	 cmp	 DWORD PTR ?pet@@3PAUPET@@A[eax+ecx+124], 0
  02e8d	7d 1f		 jge	 SHORT $LN237@lssproto_S

; 1743 : 						pet[nPetIndex].item[i].color			= 0;

  02e8f	69 85 9c f3 ff
	ff 20 0b 00 00	 imul	 eax, DWORD PTR _nPetIndex$2[ebp], 2848
  02e99	69 8d b4 f3 ff
	ff 7c 01 00 00	 imul	 ecx, DWORD PTR _i$4[ebp], 380
  02ea3	c7 84 08 7c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[eax+ecx+124], 0
$LN237@lssproto_S:

; 1744 : 					getStringToken(data, '|', no + 4, sizeof(szData) - 1, szData);

  02eae	8d 85 94 f2 ff
	ff		 lea	 eax, DWORD PTR _szData$1[ebp]
  02eb4	50		 push	 eax
  02eb5	68 ff 00 00 00	 push	 255			; 000000ffH
  02eba	8b 8d a8 f3 ff
	ff		 mov	 ecx, DWORD PTR _no$3[ebp]
  02ec0	83 c1 04	 add	 ecx, 4
  02ec3	51		 push	 ecx
  02ec4	6a 7c		 push	 124			; 0000007cH
  02ec6	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  02ec9	52		 push	 edx
  02eca	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  02ecf	83 c4 14	 add	 esp, 20			; 00000014H

; 1745 : 					makeStringFromEscaped(szData);

  02ed2	8d 85 94 f2 ff
	ff		 lea	 eax, DWORD PTR _szData$1[ebp]
  02ed8	50		 push	 eax
  02ed9	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  02ede	83 c4 04	 add	 esp, 4

; 1746 : 					if (strlen(szData) <= ITEM_MEMO_LEN)

  02ee1	8d 85 94 f2 ff
	ff		 lea	 eax, DWORD PTR _szData$1[ebp]
  02ee7	50		 push	 eax
  02ee8	e8 00 00 00 00	 call	 _strlen
  02eed	83 c4 04	 add	 esp, 4
  02ef0	83 f8 54	 cmp	 eax, 84			; 00000054H
  02ef3	77 2b		 ja	 SHORT $LN238@lssproto_S

; 1747 : 						strcpy(pet[nPetIndex].item[i].memo, szData);

  02ef5	8d 85 94 f2 ff
	ff		 lea	 eax, DWORD PTR _szData$1[ebp]
  02efb	50		 push	 eax
  02efc	69 8d 9c f3 ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _nPetIndex$2[ebp], 2848
  02f06	69 95 b4 f3 ff
	ff 7c 01 00 00	 imul	 edx, DWORD PTR _i$4[ebp], 380
  02f10	8d 84 11 90 01
	00 00		 lea	 eax, DWORD PTR ?pet@@3PAUPET@@A[ecx+edx+400]
  02f17	50		 push	 eax
  02f18	e8 00 00 00 00	 call	 _strcpy
  02f1d	83 c4 08	 add	 esp, 8
$LN238@lssproto_S:

; 1748 : 					pet[nPetIndex].item[i].graNo				= getIntegerToken(data, '|', no + 5);

  02f20	8b 85 a8 f3 ff
	ff		 mov	 eax, DWORD PTR _no$3[ebp]
  02f26	83 c0 05	 add	 eax, 5
  02f29	50		 push	 eax
  02f2a	6a 7c		 push	 124			; 0000007cH
  02f2c	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  02f2f	51		 push	 ecx
  02f30	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  02f35	83 c4 0c	 add	 esp, 12			; 0000000cH
  02f38	69 95 9c f3 ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _nPetIndex$2[ebp], 2848
  02f42	69 8d b4 f3 ff
	ff 7c 01 00 00	 imul	 ecx, DWORD PTR _i$4[ebp], 380
  02f4c	89 84 0a 80 00
	00 00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[edx+ecx+128], eax

; 1749 : 					pet[nPetIndex].item[i].field				= getIntegerToken(data, '|', no + 6);

  02f53	8b 85 a8 f3 ff
	ff		 mov	 eax, DWORD PTR _no$3[ebp]
  02f59	83 c0 06	 add	 eax, 6
  02f5c	50		 push	 eax
  02f5d	6a 7c		 push	 124			; 0000007cH
  02f5f	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  02f62	51		 push	 ecx
  02f63	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  02f68	83 c4 0c	 add	 esp, 12			; 0000000cH
  02f6b	69 95 9c f3 ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _nPetIndex$2[ebp], 2848
  02f75	69 8d b4 f3 ff
	ff 7c 01 00 00	 imul	 ecx, DWORD PTR _i$4[ebp], 380
  02f7f	66 89 84 0a 5a
	01 00 00	 mov	 WORD PTR ?pet@@3PAUPET@@A[edx+ecx+346], ax

; 1750 : 					pet[nPetIndex].item[i].target				= getIntegerToken(data, '|', no + 7);

  02f87	8b 85 a8 f3 ff
	ff		 mov	 eax, DWORD PTR _no$3[ebp]
  02f8d	83 c0 07	 add	 eax, 7
  02f90	50		 push	 eax
  02f91	6a 7c		 push	 124			; 0000007cH
  02f93	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  02f96	51		 push	 ecx
  02f97	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  02f9c	83 c4 0c	 add	 esp, 12			; 0000000cH
  02f9f	69 95 9c f3 ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _nPetIndex$2[ebp], 2848
  02fa9	69 8d b4 f3 ff
	ff 7c 01 00 00	 imul	 ecx, DWORD PTR _i$4[ebp], 380
  02fb3	66 89 84 0a 5c
	01 00 00	 mov	 WORD PTR ?pet@@3PAUPET@@A[edx+ecx+348], ax

; 1751 : 					if (pet[nPetIndex].item[i].target >= 100)

  02fbb	69 85 9c f3 ff
	ff 20 0b 00 00	 imul	 eax, DWORD PTR _nPetIndex$2[ebp], 2848
  02fc5	69 8d b4 f3 ff
	ff 7c 01 00 00	 imul	 ecx, DWORD PTR _i$4[ebp], 380
  02fcf	0f bf 94 08 5c
	01 00 00	 movsx	 edx, WORD PTR ?pet@@3PAUPET@@A[eax+ecx+348]
  02fd7	83 fa 64	 cmp	 edx, 100		; 00000064H
  02fda	7c 63		 jl	 SHORT $LN239@lssproto_S

; 1752 : 					{
; 1753 : 						pet[nPetIndex].item[i].target			%= 100;

  02fdc	69 85 9c f3 ff
	ff 20 0b 00 00	 imul	 eax, DWORD PTR _nPetIndex$2[ebp], 2848
  02fe6	69 8d b4 f3 ff
	ff 7c 01 00 00	 imul	 ecx, DWORD PTR _i$4[ebp], 380
  02ff0	0f bf 84 08 5c
	01 00 00	 movsx	 eax, WORD PTR ?pet@@3PAUPET@@A[eax+ecx+348]
  02ff8	99		 cdq
  02ff9	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  02ffe	f7 f9		 idiv	 ecx
  03000	69 85 b4 f3 ff
	ff 7c 01 00 00	 imul	 eax, DWORD PTR _i$4[ebp], 380
  0300a	69 8d 9c f3 ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _nPetIndex$2[ebp], 2848
  03014	66 89 94 01 5c
	01 00 00	 mov	 WORD PTR ?pet@@3PAUPET@@A[ecx+eax+348], dx

; 1754 : 						pet[nPetIndex].item[i].deadTargetFlag	= 1;

  0301c	69 85 9c f3 ff
	ff 20 0b 00 00	 imul	 eax, DWORD PTR _nPetIndex$2[ebp], 2848
  03026	69 8d b4 f3 ff
	ff 7c 01 00 00	 imul	 ecx, DWORD PTR _i$4[ebp], 380
  03030	ba 01 00 00 00	 mov	 edx, 1
  03035	66 89 94 08 5e
	01 00 00	 mov	 WORD PTR ?pet@@3PAUPET@@A[eax+ecx+350], dx

; 1755 : 					}
; 1756 : 					else

  0303d	eb 1e		 jmp	 SHORT $LN240@lssproto_S
$LN239@lssproto_S:

; 1757 : 						pet[nPetIndex].item[i].deadTargetFlag	= 0;

  0303f	69 85 9c f3 ff
	ff 20 0b 00 00	 imul	 eax, DWORD PTR _nPetIndex$2[ebp], 2848
  03049	69 8d b4 f3 ff
	ff 7c 01 00 00	 imul	 ecx, DWORD PTR _i$4[ebp], 380
  03053	33 d2		 xor	 edx, edx
  03055	66 89 94 08 5e
	01 00 00	 mov	 WORD PTR ?pet@@3PAUPET@@A[eax+ecx+350], dx
$LN240@lssproto_S:

; 1758 : 					pet[nPetIndex].item[i].level				= getIntegerToken(data, '|', no + 8);

  0305d	8b 85 a8 f3 ff
	ff		 mov	 eax, DWORD PTR _no$3[ebp]
  03063	83 c0 08	 add	 eax, 8
  03066	50		 push	 eax
  03067	6a 7c		 push	 124			; 0000007cH
  03069	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0306c	51		 push	 ecx
  0306d	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  03072	83 c4 0c	 add	 esp, 12			; 0000000cH
  03075	69 95 9c f3 ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _nPetIndex$2[ebp], 2848
  0307f	69 8d b4 f3 ff
	ff 7c 01 00 00	 imul	 ecx, DWORD PTR _i$4[ebp], 380
  03089	89 84 0a 84 00
	00 00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[edx+ecx+132], eax

; 1759 : 					pet[nPetIndex].item[i].sendFlag				= getIntegerToken(data, '|', no + 9);

  03090	8b 85 a8 f3 ff
	ff		 mov	 eax, DWORD PTR _no$3[ebp]
  03096	83 c0 09	 add	 eax, 9
  03099	50		 push	 eax
  0309a	6a 7c		 push	 124			; 0000007cH
  0309c	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0309f	51		 push	 ecx
  030a0	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  030a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  030a8	69 95 9c f3 ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _nPetIndex$2[ebp], 2848
  030b2	69 8d b4 f3 ff
	ff 7c 01 00 00	 imul	 ecx, DWORD PTR _i$4[ebp], 380
  030bc	66 89 84 0a 60
	01 00 00	 mov	 WORD PTR ?pet@@3PAUPET@@A[edx+ecx+352], ax

; 1760 : 					
; 1761 : 					// 显示物品耐久度
; 1762 : 					getStringToken(data, '|', no + 10, sizeof(szData) - 1, szData);

  030c4	8d 85 94 f2 ff
	ff		 lea	 eax, DWORD PTR _szData$1[ebp]
  030ca	50		 push	 eax
  030cb	68 ff 00 00 00	 push	 255			; 000000ffH
  030d0	8b 8d a8 f3 ff
	ff		 mov	 ecx, DWORD PTR _no$3[ebp]
  030d6	83 c1 0a	 add	 ecx, 10			; 0000000aH
  030d9	51		 push	 ecx
  030da	6a 7c		 push	 124			; 0000007cH
  030dc	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  030df	52		 push	 edx
  030e0	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  030e5	83 c4 14	 add	 esp, 20			; 00000014H

; 1763 : 					makeStringFromEscaped(szData);

  030e8	8d 85 94 f2 ff
	ff		 lea	 eax, DWORD PTR _szData$1[ebp]
  030ee	50		 push	 eax
  030ef	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  030f4	83 c4 04	 add	 esp, 4

; 1764 : 					if (strlen(szData) <= 16)

  030f7	8d 85 94 f2 ff
	ff		 lea	 eax, DWORD PTR _szData$1[ebp]
  030fd	50		 push	 eax
  030fe	e8 00 00 00 00	 call	 _strlen
  03103	83 c4 04	 add	 esp, 4
  03106	83 f8 10	 cmp	 eax, 16			; 00000010H
  03109	77 2b		 ja	 SHORT $LN241@lssproto_S

; 1765 : 						strcpy(pet[nPetIndex].item[i].damage, szData);

  0310b	8d 85 94 f2 ff
	ff		 lea	 eax, DWORD PTR _szData$1[ebp]
  03111	50		 push	 eax
  03112	69 8d 9c f3 ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _nPetIndex$2[ebp], 2848
  0311c	69 95 b4 f3 ff
	ff 7c 01 00 00	 imul	 edx, DWORD PTR _i$4[ebp], 380
  03126	8d 84 11 e5 01
	00 00		 lea	 eax, DWORD PTR ?pet@@3PAUPET@@A[ecx+edx+485]
  0312d	50		 push	 eax
  0312e	e8 00 00 00 00	 call	 _strcpy
  03133	83 c4 08	 add	 esp, 8
$LN241@lssproto_S:

; 1766 : 					pet[nPetIndex].item[i].pile					= getIntegerToken(data, '|', no + 11);

  03136	8b 85 a8 f3 ff
	ff		 mov	 eax, DWORD PTR _no$3[ebp]
  0313c	83 c0 0b	 add	 eax, 11			; 0000000bH
  0313f	50		 push	 eax
  03140	6a 7c		 push	 124			; 0000007cH
  03142	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  03145	51		 push	 ecx
  03146	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0314b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0314e	69 95 9c f3 ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _nPetIndex$2[ebp], 2848
  03158	69 8d b4 f3 ff
	ff 7c 01 00 00	 imul	 ecx, DWORD PTR _i$4[ebp], 380
  03162	89 84 0a 88 00
	00 00		 mov	 DWORD PTR ?pet@@3PAUPET@@A[edx+ecx+136], eax

; 1767 : 	#ifdef _ALCHEMIST //_ITEMSET7_TXT
; 1768 : 					getStringToken(data, '|', no + 12, sizeof(szData) - 1, szData);

  03169	8d 85 94 f2 ff
	ff		 lea	 eax, DWORD PTR _szData$1[ebp]
  0316f	50		 push	 eax
  03170	68 ff 00 00 00	 push	 255			; 000000ffH
  03175	8b 8d a8 f3 ff
	ff		 mov	 ecx, DWORD PTR _no$3[ebp]
  0317b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0317e	51		 push	 ecx
  0317f	6a 7c		 push	 124			; 0000007cH
  03181	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  03184	52		 push	 edx
  03185	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0318a	83 c4 14	 add	 esp, 20			; 00000014H

; 1769 : 					makeStringFromEscaped(szData);

  0318d	8d 85 94 f2 ff
	ff		 lea	 eax, DWORD PTR _szData$1[ebp]
  03193	50		 push	 eax
  03194	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  03199	83 c4 04	 add	 esp, 4

; 1770 : 					strcpy(pet[nPetIndex].item[i].alch, szData);

  0319c	8d 85 94 f2 ff
	ff		 lea	 eax, DWORD PTR _szData$1[ebp]
  031a2	50		 push	 eax
  031a3	69 8d 9c f3 ff
	ff 20 0b 00 00	 imul	 ecx, DWORD PTR _nPetIndex$2[ebp], 2848
  031ad	69 95 b4 f3 ff
	ff 7c 01 00 00	 imul	 edx, DWORD PTR _i$4[ebp], 380
  031b7	8d 84 11 8c 00
	00 00		 lea	 eax, DWORD PTR ?pet@@3PAUPET@@A[ecx+edx+140]
  031be	50		 push	 eax
  031bf	e8 00 00 00 00	 call	 _strcpy
  031c4	83 c4 08	 add	 esp, 8

; 1771 : 	#endif
; 1772 : 					pet[nPetIndex].item[i].type					= getIntegerToken(data, '|', no + 13);

  031c7	8b 85 a8 f3 ff
	ff		 mov	 eax, DWORD PTR _no$3[ebp]
  031cd	83 c0 0d	 add	 eax, 13			; 0000000dH
  031d0	50		 push	 eax
  031d1	6a 7c		 push	 124			; 0000007cH
  031d3	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  031d6	51		 push	 ecx
  031d7	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  031dc	83 c4 0c	 add	 esp, 12			; 0000000cH
  031df	69 95 9c f3 ff
	ff 20 0b 00 00	 imul	 edx, DWORD PTR _nPetIndex$2[ebp], 2848
  031e9	69 8d b4 f3 ff
	ff 7c 01 00 00	 imul	 ecx, DWORD PTR _i$4[ebp], 380
  031f3	88 84 0a f5 01
	00 00		 mov	 BYTE PTR ?pet@@3PAUPET@@A[edx+ecx+501], al

; 1773 : 					//可拿给宠物装备的道具,就不会是拼图了,以下就免了
; 1774 : 					//if( i == JigsawIdx )
; 1775 : 					//	SetJigsaw( pc.item[i].graNo, pc.item[i].jigsaw );
; 1776 : 				}

  031fa	e9 ce fa ff ff	 jmp	 $LN31@lssproto_S
$LN32@lssproto_S:

; 1777 : 			}
; 1778 : 			break;

  031ff	eb 15		 jmp	 SHORT $LN1@lssproto_S
$LN242@lssproto_S:

; 1779 : #endif
; 1780 : 			case 'V':
; 1781 : 			{
; 1782 : 				extern int itemWndMaxBag;
; 1783 : 				//V|1
; 1784 : 				itemWndMaxBag = getIntegerToken(data, '|', 2);

  03201	6a 02		 push	 2
  03203	6a 7c		 push	 124			; 0000007cH
  03205	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  03208	50		 push	 eax
  03209	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0320e	83 c4 0c	 add	 esp, 12			; 0000000cH
  03211	a3 00 00 00 00	 mov	 DWORD PTR ?itemWndMaxBag@@3HA, eax ; itemWndMaxBag
$LN1@lssproto_S:

; 1785 : 			}
; 1786 : 			break;
; 1787 :     }
; 1788 : } 

  03216	52		 push	 edx
  03217	8b cd		 mov	 ecx, ebp
  03219	50		 push	 eax
  0321a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN259@lssproto_S
  03220	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  03225	58		 pop	 eax
  03226	5a		 pop	 edx
  03227	5f		 pop	 edi
  03228	5e		 pop	 esi
  03229	5b		 pop	 ebx
  0322a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0322d	33 cd		 xor	 ecx, ebp
  0322f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  03234	81 c4 b4 12 00
	00		 add	 esp, 4788		; 000012b4H
  0323a	3b ec		 cmp	 ebp, esp
  0323c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  03241	8b e5		 mov	 esp, ebp
  03243	5d		 pop	 ebp
  03244	c3		 ret	 0
  03245	0f 1f 00	 npad	 3
$LN259@lssproto_S:
  03248	0e 00 00 00	 DD	 14			; 0000000eH
  0324c	00 00 00 00	 DD	 $LN258@lssproto_S
$LN258@lssproto_S:
  03250	bc fe ff ff	 DD	 -324			; fffffebcH
  03254	00 01 00 00	 DD	 256			; 00000100H
  03258	00 00 00 00	 DD	 $LN244@lssproto_S
  0325c	b4 fd ff ff	 DD	 -588			; fffffdb4H
  03260	00 01 00 00	 DD	 256			; 00000100H
  03264	00 00 00 00	 DD	 $LN245@lssproto_S
  03268	88 fc ff ff	 DD	 -888			; fffffc88H
  0326c	00 01 00 00	 DD	 256			; 00000100H
  03270	00 00 00 00	 DD	 $LN246@lssproto_S
  03274	80 fb ff ff	 DD	 -1152			; fffffb80H
  03278	00 01 00 00	 DD	 256			; 00000100H
  0327c	00 00 00 00	 DD	 $LN247@lssproto_S
  03280	78 fa ff ff	 DD	 -1416			; fffffa78H
  03284	00 01 00 00	 DD	 256			; 00000100H
  03288	00 00 00 00	 DD	 $LN248@lssproto_S
  0328c	3c fa ff ff	 DD	 -1476			; fffffa3cH
  03290	02 00 00 00	 DD	 2
  03294	00 00 00 00	 DD	 $LN249@lssproto_S
  03298	28 f9 ff ff	 DD	 -1752			; fffff928H
  0329c	00 01 00 00	 DD	 256			; 00000100H
  032a0	00 00 00 00	 DD	 $LN250@lssproto_S
  032a4	20 f8 ff ff	 DD	 -2016			; fffff820H
  032a8	00 01 00 00	 DD	 256			; 00000100H
  032ac	00 00 00 00	 DD	 $LN251@lssproto_S
  032b0	00 f7 ff ff	 DD	 -2304			; fffff700H
  032b4	00 01 00 00	 DD	 256			; 00000100H
  032b8	00 00 00 00	 DD	 $LN252@lssproto_S
  032bc	80 f5 ff ff	 DD	 -2688			; fffff580H
  032c0	00 01 00 00	 DD	 256			; 00000100H
  032c4	00 00 00 00	 DD	 $LN253@lssproto_S
  032c8	54 f4 ff ff	 DD	 -2988			; fffff454H
  032cc	00 01 00 00	 DD	 256			; 00000100H
  032d0	00 00 00 00	 DD	 $LN254@lssproto_S
  032d4	38 f4 ff ff	 DD	 -3016			; fffff438H
  032d8	11 00 00 00	 DD	 17			; 00000011H
  032dc	00 00 00 00	 DD	 $LN255@lssproto_S
  032e0	d8 f3 ff ff	 DD	 -3112			; fffff3d8H
  032e4	55 00 00 00	 DD	 85			; 00000055H
  032e8	00 00 00 00	 DD	 $LN256@lssproto_S
  032ec	94 f2 ff ff	 DD	 -3436			; fffff294H
  032f0	00 01 00 00	 DD	 256			; 00000100H
  032f4	00 00 00 00	 DD	 $LN257@lssproto_S
$LN257@lssproto_S:
  032f8	73		 DB	 115			; 00000073H
  032f9	7a		 DB	 122			; 0000007aH
  032fa	44		 DB	 68			; 00000044H
  032fb	61		 DB	 97			; 00000061H
  032fc	74		 DB	 116			; 00000074H
  032fd	61		 DB	 97			; 00000061H
  032fe	00		 DB	 0
$LN256@lssproto_S:
  032ff	6d		 DB	 109			; 0000006dH
  03300	65		 DB	 101			; 00000065H
  03301	6d		 DB	 109			; 0000006dH
  03302	6f		 DB	 111			; 0000006fH
  03303	00		 DB	 0
$LN255@lssproto_S:
  03304	6e		 DB	 110			; 0000006eH
  03305	61		 DB	 97			; 00000061H
  03306	6d		 DB	 109			; 0000006dH
  03307	65		 DB	 101			; 00000065H
  03308	00		 DB	 0
$LN254@lssproto_S:
  03309	74		 DB	 116			; 00000074H
  0330a	65		 DB	 101			; 00000065H
  0330b	6d		 DB	 109			; 0000006dH
  0330c	70		 DB	 112			; 00000070H
  0330d	00		 DB	 0
$LN253@lssproto_S:
  0330e	74		 DB	 116			; 00000074H
  0330f	65		 DB	 101			; 00000065H
  03310	6d		 DB	 109			; 0000006dH
  03311	70		 DB	 112			; 00000070H
  03312	00		 DB	 0
$LN252@lssproto_S:
  03313	6e		 DB	 110			; 0000006eH
  03314	61		 DB	 97			; 00000061H
  03315	6d		 DB	 109			; 0000006dH
  03316	65		 DB	 101			; 00000065H
  03317	00		 DB	 0
$LN251@lssproto_S:
  03318	6d		 DB	 109			; 0000006dH
  03319	65		 DB	 101			; 00000065H
  0331a	6d		 DB	 109			; 0000006dH
  0331b	6f		 DB	 111			; 0000006fH
  0331c	00		 DB	 0
$LN250@lssproto_S:
  0331d	6e		 DB	 110			; 0000006eH
  0331e	61		 DB	 97			; 00000061H
  0331f	6d		 DB	 109			; 0000006dH
  03320	65		 DB	 101			; 00000065H
  03321	00		 DB	 0
$LN249@lssproto_S:
  03322	e7		 DB	 -25			; ffffffe7H
  03323	bb		 DB	 -69			; ffffffbbH
  03324	91		 DB	 -111			; ffffff91H
  03325	e5		 DB	 -27			; ffffffe5H
  03326	ae		 DB	 -82			; ffffffaeH
  03327	9a		 DB	 -102			; ffffff9aH
  03328	e6		 DB	 -26			; ffffffe6H
  03329	a0		 DB	 -96			; ffffffa0H
  0332a	87		 DB	 -121			; ffffff87H
  0332b	e5		 DB	 -27			; ffffffe5H
  0332c	bf		 DB	 -65			; ffffffbfH
  0332d	97		 DB	 -105			; ffffff97H
  0332e	00		 DB	 0
$LN248@lssproto_S:
  0332f	66		 DB	 102			; 00000066H
  03330	72		 DB	 114			; 00000072H
  03331	65		 DB	 101			; 00000065H
  03332	65		 DB	 101			; 00000065H
  03333	4e		 DB	 78			; 0000004eH
  03334	61		 DB	 97			; 00000061H
  03335	6d		 DB	 109			; 0000006dH
  03336	65		 DB	 101			; 00000065H
  03337	00		 DB	 0
$LN247@lssproto_S:
  03338	6e		 DB	 110			; 0000006eH
  03339	61		 DB	 97			; 00000061H
  0333a	6d		 DB	 109			; 0000006dH
  0333b	65		 DB	 101			; 00000065H
  0333c	00		 DB	 0
$LN246@lssproto_S:
  0333d	66		 DB	 102			; 00000066H
  0333e	61		 DB	 97			; 00000061H
  0333f	6d		 DB	 109			; 0000006dH
  03340	69		 DB	 105			; 00000069H
  03341	6c		 DB	 108			; 0000006cH
  03342	79		 DB	 121			; 00000079H
  03343	4e		 DB	 78			; 0000004eH
  03344	61		 DB	 97			; 00000061H
  03345	6d		 DB	 109			; 0000006dH
  03346	65		 DB	 101			; 00000065H
  03347	00		 DB	 0
$LN245@lssproto_S:
  03348	66		 DB	 102			; 00000066H
  03349	72		 DB	 114			; 00000072H
  0334a	65		 DB	 101			; 00000065H
  0334b	65		 DB	 101			; 00000065H
  0334c	4e		 DB	 78			; 0000004eH
  0334d	61		 DB	 97			; 00000061H
  0334e	6d		 DB	 109			; 0000006dH
  0334f	65		 DB	 101			; 00000065H
  03350	00		 DB	 0
$LN244@lssproto_S:
  03351	6e		 DB	 110			; 0000006eH
  03352	61		 DB	 97			; 00000061H
  03353	6d		 DB	 109			; 0000006dH
  03354	65		 DB	 101			; 00000065H
  03355	00		 DB	 0
  03356	66 90		 npad	 2
$LN260@lssproto_S:
  03358	00 00 00 00	 DD	 $LN233@lssproto_S
  0335c	00 00 00 00	 DD	 $LN35@lssproto_S
  03360	00 00 00 00	 DD	 $LN39@lssproto_S
  03364	00 00 00 00	 DD	 $LN170@lssproto_S
  03368	00 00 00 00	 DD	 $LN112@lssproto_S
  0336c	00 00 00 00	 DD	 $LN1@lssproto_S
  03370	00 00 00 00	 DD	 $LN1@lssproto_S
  03374	00 00 00 00	 DD	 $LN213@lssproto_S
  03378	00 00 00 00	 DD	 $LN171@lssproto_S
  0337c	00 00 00 00	 DD	 $LN117@lssproto_S
  03380	00 00 00 00	 DD	 $LN1@lssproto_S
  03384	00 00 00 00	 DD	 $LN115@lssproto_S
  03388	00 00 00 00	 DD	 $LN177@lssproto_S
  0338c	00 00 00 00	 DD	 $LN1@lssproto_S
  03390	00 00 00 00	 DD	 $LN41@lssproto_S
  03394	00 00 00 00	 DD	 $LN1@lssproto_S
  03398	00 00 00 00	 DD	 $LN1@lssproto_S
  0339c	00 00 00 00	 DD	 $LN230@lssproto_S
  033a0	00 00 00 00	 DD	 $LN1@lssproto_S
  033a4	00 00 00 00	 DD	 $LN1@lssproto_S
  033a8	00 00 00 00	 DD	 $LN242@lssproto_S
  033ac	00 00 00 00	 DD	 $LN224@lssproto_S
  033b0	00 00 00 00	 DD	 $LN40@lssproto_S
?lssproto_S_recv@@YAXHPAD@Z ENDP			; lssproto_S_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_R_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_R_recv@@YAXHPAD@Z PROC			; lssproto_R_recv, COMDAT

; 4162 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 4163 : }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?lssproto_R_recv@@YAXHPAD@Z ENDP			; lssproto_R_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_CD_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_id$ = -32						; size = 4
_j$ = -20						; size = 4
_i$ = -8						; size = 4
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_CD_recv@@YAXHPAD@Z PROC			; lssproto_CD_recv, COMDAT

; 2509 : void lssproto_CD_recv( int fd, char *data ){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2510 : 	int i, j;
; 2511 : 	int id;
; 2512 : 	if ( logOutFlag )

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  00025	74 05		 je	 SHORT $LN8@lssproto_C

; 2513 : 		return;

  00027	e9 85 00 00 00	 jmp	 $LN1@lssproto_C
$LN8@lssproto_C:

; 2514 : 	for ( i = 1; ; i++ ){

  0002c	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00033	eb 09		 jmp	 SHORT $LN4@lssproto_C
$LN2@lssproto_C:
  00035	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00038	83 c0 01	 add	 eax, 1
  0003b	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@lssproto_C:

; 2515 : //		id = getInteger62Token(data, '|', i );
; 2516 : 		id = getInteger62Token(data, ',', i );

  0003e	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00041	50		 push	 eax
  00042	6a 2c		 push	 44			; 0000002cH
  00044	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ?getInteger62Token@@YAHPADDH@Z ; getInteger62Token
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00050	89 45 e0	 mov	 DWORD PTR _id$[ebp], eax

; 2517 : 		if ( id == -1 )

  00053	83 7d e0 ff	 cmp	 DWORD PTR _id$[ebp], -1
  00057	75 02		 jne	 SHORT $LN9@lssproto_C

; 2518 : 			break;

  00059	eb 56		 jmp	 SHORT $LN1@lssproto_C
$LN9@lssproto_C:

; 2519 : 
; 2520 : 		delCharObj( id );

  0005b	8b 45 e0	 mov	 eax, DWORD PTR _id$[ebp]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ?delCharObj@@YAXH@Z	; delCharObj
  00064	83 c4 04	 add	 esp, 4

; 2521 : 
; 2522 : 		for ( j = 0; j < MAX_PARTY; j++ ){

  00067	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  0006e	eb 09		 jmp	 SHORT $LN7@lssproto_C
$LN5@lssproto_C:
  00070	8b 45 ec	 mov	 eax, DWORD PTR _j$[ebp]
  00073	83 c0 01	 add	 eax, 1
  00076	89 45 ec	 mov	 DWORD PTR _j$[ebp], eax
$LN7@lssproto_C:
  00079	83 7d ec 05	 cmp	 DWORD PTR _j$[ebp], 5
  0007d	7d 30		 jge	 SHORT $LN6@lssproto_C

; 2523 : 			if ( party[j].useFlag != 0 && party[j].id == id ){

  0007f	6b 45 ec 30	 imul	 eax, DWORD PTR _j$[ebp], 48
  00083	0f bf 88 00 00
	00 00		 movsx	 ecx, WORD PTR ?party@@3PAUPARTY@@A[eax]
  0008a	85 c9		 test	 ecx, ecx
  0008c	74 1f		 je	 SHORT $LN10@lssproto_C
  0008e	6b 45 ec 30	 imul	 eax, DWORD PTR _j$[ebp], 48
  00092	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR ?party@@3PAUPARTY@@A[eax+4]
  00098	3b 4d e0	 cmp	 ecx, DWORD PTR _id$[ebp]
  0009b	75 10		 jne	 SHORT $LN10@lssproto_C

; 2524 : 				party[j].ptAct = NULL;

  0009d	6b 45 ec 30	 imul	 eax, DWORD PTR _j$[ebp], 48
  000a1	c7 80 2c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?party@@3PAUPARTY@@A[eax+44], 0

; 2525 : 				break;

  000ab	eb 02		 jmp	 SHORT $LN6@lssproto_C
$LN10@lssproto_C:

; 2526 : 			}
; 2527 : 		}

  000ad	eb c1		 jmp	 SHORT $LN5@lssproto_C
$LN6@lssproto_C:

; 2528 : 	}

  000af	eb 84		 jmp	 SHORT $LN2@lssproto_C
$LN1@lssproto_C:

; 2529 : }

  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi
  000b3	5b		 pop	 ebx
  000b4	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000ba	3b ec		 cmp	 ebp, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
?lssproto_CD_recv@@YAXHPAD@Z ENDP			; lssproto_CD_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_CA_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_ptAct$ = -8404						; size = 4
_szStreetVendorTitle$ = -8392				; size = 21
_effectparam2$ = -8360					; size = 4
_effectparam1$ = -8348					; size = 4
_effectno$ = -8336					; size = 4
_dir$ = -8324						; size = 4
_act$ = -8312						; size = 4
_y$ = -8300						; size = 4
_x$ = -8288						; size = 4
_charindex$ = -8276					; size = 4
_j$ = -8264						; size = 4
_i$ = -8252						; size = 4
_tellflag$ = -8240					; size = 4
_tellCindex$ = -8228					; size = 4
_alreadytellC$ = -8216					; size = 4096
_smalltoken$ = -4112					; size = 2048
_bigtoken$ = -2056					; size = 2048
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_CA_recv@@YAXHPAD@Z PROC			; lssproto_CA_recv, COMDAT

; 2389 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 d8 26 00 00	 mov	 eax, 9944		; 000026d8H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8d bd 28 d9 ff
	ff		 lea	 edi, DWORD PTR [ebp-9944]
  00016	b9 b6 09 00 00	 mov	 ecx, 2486		; 000009b6H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2390 : 	char bigtoken[2048];
; 2391 : 	char smalltoken[2048];
; 2392 : 	int alreadytellC[1024];
; 2393 : 	int tellCindex = 0;

  0002c	c7 85 dc df ff
	ff 00 00 00 00	 mov	 DWORD PTR _tellCindex$[ebp], 0

; 2394 : 	int tellflag;
; 2395 : 	int i, j;
; 2396 : 	int charindex;
; 2397 : 	int x;
; 2398 : 	int y;
; 2399 : 	int act;
; 2400 : 	int dir;
; 2401 : 	int effectno = 0, effectparam1 = 0, effectparam2 = 0;

  00036	c7 85 70 df ff
	ff 00 00 00 00	 mov	 DWORD PTR _effectno$[ebp], 0
  00040	c7 85 64 df ff
	ff 00 00 00 00	 mov	 DWORD PTR _effectparam1$[ebp], 0
  0004a	c7 85 58 df ff
	ff 00 00 00 00	 mov	 DWORD PTR _effectparam2$[ebp], 0

; 2402 : #ifdef _STREET_VENDOR
; 2403 : 	char szStreetVendorTitle[21];
; 2404 : #endif
; 2405 : 	ACTION *ptAct;
; 2406 : 	if ( logOutFlag )

  00054	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  0005b	74 05		 je	 SHORT $LN8@lssproto_C

; 2407 : 		return;

  0005d	e9 ec 04 00 00	 jmp	 $LN1@lssproto_C
$LN8@lssproto_C:

; 2408 : 	if ( encountNowFlag )

  00062	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?encountNowFlag@@3FA ; encountNowFlag
  00069	85 c0		 test	 eax, eax
  0006b	74 05		 je	 SHORT $LN9@lssproto_C

; 2409 : 	{
; 2410 : 		return;

  0006d	e9 dc 04 00 00	 jmp	 $LN1@lssproto_C
$LN9@lssproto_C:

; 2411 : 	}
; 2412 : 
; 2413 : 	for ( i = 0; ; i++ )

  00072	c7 85 c4 df ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  0007c	eb 0f		 jmp	 SHORT $LN4@lssproto_C
$LN2@lssproto_C:
  0007e	8b 85 c4 df ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00084	83 c0 01	 add	 eax, 1
  00087	89 85 c4 df ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN4@lssproto_C:

; 2414 : 	{
; 2415 : 		getStringToken(data, ',', i+1, sizeof(bigtoken ) - 1, bigtoken );

  0008d	8d 85 f8 f7 ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00093	50		 push	 eax
  00094	68 ff 07 00 00	 push	 2047			; 000007ffH
  00099	8b 8d c4 df ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  0009f	83 c1 01	 add	 ecx, 1
  000a2	51		 push	 ecx
  000a3	6a 2c		 push	 44			; 0000002cH
  000a5	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  000a8	52		 push	 edx
  000a9	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  000ae	83 c4 14	 add	 esp, 20			; 00000014H

; 2416 : 		if ( strlen(bigtoken ) == 0 )

  000b1	8d 85 f8 f7 ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _strlen
  000bd	83 c4 04	 add	 esp, 4
  000c0	85 c0		 test	 eax, eax
  000c2	75 05		 jne	 SHORT $LN10@lssproto_C

; 2417 : 			break;

  000c4	e9 85 04 00 00	 jmp	 $LN1@lssproto_C
$LN10@lssproto_C:

; 2418 : 		getStringToken(bigtoken, '|', 1, sizeof(smalltoken) - 1, smalltoken);

  000c9	8d 85 f0 ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  000cf	50		 push	 eax
  000d0	68 ff 07 00 00	 push	 2047			; 000007ffH
  000d5	6a 01		 push	 1
  000d7	6a 7c		 push	 124			; 0000007cH
  000d9	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  000e5	83 c4 14	 add	 esp, 20			; 00000014H

; 2419 : 		charindex = a62toi(smalltoken);

  000e8	8d 85 f0 ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 ?a62toi@@YAHPAD@Z	; a62toi
  000f4	83 c4 04	 add	 esp, 4
  000f7	89 85 ac df ff
	ff		 mov	 DWORD PTR _charindex$[ebp], eax

; 2420 : 		getStringToken(bigtoken, '|', 2, sizeof(smalltoken) - 1, smalltoken);

  000fd	8d 85 f0 ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00103	50		 push	 eax
  00104	68 ff 07 00 00	 push	 2047			; 000007ffH
  00109	6a 02		 push	 2
  0010b	6a 7c		 push	 124			; 0000007cH
  0010d	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00113	51		 push	 ecx
  00114	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00119	83 c4 14	 add	 esp, 20			; 00000014H

; 2421 : 		x = atoi(smalltoken);

  0011c	8b f4		 mov	 esi, esp
  0011e	8d 85 f0 ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00124	50		 push	 eax
  00125	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0012b	83 c4 04	 add	 esp, 4
  0012e	3b f4		 cmp	 esi, esp
  00130	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00135	89 85 a0 df ff
	ff		 mov	 DWORD PTR _x$[ebp], eax

; 2422 : 		getStringToken(bigtoken, '|', 3, sizeof(smalltoken) - 1, smalltoken);

  0013b	8d 85 f0 ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00141	50		 push	 eax
  00142	68 ff 07 00 00	 push	 2047			; 000007ffH
  00147	6a 03		 push	 3
  00149	6a 7c		 push	 124			; 0000007cH
  0014b	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00151	51		 push	 ecx
  00152	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00157	83 c4 14	 add	 esp, 20			; 00000014H

; 2423 : 		y = atoi(smalltoken);

  0015a	8b f4		 mov	 esi, esp
  0015c	8d 85 f0 ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00162	50		 push	 eax
  00163	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00169	83 c4 04	 add	 esp, 4
  0016c	3b f4		 cmp	 esi, esp
  0016e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00173	89 85 94 df ff
	ff		 mov	 DWORD PTR _y$[ebp], eax

; 2424 : 		getStringToken(bigtoken, '|', 4, sizeof(smalltoken) - 1, smalltoken);

  00179	8d 85 f0 ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0017f	50		 push	 eax
  00180	68 ff 07 00 00	 push	 2047			; 000007ffH
  00185	6a 04		 push	 4
  00187	6a 7c		 push	 124			; 0000007cH
  00189	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  0018f	51		 push	 ecx
  00190	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00195	83 c4 14	 add	 esp, 20			; 00000014H

; 2425 : 		act = atoi(smalltoken);

  00198	8b f4		 mov	 esi, esp
  0019a	8d 85 f0 ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  001a0	50		 push	 eax
  001a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  001a7	83 c4 04	 add	 esp, 4
  001aa	3b f4		 cmp	 esi, esp
  001ac	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b1	89 85 88 df ff
	ff		 mov	 DWORD PTR _act$[ebp], eax

; 2426 : 		getStringToken(bigtoken, '|', 5, sizeof(smalltoken) - 1, smalltoken);

  001b7	8d 85 f0 ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  001bd	50		 push	 eax
  001be	68 ff 07 00 00	 push	 2047			; 000007ffH
  001c3	6a 05		 push	 5
  001c5	6a 7c		 push	 124			; 0000007cH
  001c7	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  001cd	51		 push	 ecx
  001ce	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  001d3	83 c4 14	 add	 esp, 20			; 00000014H

; 2427 : 		dir = (atoi(smalltoken)+3)%8;

  001d6	8b f4		 mov	 esi, esp
  001d8	8d 85 f0 ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  001de	50		 push	 eax
  001df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  001e5	83 c4 04	 add	 esp, 4
  001e8	3b f4		 cmp	 esi, esp
  001ea	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ef	83 c0 03	 add	 eax, 3
  001f2	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  001f7	79 05		 jns	 SHORT $LN34@lssproto_C
  001f9	48		 dec	 eax
  001fa	83 c8 f8	 or	 eax, -8			; fffffff8H
  001fd	40		 inc	 eax
$LN34@lssproto_C:
  001fe	89 85 7c df ff
	ff		 mov	 DWORD PTR _dir$[ebp], eax

; 2428 : 		getStringToken(bigtoken, '|', 6, sizeof(smalltoken) - 1, smalltoken);

  00204	8d 85 f0 ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0020a	50		 push	 eax
  0020b	68 ff 07 00 00	 push	 2047			; 000007ffH
  00210	6a 06		 push	 6
  00212	6a 7c		 push	 124			; 0000007cH
  00214	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  0021a	51		 push	 ecx
  0021b	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00220	83 c4 14	 add	 esp, 20			; 00000014H

; 2429 : #ifdef _STREET_VENDOR
; 2430 : 		if (act == 41) strncpy(szStreetVendorTitle,smalltoken,sizeof(szStreetVendorTitle));

  00223	83 bd 88 df ff
	ff 29		 cmp	 DWORD PTR _act$[ebp], 41 ; 00000029H
  0022a	75 24		 jne	 SHORT $LN11@lssproto_C
  0022c	8b f4		 mov	 esi, esp
  0022e	6a 15		 push	 21			; 00000015H
  00230	8d 85 f0 ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00236	50		 push	 eax
  00237	8d 8d 38 df ff
	ff		 lea	 ecx, DWORD PTR _szStreetVendorTitle$[ebp]
  0023d	51		 push	 ecx
  0023e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncpy
  00244	83 c4 0c	 add	 esp, 12			; 0000000cH
  00247	3b f4		 cmp	 esi, esp
  00249	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2431 : 		else

  0024e	eb 51		 jmp	 SHORT $LN12@lssproto_C
$LN11@lssproto_C:

; 2432 : #endif
; 2433 : 		{
; 2434 : 		effectno = atoi(smalltoken);

  00250	8b f4		 mov	 esi, esp
  00252	8d 85 f0 ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00258	50		 push	 eax
  00259	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0025f	83 c4 04	 add	 esp, 4
  00262	3b f4		 cmp	 esi, esp
  00264	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00269	89 85 70 df ff
	ff		 mov	 DWORD PTR _effectno$[ebp], eax

; 2435 : 		effectparam1 = getIntegerToken(bigtoken, '|', 7 );

  0026f	6a 07		 push	 7
  00271	6a 7c		 push	 124			; 0000007cH
  00273	8d 85 f8 f7 ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00279	50		 push	 eax
  0027a	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0027f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00282	89 85 64 df ff
	ff		 mov	 DWORD PTR _effectparam1$[ebp], eax

; 2436 : 		effectparam2 = getIntegerToken(bigtoken, '|', 8 );

  00288	6a 08		 push	 8
  0028a	6a 7c		 push	 124			; 0000007cH
  0028c	8d 85 f8 f7 ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00292	50		 push	 eax
  00293	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00298	83 c4 0c	 add	 esp, 12			; 0000000cH
  0029b	89 85 58 df ff
	ff		 mov	 DWORD PTR _effectparam2$[ebp], eax
$LN12@lssproto_C:

; 2437 : 		}
; 2438 : 
; 2439 : 
; 2440 : 		if ( pc.id == charindex ){

  002a1	a1 08 00 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+8
  002a6	3b 85 ac df ff
	ff		 cmp	 eax, DWORD PTR _charindex$[ebp]
  002ac	0f 85 48 01 00
	00		 jne	 $LN13@lssproto_C

; 2441 : 			if ( pc.ptAct == NULL
; 2442 : 			 || (pc.ptAct != NULL && pc.ptAct->anim_chr_no == 0) )

  002b2	83 3d ec 50 00
	00 00		 cmp	 DWORD PTR ?pc@@3UPC@@A+20716, 0
  002b9	74 17		 je	 SHORT $LN16@lssproto_C
  002bb	83 3d ec 50 00
	00 00		 cmp	 DWORD PTR ?pc@@3UPC@@A+20716, 0
  002c2	74 13		 je	 SHORT $LN14@lssproto_C
  002c4	a1 ec 50 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+20716
  002c9	83 b8 44 01 00
	00 00		 cmp	 DWORD PTR [eax+324], 0
  002d0	75 05		 jne	 SHORT $LN14@lssproto_C
$LN16@lssproto_C:

; 2443 : 			{
; 2444 : // JL 2016.8.25 禁止查询
; 2445 : #if 0
; 2446 : 				if (bNewServer)
; 2447 : 					lssproto_C_send(sockfd, charindex );
; 2448 : 				else
; 2449 : 					old_lssproto_C_send(sockfd, charindex );
; 2450 : #endif
; 2451 : 			}
; 2452 : 			else

  002d2	e9 1e 01 00 00	 jmp	 $LN15@lssproto_C
$LN14@lssproto_C:

; 2453 : 			{
; 2454 : #ifdef _STREET_VENDOR
; 2455 : 				if (act == 41){

  002d7	83 bd 88 df ff
	ff 29		 cmp	 DWORD PTR _act$[ebp], 41 ; 00000029H
  002de	0f 85 d8 00 00
	00		 jne	 $LN17@lssproto_C

; 2456 : 					if (pc.iOnStreetVendor == 1){

  002e4	83 3d b8 a1 00
	00 01		 cmp	 DWORD PTR ?pc@@3UPC@@A+41400, 1
  002eb	0f 85 c9 00 00
	00		 jne	 $LN19@lssproto_C

; 2457 : 						memset(pc.ptAct->szStreetVendorTitle,0,sizeof(pc.ptAct->szStreetVendorTitle));

  002f1	6a 40		 push	 64			; 00000040H
  002f3	6a 00		 push	 0
  002f5	a1 ec 50 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+20716
  002fa	05 e4 01 00 00	 add	 eax, 484		; 000001e4H
  002ff	50		 push	 eax
  00300	e8 00 00 00 00	 call	 _memset
  00305	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2458 : 						strncpy(pc.ptAct->szStreetVendorTitle,szStreetVendorTitle,sizeof(szStreetVendorTitle));

  00308	8b f4		 mov	 esi, esp
  0030a	6a 15		 push	 21			; 00000015H
  0030c	8d 85 38 df ff
	ff		 lea	 eax, DWORD PTR _szStreetVendorTitle$[ebp]
  00312	50		 push	 eax
  00313	8b 0d ec 50 00
	00		 mov	 ecx, DWORD PTR ?pc@@3UPC@@A+20716
  00319	81 c1 e4 01 00
	00		 add	 ecx, 484		; 000001e4H
  0031f	51		 push	 ecx
  00320	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncpy
  00326	83 c4 0c	 add	 esp, 12			; 0000000cH
  00329	3b f4		 cmp	 esi, esp
  0032b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2459 : 						changePcAct( x, y, dir, act, effectno, effectparam1, effectparam2 );

  00330	8b 85 58 df ff
	ff		 mov	 eax, DWORD PTR _effectparam2$[ebp]
  00336	50		 push	 eax
  00337	8b 8d 64 df ff
	ff		 mov	 ecx, DWORD PTR _effectparam1$[ebp]
  0033d	51		 push	 ecx
  0033e	8b 95 70 df ff
	ff		 mov	 edx, DWORD PTR _effectno$[ebp]
  00344	52		 push	 edx
  00345	8b 85 88 df ff
	ff		 mov	 eax, DWORD PTR _act$[ebp]
  0034b	50		 push	 eax
  0034c	8b 8d 7c df ff
	ff		 mov	 ecx, DWORD PTR _dir$[ebp]
  00352	51		 push	 ecx
  00353	8b 95 94 df ff
	ff		 mov	 edx, DWORD PTR _y$[ebp]
  00359	52		 push	 edx
  0035a	8b 85 a0 df ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00360	50		 push	 eax
  00361	e8 00 00 00 00	 call	 ?changePcAct@@YAXHHHHHHH@Z ; changePcAct
  00366	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2460 : #ifdef _STREET_VENDOR_CHANGE_ICON
; 2461 : 						if (bNewServer)

  00369	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bNewServer@@3HA, 0 ; bNewServer
  00370	74 20		 je	 SHORT $LN20@lssproto_C

; 2462 : 							lssproto_AC_send(sockfd,nowGx,nowGy,5);

  00372	6a 05		 push	 5
  00374	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nowGy@@3HA ; nowGy
  00379	50		 push	 eax
  0037a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nowGx@@3HA ; nowGx
  00380	51		 push	 ecx
  00381	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?sockfd@@3IA ; sockfd
  00387	52		 push	 edx
  00388	e8 00 00 00 00	 call	 ?lssproto_AC_send@@YAXHHHH@Z ; lssproto_AC_send
  0038d	83 c4 10	 add	 esp, 16			; 00000010H

; 2463 : 						else

  00390	eb 1e		 jmp	 SHORT $LN21@lssproto_C
$LN20@lssproto_C:

; 2464 : 							old_lssproto_AC_send(sockfd,nowGx,nowGy,5);

  00392	6a 05		 push	 5
  00394	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nowGy@@3HA ; nowGy
  00399	50		 push	 eax
  0039a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nowGx@@3HA ; nowGx
  003a0	51		 push	 ecx
  003a1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?sockfd@@3IA ; sockfd
  003a7	52		 push	 edx
  003a8	e8 00 00 00 00	 call	 ?old_lssproto_AC_send@@YAXHHHH@Z ; old_lssproto_AC_send
  003ad	83 c4 10	 add	 esp, 16			; 00000010H
$LN21@lssproto_C:

; 2465 : 						setPcAction(5);

  003b0	6a 05		 push	 5
  003b2	e8 00 00 00 00	 call	 ?setPcAction@@YAXH@Z	; setPcAction
  003b7	83 c4 04	 add	 esp, 4
$LN19@lssproto_C:

; 2466 : #endif
; 2467 : 					}
; 2468 : 				}
; 2469 : 				else

  003ba	eb 39		 jmp	 SHORT $LN15@lssproto_C
$LN17@lssproto_C:

; 2470 : #endif
; 2471 : 				changePcAct( x, y, dir, act, effectno, effectparam1, effectparam2 );

  003bc	8b 85 58 df ff
	ff		 mov	 eax, DWORD PTR _effectparam2$[ebp]
  003c2	50		 push	 eax
  003c3	8b 8d 64 df ff
	ff		 mov	 ecx, DWORD PTR _effectparam1$[ebp]
  003c9	51		 push	 ecx
  003ca	8b 95 70 df ff
	ff		 mov	 edx, DWORD PTR _effectno$[ebp]
  003d0	52		 push	 edx
  003d1	8b 85 88 df ff
	ff		 mov	 eax, DWORD PTR _act$[ebp]
  003d7	50		 push	 eax
  003d8	8b 8d 7c df ff
	ff		 mov	 ecx, DWORD PTR _dir$[ebp]
  003de	51		 push	 ecx
  003df	8b 95 94 df ff
	ff		 mov	 edx, DWORD PTR _y$[ebp]
  003e5	52		 push	 edx
  003e6	8b 85 a0 df ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  003ec	50		 push	 eax
  003ed	e8 00 00 00 00	 call	 ?changePcAct@@YAXHHHHHHH@Z ; changePcAct
  003f2	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN15@lssproto_C:

; 2472 : 			}
; 2473 : 			continue;

  003f5	e9 84 fc ff ff	 jmp	 $LN2@lssproto_C
$LN13@lssproto_C:

; 2474 : 		}
; 2475 : 
; 2476 : 		ptAct = getCharObjAct( charindex );

  003fa	8b 85 ac df ff
	ff		 mov	 eax, DWORD PTR _charindex$[ebp]
  00400	50		 push	 eax
  00401	e8 00 00 00 00	 call	 ?getCharObjAct@@YAPAUaction@@H@Z ; getCharObjAct
  00406	83 c4 04	 add	 esp, 4
  00409	89 85 2c df ff
	ff		 mov	 DWORD PTR _ptAct$[ebp], eax

; 2477 : 		if ( ptAct == NULL ){

  0040f	83 bd 2c df ff
	ff 00		 cmp	 DWORD PTR _ptAct$[ebp], 0
  00416	0f 85 92 00 00
	00		 jne	 $LN22@lssproto_C

; 2478 : 			tellflag = 0;

  0041c	c7 85 d0 df ff
	ff 00 00 00 00	 mov	 DWORD PTR _tellflag$[ebp], 0

; 2479 : 			for ( j = 0; j < tellCindex; j++ ){

  00426	c7 85 b8 df ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$[ebp], 0
  00430	eb 0f		 jmp	 SHORT $LN7@lssproto_C
$LN5@lssproto_C:
  00432	8b 85 b8 df ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  00438	83 c0 01	 add	 eax, 1
  0043b	89 85 b8 df ff
	ff		 mov	 DWORD PTR _j$[ebp], eax
$LN7@lssproto_C:
  00441	8b 85 b8 df ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  00447	3b 85 dc df ff
	ff		 cmp	 eax, DWORD PTR _tellCindex$[ebp]
  0044d	7d 23		 jge	 SHORT $LN6@lssproto_C

; 2480 : 				if ( alreadytellC[j] == charindex ){

  0044f	8b 85 b8 df ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  00455	8b 8c 85 e8 df
	ff ff		 mov	 ecx, DWORD PTR _alreadytellC$[ebp+eax*4]
  0045c	3b 8d ac df ff
	ff		 cmp	 ecx, DWORD PTR _charindex$[ebp]
  00462	75 0c		 jne	 SHORT $LN24@lssproto_C

; 2481 : 					tellflag = 1;

  00464	c7 85 d0 df ff
	ff 01 00 00 00	 mov	 DWORD PTR _tellflag$[ebp], 1

; 2482 : 					break;

  0046e	eb 02		 jmp	 SHORT $LN6@lssproto_C
$LN24@lssproto_C:

; 2483 : 				}
; 2484 : 			}

  00470	eb c0		 jmp	 SHORT $LN5@lssproto_C
$LN6@lssproto_C:

; 2485 : 			if ( tellflag == 0 && tellCindex < sizeof(alreadytellC) ){

  00472	83 bd d0 df ff
	ff 00		 cmp	 DWORD PTR _tellflag$[ebp], 0
  00479	75 2e		 jne	 SHORT $LN25@lssproto_C
  0047b	81 bd dc df ff
	ff 00 10 00 00	 cmp	 DWORD PTR _tellCindex$[ebp], 4096 ; 00001000H
  00485	73 22		 jae	 SHORT $LN25@lssproto_C

; 2486 : 				alreadytellC[tellCindex] = charindex;

  00487	8b 85 dc df ff
	ff		 mov	 eax, DWORD PTR _tellCindex$[ebp]
  0048d	8b 8d ac df ff
	ff		 mov	 ecx, DWORD PTR _charindex$[ebp]
  00493	89 8c 85 e8 df
	ff ff		 mov	 DWORD PTR _alreadytellC$[ebp+eax*4], ecx

; 2487 : 				tellCindex++;

  0049a	8b 85 dc df ff
	ff		 mov	 eax, DWORD PTR _tellCindex$[ebp]
  004a0	83 c0 01	 add	 eax, 1
  004a3	89 85 dc df ff
	ff		 mov	 DWORD PTR _tellCindex$[ebp], eax
$LN25@lssproto_C:

; 2488 : // JL 2016.8.25 禁止查询
; 2489 : #if 0
; 2490 : 				if (bNewServer)
; 2491 : 					lssproto_C_send(sockfd, charindex);
; 2492 : 				else
; 2493 : 					old_lssproto_C_send(sockfd, charindex);
; 2494 : #endif
; 2495 : 			}
; 2496 : 		}else{

  004a9	e9 9b 00 00 00	 jmp	 $LN23@lssproto_C
$LN22@lssproto_C:

; 2497 : 			ptAct->objIndex = charindex;

  004ae	8b 85 2c df ff
	ff		 mov	 eax, DWORD PTR _ptAct$[ebp]
  004b4	8b 8d ac df ff
	ff		 mov	 ecx, DWORD PTR _charindex$[ebp]
  004ba	89 88 34 02 00
	00		 mov	 DWORD PTR [eax+564], ecx

; 2498 : #ifdef _STREET_VENDOR
; 2499 : 			if (act == 41){

  004c0	83 bd 88 df ff
	ff 29		 cmp	 DWORD PTR _act$[ebp], 41 ; 00000029H
  004c7	75 40		 jne	 SHORT $LN26@lssproto_C

; 2500 : 				memset(ptAct->szStreetVendorTitle,0,sizeof(ptAct->szStreetVendorTitle));

  004c9	6a 40		 push	 64			; 00000040H
  004cb	6a 00		 push	 0
  004cd	8b 85 2c df ff
	ff		 mov	 eax, DWORD PTR _ptAct$[ebp]
  004d3	05 e4 01 00 00	 add	 eax, 484		; 000001e4H
  004d8	50		 push	 eax
  004d9	e8 00 00 00 00	 call	 _memset
  004de	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2501 : 				strncpy(ptAct->szStreetVendorTitle,szStreetVendorTitle,sizeof(szStreetVendorTitle));

  004e1	8b f4		 mov	 esi, esp
  004e3	6a 15		 push	 21			; 00000015H
  004e5	8d 85 38 df ff
	ff		 lea	 eax, DWORD PTR _szStreetVendorTitle$[ebp]
  004eb	50		 push	 eax
  004ec	8b 8d 2c df ff
	ff		 mov	 ecx, DWORD PTR _ptAct$[ebp]
  004f2	81 c1 e4 01 00
	00		 add	 ecx, 484		; 000001e4H
  004f8	51		 push	 ecx
  004f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncpy
  004ff	83 c4 0c	 add	 esp, 12			; 0000000cH
  00502	3b f4		 cmp	 esi, esp
  00504	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN26@lssproto_C:

; 2502 : 			}
; 2503 : #endif
; 2504 : 			changeCharAct( ptAct, x, y, dir, act, effectno, effectparam1, effectparam2 );

  00509	8b 85 58 df ff
	ff		 mov	 eax, DWORD PTR _effectparam2$[ebp]
  0050f	50		 push	 eax
  00510	8b 8d 64 df ff
	ff		 mov	 ecx, DWORD PTR _effectparam1$[ebp]
  00516	51		 push	 ecx
  00517	8b 95 70 df ff
	ff		 mov	 edx, DWORD PTR _effectno$[ebp]
  0051d	52		 push	 edx
  0051e	8b 85 88 df ff
	ff		 mov	 eax, DWORD PTR _act$[ebp]
  00524	50		 push	 eax
  00525	8b 8d 7c df ff
	ff		 mov	 ecx, DWORD PTR _dir$[ebp]
  0052b	51		 push	 ecx
  0052c	8b 95 94 df ff
	ff		 mov	 edx, DWORD PTR _y$[ebp]
  00532	52		 push	 edx
  00533	8b 85 a0 df ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00539	50		 push	 eax
  0053a	8b 8d 2c df ff
	ff		 mov	 ecx, DWORD PTR _ptAct$[ebp]
  00540	51		 push	 ecx
  00541	e8 00 00 00 00	 call	 ?changeCharAct@@YAXPAUaction@@HHHHHHH@Z ; changeCharAct
  00546	83 c4 20	 add	 esp, 32			; 00000020H
$LN23@lssproto_C:

; 2505 : 		}
; 2506 : 	}

  00549	e9 30 fb ff ff	 jmp	 $LN2@lssproto_C
$LN1@lssproto_C:

; 2507 : }

  0054e	52		 push	 edx
  0054f	8b cd		 mov	 ecx, ebp
  00551	50		 push	 eax
  00552	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN33@lssproto_C
  00558	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0055d	58		 pop	 eax
  0055e	5a		 pop	 edx
  0055f	5f		 pop	 edi
  00560	5e		 pop	 esi
  00561	5b		 pop	 ebx
  00562	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00565	33 cd		 xor	 ecx, ebp
  00567	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0056c	81 c4 d8 26 00
	00		 add	 esp, 9944		; 000026d8H
  00572	3b ec		 cmp	 ebp, esp
  00574	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00579	8b e5		 mov	 esp, ebp
  0057b	5d		 pop	 ebp
  0057c	c3		 ret	 0
  0057d	0f 1f 00	 npad	 3
$LN33@lssproto_C:
  00580	04 00 00 00	 DD	 4
  00584	00 00 00 00	 DD	 $LN32@lssproto_C
$LN32@lssproto_C:
  00588	f8 f7 ff ff	 DD	 -2056			; fffff7f8H
  0058c	00 08 00 00	 DD	 2048			; 00000800H
  00590	00 00 00 00	 DD	 $LN28@lssproto_C
  00594	f0 ef ff ff	 DD	 -4112			; ffffeff0H
  00598	00 08 00 00	 DD	 2048			; 00000800H
  0059c	00 00 00 00	 DD	 $LN29@lssproto_C
  005a0	e8 df ff ff	 DD	 -8216			; ffffdfe8H
  005a4	00 10 00 00	 DD	 4096			; 00001000H
  005a8	00 00 00 00	 DD	 $LN30@lssproto_C
  005ac	38 df ff ff	 DD	 -8392			; ffffdf38H
  005b0	15 00 00 00	 DD	 21			; 00000015H
  005b4	00 00 00 00	 DD	 $LN31@lssproto_C
$LN31@lssproto_C:
  005b8	73		 DB	 115			; 00000073H
  005b9	7a		 DB	 122			; 0000007aH
  005ba	53		 DB	 83			; 00000053H
  005bb	74		 DB	 116			; 00000074H
  005bc	72		 DB	 114			; 00000072H
  005bd	65		 DB	 101			; 00000065H
  005be	65		 DB	 101			; 00000065H
  005bf	74		 DB	 116			; 00000074H
  005c0	56		 DB	 86			; 00000056H
  005c1	65		 DB	 101			; 00000065H
  005c2	6e		 DB	 110			; 0000006eH
  005c3	64		 DB	 100			; 00000064H
  005c4	6f		 DB	 111			; 0000006fH
  005c5	72		 DB	 114			; 00000072H
  005c6	54		 DB	 84			; 00000054H
  005c7	69		 DB	 105			; 00000069H
  005c8	74		 DB	 116			; 00000074H
  005c9	6c		 DB	 108			; 0000006cH
  005ca	65		 DB	 101			; 00000065H
  005cb	00		 DB	 0
$LN30@lssproto_C:
  005cc	61		 DB	 97			; 00000061H
  005cd	6c		 DB	 108			; 0000006cH
  005ce	72		 DB	 114			; 00000072H
  005cf	65		 DB	 101			; 00000065H
  005d0	61		 DB	 97			; 00000061H
  005d1	64		 DB	 100			; 00000064H
  005d2	79		 DB	 121			; 00000079H
  005d3	74		 DB	 116			; 00000074H
  005d4	65		 DB	 101			; 00000065H
  005d5	6c		 DB	 108			; 0000006cH
  005d6	6c		 DB	 108			; 0000006cH
  005d7	43		 DB	 67			; 00000043H
  005d8	00		 DB	 0
$LN29@lssproto_C:
  005d9	73		 DB	 115			; 00000073H
  005da	6d		 DB	 109			; 0000006dH
  005db	61		 DB	 97			; 00000061H
  005dc	6c		 DB	 108			; 0000006cH
  005dd	6c		 DB	 108			; 0000006cH
  005de	74		 DB	 116			; 00000074H
  005df	6f		 DB	 111			; 0000006fH
  005e0	6b		 DB	 107			; 0000006bH
  005e1	65		 DB	 101			; 00000065H
  005e2	6e		 DB	 110			; 0000006eH
  005e3	00		 DB	 0
$LN28@lssproto_C:
  005e4	62		 DB	 98			; 00000062H
  005e5	69		 DB	 105			; 00000069H
  005e6	67		 DB	 103			; 00000067H
  005e7	74		 DB	 116			; 00000074H
  005e8	6f		 DB	 111			; 0000006fH
  005e9	6b		 DB	 107			; 0000006bH
  005ea	65		 DB	 101			; 00000065H
  005eb	6e		 DB	 110			; 0000006eH
  005ec	00		 DB	 0
?lssproto_CA_recv@@YAXHPAD@Z ENDP			; lssproto_CA_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_C_recv@@YAXHPAD@Z
_TEXT	SEGMENT
tv87 = -14164						; size = 4
_ptAct$ = -12620					; size = 4
_noticeNo$ = -12608					; size = 4
_picture$ = -12593					; size = 1
_herofloor$ = -12584					; size = 4
_profession_skill_point$ = -12572			; size = 4
_profession_level$ = -12560				; size = 4
_profession_class$ = -12548				; size = 4
_petlevel$ = -12536					; size = 4
_petname$ = -12524					; size = 1024
_fmname$ = -11492					; size = 2048
_info$ = -9436						; size = 1024
_freeName$ = -8404					; size = 2048
_name$ = -6348						; size = 2048
_smalltoken$ = -4292					; size = 2048
_bigtoken$ = -2236					; size = 2048
_charNameColor$ = -180					; size = 4
_charType$ = -168					; size = 4
_money$ = -156						; size = 4
_classNo$ = -144					; size = 4
_height$ = -132						; size = 4
_walkable$ = -120					; size = 4
_nameColor$ = -108					; size = 4
_level$ = -96						; size = 4
_graNo$ = -84						; size = 4
_dir$ = -72						; size = 4
_y$ = -60						; size = 4
_x$ = -48						; size = 4
_id$ = -36						; size = 4
_j$ = -24						; size = 4
_i$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_C_recv@@YAXHPAD@Z PROC			; lssproto_C_recv, COMDAT

; 2004 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 54 37 00 00	 mov	 eax, 14164		; 00003754H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8d bd ac c8 ff
	ff		 lea	 edi, DWORD PTR [ebp-14164]
  00016	b9 d5 0d 00 00	 mov	 ecx, 3541		; 00000dd5H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2005 : 	int i, j, id, x, y, dir, graNo, level, nameColor, walkable, height, classNo, money, charType, charNameColor;
; 2006 : 	char bigtoken[2048], smalltoken[2048], name[2048], freeName[2048], info[1024], fmname[2048], petname[1024];
; 2007 : 	int petlevel;
; 2008 : #ifdef _CHAR_PROFESSION			// WON ADD 人物职业
; 2009 : 	int profession_class, profession_level, profession_skill_point;
; 2010 : #endif
; 2011 : #ifdef _ALLDOMAN // (不可开) Syu ADD 排行榜NPC
; 2012 : 	int herofloor;
; 2013 : #endif
; 2014 : #ifdef _NPC_PICTURE
; 2015 : 	char picture;
; 2016 : #endif
; 2017 : #ifdef _NB_文字称号
; 2018 : 	char nb_name[64];
; 2019 : 	int nb_namecolor;
; 2020 : #endif
; 2021 : #ifdef _NB_任务指引
; 2022 : 	int noticeNo;
; 2023 : #endif
; 2024 : 	ACTION *ptAct;
; 2025 : 
; 2026 : 	if (logOutFlag)

  0002c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  00033	74 05		 je	 SHORT $LN13@lssproto_C

; 2027 : 		return;

  00035	e9 ef 0c 00 00	 jmp	 $LN1@lssproto_C
$LN13@lssproto_C:

; 2028 : 	if (encountNowFlag)

  0003a	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?encountNowFlag@@3FA ; encountNowFlag
  00041	85 c0		 test	 eax, eax
  00043	74 05		 je	 SHORT $LN14@lssproto_C

; 2029 : 		return;

  00045	e9 df 0c 00 00	 jmp	 $LN1@lssproto_C
$LN14@lssproto_C:

; 2030 : 	for (i = 0; ; i++)

  0004a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00051	eb 09		 jmp	 SHORT $LN4@lssproto_C
$LN2@lssproto_C:
  00053	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00056	83 c0 01	 add	 eax, 1
  00059	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@lssproto_C:

; 2031 : 	{
; 2032 : 		getStringToken(data, ',', i + 1, sizeof(bigtoken) - 1, bigtoken);

  0005c	8d 85 44 f7 ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00062	50		 push	 eax
  00063	68 ff 07 00 00	 push	 2047			; 000007ffH
  00068	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0006b	83 c1 01	 add	 ecx, 1
  0006e	51		 push	 ecx
  0006f	6a 2c		 push	 44			; 0000002cH
  00071	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  00074	52		 push	 edx
  00075	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0007a	83 c4 14	 add	 esp, 20			; 00000014H

; 2033 : 		if (strlen(bigtoken) == 0)

  0007d	8d 85 44 f7 ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 _strlen
  00089	83 c4 04	 add	 esp, 4
  0008c	85 c0		 test	 eax, eax
  0008e	75 05		 jne	 SHORT $LN15@lssproto_C

; 2034 : 			break;

  00090	e9 94 0c 00 00	 jmp	 $LN1@lssproto_C
$LN15@lssproto_C:

; 2035 : #ifdef _OBJSEND_C
; 2036 : 		getStringToken(bigtoken, '|', 1, sizeof(smalltoken) - 1, smalltoken);

  00095	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0009b	50		 push	 eax
  0009c	68 ff 07 00 00	 push	 2047			; 000007ffH
  000a1	6a 01		 push	 1
  000a3	6a 7c		 push	 124			; 0000007cH
  000a5	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  000ab	51		 push	 ecx
  000ac	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  000b1	83 c4 14	 add	 esp, 20			; 00000014H

; 2037 : 		if (strlen(smalltoken) == 0)

  000b4	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _strlen
  000c0	83 c4 04	 add	 esp, 4
  000c3	85 c0		 test	 eax, eax
  000c5	75 05		 jne	 SHORT $LN16@lssproto_C

; 2038 : 			return;

  000c7	e9 5d 0c 00 00	 jmp	 $LN1@lssproto_C
$LN16@lssproto_C:

; 2039 : 		switch (atoi(smalltoken))

  000cc	8b f4		 mov	 esi, esp
  000ce	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  000d4	50		 push	 eax
  000d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  000db	83 c4 04	 add	 esp, 4
  000de	3b f4		 cmp	 esi, esp
  000e0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e5	89 85 ac c8 ff
	ff		 mov	 DWORD PTR tv87[ebp], eax
  000eb	8b 8d ac c8 ff
	ff		 mov	 ecx, DWORD PTR tv87[ebp]
  000f1	83 e9 01	 sub	 ecx, 1
  000f4	89 8d ac c8 ff
	ff		 mov	 DWORD PTR tv87[ebp], ecx
  000fa	83 bd ac c8 ff
	ff 03		 cmp	 DWORD PTR tv87[ebp], 3
  00101	0f 87 1d 0c 00
	00		 ja	 $LN5@lssproto_C
  00107	8b 95 ac c8 ff
	ff		 mov	 edx, DWORD PTR tv87[ebp]
  0010d	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN49@lssproto_C[edx*4]
$LN17@lssproto_C:

; 2040 : 		{
; 2041 : 		case 1://OBJTYPE_CHARA
; 2042 : 			//printf("bigtoken %s\n",bigtoken);
; 2043 : 			charType = getIntegerToken(bigtoken, '|', 2);

  00114	6a 02		 push	 2
  00116	6a 7c		 push	 124			; 0000007cH
  00118	8d 85 44 f7 ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00124	83 c4 0c	 add	 esp, 12			; 0000000cH
  00127	89 85 58 ff ff
	ff		 mov	 DWORD PTR _charType$[ebp], eax

; 2044 : 			getStringToken(bigtoken, '|', 3, sizeof(smalltoken) - 1, smalltoken);

  0012d	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00133	50		 push	 eax
  00134	68 ff 07 00 00	 push	 2047			; 000007ffH
  00139	6a 03		 push	 3
  0013b	6a 7c		 push	 124			; 0000007cH
  0013d	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00143	51		 push	 ecx
  00144	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00149	83 c4 14	 add	 esp, 20			; 00000014H

; 2045 : 			id = a62toi(smalltoken);

  0014c	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00152	50		 push	 eax
  00153	e8 00 00 00 00	 call	 ?a62toi@@YAHPAD@Z	; a62toi
  00158	83 c4 04	 add	 esp, 4
  0015b	89 45 dc	 mov	 DWORD PTR _id$[ebp], eax

; 2046 : 			getStringToken(bigtoken, '|', 4, sizeof(smalltoken) - 1, smalltoken);

  0015e	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00164	50		 push	 eax
  00165	68 ff 07 00 00	 push	 2047			; 000007ffH
  0016a	6a 04		 push	 4
  0016c	6a 7c		 push	 124			; 0000007cH
  0016e	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00174	51		 push	 ecx
  00175	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0017a	83 c4 14	 add	 esp, 20			; 00000014H

; 2047 : 			x = atoi(smalltoken);

  0017d	8b f4		 mov	 esi, esp
  0017f	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00185	50		 push	 eax
  00186	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0018c	83 c4 04	 add	 esp, 4
  0018f	3b f4		 cmp	 esi, esp
  00191	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00196	89 45 d0	 mov	 DWORD PTR _x$[ebp], eax

; 2048 : 			getStringToken(bigtoken, '|', 5, sizeof(smalltoken) - 1, smalltoken);

  00199	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0019f	50		 push	 eax
  001a0	68 ff 07 00 00	 push	 2047			; 000007ffH
  001a5	6a 05		 push	 5
  001a7	6a 7c		 push	 124			; 0000007cH
  001a9	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  001af	51		 push	 ecx
  001b0	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  001b5	83 c4 14	 add	 esp, 20			; 00000014H

; 2049 : 			y = atoi(smalltoken);

  001b8	8b f4		 mov	 esi, esp
  001ba	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  001c0	50		 push	 eax
  001c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  001c7	83 c4 04	 add	 esp, 4
  001ca	3b f4		 cmp	 esi, esp
  001cc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001d1	89 45 c4	 mov	 DWORD PTR _y$[ebp], eax

; 2050 : 			getStringToken(bigtoken, '|', 6, sizeof(smalltoken) - 1, smalltoken);

  001d4	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  001da	50		 push	 eax
  001db	68 ff 07 00 00	 push	 2047			; 000007ffH
  001e0	6a 06		 push	 6
  001e2	6a 7c		 push	 124			; 0000007cH
  001e4	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  001ea	51		 push	 ecx
  001eb	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  001f0	83 c4 14	 add	 esp, 20			; 00000014H

; 2051 : 			dir = (atoi(smalltoken) + 3) % 8;

  001f3	8b f4		 mov	 esi, esp
  001f5	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  001fb	50		 push	 eax
  001fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00202	83 c4 04	 add	 esp, 4
  00205	3b f4		 cmp	 esi, esp
  00207	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0020c	83 c0 03	 add	 eax, 3
  0020f	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00214	79 05		 jns	 SHORT $LN47@lssproto_C
  00216	48		 dec	 eax
  00217	83 c8 f8	 or	 eax, -8			; fffffff8H
  0021a	40		 inc	 eax
$LN47@lssproto_C:
  0021b	89 45 b8	 mov	 DWORD PTR _dir$[ebp], eax

; 2052 : 			getStringToken(bigtoken, '|', 7, sizeof(smalltoken) - 1, smalltoken);

  0021e	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00224	50		 push	 eax
  00225	68 ff 07 00 00	 push	 2047			; 000007ffH
  0022a	6a 07		 push	 7
  0022c	6a 7c		 push	 124			; 0000007cH
  0022e	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00234	51		 push	 ecx
  00235	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0023a	83 c4 14	 add	 esp, 20			; 00000014H

; 2053 : 			graNo = atoi(smalltoken);

  0023d	8b f4		 mov	 esi, esp
  0023f	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00245	50		 push	 eax
  00246	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0024c	83 c4 04	 add	 esp, 4
  0024f	3b f4		 cmp	 esi, esp
  00251	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00256	89 45 ac	 mov	 DWORD PTR _graNo$[ebp], eax

; 2054 : 			getStringToken(bigtoken, '|', 8, sizeof(smalltoken) - 1,smalltoken);

  00259	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0025f	50		 push	 eax
  00260	68 ff 07 00 00	 push	 2047			; 000007ffH
  00265	6a 08		 push	 8
  00267	6a 7c		 push	 124			; 0000007cH
  00269	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  0026f	51		 push	 ecx
  00270	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00275	83 c4 14	 add	 esp, 20			; 00000014H

; 2055 : 			level = atoi(smalltoken);

  00278	8b f4		 mov	 esi, esp
  0027a	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00280	50		 push	 eax
  00281	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00287	83 c4 04	 add	 esp, 4
  0028a	3b f4		 cmp	 esi, esp
  0028c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00291	89 45 a0	 mov	 DWORD PTR _level$[ebp], eax

; 2056 : 			nameColor = getIntegerToken(bigtoken, '|', 9);

  00294	6a 09		 push	 9
  00296	6a 7c		 push	 124			; 0000007cH
  00298	8d 85 44 f7 ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  0029e	50		 push	 eax
  0029f	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  002a4	83 c4 0c	 add	 esp, 12			; 0000000cH
  002a7	89 45 94	 mov	 DWORD PTR _nameColor$[ebp], eax

; 2057 : 			getStringToken(bigtoken, '|', 10, sizeof(name) - 1, name);

  002aa	8d 85 34 e7 ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  002b0	50		 push	 eax
  002b1	68 ff 07 00 00	 push	 2047			; 000007ffH
  002b6	6a 0a		 push	 10			; 0000000aH
  002b8	6a 7c		 push	 124			; 0000007cH
  002ba	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  002c0	51		 push	 ecx
  002c1	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  002c6	83 c4 14	 add	 esp, 20			; 00000014H

; 2058 : 			makeStringFromEscaped(name);

  002c9	8d 85 34 e7 ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  002cf	50		 push	 eax
  002d0	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  002d5	83 c4 04	 add	 esp, 4

; 2059 : 			getStringToken(bigtoken, '|', 11, sizeof(freeName) - 1, freeName);

  002d8	8d 85 2c df ff
	ff		 lea	 eax, DWORD PTR _freeName$[ebp]
  002de	50		 push	 eax
  002df	68 ff 07 00 00	 push	 2047			; 000007ffH
  002e4	6a 0b		 push	 11			; 0000000bH
  002e6	6a 7c		 push	 124			; 0000007cH
  002e8	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  002ee	51		 push	 ecx
  002ef	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  002f4	83 c4 14	 add	 esp, 20			; 00000014H

; 2060 : 			makeStringFromEscaped(freeName);

  002f7	8d 85 2c df ff
	ff		 lea	 eax, DWORD PTR _freeName$[ebp]
  002fd	50		 push	 eax
  002fe	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  00303	83 c4 04	 add	 esp, 4

; 2061 : 			getStringToken(bigtoken, '|', 12, sizeof(smalltoken) - 1, smalltoken);

  00306	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0030c	50		 push	 eax
  0030d	68 ff 07 00 00	 push	 2047			; 000007ffH
  00312	6a 0c		 push	 12			; 0000000cH
  00314	6a 7c		 push	 124			; 0000007cH
  00316	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  0031c	51		 push	 ecx
  0031d	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00322	83 c4 14	 add	 esp, 20			; 00000014H

; 2062 : 			walkable = atoi(smalltoken);

  00325	8b f4		 mov	 esi, esp
  00327	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0032d	50		 push	 eax
  0032e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00334	83 c4 04	 add	 esp, 4
  00337	3b f4		 cmp	 esi, esp
  00339	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0033e	89 45 88	 mov	 DWORD PTR _walkable$[ebp], eax

; 2063 : 			getStringToken(bigtoken, '|', 13, sizeof(smalltoken) - 1, smalltoken);

  00341	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00347	50		 push	 eax
  00348	68 ff 07 00 00	 push	 2047			; 000007ffH
  0034d	6a 0d		 push	 13			; 0000000dH
  0034f	6a 7c		 push	 124			; 0000007cH
  00351	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00357	51		 push	 ecx
  00358	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0035d	83 c4 14	 add	 esp, 20			; 00000014H

; 2064 : 			height = atoi(smalltoken);

  00360	8b f4		 mov	 esi, esp
  00362	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00368	50		 push	 eax
  00369	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0036f	83 c4 04	 add	 esp, 4
  00372	3b f4		 cmp	 esi, esp
  00374	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00379	89 85 7c ff ff
	ff		 mov	 DWORD PTR _height$[ebp], eax

; 2065 : 			charNameColor = getIntegerToken(bigtoken, '|', 14);

  0037f	6a 0e		 push	 14			; 0000000eH
  00381	6a 7c		 push	 124			; 0000007cH
  00383	8d 85 44 f7 ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  00389	50		 push	 eax
  0038a	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0038f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00392	89 85 4c ff ff
	ff		 mov	 DWORD PTR _charNameColor$[ebp], eax

; 2066 : 			getStringToken(bigtoken , '|', 15, sizeof(fmname) - 1, fmname);

  00398	8d 85 1c d3 ff
	ff		 lea	 eax, DWORD PTR _fmname$[ebp]
  0039e	50		 push	 eax
  0039f	68 ff 07 00 00	 push	 2047			; 000007ffH
  003a4	6a 0f		 push	 15			; 0000000fH
  003a6	6a 7c		 push	 124			; 0000007cH
  003a8	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  003ae	51		 push	 ecx
  003af	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  003b4	83 c4 14	 add	 esp, 20			; 00000014H

; 2067 : 			makeStringFromEscaped(fmname);

  003b7	8d 85 1c d3 ff
	ff		 lea	 eax, DWORD PTR _fmname$[ebp]
  003bd	50		 push	 eax
  003be	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  003c3	83 c4 04	 add	 esp, 4

; 2068 : 			getStringToken(bigtoken , '|', 16, sizeof(petname) - 1, petname);

  003c6	8d 85 14 cf ff
	ff		 lea	 eax, DWORD PTR _petname$[ebp]
  003cc	50		 push	 eax
  003cd	68 ff 03 00 00	 push	 1023			; 000003ffH
  003d2	6a 10		 push	 16			; 00000010H
  003d4	6a 7c		 push	 124			; 0000007cH
  003d6	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  003dc	51		 push	 ecx
  003dd	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  003e2	83 c4 14	 add	 esp, 20			; 00000014H

; 2069 : 			makeStringFromEscaped(petname);

  003e5	8d 85 14 cf ff
	ff		 lea	 eax, DWORD PTR _petname$[ebp]
  003eb	50		 push	 eax
  003ec	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  003f1	83 c4 04	 add	 esp, 4

; 2070 : 			getStringToken(bigtoken, '|', 17, sizeof(smalltoken) - 1, smalltoken);

  003f4	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  003fa	50		 push	 eax
  003fb	68 ff 07 00 00	 push	 2047			; 000007ffH
  00400	6a 11		 push	 17			; 00000011H
  00402	6a 7c		 push	 124			; 0000007cH
  00404	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  0040a	51		 push	 ecx
  0040b	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00410	83 c4 14	 add	 esp, 20			; 00000014H

; 2071 : 			petlevel = atoi(smalltoken);

  00413	8b f4		 mov	 esi, esp
  00415	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0041b	50		 push	 eax
  0041c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00422	83 c4 04	 add	 esp, 4
  00425	3b f4		 cmp	 esi, esp
  00427	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0042c	89 85 08 cf ff
	ff		 mov	 DWORD PTR _petlevel$[ebp], eax

; 2072 : 
; 2073 : #ifdef _CHAR_PROFESSION			// WON ADD 人物职业
; 2074 : 			getStringToken(bigtoken, '|', 18, sizeof(smalltoken) - 1, smalltoken);

  00432	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00438	50		 push	 eax
  00439	68 ff 07 00 00	 push	 2047			; 000007ffH
  0043e	6a 12		 push	 18			; 00000012H
  00440	6a 7c		 push	 124			; 0000007cH
  00442	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00448	51		 push	 ecx
  00449	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0044e	83 c4 14	 add	 esp, 20			; 00000014H

; 2075 : 			profession_class = atoi(smalltoken);

  00451	8b f4		 mov	 esi, esp
  00453	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00459	50		 push	 eax
  0045a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00460	83 c4 04	 add	 esp, 4
  00463	3b f4		 cmp	 esi, esp
  00465	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0046a	89 85 fc ce ff
	ff		 mov	 DWORD PTR _profession_class$[ebp], eax

; 2076 : 			getStringToken(bigtoken, '|', 19, sizeof(smalltoken) - 1, smalltoken);

  00470	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00476	50		 push	 eax
  00477	68 ff 07 00 00	 push	 2047			; 000007ffH
  0047c	6a 13		 push	 19			; 00000013H
  0047e	6a 7c		 push	 124			; 0000007cH
  00480	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00486	51		 push	 ecx
  00487	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0048c	83 c4 14	 add	 esp, 20			; 00000014H

; 2077 : 			profession_level = atoi(smalltoken);

  0048f	8b f4		 mov	 esi, esp
  00491	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00497	50		 push	 eax
  00498	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0049e	83 c4 04	 add	 esp, 4
  004a1	3b f4		 cmp	 esi, esp
  004a3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004a8	89 85 f0 ce ff
	ff		 mov	 DWORD PTR _profession_level$[ebp], eax

; 2078 : //			getStringToken(bigtoken, '|', 20, sizeof(smalltoken) - 1, smalltoken);
; 2079 : //			profession_exp = atoi(smalltoken);
; 2080 : 			getStringToken(bigtoken, '|', 20, sizeof(smalltoken) - 1, smalltoken);

  004ae	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  004b4	50		 push	 eax
  004b5	68 ff 07 00 00	 push	 2047			; 000007ffH
  004ba	6a 14		 push	 20			; 00000014H
  004bc	6a 7c		 push	 124			; 0000007cH
  004be	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  004c4	51		 push	 ecx
  004c5	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  004ca	83 c4 14	 add	 esp, 20			; 00000014H

; 2081 : 			profession_skill_point = atoi(smalltoken);

  004cd	8b f4		 mov	 esi, esp
  004cf	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  004d5	50		 push	 eax
  004d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  004dc	83 c4 04	 add	 esp, 4
  004df	3b f4		 cmp	 esi, esp
  004e1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004e6	89 85 e4 ce ff
	ff		 mov	 DWORD PTR _profession_skill_point$[ebp], eax

; 2082 : #ifdef _ALLDOMAN // Syu ADD 排行榜NPC
; 2083 : 			getStringToken(bigtoken, '|', 21, sizeof(smalltoken) - 1, smalltoken);

  004ec	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  004f2	50		 push	 eax
  004f3	68 ff 07 00 00	 push	 2047			; 000007ffH
  004f8	6a 15		 push	 21			; 00000015H
  004fa	6a 7c		 push	 124			; 0000007cH
  004fc	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00502	51		 push	 ecx
  00503	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00508	83 c4 14	 add	 esp, 20			; 00000014H

; 2084 : 			herofloor = atoi(smalltoken);

  0050b	8b f4		 mov	 esi, esp
  0050d	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00513	50		 push	 eax
  00514	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0051a	83 c4 04	 add	 esp, 4
  0051d	3b f4		 cmp	 esi, esp
  0051f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00524	89 85 d8 ce ff
	ff		 mov	 DWORD PTR _herofloor$[ebp], eax

; 2085 : #endif
; 2086 : #ifdef _NPC_PICTURE
; 2087 : 			getStringToken(bigtoken, '|', 22, sizeof(smalltoken) - 1, smalltoken);

  0052a	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00530	50		 push	 eax
  00531	68 ff 07 00 00	 push	 2047			; 000007ffH
  00536	6a 16		 push	 22			; 00000016H
  00538	6a 7c		 push	 124			; 0000007cH
  0053a	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00540	51		 push	 ecx
  00541	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00546	83 c4 14	 add	 esp, 20			; 00000014H

; 2088 : 			picture = atoi(smalltoken);

  00549	8b f4		 mov	 esi, esp
  0054b	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00551	50		 push	 eax
  00552	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00558	83 c4 04	 add	 esp, 4
  0055b	3b f4		 cmp	 esi, esp
  0055d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00562	88 85 cf ce ff
	ff		 mov	 BYTE PTR _picture$[ebp], al

; 2089 : #endif
; 2090 : #ifdef _GM_IDENTIFY		// Rog ADD GM识别
; 2091 : 			getStringToken(bigtoken , '|', 23 , sizeof( gm_name ) - 1, gm_name );
; 2092 : 			makeStringFromEscaped( gm_name );
; 2093 : #endif
; 2094 : #endif
; 2095 : #ifdef _NB_任务指引
; 2096 : 			getStringToken(bigtoken, '|', 23, sizeof(smalltoken) - 1, smalltoken);

  00568	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0056e	50		 push	 eax
  0056f	68 ff 07 00 00	 push	 2047			; 000007ffH
  00574	6a 17		 push	 23			; 00000017H
  00576	6a 7c		 push	 124			; 0000007cH
  00578	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  0057e	51		 push	 ecx
  0057f	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00584	83 c4 14	 add	 esp, 20			; 00000014H

; 2097 : 			noticeNo = atoi(smalltoken);

  00587	8b f4		 mov	 esi, esp
  00589	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0058f	50		 push	 eax
  00590	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00596	83 c4 04	 add	 esp, 4
  00599	3b f4		 cmp	 esi, esp
  0059b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  005a0	89 85 c0 ce ff
	ff		 mov	 DWORD PTR _noticeNo$[ebp], eax

; 2098 : 			//printf("name %s noticeNo %d\n",name,noticeNo);
; 2099 : #endif
; 2100 : #ifdef _NB_文字称号
; 2101 : 			getStringToken(bigtoken , '|', 24 , sizeof( nb_name ) - 1, nb_name);
; 2102 : 			makeStringFromEscaped(nb_name);
; 2103 : 			getStringToken(bigtoken, '|', 25, sizeof(smalltoken) - 1, smalltoken);
; 2104 : 			nb_namecolor = atoi(smalltoken);
; 2105 : #endif
; 2106 : 
; 2107 : 			if (charNameColor < 0)

  005a6	83 bd 4c ff ff
	ff 00		 cmp	 DWORD PTR _charNameColor$[ebp], 0
  005ad	7d 0a		 jge	 SHORT $LN18@lssproto_C

; 2108 : 				charNameColor = 0;

  005af	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _charNameColor$[ebp], 0
$LN18@lssproto_C:

; 2109 : 			if (pc.id == id){

  005b9	a1 08 00 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+8
  005be	3b 45 dc	 cmp	 eax, DWORD PTR _id$[ebp]
  005c1	0f 85 5d 01 00
	00		 jne	 $LN19@lssproto_C

; 2110 : 				if (pc.ptAct == NULL){

  005c7	83 3d ec 50 00
	00 00		 cmp	 DWORD PTR ?pc@@3UPC@@A+20716, 0
  005ce	75 1f		 jne	 SHORT $LN21@lssproto_C

; 2111 : 					createPc(graNo, x, y, dir);

  005d0	8b 45 b8	 mov	 eax, DWORD PTR _dir$[ebp]
  005d3	50		 push	 eax
  005d4	8b 4d c4	 mov	 ecx, DWORD PTR _y$[ebp]
  005d7	51		 push	 ecx
  005d8	8b 55 d0	 mov	 edx, DWORD PTR _x$[ebp]
  005db	52		 push	 edx
  005dc	8b 45 ac	 mov	 eax, DWORD PTR _graNo$[ebp]
  005df	50		 push	 eax
  005e0	e8 00 00 00 00	 call	 ?createPc@@YAXHHHH@Z	; createPc
  005e5	83 c4 10	 add	 esp, 16			; 00000010H

; 2112 : 					updataPcAct();

  005e8	e8 00 00 00 00	 call	 ?updataPcAct@@YAXXZ	; updataPcAct

; 2113 : 				}
; 2114 : 				else

  005ed	eb 12		 jmp	 SHORT $LN22@lssproto_C
$LN21@lssproto_C:

; 2115 : 					setPcGraNo(graNo, pc.dir);

  005ef	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+12
  005f4	50		 push	 eax
  005f5	8b 4d ac	 mov	 ecx, DWORD PTR _graNo$[ebp]
  005f8	51		 push	 ecx
  005f9	e8 00 00 00 00	 call	 ?setPcGraNo@@YAXHH@Z	; setPcGraNo
  005fe	83 c4 08	 add	 esp, 8
$LN22@lssproto_C:

; 2116 : 				updateMapArea();

  00601	e8 00 00 00 00	 call	 ?updateMapArea@@YAXXZ	; updateMapArea

; 2117 : 
; 2118 : #ifdef _NB_文字称号
; 2119 : 				setPcParam(name, freeName, level, petname, petlevel, nameColor, walkable, height, profession_class, profession_level, profession_skill_point,herofloor,nb_name,nb_namecolor);
; 2120 : #else
; 2121 : #ifdef _CHAR_PROFESSION			// WON ADD 人物职业
; 2122 : //    #ifdef _GM_IDENTIFY		// Rog ADD GM识别
; 2123 : //				setPcParam(name, freeName, level, petname, petlevel, nameColor, walkable, height, profession_class, profession_level, profession_exp, profession_skill_point , gm_name);
; 2124 : //				setPcParam(name, freeName, level, petname, petlevel, nameColor, walkable, height, profession_class, profession_level, profession_skill_point , gm_name);
; 2125 : //    #else
; 2126 : //				setPcParam(name, freeName, level, petname, petlevel, nameColor, walkable, height, profession_class, profession_level, profession_exp, profession_skill_point);
; 2127 : #ifdef _ALLDOMAN // Syu ADD 排行榜NPC
; 2128 : 				setPcParam(name, freeName, level, petname, petlevel, nameColor, walkable, height, profession_class, profession_level, profession_skill_point , herofloor);

  00606	8b 85 d8 ce ff
	ff		 mov	 eax, DWORD PTR _herofloor$[ebp]
  0060c	50		 push	 eax
  0060d	8b 8d e4 ce ff
	ff		 mov	 ecx, DWORD PTR _profession_skill_point$[ebp]
  00613	51		 push	 ecx
  00614	8b 95 f0 ce ff
	ff		 mov	 edx, DWORD PTR _profession_level$[ebp]
  0061a	52		 push	 edx
  0061b	8b 85 fc ce ff
	ff		 mov	 eax, DWORD PTR _profession_class$[ebp]
  00621	50		 push	 eax
  00622	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _height$[ebp]
  00628	51		 push	 ecx
  00629	8b 55 88	 mov	 edx, DWORD PTR _walkable$[ebp]
  0062c	52		 push	 edx
  0062d	8b 45 94	 mov	 eax, DWORD PTR _nameColor$[ebp]
  00630	50		 push	 eax
  00631	8b 8d 08 cf ff
	ff		 mov	 ecx, DWORD PTR _petlevel$[ebp]
  00637	51		 push	 ecx
  00638	8d 95 14 cf ff
	ff		 lea	 edx, DWORD PTR _petname$[ebp]
  0063e	52		 push	 edx
  0063f	8b 45 a0	 mov	 eax, DWORD PTR _level$[ebp]
  00642	50		 push	 eax
  00643	8d 8d 2c df ff
	ff		 lea	 ecx, DWORD PTR _freeName$[ebp]
  00649	51		 push	 ecx
  0064a	8d 95 34 e7 ff
	ff		 lea	 edx, DWORD PTR _name$[ebp]
  00650	52		 push	 edx
  00651	e8 00 00 00 00	 call	 ?setPcParam@@YAXPAD0H0HHHHHHHH@Z ; setPcParam
  00656	83 c4 30	 add	 esp, 48			; 00000030H

; 2129 : #else
; 2130 : 				setPcParam(name, freeName, level, petname, petlevel, nameColor, walkable, height, profession_class, profession_level, profession_skill_point);
; 2131 : #endif
; 2132 : //    #endif
; 2133 : #else
; 2134 : 				setPcParam(name, freeName, level, petname, petlevel, nameColor, walkable, height);
; 2135 : #endif
; 2136 : 
; 2137 : #endif
; 2138 : 				//JL 设置id
; 2139 : 				pc.ptAct->objIndex = id;

  00659	a1 ec 50 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+20716
  0065e	8b 4d dc	 mov	 ecx, DWORD PTR _id$[ebp]
  00661	89 88 34 02 00
	00		 mov	 DWORD PTR [eax+564], ecx

; 2140 : 
; 2141 : 				setPcNameColor(charNameColor);

  00667	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _charNameColor$[ebp]
  0066d	50		 push	 eax
  0066e	e8 00 00 00 00	 call	 ?setPcNameColor@@YAXH@Z	; setPcNameColor
  00673	83 c4 04	 add	 esp, 4

; 2142 : 				if ((pc.status & CHR_STATUS_LEADER) != 0 && party[0].useFlag != 0)

  00676	a1 a4 00 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+164
  0067b	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00680	74 43		 je	 SHORT $LN23@lssproto_C
  00682	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  00687	6b c8 00	 imul	 ecx, eax, 0
  0068a	0f bf 91 00 00
	00 00		 movsx	 edx, WORD PTR ?party@@3PAUPARTY@@A[ecx]
  00691	85 d2		 test	 edx, edx
  00693	74 30		 je	 SHORT $LN23@lssproto_C

; 2143 : 				{
; 2144 : 					party[0].level = pc.level;

  00695	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  0069a	6b c8 00	 imul	 ecx, eax, 0
  0069d	8b 15 38 00 00
	00		 mov	 edx, DWORD PTR ?pc@@3UPC@@A+56
  006a3	89 91 08 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[ecx+8], edx

; 2145 : 					strcpy(party[0].name, pc.name);

  006a9	68 70 00 00 00	 push	 OFFSET ?pc@@3UPC@@A+112
  006ae	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  006b3	6b c8 00	 imul	 ecx, eax, 0
  006b6	81 c1 18 00 00
	00		 add	 ecx, OFFSET ?party@@3PAUPARTY@@A+24
  006bc	51		 push	 ecx
  006bd	e8 00 00 00 00	 call	 _strcpy
  006c2	83 c4 08	 add	 esp, 8
$LN23@lssproto_C:

; 2146 : 				}
; 2147 : 				for (j = 0; j < MAX_PARTY; j++)

  006c5	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  006cc	eb 09		 jmp	 SHORT $LN9@lssproto_C
$LN7@lssproto_C:
  006ce	8b 45 e8	 mov	 eax, DWORD PTR _j$[ebp]
  006d1	83 c0 01	 add	 eax, 1
  006d4	89 45 e8	 mov	 DWORD PTR _j$[ebp], eax
$LN9@lssproto_C:
  006d7	83 7d e8 05	 cmp	 DWORD PTR _j$[ebp], 5
  006db	7d 42		 jge	 SHORT $LN8@lssproto_C

; 2148 : 				{
; 2149 : 					if (party[j].useFlag != 0 && party[j].id == id)

  006dd	6b 45 e8 30	 imul	 eax, DWORD PTR _j$[ebp], 48
  006e1	0f bf 88 00 00
	00 00		 movsx	 ecx, WORD PTR ?party@@3PAUPARTY@@A[eax]
  006e8	85 c9		 test	 ecx, ecx
  006ea	74 31		 je	 SHORT $LN24@lssproto_C
  006ec	6b 45 e8 30	 imul	 eax, DWORD PTR _j$[ebp], 48
  006f0	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR ?party@@3PAUPARTY@@A[eax+4]
  006f6	3b 4d dc	 cmp	 ecx, DWORD PTR _id$[ebp]
  006f9	75 22		 jne	 SHORT $LN24@lssproto_C

; 2150 : 					{
; 2151 : 						party[j].ptAct = pc.ptAct;

  006fb	6b 45 e8 30	 imul	 eax, DWORD PTR _j$[ebp], 48
  006ff	8b 0d ec 50 00
	00		 mov	 ecx, DWORD PTR ?pc@@3UPC@@A+20716
  00705	89 88 2c 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[eax+44], ecx

; 2152 : 						setPcParty();

  0070b	e8 00 00 00 00	 call	 ?setPcParty@@YAXXZ	; setPcParty

; 2153 : 						if (j == 0)

  00710	83 7d e8 00	 cmp	 DWORD PTR _j$[ebp], 0
  00714	75 05		 jne	 SHORT $LN25@lssproto_C

; 2154 : 							setPcLeader();

  00716	e8 00 00 00 00	 call	 ?setPcLeader@@YAXXZ	; setPcLeader
$LN25@lssproto_C:

; 2155 : 						break;

  0071b	eb 02		 jmp	 SHORT $LN8@lssproto_C
$LN24@lssproto_C:

; 2156 : 					}
; 2157 : 				}

  0071d	eb af		 jmp	 SHORT $LN7@lssproto_C
$LN8@lssproto_C:

; 2158 : 			}else{

  0071f	e9 49 01 00 00	 jmp	 $LN20@lssproto_C
$LN19@lssproto_C:

; 2159 : 				setNpcCharObj(id, graNo, x, y, dir, fmname, name, freeName,

  00724	8b 85 c0 ce ff
	ff		 mov	 eax, DWORD PTR _noticeNo$[ebp]
  0072a	50		 push	 eax
  0072b	0f be 8d cf ce
	ff ff		 movsx	 ecx, BYTE PTR _picture$[ebp]
  00732	51		 push	 ecx
  00733	8b 95 fc ce ff
	ff		 mov	 edx, DWORD PTR _profession_class$[ebp]
  00739	52		 push	 edx
  0073a	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _charType$[ebp]
  00740	50		 push	 eax
  00741	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _height$[ebp]
  00747	51		 push	 ecx
  00748	8b 55 88	 mov	 edx, DWORD PTR _walkable$[ebp]
  0074b	52		 push	 edx
  0074c	8b 45 94	 mov	 eax, DWORD PTR _nameColor$[ebp]
  0074f	50		 push	 eax
  00750	8b 8d 08 cf ff
	ff		 mov	 ecx, DWORD PTR _petlevel$[ebp]
  00756	51		 push	 ecx
  00757	8d 95 14 cf ff
	ff		 lea	 edx, DWORD PTR _petname$[ebp]
  0075d	52		 push	 edx
  0075e	8b 45 a0	 mov	 eax, DWORD PTR _level$[ebp]
  00761	50		 push	 eax
  00762	8d 8d 2c df ff
	ff		 lea	 ecx, DWORD PTR _freeName$[ebp]
  00768	51		 push	 ecx
  00769	8d 95 34 e7 ff
	ff		 lea	 edx, DWORD PTR _name$[ebp]
  0076f	52		 push	 edx
  00770	8d 85 1c d3 ff
	ff		 lea	 eax, DWORD PTR _fmname$[ebp]
  00776	50		 push	 eax
  00777	8b 4d b8	 mov	 ecx, DWORD PTR _dir$[ebp]
  0077a	51		 push	 ecx
  0077b	8b 55 c4	 mov	 edx, DWORD PTR _y$[ebp]
  0077e	52		 push	 edx
  0077f	8b 45 d0	 mov	 eax, DWORD PTR _x$[ebp]
  00782	50		 push	 eax
  00783	8b 4d ac	 mov	 ecx, DWORD PTR _graNo$[ebp]
  00786	51		 push	 ecx
  00787	8b 55 dc	 mov	 edx, DWORD PTR _id$[ebp]
  0078a	52		 push	 edx
  0078b	e8 00 00 00 00	 call	 ?setNpcCharObj@@YAXHHHHHPAD00H0HHHHHHHH@Z ; setNpcCharObj
  00790	83 c4 48	 add	 esp, 72			; 00000048H

; 2160 : 					level, petname, petlevel, nameColor, walkable, height, charType, profession_class
; 2161 : #ifdef _NPC_PICTURE
; 2162 : 					, picture
; 2163 : #endif
; 2164 : #ifdef _NB_文字称号
; 2165 : 					,nb_name,nb_namecolor
; 2166 : #endif
; 2167 : #ifdef _NB_任务指引
; 2168 : 					,noticeNo
; 2169 : #endif
; 2170 : 					);
; 2171 : 				ptAct = getCharObjAct(id);

  00793	8b 45 dc	 mov	 eax, DWORD PTR _id$[ebp]
  00796	50		 push	 eax
  00797	e8 00 00 00 00	 call	 ?getCharObjAct@@YAPAUaction@@H@Z ; getCharObjAct
  0079c	83 c4 04	 add	 esp, 4
  0079f	89 85 b4 ce ff
	ff		 mov	 DWORD PTR _ptAct$[ebp], eax

; 2172 : #ifdef _NB_任务指引
; 2173 : 				if(charType==13 && noticeNo>0){

  007a5	83 bd 58 ff ff
	ff 0d		 cmp	 DWORD PTR _charType$[ebp], 13 ; 0000000dH
  007ac	75 1f		 jne	 SHORT $LN26@lssproto_C
  007ae	83 bd c0 ce ff
	ff 00		 cmp	 DWORD PTR _noticeNo$[ebp], 0
  007b5	7e 16		 jle	 SHORT $LN26@lssproto_C

; 2174 : 					setNpcNotice( ptAct, noticeNo);

  007b7	8b 85 c0 ce ff
	ff		 mov	 eax, DWORD PTR _noticeNo$[ebp]
  007bd	50		 push	 eax
  007be	8b 8d b4 ce ff
	ff		 mov	 ecx, DWORD PTR _ptAct$[ebp]
  007c4	51		 push	 ecx
  007c5	e8 00 00 00 00	 call	 ?setNpcNotice@@YAXPAUaction@@H@Z ; setNpcNotice
  007ca	83 c4 08	 add	 esp, 8
$LN26@lssproto_C:

; 2175 : 				}
; 2176 : #endif
; 2177 : 				if (ptAct != NULL)

  007cd	83 bd b4 ce ff
	ff 00		 cmp	 DWORD PTR _ptAct$[ebp], 0
  007d4	0f 84 93 00 00
	00		 je	 $LN20@lssproto_C

; 2178 : 				{
; 2179 : 					//JL 设置id
; 2180 : 					ptAct->objIndex = id;

  007da	8b 85 b4 ce ff
	ff		 mov	 eax, DWORD PTR _ptAct$[ebp]
  007e0	8b 4d dc	 mov	 ecx, DWORD PTR _id$[ebp]
  007e3	89 88 34 02 00
	00		 mov	 DWORD PTR [eax+564], ecx

; 2181 : 					for (j = 0; j < MAX_PARTY; j++)

  007e9	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  007f0	eb 09		 jmp	 SHORT $LN12@lssproto_C
$LN10@lssproto_C:
  007f2	8b 45 e8	 mov	 eax, DWORD PTR _j$[ebp]
  007f5	83 c0 01	 add	 eax, 1
  007f8	89 45 e8	 mov	 DWORD PTR _j$[ebp], eax
$LN12@lssproto_C:
  007fb	83 7d e8 05	 cmp	 DWORD PTR _j$[ebp], 5
  007ff	7d 56		 jge	 SHORT $LN11@lssproto_C

; 2182 : 					{
; 2183 : 						if (party[j].useFlag != 0 && party[j].id == id)

  00801	6b 45 e8 30	 imul	 eax, DWORD PTR _j$[ebp], 48
  00805	0f bf 88 00 00
	00 00		 movsx	 ecx, WORD PTR ?party@@3PAUPARTY@@A[eax]
  0080c	85 c9		 test	 ecx, ecx
  0080e	74 45		 je	 SHORT $LN28@lssproto_C
  00810	6b 45 e8 30	 imul	 eax, DWORD PTR _j$[ebp], 48
  00814	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR ?party@@3PAUPARTY@@A[eax+4]
  0081a	3b 4d dc	 cmp	 ecx, DWORD PTR _id$[ebp]
  0081d	75 36		 jne	 SHORT $LN28@lssproto_C

; 2184 : 						{
; 2185 : 							party[j].ptAct = ptAct;

  0081f	6b 45 e8 30	 imul	 eax, DWORD PTR _j$[ebp], 48
  00823	8b 8d b4 ce ff
	ff		 mov	 ecx, DWORD PTR _ptAct$[ebp]
  00829	89 88 2c 00 00
	00		 mov	 DWORD PTR ?party@@3PAUPARTY@@A[eax+44], ecx

; 2186 : 							setCharParty(ptAct);

  0082f	8b 85 b4 ce ff
	ff		 mov	 eax, DWORD PTR _ptAct$[ebp]
  00835	50		 push	 eax
  00836	e8 00 00 00 00	 call	 ?setCharParty@@YAXPAUaction@@@Z ; setCharParty
  0083b	83 c4 04	 add	 esp, 4

; 2187 : 							if (j == 0)

  0083e	83 7d e8 00	 cmp	 DWORD PTR _j$[ebp], 0
  00842	75 0f		 jne	 SHORT $LN29@lssproto_C

; 2188 : 								setCharLeader(ptAct);

  00844	8b 85 b4 ce ff
	ff		 mov	 eax, DWORD PTR _ptAct$[ebp]
  0084a	50		 push	 eax
  0084b	e8 00 00 00 00	 call	 ?setCharLeader@@YAXPAUaction@@@Z ; setCharLeader
  00850	83 c4 04	 add	 esp, 4
$LN29@lssproto_C:

; 2189 : 							break;

  00853	eb 02		 jmp	 SHORT $LN11@lssproto_C
$LN28@lssproto_C:

; 2190 : 						}
; 2191 : 					}

  00855	eb 9b		 jmp	 SHORT $LN10@lssproto_C
$LN11@lssproto_C:

; 2192 : 					setCharNameColor(ptAct, charNameColor);

  00857	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _charNameColor$[ebp]
  0085d	50		 push	 eax
  0085e	8b 8d b4 ce ff
	ff		 mov	 ecx, DWORD PTR _ptAct$[ebp]
  00864	51		 push	 ecx
  00865	e8 00 00 00 00	 call	 ?setCharNameColor@@YAXPAUaction@@H@Z ; setCharNameColor
  0086a	83 c4 08	 add	 esp, 8
$LN20@lssproto_C:

; 2193 : 				}
; 2194 : 			}
; 2195 : 			break;

  0086d	e9 b2 04 00 00	 jmp	 $LN5@lssproto_C
$LN30@lssproto_C:

; 2196 : 		case 2://OBJTYPE_ITEM
; 2197 : 				getStringToken(bigtoken, '|', 2, sizeof(smalltoken) - 1, smalltoken);

  00872	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00878	50		 push	 eax
  00879	68 ff 07 00 00	 push	 2047			; 000007ffH
  0087e	6a 02		 push	 2
  00880	6a 7c		 push	 124			; 0000007cH
  00882	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00888	51		 push	 ecx
  00889	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0088e	83 c4 14	 add	 esp, 20			; 00000014H

; 2198 : 				id = a62toi(smalltoken);

  00891	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00897	50		 push	 eax
  00898	e8 00 00 00 00	 call	 ?a62toi@@YAHPAD@Z	; a62toi
  0089d	83 c4 04	 add	 esp, 4
  008a0	89 45 dc	 mov	 DWORD PTR _id$[ebp], eax

; 2199 : 				getStringToken(bigtoken, '|', 3, sizeof(smalltoken) - 1, smalltoken);

  008a3	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  008a9	50		 push	 eax
  008aa	68 ff 07 00 00	 push	 2047			; 000007ffH
  008af	6a 03		 push	 3
  008b1	6a 7c		 push	 124			; 0000007cH
  008b3	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  008b9	51		 push	 ecx
  008ba	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  008bf	83 c4 14	 add	 esp, 20			; 00000014H

; 2200 : 				x = atoi(smalltoken);

  008c2	8b f4		 mov	 esi, esp
  008c4	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  008ca	50		 push	 eax
  008cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  008d1	83 c4 04	 add	 esp, 4
  008d4	3b f4		 cmp	 esi, esp
  008d6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  008db	89 45 d0	 mov	 DWORD PTR _x$[ebp], eax

; 2201 : 				getStringToken(bigtoken, '|', 4, sizeof(smalltoken) - 1, smalltoken);

  008de	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  008e4	50		 push	 eax
  008e5	68 ff 07 00 00	 push	 2047			; 000007ffH
  008ea	6a 04		 push	 4
  008ec	6a 7c		 push	 124			; 0000007cH
  008ee	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  008f4	51		 push	 ecx
  008f5	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  008fa	83 c4 14	 add	 esp, 20			; 00000014H

; 2202 : 				y = atoi(smalltoken);

  008fd	8b f4		 mov	 esi, esp
  008ff	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00905	50		 push	 eax
  00906	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0090c	83 c4 04	 add	 esp, 4
  0090f	3b f4		 cmp	 esi, esp
  00911	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00916	89 45 c4	 mov	 DWORD PTR _y$[ebp], eax

; 2203 : 				getStringToken(bigtoken, '|', 5, sizeof(smalltoken) - 1, smalltoken);

  00919	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  0091f	50		 push	 eax
  00920	68 ff 07 00 00	 push	 2047			; 000007ffH
  00925	6a 05		 push	 5
  00927	6a 7c		 push	 124			; 0000007cH
  00929	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  0092f	51		 push	 ecx
  00930	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00935	83 c4 14	 add	 esp, 20			; 00000014H

; 2204 : 				graNo = atoi(smalltoken);

  00938	8b f4		 mov	 esi, esp
  0093a	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00940	50		 push	 eax
  00941	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00947	83 c4 04	 add	 esp, 4
  0094a	3b f4		 cmp	 esi, esp
  0094c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00951	89 45 ac	 mov	 DWORD PTR _graNo$[ebp], eax

; 2205 : 				classNo = getIntegerToken(bigtoken, '|', 6);

  00954	6a 06		 push	 6
  00956	6a 7c		 push	 124			; 0000007cH
  00958	8d 85 44 f7 ff
	ff		 lea	 eax, DWORD PTR _bigtoken$[ebp]
  0095e	50		 push	 eax
  0095f	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00964	83 c4 0c	 add	 esp, 12			; 0000000cH
  00967	89 85 70 ff ff
	ff		 mov	 DWORD PTR _classNo$[ebp], eax

; 2206 : 				getStringToken(bigtoken, '|', 7, sizeof(info) - 1, info);

  0096d	8d 85 24 db ff
	ff		 lea	 eax, DWORD PTR _info$[ebp]
  00973	50		 push	 eax
  00974	68 ff 03 00 00	 push	 1023			; 000003ffH
  00979	6a 07		 push	 7
  0097b	6a 7c		 push	 124			; 0000007cH
  0097d	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00983	51		 push	 ecx
  00984	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00989	83 c4 14	 add	 esp, 20			; 00000014H

; 2207 : 				makeStringFromEscaped(info);

  0098c	8d 85 24 db ff
	ff		 lea	 eax, DWORD PTR _info$[ebp]
  00992	50		 push	 eax
  00993	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  00998	83 c4 04	 add	 esp, 4

; 2208 : 				setItemCharObj(id, graNo, x, y, 0, classNo, info);

  0099b	8d 85 24 db ff
	ff		 lea	 eax, DWORD PTR _info$[ebp]
  009a1	50		 push	 eax
  009a2	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _classNo$[ebp]
  009a8	51		 push	 ecx
  009a9	6a 00		 push	 0
  009ab	8b 55 c4	 mov	 edx, DWORD PTR _y$[ebp]
  009ae	52		 push	 edx
  009af	8b 45 d0	 mov	 eax, DWORD PTR _x$[ebp]
  009b2	50		 push	 eax
  009b3	8b 4d ac	 mov	 ecx, DWORD PTR _graNo$[ebp]
  009b6	51		 push	 ecx
  009b7	8b 55 dc	 mov	 edx, DWORD PTR _id$[ebp]
  009ba	52		 push	 edx
  009bb	e8 00 00 00 00	 call	 ?setItemCharObj@@YAXHHHHHHPAD@Z ; setItemCharObj
  009c0	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2209 : 			break;

  009c3	e9 5c 03 00 00	 jmp	 $LN5@lssproto_C
$LN31@lssproto_C:

; 2210 : 		case 3://OBJTYPE_GOLD
; 2211 : 				getStringToken(bigtoken, '|', 2, sizeof(smalltoken) - 1, smalltoken);

  009c8	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  009ce	50		 push	 eax
  009cf	68 ff 07 00 00	 push	 2047			; 000007ffH
  009d4	6a 02		 push	 2
  009d6	6a 7c		 push	 124			; 0000007cH
  009d8	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  009de	51		 push	 ecx
  009df	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  009e4	83 c4 14	 add	 esp, 20			; 00000014H

; 2212 : 				id = a62toi(smalltoken);

  009e7	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  009ed	50		 push	 eax
  009ee	e8 00 00 00 00	 call	 ?a62toi@@YAHPAD@Z	; a62toi
  009f3	83 c4 04	 add	 esp, 4
  009f6	89 45 dc	 mov	 DWORD PTR _id$[ebp], eax

; 2213 : 				getStringToken(bigtoken, '|', 3, sizeof(smalltoken) - 1, smalltoken);

  009f9	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  009ff	50		 push	 eax
  00a00	68 ff 07 00 00	 push	 2047			; 000007ffH
  00a05	6a 03		 push	 3
  00a07	6a 7c		 push	 124			; 0000007cH
  00a09	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00a0f	51		 push	 ecx
  00a10	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00a15	83 c4 14	 add	 esp, 20			; 00000014H

; 2214 : 				x = atoi(smalltoken);

  00a18	8b f4		 mov	 esi, esp
  00a1a	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00a20	50		 push	 eax
  00a21	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00a27	83 c4 04	 add	 esp, 4
  00a2a	3b f4		 cmp	 esi, esp
  00a2c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00a31	89 45 d0	 mov	 DWORD PTR _x$[ebp], eax

; 2215 : 				getStringToken(bigtoken, '|', 4, sizeof(smalltoken) - 1, smalltoken);

  00a34	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00a3a	50		 push	 eax
  00a3b	68 ff 07 00 00	 push	 2047			; 000007ffH
  00a40	6a 04		 push	 4
  00a42	6a 7c		 push	 124			; 0000007cH
  00a44	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00a4a	51		 push	 ecx
  00a4b	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00a50	83 c4 14	 add	 esp, 20			; 00000014H

; 2216 : 				y = atoi(smalltoken);

  00a53	8b f4		 mov	 esi, esp
  00a55	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00a5b	50		 push	 eax
  00a5c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00a62	83 c4 04	 add	 esp, 4
  00a65	3b f4		 cmp	 esi, esp
  00a67	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00a6c	89 45 c4	 mov	 DWORD PTR _y$[ebp], eax

; 2217 : 				getStringToken(bigtoken, '|', 5, sizeof(smalltoken) - 1, smalltoken);

  00a6f	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00a75	50		 push	 eax
  00a76	68 ff 07 00 00	 push	 2047			; 000007ffH
  00a7b	6a 05		 push	 5
  00a7d	6a 7c		 push	 124			; 0000007cH
  00a7f	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00a85	51		 push	 ecx
  00a86	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00a8b	83 c4 14	 add	 esp, 20			; 00000014H

; 2218 : 				money = atoi(smalltoken);

  00a8e	8b f4		 mov	 esi, esp
  00a90	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00a96	50		 push	 eax
  00a97	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00a9d	83 c4 04	 add	 esp, 4
  00aa0	3b f4		 cmp	 esi, esp
  00aa2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00aa7	89 85 64 ff ff
	ff		 mov	 DWORD PTR _money$[ebp], eax

; 2219 : 				sprintf(info, "%d Stone", money);

  00aad	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _money$[ebp]
  00ab3	50		 push	 eax
  00ab4	68 00 00 00 00	 push	 OFFSET ??_C@_08PFECBJKL@?$CFd?5Stone?$AA@
  00ab9	8d 8d 24 db ff
	ff		 lea	 ecx, DWORD PTR _info$[ebp]
  00abf	51		 push	 ecx
  00ac0	e8 00 00 00 00	 call	 _sprintf
  00ac5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2220 : 				if (money > 10000)

  00ac8	81 bd 64 ff ff
	ff 10 27 00 00	 cmp	 DWORD PTR _money$[ebp], 10000 ; 00002710H
  00ad2	7e 2b		 jle	 SHORT $LN32@lssproto_C

; 2221 : 					setMoneyCharObj(id, 24050, x, y, 0, money, info);

  00ad4	8d 85 24 db ff
	ff		 lea	 eax, DWORD PTR _info$[ebp]
  00ada	50		 push	 eax
  00adb	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _money$[ebp]
  00ae1	51		 push	 ecx
  00ae2	6a 00		 push	 0
  00ae4	8b 55 c4	 mov	 edx, DWORD PTR _y$[ebp]
  00ae7	52		 push	 edx
  00ae8	8b 45 d0	 mov	 eax, DWORD PTR _x$[ebp]
  00aeb	50		 push	 eax
  00aec	68 f2 5d 00 00	 push	 24050			; 00005df2H
  00af1	8b 4d dc	 mov	 ecx, DWORD PTR _id$[ebp]
  00af4	51		 push	 ecx
  00af5	e8 00 00 00 00	 call	 ?setMoneyCharObj@@YAXHHHHHHPAD@Z ; setMoneyCharObj
  00afa	83 c4 1c	 add	 esp, 28			; 0000001cH
  00afd	eb 60		 jmp	 SHORT $LN33@lssproto_C
$LN32@lssproto_C:

; 2222 : 				else if (money > 1000)

  00aff	81 bd 64 ff ff
	ff e8 03 00 00	 cmp	 DWORD PTR _money$[ebp], 1000 ; 000003e8H
  00b09	7e 2b		 jle	 SHORT $LN34@lssproto_C

; 2223 : 					setMoneyCharObj(id, 24051, x, y, 0, money, info);

  00b0b	8d 85 24 db ff
	ff		 lea	 eax, DWORD PTR _info$[ebp]
  00b11	50		 push	 eax
  00b12	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _money$[ebp]
  00b18	51		 push	 ecx
  00b19	6a 00		 push	 0
  00b1b	8b 55 c4	 mov	 edx, DWORD PTR _y$[ebp]
  00b1e	52		 push	 edx
  00b1f	8b 45 d0	 mov	 eax, DWORD PTR _x$[ebp]
  00b22	50		 push	 eax
  00b23	68 f3 5d 00 00	 push	 24051			; 00005df3H
  00b28	8b 4d dc	 mov	 ecx, DWORD PTR _id$[ebp]
  00b2b	51		 push	 ecx
  00b2c	e8 00 00 00 00	 call	 ?setMoneyCharObj@@YAXHHHHHHPAD@Z ; setMoneyCharObj
  00b31	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2224 : 				else

  00b34	eb 29		 jmp	 SHORT $LN33@lssproto_C
$LN34@lssproto_C:

; 2225 : 					setMoneyCharObj(id, 24052, x, y, 0, money, info);

  00b36	8d 85 24 db ff
	ff		 lea	 eax, DWORD PTR _info$[ebp]
  00b3c	50		 push	 eax
  00b3d	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _money$[ebp]
  00b43	51		 push	 ecx
  00b44	6a 00		 push	 0
  00b46	8b 55 c4	 mov	 edx, DWORD PTR _y$[ebp]
  00b49	52		 push	 edx
  00b4a	8b 45 d0	 mov	 eax, DWORD PTR _x$[ebp]
  00b4d	50		 push	 eax
  00b4e	68 f4 5d 00 00	 push	 24052			; 00005df4H
  00b53	8b 4d dc	 mov	 ecx, DWORD PTR _id$[ebp]
  00b56	51		 push	 ecx
  00b57	e8 00 00 00 00	 call	 ?setMoneyCharObj@@YAXHHHHHHPAD@Z ; setMoneyCharObj
  00b5c	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN33@lssproto_C:

; 2226 : 			break;

  00b5f	e9 c0 01 00 00	 jmp	 $LN5@lssproto_C
$LN36@lssproto_C:

; 2227 : 		case 4:
; 2228 : 			getStringToken(bigtoken, '|', 2, sizeof(smalltoken) - 1, smalltoken);

  00b64	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00b6a	50		 push	 eax
  00b6b	68 ff 07 00 00	 push	 2047			; 000007ffH
  00b70	6a 02		 push	 2
  00b72	6a 7c		 push	 124			; 0000007cH
  00b74	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00b7a	51		 push	 ecx
  00b7b	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00b80	83 c4 14	 add	 esp, 20			; 00000014H

; 2229 : 			id = a62toi(smalltoken);

  00b83	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00b89	50		 push	 eax
  00b8a	e8 00 00 00 00	 call	 ?a62toi@@YAHPAD@Z	; a62toi
  00b8f	83 c4 04	 add	 esp, 4
  00b92	89 45 dc	 mov	 DWORD PTR _id$[ebp], eax

; 2230 : 			getStringToken(bigtoken, '|', 3, sizeof(name) - 1, name);

  00b95	8d 85 34 e7 ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  00b9b	50		 push	 eax
  00b9c	68 ff 07 00 00	 push	 2047			; 000007ffH
  00ba1	6a 03		 push	 3
  00ba3	6a 7c		 push	 124			; 0000007cH
  00ba5	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00bab	51		 push	 ecx
  00bac	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00bb1	83 c4 14	 add	 esp, 20			; 00000014H

; 2231 : 			makeStringFromEscaped(name);

  00bb4	8d 85 34 e7 ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  00bba	50		 push	 eax
  00bbb	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  00bc0	83 c4 04	 add	 esp, 4

; 2232 : 			getStringToken(bigtoken, '|', 4, sizeof(smalltoken) - 1, smalltoken);

  00bc3	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00bc9	50		 push	 eax
  00bca	68 ff 07 00 00	 push	 2047			; 000007ffH
  00bcf	6a 04		 push	 4
  00bd1	6a 7c		 push	 124			; 0000007cH
  00bd3	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00bd9	51		 push	 ecx
  00bda	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00bdf	83 c4 14	 add	 esp, 20			; 00000014H

; 2233 : 			dir = (atoi(smalltoken) + 3) % 8;

  00be2	8b f4		 mov	 esi, esp
  00be4	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00bea	50		 push	 eax
  00beb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00bf1	83 c4 04	 add	 esp, 4
  00bf4	3b f4		 cmp	 esi, esp
  00bf6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00bfb	83 c0 03	 add	 eax, 3
  00bfe	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00c03	79 05		 jns	 SHORT $LN48@lssproto_C
  00c05	48		 dec	 eax
  00c06	83 c8 f8	 or	 eax, -8			; fffffff8H
  00c09	40		 inc	 eax
$LN48@lssproto_C:
  00c0a	89 45 b8	 mov	 DWORD PTR _dir$[ebp], eax

; 2234 : 			getStringToken(bigtoken, '|', 5, sizeof(smalltoken) - 1, smalltoken);

  00c0d	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00c13	50		 push	 eax
  00c14	68 ff 07 00 00	 push	 2047			; 000007ffH
  00c19	6a 05		 push	 5
  00c1b	6a 7c		 push	 124			; 0000007cH
  00c1d	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00c23	51		 push	 ecx
  00c24	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00c29	83 c4 14	 add	 esp, 20			; 00000014H

; 2235 : 			graNo = atoi(smalltoken);

  00c2c	8b f4		 mov	 esi, esp
  00c2e	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00c34	50		 push	 eax
  00c35	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00c3b	83 c4 04	 add	 esp, 4
  00c3e	3b f4		 cmp	 esi, esp
  00c40	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00c45	89 45 ac	 mov	 DWORD PTR _graNo$[ebp], eax

; 2236 : 			getStringToken(bigtoken, '|', 6, sizeof(smalltoken) - 1, smalltoken);

  00c48	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00c4e	50		 push	 eax
  00c4f	68 ff 07 00 00	 push	 2047			; 000007ffH
  00c54	6a 06		 push	 6
  00c56	6a 7c		 push	 124			; 0000007cH
  00c58	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00c5e	51		 push	 ecx
  00c5f	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00c64	83 c4 14	 add	 esp, 20			; 00000014H

; 2237 : 			x = atoi(smalltoken);

  00c67	8b f4		 mov	 esi, esp
  00c69	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00c6f	50		 push	 eax
  00c70	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00c76	83 c4 04	 add	 esp, 4
  00c79	3b f4		 cmp	 esi, esp
  00c7b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00c80	89 45 d0	 mov	 DWORD PTR _x$[ebp], eax

; 2238 : 			getStringToken(bigtoken, '|', 7, sizeof(smalltoken) - 1, smalltoken);

  00c83	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00c89	50		 push	 eax
  00c8a	68 ff 07 00 00	 push	 2047			; 000007ffH
  00c8f	6a 07		 push	 7
  00c91	6a 7c		 push	 124			; 0000007cH
  00c93	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR _bigtoken$[ebp]
  00c99	51		 push	 ecx
  00c9a	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00c9f	83 c4 14	 add	 esp, 20			; 00000014H

; 2239 : 			y = atoi(smalltoken);

  00ca2	8b f4		 mov	 esi, esp
  00ca4	8d 85 3c ef ff
	ff		 lea	 eax, DWORD PTR _smalltoken$[ebp]
  00caa	50		 push	 eax
  00cab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00cb1	83 c4 04	 add	 esp, 4
  00cb4	3b f4		 cmp	 esi, esp
  00cb6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00cbb	89 45 c4	 mov	 DWORD PTR _y$[ebp], eax

; 2240 : 			setNpcCharObj( id, graNo, x, y, dir, "", name, "",

  00cbe	6a 00		 push	 0
  00cc0	6a 00		 push	 0
  00cc2	6a 00		 push	 0
  00cc4	6a 02		 push	 2
  00cc6	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _height$[ebp]
  00ccc	50		 push	 eax
  00ccd	6a 00		 push	 0
  00ccf	8b 4d 94	 mov	 ecx, DWORD PTR _nameColor$[ebp]
  00cd2	51		 push	 ecx
  00cd3	8b 95 08 cf ff
	ff		 mov	 edx, DWORD PTR _petlevel$[ebp]
  00cd9	52		 push	 edx
  00cda	8d 85 14 cf ff
	ff		 lea	 eax, DWORD PTR _petname$[ebp]
  00ce0	50		 push	 eax
  00ce1	8b 4d a0	 mov	 ecx, DWORD PTR _level$[ebp]
  00ce4	51		 push	 ecx
  00ce5	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00cea	8d 95 34 e7 ff
	ff		 lea	 edx, DWORD PTR _name$[ebp]
  00cf0	52		 push	 edx
  00cf1	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00cf6	8b 45 b8	 mov	 eax, DWORD PTR _dir$[ebp]
  00cf9	50		 push	 eax
  00cfa	8b 4d c4	 mov	 ecx, DWORD PTR _y$[ebp]
  00cfd	51		 push	 ecx
  00cfe	8b 55 d0	 mov	 edx, DWORD PTR _x$[ebp]
  00d01	52		 push	 edx
  00d02	8b 45 ac	 mov	 eax, DWORD PTR _graNo$[ebp]
  00d05	50		 push	 eax
  00d06	8b 4d dc	 mov	 ecx, DWORD PTR _id$[ebp]
  00d09	51		 push	 ecx
  00d0a	e8 00 00 00 00	 call	 ?setNpcCharObj@@YAXHHHHHPAD00H0HHHHHHHH@Z ; setNpcCharObj
  00d0f	83 c4 48	 add	 esp, 72			; 00000048H

; 2241 : 				level, petname, petlevel, nameColor, 0, height, 2, 0
; 2242 : #ifdef _NPC_PICTURE
; 2243 : 			,0 
; 2244 : #endif
; 2245 : #ifdef _NB_文字称号
; 2246 : 			,"",0
; 2247 : #endif
; 2248 : #ifdef _NB_任务指引
; 2249 : 			,0
; 2250 : #endif
; 2251 : 			);
; 2252 : 			ptAct = getCharObjAct( id );

  00d12	8b 45 dc	 mov	 eax, DWORD PTR _id$[ebp]
  00d15	50		 push	 eax
  00d16	e8 00 00 00 00	 call	 ?getCharObjAct@@YAPAUaction@@H@Z ; getCharObjAct
  00d1b	83 c4 04	 add	 esp, 4
  00d1e	89 85 b4 ce ff
	ff		 mov	 DWORD PTR _ptAct$[ebp], eax
$LN5@lssproto_C:

; 2253 : 			break;
; 2254 : 		}
; 2255 : #else
; 2256 : 		getStringToken(bigtoken , '|' , 11 , sizeof(smalltoken) - 1, smalltoken);
; 2257 : 		if ( strlen(smalltoken) > 0 ){
; 2258 : 			// NPC?雪
; 2259 : 			charType = getIntegerToken(bigtoken, '|', 1 );
; 2260 : 			getStringToken(bigtoken, '|', 2, sizeof(smalltoken) - 1, smalltoken);
; 2261 : 			id = a62toi(smalltoken);
; 2262 : 			getStringToken(bigtoken, '|', 3, sizeof(smalltoken) - 1, smalltoken);
; 2263 : 			x = atoi(smalltoken);
; 2264 : 			getStringToken(bigtoken, '|', 4, sizeof(smalltoken) - 1, smalltoken);
; 2265 : 			y = atoi(smalltoken);
; 2266 : 			getStringToken(bigtoken, '|', 5, sizeof(smalltoken) - 1, smalltoken);
; 2267 : 			dir = (atoi(smalltoken) + 3) % 8;
; 2268 : 			getStringToken(bigtoken, '|', 6, sizeof(smalltoken) - 1, smalltoken);
; 2269 : 			graNo = atoi(smalltoken);
; 2270 : 			getStringToken(bigtoken, '|', 7, sizeof(smalltoken) - 1,smalltoken);
; 2271 : 			level = atoi(smalltoken);
; 2272 : 			nameColor = getIntegerToken(bigtoken, '|', 8 );
; 2273 : 			getStringToken(bigtoken , '|' , 9 , sizeof(name) - 1, name );
; 2274 : 			makeStringFromEscaped(name);
; 2275 : 			getStringToken(bigtoken , '|' , 10 , sizeof( freeName ) - 1, freeName );
; 2276 : 			makeStringFromEscaped( freeName );
; 2277 : 			getStringToken(bigtoken, '|', 11, sizeof(smalltoken) - 1, smalltoken);
; 2278 : 			walkable = atoi(smalltoken);
; 2279 : 			getStringToken(bigtoken, '|', 12, sizeof(smalltoken) - 1, smalltoken);
; 2280 : 			height = atoi(smalltoken);
; 2281 : 			charNameColor = getIntegerToken(bigtoken, '|', 13 );
; 2282 : 			getStringToken(bigtoken , '|' , 14, sizeof( fmname ) - 1, fmname );
; 2283 : 			makeStringFromEscaped( fmname );
; 2284 : 			getStringToken(bigtoken , '|' , 15 , sizeof( petname ) - 1, petname );
; 2285 : 			makeStringFromEscaped( petname );
; 2286 : 			getStringToken(bigtoken, '|', 16, sizeof(smalltoken) - 1, smalltoken);
; 2287 : 			petlevel = atoi(smalltoken);
; 2288 : 			if ( charNameColor < 0 )
; 2289 : 				charNameColor = 0;
; 2290 : 
; 2291 : 			if ( pc.id == id ){
; 2292 : 				if ( pc.ptAct == NULL ){
; 2293 : 					createPc( graNo, x, y, dir );
; 2294 : 					updataPcAct();
; 2295 : 				}else{
; 2296 : 					setPcGraNo( graNo, pc.dir );
; 2297 : 				}
; 2298 : 				updateMapArea();
; 2299 : 				setPcParam( name, freeName, level, petname, petlevel, nameColor, walkable, height );			
; 2300 : 				setPcNameColor( charNameColor );
; 2301 : 				if ( (pc.status & CHR_STATUS_LEADER) != 0
; 2302 : 				 && party[0].useFlag != 0 ){
; 2303 : 					party[0].level = pc.level;
; 2304 : 					strcpy( party[0].name, pc.name );
; 2305 : 				}
; 2306 : 				for ( j = 0; j < MAX_PARTY; j++ ){
; 2307 : 					if ( party[j].useFlag != 0 && party[j].id == id ){
; 2308 : 						party[j].ptAct = pc.ptAct;
; 2309 : 						setPcParty();
; 2310 : 						if ( j == 0 ){
; 2311 : 							setPcLeader();
; 2312 : 						}
; 2313 : 						break;
; 2314 : 					}
; 2315 : 				}
; 2316 : 			}else{
; 2317 : 				setNpcCharObj( id, graNo, x, y, dir, fmname, name, freeName,
; 2318 : 					level, petname, petlevel, nameColor, walkable, height, charType
; 2319 : #ifdef _NPC_PICTURE
; 2320 : 					, 0 
; 2321 : #endif
; 2322 : #ifdef _NB_文字称号
; 2323 : 					,"",0
; 2324 : #endif
; 2325 : #ifdef _NB_任务指引	
; 2326 : 					,0
; 2327 : #endif
; 2328 : 					);
; 2329 : 				ptAct = getCharObjAct( id );
; 2330 : 				if ( ptAct != NULL ){
; 2331 : 					for ( j = 0; j < MAX_PARTY; j++ ){
; 2332 : 						if ( party[j].useFlag != 0 && party[j].id == id ){
; 2333 : 							party[j].ptAct = ptAct;
; 2334 : 							setCharParty( ptAct );
; 2335 : 							if ( j == 0 ){
; 2336 : 								setCharLeader( ptAct );
; 2337 : 							}
; 2338 : 							break;
; 2339 : 						}
; 2340 : 					}
; 2341 : 					setCharNameColor( ptAct, charNameColor );
; 2342 : 				}
; 2343 : 			}
; 2344 : 		}else{
; 2345 : 			getStringToken(bigtoken, '|', 6, sizeof(smalltoken) - 1, smalltoken);
; 2346 : 			if ( strlen(smalltoken) > 0 ){
; 2347 : 				getStringToken(bigtoken, '|', 1, sizeof(smalltoken) - 1, smalltoken);
; 2348 : 				id = a62toi(smalltoken);
; 2349 : 				getStringToken(bigtoken, '|', 2, sizeof(smalltoken) - 1, smalltoken);
; 2350 : 				x = atoi(smalltoken);
; 2351 : 				getStringToken(bigtoken, '|', 3, sizeof(smalltoken) - 1, smalltoken);
; 2352 : 				y = atoi(smalltoken);
; 2353 : 				getStringToken(bigtoken, '|', 4, sizeof(smalltoken) - 1, smalltoken);
; 2354 : 				graNo = atoi(smalltoken);
; 2355 : 				classNo = getIntegerToken(bigtoken, '|', 5 );
; 2356 : 				getStringToken(bigtoken, '|', 6, sizeof( info ) - 1, info );
; 2357 : 				makeStringFromEscaped( info );
; 2358 : 				setItemCharObj( id, graNo, x, y, 0, classNo, info );
; 2359 : 			}else{
; 2360 : 				getStringToken(bigtoken, '|', 4, sizeof(smalltoken) - 1, smalltoken);
; 2361 : 				if ( strlen(smalltoken) > 0 ){
; 2362 : 					getStringToken(bigtoken, '|', 1, sizeof(smalltoken) - 1, smalltoken);
; 2363 : 					id = a62toi(smalltoken);
; 2364 : 					getStringToken(bigtoken, '|', 2, sizeof(smalltoken) - 1, smalltoken);
; 2365 : 					x = atoi(smalltoken);
; 2366 : 					getStringToken(bigtoken, '|', 3, sizeof(smalltoken) - 1, smalltoken);
; 2367 : 					y = atoi(smalltoken);
; 2368 : 					getStringToken(bigtoken, '|', 4, sizeof(smalltoken) - 1, smalltoken);
; 2369 : 					money = atoi(smalltoken);
; 2370 : 					sprintf( info, "%d Stone", money );
; 2371 : 					if ( money > 10000 ){
; 2372 : 						setMoneyCharObj( id, 24050, x, y, 0, money, info );
; 2373 : 					}else
; 2374 : 					if ( money > 1000 ){
; 2375 : 						setMoneyCharObj( id, 24051, x, y, 0, money, info );
; 2376 : 					}else{
; 2377 : 						setMoneyCharObj( id, 24052, x, y, 0, money, info );
; 2378 : 					}
; 2379 : 				}
; 2380 : 			}
; 2381 : 		}
; 2382 : #endif
; 2383 : 	}

  00d24	e9 2a f3 ff ff	 jmp	 $LN2@lssproto_C
$LN1@lssproto_C:

; 2384 : 
; 2385 : }

  00d29	52		 push	 edx
  00d2a	8b cd		 mov	 ecx, ebp
  00d2c	50		 push	 eax
  00d2d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN46@lssproto_C
  00d33	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00d38	58		 pop	 eax
  00d39	5a		 pop	 edx
  00d3a	5f		 pop	 edi
  00d3b	5e		 pop	 esi
  00d3c	5b		 pop	 ebx
  00d3d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d40	33 cd		 xor	 ecx, ebp
  00d42	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d47	81 c4 54 37 00
	00		 add	 esp, 14164		; 00003754H
  00d4d	3b ec		 cmp	 ebp, esp
  00d4f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00d54	8b e5		 mov	 esp, ebp
  00d56	5d		 pop	 ebp
  00d57	c3		 ret	 0
$LN46@lssproto_C:
  00d58	07 00 00 00	 DD	 7
  00d5c	00 00 00 00	 DD	 $LN45@lssproto_C
$LN45@lssproto_C:
  00d60	44 f7 ff ff	 DD	 -2236			; fffff744H
  00d64	00 08 00 00	 DD	 2048			; 00000800H
  00d68	00 00 00 00	 DD	 $LN38@lssproto_C
  00d6c	3c ef ff ff	 DD	 -4292			; ffffef3cH
  00d70	00 08 00 00	 DD	 2048			; 00000800H
  00d74	00 00 00 00	 DD	 $LN39@lssproto_C
  00d78	34 e7 ff ff	 DD	 -6348			; ffffe734H
  00d7c	00 08 00 00	 DD	 2048			; 00000800H
  00d80	00 00 00 00	 DD	 $LN40@lssproto_C
  00d84	2c df ff ff	 DD	 -8404			; ffffdf2cH
  00d88	00 08 00 00	 DD	 2048			; 00000800H
  00d8c	00 00 00 00	 DD	 $LN41@lssproto_C
  00d90	24 db ff ff	 DD	 -9436			; ffffdb24H
  00d94	00 04 00 00	 DD	 1024			; 00000400H
  00d98	00 00 00 00	 DD	 $LN42@lssproto_C
  00d9c	1c d3 ff ff	 DD	 -11492			; ffffd31cH
  00da0	00 08 00 00	 DD	 2048			; 00000800H
  00da4	00 00 00 00	 DD	 $LN43@lssproto_C
  00da8	14 cf ff ff	 DD	 -12524			; ffffcf14H
  00dac	00 04 00 00	 DD	 1024			; 00000400H
  00db0	00 00 00 00	 DD	 $LN44@lssproto_C
$LN44@lssproto_C:
  00db4	70		 DB	 112			; 00000070H
  00db5	65		 DB	 101			; 00000065H
  00db6	74		 DB	 116			; 00000074H
  00db7	6e		 DB	 110			; 0000006eH
  00db8	61		 DB	 97			; 00000061H
  00db9	6d		 DB	 109			; 0000006dH
  00dba	65		 DB	 101			; 00000065H
  00dbb	00		 DB	 0
$LN43@lssproto_C:
  00dbc	66		 DB	 102			; 00000066H
  00dbd	6d		 DB	 109			; 0000006dH
  00dbe	6e		 DB	 110			; 0000006eH
  00dbf	61		 DB	 97			; 00000061H
  00dc0	6d		 DB	 109			; 0000006dH
  00dc1	65		 DB	 101			; 00000065H
  00dc2	00		 DB	 0
$LN42@lssproto_C:
  00dc3	69		 DB	 105			; 00000069H
  00dc4	6e		 DB	 110			; 0000006eH
  00dc5	66		 DB	 102			; 00000066H
  00dc6	6f		 DB	 111			; 0000006fH
  00dc7	00		 DB	 0
$LN41@lssproto_C:
  00dc8	66		 DB	 102			; 00000066H
  00dc9	72		 DB	 114			; 00000072H
  00dca	65		 DB	 101			; 00000065H
  00dcb	65		 DB	 101			; 00000065H
  00dcc	4e		 DB	 78			; 0000004eH
  00dcd	61		 DB	 97			; 00000061H
  00dce	6d		 DB	 109			; 0000006dH
  00dcf	65		 DB	 101			; 00000065H
  00dd0	00		 DB	 0
$LN40@lssproto_C:
  00dd1	6e		 DB	 110			; 0000006eH
  00dd2	61		 DB	 97			; 00000061H
  00dd3	6d		 DB	 109			; 0000006dH
  00dd4	65		 DB	 101			; 00000065H
  00dd5	00		 DB	 0
$LN39@lssproto_C:
  00dd6	73		 DB	 115			; 00000073H
  00dd7	6d		 DB	 109			; 0000006dH
  00dd8	61		 DB	 97			; 00000061H
  00dd9	6c		 DB	 108			; 0000006cH
  00dda	6c		 DB	 108			; 0000006cH
  00ddb	74		 DB	 116			; 00000074H
  00ddc	6f		 DB	 111			; 0000006fH
  00ddd	6b		 DB	 107			; 0000006bH
  00dde	65		 DB	 101			; 00000065H
  00ddf	6e		 DB	 110			; 0000006eH
  00de0	00		 DB	 0
$LN38@lssproto_C:
  00de1	62		 DB	 98			; 00000062H
  00de2	69		 DB	 105			; 00000069H
  00de3	67		 DB	 103			; 00000067H
  00de4	74		 DB	 116			; 00000074H
  00de5	6f		 DB	 111			; 0000006fH
  00de6	6b		 DB	 107			; 0000006bH
  00de7	65		 DB	 101			; 00000065H
  00de8	6e		 DB	 110			; 0000006eH
  00de9	00		 DB	 0
  00dea	66 90		 npad	 2
$LN49@lssproto_C:
  00dec	00 00 00 00	 DD	 $LN17@lssproto_C
  00df0	00 00 00 00	 DD	 $LN30@lssproto_C
  00df4	00 00 00 00	 DD	 $LN31@lssproto_C
  00df8	00 00 00 00	 DD	 $LN36@lssproto_C
?lssproto_C_recv@@YAXHPAD@Z ENDP			; lssproto_C_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_M_recv@@YAXHHHHHHPAD@Z
_TEXT	SEGMENT
_i$1 = -67668						; size = 4
_pal$2 = -67656						; size = 4
_strPal$3 = -67644					; size = 32
_flag$ = -67604						; size = 4
_i$ = -67592						; size = 4
_event$ = -67580					; size = 4096
_parts$ = -63476					; size = 4096
_tile$ = -59372						; size = 4096
_tmp$ = -55268						; size = 100
_eventstring$ = -55160					; size = 18192
_partsstring$ = -36960					; size = 18192
_tilestring$ = -18760					; size = 18192
_floorName$ = -560					; size = 32
_showString$ = -520					; size = 512
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_fl$ = 12						; size = 4
_x1$ = 16						; size = 4
_y1$ = 20						; size = 4
_x2$ = 24						; size = 4
_y2$ = 28						; size = 4
_data$ = 32						; size = 4
?lssproto_M_recv@@YAXHHHHHHPAD@Z PROC			; lssproto_M_recv, COMDAT

; 1884 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 58 0e 01 00	 mov	 eax, 69208		; 00010e58H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8d bd a8 f1 fe
	ff		 lea	 edi, DWORD PTR [ebp-69208]
  00016	b9 96 43 00 00	 mov	 ecx, 17302		; 00004396H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1885 : 	char showString[512], floorName[32], tilestring[18192], partsstring[18192], eventstring[18192], tmp[100];
; 1886 : 	unsigned short tile[2048] , parts[2048], event[2048];
; 1887 : 	int i, flag;
; 1888 : 
; 1889 : 	if (logOutFlag)

  0002c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  00033	74 05		 je	 SHORT $LN8@lssproto_M

; 1890 : 		return;

  00035	e9 e8 03 00 00	 jmp	 $LN1@lssproto_M
$LN8@lssproto_M:

; 1891 : 
; 1892 : #ifdef DEBUGPUSH
; 1893 :     char msg[800];
; 1894 :     sprintf(msg , "??????????????FL%d %d,%d-%d,%d", fl, x1, y1, x2, y2);
; 1895 :     PUSH(msg);
; 1896 : #endif
; 1897 : 	getStringToken(data, '|', 1, sizeof(showString) - 1, showString);

  0003a	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _showString$[ebp]
  00040	50		 push	 eax
  00041	68 ff 01 00 00	 push	 511			; 000001ffH
  00046	6a 01		 push	 1
  00048	6a 7c		 push	 124			; 0000007cH
  0004a	8b 4d 20	 mov	 ecx, DWORD PTR _data$[ebp]
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00053	83 c4 14	 add	 esp, 20			; 00000014H

; 1898 : 	makeStringFromEscaped(showString);

  00056	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _showString$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  00062	83 c4 04	 add	 esp, 4

; 1899 : 	if (nowFloor == fl)

  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nowFloor@@3HA ; nowFloor
  0006a	3b 45 0c	 cmp	 eax, DWORD PTR _fl$[ebp]
  0006d	0f 85 51 01 00
	00		 jne	 $LN9@lssproto_M

; 1900 : 	{
; 1901 : 		char strPal[32];
; 1902 : 
; 1903 : 		getStringToken(showString, '|', 1, sizeof(floorName) - 1, floorName);

  00073	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _floorName$[ebp]
  00079	50		 push	 eax
  0007a	6a 1f		 push	 31			; 0000001fH
  0007c	6a 01		 push	 1
  0007e	6a 7c		 push	 124			; 0000007cH
  00080	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _showString$[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0008c	83 c4 14	 add	 esp, 20			; 00000014H

; 1904 : 		if (strlen(floorName) <= FLOOR_NAME_LEN)

  0008f	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _floorName$[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 _strlen
  0009b	83 c4 04	 add	 esp, 4
  0009e	83 f8 18	 cmp	 eax, 24			; 00000018H
  000a1	77 16		 ja	 SHORT $LN10@lssproto_M

; 1905 : 			strcpy(nowFloorName, floorName);

  000a3	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _floorName$[ebp]
  000a9	50		 push	 eax
  000aa	68 00 00 00 00	 push	 OFFSET ?nowFloorName@@3PADA ; nowFloorName
  000af	e8 00 00 00 00	 call	 _strcpy
  000b4	83 c4 08	 add	 esp, 8

; 1906 : 		else

  000b7	eb 12		 jmp	 SHORT $LN11@lssproto_M
$LN10@lssproto_M:

; 1907 : 			strcpy(nowFloorName, "???");

  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_03BBKEAIF@?$DP?$DP?$DP?$AA@
  000be	68 00 00 00 00	 push	 OFFSET ?nowFloorName@@3PADA ; nowFloorName
  000c3	e8 00 00 00 00	 call	 _strcpy
  000c8	83 c4 08	 add	 esp, 8
$LN11@lssproto_M:

; 1908 : 		palNo = -2;

  000cb	c7 05 00 00 00
	00 fe ff ff ff	 mov	 DWORD PTR ?palNo@@3HA, -2 ; palNo, fffffffeH

; 1909 : 		getStringToken(showString, '|', 2, sizeof(strPal) - 1, strPal);

  000d5	8d 85 c4 f7 fe
	ff		 lea	 eax, DWORD PTR _strPal$3[ebp]
  000db	50		 push	 eax
  000dc	6a 1f		 push	 31			; 0000001fH
  000de	6a 02		 push	 2
  000e0	6a 7c		 push	 124			; 0000007cH
  000e2	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _showString$[ebp]
  000e8	51		 push	 ecx
  000e9	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  000ee	83 c4 14	 add	 esp, 20			; 00000014H

; 1910 : 		if (strlen(strPal) == 0)

  000f1	8d 85 c4 f7 fe
	ff		 lea	 eax, DWORD PTR _strPal$3[ebp]
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 _strlen
  000fd	83 c4 04	 add	 esp, 4
  00100	85 c0		 test	 eax, eax
  00102	75 36		 jne	 SHORT $LN12@lssproto_M

; 1911 : 		{
; 1912 : 			if (TimeZonePalChangeFlag == FALSE || loginFlag)

  00104	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?TimeZonePalChangeFlag@@3HA, 0 ; TimeZonePalChangeFlag
  0010b	74 09		 je	 SHORT $LN15@lssproto_M
  0010d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?loginFlag@@3HA, 0 ; loginFlag
  00114	74 1f		 je	 SHORT $LN14@lssproto_M
$LN15@lssproto_M:

; 1913 : 			{
; 1914 : 				palNo = -1;

  00116	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?palNo@@3HA, -1 ; palNo

; 1915 : 				palTime = 0;

  00120	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?palTime@@3HA, 0 ; palTime

; 1916 : 				drawTimeAnimeFlag = 1;

  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	66 a3 00 00 00
	00		 mov	 WORD PTR ?drawTimeAnimeFlag@@3FA, ax ; drawTimeAnimeFlag
$LN14@lssproto_M:

; 1917 : 			}
; 1918 : 		}
; 1919 : 		else

  00135	e9 8a 00 00 00	 jmp	 $LN9@lssproto_M
$LN12@lssproto_M:

; 1920 : 		{
; 1921 : 			int pal;
; 1922 : 
; 1923 : 			pal = atoi(strPal);

  0013a	8b f4		 mov	 esi, esp
  0013c	8d 85 c4 f7 fe
	ff		 lea	 eax, DWORD PTR _strPal$3[ebp]
  00142	50		 push	 eax
  00143	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00149	83 c4 04	 add	 esp, 4
  0014c	3b f4		 cmp	 esi, esp
  0014e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00153	89 85 b8 f7 fe
	ff		 mov	 DWORD PTR _pal$2[ebp], eax

; 1924 : 			if (pal >= 0)

  00159	83 bd b8 f7 fe
	ff 00		 cmp	 DWORD PTR _pal$2[ebp], 0
  00160	7c 31		 jl	 SHORT $LN16@lssproto_M

; 1925 : 			{
; 1926 : 				if (TimeZonePalChangeFlag == TRUE || loginFlag)

  00162	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?TimeZonePalChangeFlag@@3HA, 1 ; TimeZonePalChangeFlag
  00169	74 09		 je	 SHORT $LN19@lssproto_M
  0016b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?loginFlag@@3HA, 0 ; loginFlag
  00172	74 1d		 je	 SHORT $LN18@lssproto_M
$LN19@lssproto_M:

; 1927 : 				{
; 1928 : 					palNo = pal;

  00174	8b 85 b8 f7 fe
	ff		 mov	 eax, DWORD PTR _pal$2[ebp]
  0017a	a3 00 00 00 00	 mov	 DWORD PTR ?palNo@@3HA, eax ; palNo

; 1929 : 					palTime = 0;

  0017f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?palTime@@3HA, 0 ; palTime

; 1930 : 					drawTimeAnimeFlag = 0;

  00189	33 c0		 xor	 eax, eax
  0018b	66 a3 00 00 00
	00		 mov	 WORD PTR ?drawTimeAnimeFlag@@3FA, ax ; drawTimeAnimeFlag
$LN18@lssproto_M:

; 1931 : 				}
; 1932 : 			}
; 1933 : 			else

  00191	eb 31		 jmp	 SHORT $LN9@lssproto_M
$LN16@lssproto_M:

; 1934 : 			{
; 1935 : 				if (TimeZonePalChangeFlag == FALSE || loginFlag)

  00193	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?TimeZonePalChangeFlag@@3HA, 0 ; TimeZonePalChangeFlag
  0019a	74 09		 je	 SHORT $LN21@lssproto_M
  0019c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?loginFlag@@3HA, 0 ; loginFlag
  001a3	74 1f		 je	 SHORT $LN9@lssproto_M
$LN21@lssproto_M:

; 1936 : 				{
; 1937 : 					palNo = -1;

  001a5	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?palNo@@3HA, -1 ; palNo

; 1938 : 					palTime = 0;

  001af	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?palTime@@3HA, 0 ; palTime

; 1939 : 					drawTimeAnimeFlag = 1;

  001b9	b8 01 00 00 00	 mov	 eax, 1
  001be	66 a3 00 00 00
	00		 mov	 WORD PTR ?drawTimeAnimeFlag@@3FA, ax ; drawTimeAnimeFlag
$LN9@lssproto_M:

; 1940 : 				}
; 1941 : 			}
; 1942 : 		}
; 1943 : 	}
; 1944 : 
; 1945 : 
; 1946 : 	//JL fix 2017.9.25  修复组队跑的时候客户端卡的问题，因为会频繁收到此包，如果是队员则把后面的地图操作??掉
; 1947 : 	for (int i = 1; i < MAX_PARTY; i++)  //检测是否为队员

  001c4	c7 85 ac f7 fe
	ff 01 00 00 00	 mov	 DWORD PTR _i$1[ebp], 1
  001ce	eb 0f		 jmp	 SHORT $LN4@lssproto_M
$LN2@lssproto_M:
  001d0	8b 85 ac f7 fe
	ff		 mov	 eax, DWORD PTR _i$1[ebp]
  001d6	83 c0 01	 add	 eax, 1
  001d9	89 85 ac f7 fe
	ff		 mov	 DWORD PTR _i$1[ebp], eax
$LN4@lssproto_M:
  001df	83 bd ac f7 fe
	ff 05		 cmp	 DWORD PTR _i$1[ebp], 5
  001e6	7d 79		 jge	 SHORT $LN3@lssproto_M

; 1948 : 	{
; 1949 : 		if (party[i].useFlag != 0)

  001e8	6b 85 ac f7 fe
	ff 30		 imul	 eax, DWORD PTR _i$1[ebp], 48
  001ef	0f bf 88 00 00
	00 00		 movsx	 ecx, WORD PTR ?party@@3PAUPARTY@@A[eax]
  001f6	85 c9		 test	 ecx, ecx
  001f8	74 62		 je	 SHORT $LN22@lssproto_M

; 1950 : 		{
; 1951 : 			if (party[i].id == pc.id)

  001fa	6b 85 ac f7 fe
	ff 30		 imul	 eax, DWORD PTR _i$1[ebp], 48
  00201	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR ?party@@3PAUPARTY@@A[eax+4]
  00207	3b 0d 08 00 00
	00		 cmp	 ecx, DWORD PTR ?pc@@3UPC@@A+8
  0020d	75 4d		 jne	 SHORT $LN22@lssproto_M

; 1952 : 			{
; 1953 : 				if (mapEmptyFlag || floorChangeFlag)

  0020f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?mapEmptyFlag@@3HA, 0 ; mapEmptyFlag
  00216	75 09		 jne	 SHORT $LN25@lssproto_M
  00218	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?floorChangeFlag@@3HA, 0 ; floorChangeFlag
  0021f	74 2c		 je	 SHORT $LN24@lssproto_M
$LN25@lssproto_M:

; 1954 : 				{
; 1955 : 					if (nowFloor == fl)

  00221	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nowFloor@@3HA ; nowFloor
  00226	3b 45 0c	 cmp	 eax, DWORD PTR _fl$[ebp]
  00229	75 22		 jne	 SHORT $LN24@lssproto_M

; 1956 : 					{
; 1957 : 						redrawMap();

  0022b	e8 00 00 00 00	 call	 ?redrawMap@@YAXXZ	; redrawMap

; 1958 : 						floorChangeFlag = FALSE;

  00230	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?floorChangeFlag@@3HA, 0 ; floorChangeFlag

; 1959 : 						if (warpEffectStart)

  0023a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?warpEffectStart@@3HA, 0 ; warpEffectStart
  00241	74 0a		 je	 SHORT $LN24@lssproto_M

; 1960 : 							warpEffectOk = TRUE;

  00243	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?warpEffectOk@@3HA, 1 ; warpEffectOk
$LN24@lssproto_M:

; 1961 : 					}
; 1962 : 				}
; 1963 : 				loginFlag = FALSE;

  0024d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?loginFlag@@3HA, 0 ; loginFlag

; 1964 : 				return;

  00257	e9 c6 01 00 00	 jmp	 $LN1@lssproto_M
$LN22@lssproto_M:

; 1965 : 			}
; 1966 : 		}
; 1967 : 	}

  0025c	e9 6f ff ff ff	 jmp	 $LN2@lssproto_M
$LN3@lssproto_M:

; 1968 : 
; 1969 : 	getStringToken(data, '|', 2, sizeof(tilestring) - 1, tilestring);	

  00261	8d 85 b8 b6 ff
	ff		 lea	 eax, DWORD PTR _tilestring$[ebp]
  00267	50		 push	 eax
  00268	68 0f 47 00 00	 push	 18191			; 0000470fH
  0026d	6a 02		 push	 2
  0026f	6a 7c		 push	 124			; 0000007cH
  00271	8b 4d 20	 mov	 ecx, DWORD PTR _data$[ebp]
  00274	51		 push	 ecx
  00275	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0027a	83 c4 14	 add	 esp, 20			; 00000014H

; 1970 : 	getStringToken(data, '|', 3, sizeof(partsstring) - 1, partsstring);

  0027d	8d 85 a0 6f ff
	ff		 lea	 eax, DWORD PTR _partsstring$[ebp]
  00283	50		 push	 eax
  00284	68 0f 47 00 00	 push	 18191			; 0000470fH
  00289	6a 03		 push	 3
  0028b	6a 7c		 push	 124			; 0000007cH
  0028d	8b 4d 20	 mov	 ecx, DWORD PTR _data$[ebp]
  00290	51		 push	 ecx
  00291	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00296	83 c4 14	 add	 esp, 20			; 00000014H

; 1971 : 	getStringToken(data, '|', 4, sizeof(eventstring) - 1, eventstring);

  00299	8d 85 88 28 ff
	ff		 lea	 eax, DWORD PTR _eventstring$[ebp]
  0029f	50		 push	 eax
  002a0	68 0f 47 00 00	 push	 18191			; 0000470fH
  002a5	6a 04		 push	 4
  002a7	6a 7c		 push	 124			; 0000007cH
  002a9	8b 4d 20	 mov	 ecx, DWORD PTR _data$[ebp]
  002ac	51		 push	 ecx
  002ad	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  002b2	83 c4 14	 add	 esp, 20			; 00000014H

; 1972 : 	for (i = 0; ; i++)

  002b5	c7 85 f8 f7 fe
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  002bf	eb 0f		 jmp	 SHORT $LN7@lssproto_M
$LN5@lssproto_M:
  002c1	8b 85 f8 f7 fe
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  002c7	83 c0 01	 add	 eax, 1
  002ca	89 85 f8 f7 fe
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN7@lssproto_M:

; 1973 : 	{
; 1974 : 		flag = getStringToken(tilestring, ',', i + 1, sizeof(tmp) - 1, tmp);

  002d0	8d 85 1c 28 ff
	ff		 lea	 eax, DWORD PTR _tmp$[ebp]
  002d6	50		 push	 eax
  002d7	6a 63		 push	 99			; 00000063H
  002d9	8b 8d f8 f7 fe
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  002df	83 c1 01	 add	 ecx, 1
  002e2	51		 push	 ecx
  002e3	6a 2c		 push	 44			; 0000002cH
  002e5	8d 95 b8 b6 ff
	ff		 lea	 edx, DWORD PTR _tilestring$[ebp]
  002eb	52		 push	 edx
  002ec	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  002f1	83 c4 14	 add	 esp, 20			; 00000014H
  002f4	89 85 ec f7 fe
	ff		 mov	 DWORD PTR _flag$[ebp], eax

; 1975 : 		tile[i] = a62toi(tmp);

  002fa	8d 85 1c 28 ff
	ff		 lea	 eax, DWORD PTR _tmp$[ebp]
  00300	50		 push	 eax
  00301	e8 00 00 00 00	 call	 ?a62toi@@YAHPAD@Z	; a62toi
  00306	83 c4 04	 add	 esp, 4
  00309	8b 8d f8 f7 fe
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  0030f	66 89 84 4d 14
	18 ff ff	 mov	 WORD PTR _tile$[ebp+ecx*2], ax

; 1976 : 		getStringToken(partsstring, ',', i + 1, sizeof(tmp) - 1, tmp);

  00317	8d 85 1c 28 ff
	ff		 lea	 eax, DWORD PTR _tmp$[ebp]
  0031d	50		 push	 eax
  0031e	6a 63		 push	 99			; 00000063H
  00320	8b 8d f8 f7 fe
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00326	83 c1 01	 add	 ecx, 1
  00329	51		 push	 ecx
  0032a	6a 2c		 push	 44			; 0000002cH
  0032c	8d 95 a0 6f ff
	ff		 lea	 edx, DWORD PTR _partsstring$[ebp]
  00332	52		 push	 edx
  00333	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00338	83 c4 14	 add	 esp, 20			; 00000014H

; 1977 : 		parts[i] = a62toi(tmp);

  0033b	8d 85 1c 28 ff
	ff		 lea	 eax, DWORD PTR _tmp$[ebp]
  00341	50		 push	 eax
  00342	e8 00 00 00 00	 call	 ?a62toi@@YAHPAD@Z	; a62toi
  00347	83 c4 04	 add	 esp, 4
  0034a	8b 8d f8 f7 fe
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00350	66 89 84 4d 0c
	08 ff ff	 mov	 WORD PTR _parts$[ebp+ecx*2], ax

; 1978 : 		getStringToken(eventstring, ',', i + 1, sizeof(tmp) - 1, tmp);

  00358	8d 85 1c 28 ff
	ff		 lea	 eax, DWORD PTR _tmp$[ebp]
  0035e	50		 push	 eax
  0035f	6a 63		 push	 99			; 00000063H
  00361	8b 8d f8 f7 fe
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00367	83 c1 01	 add	 ecx, 1
  0036a	51		 push	 ecx
  0036b	6a 2c		 push	 44			; 0000002cH
  0036d	8d 95 88 28 ff
	ff		 lea	 edx, DWORD PTR _eventstring$[ebp]
  00373	52		 push	 edx
  00374	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00379	83 c4 14	 add	 esp, 20			; 00000014H

; 1979 : 		event[i] = a62toi(tmp);

  0037c	8d 85 1c 28 ff
	ff		 lea	 eax, DWORD PTR _tmp$[ebp]
  00382	50		 push	 eax
  00383	e8 00 00 00 00	 call	 ?a62toi@@YAHPAD@Z	; a62toi
  00388	83 c4 04	 add	 esp, 4
  0038b	8b 8d f8 f7 fe
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00391	66 89 84 4d 04
	f8 fe ff	 mov	 WORD PTR _event$[ebp+ecx*2], ax

; 1980 : 		if (flag == 1)

  00399	83 bd ec f7 fe
	ff 01		 cmp	 DWORD PTR _flag$[ebp], 1
  003a0	75 02		 jne	 SHORT $LN28@lssproto_M

; 1981 : 			break;

  003a2	eb 05		 jmp	 SHORT $LN6@lssproto_M
$LN28@lssproto_M:

; 1982 : 	}

  003a4	e9 18 ff ff ff	 jmp	 $LN5@lssproto_M
$LN6@lssproto_M:

; 1983 : 	writeMap(fl, x1, y1, x2, y2, tile, parts, event);

  003a9	8d 85 04 f8 fe
	ff		 lea	 eax, DWORD PTR _event$[ebp]
  003af	50		 push	 eax
  003b0	8d 8d 0c 08 ff
	ff		 lea	 ecx, DWORD PTR _parts$[ebp]
  003b6	51		 push	 ecx
  003b7	8d 95 14 18 ff
	ff		 lea	 edx, DWORD PTR _tile$[ebp]
  003bd	52		 push	 edx
  003be	8b 45 1c	 mov	 eax, DWORD PTR _y2$[ebp]
  003c1	50		 push	 eax
  003c2	8b 4d 18	 mov	 ecx, DWORD PTR _x2$[ebp]
  003c5	51		 push	 ecx
  003c6	8b 55 14	 mov	 edx, DWORD PTR _y1$[ebp]
  003c9	52		 push	 edx
  003ca	8b 45 10	 mov	 eax, DWORD PTR _x1$[ebp]
  003cd	50		 push	 eax
  003ce	8b 4d 0c	 mov	 ecx, DWORD PTR _fl$[ebp]
  003d1	51		 push	 ecx
  003d2	e8 00 00 00 00	 call	 ?writeMap@@YAHHHHHHPAG00@Z ; writeMap
  003d7	83 c4 20	 add	 esp, 32			; 00000020H

; 1984 : 	if (mapEmptyFlag || floorChangeFlag)

  003da	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?mapEmptyFlag@@3HA, 0 ; mapEmptyFlag
  003e1	75 09		 jne	 SHORT $LN30@lssproto_M
  003e3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?floorChangeFlag@@3HA, 0 ; floorChangeFlag
  003ea	74 2c		 je	 SHORT $LN29@lssproto_M
$LN30@lssproto_M:

; 1985 : 	{
; 1986 : 		if (nowFloor == fl)

  003ec	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nowFloor@@3HA ; nowFloor
  003f1	3b 45 0c	 cmp	 eax, DWORD PTR _fl$[ebp]
  003f4	75 22		 jne	 SHORT $LN29@lssproto_M

; 1987 : 		{
; 1988 : 			redrawMap();

  003f6	e8 00 00 00 00	 call	 ?redrawMap@@YAXXZ	; redrawMap

; 1989 : 			floorChangeFlag = FALSE;

  003fb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?floorChangeFlag@@3HA, 0 ; floorChangeFlag

; 1990 : 			if (warpEffectStart)

  00405	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?warpEffectStart@@3HA, 0 ; warpEffectStart
  0040c	74 0a		 je	 SHORT $LN29@lssproto_M

; 1991 : 				warpEffectOk = TRUE;

  0040e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?warpEffectOk@@3HA, 1 ; warpEffectOk
$LN29@lssproto_M:

; 1992 : 		}
; 1993 : 	}
; 1994 : 	loginFlag = FALSE;

  00418	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?loginFlag@@3HA, 0 ; loginFlag
$LN1@lssproto_M:

; 1995 : }

  00422	52		 push	 edx
  00423	8b cd		 mov	 ecx, ebp
  00425	50		 push	 eax
  00426	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN45@lssproto_M
  0042c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00431	58		 pop	 eax
  00432	5a		 pop	 edx
  00433	5f		 pop	 edi
  00434	5e		 pop	 esi
  00435	5b		 pop	 ebx
  00436	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00439	33 cd		 xor	 ecx, ebp
  0043b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00440	81 c4 58 0e 01
	00		 add	 esp, 69208		; 00010e58H
  00446	3b ec		 cmp	 ebp, esp
  00448	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0044d	8b e5		 mov	 esp, ebp
  0044f	5d		 pop	 ebp
  00450	c3		 ret	 0
  00451	0f 1f 00	 npad	 3
$LN45@lssproto_M:
  00454	0a 00 00 00	 DD	 10			; 0000000aH
  00458	00 00 00 00	 DD	 $LN44@lssproto_M
$LN44@lssproto_M:
  0045c	f8 fd ff ff	 DD	 -520			; fffffdf8H
  00460	00 02 00 00	 DD	 512			; 00000200H
  00464	00 00 00 00	 DD	 $LN34@lssproto_M
  00468	d0 fd ff ff	 DD	 -560			; fffffdd0H
  0046c	20 00 00 00	 DD	 32			; 00000020H
  00470	00 00 00 00	 DD	 $LN35@lssproto_M
  00474	b8 b6 ff ff	 DD	 -18760			; ffffb6b8H
  00478	10 47 00 00	 DD	 18192			; 00004710H
  0047c	00 00 00 00	 DD	 $LN36@lssproto_M
  00480	a0 6f ff ff	 DD	 -36960			; ffff6fa0H
  00484	10 47 00 00	 DD	 18192			; 00004710H
  00488	00 00 00 00	 DD	 $LN37@lssproto_M
  0048c	88 28 ff ff	 DD	 -55160			; ffff2888H
  00490	10 47 00 00	 DD	 18192			; 00004710H
  00494	00 00 00 00	 DD	 $LN38@lssproto_M
  00498	1c 28 ff ff	 DD	 -55268			; ffff281cH
  0049c	64 00 00 00	 DD	 100			; 00000064H
  004a0	00 00 00 00	 DD	 $LN39@lssproto_M
  004a4	14 18 ff ff	 DD	 -59372			; ffff1814H
  004a8	00 10 00 00	 DD	 4096			; 00001000H
  004ac	00 00 00 00	 DD	 $LN40@lssproto_M
  004b0	0c 08 ff ff	 DD	 -63476			; ffff080cH
  004b4	00 10 00 00	 DD	 4096			; 00001000H
  004b8	00 00 00 00	 DD	 $LN41@lssproto_M
  004bc	04 f8 fe ff	 DD	 -67580			; fffef804H
  004c0	00 10 00 00	 DD	 4096			; 00001000H
  004c4	00 00 00 00	 DD	 $LN42@lssproto_M
  004c8	c4 f7 fe ff	 DD	 -67644			; fffef7c4H
  004cc	20 00 00 00	 DD	 32			; 00000020H
  004d0	00 00 00 00	 DD	 $LN43@lssproto_M
$LN43@lssproto_M:
  004d4	73		 DB	 115			; 00000073H
  004d5	74		 DB	 116			; 00000074H
  004d6	72		 DB	 114			; 00000072H
  004d7	50		 DB	 80			; 00000050H
  004d8	61		 DB	 97			; 00000061H
  004d9	6c		 DB	 108			; 0000006cH
  004da	00		 DB	 0
$LN42@lssproto_M:
  004db	65		 DB	 101			; 00000065H
  004dc	76		 DB	 118			; 00000076H
  004dd	65		 DB	 101			; 00000065H
  004de	6e		 DB	 110			; 0000006eH
  004df	74		 DB	 116			; 00000074H
  004e0	00		 DB	 0
$LN41@lssproto_M:
  004e1	70		 DB	 112			; 00000070H
  004e2	61		 DB	 97			; 00000061H
  004e3	72		 DB	 114			; 00000072H
  004e4	74		 DB	 116			; 00000074H
  004e5	73		 DB	 115			; 00000073H
  004e6	00		 DB	 0
$LN40@lssproto_M:
  004e7	74		 DB	 116			; 00000074H
  004e8	69		 DB	 105			; 00000069H
  004e9	6c		 DB	 108			; 0000006cH
  004ea	65		 DB	 101			; 00000065H
  004eb	00		 DB	 0
$LN39@lssproto_M:
  004ec	74		 DB	 116			; 00000074H
  004ed	6d		 DB	 109			; 0000006dH
  004ee	70		 DB	 112			; 00000070H
  004ef	00		 DB	 0
$LN38@lssproto_M:
  004f0	65		 DB	 101			; 00000065H
  004f1	76		 DB	 118			; 00000076H
  004f2	65		 DB	 101			; 00000065H
  004f3	6e		 DB	 110			; 0000006eH
  004f4	74		 DB	 116			; 00000074H
  004f5	73		 DB	 115			; 00000073H
  004f6	74		 DB	 116			; 00000074H
  004f7	72		 DB	 114			; 00000072H
  004f8	69		 DB	 105			; 00000069H
  004f9	6e		 DB	 110			; 0000006eH
  004fa	67		 DB	 103			; 00000067H
  004fb	00		 DB	 0
$LN37@lssproto_M:
  004fc	70		 DB	 112			; 00000070H
  004fd	61		 DB	 97			; 00000061H
  004fe	72		 DB	 114			; 00000072H
  004ff	74		 DB	 116			; 00000074H
  00500	73		 DB	 115			; 00000073H
  00501	73		 DB	 115			; 00000073H
  00502	74		 DB	 116			; 00000074H
  00503	72		 DB	 114			; 00000072H
  00504	69		 DB	 105			; 00000069H
  00505	6e		 DB	 110			; 0000006eH
  00506	67		 DB	 103			; 00000067H
  00507	00		 DB	 0
$LN36@lssproto_M:
  00508	74		 DB	 116			; 00000074H
  00509	69		 DB	 105			; 00000069H
  0050a	6c		 DB	 108			; 0000006cH
  0050b	65		 DB	 101			; 00000065H
  0050c	73		 DB	 115			; 00000073H
  0050d	74		 DB	 116			; 00000074H
  0050e	72		 DB	 114			; 00000072H
  0050f	69		 DB	 105			; 00000069H
  00510	6e		 DB	 110			; 0000006eH
  00511	67		 DB	 103			; 00000067H
  00512	00		 DB	 0
$LN35@lssproto_M:
  00513	66		 DB	 102			; 00000066H
  00514	6c		 DB	 108			; 0000006cH
  00515	6f		 DB	 111			; 0000006fH
  00516	6f		 DB	 111			; 0000006fH
  00517	72		 DB	 114			; 00000072H
  00518	4e		 DB	 78			; 0000004eH
  00519	61		 DB	 97			; 00000061H
  0051a	6d		 DB	 109			; 0000006dH
  0051b	65		 DB	 101			; 00000065H
  0051c	00		 DB	 0
$LN34@lssproto_M:
  0051d	73		 DB	 115			; 00000073H
  0051e	68		 DB	 104			; 00000068H
  0051f	6f		 DB	 111			; 0000006fH
  00520	77		 DB	 119			; 00000077H
  00521	53		 DB	 83			; 00000053H
  00522	74		 DB	 116			; 00000074H
  00523	72		 DB	 114			; 00000072H
  00524	69		 DB	 105			; 00000069H
  00525	6e		 DB	 110			; 0000006eH
  00526	67		 DB	 103			; 00000067H
  00527	00		 DB	 0
?lssproto_M_recv@@YAXHHHHHHPAD@Z ENDP			; lssproto_M_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_MC_recv@@YAXHHHHHHHHHPAD@Z
_TEXT	SEGMENT
_i$1 = -624						; size = 4
_pal$2 = -612						; size = 4
_strPal$3 = -600					; size = 32
_floorName$ = -560					; size = 32
_showString$ = -520					; size = 512
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_fl$ = 12						; size = 4
_x1$ = 16						; size = 4
_y1$ = 20						; size = 4
_x2$ = 24						; size = 4
_y2$ = 28						; size = 4
_tileSum$ = 32						; size = 4
_partsSum$ = 36						; size = 4
_eventSum$ = 40						; size = 4
_data$ = 44						; size = 4
?lssproto_MC_recv@@YAXHHHHHHHHHPAD@Z PROC		; lssproto_MC_recv, COMDAT

; 1791 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 03 00
	00		 sub	 esp, 1012		; 000003f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 0c fc ff
	ff		 lea	 edi, DWORD PTR [ebp-1012]
  00012	b9 fd 00 00 00	 mov	 ecx, 253		; 000000fdH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1792 : 	char showString[512], floorName[32];
; 1793 : 
; 1794 : 	if (logOutFlag)

  00028	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  0002f	74 05		 je	 SHORT $LN5@lssproto_M

; 1795 : 		return;

  00031	e9 67 02 00 00	 jmp	 $LN1@lssproto_M
$LN5@lssproto_M:

; 1796 : 
; 1797 : #ifdef DEBUGPUSH
; 1798 :     char msg[800];
; 1799 :     sprintf(msg, "???????????????FL%d %d,%d-%d,%d (%ud/%ud)", fl, x1, y1, x2, y2, tileSum, partsSum);
; 1800 :     PUSH(msg);
; 1801 : #endif
; 1802 : 	getStringToken(data, '|', 1, sizeof(showString) - 1, showString);

  00036	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _showString$[ebp]
  0003c	50		 push	 eax
  0003d	68 ff 01 00 00	 push	 511			; 000001ffH
  00042	6a 01		 push	 1
  00044	6a 7c		 push	 124			; 0000007cH
  00046	8b 4d 2c	 mov	 ecx, DWORD PTR _data$[ebp]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0004f	83 c4 14	 add	 esp, 20			; 00000014H

; 1803 : 	makeStringFromEscaped(showString);

  00052	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _showString$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  0005e	83 c4 04	 add	 esp, 4

; 1804 : 	if (nowFloor == fl)

  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nowFloor@@3HA ; nowFloor
  00066	3b 45 0c	 cmp	 eax, DWORD PTR _fl$[ebp]
  00069	0f 85 51 01 00
	00		 jne	 $LN6@lssproto_M

; 1805 : 	{
; 1806 : 		char strPal[32];
; 1807 : 
; 1808 : 		getStringToken(showString, '|', 1, sizeof(floorName) - 1, floorName);

  0006f	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _floorName$[ebp]
  00075	50		 push	 eax
  00076	6a 1f		 push	 31			; 0000001fH
  00078	6a 01		 push	 1
  0007a	6a 7c		 push	 124			; 0000007cH
  0007c	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _showString$[ebp]
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00088	83 c4 14	 add	 esp, 20			; 00000014H

; 1809 : 		if (strlen(floorName) <= FLOOR_NAME_LEN)

  0008b	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _floorName$[ebp]
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 _strlen
  00097	83 c4 04	 add	 esp, 4
  0009a	83 f8 18	 cmp	 eax, 24			; 00000018H
  0009d	77 16		 ja	 SHORT $LN7@lssproto_M

; 1810 : 			strcpy(nowFloorName, floorName);

  0009f	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _floorName$[ebp]
  000a5	50		 push	 eax
  000a6	68 00 00 00 00	 push	 OFFSET ?nowFloorName@@3PADA ; nowFloorName
  000ab	e8 00 00 00 00	 call	 _strcpy
  000b0	83 c4 08	 add	 esp, 8

; 1811 : 		else

  000b3	eb 12		 jmp	 SHORT $LN8@lssproto_M
$LN7@lssproto_M:

; 1812 : 			strcpy(nowFloorName, "???");

  000b5	68 00 00 00 00	 push	 OFFSET ??_C@_03BBKEAIF@?$DP?$DP?$DP?$AA@
  000ba	68 00 00 00 00	 push	 OFFSET ?nowFloorName@@3PADA ; nowFloorName
  000bf	e8 00 00 00 00	 call	 _strcpy
  000c4	83 c4 08	 add	 esp, 8
$LN8@lssproto_M:

; 1813 : 		palNo = -2;

  000c7	c7 05 00 00 00
	00 fe ff ff ff	 mov	 DWORD PTR ?palNo@@3HA, -2 ; palNo, fffffffeH

; 1814 : 		getStringToken(showString, '|', 2, sizeof(strPal) - 1, strPal);

  000d1	8d 85 a8 fd ff
	ff		 lea	 eax, DWORD PTR _strPal$3[ebp]
  000d7	50		 push	 eax
  000d8	6a 1f		 push	 31			; 0000001fH
  000da	6a 02		 push	 2
  000dc	6a 7c		 push	 124			; 0000007cH
  000de	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _showString$[ebp]
  000e4	51		 push	 ecx
  000e5	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  000ea	83 c4 14	 add	 esp, 20			; 00000014H

; 1815 : 		if (strlen(strPal) == 0)

  000ed	8d 85 a8 fd ff
	ff		 lea	 eax, DWORD PTR _strPal$3[ebp]
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 _strlen
  000f9	83 c4 04	 add	 esp, 4
  000fc	85 c0		 test	 eax, eax
  000fe	75 36		 jne	 SHORT $LN9@lssproto_M

; 1816 : 		{
; 1817 : 			if (TimeZonePalChangeFlag == FALSE || loginFlag)

  00100	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?TimeZonePalChangeFlag@@3HA, 0 ; TimeZonePalChangeFlag
  00107	74 09		 je	 SHORT $LN12@lssproto_M
  00109	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?loginFlag@@3HA, 0 ; loginFlag
  00110	74 1f		 je	 SHORT $LN11@lssproto_M
$LN12@lssproto_M:

; 1818 : 			{
; 1819 : 				palNo = -1;

  00112	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?palNo@@3HA, -1 ; palNo

; 1820 : 				palTime = 0;

  0011c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?palTime@@3HA, 0 ; palTime

; 1821 : 				drawTimeAnimeFlag = 1;

  00126	b8 01 00 00 00	 mov	 eax, 1
  0012b	66 a3 00 00 00
	00		 mov	 WORD PTR ?drawTimeAnimeFlag@@3FA, ax ; drawTimeAnimeFlag
$LN11@lssproto_M:

; 1822 : 			}
; 1823 : 		}
; 1824 : 		else

  00131	e9 8a 00 00 00	 jmp	 $LN6@lssproto_M
$LN9@lssproto_M:

; 1825 : 		{
; 1826 : 			int pal;
; 1827 : 
; 1828 : 			pal = atoi(strPal);

  00136	8b f4		 mov	 esi, esp
  00138	8d 85 a8 fd ff
	ff		 lea	 eax, DWORD PTR _strPal$3[ebp]
  0013e	50		 push	 eax
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00145	83 c4 04	 add	 esp, 4
  00148	3b f4		 cmp	 esi, esp
  0014a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014f	89 85 9c fd ff
	ff		 mov	 DWORD PTR _pal$2[ebp], eax

; 1829 : 			if (pal >= 0)

  00155	83 bd 9c fd ff
	ff 00		 cmp	 DWORD PTR _pal$2[ebp], 0
  0015c	7c 31		 jl	 SHORT $LN13@lssproto_M

; 1830 : 			{
; 1831 : 				if (TimeZonePalChangeFlag == TRUE || loginFlag)

  0015e	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?TimeZonePalChangeFlag@@3HA, 1 ; TimeZonePalChangeFlag
  00165	74 09		 je	 SHORT $LN16@lssproto_M
  00167	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?loginFlag@@3HA, 0 ; loginFlag
  0016e	74 1d		 je	 SHORT $LN15@lssproto_M
$LN16@lssproto_M:

; 1832 : 				{
; 1833 : 					palNo = pal;

  00170	8b 85 9c fd ff
	ff		 mov	 eax, DWORD PTR _pal$2[ebp]
  00176	a3 00 00 00 00	 mov	 DWORD PTR ?palNo@@3HA, eax ; palNo

; 1834 : 					palTime = 0;

  0017b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?palTime@@3HA, 0 ; palTime

; 1835 : 					drawTimeAnimeFlag = 0;

  00185	33 c0		 xor	 eax, eax
  00187	66 a3 00 00 00
	00		 mov	 WORD PTR ?drawTimeAnimeFlag@@3FA, ax ; drawTimeAnimeFlag
$LN15@lssproto_M:

; 1836 : 				}
; 1837 : 			}
; 1838 : 			else

  0018d	eb 31		 jmp	 SHORT $LN6@lssproto_M
$LN13@lssproto_M:

; 1839 : 			{
; 1840 : 				if (TimeZonePalChangeFlag == FALSE || loginFlag)

  0018f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?TimeZonePalChangeFlag@@3HA, 0 ; TimeZonePalChangeFlag
  00196	74 09		 je	 SHORT $LN18@lssproto_M
  00198	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?loginFlag@@3HA, 0 ; loginFlag
  0019f	74 1f		 je	 SHORT $LN6@lssproto_M
$LN18@lssproto_M:

; 1841 : 				{
; 1842 : 					palNo = -1;

  001a1	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?palNo@@3HA, -1 ; palNo

; 1843 : 					palTime = 0;

  001ab	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?palTime@@3HA, 0 ; palTime

; 1844 : 					drawTimeAnimeFlag = 1;

  001b5	b8 01 00 00 00	 mov	 eax, 1
  001ba	66 a3 00 00 00
	00		 mov	 WORD PTR ?drawTimeAnimeFlag@@3FA, ax ; drawTimeAnimeFlag
$LN6@lssproto_M:

; 1845 : 				}
; 1846 : 			}
; 1847 : 		}
; 1848 : 	}
; 1849 : 
; 1850 : 	//JL fix 2017.9.25 组队情况下，队员不检查地图，防止很卡
; 1851 : 	for (int i = 1; i < MAX_PARTY; i++) 

  001c0	c7 85 90 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR _i$1[ebp], 1
  001ca	eb 0f		 jmp	 SHORT $LN4@lssproto_M
$LN2@lssproto_M:
  001cc	8b 85 90 fd ff
	ff		 mov	 eax, DWORD PTR _i$1[ebp]
  001d2	83 c0 01	 add	 eax, 1
  001d5	89 85 90 fd ff
	ff		 mov	 DWORD PTR _i$1[ebp], eax
$LN4@lssproto_M:
  001db	83 bd 90 fd ff
	ff 05		 cmp	 DWORD PTR _i$1[ebp], 5
  001e2	7d 5c		 jge	 SHORT $LN3@lssproto_M

; 1852 : 	{
; 1853 : 		if (party[i].useFlag != 0)

  001e4	6b 85 90 fd ff
	ff 30		 imul	 eax, DWORD PTR _i$1[ebp], 48
  001eb	0f bf 88 00 00
	00 00		 movsx	 ecx, WORD PTR ?party@@3PAUPARTY@@A[eax]
  001f2	85 c9		 test	 ecx, ecx
  001f4	74 48		 je	 SHORT $LN19@lssproto_M

; 1854 : 		{
; 1855 : 			if (party[i].id == pc.id)

  001f6	6b 85 90 fd ff
	ff 30		 imul	 eax, DWORD PTR _i$1[ebp], 48
  001fd	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR ?party@@3PAUPARTY@@A[eax+4]
  00203	3b 0d 08 00 00
	00		 cmp	 ecx, DWORD PTR ?pc@@3UPC@@A+8
  00209	75 33		 jne	 SHORT $LN19@lssproto_M

; 1856 : 			{
; 1857 : 				if (nowFloor == fl)

  0020b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nowFloor@@3HA ; nowFloor
  00210	3b 45 0c	 cmp	 eax, DWORD PTR _fl$[ebp]
  00213	75 1d		 jne	 SHORT $LN21@lssproto_M

; 1858 : 				{
; 1859 : 					floorChangeFlag = FALSE;

  00215	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?floorChangeFlag@@3HA, 0 ; floorChangeFlag

; 1860 : 					if (warpEffectStart)

  0021f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?warpEffectStart@@3HA, 0 ; warpEffectStart
  00226	74 0a		 je	 SHORT $LN21@lssproto_M

; 1861 : 						warpEffectOk = TRUE;

  00228	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?warpEffectOk@@3HA, 1 ; warpEffectOk
$LN21@lssproto_M:

; 1862 : 				}
; 1863 : 				loginFlag = FALSE;

  00232	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?loginFlag@@3HA, 0 ; loginFlag

; 1864 : 				return;

  0023c	eb 5f		 jmp	 SHORT $LN1@lssproto_M
$LN19@lssproto_M:

; 1865 : 			}
; 1866 : 		}
; 1867 : 	}

  0023e	eb 8c		 jmp	 SHORT $LN2@lssproto_M
$LN3@lssproto_M:

; 1868 : 
; 1869 : 
; 1870 : 
; 1871 : 	if (mapCheckSum(fl, x1, y1, x2, y2, tileSum, partsSum, eventSum))

  00240	8b 45 28	 mov	 eax, DWORD PTR _eventSum$[ebp]
  00243	50		 push	 eax
  00244	8b 4d 24	 mov	 ecx, DWORD PTR _partsSum$[ebp]
  00247	51		 push	 ecx
  00248	8b 55 20	 mov	 edx, DWORD PTR _tileSum$[ebp]
  0024b	52		 push	 edx
  0024c	8b 45 1c	 mov	 eax, DWORD PTR _y2$[ebp]
  0024f	50		 push	 eax
  00250	8b 4d 18	 mov	 ecx, DWORD PTR _x2$[ebp]
  00253	51		 push	 ecx
  00254	8b 55 14	 mov	 edx, DWORD PTR _y1$[ebp]
  00257	52		 push	 edx
  00258	8b 45 10	 mov	 eax, DWORD PTR _x1$[ebp]
  0025b	50		 push	 eax
  0025c	8b 4d 0c	 mov	 ecx, DWORD PTR _fl$[ebp]
  0025f	51		 push	 ecx
  00260	e8 00 00 00 00	 call	 ?mapCheckSum@@YAHHHHHHHHH@Z ; mapCheckSum
  00265	83 c4 20	 add	 esp, 32			; 00000020H
  00268	85 c0		 test	 eax, eax
  0026a	74 31		 je	 SHORT $LN1@lssproto_M

; 1872 : 	{
; 1873 : 		if (nowFloor == fl)

  0026c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nowFloor@@3HA ; nowFloor
  00271	3b 45 0c	 cmp	 eax, DWORD PTR _fl$[ebp]
  00274	75 1d		 jne	 SHORT $LN24@lssproto_M

; 1874 : 		{
; 1875 : 			floorChangeFlag = FALSE;

  00276	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?floorChangeFlag@@3HA, 0 ; floorChangeFlag

; 1876 : 			if (warpEffectStart)

  00280	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?warpEffectStart@@3HA, 0 ; warpEffectStart
  00287	74 0a		 je	 SHORT $LN24@lssproto_M

; 1877 : 				warpEffectOk = TRUE;

  00289	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?warpEffectOk@@3HA, 1 ; warpEffectOk
$LN24@lssproto_M:

; 1878 : 		}
; 1879 : 		loginFlag = FALSE;

  00293	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?loginFlag@@3HA, 0 ; loginFlag
$LN1@lssproto_M:

; 1880 : 	}
; 1881 : }

  0029d	52		 push	 edx
  0029e	8b cd		 mov	 ecx, ebp
  002a0	50		 push	 eax
  002a1	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN31@lssproto_M
  002a7	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002ac	58		 pop	 eax
  002ad	5a		 pop	 edx
  002ae	5f		 pop	 edi
  002af	5e		 pop	 esi
  002b0	5b		 pop	 ebx
  002b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002b4	33 cd		 xor	 ecx, ebp
  002b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002bb	81 c4 f4 03 00
	00		 add	 esp, 1012		; 000003f4H
  002c1	3b ec		 cmp	 ebp, esp
  002c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002c8	8b e5		 mov	 esp, ebp
  002ca	5d		 pop	 ebp
  002cb	c3		 ret	 0
$LN31@lssproto_M:
  002cc	03 00 00 00	 DD	 3
  002d0	00 00 00 00	 DD	 $LN30@lssproto_M
$LN30@lssproto_M:
  002d4	f8 fd ff ff	 DD	 -520			; fffffdf8H
  002d8	00 02 00 00	 DD	 512			; 00000200H
  002dc	00 00 00 00	 DD	 $LN27@lssproto_M
  002e0	d0 fd ff ff	 DD	 -560			; fffffdd0H
  002e4	20 00 00 00	 DD	 32			; 00000020H
  002e8	00 00 00 00	 DD	 $LN28@lssproto_M
  002ec	a8 fd ff ff	 DD	 -600			; fffffda8H
  002f0	20 00 00 00	 DD	 32			; 00000020H
  002f4	00 00 00 00	 DD	 $LN29@lssproto_M
$LN29@lssproto_M:
  002f8	73		 DB	 115			; 00000073H
  002f9	74		 DB	 116			; 00000074H
  002fa	72		 DB	 114			; 00000072H
  002fb	50		 DB	 80			; 00000050H
  002fc	61		 DB	 97			; 00000061H
  002fd	6c		 DB	 108			; 0000006cH
  002fe	00		 DB	 0
$LN28@lssproto_M:
  002ff	66		 DB	 102			; 00000066H
  00300	6c		 DB	 108			; 0000006cH
  00301	6f		 DB	 111			; 0000006fH
  00302	6f		 DB	 111			; 0000006fH
  00303	72		 DB	 114			; 00000072H
  00304	4e		 DB	 78			; 0000004eH
  00305	61		 DB	 97			; 00000061H
  00306	6d		 DB	 109			; 0000006dH
  00307	65		 DB	 101			; 00000065H
  00308	00		 DB	 0
$LN27@lssproto_M:
  00309	73		 DB	 115			; 00000073H
  0030a	68		 DB	 104			; 00000068H
  0030b	6f		 DB	 111			; 0000006fH
  0030c	77		 DB	 119			; 00000077H
  0030d	53		 DB	 83			; 00000053H
  0030e	74		 DB	 116			; 00000074H
  0030f	72		 DB	 114			; 00000072H
  00310	69		 DB	 105			; 00000069H
  00311	6e		 DB	 110			; 0000006eH
  00312	67		 DB	 103			; 00000067H
  00313	00		 DB	 0
?lssproto_MC_recv@@YAXHHHHHHHHHPAD@Z ENDP		; lssproto_MC_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_TK_recv@@YAXHHPADH@Z
_TEXT	SEGMENT
tv148 = -3080						; size = 4
_token$1 = -2112					; size = 10
_szToken$2 = -2092					; size = 4
_type$ = -2080						; size = 4
_fontsize$ = -2068					; size = 4
_ptAct$ = -2056						; size = 4
_msg$ = -2044						; size = 2024
_id$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_index$ = 12						; size = 4
_message$ = 16						; size = 4
_color$ = 20						; size = 4
?lssproto_TK_recv@@YAXHHPADH@Z PROC			; lssproto_TK_recv, COMDAT

; 2709 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 0c 00
	00		 sub	 esp, 3080		; 00000c08H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 f3 ff
	ff		 lea	 edi, DWORD PTR [ebp-3080]
  00012	b9 02 03 00 00	 mov	 ecx, 770		; 00000302H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2710 : 	char id[2];
; 2711 : 	char msg[2024];
; 2712 : 	ACTION *ptAct;
; 2713 : 	int fontsize =0;

  00028	c7 85 ec f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _fontsize$[ebp], 0

; 2714 : 
; 2715 : 	int type;
; 2716 : 
; 2717 : 	// ????????????????雪????
; 2718 : 	if ( logOutFlag )

  00032	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  00039	74 05		 je	 SHORT $LN4@lssproto_T

; 2719 : 		return;

  0003b	e9 cc 02 00 00	 jmp	 $LN1@lssproto_T
$LN4@lssproto_T:

; 2720 : 
; 2721 : 	getStringToken( message, '|', 1, sizeof( id  ) - 1, id );

  00040	8d 45 f4	 lea	 eax, DWORD PTR _id$[ebp]
  00043	50		 push	 eax
  00044	6a 01		 push	 1
  00046	6a 01		 push	 1
  00048	6a 7c		 push	 124			; 0000007cH
  0004a	8b 4d 10	 mov	 ecx, DWORD PTR _message$[ebp]
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00053	83 c4 14	 add	 esp, 20			; 00000014H

; 2722 : 
; 2723 : 	if ( id[0] == 'P' ){

  00056	b8 01 00 00 00	 mov	 eax, 1
  0005b	6b c8 00	 imul	 ecx, eax, 0
  0005e	0f be 54 0d f4	 movsx	 edx, BYTE PTR _id$[ebp+ecx]
  00063	83 fa 50	 cmp	 edx, 80			; 00000050H
  00066	0f 85 a0 02 00
	00		 jne	 $LN1@lssproto_T

; 2724 : #ifndef _CHANNEL_MODIFY
; 2725 : 		getStringToken( message, '|', 2, sizeof( msg ) - 1, msg );
; 2726 : 		makeStringFromEscaped( msg );
; 2727 : 	#ifdef _TRADETALKWND				// (不可开) Syu ADD 交易新增对话框架
; 2728 : 		TradeTalk( msg ) ; 
; 2729 : 	#endif
; 2730 : #endif
; 2731 : 
; 2732 : #ifdef _CHANNEL_MODIFY
; 2733 : 		char szToken[4];
; 2734 : 
; 2735 : 		if (getStringToken(message,'|',2,sizeof(szToken) - 1,szToken) == 0){

  0006c	8d 85 d4 f7 ff
	ff		 lea	 eax, DWORD PTR _szToken$2[ebp]
  00072	50		 push	 eax
  00073	6a 03		 push	 3
  00075	6a 02		 push	 2
  00077	6a 7c		 push	 124			; 0000007cH
  00079	8b 4d 10	 mov	 ecx, DWORD PTR _message$[ebp]
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00082	83 c4 14	 add	 esp, 20			; 00000014H
  00085	85 c0		 test	 eax, eax
  00087	0f 85 a4 01 00
	00		 jne	 $LN6@lssproto_T

; 2736 : 			getStringToken(message,'|',3,sizeof(msg) - 1,msg);

  0008d	8d 85 04 f8 ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  00093	50		 push	 eax
  00094	68 e7 07 00 00	 push	 2023			; 000007e7H
  00099	6a 03		 push	 3
  0009b	6a 7c		 push	 124			; 0000007cH
  0009d	8b 4d 10	 mov	 ecx, DWORD PTR _message$[ebp]
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  000a6	83 c4 14	 add	 esp, 20			; 00000014H

; 2737 : 			makeStringFromEscaped(msg);

  000a9	8d 85 04 f8 ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  000b5	83 c4 04	 add	 esp, 4

; 2738 : #ifdef _FONT_SIZE
; 2739 : 			char token[10];
; 2740 : 			if ( getStringToken(message,'|',4,sizeof(token) - 1,token) == 1) {

  000b8	8d 85 c0 f7 ff
	ff		 lea	 eax, DWORD PTR _token$1[ebp]
  000be	50		 push	 eax
  000bf	6a 09		 push	 9
  000c1	6a 04		 push	 4
  000c3	6a 7c		 push	 124			; 0000007cH
  000c5	8b 4d 10	 mov	 ecx, DWORD PTR _message$[ebp]
  000c8	51		 push	 ecx
  000c9	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  000ce	83 c4 14	 add	 esp, 20			; 00000014H
  000d1	83 f8 01	 cmp	 eax, 1
  000d4	75 47		 jne	 SHORT $LN8@lssproto_T

; 2741 : 				fontsize = atoi( token);

  000d6	8b f4		 mov	 esi, esp
  000d8	8d 85 c0 f7 ff
	ff		 lea	 eax, DWORD PTR _token$1[ebp]
  000de	50		 push	 eax
  000df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  000e5	83 c4 04	 add	 esp, 4
  000e8	3b f4		 cmp	 esi, esp
  000ea	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ef	89 85 ec f7 ff
	ff		 mov	 DWORD PTR _fontsize$[ebp], eax

; 2742 : 				if ( fontsize < 0 )	fontsize = 0;

  000f5	83 bd ec f7 ff
	ff 00		 cmp	 DWORD PTR _fontsize$[ebp], 0
  000fc	7d 0a		 jge	 SHORT $LN10@lssproto_T
  000fe	c7 85 ec f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _fontsize$[ebp], 0
$LN10@lssproto_T:

; 2743 : 
; 2744 : 				//CC fix
; 2745 : 				//适配世界频道
; 2746 : 				if (fontsize == 99)	fontsize = 0;

  00108	83 bd ec f7 ff
	ff 63		 cmp	 DWORD PTR _fontsize$[ebp], 99 ; 00000063H
  0010f	75 0a		 jne	 SHORT $LN11@lssproto_T
  00111	c7 85 ec f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _fontsize$[ebp], 0
$LN11@lssproto_T:

; 2747 : 			}
; 2748 : 			else {

  0011b	eb 0a		 jmp	 SHORT $LN9@lssproto_T
$LN8@lssproto_T:

; 2749 : 				fontsize = 0;

  0011d	c7 85 ec f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _fontsize$[ebp], 0
$LN9@lssproto_T:

; 2750 : 			}
; 2751 : #endif
; 2752 : 
; 2753 : 			type = TYPE_TALK::附近;

  00127	c7 85 e0 f7 ff
	ff 01 00 00 00	 mov	 DWORD PTR _type$[ebp], 1

; 2754 : 
; 2755 : 			if (strlen(szToken) > 1){

  00131	8d 85 d4 f7 ff
	ff		 lea	 eax, DWORD PTR _szToken$2[ebp]
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 _strlen
  0013d	83 c4 04	 add	 esp, 4
  00140	83 f8 01	 cmp	 eax, 1
  00143	76 58		 jbe	 SHORT $LN12@lssproto_T

; 2756 : 				if (strcmp(szToken,"TK") == 0)	InitSelectChar(message,0);

  00145	68 00 00 00 00	 push	 OFFSET ??_C@_02HIIGDGEP@TK?$AA@
  0014a	8d 85 d4 f7 ff
	ff		 lea	 eax, DWORD PTR _szToken$2[ebp]
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 _strcmp
  00156	83 c4 08	 add	 esp, 8
  00159	85 c0		 test	 eax, eax
  0015b	75 10		 jne	 SHORT $LN14@lssproto_T
  0015d	6a 00		 push	 0
  0015f	8b 45 10	 mov	 eax, DWORD PTR _message$[ebp]
  00162	50		 push	 eax
  00163	e8 00 00 00 00	 call	 ?InitSelectChar@@YAXPADH@Z ; InitSelectChar
  00168	83 c4 08	 add	 esp, 8
  0016b	eb 26		 jmp	 SHORT $LN15@lssproto_T
$LN14@lssproto_T:

; 2757 : 				else if (strcmp(szToken,"TE") == 0) InitSelectChar(message,1);

  0016d	68 00 00 00 00	 push	 OFFSET ??_C@_02OGAFBLMB@TE?$AA@
  00172	8d 85 d4 f7 ff
	ff		 lea	 eax, DWORD PTR _szToken$2[ebp]
  00178	50		 push	 eax
  00179	e8 00 00 00 00	 call	 _strcmp
  0017e	83 c4 08	 add	 esp, 8
  00181	85 c0		 test	 eax, eax
  00183	75 0e		 jne	 SHORT $LN15@lssproto_T
  00185	6a 01		 push	 1
  00187	8b 45 10	 mov	 eax, DWORD PTR _message$[ebp]
  0018a	50		 push	 eax
  0018b	e8 00 00 00 00	 call	 ?InitSelectChar@@YAXPADH@Z ; InitSelectChar
  00190	83 c4 08	 add	 esp, 8
$LN15@lssproto_T:

; 2758 : 				return;

  00193	e9 74 01 00 00	 jmp	 $LN1@lssproto_T

; 2759 : 			}
; 2760 : 			else{

  00198	e9 92 00 00 00	 jmp	 $LN13@lssproto_T
$LN12@lssproto_T:

; 2761 : 				switch (szToken[0]){

  0019d	b8 01 00 00 00	 mov	 eax, 1
  001a2	6b c8 00	 imul	 ecx, eax, 0
  001a5	0f be 94 0d d4
	f7 ff ff	 movsx	 edx, BYTE PTR _szToken$2[ebp+ecx]
  001ad	89 95 f8 f3 ff
	ff		 mov	 DWORD PTR tv148[ebp], edx
  001b3	8b 85 f8 f3 ff
	ff		 mov	 eax, DWORD PTR tv148[ebp]
  001b9	83 e8 46	 sub	 eax, 70			; 00000046H
  001bc	89 85 f8 f3 ff
	ff		 mov	 DWORD PTR tv148[ebp], eax
  001c2	83 bd f8 f3 ff
	ff 0e		 cmp	 DWORD PTR tv148[ebp], 14 ; 0000000eH
  001c9	77 42		 ja	 SHORT $LN2@lssproto_T
  001cb	8b 8d f8 f3 ff
	ff		 mov	 ecx, DWORD PTR tv148[ebp]
  001d1	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN28@lssproto_T[ecx]
  001d8	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN35@lssproto_T[edx*4]
$LN17@lssproto_T:

; 2762 : 				
; 2763 : 				case 'M':
; 2764 : 					type = TYPE_TALK::私聊;  // 密语频道

  001df	c7 85 e0 f7 ff
	ff 03 00 00 00	 mov	 DWORD PTR _type$[ebp], 3

; 2765 : 					break;

  001e9	eb 22		 jmp	 SHORT $LN2@lssproto_T
$LN18@lssproto_T:

; 2766 : 				
; 2767 : 				case 'F':
; 2768 : 					type = TYPE_TALK::家族;  // 家族频道

  001eb	c7 85 e0 f7 ff
	ff 02 00 00 00	 mov	 DWORD PTR _type$[ebp], 2

; 2769 : 					break;

  001f5	eb 16		 jmp	 SHORT $LN2@lssproto_T
$LN19@lssproto_T:

; 2770 : 			
; 2771 : 				case 'T':
; 2772 : 					type = TYPE_TALK::队伍;  // 队伍频道

  001f7	c7 85 e0 f7 ff
	ff 04 00 00 00	 mov	 DWORD PTR _type$[ebp], 4

; 2773 : 					break;	 

  00201	eb 0a		 jmp	 SHORT $LN2@lssproto_T
$LN20@lssproto_T:

; 2774 : 
; 2775 : 				case 'O':
; 2776 : 					type = TYPE_TALK::系统;  // 职业频道

  00203	c7 85 e0 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _type$[ebp], 0
$LN2@lssproto_T:

; 2777 : 					break;
; 2778 : 				}
; 2779 : 				SaveChatData(msg,szToken[0],false);

  0020d	6a 00		 push	 0
  0020f	b8 01 00 00 00	 mov	 eax, 1
  00214	6b c8 00	 imul	 ecx, eax, 0
  00217	0f b6 94 0d d4
	f7 ff ff	 movzx	 edx, BYTE PTR _szToken$2[ebp+ecx]
  0021f	52		 push	 edx
  00220	8d 85 04 f8 ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  00226	50		 push	 eax
  00227	e8 00 00 00 00	 call	 ?SaveChatData@@YAXPADD_N@Z ; SaveChatData
  0022c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN13@lssproto_T:

; 2780 : 			}

  0022f	eb 1c		 jmp	 SHORT $LN7@lssproto_T
$LN6@lssproto_T:

; 2781 : 		}
; 2782 : 		else getStringToken(message,'|',2,sizeof(msg) - 1,msg);

  00231	8d 85 04 f8 ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  00237	50		 push	 eax
  00238	68 e7 07 00 00	 push	 2023			; 000007e7H
  0023d	6a 02		 push	 2
  0023f	6a 7c		 push	 124			; 0000007cH
  00241	8b 4d 10	 mov	 ecx, DWORD PTR _message$[ebp]
  00244	51		 push	 ecx
  00245	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0024a	83 c4 14	 add	 esp, 20			; 00000014H
$LN7@lssproto_T:

; 2783 : #ifdef _TALK_WINDOW
; 2784 : 		if (!g_bTalkWindow)
; 2785 : #endif
; 2786 : 		TradeTalk(msg);

  0024d	8d 85 04 f8 ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  00253	50		 push	 eax
  00254	e8 00 00 00 00	 call	 ?TradeTalk@@YAXPAD@Z	; TradeTalk
  00259	83 c4 04	 add	 esp, 4

; 2787 : 		if (strcmp(msg,"成立聊天室扣除２００石币") == 0)	pc.gold -= 200;

  0025c	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@DFPJGLLL@?$OA?w?X?$KB?V?$PN?t?$LI?c?x?$DP?p?$LG?$KD?$LC?$KD?$LA?$KD?$LA?$OA?$LE?$DP?$AA@
  00261	8d 85 04 f8 ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  00267	50		 push	 eax
  00268	e8 00 00 00 00	 call	 _strcmp
  0026d	83 c4 08	 add	 esp, 8
  00270	85 c0		 test	 eax, eax
  00272	75 0f		 jne	 SHORT $LN21@lssproto_T
  00274	a1 60 00 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+96
  00279	2d c8 00 00 00	 sub	 eax, 200		; 000000c8H
  0027e	a3 60 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+96, eax
$LN21@lssproto_T:

; 2788 : #ifdef _FONT_SIZE
; 2789 : 
; 2790 : 		if (index == -1)type = TYPE_TALK::系统;

  00283	83 7d 0c ff	 cmp	 DWORD PTR _index$[ebp], -1
  00287	75 0a		 jne	 SHORT $LN22@lssproto_T
  00289	c7 85 e0 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _type$[ebp], 0
$LN22@lssproto_T:

; 2791 : 
; 2792 : 
; 2793 : 		StockChatBufferLineExt( msg, color, fontsize, type);

  00293	8b 85 e0 f7 ff
	ff		 mov	 eax, DWORD PTR _type$[ebp]
  00299	50		 push	 eax
  0029a	8b 8d ec f7 ff
	ff		 mov	 ecx, DWORD PTR _fontsize$[ebp]
  002a0	51		 push	 ecx
  002a1	0f b6 55 14	 movzx	 edx, BYTE PTR _color$[ebp]
  002a5	52		 push	 edx
  002a6	8d 85 04 f8 ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  002ac	50		 push	 eax
  002ad	e8 00 00 00 00	 call	 ?StockChatBufferLineExt@@YAXPADEHH@Z ; StockChatBufferLineExt
  002b2	83 c4 10	 add	 esp, 16			; 00000010H

; 2794 : #else
; 2795 : 		StockChatBufferLine(msg,color);
; 2796 : #endif
; 2797 : #else
; 2798 : 	#ifdef _TELLCHANNEL		// (不可开) ROG ADD 密语频道
; 2799 : 		char tellName[128] = { "" };
; 2800 : 		char tmpMsg[STR_BUFFER_SIZE + 32];
; 2801 : 		char TK[4];
; 2802 : 
; 2803 : 		if ( getStringToken( msg, '|', 1, sizeof( TK ) - 1, TK ) == 0){
; 2804 : 			if (strcmp(TK,"TK") == 0)	InitSelectChar( msg, 0);
; 2805 : 			else if (strcmp(TK,"TE") == 0) InitSelectChar( msg, 1);
; 2806 : 		}
; 2807 : 		else{
; 2808 : 			char temp[] = "告诉你：";
; 2809 : 			char *found;
; 2810 : 
; 2811 : 			if (strcmp( msg, "成立聊天室扣除２００石币") == 0)	pc.gold -= 200;
; 2812 : 
; 2813 : 			if ( found = strstr( msg, temp )){
; 2814 : 				strncpy(tellName, msg, strlen(msg) - strlen(found));
; 2815 : 				color = 5;
; 2816 : 				sprintf(tmpMsg,"[%s]%s",tellName, found);
; 2817 : 				StockChatBufferLine( tmpMsg, color );
; 2818 : 				sprintf(msg,"");
; 2819 : 				sprintf(secretName,"%s ",tellName);
; 2820 : 			}else StockChatBufferLine( msg, color );
; 2821 : 		}
; 2822 : 	#else
; 2823 : #ifdef _FONT_SIZE
; 2824 : 		StockChatBufferLineExt( msg, color, fontsize );
; 2825 : #else
; 2826 : 		StockChatBufferLine( msg, color );
; 2827 : #endif
; 2828 : #endif
; 2829 : #endif
; 2830 : 		if ( index >= 0 ){

  002b5	83 7d 0c 00	 cmp	 DWORD PTR _index$[ebp], 0
  002b9	7c 51		 jl	 SHORT $LN1@lssproto_T

; 2831 : 			if ( pc.ptAct != NULL && pc.id == index ){

  002bb	83 3d ec 50 00
	00 00		 cmp	 DWORD PTR ?pc@@3UPC@@A+20716, 0
  002c2	74 19		 je	 SHORT $LN24@lssproto_T
  002c4	a1 08 00 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+8
  002c9	3b 45 0c	 cmp	 eax, DWORD PTR _index$[ebp]
  002cc	75 0f		 jne	 SHORT $LN24@lssproto_T

; 2832 : 				// JL 注释 设置说话时气泡保留的时间
; 2833 : 				setPcFukidashi( 1000 );  

  002ce	68 e8 03 00 00	 push	 1000			; 000003e8H
  002d3	e8 00 00 00 00	 call	 ?setPcFukidashi@@YAXI@Z	; setPcFukidashi
  002d8	83 c4 04	 add	 esp, 4

; 2834 : 			}
; 2835 : 			else

  002db	eb 2f		 jmp	 SHORT $LN1@lssproto_T
$LN24@lssproto_T:

; 2836 : 			{
; 2837 : 				ptAct = getCharObjAct( index );

  002dd	8b 45 0c	 mov	 eax, DWORD PTR _index$[ebp]
  002e0	50		 push	 eax
  002e1	e8 00 00 00 00	 call	 ?getCharObjAct@@YAPAUaction@@H@Z ; getCharObjAct
  002e6	83 c4 04	 add	 esp, 4
  002e9	89 85 f8 f7 ff
	ff		 mov	 DWORD PTR _ptAct$[ebp], eax

; 2838 : 				if ( ptAct != NULL )

  002ef	83 bd f8 f7 ff
	ff 00		 cmp	 DWORD PTR _ptAct$[ebp], 0
  002f6	74 14		 je	 SHORT $LN1@lssproto_T

; 2839 : 				{
; 2840 : 					// 1000??
; 2841 : 					setCharFukidashi( ptAct, 1000 );

  002f8	68 e8 03 00 00	 push	 1000			; 000003e8H
  002fd	8b 85 f8 f7 ff
	ff		 mov	 eax, DWORD PTR _ptAct$[ebp]
  00303	50		 push	 eax
  00304	e8 00 00 00 00	 call	 ?setCharFukidashi@@YAXPAUaction@@I@Z ; setCharFukidashi
  00309	83 c4 08	 add	 esp, 8
$LN1@lssproto_T:

; 2842 : 				}
; 2843 : 			}
; 2844 : 		}
; 2845 : 	}
; 2846 : 
; 2847 : /*#if 0
; 2848 : 	if (index == my_id_in_server){
; 2849 : 		if (pinfo.ptaction != NULL){
; 2850 : 			createPlayerCommonEffect( pinfo.ptaction, SPR_fukidasi, 0, 1, -5 );
; 2851 : 		}
; 2852 : 	}else{
; 2853 : 		int goind = searchGameObjectIndex( index );
; 2854 : //		if ( goind >= 0 ||gameobj[goind].ptaction!=NULL){
; 2855 : 		if ( goind >= 0 && gameobj[goind].ptaction!=NULL ){
; 2856 : 			createPlayerCommonEffect( gameobj[goind].ptaction, SPR_fukidasi, 0, 1, -5 );
; 2857 : 		}
; 2858 : 	}
; 2859 : 
; 2860 : #ifdef DEBUGPUSH
; 2861 : 	if (color<249)PUSHVAR("??????????%d?'%s'",color, message); 
; 2862 : #endif
; 2863 : 	char id[2];
; 2864 :     char msg[2024];
; 2865 : 	getStringToken( message , '|' , 1 , sizeof( id ) - 1, id);
; 2866 : 	if (id[0] == 'P'){
; 2867 : 		getStringToken( message , '|' , 2 , sizeof( msg ) - 1, msg);
; 2868 : 		makeStringFromEscaped(msg);
; 2869 : 		char cutmes[1024];
; 2870 : 		int i, j;
; 2871 : 		for (i=0, j=0;;i++,j++){
; 2872 : 			cutmes[j] = msg[i];
; 2873 : 			if (msg[i] == '\0'){
; 2874 : 				chatinputPushString(cutmes, color);
; 2875 : 				break;
; 2876 : 			}
; 2877 : 			if ( IsDBCSTrailByte( msg, &msg[i+1] ) ){
; 2878 : 				continue;
; 2879 : 			}
; 2880 : 			cutmes[j+1]='\0';
; 2881 : 			if (GetStringWidth(cutmes)>600){
; 2882 : 				j = -1;
; 2883 : 				chatinputPushString(cutmes, color);
; 2884 : 			}
; 2885 : 		}
; 2886 : 	}else if (id[0] == 'D'){
; 2887 : 		int i;
; 2888 : 		selectwindowid = getIntegerToken(message, '|', 2);
; 2889 : 		void setDengonbanMessageNumber(int i);//netaction.cpp?ol
; 2890 : 		setDengonbanMessageNumber(getIntegerToken(message, '|', 3));
; 2891 : 		for (i=0;i<5;i++){
; 2892 : 			getStringToken( message , '|' , i+4 , sizeof( selectstringline[i] ) - 1, selectstringline[i]);
; 2893 : 			makeStringFromEscaped(selectstringline[i]);
; 2894 : 		}
; 2895 : 		cantclosewindowflag = 1;
; 2896 : 		OpenNPCWindow(NPC_BOARD_WINDOW);
; 2897 : 	}else if (id[0] == 'W'){
; 2898 : 		int i;
; 2899 : 		char token[1024];
; 2900 : 		getStringToken( message , '|' , 2 , sizeof( token ) - 1, token);
; 2901 : 		selectwindowid = atoi(token);
; 2902 : 		char mode[10];
; 2903 : 		getStringToken( message , '|' , 3 , sizeof( mode ) - 1, mode);
; 2904 : 		char caption[255];
; 2905 : 		int flag;
; 2906 : 		flag = getStringToken( message , '|' , 4 , sizeof( caption ) - 1, caption);
; 2907 : 		makeStringFromEscaped(caption);
; 2908 : 		strcpy(selectstringline[0],caption);
; 2909 : 		for (i=1;;i++){
; 2910 : 			selectstringlineindex[i] = getIntegerToken(message, '|', 3+i*2);
; 2911 : 			flag = getStringToken( message , '|' , 4+i*2 , sizeof( caption ) - 1, caption);
; 2912 : 			makeStringFromEscaped(caption);
; 2913 : 			strcpy(selectstringline[i],caption);
; 2914 : 			if (flag==1)break;
; 2915 : 		}
; 2916 : 		selectstringlinenumber=i;
; 2917 : 		cantclosewindowflag = 1;
; 2918 : 		if (mode[0] == 'G')OpenNPCWindow(NPC_KATARIBE_WINDOW);
; 2919 : 		else if (mode[0] == 'N')OpenNPCWindow(NPC_WINDOW);
; 2920 : 		else PUSHVAR("????????????????????????", msg);
; 2921 : 	}else if (id[0] == 'M'){
; 2922 : 		int i = 0, j = 0, k = 0;
; 2923 : 		if (strlen(message)>1024){
; 2924 : #ifdef DEBUGPUSH
; 2925 : 			PUSH("??????????????????");
; 2926 : #endif
; 2927 : 			return;
; 2928 : 		}
; 2929 : 		char token[1024];
; 2930 : 		getStringToken( message , '|' , 2 , sizeof( token ) - 1, token);
; 2931 : 		selectwindowid = atoi(token);
; 2932 : 		char mode[10];
; 2933 : 		getStringToken( message , '|' , 3 , sizeof( mode ) - 1, mode);
; 2934 : 		char caption[1024], onelinestring[1024];
; 2935 : 		getStringToken( message , '|' , 4 , sizeof( caption ) - 1, caption);
; 2936 : 		makeStringFromEscaped(caption);
; 2937 : 		for (i=0;;i++){
; 2938 : 			if (caption[i] == '\n'){
; 2939 : 				onelinestring[k] = '\0';
; 2940 : 				memcpy(selectstringline[j], onelinestring, k+1);
; 2941 : 				j++;
; 2942 : 				k = 0;
; 2943 : 			}else if (caption[i] == '\0'){
; 2944 : 				onelinestring[k] = '\0';
; 2945 : 				memcpy(selectstringline[j], onelinestring, k+1);
; 2946 : 				j++;
; 2947 : 				break;
; 2948 : 			}else{
; 2949 : 				onelinestring[k] = caption[i];
; 2950 : 				k++;
; 2951 : 			}
; 2952 : 		}
; 2953 : 		selectstringlinenumber=j;
; 2954 : 		if (mode[0] == 'G')OpenNPCWindow(NPC_G_MESSAGE_WINDOW);
; 2955 : 		else if (mode[0] == 'N')OpenNPCWindow(NPC_MESSAGE_WINDOW);
; 2956 : 		else PUSHVAR("????????????????????????", msg);
; 2957 : 	}else if (id[0] == 'S'){
; 2958 : 		int i;
; 2959 : #if 1
; 2960 : 		// ?????????????????
; 2961 : 		for ( i = 0; i < MAXSHOPITEM; i++ )
; 2962 : 		{
; 2963 : 			shopitem[i].plice = 0;
; 2964 : 			shopitem[i].stock = 0;
; 2965 : 			shopitem[i].itm.name[0] = '\0';
; 2966 : 			shopitem[i].itm.name2[0] = '\0';
; 2967 : 			shopitem[i].itm.memo[0] = '\0';
; 2968 : 			shopitem[i].itm.stage = 0;
; 2969 : 			shopitem[i].itm.imgno = 0;
; 2970 : 		}
; 2971 : #endif
; 2972 : 		selectwindowid = getIntegerToken( message , '|' , 2 );	
; 2973 : 		for (i=0;i<7;i++){
; 2974 : 			getStringToken( message , '|' , 3+i , sizeof( shopmessage[i] ) - 1, shopmessage[i] );
; 2975 : 			makeStringFromEscaped(shopmessage[i]);
; 2976 : 		}
; 2977 : 		shopgold = getIntegerToken( message , '|' , 10 );
; 2978 : 		shopstock = getIntegerToken(message, '|', 11 );
; 2979 : 		for (i=0;i<shopstock;i++){
; 2980 : 			getStringToken( message , '|' , 12+i*5, sizeof(shopitem[i].itm.name) - 1, shopitem[i].itm.name);
; 2981 : 			makeStringFromEscaped(shopitem[i].itm.name);
; 2982 : 			if (strlen(shopitem[i].itm.name)==0)break;
; 2983 : 			shopitem[i].plice = getIntegerToken( message , '|' , 13+i*5);
; 2984 : 			shopitem[i].itm.stage = getIntegerToken( message , '|' , 14+i*5);
; 2985 : 			if (shopitem[i].itm.stage<0)shopitem[i].itm.stage=0;
; 2986 : 			shopitem[i].itm.imgno = getIntegerToken( message , '|' , 15+i*5);
; 2987 : 			getStringToken( message , '|' , 16+i*5, sizeof(shopitem[i].itm.memo) - 1, shopitem[i].itm.memo);
; 2988 : 			makeStringFromEscaped(shopitem[i].itm.memo);
; 2989 : 			shopitem[i].stock = 1;
; 2990 : 		}
; 2991 : 		for (i=0;i<40;i++){
; 2992 : 			charitemplice[i] = getIntegerToken(message, '|', 12+shopstock*5+i);
; 2993 : 		}
; 2994 : 		void setShoppage(int i);//layout.cpp
; 2995 : 		setShoppage (0);
; 2996 : 		OpenNPCWindow(NPC_SHOP_START_WINDOW);
; 2997 : 		cantclosewindowflag = 1;
; 2998 : 		PUSHVAR( "??????? '%s'??????????" , msg );
; 2999 : 	}else if (id[0] == 'L'){//???
; 3000 : 		getStringToken( message , '|' , 2 , sizeof( selectstringline[0] ) - 1, selectstringline[0] );
; 3001 : 			makeStringFromEscaped(selectstringline[0]);
; 3002 : 		getStringToken( message , '|' , 3 , sizeof( selectstringline[1] ) - 1, selectstringline[1] );
; 3003 : 			makeStringFromEscaped(selectstringline[1]);
; 3004 : 		selectstringlineindex[1] = SYSTEM_CHARLOST;
; 3005 : 		selectstringlinenumber=1;
; 3006 : 		cantclosewindowflag = 1;
; 3007 : 		OpenSystemWindow();
; 3008 : 	}else if (id[0] == 'K'){
; 3009 : 		void setSystemMessage(int i, char *mes, int index);//layout.cpp
; 3010 : 		int i;
; 3011 : 		char token[1024];
; 3012 : 		getStringToken( message , '|' , 2 , sizeof( token ) - 1, token);
; 3013 : 		selectwindowid = atoi(token);
; 3014 : 		char caption[255];
; 3015 : 		int flag;
; 3016 : 		int index;
; 3017 : 		flag = getStringToken( message , '|' , 3 , sizeof( caption ) - 1, caption);
; 3018 : 		makeStringFromEscaped(caption);
; 3019 : 		strcpy(selectstringline[0],caption);
; 3020 : 		setSystemMessage( 0, caption, SYSTEM_SYSTEM);
; 3021 : 		for (i=1;;i++){
; 3022 : 			flag = getStringToken( message , '|' , i+3 , sizeof( caption ) - 1, caption);
; 3023 : 			makeStringFromEscaped(caption);
; 3024 : 			strcpy(selectstringline[i],caption);
; 3025 : 			if (strcmp(selectstringline[i],"?????")==0){
; 3026 : 				index = SYSTEM_LOGOUT;
; 3027 : 			}else{
; 3028 : 				index = SYSTEM_SERVERPUSH_1+i-1;
; 3029 : 			}
; 3030 : 			selectstringlineindex[i]=index;
; 3031 : 			setSystemMessage( i, caption, index);
; 3032 : 			if (flag==1)break;
; 3033 : 		}
; 3034 : 		selectstringlinenumber=i;
; 3035 : 		deadflag = 1;
; 3036 : 		OpenSystemWindow();
; 3037 : //		OpenNPCWindow(NPC_WINDOW);
; 3038 : 		PUSH("TK?????????");
; 3039 : 	}else if (id[0] == 'R'){
; 3040 : 		deadflag = 0;
; 3041 : 	}else{
; 3042 : 		PUSH("TK????????????");
; 3043 : 	}
; 3044 : 
; 3045 : #endif
; 3046 : 	*/
; 3047 : }

  0030c	52		 push	 edx
  0030d	8b cd		 mov	 ecx, ebp
  0030f	50		 push	 eax
  00310	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN34@lssproto_T
  00316	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0031b	58		 pop	 eax
  0031c	5a		 pop	 edx
  0031d	5f		 pop	 edi
  0031e	5e		 pop	 esi
  0031f	5b		 pop	 ebx
  00320	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00323	33 cd		 xor	 ecx, ebp
  00325	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0032a	81 c4 08 0c 00
	00		 add	 esp, 3080		; 00000c08H
  00330	3b ec		 cmp	 ebp, esp
  00332	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00337	8b e5		 mov	 esp, ebp
  00339	5d		 pop	 ebp
  0033a	c3		 ret	 0
  0033b	90		 npad	 1
$LN34@lssproto_T:
  0033c	04 00 00 00	 DD	 4
  00340	00 00 00 00	 DD	 $LN33@lssproto_T
$LN33@lssproto_T:
  00344	f4 ff ff ff	 DD	 -12			; fffffff4H
  00348	02 00 00 00	 DD	 2
  0034c	00 00 00 00	 DD	 $LN29@lssproto_T
  00350	04 f8 ff ff	 DD	 -2044			; fffff804H
  00354	e8 07 00 00	 DD	 2024			; 000007e8H
  00358	00 00 00 00	 DD	 $LN30@lssproto_T
  0035c	d4 f7 ff ff	 DD	 -2092			; fffff7d4H
  00360	04 00 00 00	 DD	 4
  00364	00 00 00 00	 DD	 $LN31@lssproto_T
  00368	c0 f7 ff ff	 DD	 -2112			; fffff7c0H
  0036c	0a 00 00 00	 DD	 10			; 0000000aH
  00370	00 00 00 00	 DD	 $LN32@lssproto_T
$LN32@lssproto_T:
  00374	74		 DB	 116			; 00000074H
  00375	6f		 DB	 111			; 0000006fH
  00376	6b		 DB	 107			; 0000006bH
  00377	65		 DB	 101			; 00000065H
  00378	6e		 DB	 110			; 0000006eH
  00379	00		 DB	 0
$LN31@lssproto_T:
  0037a	73		 DB	 115			; 00000073H
  0037b	7a		 DB	 122			; 0000007aH
  0037c	54		 DB	 84			; 00000054H
  0037d	6f		 DB	 111			; 0000006fH
  0037e	6b		 DB	 107			; 0000006bH
  0037f	65		 DB	 101			; 00000065H
  00380	6e		 DB	 110			; 0000006eH
  00381	00		 DB	 0
$LN30@lssproto_T:
  00382	6d		 DB	 109			; 0000006dH
  00383	73		 DB	 115			; 00000073H
  00384	67		 DB	 103			; 00000067H
  00385	00		 DB	 0
$LN29@lssproto_T:
  00386	69		 DB	 105			; 00000069H
  00387	64		 DB	 100			; 00000064H
  00388	00		 DB	 0
  00389	0f 1f 00	 npad	 3
$LN35@lssproto_T:
  0038c	00 00 00 00	 DD	 $LN18@lssproto_T
  00390	00 00 00 00	 DD	 $LN17@lssproto_T
  00394	00 00 00 00	 DD	 $LN20@lssproto_T
  00398	00 00 00 00	 DD	 $LN19@lssproto_T
  0039c	00 00 00 00	 DD	 $LN2@lssproto_T
$LN28@lssproto_T:
  003a0	00		 DB	 0
  003a1	04		 DB	 4
  003a2	04		 DB	 4
  003a3	04		 DB	 4
  003a4	04		 DB	 4
  003a5	04		 DB	 4
  003a6	04		 DB	 4
  003a7	01		 DB	 1
  003a8	04		 DB	 4
  003a9	02		 DB	 2
  003aa	04		 DB	 4
  003ab	04		 DB	 4
  003ac	04		 DB	 4
  003ad	04		 DB	 4
  003ae	03		 DB	 3
?lssproto_TK_recv@@YAXHHPADH@Z ENDP			; lssproto_TK_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_ABI_recv@@YAXHHPAD@Z
_TEXT	SEGMENT
_useFlag$ = -288					; size = 4
_nameLen$ = -276					; size = 4
_name$ = -264						; size = 256
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_num$ = 12						; size = 4
_data$ = 16						; size = 4
?lssproto_ABI_recv@@YAXHHPAD@Z PROC			; lssproto_ABI_recv, COMDAT

; 3358 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 02 00
	00		 sub	 esp, 512		; 00000200H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 00 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-512]
  00012	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3359 : 	char name[256];
; 3360 : 	int nameLen;
; 3361 : 	int useFlag;
; 3362 : #ifdef _MAILSHOWPLANET				// (可开放) Syu ADD 显示名片星球
; 3363 : 	char planetid[8];
; 3364 : 	int j ;
; 3365 : #endif
; 3366 : 
; 3367 : 	// ????????????????雪????
; 3368 : 	if ( logOutFlag )

  00028	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  0002f	74 05		 je	 SHORT $LN2@lssproto_A

; 3369 : 		return;

  00031	e9 1d 02 00 00	 jmp	 $LN1@lssproto_A
$LN2@lssproto_A:

; 3370 : 
; 3371 : 	useFlag = getIntegerToken(data, '|', 1 );

  00036	6a 01		 push	 1
  00038	6a 7c		 push	 124			; 0000007cH
  0003a	8b 45 10	 mov	 eax, DWORD PTR _data$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _useFlag$[ebp], eax

; 3372 : 	if ( useFlag == -1 )

  0004c	83 bd e0 fe ff
	ff ff		 cmp	 DWORD PTR _useFlag$[ebp], -1
  00053	75 0a		 jne	 SHORT $LN3@lssproto_A

; 3373 : 	{
; 3374 : 		useFlag = 0;

  00055	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _useFlag$[ebp], 0
$LN3@lssproto_A:

; 3375 : 	}
; 3376 : 	if ( useFlag == 0 )

  0005f	83 bd e0 fe ff
	ff 00		 cmp	 DWORD PTR _useFlag$[ebp], 0
  00066	0f 85 89 00 00
	00		 jne	 $LN4@lssproto_A

; 3377 : 	{
; 3378 : #if 0
; 3379 : 		if ( addressBook[num].useFlag == 1 )
; 3380 : #else
; 3381 : 		if ( MailHistory[num].dateStr[MAIL_MAX_HISTORY-1][0] != '\0' )

  0006c	69 45 0c f0 0e
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 3824
  00073	b9 15 00 00 00	 mov	 ecx, 21			; 00000015H
  00078	6b d1 13	 imul	 edx, ecx, 19
  0007b	8d 84 10 04 0b
	00 00		 lea	 eax, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[eax+edx+2820]
  00082	b9 01 00 00 00	 mov	 ecx, 1
  00087	6b d1 00	 imul	 edx, ecx, 0
  0008a	0f be 04 10	 movsx	 eax, BYTE PTR [eax+edx]
  0008e	85 c0		 test	 eax, eax
  00090	74 38		 je	 SHORT $LN5@lssproto_A

; 3382 : #endif
; 3383 : 		{
; 3384 : 			memset( &MailHistory[num], 0, sizeof( MailHistory[0] ) ) ;

  00092	68 f0 0e 00 00	 push	 3824			; 00000ef0H
  00097	6a 00		 push	 0
  00099	69 45 0c f0 0e
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 3824
  000a0	05 00 00 00 00	 add	 eax, OFFSET ?MailHistory@@3PAUMAIL_HISTORY@@A ; MailHistory
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 _memset
  000ab	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3385 : 			SaveMailHistory( num );

  000ae	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ?SaveMailHistory@@YAHH@Z ; SaveMailHistory
  000b7	83 c4 04	 add	 esp, 4

; 3386 : 			// t????
; 3387 : 			mailLamp = CheckMailNoReadFlag();

  000ba	e8 00 00 00 00	 call	 ?CheckMailNoReadFlag@@YAHXZ ; CheckMailNoReadFlag
  000bf	66 a3 00 00 00
	00		 mov	 WORD PTR ?mailLamp@@3FA, ax ; mailLamp

; 3388 : 			// ?????
; 3389 : 			DeathLetterAction();

  000c5	e8 00 00 00 00	 call	 ?DeathLetterAction@@YAXXZ ; DeathLetterAction
$LN5@lssproto_A:

; 3390 : 		}
; 3391 : 		addressBook[num].useFlag = useFlag;

  000ca	6b 45 0c 68	 imul	 eax, DWORD PTR _num$[ebp], 104
  000ce	66 8b 8d e0 fe
	ff ff		 mov	 cx, WORD PTR _useFlag$[ebp]
  000d5	66 89 88 00 00
	00 00		 mov	 WORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[eax], cx

; 3392 : 		addressBook[num].name[0] = '\0';

  000dc	6b 45 0c 68	 imul	 eax, DWORD PTR _num$[ebp], 104
  000e0	b9 01 00 00 00	 mov	 ecx, 1
  000e5	6b d1 00	 imul	 edx, ecx, 0
  000e8	c6 84 10 14 00
	00 00 00	 mov	 BYTE PTR ?addressBook@@3PAUADDRESS_BOOK@@A[eax+edx+20], 0

; 3393 : 		return;

  000f0	e9 5e 01 00 00	 jmp	 $LN1@lssproto_A
$LN4@lssproto_A:

; 3394 : 	}
; 3395 : 
; 3396 : #ifdef _EXTEND_AB
; 3397 : 	if ( num == MAX_ADR_BOOK-1 )

  000f5	83 7d 0c 4f	 cmp	 DWORD PTR _num$[ebp], 79 ; 0000004fH
  000f9	75 14		 jne	 SHORT $LN6@lssproto_A

; 3398 : 		addressBook[num].useFlag = useFlag;

  000fb	6b 45 0c 68	 imul	 eax, DWORD PTR _num$[ebp], 104
  000ff	66 8b 8d e0 fe
	ff ff		 mov	 cx, WORD PTR _useFlag$[ebp]
  00106	66 89 88 00 00
	00 00		 mov	 WORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[eax], cx

; 3399 : 	else

  0010d	eb 10		 jmp	 SHORT $LN7@lssproto_A
$LN6@lssproto_A:

; 3400 : 		addressBook[num].useFlag = 1;

  0010f	6b 45 0c 68	 imul	 eax, DWORD PTR _num$[ebp], 104
  00113	b9 01 00 00 00	 mov	 ecx, 1
  00118	66 89 88 00 00
	00 00		 mov	 WORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[eax], cx
$LN7@lssproto_A:

; 3401 : #else
; 3402 : 	addressBook[num].useFlag = useFlag;
; 3403 : #endif
; 3404 : 
; 3405 : 	getStringToken(data, '|', 2, sizeof(name) - 1 , name );

  0011f	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  00125	50		 push	 eax
  00126	68 ff 00 00 00	 push	 255			; 000000ffH
  0012b	6a 02		 push	 2
  0012d	6a 7c		 push	 124			; 0000007cH
  0012f	8b 4d 10	 mov	 ecx, DWORD PTR _data$[ebp]
  00132	51		 push	 ecx
  00133	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00138	83 c4 14	 add	 esp, 20			; 00000014H

; 3406 : 	makeStringFromEscaped(name);

  0013b	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  00141	50		 push	 eax
  00142	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  00147	83 c4 04	 add	 esp, 4

; 3407 : 	nameLen = strlen(name);

  0014a	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 _strlen
  00156	83 c4 04	 add	 esp, 4
  00159	89 85 ec fe ff
	ff		 mov	 DWORD PTR _nameLen$[ebp], eax

; 3408 : 	if ( 0 < nameLen && nameLen <= CHAR_NAME_LEN )

  0015f	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _nameLen$[ebp], 0
  00166	7e 23		 jle	 SHORT $LN8@lssproto_A
  00168	83 bd ec fe ff
	ff 10		 cmp	 DWORD PTR _nameLen$[ebp], 16 ; 00000010H
  0016f	7f 1a		 jg	 SHORT $LN8@lssproto_A

; 3409 : 	{
; 3410 : 		strcpy( addressBook[num].name, name );

  00171	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  00177	50		 push	 eax
  00178	6b 4d 0c 68	 imul	 ecx, DWORD PTR _num$[ebp], 104
  0017c	81 c1 14 00 00
	00		 add	 ecx, OFFSET ?addressBook@@3PAUADDRESS_BOOK@@A+20
  00182	51		 push	 ecx
  00183	e8 00 00 00 00	 call	 _strcpy
  00188	83 c4 08	 add	 esp, 8
$LN8@lssproto_A:

; 3411 : 	}
; 3412 : 	addressBook[num].level = getIntegerToken(data, '|', 3 );

  0018b	6a 03		 push	 3
  0018d	6a 7c		 push	 124			; 0000007cH
  0018f	8b 45 10	 mov	 eax, DWORD PTR _data$[ebp]
  00192	50		 push	 eax
  00193	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00198	83 c4 0c	 add	 esp, 12			; 0000000cH
  0019b	6b 4d 0c 68	 imul	 ecx, DWORD PTR _num$[ebp], 104
  0019f	89 81 04 00 00
	00		 mov	 DWORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[ecx+4], eax

; 3413 : 	addressBook[num].dp = getIntegerToken(data, '|', 4 );

  001a5	6a 04		 push	 4
  001a7	6a 7c		 push	 124			; 0000007cH
  001a9	8b 45 10	 mov	 eax, DWORD PTR _data$[ebp]
  001ac	50		 push	 eax
  001ad	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  001b2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b5	6b 4d 0c 68	 imul	 ecx, DWORD PTR _num$[ebp], 104
  001b9	89 81 0c 00 00
	00		 mov	 DWORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[ecx+12], eax

; 3414 : 	addressBook[num].onlineFlag = (short)getIntegerToken(data, '|', 5 );

  001bf	6a 05		 push	 5
  001c1	6a 7c		 push	 124			; 0000007cH
  001c3	8b 45 10	 mov	 eax, DWORD PTR _data$[ebp]
  001c6	50		 push	 eax
  001c7	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  001cc	83 c4 0c	 add	 esp, 12			; 0000000cH
  001cf	6b 4d 0c 68	 imul	 ecx, DWORD PTR _num$[ebp], 104
  001d3	66 89 81 02 00
	00 00		 mov	 WORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[ecx+2], ax

; 3415 : 	addressBook[num].graNo = getIntegerToken(data, '|', 6 );

  001da	6a 06		 push	 6
  001dc	6a 7c		 push	 124			; 0000007cH
  001de	8b 45 10	 mov	 eax, DWORD PTR _data$[ebp]
  001e1	50		 push	 eax
  001e2	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  001e7	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ea	6b 4d 0c 68	 imul	 ecx, DWORD PTR _num$[ebp], 104
  001ee	89 81 10 00 00
	00		 mov	 DWORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[ecx+16], eax

; 3416 : 	addressBook[num].transmigration = getIntegerToken(data, '|', 7 );

  001f4	6a 07		 push	 7
  001f6	6a 7c		 push	 124			; 0000007cH
  001f8	8b 45 10	 mov	 eax, DWORD PTR _data$[ebp]
  001fb	50		 push	 eax
  001fc	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00201	83 c4 0c	 add	 esp, 12			; 0000000cH
  00204	6b 4d 0c 68	 imul	 ecx, DWORD PTR _num$[ebp], 104
  00208	66 89 81 08 00
	00 00		 mov	 WORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[ecx+8], ax

; 3417 : #ifdef 修复邮件服务器显示				// (可开放) Syu ADD 显示名片星球
; 3418 : 	if ( addressBook[num].onlineFlag == 0 ) 

  0020f	6b 45 0c 68	 imul	 eax, DWORD PTR _num$[ebp], 104
  00213	0f bf 88 02 00
	00 00		 movsx	 ecx, WORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[eax+2]
  0021a	85 c9		 test	 ecx, ecx
  0021c	75 19		 jne	 SHORT $LN9@lssproto_A

; 3419 : 		sprintf( addressBook[num].planetname , " ");

  0021e	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  00223	6b 45 0c 68	 imul	 eax, DWORD PTR _num$[ebp], 104
  00227	05 25 00 00 00	 add	 eax, OFFSET ?addressBook@@3PAUADDRESS_BOOK@@A+37
  0022c	50		 push	 eax
  0022d	e8 00 00 00 00	 call	 _sprintf
  00232	83 c4 08	 add	 esp, 8

; 3420 : 	else

  00235	eb 1c		 jmp	 SHORT $LN1@lssproto_A
$LN9@lssproto_A:

; 3421 : 		getStringToken(data, '|',  8, 12, addressBook[num].planetname);

  00237	6b 45 0c 68	 imul	 eax, DWORD PTR _num$[ebp], 104
  0023b	05 25 00 00 00	 add	 eax, OFFSET ?addressBook@@3PAUADDRESS_BOOK@@A+37
  00240	50		 push	 eax
  00241	6a 0c		 push	 12			; 0000000cH
  00243	6a 08		 push	 8
  00245	6a 7c		 push	 124			; 0000007cH
  00247	8b 4d 10	 mov	 ecx, DWORD PTR _data$[ebp]
  0024a	51		 push	 ecx
  0024b	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00250	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@lssproto_A:

; 3422 : 	//for ( j = 0 ; j < MAX_GMSV ; j ++ ) {
; 3423 : 	//	if ( gmsv[j].used == '1' ) {
; 3424 : 	//		getStringToken( gmsv[j].ipaddr, '.', 4, sizeof( planetid ) -1, planetid );
; 3425 : 	//		if ( addressBook[num].onlineFlag == atoi(planetid) ) {
; 3426 : 	//			sprintf ( addressBook[num].planetname , "%s" , gmsv[j].name ) ; 
; 3427 : 	//			break;
; 3428 : 	//		}
; 3429 : 	//	}
; 3430 : 	//}
; 3431 : #endif
; 3432 : 
; 3433 : 
; 3434 : }

  00253	52		 push	 edx
  00254	8b cd		 mov	 ecx, ebp
  00256	50		 push	 eax
  00257	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@lssproto_A
  0025d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00262	58		 pop	 eax
  00263	5a		 pop	 edx
  00264	5f		 pop	 edi
  00265	5e		 pop	 esi
  00266	5b		 pop	 ebx
  00267	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0026a	33 cd		 xor	 ecx, ebp
  0026c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00271	81 c4 00 02 00
	00		 add	 esp, 512		; 00000200H
  00277	3b ec		 cmp	 ebp, esp
  00279	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0027e	8b e5		 mov	 esp, ebp
  00280	5d		 pop	 ebp
  00281	c3		 ret	 0
  00282	66 90		 npad	 2
$LN15@lssproto_A:
  00284	02 00 00 00	 DD	 2
  00288	00 00 00 00	 DD	 $LN14@lssproto_A
$LN14@lssproto_A:
  0028c	f8 fe ff ff	 DD	 -264			; fffffef8H
  00290	00 01 00 00	 DD	 256			; 00000100H
  00294	00 00 00 00	 DD	 $LN12@lssproto_A
  00298	d0 fe ff ff	 DD	 -304			; fffffed0H
  0029c	08 00 00 00	 DD	 8
  002a0	00 00 00 00	 DD	 $LN13@lssproto_A
$LN13@lssproto_A:
  002a4	70		 DB	 112			; 00000070H
  002a5	6c		 DB	 108			; 0000006cH
  002a6	61		 DB	 97			; 00000061H
  002a7	6e		 DB	 110			; 0000006eH
  002a8	65		 DB	 101			; 00000065H
  002a9	74		 DB	 116			; 00000074H
  002aa	69		 DB	 105			; 00000069H
  002ab	64		 DB	 100			; 00000064H
  002ac	00		 DB	 0
$LN12@lssproto_A:
  002ad	6e		 DB	 110			; 0000006eH
  002ae	61		 DB	 97			; 00000061H
  002af	6d		 DB	 109			; 0000006dH
  002b0	65		 DB	 101			; 00000065H
  002b1	00		 DB	 0
?lssproto_ABI_recv@@YAXHHPAD@Z ENDP			; lssproto_ABI_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_AB_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_useFlag$ = -324					; size = 4
_flag$ = -312						; size = 4
_name$ = -300						; size = 256
_nameLen$ = -36						; size = 4
_no$ = -24						; size = 4
_i$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_AB_recv@@YAXHPAD@Z PROC			; lssproto_AB_recv, COMDAT

; 3259 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 02 00
	00		 sub	 esp, 548		; 00000224H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd dc fd ff
	ff		 lea	 edi, DWORD PTR [ebp-548]
  00012	b9 89 00 00 00	 mov	 ecx, 137		; 00000089H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3260 : 	int i;
; 3261 : 	int no;
; 3262 : 	int nameLen;
; 3263 : 	char name[256];
; 3264 : 	int flag;
; 3265 : 	int useFlag;
; 3266 : #ifdef _MAILSHOWPLANET				// (可开放) Syu ADD 显示名片星球
; 3267 : 	char planetid[8];
; 3268 : 	int j ;
; 3269 : #endif
; 3270 : 	// ????????????????雪????
; 3271 : 	if ( logOutFlag )

  00028	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  0002f	74 05		 je	 SHORT $LN5@lssproto_A

; 3272 : 		return;

  00031	e9 5c 02 00 00	 jmp	 $LN1@lssproto_A
$LN5@lssproto_A:

; 3273 : 
; 3274 : 	for ( i = 0; i < MAX_ADR_BOOK; i++ )

  00036	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0003d	eb 09		 jmp	 SHORT $LN4@lssproto_A
$LN2@lssproto_A:
  0003f	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00042	83 c0 01	 add	 eax, 1
  00045	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@lssproto_A:
  00048	83 7d f4 50	 cmp	 DWORD PTR _i$[ebp], 80	; 00000050H
  0004c	0f 8d 40 02 00
	00		 jge	 $LN1@lssproto_A

; 3275 : 	{
; 3276 : 		//no = i * 6; //the second
; 3277 :         //CC_FIX 客户端名片有故障，每一个名片应该有8个说明符号，7个说明有异常 20170806
; 3278 : 		//no = i * 7;
; 3279 : 		no = i * 8;

  00052	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00055	c1 e0 03	 shl	 eax, 3
  00058	89 45 e8	 mov	 DWORD PTR _no$[ebp], eax

; 3280 : 		useFlag = getIntegerToken(data, '|', no+1 );

  0005b	8b 45 e8	 mov	 eax, DWORD PTR _no$[ebp]
  0005e	83 c0 01	 add	 eax, 1
  00061	50		 push	 eax
  00062	6a 7c		 push	 124			; 0000007cH
  00064	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00070	89 85 bc fe ff
	ff		 mov	 DWORD PTR _useFlag$[ebp], eax

; 3281 : 		if ( useFlag == -1 )

  00076	83 bd bc fe ff
	ff ff		 cmp	 DWORD PTR _useFlag$[ebp], -1
  0007d	75 0a		 jne	 SHORT $LN6@lssproto_A

; 3282 : 		{
; 3283 : 			useFlag = 0;

  0007f	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _useFlag$[ebp], 0
$LN6@lssproto_A:

; 3284 : 		}
; 3285 : 		if ( useFlag <= 0 )

  00089	83 bd bc fe ff
	ff 00		 cmp	 DWORD PTR _useFlag$[ebp], 0
  00090	0f 8f 84 00 00
	00		 jg	 $LN7@lssproto_A

; 3286 : 		{
; 3287 : #if 0
; 3288 : 			if ( addressBook[i].useFlag == 1 )
; 3289 : #else
; 3290 : 			if ( MailHistory[i].dateStr[MAIL_MAX_HISTORY-1][0] != '\0' )

  00096	69 45 f4 f0 0e
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 3824
  0009d	b9 15 00 00 00	 mov	 ecx, 21			; 00000015H
  000a2	6b d1 13	 imul	 edx, ecx, 19
  000a5	8d 84 10 04 0b
	00 00		 lea	 eax, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[eax+edx+2820]
  000ac	b9 01 00 00 00	 mov	 ecx, 1
  000b1	6b d1 00	 imul	 edx, ecx, 0
  000b4	0f be 04 10	 movsx	 eax, BYTE PTR [eax+edx]
  000b8	85 c0		 test	 eax, eax
  000ba	74 38		 je	 SHORT $LN8@lssproto_A

; 3291 : #endif
; 3292 : 			{
; 3293 : 				memset( &MailHistory[i], 0, sizeof( MailHistory[0] ) ) ;

  000bc	68 f0 0e 00 00	 push	 3824			; 00000ef0H
  000c1	6a 00		 push	 0
  000c3	69 45 f4 f0 0e
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 3824
  000ca	05 00 00 00 00	 add	 eax, OFFSET ?MailHistory@@3PAUMAIL_HISTORY@@A ; MailHistory
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 _memset
  000d5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3294 : 				SaveMailHistory( i );

  000d8	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 ?SaveMailHistory@@YAHH@Z ; SaveMailHistory
  000e1	83 c4 04	 add	 esp, 4

; 3295 : 				// t????
; 3296 : 				mailLamp = CheckMailNoReadFlag();

  000e4	e8 00 00 00 00	 call	 ?CheckMailNoReadFlag@@YAHXZ ; CheckMailNoReadFlag
  000e9	66 a3 00 00 00
	00		 mov	 WORD PTR ?mailLamp@@3FA, ax ; mailLamp

; 3297 : 				// ?????
; 3298 : 				DeathLetterAction();

  000ef	e8 00 00 00 00	 call	 ?DeathLetterAction@@YAXXZ ; DeathLetterAction
$LN8@lssproto_A:

; 3299 : 			}
; 3300 : 			addressBook[i].useFlag = 0;

  000f4	6b 45 f4 68	 imul	 eax, DWORD PTR _i$[ebp], 104
  000f8	33 c9		 xor	 ecx, ecx
  000fa	66 89 88 00 00
	00 00		 mov	 WORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[eax], cx

; 3301 : 			addressBook[i].name[0] = '\0';

  00101	6b 45 f4 68	 imul	 eax, DWORD PTR _i$[ebp], 104
  00105	b9 01 00 00 00	 mov	 ecx, 1
  0010a	6b d1 00	 imul	 edx, ecx, 0
  0010d	c6 84 10 14 00
	00 00 00	 mov	 BYTE PTR ?addressBook@@3PAUADDRESS_BOOK@@A[eax+edx+20], 0

; 3302 : 			continue;

  00115	e9 25 ff ff ff	 jmp	 $LN2@lssproto_A
$LN7@lssproto_A:

; 3303 : 		}
; 3304 : 
; 3305 : #ifdef _EXTEND_AB
; 3306 : 		if ( i == MAX_ADR_BOOK-1 )

  0011a	83 7d f4 4f	 cmp	 DWORD PTR _i$[ebp], 79	; 0000004fH
  0011e	75 14		 jne	 SHORT $LN9@lssproto_A

; 3307 : 			addressBook[i].useFlag = useFlag;

  00120	6b 45 f4 68	 imul	 eax, DWORD PTR _i$[ebp], 104
  00124	66 8b 8d bc fe
	ff ff		 mov	 cx, WORD PTR _useFlag$[ebp]
  0012b	66 89 88 00 00
	00 00		 mov	 WORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[eax], cx

; 3308 : 		else

  00132	eb 10		 jmp	 SHORT $LN10@lssproto_A
$LN9@lssproto_A:

; 3309 : 			addressBook[i].useFlag = 1;

  00134	6b 45 f4 68	 imul	 eax, DWORD PTR _i$[ebp], 104
  00138	b9 01 00 00 00	 mov	 ecx, 1
  0013d	66 89 88 00 00
	00 00		 mov	 WORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[eax], cx
$LN10@lssproto_A:

; 3310 : #else
; 3311 : 		addressBook[i].useFlag = 1;
; 3312 : #endif
; 3313 : 
; 3314 : 		flag = getStringToken(data, '|', no+2, sizeof(name) - 1 , name );

  00144	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  0014a	50		 push	 eax
  0014b	68 ff 00 00 00	 push	 255			; 000000ffH
  00150	8b 4d e8	 mov	 ecx, DWORD PTR _no$[ebp]
  00153	83 c1 02	 add	 ecx, 2
  00156	51		 push	 ecx
  00157	6a 7c		 push	 124			; 0000007cH
  00159	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  0015c	52		 push	 edx
  0015d	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00162	83 c4 14	 add	 esp, 20			; 00000014H
  00165	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _flag$[ebp], eax

; 3315 : 
; 3316 : 		if ( flag == 1 )

  0016b	83 bd c8 fe ff
	ff 01		 cmp	 DWORD PTR _flag$[ebp], 1
  00172	75 05		 jne	 SHORT $LN11@lssproto_A

; 3317 : 			break;

  00174	e9 19 01 00 00	 jmp	 $LN1@lssproto_A
$LN11@lssproto_A:

; 3318 : 
; 3319 : 		makeStringFromEscaped(name);

  00179	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  0017f	50		 push	 eax
  00180	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  00185	83 c4 04	 add	 esp, 4

; 3320 : 		nameLen = strlen(name);

  00188	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  0018e	50		 push	 eax
  0018f	e8 00 00 00 00	 call	 _strlen
  00194	83 c4 04	 add	 esp, 4
  00197	89 45 dc	 mov	 DWORD PTR _nameLen$[ebp], eax

; 3321 : 		if ( 0 < nameLen && nameLen <= CHAR_NAME_LEN )

  0019a	83 7d dc 00	 cmp	 DWORD PTR _nameLen$[ebp], 0
  0019e	7e 20		 jle	 SHORT $LN12@lssproto_A
  001a0	83 7d dc 10	 cmp	 DWORD PTR _nameLen$[ebp], 16 ; 00000010H
  001a4	7f 1a		 jg	 SHORT $LN12@lssproto_A

; 3322 : 		{
; 3323 : 			strcpy( addressBook[i].name, name );

  001a6	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  001ac	50		 push	 eax
  001ad	6b 4d f4 68	 imul	 ecx, DWORD PTR _i$[ebp], 104
  001b1	81 c1 14 00 00
	00		 add	 ecx, OFFSET ?addressBook@@3PAUADDRESS_BOOK@@A+20
  001b7	51		 push	 ecx
  001b8	e8 00 00 00 00	 call	 _strcpy
  001bd	83 c4 08	 add	 esp, 8
$LN12@lssproto_A:

; 3324 : 		}
; 3325 : 		addressBook[i].level = getIntegerToken(data, '|', no+3 );

  001c0	8b 45 e8	 mov	 eax, DWORD PTR _no$[ebp]
  001c3	83 c0 03	 add	 eax, 3
  001c6	50		 push	 eax
  001c7	6a 7c		 push	 124			; 0000007cH
  001c9	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  001cc	51		 push	 ecx
  001cd	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  001d2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d5	6b 55 f4 68	 imul	 edx, DWORD PTR _i$[ebp], 104
  001d9	89 82 04 00 00
	00		 mov	 DWORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[edx+4], eax

; 3326 : 		addressBook[i].dp = getIntegerToken(data, '|', no+4 );

  001df	8b 45 e8	 mov	 eax, DWORD PTR _no$[ebp]
  001e2	83 c0 04	 add	 eax, 4
  001e5	50		 push	 eax
  001e6	6a 7c		 push	 124			; 0000007cH
  001e8	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  001eb	51		 push	 ecx
  001ec	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  001f1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f4	6b 55 f4 68	 imul	 edx, DWORD PTR _i$[ebp], 104
  001f8	89 82 0c 00 00
	00		 mov	 DWORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[edx+12], eax

; 3327 : 		addressBook[i].onlineFlag = (short)getIntegerToken(data, '|', no+5 );

  001fe	8b 45 e8	 mov	 eax, DWORD PTR _no$[ebp]
  00201	83 c0 05	 add	 eax, 5
  00204	50		 push	 eax
  00205	6a 7c		 push	 124			; 0000007cH
  00207	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0020a	51		 push	 ecx
  0020b	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00210	83 c4 0c	 add	 esp, 12			; 0000000cH
  00213	6b 55 f4 68	 imul	 edx, DWORD PTR _i$[ebp], 104
  00217	66 89 82 02 00
	00 00		 mov	 WORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[edx+2], ax

; 3328 : 		addressBook[i].graNo = getIntegerToken(data, '|', no+6 );

  0021e	8b 45 e8	 mov	 eax, DWORD PTR _no$[ebp]
  00221	83 c0 06	 add	 eax, 6
  00224	50		 push	 eax
  00225	6a 7c		 push	 124			; 0000007cH
  00227	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0022a	51		 push	 ecx
  0022b	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00230	83 c4 0c	 add	 esp, 12			; 0000000cH
  00233	6b 55 f4 68	 imul	 edx, DWORD PTR _i$[ebp], 104
  00237	89 82 10 00 00
	00		 mov	 DWORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[edx+16], eax

; 3329 : 		addressBook[i].transmigration = getIntegerToken(data, '|', no+7 );

  0023d	8b 45 e8	 mov	 eax, DWORD PTR _no$[ebp]
  00240	83 c0 07	 add	 eax, 7
  00243	50		 push	 eax
  00244	6a 7c		 push	 124			; 0000007cH
  00246	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00249	51		 push	 ecx
  0024a	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0024f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00252	6b 55 f4 68	 imul	 edx, DWORD PTR _i$[ebp], 104
  00256	66 89 82 08 00
	00 00		 mov	 WORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[edx+8], ax

; 3330 : #ifdef 修复邮件服务器显示
; 3331 : 		if (addressBook[i].onlineFlag)

  0025d	6b 45 f4 68	 imul	 eax, DWORD PTR _i$[ebp], 104
  00261	0f bf 88 02 00
	00 00		 movsx	 ecx, WORD PTR ?addressBook@@3PAUADDRESS_BOOK@@A[eax+2]
  00268	85 c9		 test	 ecx, ecx
  0026a	74 21		 je	 SHORT $LN13@lssproto_A

; 3332 : 		{
; 3333 : 			getStringToken(data, '|', no + 8, 12, addressBook[i].planetname);

  0026c	6b 45 f4 68	 imul	 eax, DWORD PTR _i$[ebp], 104
  00270	05 25 00 00 00	 add	 eax, OFFSET ?addressBook@@3PAUADDRESS_BOOK@@A+37
  00275	50		 push	 eax
  00276	6a 0c		 push	 12			; 0000000cH
  00278	8b 4d e8	 mov	 ecx, DWORD PTR _no$[ebp]
  0027b	83 c1 08	 add	 ecx, 8
  0027e	51		 push	 ecx
  0027f	6a 7c		 push	 124			; 0000007cH
  00281	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  00284	52		 push	 edx
  00285	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0028a	83 c4 14	 add	 esp, 20			; 00000014H
$LN13@lssproto_A:

; 3334 : 		}
; 3335 : #endif // 修复邮件服务器显示
; 3336 : 
; 3337 : 
; 3338 : 
; 3339 : //#ifdef _MAILSHOWPLANET				// (可开放) Syu ADD 显示名片星球
; 3340 : //		for ( j = 0 ; j < MAX_GMSV ; j ++ ) {
; 3341 : //			if ( gmsv[j].used == '1' ) {
; 3342 : //				getStringToken( gmsv[j].ipaddr, '.', 4, sizeof( planetid ) -1, planetid );
; 3343 : //				if ( addressBook[i].onlineFlag == atoi(planetid) ) {
; 3344 : //					sprintf ( addressBook[i].planetname , "%s" , gmsv[j].name ) ; 
; 3345 : //					break;
; 3346 : //				}
; 3347 : //			}
; 3348 : //		}
; 3349 : //#endif
; 3350 : 
; 3351 : 
; 3352 : 	}

  0028d	e9 ad fd ff ff	 jmp	 $LN2@lssproto_A
$LN1@lssproto_A:

; 3353 : }

  00292	52		 push	 edx
  00293	8b cd		 mov	 ecx, ebp
  00295	50		 push	 eax
  00296	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN18@lssproto_A
  0029c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002a1	58		 pop	 eax
  002a2	5a		 pop	 edx
  002a3	5f		 pop	 edi
  002a4	5e		 pop	 esi
  002a5	5b		 pop	 ebx
  002a6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a9	33 cd		 xor	 ecx, ebp
  002ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b0	81 c4 24 02 00
	00		 add	 esp, 548		; 00000224H
  002b6	3b ec		 cmp	 ebp, esp
  002b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002bd	8b e5		 mov	 esp, ebp
  002bf	5d		 pop	 ebp
  002c0	c3		 ret	 0
  002c1	0f 1f 00	 npad	 3
$LN18@lssproto_A:
  002c4	02 00 00 00	 DD	 2
  002c8	00 00 00 00	 DD	 $LN17@lssproto_A
$LN17@lssproto_A:
  002cc	d4 fe ff ff	 DD	 -300			; fffffed4H
  002d0	00 01 00 00	 DD	 256			; 00000100H
  002d4	00 00 00 00	 DD	 $LN15@lssproto_A
  002d8	ac fe ff ff	 DD	 -340			; fffffeacH
  002dc	08 00 00 00	 DD	 8
  002e0	00 00 00 00	 DD	 $LN16@lssproto_A
$LN16@lssproto_A:
  002e4	70		 DB	 112			; 00000070H
  002e5	6c		 DB	 108			; 0000006cH
  002e6	61		 DB	 97			; 00000061H
  002e7	6e		 DB	 110			; 0000006eH
  002e8	65		 DB	 101			; 00000065H
  002e9	74		 DB	 116			; 00000074H
  002ea	69		 DB	 105			; 00000069H
  002eb	64		 DB	 100			; 00000064H
  002ec	00		 DB	 0
$LN15@lssproto_A:
  002ed	6e		 DB	 110			; 0000006eH
  002ee	61		 DB	 97			; 00000061H
  002ef	6d		 DB	 109			; 0000006dH
  002f0	65		 DB	 101			; 00000065H
  002f1	00		 DB	 0
?lssproto_AB_recv@@YAXHPAD@Z ENDP			; lssproto_AB_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_PME_recv@@YAXHHHHHHHHPAD@Z
_TEXT	SEGMENT
tv233 = -7844						; size = 4
tv214 = -7844						; size = 4
tv205 = -7844						; size = 4
tv197 = -7844						; size = 4
tv189 = -7844						; size = 4
tv181 = -7844						; size = 4
tv174 = -7844						; size = 4
tv165 = -7844						; size = 4
tv154 = -7844						; size = 4
tv145 = -7844						; size = 4
tv136 = -7844						; size = 4
tv95 = -7844						; size = 4
tv87 = -7844						; size = 4
tv68 = -7844						; size = 4
_ps$1 = -6300						; size = 4
_charType$2 = -6288					; size = 4
_height$3 = -6276					; size = 4
_walkable$4 = -6264					; size = 4
_freeName$5 = -6252					; size = 2048
_name$6 = -4196						; size = 2048
_nameColor$7 = -2140					; size = 4
_level$8 = -2128					; size = 4
_graNo$9 = -2116					; size = 4
_dir$10 = -2104						; size = 4
_y$11 = -2092						; size = 4
_x$12 = -2080						; size = 4
_id$13 = -2068						; size = 4
_smalltoken$14 = -2056					; size = 2048
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_objindex$ = 12						; size = 4
_graphicsno$ = 16					; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
_dir$ = 28						; size = 4
_flg$ = 32						; size = 4
_no$ = 36						; size = 4
_cdata$ = 40						; size = 4
?lssproto_PME_recv@@YAXHHHHHHHHPAD@Z PROC		; lssproto_PME_recv, COMDAT

; 3632 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 a4 1e 00 00	 mov	 eax, 7844		; 00001ea4H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8d bd 5c e1 ff
	ff		 lea	 edi, DWORD PTR [ebp-7844]
  00016	b9 a9 07 00 00	 mov	 ecx, 1961		; 000007a9H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3633 : 	// ????????????????雪????
; 3634 : 	if ( logOutFlag )

  0002c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  00033	74 05		 je	 SHORT $LN6@lssproto_P

; 3635 : 		return;

  00035	e9 3c 05 00 00	 jmp	 $LN1@lssproto_P
$LN6@lssproto_P:

; 3636 : 
; 3637 : 	// Pf?????
; 3638 : 	if ( encountNowFlag )

  0003a	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?encountNowFlag@@3FA ; encountNowFlag
  00041	85 c0		 test	 eax, eax
  00043	74 05		 je	 SHORT $LN7@lssproto_P

; 3639 : 		return;

  00045	e9 2c 05 00 00	 jmp	 $LN1@lssproto_P
$LN7@lssproto_P:

; 3640 : 
; 3641 : 	// ??
; 3642 : 	if ( flg == 0 )

  0004a	83 7d 20 00	 cmp	 DWORD PTR _flg$[ebp], 0
  0004e	75 62		 jne	 SHORT $LN8@lssproto_P

; 3643 : 	{
; 3644 : 		switch ( no )

  00050	8b 45 24	 mov	 eax, DWORD PTR _no$[ebp]
  00053	89 85 5c e1 ff
	ff		 mov	 DWORD PTR tv68[ebp], eax
  00059	83 bd 5c e1 ff
	ff 00		 cmp	 DWORD PTR tv68[ebp], 0
  00060	74 0b		 je	 SHORT $LN10@lssproto_P
  00062	83 bd 5c e1 ff
	ff 01		 cmp	 DWORD PTR tv68[ebp], 1
  00069	74 24		 je	 SHORT $LN11@lssproto_P
  0006b	eb 40		 jmp	 SHORT $LN2@lssproto_P
$LN10@lssproto_P:

; 3645 : 		{
; 3646 : 			case 0:
; 3647 : 				createPetAction( graphicsno, x, y, dir, 0, dir, -1 );

  0006d	6a ff		 push	 -1
  0006f	8b 45 1c	 mov	 eax, DWORD PTR _dir$[ebp]
  00072	50		 push	 eax
  00073	6a 00		 push	 0
  00075	8b 4d 1c	 mov	 ecx, DWORD PTR _dir$[ebp]
  00078	51		 push	 ecx
  00079	8b 55 18	 mov	 edx, DWORD PTR _y$[ebp]
  0007c	52		 push	 edx
  0007d	8b 45 14	 mov	 eax, DWORD PTR _x$[ebp]
  00080	50		 push	 eax
  00081	8b 4d 10	 mov	 ecx, DWORD PTR _graphicsno$[ebp]
  00084	51		 push	 ecx
  00085	e8 00 00 00 00	 call	 ?createPetAction@@YAPAUaction@@HHHHHHH@Z ; createPetAction
  0008a	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3648 : 				break;

  0008d	eb 1e		 jmp	 SHORT $LN2@lssproto_P
$LN11@lssproto_P:

; 3649 : 			case 1:
; 3650 : 				createPetAction( graphicsno, x, y, dir, 2, 0, -1 );

  0008f	6a ff		 push	 -1
  00091	6a 00		 push	 0
  00093	6a 02		 push	 2
  00095	8b 45 1c	 mov	 eax, DWORD PTR _dir$[ebp]
  00098	50		 push	 eax
  00099	8b 4d 18	 mov	 ecx, DWORD PTR _y$[ebp]
  0009c	51		 push	 ecx
  0009d	8b 55 14	 mov	 edx, DWORD PTR _x$[ebp]
  000a0	52		 push	 edx
  000a1	8b 45 10	 mov	 eax, DWORD PTR _graphicsno$[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 ?createPetAction@@YAPAUaction@@HHHHHHH@Z ; createPetAction
  000aa	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN2@lssproto_P:

; 3651 : 				break;
; 3652 : 		}
; 3653 : 	}
; 3654 : 	else

  000ad	e9 c4 04 00 00	 jmp	 $LN1@lssproto_P
$LN8@lssproto_P:

; 3655 : 	// 觚?
; 3656 : 	{
; 3657 : 		char smalltoken[2048];
; 3658 : 		int id;
; 3659 : 		int x;
; 3660 : 		int y;
; 3661 : 		int dir;
; 3662 : 		int graNo;
; 3663 : 		int level;
; 3664 : 		int nameColor;
; 3665 : 		char name[2048];
; 3666 : 		char freeName[2048];
; 3667 : 		int walkable;
; 3668 : 		int height;
; 3669 : 		int charType;
; 3670 : 		int ps=1;

  000b2	c7 85 64 e7 ff
	ff 01 00 00 00	 mov	 DWORD PTR _ps$1[ebp], 1

; 3671 : #ifdef _OBJSEND_C
; 3672 : 		ps = 2;

  000bc	c7 85 64 e7 ff
	ff 02 00 00 00	 mov	 DWORD PTR _ps$1[ebp], 2

; 3673 : #endif
; 3674 : 		charType = getIntegerToken( cdata, '|', ps++);

  000c6	8b 85 64 e7 ff
	ff		 mov	 eax, DWORD PTR _ps$1[ebp]
  000cc	89 85 5c e1 ff
	ff		 mov	 DWORD PTR tv87[ebp], eax
  000d2	8b 8d 64 e7 ff
	ff		 mov	 ecx, DWORD PTR _ps$1[ebp]
  000d8	83 c1 01	 add	 ecx, 1
  000db	89 8d 64 e7 ff
	ff		 mov	 DWORD PTR _ps$1[ebp], ecx
  000e1	8b 95 5c e1 ff
	ff		 mov	 edx, DWORD PTR tv87[ebp]
  000e7	52		 push	 edx
  000e8	6a 7c		 push	 124			; 0000007cH
  000ea	8b 45 28	 mov	 eax, DWORD PTR _cdata$[ebp]
  000ed	50		 push	 eax
  000ee	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  000f3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f6	89 85 70 e7 ff
	ff		 mov	 DWORD PTR _charType$2[ebp], eax

; 3675 : 		getStringToken( cdata, '|', ps++, sizeof(smalltoken) - 1, smalltoken);

  000fc	8b 85 64 e7 ff
	ff		 mov	 eax, DWORD PTR _ps$1[ebp]
  00102	89 85 5c e1 ff
	ff		 mov	 DWORD PTR tv95[ebp], eax
  00108	8b 8d 64 e7 ff
	ff		 mov	 ecx, DWORD PTR _ps$1[ebp]
  0010e	83 c1 01	 add	 ecx, 1
  00111	89 8d 64 e7 ff
	ff		 mov	 DWORD PTR _ps$1[ebp], ecx
  00117	8d 95 f8 f7 ff
	ff		 lea	 edx, DWORD PTR _smalltoken$14[ebp]
  0011d	52		 push	 edx
  0011e	68 ff 07 00 00	 push	 2047			; 000007ffH
  00123	8b 85 5c e1 ff
	ff		 mov	 eax, DWORD PTR tv95[ebp]
  00129	50		 push	 eax
  0012a	6a 7c		 push	 124			; 0000007cH
  0012c	8b 4d 28	 mov	 ecx, DWORD PTR _cdata$[ebp]
  0012f	51		 push	 ecx
  00130	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00135	83 c4 14	 add	 esp, 20			; 00000014H

; 3676 : 		id = a62toi(smalltoken);

  00138	8d 85 f8 f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$14[ebp]
  0013e	50		 push	 eax
  0013f	e8 00 00 00 00	 call	 ?a62toi@@YAHPAD@Z	; a62toi
  00144	83 c4 04	 add	 esp, 4
  00147	89 85 ec f7 ff
	ff		 mov	 DWORD PTR _id$13[ebp], eax

; 3677 : 		getStringToken( cdata, '|', ps++, sizeof(smalltoken) - 1, smalltoken);

  0014d	8b 85 64 e7 ff
	ff		 mov	 eax, DWORD PTR _ps$1[ebp]
  00153	89 85 5c e1 ff
	ff		 mov	 DWORD PTR tv136[ebp], eax
  00159	8b 8d 64 e7 ff
	ff		 mov	 ecx, DWORD PTR _ps$1[ebp]
  0015f	83 c1 01	 add	 ecx, 1
  00162	89 8d 64 e7 ff
	ff		 mov	 DWORD PTR _ps$1[ebp], ecx
  00168	8d 95 f8 f7 ff
	ff		 lea	 edx, DWORD PTR _smalltoken$14[ebp]
  0016e	52		 push	 edx
  0016f	68 ff 07 00 00	 push	 2047			; 000007ffH
  00174	8b 85 5c e1 ff
	ff		 mov	 eax, DWORD PTR tv136[ebp]
  0017a	50		 push	 eax
  0017b	6a 7c		 push	 124			; 0000007cH
  0017d	8b 4d 28	 mov	 ecx, DWORD PTR _cdata$[ebp]
  00180	51		 push	 ecx
  00181	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00186	83 c4 14	 add	 esp, 20			; 00000014H

; 3678 : 		x = atoi(smalltoken);

  00189	8b f4		 mov	 esi, esp
  0018b	8d 85 f8 f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$14[ebp]
  00191	50		 push	 eax
  00192	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00198	83 c4 04	 add	 esp, 4
  0019b	3b f4		 cmp	 esi, esp
  0019d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a2	89 85 e0 f7 ff
	ff		 mov	 DWORD PTR _x$12[ebp], eax

; 3679 : 		getStringToken( cdata, '|', ps++, sizeof(smalltoken) - 1, smalltoken);

  001a8	8b 85 64 e7 ff
	ff		 mov	 eax, DWORD PTR _ps$1[ebp]
  001ae	89 85 5c e1 ff
	ff		 mov	 DWORD PTR tv145[ebp], eax
  001b4	8b 8d 64 e7 ff
	ff		 mov	 ecx, DWORD PTR _ps$1[ebp]
  001ba	83 c1 01	 add	 ecx, 1
  001bd	89 8d 64 e7 ff
	ff		 mov	 DWORD PTR _ps$1[ebp], ecx
  001c3	8d 95 f8 f7 ff
	ff		 lea	 edx, DWORD PTR _smalltoken$14[ebp]
  001c9	52		 push	 edx
  001ca	68 ff 07 00 00	 push	 2047			; 000007ffH
  001cf	8b 85 5c e1 ff
	ff		 mov	 eax, DWORD PTR tv145[ebp]
  001d5	50		 push	 eax
  001d6	6a 7c		 push	 124			; 0000007cH
  001d8	8b 4d 28	 mov	 ecx, DWORD PTR _cdata$[ebp]
  001db	51		 push	 ecx
  001dc	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  001e1	83 c4 14	 add	 esp, 20			; 00000014H

; 3680 : 		y = atoi(smalltoken);

  001e4	8b f4		 mov	 esi, esp
  001e6	8d 85 f8 f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$14[ebp]
  001ec	50		 push	 eax
  001ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  001f3	83 c4 04	 add	 esp, 4
  001f6	3b f4		 cmp	 esi, esp
  001f8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001fd	89 85 d4 f7 ff
	ff		 mov	 DWORD PTR _y$11[ebp], eax

; 3681 : 		getStringToken( cdata, '|', ps++, sizeof(smalltoken) - 1, smalltoken);

  00203	8b 85 64 e7 ff
	ff		 mov	 eax, DWORD PTR _ps$1[ebp]
  00209	89 85 5c e1 ff
	ff		 mov	 DWORD PTR tv154[ebp], eax
  0020f	8b 8d 64 e7 ff
	ff		 mov	 ecx, DWORD PTR _ps$1[ebp]
  00215	83 c1 01	 add	 ecx, 1
  00218	89 8d 64 e7 ff
	ff		 mov	 DWORD PTR _ps$1[ebp], ecx
  0021e	8d 95 f8 f7 ff
	ff		 lea	 edx, DWORD PTR _smalltoken$14[ebp]
  00224	52		 push	 edx
  00225	68 ff 07 00 00	 push	 2047			; 000007ffH
  0022a	8b 85 5c e1 ff
	ff		 mov	 eax, DWORD PTR tv154[ebp]
  00230	50		 push	 eax
  00231	6a 7c		 push	 124			; 0000007cH
  00233	8b 4d 28	 mov	 ecx, DWORD PTR _cdata$[ebp]
  00236	51		 push	 ecx
  00237	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0023c	83 c4 14	 add	 esp, 20			; 00000014H

; 3682 : 		dir = (atoi(smalltoken)+3)%8;

  0023f	8b f4		 mov	 esi, esp
  00241	8d 85 f8 f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$14[ebp]
  00247	50		 push	 eax
  00248	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0024e	83 c4 04	 add	 esp, 4
  00251	3b f4		 cmp	 esi, esp
  00253	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00258	83 c0 03	 add	 eax, 3
  0025b	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00260	79 05		 jns	 SHORT $LN21@lssproto_P
  00262	48		 dec	 eax
  00263	83 c8 f8	 or	 eax, -8			; fffffff8H
  00266	40		 inc	 eax
$LN21@lssproto_P:
  00267	89 85 c8 f7 ff
	ff		 mov	 DWORD PTR _dir$10[ebp], eax

; 3683 : 		getStringToken( cdata, '|', ps++, sizeof(smalltoken) - 1, smalltoken);

  0026d	8b 85 64 e7 ff
	ff		 mov	 eax, DWORD PTR _ps$1[ebp]
  00273	89 85 5c e1 ff
	ff		 mov	 DWORD PTR tv165[ebp], eax
  00279	8b 8d 64 e7 ff
	ff		 mov	 ecx, DWORD PTR _ps$1[ebp]
  0027f	83 c1 01	 add	 ecx, 1
  00282	89 8d 64 e7 ff
	ff		 mov	 DWORD PTR _ps$1[ebp], ecx
  00288	8d 95 f8 f7 ff
	ff		 lea	 edx, DWORD PTR _smalltoken$14[ebp]
  0028e	52		 push	 edx
  0028f	68 ff 07 00 00	 push	 2047			; 000007ffH
  00294	8b 85 5c e1 ff
	ff		 mov	 eax, DWORD PTR tv165[ebp]
  0029a	50		 push	 eax
  0029b	6a 7c		 push	 124			; 0000007cH
  0029d	8b 4d 28	 mov	 ecx, DWORD PTR _cdata$[ebp]
  002a0	51		 push	 ecx
  002a1	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  002a6	83 c4 14	 add	 esp, 20			; 00000014H

; 3684 : 		graNo = atoi(smalltoken);

  002a9	8b f4		 mov	 esi, esp
  002ab	8d 85 f8 f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$14[ebp]
  002b1	50		 push	 eax
  002b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  002b8	83 c4 04	 add	 esp, 4
  002bb	3b f4		 cmp	 esi, esp
  002bd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002c2	89 85 bc f7 ff
	ff		 mov	 DWORD PTR _graNo$9[ebp], eax

; 3685 : 		getStringToken( cdata, '|', ps++, sizeof(smalltoken) - 1,smalltoken);

  002c8	8b 85 64 e7 ff
	ff		 mov	 eax, DWORD PTR _ps$1[ebp]
  002ce	89 85 5c e1 ff
	ff		 mov	 DWORD PTR tv174[ebp], eax
  002d4	8b 8d 64 e7 ff
	ff		 mov	 ecx, DWORD PTR _ps$1[ebp]
  002da	83 c1 01	 add	 ecx, 1
  002dd	89 8d 64 e7 ff
	ff		 mov	 DWORD PTR _ps$1[ebp], ecx
  002e3	8d 95 f8 f7 ff
	ff		 lea	 edx, DWORD PTR _smalltoken$14[ebp]
  002e9	52		 push	 edx
  002ea	68 ff 07 00 00	 push	 2047			; 000007ffH
  002ef	8b 85 5c e1 ff
	ff		 mov	 eax, DWORD PTR tv174[ebp]
  002f5	50		 push	 eax
  002f6	6a 7c		 push	 124			; 0000007cH
  002f8	8b 4d 28	 mov	 ecx, DWORD PTR _cdata$[ebp]
  002fb	51		 push	 ecx
  002fc	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00301	83 c4 14	 add	 esp, 20			; 00000014H

; 3686 : 		level = atoi(smalltoken);

  00304	8b f4		 mov	 esi, esp
  00306	8d 85 f8 f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$14[ebp]
  0030c	50		 push	 eax
  0030d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00313	83 c4 04	 add	 esp, 4
  00316	3b f4		 cmp	 esi, esp
  00318	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0031d	89 85 b0 f7 ff
	ff		 mov	 DWORD PTR _level$8[ebp], eax

; 3687 : 		nameColor = getIntegerToken( cdata, '|', ps++ );

  00323	8b 85 64 e7 ff
	ff		 mov	 eax, DWORD PTR _ps$1[ebp]
  00329	89 85 5c e1 ff
	ff		 mov	 DWORD PTR tv181[ebp], eax
  0032f	8b 8d 64 e7 ff
	ff		 mov	 ecx, DWORD PTR _ps$1[ebp]
  00335	83 c1 01	 add	 ecx, 1
  00338	89 8d 64 e7 ff
	ff		 mov	 DWORD PTR _ps$1[ebp], ecx
  0033e	8b 95 5c e1 ff
	ff		 mov	 edx, DWORD PTR tv181[ebp]
  00344	52		 push	 edx
  00345	6a 7c		 push	 124			; 0000007cH
  00347	8b 45 28	 mov	 eax, DWORD PTR _cdata$[ebp]
  0034a	50		 push	 eax
  0034b	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00350	83 c4 0c	 add	 esp, 12			; 0000000cH
  00353	89 85 a4 f7 ff
	ff		 mov	 DWORD PTR _nameColor$7[ebp], eax

; 3688 : 		getStringToken( cdata, '|' , ps++ , sizeof(name) - 1, name );

  00359	8b 85 64 e7 ff
	ff		 mov	 eax, DWORD PTR _ps$1[ebp]
  0035f	89 85 5c e1 ff
	ff		 mov	 DWORD PTR tv189[ebp], eax
  00365	8b 8d 64 e7 ff
	ff		 mov	 ecx, DWORD PTR _ps$1[ebp]
  0036b	83 c1 01	 add	 ecx, 1
  0036e	89 8d 64 e7 ff
	ff		 mov	 DWORD PTR _ps$1[ebp], ecx
  00374	8d 95 9c ef ff
	ff		 lea	 edx, DWORD PTR _name$6[ebp]
  0037a	52		 push	 edx
  0037b	68 ff 07 00 00	 push	 2047			; 000007ffH
  00380	8b 85 5c e1 ff
	ff		 mov	 eax, DWORD PTR tv189[ebp]
  00386	50		 push	 eax
  00387	6a 7c		 push	 124			; 0000007cH
  00389	8b 4d 28	 mov	 ecx, DWORD PTR _cdata$[ebp]
  0038c	51		 push	 ecx
  0038d	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00392	83 c4 14	 add	 esp, 20			; 00000014H

; 3689 : 		makeStringFromEscaped(name);

  00395	8d 85 9c ef ff
	ff		 lea	 eax, DWORD PTR _name$6[ebp]
  0039b	50		 push	 eax
  0039c	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  003a1	83 c4 04	 add	 esp, 4

; 3690 : 		getStringToken( cdata, '|' , ps++ , sizeof( freeName ) - 1, freeName );

  003a4	8b 85 64 e7 ff
	ff		 mov	 eax, DWORD PTR _ps$1[ebp]
  003aa	89 85 5c e1 ff
	ff		 mov	 DWORD PTR tv197[ebp], eax
  003b0	8b 8d 64 e7 ff
	ff		 mov	 ecx, DWORD PTR _ps$1[ebp]
  003b6	83 c1 01	 add	 ecx, 1
  003b9	89 8d 64 e7 ff
	ff		 mov	 DWORD PTR _ps$1[ebp], ecx
  003bf	8d 95 94 e7 ff
	ff		 lea	 edx, DWORD PTR _freeName$5[ebp]
  003c5	52		 push	 edx
  003c6	68 ff 07 00 00	 push	 2047			; 000007ffH
  003cb	8b 85 5c e1 ff
	ff		 mov	 eax, DWORD PTR tv197[ebp]
  003d1	50		 push	 eax
  003d2	6a 7c		 push	 124			; 0000007cH
  003d4	8b 4d 28	 mov	 ecx, DWORD PTR _cdata$[ebp]
  003d7	51		 push	 ecx
  003d8	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  003dd	83 c4 14	 add	 esp, 20			; 00000014H

; 3691 : 		makeStringFromEscaped( freeName );

  003e0	8d 85 94 e7 ff
	ff		 lea	 eax, DWORD PTR _freeName$5[ebp]
  003e6	50		 push	 eax
  003e7	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  003ec	83 c4 04	 add	 esp, 4

; 3692 : 		getStringToken( cdata, '|', ps++, sizeof(smalltoken) - 1, smalltoken);

  003ef	8b 85 64 e7 ff
	ff		 mov	 eax, DWORD PTR _ps$1[ebp]
  003f5	89 85 5c e1 ff
	ff		 mov	 DWORD PTR tv205[ebp], eax
  003fb	8b 8d 64 e7 ff
	ff		 mov	 ecx, DWORD PTR _ps$1[ebp]
  00401	83 c1 01	 add	 ecx, 1
  00404	89 8d 64 e7 ff
	ff		 mov	 DWORD PTR _ps$1[ebp], ecx
  0040a	8d 95 f8 f7 ff
	ff		 lea	 edx, DWORD PTR _smalltoken$14[ebp]
  00410	52		 push	 edx
  00411	68 ff 07 00 00	 push	 2047			; 000007ffH
  00416	8b 85 5c e1 ff
	ff		 mov	 eax, DWORD PTR tv205[ebp]
  0041c	50		 push	 eax
  0041d	6a 7c		 push	 124			; 0000007cH
  0041f	8b 4d 28	 mov	 ecx, DWORD PTR _cdata$[ebp]
  00422	51		 push	 ecx
  00423	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00428	83 c4 14	 add	 esp, 20			; 00000014H

; 3693 : 		walkable = atoi(smalltoken);

  0042b	8b f4		 mov	 esi, esp
  0042d	8d 85 f8 f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$14[ebp]
  00433	50		 push	 eax
  00434	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0043a	83 c4 04	 add	 esp, 4
  0043d	3b f4		 cmp	 esi, esp
  0043f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00444	89 85 88 e7 ff
	ff		 mov	 DWORD PTR _walkable$4[ebp], eax

; 3694 : 		getStringToken( cdata, '|', ps++, sizeof(smalltoken) - 1, smalltoken);

  0044a	8b 85 64 e7 ff
	ff		 mov	 eax, DWORD PTR _ps$1[ebp]
  00450	89 85 5c e1 ff
	ff		 mov	 DWORD PTR tv214[ebp], eax
  00456	8b 8d 64 e7 ff
	ff		 mov	 ecx, DWORD PTR _ps$1[ebp]
  0045c	83 c1 01	 add	 ecx, 1
  0045f	89 8d 64 e7 ff
	ff		 mov	 DWORD PTR _ps$1[ebp], ecx
  00465	8d 95 f8 f7 ff
	ff		 lea	 edx, DWORD PTR _smalltoken$14[ebp]
  0046b	52		 push	 edx
  0046c	68 ff 07 00 00	 push	 2047			; 000007ffH
  00471	8b 85 5c e1 ff
	ff		 mov	 eax, DWORD PTR tv214[ebp]
  00477	50		 push	 eax
  00478	6a 7c		 push	 124			; 0000007cH
  0047a	8b 4d 28	 mov	 ecx, DWORD PTR _cdata$[ebp]
  0047d	51		 push	 ecx
  0047e	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00483	83 c4 14	 add	 esp, 20			; 00000014H

; 3695 : 		height = atoi(smalltoken);

  00486	8b f4		 mov	 esi, esp
  00488	8d 85 f8 f7 ff
	ff		 lea	 eax, DWORD PTR _smalltoken$14[ebp]
  0048e	50		 push	 eax
  0048f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00495	83 c4 04	 add	 esp, 4
  00498	3b f4		 cmp	 esi, esp
  0049a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0049f	89 85 7c e7 ff
	ff		 mov	 DWORD PTR _height$3[ebp], eax

; 3696 : 
; 3697 : 		// ???雪??????????
; 3698 : 		if ( setReturnPetObj( id, graNo, x, y, dir, name, freeName,

  004a5	8b 85 70 e7 ff
	ff		 mov	 eax, DWORD PTR _charType$2[ebp]
  004ab	50		 push	 eax
  004ac	8b 8d 7c e7 ff
	ff		 mov	 ecx, DWORD PTR _height$3[ebp]
  004b2	51		 push	 ecx
  004b3	8b 95 88 e7 ff
	ff		 mov	 edx, DWORD PTR _walkable$4[ebp]
  004b9	52		 push	 edx
  004ba	8b 85 a4 f7 ff
	ff		 mov	 eax, DWORD PTR _nameColor$7[ebp]
  004c0	50		 push	 eax
  004c1	8b 8d b0 f7 ff
	ff		 mov	 ecx, DWORD PTR _level$8[ebp]
  004c7	51		 push	 ecx
  004c8	8d 95 94 e7 ff
	ff		 lea	 edx, DWORD PTR _freeName$5[ebp]
  004ce	52		 push	 edx
  004cf	8d 85 9c ef ff
	ff		 lea	 eax, DWORD PTR _name$6[ebp]
  004d5	50		 push	 eax
  004d6	8b 8d c8 f7 ff
	ff		 mov	 ecx, DWORD PTR _dir$10[ebp]
  004dc	51		 push	 ecx
  004dd	8b 95 d4 f7 ff
	ff		 mov	 edx, DWORD PTR _y$11[ebp]
  004e3	52		 push	 edx
  004e4	8b 85 e0 f7 ff
	ff		 mov	 eax, DWORD PTR _x$12[ebp]
  004ea	50		 push	 eax
  004eb	8b 8d bc f7 ff
	ff		 mov	 ecx, DWORD PTR _graNo$9[ebp]
  004f1	51		 push	 ecx
  004f2	8b 95 ec f7 ff
	ff		 mov	 edx, DWORD PTR _id$13[ebp]
  004f8	52		 push	 edx
  004f9	e8 00 00 00 00	 call	 ?setReturnPetObj@@YAHHHHHHPAD0HHHHH@Z ; setReturnPetObj
  004fe	83 c4 30	 add	 esp, 48			; 00000030H
  00501	85 c0		 test	 eax, eax
  00503	74 71		 je	 SHORT $LN1@lssproto_P

; 3699 : 			level, nameColor, walkable, height, charType ) )
; 3700 : 		{
; 3701 : 			switch ( no )

  00505	8b 45 24	 mov	 eax, DWORD PTR _no$[ebp]
  00508	89 85 5c e1 ff
	ff		 mov	 DWORD PTR tv233[ebp], eax
  0050e	83 bd 5c e1 ff
	ff 00		 cmp	 DWORD PTR tv233[ebp], 0
  00515	74 0b		 je	 SHORT $LN13@lssproto_P
  00517	83 bd 5c e1 ff
	ff 01		 cmp	 DWORD PTR tv233[ebp], 1
  0051e	74 2d		 je	 SHORT $LN14@lssproto_P
  00520	eb 54		 jmp	 SHORT $LN1@lssproto_P
$LN13@lssproto_P:

; 3702 : 			{
; 3703 : 				case 0:
; 3704 : 					createPetAction( graphicsno, x, y, dir, 1, 0, objindex );

  00522	8b 45 0c	 mov	 eax, DWORD PTR _objindex$[ebp]
  00525	50		 push	 eax
  00526	6a 00		 push	 0
  00528	6a 01		 push	 1
  0052a	8b 8d c8 f7 ff
	ff		 mov	 ecx, DWORD PTR _dir$10[ebp]
  00530	51		 push	 ecx
  00531	8b 95 d4 f7 ff
	ff		 mov	 edx, DWORD PTR _y$11[ebp]
  00537	52		 push	 edx
  00538	8b 85 e0 f7 ff
	ff		 mov	 eax, DWORD PTR _x$12[ebp]
  0053e	50		 push	 eax
  0053f	8b 4d 10	 mov	 ecx, DWORD PTR _graphicsno$[ebp]
  00542	51		 push	 ecx
  00543	e8 00 00 00 00	 call	 ?createPetAction@@YAPAUaction@@HHHHHHH@Z ; createPetAction
  00548	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3705 : 					break;

  0054b	eb 29		 jmp	 SHORT $LN1@lssproto_P
$LN14@lssproto_P:

; 3706 : 
; 3707 : 				case 1:
; 3708 : 					createPetAction( graphicsno, x, y, dir, 3, 0, objindex );

  0054d	8b 45 0c	 mov	 eax, DWORD PTR _objindex$[ebp]
  00550	50		 push	 eax
  00551	6a 00		 push	 0
  00553	6a 03		 push	 3
  00555	8b 8d c8 f7 ff
	ff		 mov	 ecx, DWORD PTR _dir$10[ebp]
  0055b	51		 push	 ecx
  0055c	8b 95 d4 f7 ff
	ff		 mov	 edx, DWORD PTR _y$11[ebp]
  00562	52		 push	 edx
  00563	8b 85 e0 f7 ff
	ff		 mov	 eax, DWORD PTR _x$12[ebp]
  00569	50		 push	 eax
  0056a	8b 4d 10	 mov	 ecx, DWORD PTR _graphicsno$[ebp]
  0056d	51		 push	 ecx
  0056e	e8 00 00 00 00	 call	 ?createPetAction@@YAPAUaction@@HHHHHHH@Z ; createPetAction
  00573	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN1@lssproto_P:

; 3709 : 					break;
; 3710 : 			}
; 3711 : 		}
; 3712 : 	}
; 3713 : }

  00576	52		 push	 edx
  00577	8b cd		 mov	 ecx, ebp
  00579	50		 push	 eax
  0057a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN20@lssproto_P
  00580	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00585	58		 pop	 eax
  00586	5a		 pop	 edx
  00587	5f		 pop	 edi
  00588	5e		 pop	 esi
  00589	5b		 pop	 ebx
  0058a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0058d	33 cd		 xor	 ecx, ebp
  0058f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00594	81 c4 a4 1e 00
	00		 add	 esp, 7844		; 00001ea4H
  0059a	3b ec		 cmp	 ebp, esp
  0059c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  005a1	8b e5		 mov	 esp, ebp
  005a3	5d		 pop	 ebp
  005a4	c3		 ret	 0
  005a5	0f 1f 00	 npad	 3
$LN20@lssproto_P:
  005a8	03 00 00 00	 DD	 3
  005ac	00 00 00 00	 DD	 $LN19@lssproto_P
$LN19@lssproto_P:
  005b0	f8 f7 ff ff	 DD	 -2056			; fffff7f8H
  005b4	00 08 00 00	 DD	 2048			; 00000800H
  005b8	00 00 00 00	 DD	 $LN16@lssproto_P
  005bc	9c ef ff ff	 DD	 -4196			; ffffef9cH
  005c0	00 08 00 00	 DD	 2048			; 00000800H
  005c4	00 00 00 00	 DD	 $LN17@lssproto_P
  005c8	94 e7 ff ff	 DD	 -6252			; ffffe794H
  005cc	00 08 00 00	 DD	 2048			; 00000800H
  005d0	00 00 00 00	 DD	 $LN18@lssproto_P
$LN18@lssproto_P:
  005d4	66		 DB	 102			; 00000066H
  005d5	72		 DB	 114			; 00000072H
  005d6	65		 DB	 101			; 00000065H
  005d7	65		 DB	 101			; 00000065H
  005d8	4e		 DB	 78			; 0000004eH
  005d9	61		 DB	 97			; 00000061H
  005da	6d		 DB	 109			; 0000006dH
  005db	65		 DB	 101			; 00000065H
  005dc	00		 DB	 0
$LN17@lssproto_P:
  005dd	6e		 DB	 110			; 0000006eH
  005de	61		 DB	 97			; 00000061H
  005df	6d		 DB	 109			; 0000006dH
  005e0	65		 DB	 101			; 00000065H
  005e1	00		 DB	 0
$LN16@lssproto_P:
  005e2	73		 DB	 115			; 00000073H
  005e3	6d		 DB	 109			; 0000006dH
  005e4	61		 DB	 97			; 00000061H
  005e5	6c		 DB	 108			; 0000006cH
  005e6	6c		 DB	 108			; 0000006cH
  005e7	74		 DB	 116			; 00000074H
  005e8	6f		 DB	 111			; 0000006fH
  005e9	6b		 DB	 107			; 0000006bH
  005ea	65		 DB	 101			; 00000065H
  005eb	6e		 DB	 110			; 0000006eH
  005ec	00		 DB	 0
?lssproto_PME_recv@@YAXHHHHHHHHPAD@Z ENDP		; lssproto_PME_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_MSG_recv@@YAXHHPADH@Z
_TEXT	SEGMENT
_noReadFlag$ = -276					; size = 4
_moji$ = -264						; size = 256
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_aindex$ = 12						; size = 4
_text$ = 16						; size = 4
_color$ = 20						; size = 4
?lssproto_MSG_recv@@YAXHHPADH@Z PROC			; lssproto_MSG_recv, COMDAT

; 3974 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 01 00
	00		 sub	 esp, 472		; 000001d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-472]
  00012	b9 76 00 00 00	 mov	 ecx, 118		; 00000076H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3975 : 	char moji[ 256 ];
; 3976 : 	int noReadFlag;
; 3977 : 	
; 3978 : 	// ???????????
; 3979 : 	mailLamp = TRUE;

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	66 a3 00 00 00
	00		 mov	 WORD PTR ?mailLamp@@3FA, ax ; mailLamp

; 3980 : 	
; 3981 : 	// ???k???
; 3982 : 	MailHistory[ aindex ].newHistoryNo--;

  00033	69 45 0c f0 0e
	00 00		 imul	 eax, DWORD PTR _aindex$[ebp], 3824
  0003a	8b 88 ec 0e 00
	00		 mov	 ecx, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[eax+3820]
  00040	83 e9 01	 sub	 ecx, 1
  00043	69 55 0c f0 0e
	00 00		 imul	 edx, DWORD PTR _aindex$[ebp], 3824
  0004a	89 8a ec 0e 00
	00		 mov	 DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[edx+3820], ecx

; 3983 : 	// ????????
; 3984 : 	if ( MailHistory[ aindex ].newHistoryNo <= -1 ) MailHistory[ aindex ].newHistoryNo = MAIL_MAX_HISTORY - 1;

  00050	69 45 0c f0 0e
	00 00		 imul	 eax, DWORD PTR _aindex$[ebp], 3824
  00057	83 b8 ec 0e 00
	00 ff		 cmp	 DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[eax+3820], -1
  0005e	7f 11		 jg	 SHORT $LN2@lssproto_M
  00060	69 45 0c f0 0e
	00 00		 imul	 eax, DWORD PTR _aindex$[ebp], 3824
  00067	c7 80 ec 0e 00
	00 13 00 00 00	 mov	 DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[eax+3820], 19 ; 00000013H
$LN2@lssproto_M:

; 3985 : 	
; 3986 : 	// T????
; 3987 : 	getStringToken( text, '|', 1, sizeof( MailHistory[ aindex ].dateStr[ MailHistory[ aindex ].newHistoryNo ] ) - 1, 

  00071	69 45 0c f0 0e
	00 00		 imul	 eax, DWORD PTR _aindex$[ebp], 3824
  00078	69 4d 0c f0 0e
	00 00		 imul	 ecx, DWORD PTR _aindex$[ebp], 3824
  0007f	6b 91 ec 0e 00
	00 15		 imul	 edx, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[ecx+3820], 21
  00086	8d 84 10 04 0b
	00 00		 lea	 eax, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[eax+edx+2820]
  0008d	50		 push	 eax
  0008e	6a 14		 push	 20			; 00000014H
  00090	6a 01		 push	 1
  00092	6a 7c		 push	 124			; 0000007cH
  00094	8b 4d 10	 mov	 ecx, DWORD PTR _text$[ebp]
  00097	51		 push	 ecx
  00098	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0009d	83 c4 14	 add	 esp, 20			; 00000014H

; 3988 : 					MailHistory[ aindex ].dateStr[ MailHistory[ aindex ].newHistoryNo ] );
; 3989 : 	// 簖???
; 3990 : 	getStringToken( text, '|', 2, sizeof( MailHistory[ aindex ].str[ MailHistory[ aindex ].newHistoryNo ] ) - 1, 

  000a0	69 45 0c f0 0e
	00 00		 imul	 eax, DWORD PTR _aindex$[ebp], 3824
  000a7	69 4d 0c f0 0e
	00 00		 imul	 ecx, DWORD PTR _aindex$[ebp], 3824
  000ae	69 91 ec 0e 00
	00 8d 00 00 00	 imul	 edx, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[ecx+3820], 141
  000b8	8d 84 10 00 00
	00 00		 lea	 eax, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[eax+edx]
  000bf	50		 push	 eax
  000c0	68 8c 00 00 00	 push	 140			; 0000008cH
  000c5	6a 02		 push	 2
  000c7	6a 7c		 push	 124			; 0000007cH
  000c9	8b 4d 10	 mov	 ecx, DWORD PTR _text$[ebp]
  000cc	51		 push	 ecx
  000cd	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  000d2	83 c4 14	 add	 esp, 20			; 00000014H

; 3991 : 					MailHistory[ aindex ].str[ MailHistory[ aindex ].newHistoryNo ] );
; 3992 : 	// ????????
; 3993 : 	makeStringFromEscaped( MailHistory[ aindex ].str[ MailHistory[ aindex ].newHistoryNo ] );

  000d5	69 45 0c f0 0e
	00 00		 imul	 eax, DWORD PTR _aindex$[ebp], 3824
  000dc	69 4d 0c f0 0e
	00 00		 imul	 ecx, DWORD PTR _aindex$[ebp], 3824
  000e3	69 91 ec 0e 00
	00 8d 00 00 00	 imul	 edx, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[ecx+3820], 141
  000ed	8d 84 10 00 00
	00 00		 lea	 eax, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[eax+edx]
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  000fa	83 c4 04	 add	 esp, 4

; 3994 : 	
; 3995 : 	// ??????????k???
; 3996 : 	noReadFlag = getIntegerToken( text, '|', 3 );

  000fd	6a 03		 push	 3
  000ff	6a 7c		 push	 124			; 0000007cH
  00101	8b 45 10	 mov	 eax, DWORD PTR _text$[ebp]
  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0010a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010d	89 85 ec fe ff
	ff		 mov	 DWORD PTR _noReadFlag$[ebp], eax

; 3997 : 	// ????????
; 3998 : 	if ( noReadFlag != -1 ){

  00113	83 bd ec fe ff
	ff ff		 cmp	 DWORD PTR _noReadFlag$[ebp], -1
  0011a	0f 84 eb 00 00
	00		 je	 $LN3@lssproto_M

; 3999 : 		// ??????????k???
; 4000 : 		MailHistory[ aindex ].noReadFlag[ MailHistory[ aindex ].newHistoryNo ] = noReadFlag;

  00120	69 45 0c f0 0e
	00 00		 imul	 eax, DWORD PTR _aindex$[ebp], 3824
  00127	69 4d 0c f0 0e
	00 00		 imul	 ecx, DWORD PTR _aindex$[ebp], 3824
  0012e	8b 91 ec 0e 00
	00		 mov	 edx, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[ecx+3820]
  00134	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _noReadFlag$[ebp]
  0013a	89 8c 90 a8 0c
	00 00		 mov	 DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[eax+edx*4+3240], ecx

; 4001 : 		// ??????????
; 4002 : 		MailHistory[ aindex ].petLevel[ MailHistory[ aindex ].newHistoryNo ] = getIntegerToken( text, '|', 4 );

  00141	6a 04		 push	 4
  00143	6a 7c		 push	 124			; 0000007cH
  00145	8b 45 10	 mov	 eax, DWORD PTR _text$[ebp]
  00148	50		 push	 eax
  00149	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0014e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00151	69 4d 0c f0 0e
	00 00		 imul	 ecx, DWORD PTR _aindex$[ebp], 3824
  00158	69 55 0c f0 0e
	00 00		 imul	 edx, DWORD PTR _aindex$[ebp], 3824
  0015f	8b 92 ec 0e 00
	00		 mov	 edx, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[edx+3820]
  00165	89 84 91 f8 0c
	00 00		 mov	 DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[ecx+edx*4+3320], eax

; 4003 : 		// ????q???
; 4004 : 		getStringToken( text, '|', 5, sizeof( MailHistory[ aindex ].petName[ MailHistory[ aindex ].newHistoryNo ] ), 

  0016c	69 45 0c f0 0e
	00 00		 imul	 eax, DWORD PTR _aindex$[ebp], 3824
  00173	69 4d 0c f0 0e
	00 00		 imul	 ecx, DWORD PTR _aindex$[ebp], 3824
  0017a	6b 91 ec 0e 00
	00 11		 imul	 edx, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[ecx+3820], 17
  00181	8d 84 10 48 0d
	00 00		 lea	 eax, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[eax+edx+3400]
  00188	50		 push	 eax
  00189	6a 11		 push	 17			; 00000011H
  0018b	6a 05		 push	 5
  0018d	6a 7c		 push	 124			; 0000007cH
  0018f	8b 4d 10	 mov	 ecx, DWORD PTR _text$[ebp]
  00192	51		 push	 ecx
  00193	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00198	83 c4 14	 add	 esp, 20			; 00000014H

; 4005 : 						MailHistory[ aindex ].petName[ MailHistory[ aindex ].newHistoryNo ] );
; 4006 : 		// ????q?????????
; 4007 : 		makeStringFromEscaped( MailHistory[ aindex ].petName[ MailHistory[ aindex ].newHistoryNo ] );

  0019b	69 45 0c f0 0e
	00 00		 imul	 eax, DWORD PTR _aindex$[ebp], 3824
  001a2	69 4d 0c f0 0e
	00 00		 imul	 ecx, DWORD PTR _aindex$[ebp], 3824
  001a9	6b 91 ec 0e 00
	00 11		 imul	 edx, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[ecx+3820], 17
  001b0	8d 84 10 48 0d
	00 00		 lea	 eax, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[eax+edx+3400]
  001b7	50		 push	 eax
  001b8	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  001bd	83 c4 04	 add	 esp, 4

; 4008 : 		// ???????????k????
; 4009 : 		MailHistory[ aindex ].itemGraNo[ MailHistory[ aindex ].newHistoryNo ] = getIntegerToken( text, '|', 6 );

  001c0	6a 06		 push	 6
  001c2	6a 7c		 push	 124			; 0000007cH
  001c4	8b 45 10	 mov	 eax, DWORD PTR _text$[ebp]
  001c7	50		 push	 eax
  001c8	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  001cd	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d0	69 4d 0c f0 0e
	00 00		 imul	 ecx, DWORD PTR _aindex$[ebp], 3824
  001d7	69 55 0c f0 0e
	00 00		 imul	 edx, DWORD PTR _aindex$[ebp], 3824
  001de	8b 92 ec 0e 00
	00		 mov	 edx, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[edx+3820]
  001e4	89 84 91 9c 0e
	00 00		 mov	 DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[ecx+edx*4+3740], eax

; 4010 : 		// ????????????
; 4011 : 		sprintf( moji,"收到%s送来的宠物邮件！", addressBook[ aindex ].name );

  001eb	6b 45 0c 68	 imul	 eax, DWORD PTR _aindex$[ebp], 104
  001ef	05 14 00 00 00	 add	 eax, OFFSET ?addressBook@@3PAUADDRESS_BOOK@@A+20
  001f4	50		 push	 eax
  001f5	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@MGOKMGBK@?b?$KF?S?p?$CFs?a?j?$DP?n?$NM?$DP?Z?$KK?$DP?K?l?$KD?$KB?$AA@
  001fa	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _moji$[ebp]
  00200	51		 push	 ecx
  00201	e8 00 00 00 00	 call	 _sprintf
  00206	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4012 : 	}
; 4013 : 	// ?G?????
; 4014 : 	else{	

  00209	eb 3d		 jmp	 SHORT $LN4@lssproto_M
$LN3@lssproto_M:

; 4015 : 		MailHistory[ aindex ].noReadFlag[ MailHistory[ aindex ].newHistoryNo ] = TRUE;

  0020b	69 45 0c f0 0e
	00 00		 imul	 eax, DWORD PTR _aindex$[ebp], 3824
  00212	69 4d 0c f0 0e
	00 00		 imul	 ecx, DWORD PTR _aindex$[ebp], 3824
  00219	8b 91 ec 0e 00
	00		 mov	 edx, DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[ecx+3820]
  0021f	c7 84 90 a8 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR ?MailHistory@@3PAUMAIL_HISTORY@@A[eax+edx*4+3240], 1

; 4016 : 		// ????????????
; 4017 : 		sprintf( moji,"收到%s送来的邮件！", addressBook[ aindex ].name );

  0022a	6b 45 0c 68	 imul	 eax, DWORD PTR _aindex$[ebp], 104
  0022e	05 14 00 00 00	 add	 eax, OFFSET ?addressBook@@3PAUADDRESS_BOOK@@A+20
  00233	50		 push	 eax
  00234	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JIMIMFE@?b?$KF?S?p?$CFs?a?j?$DP?n?$NM?$DP?K?l?$KD?$KB?$AA@
  00239	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _moji$[ebp]
  0023f	51		 push	 ecx
  00240	e8 00 00 00 00	 call	 _sprintf
  00245	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@lssproto_M:

; 4018 : 	}
; 4019 : 	
; 4020 : 	// ??????????????????
; 4021 : 	StockChatBufferLine( moji, FONT_PAL_WHITE );

  00248	6a 00		 push	 0
  0024a	6a 00		 push	 0
  0024c	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _moji$[ebp]
  00252	50		 push	 eax
  00253	e8 00 00 00 00	 call	 ?StockChatBufferLine@@YAXPADEH@Z ; StockChatBufferLine
  00258	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4022 : 	
; 4023 : 	// ????????
; 4024 : 	if ( mailHistoryWndSelectNo == aindex ){

  0025b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?mailHistoryWndSelectNo@@3HA ; mailHistoryWndSelectNo
  00260	3b 45 0c	 cmp	 eax, DWORD PTR _aindex$[ebp]
  00263	75 20		 jne	 SHORT $LN5@lssproto_M

; 4025 : 		// ??????????????
; 4026 : 		mailHistoryWndPageNo++;

  00265	a1 00 00 00 00	 mov	 eax, DWORD PTR ?mailHistoryWndPageNo@@3HA ; mailHistoryWndPageNo
  0026a	83 c0 01	 add	 eax, 1
  0026d	a3 00 00 00 00	 mov	 DWORD PTR ?mailHistoryWndPageNo@@3HA, eax ; mailHistoryWndPageNo

; 4027 : 		// ????????
; 4028 : 		if ( mailHistoryWndPageNo >= MAIL_MAX_HISTORY ) mailHistoryWndPageNo = 0;

  00272	83 3d 00 00 00
	00 14		 cmp	 DWORD PTR ?mailHistoryWndPageNo@@3HA, 20 ; mailHistoryWndPageNo, 00000014H
  00279	7c 0a		 jl	 SHORT $LN5@lssproto_M
  0027b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?mailHistoryWndPageNo@@3HA, 0 ; mailHistoryWndPageNo
$LN5@lssproto_M:

; 4029 : 		// ?????????
; 4030 : 	//	DeathLetterAction();
; 4031 : 	}
; 4032 : 	// 觚?
; 4033 : 	play_se( 101, 320, 240 );

  00285	68 f0 00 00 00	 push	 240			; 000000f0H
  0028a	68 40 01 00 00	 push	 320			; 00000140H
  0028f	6a 65		 push	 101			; 00000065H
  00291	e8 00 00 00 00	 call	 ?play_se@@YAHHHH@Z	; play_se
  00296	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4034 : 	// ???????颌V
; 4035 : 	SaveMailHistory( aindex );

  00299	8b 45 0c	 mov	 eax, DWORD PTR _aindex$[ebp]
  0029c	50		 push	 eax
  0029d	e8 00 00 00 00	 call	 ?SaveMailHistory@@YAHH@Z ; SaveMailHistory
  002a2	83 c4 04	 add	 esp, 4

; 4036 : }

  002a5	52		 push	 edx
  002a6	8b cd		 mov	 ecx, ebp
  002a8	50		 push	 eax
  002a9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@lssproto_M
  002af	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002b4	58		 pop	 eax
  002b5	5a		 pop	 edx
  002b6	5f		 pop	 edi
  002b7	5e		 pop	 esi
  002b8	5b		 pop	 ebx
  002b9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002bc	33 cd		 xor	 ecx, ebp
  002be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002c3	81 c4 d8 01 00
	00		 add	 esp, 472		; 000001d8H
  002c9	3b ec		 cmp	 ebp, esp
  002cb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002d0	8b e5		 mov	 esp, ebp
  002d2	5d		 pop	 ebp
  002d3	c3		 ret	 0
$LN10@lssproto_M:
  002d4	01 00 00 00	 DD	 1
  002d8	00 00 00 00	 DD	 $LN9@lssproto_M
$LN9@lssproto_M:
  002dc	f8 fe ff ff	 DD	 -264			; fffffef8H
  002e0	00 01 00 00	 DD	 256			; 00000100H
  002e4	00 00 00 00	 DD	 $LN8@lssproto_M
$LN8@lssproto_M:
  002e8	6d		 DB	 109			; 0000006dH
  002e9	6f		 DB	 111			; 0000006fH
  002ea	6a		 DB	 106			; 0000006aH
  002eb	69		 DB	 105			; 00000069H
  002ec	00		 DB	 0
?lssproto_MSG_recv@@YAXHHPADH@Z ENDP			; lssproto_MSG_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_SI_recv@@YAXHHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
?lssproto_SI_recv@@YAXHHH@Z PROC			; lssproto_SI_recv, COMDAT

; 3505 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3506 : 	// ????????????????雪????
; 3507 : 	if ( logOutFlag )

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  00025	74 02		 je	 SHORT $LN2@lssproto_S

; 3508 : 		return;

  00027	eb 10		 jmp	 SHORT $LN1@lssproto_S
$LN2@lssproto_S:

; 3509 : 
; 3510 : 	swapItem( from, to );

  00029	8b 45 10	 mov	 eax, DWORD PTR _to$[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _from$[ebp]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 ?swapItem@@YAXHH@Z	; swapItem
  00036	83 c4 08	 add	 esp, 8
$LN1@lssproto_S:

; 3511 : }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?lssproto_SI_recv@@YAXHHH@Z ENDP			; lssproto_SI_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_I_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_type$1 = -1636						; size = 8
_alch$2 = -1620						; size = 256
_pile$3 = -1356						; size = 256
_damage$4 = -1092					; size = 256
_memo$ = -828						; size = 256
_name2$ = -564						; size = 256
_name$ = -300						; size = 256
_no$ = -36						; size = 4
_j$ = -24						; size = 4
_i$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_I_recv@@YAXHPAD@Z PROC			; lssproto_I_recv, COMDAT

; 3516 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 68 09 00
	00		 sub	 esp, 2408		; 00000968H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 98 f6 ff
	ff		 lea	 edi, DWORD PTR [ebp-2408]
  00012	b9 5a 02 00 00	 mov	 ecx, 602		; 0000025aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3517 : 	int i, j;
; 3518 : 	int no;
; 3519 : 	char name[256];
; 3520 : 	char name2[256];
; 3521 : 	char memo[256];
; 3522 : 
; 3523 : 	// ????????????????雪????
; 3524 : 	if ( logOutFlag )

  00028	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  0002f	74 05		 je	 SHORT $LN5@lssproto_I

; 3525 : 		return;

  00031	e9 41 04 00 00	 jmp	 $LN1@lssproto_I
$LN5@lssproto_I:

; 3526 : 
; 3527 : 	for ( j = 0; ; j++ ){

  00036	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  0003d	eb 09		 jmp	 SHORT $LN4@lssproto_I
$LN2@lssproto_I:
  0003f	8b 45 e8	 mov	 eax, DWORD PTR _j$[ebp]
  00042	83 c0 01	 add	 eax, 1
  00045	89 45 e8	 mov	 DWORD PTR _j$[ebp], eax
$LN4@lssproto_I:

; 3528 : 
; 3529 : #ifdef _PET_ITEM
; 3530 : 		//no = j * 14;
; 3531 : 		//CC FIX 这里修复成15？？？
; 3532 : 		no = j * 15;

  00048	6b 45 e8 0f	 imul	 eax, DWORD PTR _j$[ebp], 15
  0004c	89 45 dc	 mov	 DWORD PTR _no$[ebp], eax

; 3533 : #endif//_PET_ITEM
; 3534 : 
; 3535 : 		i = getIntegerToken(data, '|', no+1 );

  0004f	8b 45 dc	 mov	 eax, DWORD PTR _no$[ebp]
  00052	83 c0 01	 add	 eax, 1
  00055	50		 push	 eax
  00056	6a 7c		 push	 124			; 0000007cH
  00058	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH
  00064	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax

; 3536 : 		if ( getStringToken(data, '|', no+2, sizeof(name) - 1 , name ) == 1 )

  00067	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  0006d	50		 push	 eax
  0006e	68 ff 00 00 00	 push	 255			; 000000ffH
  00073	8b 4d dc	 mov	 ecx, DWORD PTR _no$[ebp]
  00076	83 c1 02	 add	 ecx, 2
  00079	51		 push	 ecx
  0007a	6a 7c		 push	 124			; 0000007cH
  0007c	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  0007f	52		 push	 edx
  00080	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00085	83 c4 14	 add	 esp, 20			; 00000014H
  00088	83 f8 01	 cmp	 eax, 1
  0008b	75 05		 jne	 SHORT $LN6@lssproto_I

; 3537 : 			break;

  0008d	e9 e5 03 00 00	 jmp	 $LN1@lssproto_I
$LN6@lssproto_I:

; 3538 : 		makeStringFromEscaped(name);

  00092	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  0009e	83 c4 04	 add	 esp, 4

; 3539 : 		if ( strlen(name) == 0 ){

  000a1	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  000a7	50		 push	 eax
  000a8	e8 00 00 00 00	 call	 _strlen
  000ad	83 c4 04	 add	 esp, 4
  000b0	85 c0		 test	 eax, eax
  000b2	75 15		 jne	 SHORT $LN7@lssproto_I

; 3540 : 			pc.item[i].useFlag = 0;

  000b4	69 45 f4 7c 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 380
  000bb	33 c9		 xor	 ecx, ecx
  000bd	66 89 88 a0 01
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A[eax+416], cx

; 3541 : 			continue;

  000c4	e9 76 ff ff ff	 jmp	 $LN2@lssproto_I
$LN7@lssproto_I:

; 3542 : 		}
; 3543 : 
; 3544 : 		pc.item[i].useFlag = 1;

  000c9	69 45 f4 7c 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 380
  000d0	b9 01 00 00 00	 mov	 ecx, 1
  000d5	66 89 88 a0 01
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A[eax+416], cx

; 3545 : 		if ( strlen(name) <= ITEM_NAME_LEN ){

  000dc	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  000e2	50		 push	 eax
  000e3	e8 00 00 00 00	 call	 _strlen
  000e8	83 c4 04	 add	 esp, 4
  000eb	83 f8 1c	 cmp	 eax, 28			; 0000001cH
  000ee	77 1d		 ja	 SHORT $LN8@lssproto_I

; 3546 : 			strcpy( pc.item[i].name, name );

  000f0	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  000f6	50		 push	 eax
  000f7	69 4d f4 7c 01
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 380
  000fe	81 c1 aa 01 00
	00		 add	 ecx, OFFSET ?pc@@3UPC@@A+426
  00104	51		 push	 ecx
  00105	e8 00 00 00 00	 call	 _strcpy
  0010a	83 c4 08	 add	 esp, 8
$LN8@lssproto_I:

; 3547 : 		}
; 3548 : 		getStringToken(data, '|', no+3, sizeof( name2 ) - 1, name2 );

  0010d	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _name2$[ebp]
  00113	50		 push	 eax
  00114	68 ff 00 00 00	 push	 255			; 000000ffH
  00119	8b 4d dc	 mov	 ecx, DWORD PTR _no$[ebp]
  0011c	83 c1 03	 add	 ecx, 3
  0011f	51		 push	 ecx
  00120	6a 7c		 push	 124			; 0000007cH
  00122	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  00125	52		 push	 edx
  00126	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0012b	83 c4 14	 add	 esp, 20			; 00000014H

; 3549 : 		makeStringFromEscaped( name2 );

  0012e	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _name2$[ebp]
  00134	50		 push	 eax
  00135	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  0013a	83 c4 04	 add	 esp, 4

; 3550 : 		if ( strlen( name2 ) <= ITEM_NAME2_LEN ){

  0013d	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _name2$[ebp]
  00143	50		 push	 eax
  00144	e8 00 00 00 00	 call	 _strlen
  00149	83 c4 04	 add	 esp, 4
  0014c	83 f8 10	 cmp	 eax, 16			; 00000010H
  0014f	77 1d		 ja	 SHORT $LN9@lssproto_I

; 3551 : 			strcpy( pc.item[i].name2, name2 );

  00151	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _name2$[ebp]
  00157	50		 push	 eax
  00158	69 4d f4 7c 01
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 380
  0015f	81 c1 c7 01 00
	00		 add	 ecx, OFFSET ?pc@@3UPC@@A+455
  00165	51		 push	 ecx
  00166	e8 00 00 00 00	 call	 _strcpy
  0016b	83 c4 08	 add	 esp, 8
$LN9@lssproto_I:

; 3552 : 		}
; 3553 : 		pc.item[i].color = getIntegerToken(data, '|', no+4 );

  0016e	8b 45 dc	 mov	 eax, DWORD PTR _no$[ebp]
  00171	83 c0 04	 add	 eax, 4
  00174	50		 push	 eax
  00175	6a 7c		 push	 124			; 0000007cH
  00177	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0017a	51		 push	 ecx
  0017b	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00180	83 c4 0c	 add	 esp, 12			; 0000000cH
  00183	69 55 f4 7c 01
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 380
  0018a	89 82 c4 00 00
	00		 mov	 DWORD PTR ?pc@@3UPC@@A[edx+196], eax

; 3554 : 		if ( pc.item[i].color < 0 )

  00190	69 45 f4 7c 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 380
  00197	83 b8 c4 00 00
	00 00		 cmp	 DWORD PTR ?pc@@3UPC@@A[eax+196], 0
  0019e	7d 11		 jge	 SHORT $LN10@lssproto_I

; 3555 : 			pc.item[i].color = 0;

  001a0	69 45 f4 7c 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 380
  001a7	c7 80 c4 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A[eax+196], 0
$LN10@lssproto_I:

; 3556 : 		getStringToken(data, '|', no+5, sizeof( memo ) - 1, memo );

  001b1	8d 85 c4 fc ff
	ff		 lea	 eax, DWORD PTR _memo$[ebp]
  001b7	50		 push	 eax
  001b8	68 ff 00 00 00	 push	 255			; 000000ffH
  001bd	8b 4d dc	 mov	 ecx, DWORD PTR _no$[ebp]
  001c0	83 c1 05	 add	 ecx, 5
  001c3	51		 push	 ecx
  001c4	6a 7c		 push	 124			; 0000007cH
  001c6	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  001c9	52		 push	 edx
  001ca	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  001cf	83 c4 14	 add	 esp, 20			; 00000014H

; 3557 : 		makeStringFromEscaped( memo );

  001d2	8d 85 c4 fc ff
	ff		 lea	 eax, DWORD PTR _memo$[ebp]
  001d8	50		 push	 eax
  001d9	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  001de	83 c4 04	 add	 esp, 4

; 3558 : 		if ( strlen( memo ) <= ITEM_MEMO_LEN ){

  001e1	8d 85 c4 fc ff
	ff		 lea	 eax, DWORD PTR _memo$[ebp]
  001e7	50		 push	 eax
  001e8	e8 00 00 00 00	 call	 _strlen
  001ed	83 c4 04	 add	 esp, 4
  001f0	83 f8 54	 cmp	 eax, 84			; 00000054H
  001f3	77 1d		 ja	 SHORT $LN11@lssproto_I

; 3559 : 			strcpy( pc.item[i].memo, memo );

  001f5	8d 85 c4 fc ff
	ff		 lea	 eax, DWORD PTR _memo$[ebp]
  001fb	50		 push	 eax
  001fc	69 4d f4 7c 01
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 380
  00203	81 c1 d8 01 00
	00		 add	 ecx, OFFSET ?pc@@3UPC@@A+472
  00209	51		 push	 ecx
  0020a	e8 00 00 00 00	 call	 _strcpy
  0020f	83 c4 08	 add	 esp, 8
$LN11@lssproto_I:

; 3560 : 		}
; 3561 : 		pc.item[i].graNo = getIntegerToken(data, '|', no+6 );

  00212	8b 45 dc	 mov	 eax, DWORD PTR _no$[ebp]
  00215	83 c0 06	 add	 eax, 6
  00218	50		 push	 eax
  00219	6a 7c		 push	 124			; 0000007cH
  0021b	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0021e	51		 push	 ecx
  0021f	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00224	83 c4 0c	 add	 esp, 12			; 0000000cH
  00227	69 55 f4 7c 01
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 380
  0022e	89 82 c8 00 00
	00		 mov	 DWORD PTR ?pc@@3UPC@@A[edx+200], eax

; 3562 : 		pc.item[i].field = getIntegerToken(data, '|', no+7 );

  00234	8b 45 dc	 mov	 eax, DWORD PTR _no$[ebp]
  00237	83 c0 07	 add	 eax, 7
  0023a	50		 push	 eax
  0023b	6a 7c		 push	 124			; 0000007cH
  0023d	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00240	51		 push	 ecx
  00241	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00246	83 c4 0c	 add	 esp, 12			; 0000000cH
  00249	69 55 f4 7c 01
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 380
  00250	66 89 82 a2 01
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A[edx+418], ax

; 3563 : 		pc.item[i].target = getIntegerToken(data, '|', no+8 );

  00257	8b 45 dc	 mov	 eax, DWORD PTR _no$[ebp]
  0025a	83 c0 08	 add	 eax, 8
  0025d	50		 push	 eax
  0025e	6a 7c		 push	 124			; 0000007cH
  00260	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00263	51		 push	 ecx
  00264	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00269	83 c4 0c	 add	 esp, 12			; 0000000cH
  0026c	69 55 f4 7c 01
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 380
  00273	66 89 82 a4 01
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A[edx+420], ax

; 3564 : 		if ( pc.item[i].target >= 100 ){

  0027a	69 45 f4 7c 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 380
  00281	0f bf 88 a4 01
	00 00		 movsx	 ecx, WORD PTR ?pc@@3UPC@@A[eax+420]
  00288	83 f9 64	 cmp	 ecx, 100		; 00000064H
  0028b	7c 39		 jl	 SHORT $LN12@lssproto_I

; 3565 : 			pc.item[i].target %= 100;

  0028d	69 45 f4 7c 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 380
  00294	0f bf 80 a4 01
	00 00		 movsx	 eax, WORD PTR ?pc@@3UPC@@A[eax+420]
  0029b	99		 cdq
  0029c	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  002a1	f7 f9		 idiv	 ecx
  002a3	69 45 f4 7c 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 380
  002aa	66 89 90 a4 01
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A[eax+420], dx

; 3566 : 			pc.item[i].deadTargetFlag = 1;

  002b1	69 45 f4 7c 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 380
  002b8	b9 01 00 00 00	 mov	 ecx, 1
  002bd	66 89 88 a6 01
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A[eax+422], cx

; 3567 : 		}else{

  002c4	eb 10		 jmp	 SHORT $LN13@lssproto_I
$LN12@lssproto_I:

; 3568 : 			pc.item[i].deadTargetFlag = 0;

  002c6	69 45 f4 7c 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 380
  002cd	33 c9		 xor	 ecx, ecx
  002cf	66 89 88 a6 01
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A[eax+422], cx
$LN13@lssproto_I:

; 3569 : 		}
; 3570 : 		pc.item[i].level = getIntegerToken(data, '|', no+9 );

  002d6	8b 45 dc	 mov	 eax, DWORD PTR _no$[ebp]
  002d9	83 c0 09	 add	 eax, 9
  002dc	50		 push	 eax
  002dd	6a 7c		 push	 124			; 0000007cH
  002df	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  002e2	51		 push	 ecx
  002e3	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  002e8	83 c4 0c	 add	 esp, 12			; 0000000cH
  002eb	69 55 f4 7c 01
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 380
  002f2	89 82 cc 00 00
	00		 mov	 DWORD PTR ?pc@@3UPC@@A[edx+204], eax

; 3571 : 		pc.item[i].sendFlag = getIntegerToken(data, '|', no+10 );

  002f8	8b 45 dc	 mov	 eax, DWORD PTR _no$[ebp]
  002fb	83 c0 0a	 add	 eax, 10			; 0000000aH
  002fe	50		 push	 eax
  002ff	6a 7c		 push	 124			; 0000007cH
  00301	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00304	51		 push	 ecx
  00305	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0030a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0030d	69 55 f4 7c 01
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 380
  00314	66 89 82 a8 01
	00 00		 mov	 WORD PTR ?pc@@3UPC@@A[edx+424], ax

; 3572 : 
; 3573 : 		{
; 3574 : 			// 显示物品耐久度
; 3575 : 			char damage[256];
; 3576 : 			getStringToken(data, '|', no+11, sizeof( damage ) - 1, damage );

  0031b	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR _damage$4[ebp]
  00321	50		 push	 eax
  00322	68 ff 00 00 00	 push	 255			; 000000ffH
  00327	8b 4d dc	 mov	 ecx, DWORD PTR _no$[ebp]
  0032a	83 c1 0b	 add	 ecx, 11			; 0000000bH
  0032d	51		 push	 ecx
  0032e	6a 7c		 push	 124			; 0000007cH
  00330	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  00333	52		 push	 edx
  00334	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00339	83 c4 14	 add	 esp, 20			; 00000014H

; 3577 : 			makeStringFromEscaped( damage );

  0033c	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR _damage$4[ebp]
  00342	50		 push	 eax
  00343	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  00348	83 c4 04	 add	 esp, 4

; 3578 : 			if ( strlen( damage ) <= 16 ){	

  0034b	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR _damage$4[ebp]
  00351	50		 push	 eax
  00352	e8 00 00 00 00	 call	 _strlen
  00357	83 c4 04	 add	 esp, 4
  0035a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0035d	77 1d		 ja	 SHORT $LN14@lssproto_I

; 3579 : 				strcpy( pc.item[i].damage, damage );

  0035f	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR _damage$4[ebp]
  00365	50		 push	 eax
  00366	69 4d f4 7c 01
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 380
  0036d	81 c1 2d 02 00
	00		 add	 ecx, OFFSET ?pc@@3UPC@@A+557
  00373	51		 push	 ecx
  00374	e8 00 00 00 00	 call	 _strcpy
  00379	83 c4 08	 add	 esp, 8
$LN14@lssproto_I:

; 3580 : 			}
; 3581 : 		} 
; 3582 : 
; 3583 : #ifdef _ITEM_PILENUMS
; 3584 : 		{
; 3585 : 			char pile[256];
; 3586 : 			getStringToken(data, '|', no+12, sizeof( pile ) - 1, pile );

  0037c	8d 85 b4 fa ff
	ff		 lea	 eax, DWORD PTR _pile$3[ebp]
  00382	50		 push	 eax
  00383	68 ff 00 00 00	 push	 255			; 000000ffH
  00388	8b 4d dc	 mov	 ecx, DWORD PTR _no$[ebp]
  0038b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0038e	51		 push	 ecx
  0038f	6a 7c		 push	 124			; 0000007cH
  00391	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  00394	52		 push	 edx
  00395	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0039a	83 c4 14	 add	 esp, 20			; 00000014H

; 3587 : 			makeStringFromEscaped( pile );

  0039d	8d 85 b4 fa ff
	ff		 lea	 eax, DWORD PTR _pile$3[ebp]
  003a3	50		 push	 eax
  003a4	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  003a9	83 c4 04	 add	 esp, 4

; 3588 : 			pc.item[i].pile = atoi( pile);

  003ac	8b f4		 mov	 esi, esp
  003ae	8d 85 b4 fa ff
	ff		 lea	 eax, DWORD PTR _pile$3[ebp]
  003b4	50		 push	 eax
  003b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  003bb	83 c4 04	 add	 esp, 4
  003be	3b f4		 cmp	 esi, esp
  003c0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003c5	69 4d f4 7c 01
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 380
  003cc	89 81 d0 00 00
	00		 mov	 DWORD PTR ?pc@@3UPC@@A[ecx+208], eax

; 3589 : 		}
; 3590 : #endif
; 3591 : 
; 3592 : #ifdef _ALCHEMIST //_ITEMSET7_TXT
; 3593 : 		{
; 3594 : 			char alch[256];
; 3595 : 			getStringToken(data, '|', no+13, sizeof( alch ) - 1, alch );

  003d2	8d 85 ac f9 ff
	ff		 lea	 eax, DWORD PTR _alch$2[ebp]
  003d8	50		 push	 eax
  003d9	68 ff 00 00 00	 push	 255			; 000000ffH
  003de	8b 4d dc	 mov	 ecx, DWORD PTR _no$[ebp]
  003e1	83 c1 0d	 add	 ecx, 13			; 0000000dH
  003e4	51		 push	 ecx
  003e5	6a 7c		 push	 124			; 0000007cH
  003e7	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  003ea	52		 push	 edx
  003eb	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  003f0	83 c4 14	 add	 esp, 20			; 00000014H

; 3596 : 			makeStringFromEscaped( alch );

  003f3	8d 85 ac f9 ff
	ff		 lea	 eax, DWORD PTR _alch$2[ebp]
  003f9	50		 push	 eax
  003fa	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  003ff	83 c4 04	 add	 esp, 4

; 3597 : 			strcpy( pc.item[i].alch, alch );

  00402	8d 85 ac f9 ff
	ff		 lea	 eax, DWORD PTR _alch$2[ebp]
  00408	50		 push	 eax
  00409	69 4d f4 7c 01
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 380
  00410	81 c1 d4 00 00
	00		 add	 ecx, OFFSET ?pc@@3UPC@@A+212
  00416	51		 push	 ecx
  00417	e8 00 00 00 00	 call	 _strcpy
  0041c	83 c4 08	 add	 esp, 8

; 3598 : 		}
; 3599 : #endif
; 3600 : #ifdef _PET_ITEM
; 3601 : 		{
; 3602 : 			char type[8];
; 3603 : 			getStringToken(data, '|', no + 14, sizeof(type) - 1, type);

  0041f	8d 85 9c f9 ff
	ff		 lea	 eax, DWORD PTR _type$1[ebp]
  00425	50		 push	 eax
  00426	6a 07		 push	 7
  00428	8b 4d dc	 mov	 ecx, DWORD PTR _no$[ebp]
  0042b	83 c1 0e	 add	 ecx, 14			; 0000000eH
  0042e	51		 push	 ecx
  0042f	6a 7c		 push	 124			; 0000007cH
  00431	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  00434	52		 push	 edx
  00435	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0043a	83 c4 14	 add	 esp, 20			; 00000014H

; 3604 : 			makeStringFromEscaped(type);

  0043d	8d 85 9c f9 ff
	ff		 lea	 eax, DWORD PTR _type$1[ebp]
  00443	50		 push	 eax
  00444	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  00449	83 c4 04	 add	 esp, 4

; 3605 : 			pc.item[i].type = atoi(type);

  0044c	8b f4		 mov	 esi, esp
  0044e	8d 85 9c f9 ff
	ff		 lea	 eax, DWORD PTR _type$1[ebp]
  00454	50		 push	 eax
  00455	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0045b	83 c4 04	 add	 esp, 4
  0045e	3b f4		 cmp	 esi, esp
  00460	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00465	69 4d f4 7c 01
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 380
  0046c	88 81 3d 02 00
	00		 mov	 BYTE PTR ?pc@@3UPC@@A[ecx+573], al

; 3606 : 		}
; 3607 : #endif
; 3608 : 
; 3609 : 
; 3610 : 	}

  00472	e9 c8 fb ff ff	 jmp	 $LN2@lssproto_I
$LN1@lssproto_I:

; 3611 : }

  00477	52		 push	 edx
  00478	8b cd		 mov	 ecx, ebp
  0047a	50		 push	 eax
  0047b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN24@lssproto_I
  00481	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00486	58		 pop	 eax
  00487	5a		 pop	 edx
  00488	5f		 pop	 edi
  00489	5e		 pop	 esi
  0048a	5b		 pop	 ebx
  0048b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0048e	33 cd		 xor	 ecx, ebp
  00490	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00495	81 c4 68 09 00
	00		 add	 esp, 2408		; 00000968H
  0049b	3b ec		 cmp	 ebp, esp
  0049d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004a2	8b e5		 mov	 esp, ebp
  004a4	5d		 pop	 ebp
  004a5	c3		 ret	 0
  004a6	66 90		 npad	 2
$LN24@lssproto_I:
  004a8	07 00 00 00	 DD	 7
  004ac	00 00 00 00	 DD	 $LN23@lssproto_I
$LN23@lssproto_I:
  004b0	d4 fe ff ff	 DD	 -300			; fffffed4H
  004b4	00 01 00 00	 DD	 256			; 00000100H
  004b8	00 00 00 00	 DD	 $LN16@lssproto_I
  004bc	cc fd ff ff	 DD	 -564			; fffffdccH
  004c0	00 01 00 00	 DD	 256			; 00000100H
  004c4	00 00 00 00	 DD	 $LN17@lssproto_I
  004c8	c4 fc ff ff	 DD	 -828			; fffffcc4H
  004cc	00 01 00 00	 DD	 256			; 00000100H
  004d0	00 00 00 00	 DD	 $LN18@lssproto_I
  004d4	bc fb ff ff	 DD	 -1092			; fffffbbcH
  004d8	00 01 00 00	 DD	 256			; 00000100H
  004dc	00 00 00 00	 DD	 $LN19@lssproto_I
  004e0	b4 fa ff ff	 DD	 -1356			; fffffab4H
  004e4	00 01 00 00	 DD	 256			; 00000100H
  004e8	00 00 00 00	 DD	 $LN20@lssproto_I
  004ec	ac f9 ff ff	 DD	 -1620			; fffff9acH
  004f0	00 01 00 00	 DD	 256			; 00000100H
  004f4	00 00 00 00	 DD	 $LN21@lssproto_I
  004f8	9c f9 ff ff	 DD	 -1636			; fffff99cH
  004fc	08 00 00 00	 DD	 8
  00500	00 00 00 00	 DD	 $LN22@lssproto_I
$LN22@lssproto_I:
  00504	74		 DB	 116			; 00000074H
  00505	79		 DB	 121			; 00000079H
  00506	70		 DB	 112			; 00000070H
  00507	65		 DB	 101			; 00000065H
  00508	00		 DB	 0
$LN21@lssproto_I:
  00509	61		 DB	 97			; 00000061H
  0050a	6c		 DB	 108			; 0000006cH
  0050b	63		 DB	 99			; 00000063H
  0050c	68		 DB	 104			; 00000068H
  0050d	00		 DB	 0
$LN20@lssproto_I:
  0050e	70		 DB	 112			; 00000070H
  0050f	69		 DB	 105			; 00000069H
  00510	6c		 DB	 108			; 0000006cH
  00511	65		 DB	 101			; 00000065H
  00512	00		 DB	 0
$LN19@lssproto_I:
  00513	64		 DB	 100			; 00000064H
  00514	61		 DB	 97			; 00000061H
  00515	6d		 DB	 109			; 0000006dH
  00516	61		 DB	 97			; 00000061H
  00517	67		 DB	 103			; 00000067H
  00518	65		 DB	 101			; 00000065H
  00519	00		 DB	 0
$LN18@lssproto_I:
  0051a	6d		 DB	 109			; 0000006dH
  0051b	65		 DB	 101			; 00000065H
  0051c	6d		 DB	 109			; 0000006dH
  0051d	6f		 DB	 111			; 0000006fH
  0051e	00		 DB	 0
$LN17@lssproto_I:
  0051f	6e		 DB	 110			; 0000006eH
  00520	61		 DB	 97			; 00000061H
  00521	6d		 DB	 109			; 0000006dH
  00522	65		 DB	 101			; 00000065H
  00523	32		 DB	 50			; 00000032H
  00524	00		 DB	 0
$LN16@lssproto_I:
  00525	6e		 DB	 110			; 0000006eH
  00526	61		 DB	 97			; 00000061H
  00527	6d		 DB	 109			; 0000006dH
  00528	65		 DB	 101			; 00000065H
  00529	00		 DB	 0
?lssproto_I_recv@@YAXHPAD@Z ENDP			; lssproto_I_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_B_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_command$ = 12						; size = 4
?lssproto_B_recv@@YAXHPAD@Z PROC			; lssproto_B_recv, COMDAT

; 3848 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3849 : 	//JLWG 是快速战斗则不处理此包
; 3850 : 	extern int g_bFastFight;
; 3851 : 	if (g_bFastFight)

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bFastFight@@3HA, 0 ; g_bFastFight
  00025	74 05		 je	 SHORT $LN2@lssproto_B

; 3852 : 	{
; 3853 : 		return;

  00027	e9 77 01 00 00	 jmp	 $LN1@lssproto_B
$LN2@lssproto_B:

; 3854 : 	}
; 3855 : 	//printf("\n%s",command);
; 3856 : 	if ( *( command + 1 ) == 'C'){

  0002c	8b 45 0c	 mov	 eax, DWORD PTR _command$[ebp]
  0002f	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  00033	83 f9 43	 cmp	 ecx, 67			; 00000043H
  00036	75 31		 jne	 SHORT $LN3@lssproto_B

; 3857 : 		strcpy( BattleStatusBak[ BattleStatusWritePointer ], command );

  00038	8b 45 0c	 mov	 eax, DWORD PTR _command$[ebp]
  0003b	50		 push	 eax
  0003c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BattleStatusWritePointer@@3HA ; BattleStatusWritePointer
  00042	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  00045	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?BattleStatusBak@@3PAY0BAAA@DA ; BattleStatusBak
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 _strcpy
  00051	83 c4 08	 add	 esp, 8

; 3858 : 		BattleStatusWritePointer = ( BattleStatusWritePointer + 1 ) & ( BATTLE_BUF_SIZE-1 );

  00054	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BattleStatusWritePointer@@3HA ; BattleStatusWritePointer
  00059	83 c0 01	 add	 eax, 1
  0005c	83 e0 03	 and	 eax, 3
  0005f	a3 00 00 00 00	 mov	 DWORD PTR ?BattleStatusWritePointer@@3HA, eax ; BattleStatusWritePointer
  00064	e9 3a 01 00 00	 jmp	 $LN1@lssproto_B
$LN3@lssproto_B:

; 3859 : 	}else if (*(command + 1) == 'P') {

  00069	8b 45 0c	 mov	 eax, DWORD PTR _command$[ebp]
  0006c	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  00070	83 f9 50	 cmp	 ecx, 80			; 00000050H
  00073	75 3b		 jne	 SHORT $LN5@lssproto_B

; 3860 : 		sscanf(command + 3, "%X|%X|%X", &BattleMyNo, &BattleBpFlag, &BattleMyMp);

  00075	68 00 00 00 00	 push	 OFFSET ?BattleMyMp@@3HA	; BattleMyMp
  0007a	68 00 00 00 00	 push	 OFFSET ?BattleBpFlag@@3HA ; BattleBpFlag
  0007f	68 00 00 00 00	 push	 OFFSET ?BattleMyNo@@3HA	; BattleMyNo
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_08EOJECCGN@?$CFX?$HM?$CFX?$HM?$CFX?$AA@
  00089	8b 45 0c	 mov	 eax, DWORD PTR _command$[ebp]
  0008c	83 c0 03	 add	 eax, 3
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 _sscanf
  00095	83 c4 14	 add	 esp, 20			; 00000014H

; 3861 : 		//JL fix 遇敌偷袭
; 3862 : 		if (BattleBpFlag == 26)

  00098	83 3d 00 00 00
	00 1a		 cmp	 DWORD PTR ?BattleBpFlag@@3HA, 26 ; BattleBpFlag, 0000001aH
  0009f	75 0a		 jne	 SHORT $LN7@lssproto_B

; 3863 : 		{
; 3864 : 			BattleBpFlag = 0;

  000a1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BattleBpFlag@@3HA, 0 ; BattleBpFlag
$LN7@lssproto_B:

; 3865 : 		}

  000ab	e9 f3 00 00 00	 jmp	 $LN1@lssproto_B
$LN5@lssproto_B:

; 3866 : 	}else if ( *( command + 1 ) == 'A'){

  000b0	8b 45 0c	 mov	 eax, DWORD PTR _command$[ebp]
  000b3	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  000b7	83 f9 41	 cmp	 ecx, 65			; 00000041H
  000ba	75 40		 jne	 SHORT $LN8@lssproto_B

; 3867 : 		sscanf( command + 3, "%X|%X", &BattleAnimFlag, &BattleSvTurnNo );

  000bc	68 00 00 00 00	 push	 OFFSET ?BattleSvTurnNo@@3HA ; BattleSvTurnNo
  000c1	68 00 00 00 00	 push	 OFFSET ?BattleAnimFlag@@3HA ; BattleAnimFlag
  000c6	68 00 00 00 00	 push	 OFFSET ??_C@_05HMDCACKA@?$CFX?$HM?$CFX?$AA@
  000cb	8b 45 0c	 mov	 eax, DWORD PTR _command$[ebp]
  000ce	83 c0 03	 add	 eax, 3
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 _sscanf
  000d7	83 c4 10	 add	 esp, 16			; 00000010H

; 3868 : 
; 3869 : 		if ( BattleTurnReceiveFlag == TRUE ){ 

  000da	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?BattleTurnReceiveFlag@@3HA, 1 ; BattleTurnReceiveFlag
  000e1	75 14		 jne	 SHORT $LN10@lssproto_B

; 3870 : 			BattleCliTurnNo = BattleSvTurnNo;

  000e3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BattleSvTurnNo@@3HA ; BattleSvTurnNo
  000e8	a3 00 00 00 00	 mov	 DWORD PTR ?BattleCliTurnNo@@3HA, eax ; BattleCliTurnNo

; 3871 : 			BattleTurnReceiveFlag = FALSE;

  000ed	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BattleTurnReceiveFlag@@3HA, 0 ; BattleTurnReceiveFlag
$LN10@lssproto_B:

; 3872 : 		}

  000f7	e9 a7 00 00 00	 jmp	 $LN1@lssproto_B
$LN8@lssproto_B:

; 3873 : 	}else if ( *( command + 1 ) == 'U')

  000fc	8b 45 0c	 mov	 eax, DWORD PTR _command$[ebp]
  000ff	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  00103	83 f9 55	 cmp	 ecx, 85			; 00000055H
  00106	75 0f		 jne	 SHORT $LN11@lssproto_B

; 3874 : 		BattleEscFlag = TRUE;

  00108	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?BattleEscFlag@@3HA, 1 ; BattleEscFlag
  00112	e9 8c 00 00 00	 jmp	 $LN1@lssproto_B
$LN11@lssproto_B:

; 3875 : #ifdef 战斗光环
; 3876 : 	else if (*(command + 1) == '&'){

  00117	8b 45 0c	 mov	 eax, DWORD PTR _command$[ebp]
  0011a	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  0011e	83 f9 26	 cmp	 ecx, 38			; 00000026H
  00121	75 54		 jne	 SHORT $LN13@lssproto_B

; 3877 : 		printf("\n%s",command);

  00123	8b 45 0c	 mov	 eax, DWORD PTR _command$[ebp]
  00126	50		 push	 eax
  00127	68 00 00 00 00	 push	 OFFSET ??_C@_03ILJCGOLJ@?6?$CFs?$AA@
  0012c	e8 00 00 00 00	 call	 _printf
  00131	83 c4 08	 add	 esp, 8

; 3878 : 		if (*(command + 2) == '|'  && *(command + 3) && *(command + 4)){

  00134	8b 45 0c	 mov	 eax, DWORD PTR _command$[ebp]
  00137	0f be 48 02	 movsx	 ecx, BYTE PTR [eax+2]
  0013b	83 f9 7c	 cmp	 ecx, 124		; 0000007cH
  0013e	75 33		 jne	 SHORT $LN15@lssproto_B
  00140	8b 45 0c	 mov	 eax, DWORD PTR _command$[ebp]
  00143	0f be 48 03	 movsx	 ecx, BYTE PTR [eax+3]
  00147	85 c9		 test	 ecx, ecx
  00149	74 28		 je	 SHORT $LN15@lssproto_B
  0014b	8b 45 0c	 mov	 eax, DWORD PTR _command$[ebp]
  0014e	0f be 48 04	 movsx	 ecx, BYTE PTR [eax+4]
  00152	85 c9		 test	 ecx, ecx
  00154	74 1d		 je	 SHORT $LN15@lssproto_B

; 3879 : 			lstrcpyA(gStr光环, command + 3);

  00156	8b 45 0c	 mov	 eax, DWORD PTR _command$[ebp]
  00159	83 c0 03	 add	 eax, 3
  0015c	8b f4		 mov	 esi, esp
  0015e	50		 push	 eax
  0015f	68 00 00 00 00	 push	 OFFSET ?gStr光环@@3PADA	; gStr光环
  00164	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8
  0016a	3b f4		 cmp	 esi, esp
  0016c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3880 : 		}else{

  00171	eb 02		 jmp	 SHORT $LN16@lssproto_B
$LN15@lssproto_B:

; 3881 : 			return;

  00173	eb 2e		 jmp	 SHORT $LN1@lssproto_B
$LN16@lssproto_B:

; 3882 : 		}
; 3883 : 	
; 3884 : 	}
; 3885 : #endif
; 3886 : 	else {

  00175	eb 2c		 jmp	 SHORT $LN1@lssproto_B
$LN13@lssproto_B:

; 3887 : 		strcpy( BattleCmdBak[ BattleCmdWritePointer ], command );

  00177	8b 45 0c	 mov	 eax, DWORD PTR _command$[ebp]
  0017a	50		 push	 eax
  0017b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BattleCmdWritePointer@@3HA ; BattleCmdWritePointer
  00181	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  00184	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?BattleCmdBak@@3PAY0BAAA@DA ; BattleCmdBak
  0018a	51		 push	 ecx
  0018b	e8 00 00 00 00	 call	 _strcpy
  00190	83 c4 08	 add	 esp, 8

; 3888 : 		BattleCmdWritePointer = ( BattleCmdWritePointer + 1 ) & ( BATTLE_BUF_SIZE-1 );

  00193	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BattleCmdWritePointer@@3HA ; BattleCmdWritePointer
  00198	83 c0 01	 add	 eax, 1
  0019b	83 e0 03	 and	 eax, 3
  0019e	a3 00 00 00 00	 mov	 DWORD PTR ?BattleCmdWritePointer@@3HA, eax ; BattleCmdWritePointer
$LN1@lssproto_B:

; 3889 : 	}
; 3890 : 	
; 3891 : #ifdef  _STONDEBUG__MSG
; 3892 : //	StockChatBufferLine( command, FONT_PAL_RED );
; 3893 : #endif
; 3894 : 
; 3895 : }

  001a3	5f		 pop	 edi
  001a4	5e		 pop	 esi
  001a5	5b		 pop	 ebx
  001a6	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  001ac	3b ec		 cmp	 ebp, esp
  001ae	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b3	8b e5		 mov	 esp, ebp
  001b5	5d		 pop	 ebp
  001b6	c3		 ret	 0
?lssproto_B_recv@@YAXHPAD@Z ENDP			; lssproto_B_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_RD_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_RD_recv@@YAXHPAD@Z PROC			; lssproto_RD_recv, COMDAT

; 3491 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3492 : 	// ????????????????雪????
; 3493 : 	if ( logOutFlag )

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  00025	74 02		 je	 SHORT $LN2@lssproto_R

; 3494 : 		return;

  00027	eb 47		 jmp	 SHORT $LN1@lssproto_R
$LN2@lssproto_R:

; 3495 : 
; 3496 : 	battleResultMsg.useFlag = 2;

  00029	b8 02 00 00 00	 mov	 eax, 2
  0002e	66 a3 00 00 00
	00		 mov	 WORD PTR ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A, ax

; 3497 : 
; 3498 : 	battleResultMsg.resChr[0].exp = getInteger62Token(data, '|', 1 );

  00034	6a 01		 push	 1
  00036	6a 7c		 push	 124			; 0000007cH
  00038	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?getInteger62Token@@YAHPADDH@Z ; getInteger62Token
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	b9 08 00 00 00	 mov	 ecx, 8
  00049	6b d1 00	 imul	 edx, ecx, 0
  0004c	89 82 08 00 00
	00		 mov	 DWORD PTR ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A[edx+8], eax

; 3499 : 	battleResultMsg.resChr[1].exp = getInteger62Token(data, '|', 2 );

  00052	6a 02		 push	 2
  00054	6a 7c		 push	 124			; 0000007cH
  00056	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ?getInteger62Token@@YAHPADDH@Z ; getInteger62Token
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	b9 08 00 00 00	 mov	 ecx, 8
  00067	c1 e1 00	 shl	 ecx, 0
  0006a	89 81 08 00 00
	00		 mov	 DWORD PTR ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A[ecx+8], eax
$LN1@lssproto_R:

; 3500 : }

  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx
  00073	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00079	3b ec		 cmp	 ebp, esp
  0007b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
?lssproto_RD_recv@@YAXHPAD@Z ENDP			; lssproto_RD_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_RS_recv@@YAXHPAD@Z
_TEXT	SEGMENT
_cols$ = -4136						; size = 4
_item$ = -4124						; size = 2048
_token$ = -2068						; size = 2048
_i$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_data$ = 12						; size = 4
?lssproto_RS_recv@@YAXHPAD@Z PROC			; lssproto_RS_recv, COMDAT

; 3438 : void lssproto_RS_recv( int fd, char *data ){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 2c 16 00 00	 mov	 eax, 5676		; 0000162cH
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8d bd d4 e9 ff
	ff		 lea	 edi, DWORD PTR [ebp-5676]
  00016	b9 8b 05 00 00	 mov	 ecx, 1419		; 0000058bH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3439 : 	int i;
; 3440 : 	char token[2048];
; 3441 : 	char item[2048];
; 3442 : 
; 3443 : 	//JLWG 是快速战斗则不处理此包
; 3444 : 	extern int g_bFastFight;
; 3445 : 	if (g_bFastFight){

  0002c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bFastFight@@3HA, 0 ; g_bFastFight
  00033	74 05		 je	 SHORT $LN5@lssproto_R

; 3446 : 		return;

  00035	e9 6f 02 00 00	 jmp	 $LN1@lssproto_R
$LN5@lssproto_R:

; 3447 : 	}
; 3448 : 
; 3449 : 	if ( logOutFlag )

  0003a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  00041	74 05		 je	 SHORT $LN6@lssproto_R

; 3450 : 		return;

  00043	e9 61 02 00 00	 jmp	 $LN1@lssproto_R
$LN6@lssproto_R:

; 3451 : 
; 3452 : 	battleResultMsg.useFlag = 1;

  00048	b8 01 00 00 00	 mov	 eax, 1
  0004d	66 a3 00 00 00
	00		 mov	 WORD PTR ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A, ax

; 3453 : 	//cary ?? 栏位 数
; 3454 : 	int cols = RESULT_CHR_EXP;

  00053	c7 85 d8 ef ff
	ff 05 00 00 00	 mov	 DWORD PTR _cols$[ebp], 5

; 3455 : 	getStringToken(data, ',', RESULT_CHR_EXP+1, sizeof( token ) - 1, token );

  0005d	8d 85 ec f7 ff
	ff		 lea	 eax, DWORD PTR _token$[ebp]
  00063	50		 push	 eax
  00064	68 ff 07 00 00	 push	 2047			; 000007ffH
  00069	6a 06		 push	 6
  0006b	6a 2c		 push	 44			; 0000002cH
  0006d	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00070	51		 push	 ecx
  00071	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00076	83 c4 14	 add	 esp, 20			; 00000014H

; 3456 : 	if ( token[0] == 0){

  00079	b8 01 00 00 00	 mov	 eax, 1
  0007e	6b c8 00	 imul	 ecx, eax, 0
  00081	0f be 94 0d ec
	f7 ff ff	 movsx	 edx, BYTE PTR _token$[ebp+ecx]
  00089	85 d2		 test	 edx, edx
  0008b	75 40		 jne	 SHORT $LN7@lssproto_R

; 3457 : 		cols = RESULT_CHR_EXP - 1;

  0008d	c7 85 d8 ef ff
	ff 04 00 00 00	 mov	 DWORD PTR _cols$[ebp], 4

; 3458 : 		battleResultMsg.resChr[RESULT_CHR_EXP-1].petNo = -1;

  00097	b8 08 00 00 00	 mov	 eax, 8
  0009c	c1 e0 02	 shl	 eax, 2
  0009f	83 c9 ff	 or	 ecx, -1
  000a2	66 89 88 04 00
	00 00		 mov	 WORD PTR ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A[eax+4], cx

; 3459 : 		battleResultMsg.resChr[RESULT_CHR_EXP-1].levelUp = -1;

  000a9	b8 08 00 00 00	 mov	 eax, 8
  000ae	c1 e0 02	 shl	 eax, 2
  000b1	83 c9 ff	 or	 ecx, -1
  000b4	66 89 88 06 00
	00 00		 mov	 WORD PTR ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A[eax+6], cx

; 3460 : 		battleResultMsg.resChr[RESULT_CHR_EXP-1].exp = -1;

  000bb	b8 08 00 00 00	 mov	 eax, 8
  000c0	c1 e0 02	 shl	 eax, 2
  000c3	c7 80 08 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A[eax+8], -1
$LN7@lssproto_R:

; 3461 : 	}
; 3462 : 	//end cary
; 3463 : 	for ( i = 0; i < cols; i++ ){

  000cd	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000d4	eb 09		 jmp	 SHORT $LN4@lssproto_R
$LN2@lssproto_R:
  000d6	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000d9	83 c0 01	 add	 eax, 1
  000dc	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@lssproto_R:
  000df	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000e2	3b 85 d8 ef ff
	ff		 cmp	 eax, DWORD PTR _cols$[ebp]
  000e8	7d 7f		 jge	 SHORT $LN3@lssproto_R

; 3464 : 		getStringToken(data, ',', i+1, sizeof( token ) - 1, token );

  000ea	8d 85 ec f7 ff
	ff		 lea	 eax, DWORD PTR _token$[ebp]
  000f0	50		 push	 eax
  000f1	68 ff 07 00 00	 push	 2047			; 000007ffH
  000f6	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  000f9	83 c1 01	 add	 ecx, 1
  000fc	51		 push	 ecx
  000fd	6a 2c		 push	 44			; 0000002cH
  000ff	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  00102	52		 push	 edx
  00103	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00108	83 c4 14	 add	 esp, 20			; 00000014H

; 3465 : 		battleResultMsg.resChr[i].petNo = getIntegerToken( token, '|', 1 );

  0010b	6a 01		 push	 1
  0010d	6a 7c		 push	 124			; 0000007cH
  0010f	8d 85 ec f7 ff
	ff		 lea	 eax, DWORD PTR _token$[ebp]
  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  0011b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011e	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00121	66 89 04 cd 04
	00 00 00	 mov	 WORD PTR ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A[ecx*8+4], ax

; 3466 : 		battleResultMsg.resChr[i].levelUp = getIntegerToken( token, '|', 2 );

  00129	6a 02		 push	 2
  0012b	6a 7c		 push	 124			; 0000007cH
  0012d	8d 85 ec f7 ff
	ff		 lea	 eax, DWORD PTR _token$[ebp]
  00133	50		 push	 eax
  00134	e8 00 00 00 00	 call	 ?getIntegerToken@@YAHPADDH@Z ; getIntegerToken
  00139	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013c	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0013f	66 89 04 cd 06
	00 00 00	 mov	 WORD PTR ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A[ecx*8+6], ax

; 3467 : 		battleResultMsg.resChr[i].exp = getInteger62Token( token, '|', 3 );

  00147	6a 03		 push	 3
  00149	6a 7c		 push	 124			; 0000007cH
  0014b	8d 85 ec f7 ff
	ff		 lea	 eax, DWORD PTR _token$[ebp]
  00151	50		 push	 eax
  00152	e8 00 00 00 00	 call	 ?getInteger62Token@@YAHPADDH@Z ; getInteger62Token
  00157	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015a	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0015d	89 04 cd 08 00
	00 00		 mov	 DWORD PTR ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A[ecx*8+8], eax

; 3468 : 	}

  00164	e9 6d ff ff ff	 jmp	 $LN2@lssproto_R
$LN3@lssproto_R:

; 3469 : 
; 3470 : 	getStringToken(data, ',', i+1, sizeof( token ) - 1, token );

  00169	8d 85 ec f7 ff
	ff		 lea	 eax, DWORD PTR _token$[ebp]
  0016f	50		 push	 eax
  00170	68 ff 07 00 00	 push	 2047			; 000007ffH
  00175	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00178	83 c1 01	 add	 ecx, 1
  0017b	51		 push	 ecx
  0017c	6a 2c		 push	 44			; 0000002cH
  0017e	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  00181	52		 push	 edx
  00182	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00187	83 c4 14	 add	 esp, 20			; 00000014H

; 3471 : 	getStringToken( token, '|', 1, sizeof( item ) - 1, item );

  0018a	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _item$[ebp]
  00190	50		 push	 eax
  00191	68 ff 07 00 00	 push	 2047			; 000007ffH
  00196	6a 01		 push	 1
  00198	6a 7c		 push	 124			; 0000007cH
  0019a	8d 8d ec f7 ff
	ff		 lea	 ecx, DWORD PTR _token$[ebp]
  001a0	51		 push	 ecx
  001a1	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  001a6	83 c4 14	 add	 esp, 20			; 00000014H

; 3472 : 	makeStringFromEscaped( item );

  001a9	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _item$[ebp]
  001af	50		 push	 eax
  001b0	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  001b5	83 c4 04	 add	 esp, 4

; 3473 : 	if ( strlen( item ) <= RESULT_ITEM_NAME_LEN ){

  001b8	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _item$[ebp]
  001be	50		 push	 eax
  001bf	e8 00 00 00 00	 call	 _strlen
  001c4	83 c4 04	 add	 esp, 4
  001c7	83 f8 18	 cmp	 eax, 24			; 00000018H
  001ca	77 1e		 ja	 SHORT $LN8@lssproto_R

; 3474 : 		strcpy( battleResultMsg.item[0], item );

  001cc	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _item$[ebp]
  001d2	50		 push	 eax
  001d3	b9 19 00 00 00	 mov	 ecx, 25			; 00000019H
  001d8	6b d1 00	 imul	 edx, ecx, 0
  001db	81 c2 2c 00 00
	00		 add	 edx, OFFSET ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A+44
  001e1	52		 push	 edx
  001e2	e8 00 00 00 00	 call	 _strcpy
  001e7	83 c4 08	 add	 esp, 8
$LN8@lssproto_R:

; 3475 : 	}
; 3476 : 	getStringToken( token, '|', 2, sizeof( item ) - 1, item );

  001ea	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _item$[ebp]
  001f0	50		 push	 eax
  001f1	68 ff 07 00 00	 push	 2047			; 000007ffH
  001f6	6a 02		 push	 2
  001f8	6a 7c		 push	 124			; 0000007cH
  001fa	8d 8d ec f7 ff
	ff		 lea	 ecx, DWORD PTR _token$[ebp]
  00200	51		 push	 ecx
  00201	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00206	83 c4 14	 add	 esp, 20			; 00000014H

; 3477 : 	makeStringFromEscaped( item );

  00209	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _item$[ebp]
  0020f	50		 push	 eax
  00210	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  00215	83 c4 04	 add	 esp, 4

; 3478 : 	if ( strlen( item ) <= RESULT_ITEM_NAME_LEN ){

  00218	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _item$[ebp]
  0021e	50		 push	 eax
  0021f	e8 00 00 00 00	 call	 _strlen
  00224	83 c4 04	 add	 esp, 4
  00227	83 f8 18	 cmp	 eax, 24			; 00000018H
  0022a	77 1e		 ja	 SHORT $LN9@lssproto_R

; 3479 : 		strcpy( battleResultMsg.item[1], item );

  0022c	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _item$[ebp]
  00232	50		 push	 eax
  00233	b9 19 00 00 00	 mov	 ecx, 25			; 00000019H
  00238	c1 e1 00	 shl	 ecx, 0
  0023b	81 c1 2c 00 00
	00		 add	 ecx, OFFSET ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A+44
  00241	51		 push	 ecx
  00242	e8 00 00 00 00	 call	 _strcpy
  00247	83 c4 08	 add	 esp, 8
$LN9@lssproto_R:

; 3480 : 	}
; 3481 : 	getStringToken( token, '|', 3, sizeof( item ) - 1, item );

  0024a	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _item$[ebp]
  00250	50		 push	 eax
  00251	68 ff 07 00 00	 push	 2047			; 000007ffH
  00256	6a 03		 push	 3
  00258	6a 7c		 push	 124			; 0000007cH
  0025a	8d 8d ec f7 ff
	ff		 lea	 ecx, DWORD PTR _token$[ebp]
  00260	51		 push	 ecx
  00261	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  00266	83 c4 14	 add	 esp, 20			; 00000014H

; 3482 : 	makeStringFromEscaped( item );

  00269	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _item$[ebp]
  0026f	50		 push	 eax
  00270	e8 00 00 00 00	 call	 ?makeStringFromEscaped@@YAPADPAD@Z ; makeStringFromEscaped
  00275	83 c4 04	 add	 esp, 4

; 3483 : 	if ( strlen( item ) <= RESULT_ITEM_NAME_LEN ){

  00278	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _item$[ebp]
  0027e	50		 push	 eax
  0027f	e8 00 00 00 00	 call	 _strlen
  00284	83 c4 04	 add	 esp, 4
  00287	83 f8 18	 cmp	 eax, 24			; 00000018H
  0028a	77 1d		 ja	 SHORT $LN1@lssproto_R

; 3484 : 		strcpy( battleResultMsg.item[2], item );

  0028c	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _item$[ebp]
  00292	50		 push	 eax
  00293	b9 19 00 00 00	 mov	 ecx, 25			; 00000019H
  00298	d1 e1		 shl	 ecx, 1
  0029a	81 c1 2c 00 00
	00		 add	 ecx, OFFSET ?battleResultMsg@@3UBATTLE_RESULT_MSG@@A+44
  002a0	51		 push	 ecx
  002a1	e8 00 00 00 00	 call	 _strcpy
  002a6	83 c4 08	 add	 esp, 8
$LN1@lssproto_R:

; 3485 : 	}
; 3486 : }

  002a9	52		 push	 edx
  002aa	8b cd		 mov	 ecx, ebp
  002ac	50		 push	 eax
  002ad	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@lssproto_R
  002b3	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002b8	58		 pop	 eax
  002b9	5a		 pop	 edx
  002ba	5f		 pop	 edi
  002bb	5e		 pop	 esi
  002bc	5b		 pop	 ebx
  002bd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c0	33 cd		 xor	 ecx, ebp
  002c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002c7	81 c4 2c 16 00
	00		 add	 esp, 5676		; 0000162cH
  002cd	3b ec		 cmp	 ebp, esp
  002cf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002d4	8b e5		 mov	 esp, ebp
  002d6	5d		 pop	 ebp
  002d7	c3		 ret	 0
$LN15@lssproto_R:
  002d8	02 00 00 00	 DD	 2
  002dc	00 00 00 00	 DD	 $LN14@lssproto_R
$LN14@lssproto_R:
  002e0	ec f7 ff ff	 DD	 -2068			; fffff7ecH
  002e4	00 08 00 00	 DD	 2048			; 00000800H
  002e8	00 00 00 00	 DD	 $LN12@lssproto_R
  002ec	e4 ef ff ff	 DD	 -4124			; ffffefe4H
  002f0	00 08 00 00	 DD	 2048			; 00000800H
  002f4	00 00 00 00	 DD	 $LN13@lssproto_R
$LN13@lssproto_R:
  002f8	69		 DB	 105			; 00000069H
  002f9	74		 DB	 116			; 00000074H
  002fa	65		 DB	 101			; 00000065H
  002fb	6d		 DB	 109			; 0000006dH
  002fc	00		 DB	 0
$LN12@lssproto_R:
  002fd	74		 DB	 116			; 00000074H
  002fe	6f		 DB	 111			; 0000006fH
  002ff	6b		 DB	 107			; 0000006bH
  00300	65		 DB	 101			; 00000065H
  00301	6e		 DB	 110			; 0000006eH
  00302	00		 DB	 0
?lssproto_RS_recv@@YAXHPAD@Z ENDP			; lssproto_RS_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_EN_recv@@YAXHHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_result$ = 12						; size = 4
_field$ = 16						; size = 4
?lssproto_EN_recv@@YAXHHH@Z PROC			; lssproto_EN_recv, COMDAT

; 3779 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3780 : 
; 3781 : 	if ( logOutFlag )

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  00025	74 05		 je	 SHORT $LN2@lssproto_E

; 3782 : 		return;

  00027	e9 45 01 00 00	 jmp	 $LN1@lssproto_E
$LN2@lssproto_E:

; 3783 : 	if ( result > 0 ){

  0002c	83 7d 0c 00	 cmp	 DWORD PTR _result$[ebp], 0
  00030	0f 8e 23 01 00
	00		 jle	 $LN3@lssproto_E

; 3784 : 		EncountFlag = TRUE;

  00036	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?EncountFlag@@3HA, 1 ; EncountFlag

; 3785 : 		if ( result == 4)

  00040	83 7d 0c 04	 cmp	 DWORD PTR _result$[ebp], 4
  00044	75 0b		 jne	 SHORT $LN5@lssproto_E

; 3786 : 			vsLookFlag = 1;

  00046	b8 01 00 00 00	 mov	 eax, 1
  0004b	66 a3 00 00 00
	00		 mov	 WORD PTR ?vsLookFlag@@3FA, ax ; vsLookFlag
$LN5@lssproto_E:

; 3787 : 		
; 3788 : 
; 3789 : 		//JLWG 2016.9.16 快速战斗处理
; 3790 : 		extern int g_flag_FastFight;
; 3791 : 		if (vsLookFlag == 0 && g_flag_FastFight == 1)	//如果是快速战斗的处理

  00051	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?vsLookFlag@@3FA ; vsLookFlag
  00058	85 c0		 test	 eax, eax
  0005a	75 3d		 jne	 SHORT $LN6@lssproto_E
  0005c	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_flag_FastFight@@3HA, 1 ; g_flag_FastFight
  00063	75 34		 jne	 SHORT $LN6@lssproto_E

; 3792 : 		{
; 3793 : 			EncountFlag = FALSE;

  00065	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?EncountFlag@@3HA, 0 ; EncountFlag

; 3794 : 			pc.status |= CHR_STATUS_BATTLE;

  0006f	a1 a4 00 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+164
  00074	0d 00 04 00 00	 or	 eax, 1024		; 00000400H
  00079	a3 a4 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+164, eax

; 3795 : 			JL_SetFastFightFlag(true);

  0007e	6a 01		 push	 1
  00080	e8 00 00 00 00	 call	 ?JL_SetFastFightFlag@@YAX_N@Z ; JL_SetFastFightFlag
  00085	83 c4 04	 add	 esp, 4

; 3796 : 			JL_锁定人物(true);

  00088	6a 01		 push	 1
  0008a	e8 00 00 00 00	 call	 ?JL_锁定人物@@YAX_N@Z	; JL_锁定人物
  0008f	83 c4 04	 add	 esp, 4

; 3797 : 
; 3798 : 			return;

  00092	e9 da 00 00 00	 jmp	 $LN1@lssproto_E

; 3799 : 		}else{

  00097	eb 0a		 jmp	 SHORT $LN7@lssproto_E
$LN6@lssproto_E:

; 3800 : 			JL_SetFastFightFlag(false);

  00099	6a 00		 push	 0
  0009b	e8 00 00 00 00	 call	 ?JL_SetFastFightFlag@@YAX_N@Z ; JL_SetFastFightFlag
  000a0	83 c4 04	 add	 esp, 4
$LN7@lssproto_E:

; 3801 : 		}
; 3802 : 
; 3803 : 
; 3804 : 		if ( result == 6 || result == 2 )

  000a3	83 7d 0c 06	 cmp	 DWORD PTR _result$[ebp], 6
  000a7	74 06		 je	 SHORT $LN10@lssproto_E
  000a9	83 7d 0c 02	 cmp	 DWORD PTR _result$[ebp], 2
  000ad	75 0d		 jne	 SHORT $LN8@lssproto_E
$LN10@lssproto_E:

; 3805 : 			eventEnemyFlag = 1;

  000af	b8 01 00 00 00	 mov	 eax, 1
  000b4	66 a3 00 00 00
	00		 mov	 WORD PTR ?eventEnemyFlag@@3FA, ax ; eventEnemyFlag

; 3806 : 		else

  000ba	eb 08		 jmp	 SHORT $LN9@lssproto_E
$LN8@lssproto_E:

; 3807 : 			eventEnemyFlag = 0;

  000bc	33 c0		 xor	 eax, eax
  000be	66 a3 00 00 00
	00		 mov	 WORD PTR ?eventEnemyFlag@@3FA, ax ; eventEnemyFlag
$LN9@lssproto_E:

; 3808 : 
; 3809 : 		if ( field < 0 || BATTLE_MAP_FILES <= field )

  000c4	83 7d 10 00	 cmp	 DWORD PTR _field$[ebp], 0
  000c8	7c 09		 jl	 SHORT $LN13@lssproto_E
  000ca	81 7d 10 dc 00
	00 00		 cmp	 DWORD PTR _field$[ebp], 220 ; 000000dcH
  000d1	7c 0c		 jl	 SHORT $LN11@lssproto_E
$LN13@lssproto_E:

; 3810 : 			BattleMapNo = 0;

  000d3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BattleMapNo@@3HA, 0 ; BattleMapNo

; 3811 : 		else

  000dd	eb 08		 jmp	 SHORT $LN12@lssproto_E
$LN11@lssproto_E:

; 3812 : 			BattleMapNo = field;

  000df	8b 45 10	 mov	 eax, DWORD PTR _field$[ebp]
  000e2	a3 00 00 00 00	 mov	 DWORD PTR ?BattleMapNo@@3HA, eax ; BattleMapNo
$LN12@lssproto_E:

; 3813 : 
; 3814 : 		if (result == 2)

  000e7	83 7d 0c 02	 cmp	 DWORD PTR _result$[ebp], 2
  000eb	75 16		 jne	 SHORT $LN14@lssproto_E

; 3815 : 		{
; 3816 : 			NoCastFlag = false;  //JL fix 2018/8/28 决斗时强制复位沉默，可以下指令

  000ed	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?NoCastFlag@@3HA, 0 ; NoCastFlag

; 3817 : 			DuelFlag = TRUE;

  000f7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?DuelFlag@@3HA, 1 ; DuelFlag

; 3818 : 		}
; 3819 : 		else

  00101	eb 0a		 jmp	 SHORT $LN15@lssproto_E
$LN14@lssproto_E:

; 3820 : 			DuelFlag = FALSE;

  00103	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?DuelFlag@@3HA, 0 ; DuelFlag
$LN15@lssproto_E:

; 3821 : 
; 3822 : 		if ( result == 2 || result == 5 )

  0010d	83 7d 0c 02	 cmp	 DWORD PTR _result$[ebp], 2
  00111	74 06		 je	 SHORT $LN18@lssproto_E
  00113	83 7d 0c 05	 cmp	 DWORD PTR _result$[ebp], 5
  00117	75 0c		 jne	 SHORT $LN16@lssproto_E
$LN18@lssproto_E:

; 3823 : 			NoHelpFlag = TRUE;

  00119	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?NoHelpFlag@@3HA, 1 ; NoHelpFlag

; 3824 : 		else

  00123	eb 0a		 jmp	 SHORT $LN17@lssproto_E
$LN16@lssproto_E:

; 3825 : 			NoHelpFlag = FALSE;

  00125	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?NoHelpFlag@@3HA, 0 ; NoHelpFlag
$LN17@lssproto_E:

; 3826 : 
; 3827 : 		BattleStatusReadPointer = BattleStatusWritePointer =0;

  0012f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BattleStatusWritePointer@@3HA, 0 ; BattleStatusWritePointer
  00139	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BattleStatusWritePointer@@3HA ; BattleStatusWritePointer
  0013e	a3 00 00 00 00	 mov	 DWORD PTR ?BattleStatusReadPointer@@3HA, eax ; BattleStatusReadPointer

; 3828 : 		BattleCmdReadPointer = BattleCmdWritePointer =0;

  00143	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BattleCmdWritePointer@@3HA, 0 ; BattleCmdWritePointer
  0014d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BattleCmdWritePointer@@3HA ; BattleCmdWritePointer
  00152	a3 00 00 00 00	 mov	 DWORD PTR ?BattleCmdReadPointer@@3HA, eax ; BattleCmdReadPointer

; 3829 : 
; 3830 : 	}else{

  00157	eb 18		 jmp	 SHORT $LN1@lssproto_E
$LN3@lssproto_E:

; 3831 : 		sendEnFlag = 0;

  00159	33 c0		 xor	 eax, eax
  0015b	66 a3 00 00 00
	00		 mov	 WORD PTR ?sendEnFlag@@3FA, ax ; sendEnFlag

; 3832 : 		duelSendFlag = 0;

  00161	33 c0		 xor	 eax, eax
  00163	66 a3 00 00 00
	00		 mov	 WORD PTR ?duelSendFlag@@3FA, ax ; duelSendFlag

; 3833 : 		jbSendFlag = 0;

  00169	33 c0		 xor	 eax, eax
  0016b	66 a3 00 00 00
	00		 mov	 WORD PTR ?jbSendFlag@@3FA, ax ; jbSendFlag
$LN1@lssproto_E:

; 3834 : 	}
; 3835 : }

  00171	5f		 pop	 edi
  00172	5e		 pop	 esi
  00173	5b		 pop	 ebx
  00174	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0017a	3b ec		 cmp	 ebp, esp
  0017c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00181	8b e5		 mov	 esp, ebp
  00183	5d		 pop	 ebp
  00184	c3		 ret	 0
?lssproto_EN_recv@@YAXHHH@Z ENDP			; lssproto_EN_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_EV_recv@@YAXHHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_seqno$ = 12						; size = 4
_result$ = 16						; size = 4
?lssproto_EV_recv@@YAXHHH@Z PROC			; lssproto_EV_recv, COMDAT

; 3209 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3210 : 
; 3211 : 
; 3212 : 	// ????????????????雪????
; 3213 : 	if ( logOutFlag )

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?logOutFlag@@3HA, 0 ; logOutFlag
  00025	74 02		 je	 SHORT $LN2@lssproto_E

; 3214 : 		return;

  00027	eb 4f		 jmp	 SHORT $LN1@lssproto_E
$LN2@lssproto_E:

; 3215 : 
; 3216 : 	if ( eventWarpSendId == seqno )

  00029	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?eventWarpSendId@@3FA ; eventWarpSendId
  00030	3b 45 0c	 cmp	 eax, DWORD PTR _seqno$[ebp]
  00033	75 29		 jne	 SHORT $LN3@lssproto_E

; 3217 : 	{
; 3218 : 		eventWarpSendFlag = 0;

  00035	33 c0		 xor	 eax, eax
  00037	66 a3 00 00 00
	00		 mov	 WORD PTR ?eventWarpSendFlag@@3FA, ax ; eventWarpSendFlag

; 3219 : 		if ( result == 0 )

  0003d	83 7d 10 00	 cmp	 DWORD PTR _result$[ebp], 0
  00041	75 19		 jne	 SHORT $LN5@lssproto_E

; 3220 : 		{
; 3221 : 			// ???害??????????
; 3222 : 			redrawMap();

  00043	e8 00 00 00 00	 call	 ?redrawMap@@YAXXZ	; redrawMap

; 3223 : 			floorChangeFlag = FALSE;

  00048	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?floorChangeFlag@@3HA, 0 ; floorChangeFlag

; 3224 : 			// ?嗓??????????
; 3225 : 			warpEffectStart = TRUE;

  00052	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?warpEffectStart@@3HA, 1 ; warpEffectStart
$LN5@lssproto_E:

; 3226 : 
; 3227 : 		}
; 3228 : 	}
; 3229 : 	else

  0005c	eb 1a		 jmp	 SHORT $LN1@lssproto_E
$LN3@lssproto_E:

; 3230 : 	if ( eventEnemySendId == seqno )

  0005e	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?eventEnemySendId@@3FA ; eventEnemySendId
  00065	3b 45 0c	 cmp	 eax, DWORD PTR _seqno$[ebp]
  00068	75 0e		 jne	 SHORT $LN1@lssproto_E

; 3231 : 	{
; 3232 : 		if ( result == 0 )

  0006a	83 7d 10 00	 cmp	 DWORD PTR _result$[ebp], 0
  0006e	75 08		 jne	 SHORT $LN1@lssproto_E

; 3233 : 		{
; 3234 : 			eventEnemySendFlag = 0;

  00070	33 c0		 xor	 eax, eax
  00072	66 a3 00 00 00
	00		 mov	 WORD PTR ?eventEnemySendFlag@@3FA, ax ; eventEnemySendFlag
$LN1@lssproto_E:

; 3235 : 		}
; 3236 : 		//else
; 3237 : 		//{
; 3238 : 			// ??????process.cpp???
; 3239 : 		//}
; 3240 : 	}
; 3241 : }

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00081	3b ec		 cmp	 ebp, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?lssproto_EV_recv@@YAXHHH@Z ENDP			; lssproto_EV_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_XYD_recv@@YAXHHHH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_dir$ = 20						; size = 4
?lssproto_XYD_recv@@YAXHHHH@Z PROC			; lssproto_XYD_recv, COMDAT

; 4077 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 4078 : 	updateMapArea();

  0001e	e8 00 00 00 00	 call	 ?updateMapArea@@YAXXZ	; updateMapArea

; 4079 : 	setPcWarpPoint( x, y );

  00023	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ?setPcWarpPoint@@YAXHH@Z ; setPcWarpPoint
  00030	83 c4 08	 add	 esp, 8

; 4080 : 	setPcPoint();

  00033	e8 00 00 00 00	 call	 ?setPcPoint@@YAXXZ	; setPcPoint

; 4081 : 	dir = (dir+3) % 8;

  00038	8b 45 14	 mov	 eax, DWORD PTR _dir$[ebp]
  0003b	83 c0 03	 add	 eax, 3
  0003e	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00043	79 05		 jns	 SHORT $LN3@lssproto_X
  00045	48		 dec	 eax
  00046	83 c8 f8	 or	 eax, -8			; fffffff8H
  00049	40		 inc	 eax
$LN3@lssproto_X:
  0004a	89 45 14	 mov	 DWORD PTR _dir$[ebp], eax

; 4082 : 	setPcDir( dir );

  0004d	8b 45 14	 mov	 eax, DWORD PTR _dir$[ebp]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ?setPcDir@@YAXH@Z	; setPcDir
  00056	83 c4 04	 add	 esp, 4

; 4083 : 
; 4084 : 	//JLWG 2016.9.16 收到2号包，战斗结束，去掉头顶战斗vs图案
; 4085 : 	pc.status &= (~CHR_STATUS_BATTLE);

  00059	a1 a4 00 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+164
  0005e	25 ff fb ff ff	 and	 eax, -1025		; fffffbffH
  00063	a3 a4 00 00 00	 mov	 DWORD PTR ?pc@@3UPC@@A+164, eax

; 4086 : 
; 4087 : 	vsLookFlag = 0;

  00068	33 c0		 xor	 eax, eax
  0006a	66 a3 00 00 00
	00		 mov	 WORD PTR ?vsLookFlag@@3FA, ax ; vsLookFlag

; 4088 : 	JL_锁定人物(false);

  00070	6a 00		 push	 0
  00072	e8 00 00 00 00	 call	 ?JL_锁定人物@@YAX_N@Z	; JL_锁定人物
  00077	83 c4 04	 add	 esp, 4

; 4089 : 
; 4090 : 	//JL fix 2017.9.18  把eo放到这里发,因为原eo需要SubProcNo=8时发,(battleProc.cpp line:1011)
; 4091 : 	//而如果画面速度过快,可能会不经过SubProcNo=8,导致不发eo,卡画面
; 4092 : 	//暂时先不修,会出现战斗后画面被清
; 4093 : 	//if (bNewServer)
; 4094 : 	//	lssproto_EO_send(sockfd, 0);
; 4095 : 	//else
; 4096 : 	//	old_lssproto_EO_send(sockfd, 0);
; 4097 : }

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
?lssproto_XYD_recv@@YAXHHHH@Z ENDP			; lssproto_XYD_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?lssproto_DENGON_recv@@YAXPADHH@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
_colors$ = 12						; size = 4
_nums$ = 16						; size = 4
?lssproto_DENGON_recv@@YAXPADHH@Z PROC			; lssproto_DENGON_recv, COMDAT

; 4688 : void lssproto_DENGON_recv(char *data, int colors, int nums){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 4689 : 	extern int 公告数量;
; 4690 : 	extern char 公告内容[512];
; 4691 : 	extern int 公告颜色;
; 4692 : 	extern int 公告时间;
; 4693 : 	公告时间=0;

  0001e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?公告时间@@3HA, 0 ; 公告时间

; 4694 : 	sprintf(公告内容, "%s", data);

  00028	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  0002b	50		 push	 eax
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00031	68 00 00 00 00	 push	 OFFSET ?公告内容@@3PADA	; 公告内容
  00036	e8 00 00 00 00	 call	 _sprintf
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4695 : 	公告颜色 = colors;

  0003e	8b 45 0c	 mov	 eax, DWORD PTR _colors$[ebp]
  00041	a3 00 00 00 00	 mov	 DWORD PTR ?公告颜色@@3HA, eax ; 公告颜色

; 4696 : 	公告数量 = nums;

  00046	8b 45 10	 mov	 eax, DWORD PTR _nums$[ebp]
  00049	a3 00 00 00 00	 mov	 DWORD PTR ?公告数量@@3HA, eax ; 公告数量

; 4697 : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00057	3b ec		 cmp	 ebp, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
?lssproto_DENGON_recv@@YAXPADHH@Z ENDP			; lssproto_DENGON_recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?delCharProc@@YAHXZ
_TEXT	SEGMENT
?delCharProc@@YAHXZ PROC				; delCharProc, COMDAT

; 3138 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3139 : 	if ( netproc_sending == NETPROC_RECEIVED )

  0001e	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?netproc_sending@@3HA, 2 ; netproc_sending
  00025	75 25		 jne	 SHORT $LN2@delCharPro

; 3140 : 	{
; 3141 : 		netproc_sending = NETPROC_NOTSEND;

  00027	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 0 ; netproc_sending

; 3142 : 		if ( charDelStatus )

  00031	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?charDelStatus@@3FA ; charDelStatus
  00038	85 c0		 test	 eax, eax
  0003a	74 09		 je	 SHORT $LN3@delCharPro

; 3143 : 		{
; 3144 : 			return 1;

  0003c	b8 01 00 00 00	 mov	 eax, 1
  00041	eb 34		 jmp	 SHORT $LN1@delCharPro

; 3145 : 		}
; 3146 : 		else

  00043	eb 07		 jmp	 SHORT $LN2@delCharPro
$LN3@delCharPro:

; 3147 : 		{
; 3148 : 			return -2;

  00045	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0004a	eb 2b		 jmp	 SHORT $LN1@delCharPro
$LN2@delCharPro:

; 3149 : 		}
; 3150 : 	}
; 3151 : 
; 3152 : 	SETTIMEOUT2( NET_ERRMSG_DELETECHARTIMEOUT );

  0004c	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00051	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?start_time@@3KA ; start_time
  00057	3d c0 27 09 00	 cmp	 eax, 600000		; 000927c0H
  0005c	76 17		 jbe	 SHORT $LN5@delCharPro
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@ILDAKNL@?l?Q?Z?$KK?$NO?$PL?p?$LG?$DP?$DP?l?$KL?S?p?$KB?$KD?$AA@
  00063	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  00068	e8 00 00 00 00	 call	 _sprintf
  0006d	83 c4 08	 add	 esp, 8
  00070	83 c8 ff	 or	 eax, -1
  00073	eb 02		 jmp	 SHORT $LN1@delCharPro
$LN5@delCharPro:

; 3153 : 
; 3154 : 	return 0;

  00075	33 c0		 xor	 eax, eax
$LN1@delCharPro:

; 3155 : }

  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00080	3b ec		 cmp	 ebp, esp
  00082	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
?delCharProc@@YAHXZ ENDP				; delCharProc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?delCharStart@@YAXXZ
_TEXT	SEGMENT
?delCharStart@@YAXXZ PROC				; delCharStart, COMDAT

; 3123 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3124 : 	charDelStatus = 0;

  0001e	33 c0		 xor	 eax, eax
  00020	66 a3 00 00 00
	00		 mov	 WORD PTR ?charDelStatus@@3FA, ax ; charDelStatus

; 3125 : 
; 3126 : 	if (bNewServer)

  00026	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bNewServer@@3HA, 0 ; bNewServer
  0002d	74 15		 je	 SHORT $LN2@delCharSta

; 3127 : 		lssproto_CharDelete_send(sockfd, gamestate_deletechar_charname );

  0002f	68 00 00 00 00	 push	 OFFSET ?gamestate_deletechar_charname@@3PADA ; gamestate_deletechar_charname
  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?lssproto_CharDelete_send@@YAXHPAD@Z ; lssproto_CharDelete_send
  0003f	83 c4 08	 add	 esp, 8

; 3128 : 	else

  00042	eb 13		 jmp	 SHORT $LN3@delCharSta
$LN2@delCharSta:

; 3129 : 		old_lssproto_CharDelete_send(sockfd, gamestate_deletechar_charname );

  00044	68 00 00 00 00	 push	 OFFSET ?gamestate_deletechar_charname@@3PADA ; gamestate_deletechar_charname
  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ?old_lssproto_CharDelete_send@@YAXHPAD@Z ; old_lssproto_CharDelete_send
  00054	83 c4 08	 add	 esp, 8
$LN3@delCharSta:

; 3130 : 
; 3131 : 	SETSENDING;

  00057	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 1 ; netproc_sending
  00061	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00066	a3 00 00 00 00	 mov	 DWORD PTR ?start_time@@3KA, eax ; start_time

; 3132 : }

  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00074	3b ec		 cmp	 ebp, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
?delCharStart@@YAXXZ ENDP				; delCharStart
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?chatStrSendForServer@@YAXPADH@Z
_TEXT	SEGMENT
tv77 = -3380						; size = 4
_tellName$ = -2412					; size = 32
_found$ = -2372						; size = 4
_tmp1$ = -2360						; size = 128
_tmpMsg$ = -2224					; size = 128
_y$ = -2088						; size = 4
_x$ = -2076						; size = 4
_m$ = -2064						; size = 1024
_dest$ = -1032						; size = 1024
__$ArrayPad$ = -4					; size = 4
_str$ = 8						; size = 4
_color$ = 12						; size = 4
?chatStrSendForServer@@YAXPADH@Z PROC			; chatStrSendForServer, COMDAT

; 2587 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 34 0d 00
	00		 sub	 esp, 3380		; 00000d34H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd cc f2 ff
	ff		 lea	 edi, DWORD PTR [ebp-3380]
  00012	b9 4d 03 00 00	 mov	 ecx, 845		; 0000034dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2588 : 	char dest[1024], m[1024];
; 2589 : 	int x, y;
; 2590 : #ifdef _FRIENDCHANNEL
; 2591 : 	char tmpMsg[128];
; 2592 : #endif
; 2593 : #ifdef _TELLCHANNEL
; 2594 : 	char tmp1[128] ;
; 2595 : #endif
; 2596 : 
; 2597 : #ifdef _CHAR_MANOR_DEBUG
; 2598 : 	if (strstr(str, ".光环")) {
; 2599 : 		int 光环ID = 0;
; 2600 : 		光环ID = getIntegerToken(str, ' ', 2);
; 2601 : 		setCharmManor(pc.ptAct, 光环ID);
; 2602 : 		return;
; 2603 : 	}
; 2604 : #endif
; 2605 : 
; 2606 : #ifdef _人物称号_DEBUG
; 2607 : 	if (strstr(str, ".称号")) {
; 2608 : 		int 称号ID = 0;
; 2609 : 		称号ID = getIntegerToken(str, ' ', 2);
; 2610 : 		setCharmTitle(pc.ptAct, 称号ID);
; 2611 : 		return;
; 2612 : 	}
; 2613 : #endif
; 2614 : 
; 2615 : 
; 2616 : #ifdef _SETTICK_COUNT
; 2617 : 	if ( fTalkTick == NULL || (GetTickCount() - *fTalkTick) > 60000 ){
; 2618 : 		FREE( fTalkTick);
; 2619 : #ifdef  _STONDEBUG_
; 2620 : 		g_iMallocCount--;
; 2621 : #endif
; 2622 : 		fTalkTick = (float *)MALLOC( sizeof(float));
; 2623 : #ifdef  _STONDEBUG_
; 2624 : 		g_iMallocCount++;
; 2625 : #endif
; 2626 : 		*fTalkTick = (float)0.00;
; 2627 : 	}
; 2628 : 	if ( (GetTickCount() - *fTalkTick) > 2500 ){
; 2629 : 		*fTalkTick = (float)GetTickCount();
; 2630 : 	}else{
; 2631 : 		return;
; 2632 : 	}
; 2633 : #endif
; 2634 : 	x = nowGx;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nowGx@@3HA ; nowGx
  0002d	89 85 e4 f7 ff
	ff		 mov	 DWORD PTR _x$[ebp], eax

; 2635 : 	y = nowGy;

  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nowGy@@3HA ; nowGy
  00038	89 85 d8 f7 ff
	ff		 mov	 DWORD PTR _y$[ebp], eax

; 2636 : 	makeEscapeString( str, dest, sizeof(dest) );

  0003e	68 00 04 00 00	 push	 1024			; 00000400H
  00043	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _dest$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 ?makeEscapeString@@YAPADPAD0H@Z ; makeEscapeString
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2637 : 
; 2638 : #ifdef _TELLCHANNEL
; 2639 : 	getStringToken( str , ' ', 1, sizeof( tmp1 ) -1, tmp1 );

  00056	8d 85 c8 f6 ff
	ff		 lea	 eax, DWORD PTR _tmp1$[ebp]
  0005c	50		 push	 eax
  0005d	6a 7f		 push	 127			; 0000007fH
  0005f	6a 01		 push	 1
  00061	6a 20		 push	 32			; 00000020H
  00063	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00066	51		 push	 ecx
  00067	e8 00 00 00 00	 call	 ?getStringToken@@YAHPADDHH0@Z ; getStringToken
  0006c	83 c4 14	 add	 esp, 20			; 00000014H

; 2640 : 		char *found;
; 2641 : 		char tellName[32]={""};

  0006f	a0 00 00 00 00	 mov	 al, BYTE PTR ??_C@_00CNPNBAHC@?$AA@
  00074	88 85 94 f6 ff
	ff		 mov	 BYTE PTR _tellName$[ebp], al
  0007a	33 c0		 xor	 eax, eax
  0007c	89 85 95 f6 ff
	ff		 mov	 DWORD PTR _tellName$[ebp+1], eax
  00082	89 85 99 f6 ff
	ff		 mov	 DWORD PTR _tellName$[ebp+5], eax
  00088	89 85 9d f6 ff
	ff		 mov	 DWORD PTR _tellName$[ebp+9], eax
  0008e	89 85 a1 f6 ff
	ff		 mov	 DWORD PTR _tellName$[ebp+13], eax
  00094	89 85 a5 f6 ff
	ff		 mov	 DWORD PTR _tellName$[ebp+17], eax
  0009a	89 85 a9 f6 ff
	ff		 mov	 DWORD PTR _tellName$[ebp+21], eax
  000a0	89 85 ad f6 ff
	ff		 mov	 DWORD PTR _tellName$[ebp+25], eax
  000a6	66 89 85 b1 f6
	ff ff		 mov	 WORD PTR _tellName$[ebp+29], ax
  000ad	88 85 b3 f6 ff
	ff		 mov	 BYTE PTR _tellName$[ebp+31], al

; 2642 : 
; 2643 : 	switch (TalkMode){

  000b3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?TalkMode@@3HA ; TalkMode
  000b8	89 85 cc f2 ff
	ff		 mov	 DWORD PTR tv77[ebp], eax
  000be	83 bd cc f2 ff
	ff 07		 cmp	 DWORD PTR tv77[ebp], 7
  000c5	0f 87 cb 01 00
	00		 ja	 $LN2@chatStrSen
  000cb	8b 8d cc f2 ff
	ff		 mov	 ecx, DWORD PTR tv77[ebp]
  000d1	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN24@chatStrSen[ecx*4]
$LN4@chatStrSen:

; 2644 : 	case 0:
; 2645 : 
; 2646 : #ifdef _CHANNEL_MODIFY
; 2647 : 	case 2:
; 2648 : #endif
; 2649 : 		sprintf( m, "P|%s", dest );

  000d8	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _dest$[ebp]
  000de	50		 push	 eax
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_04BKLDHGDD@P?$HM?$CFs?$AA@
  000e4	8d 8d f0 f7 ff
	ff		 lea	 ecx, DWORD PTR _m$[ebp]
  000ea	51		 push	 ecx
  000eb	e8 00 00 00 00	 call	 _sprintf
  000f0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2650 : 		break;

  000f3	e9 9e 01 00 00	 jmp	 $LN2@chatStrSen
$LN5@chatStrSen:

; 2651 : 	case 1:
; 2652 : 		if ( strcmp ( tmp1 , str ) == 0 || strlen(tmp1) > 16) {

  000f8	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  000fb	50		 push	 eax
  000fc	8d 8d c8 f6 ff
	ff		 lea	 ecx, DWORD PTR _tmp1$[ebp]
  00102	51		 push	 ecx
  00103	e8 00 00 00 00	 call	 _strcmp
  00108	83 c4 08	 add	 esp, 8
  0010b	85 c0		 test	 eax, eax
  0010d	74 14		 je	 SHORT $LN7@chatStrSen
  0010f	8d 85 c8 f6 ff
	ff		 lea	 eax, DWORD PTR _tmp1$[ebp]
  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 _strlen
  0011b	83 c4 04	 add	 esp, 4
  0011e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00121	76 28		 jbe	 SHORT $LN6@chatStrSen
$LN7@chatStrSen:

; 2653 : 			StockChatBufferLine(  "指令使用格式不正确！" , FONT_PAL_RED);

  00123	6a 00		 push	 0
  00125	6a 06		 push	 6
  00127	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@BFJFDKGC@?r?$KG?V?$LF?$NO?E?i?D?L?$KL?c?R?$NM?t?o?a?$DP?$KD?$KB?$AA@
  0012c	e8 00 00 00 00	 call	 ?StockChatBufferLine@@YAXPADEH@Z ; StockChatBufferLine
  00131	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2654 : 			strcpy(secretName,"");

  00134	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00139	68 00 00 00 00	 push	 OFFSET ?secretName@@3PADA ; secretName
  0013e	e8 00 00 00 00	 call	 _strcpy
  00143	83 c4 08	 add	 esp, 8

; 2655 : 			return ; 

  00146	e9 b2 01 00 00	 jmp	 $LN1@chatStrSen
$LN6@chatStrSen:

; 2656 : 		}
; 2657 : 		if ( found = strstr( str, " " )){

  0014b	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  00150	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 ?strstr@@YAPADQADQBD@Z	; strstr
  00159	83 c4 08	 add	 esp, 8
  0015c	89 85 bc f6 ff
	ff		 mov	 DWORD PTR _found$[ebp], eax
  00162	83 bd bc f6 ff
	ff 00		 cmp	 DWORD PTR _found$[ebp], 0
  00169	74 3d		 je	 SHORT $LN8@chatStrSen

; 2658 : 			strncpy(tellName, str, strlen(str) - strlen(found));

  0016b	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  0016e	50		 push	 eax
  0016f	e8 00 00 00 00	 call	 _strlen
  00174	83 c4 04	 add	 esp, 4
  00177	8b f0		 mov	 esi, eax
  00179	8b 8d bc f6 ff
	ff		 mov	 ecx, DWORD PTR _found$[ebp]
  0017f	51		 push	 ecx
  00180	e8 00 00 00 00	 call	 _strlen
  00185	83 c4 04	 add	 esp, 4
  00188	2b f0		 sub	 esi, eax
  0018a	8b fc		 mov	 edi, esp
  0018c	56		 push	 esi
  0018d	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00190	52		 push	 edx
  00191	8d 85 94 f6 ff
	ff		 lea	 eax, DWORD PTR _tellName$[ebp]
  00197	50		 push	 eax
  00198	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncpy
  0019e	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a1	3b fc		 cmp	 edi, esp
  001a3	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN8@chatStrSen:

; 2659 : 		}
; 2660 : 		sprintf( secretName, "%s ",tellName);

  001a8	8d 85 94 f6 ff
	ff		 lea	 eax, DWORD PTR _tellName$[ebp]
  001ae	50		 push	 eax
  001af	68 00 00 00 00	 push	 OFFSET ??_C@_03IKGEINEE@?$CFs?5?$AA@
  001b4	68 00 00 00 00	 push	 OFFSET ?secretName@@3PADA ; secretName
  001b9	e8 00 00 00 00	 call	 _sprintf
  001be	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2661 : 		sprintf( m, "P|/tell %s", dest );

  001c1	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _dest$[ebp]
  001c7	50		 push	 eax
  001c8	68 00 00 00 00	 push	 OFFSET ??_C@_0L@BFDNBDBG@P?$HM?1tell?5?$CFs?$AA@
  001cd	8d 8d f0 f7 ff
	ff		 lea	 ecx, DWORD PTR _m$[ebp]
  001d3	51		 push	 ecx
  001d4	e8 00 00 00 00	 call	 _sprintf
  001d9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2662 : 		break;

  001dc	e9 b5 00 00 00	 jmp	 $LN2@chatStrSen
$LN9@chatStrSen:

; 2663 : #ifndef _CHANNEL_MODIFY
; 2664 : 	#ifdef _FRIENDCHANNEL
; 2665 : 		case 2:
; 2666 : 			sprintf(tmpMsg,"T|%s : %s",pc.name,dest);
; 2667 : 			lssproto_CHATROOM_send (sockfd ,tmpMsg);
; 2668 : 			return;
; 2669 : 	#endif
; 2670 : #else
; 2671 : 		case 3:
; 2672 : 			sprintf(m,"P|/FM%s",dest);

  001e1	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _dest$[ebp]
  001e7	50		 push	 eax
  001e8	68 00 00 00 00	 push	 OFFSET ??_C@_07JGJAFNNL@P?$HM?1FM?$CFs?$AA@
  001ed	8d 8d f0 f7 ff
	ff		 lea	 ecx, DWORD PTR _m$[ebp]
  001f3	51		 push	 ecx
  001f4	e8 00 00 00 00	 call	 _sprintf
  001f9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2673 : 			break;

  001fc	e9 95 00 00 00	 jmp	 $LN2@chatStrSen
$LN10@chatStrSen:

; 2674 : 		case 4:
; 2675 : 			sprintf(m,"P|/OCC%s：%s",pc.name,dest);

  00201	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _dest$[ebp]
  00207	50		 push	 eax
  00208	68 70 00 00 00	 push	 OFFSET ?pc@@3UPC@@A+112
  0020d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@INHGBDFL@P?$HM?1OCC?$CFs?$KD?$LK?$CFs?$AA@
  00212	8d 8d f0 f7 ff
	ff		 lea	 ecx, DWORD PTR _m$[ebp]
  00218	51		 push	 ecx
  00219	e8 00 00 00 00	 call	 _sprintf
  0021e	83 c4 10	 add	 esp, 16			; 00000010H

; 2676 : 			break;

  00221	eb 73		 jmp	 SHORT $LN2@chatStrSen
$LN11@chatStrSen:

; 2677 : #ifdef _CHATROOMPROTOCOL
; 2678 : 		case 5:
; 2679 : 			sprintf(tmpMsg,"T|%s：%s",pc.name,dest);

  00223	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _dest$[ebp]
  00229	50		 push	 eax
  0022a	68 70 00 00 00	 push	 OFFSET ?pc@@3UPC@@A+112
  0022f	68 00 00 00 00	 push	 OFFSET ??_C@_08KCFIPDCG@T?$HM?$CFs?$KD?$LK?$CFs?$AA@
  00234	8d 8d 50 f7 ff
	ff		 lea	 ecx, DWORD PTR _tmpMsg$[ebp]
  0023a	51		 push	 ecx
  0023b	e8 00 00 00 00	 call	 _sprintf
  00240	83 c4 10	 add	 esp, 16			; 00000010H

; 2680 : 			lssproto_CHATROOM_send (sockfd ,tmpMsg);

  00243	8d 85 50 f7 ff
	ff		 lea	 eax, DWORD PTR _tmpMsg$[ebp]
  00249	50		 push	 eax
  0024a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockfd@@3IA ; sockfd
  00250	51		 push	 ecx
  00251	e8 00 00 00 00	 call	 ?lssproto_CHATROOM_send@@YAXHPAD@Z ; lssproto_CHATROOM_send
  00256	83 c4 08	 add	 esp, 8

; 2681 : 			return;

  00259	e9 9f 00 00 00	 jmp	 $LN1@chatStrSen
$LN12@chatStrSen:

; 2682 : #endif
; 2683 : #ifdef _CHATWORLDWIDEPROTOCOL
; 2684 : 		case 6:
; 2685 : 			sprintf(m, "P|/WD %s", dest);

  0025e	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _dest$[ebp]
  00264	50		 push	 eax
  00265	68 00 00 00 00	 push	 OFFSET ??_C@_08IPPAKAEL@P?$HM?1WD?5?$CFs?$AA@
  0026a	8d 8d f0 f7 ff
	ff		 lea	 ecx, DWORD PTR _m$[ebp]
  00270	51		 push	 ecx
  00271	e8 00 00 00 00	 call	 _sprintf
  00276	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2686 : 			break;

  00279	eb 1b		 jmp	 SHORT $LN2@chatStrSen
$LN13@chatStrSen:

; 2687 : #endif
; 2688 : #ifdef _NB_CHANNEL_ALLSERV
; 2689 : 		case 7:
; 2690 : 			sprintf(m, "P|/XQ %s", dest);

  0027b	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _dest$[ebp]
  00281	50		 push	 eax
  00282	68 00 00 00 00	 push	 OFFSET ??_C@_08NGKGAKGM@P?$HM?1XQ?5?$CFs?$AA@
  00287	8d 8d f0 f7 ff
	ff		 lea	 ecx, DWORD PTR _m$[ebp]
  0028d	51		 push	 ecx
  0028e	e8 00 00 00 00	 call	 _sprintf
  00293	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@chatStrSen:

; 2691 : 			break;
; 2692 : #endif
; 2693 : #endif
; 2694 : 	}
; 2695 : #else
; 2696 : 	sprintf( m, "P|%s", dest );
; 2697 : #endif
; 2698 : 	if (bNewServer)

  00296	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bNewServer@@3HA, 0 ; bNewServer
  0029d	74 30		 je	 SHORT $LN14@chatStrSen

; 2699 : 		lssproto_TK_send(sockfd, x, y, m, color, NowMaxVoice );

  0029f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?NowMaxVoice@@3HA ; NowMaxVoice
  002a4	50		 push	 eax
  002a5	8b 4d 0c	 mov	 ecx, DWORD PTR _color$[ebp]
  002a8	51		 push	 ecx
  002a9	8d 95 f0 f7 ff
	ff		 lea	 edx, DWORD PTR _m$[ebp]
  002af	52		 push	 edx
  002b0	8b 85 d8 f7 ff
	ff		 mov	 eax, DWORD PTR _y$[ebp]
  002b6	50		 push	 eax
  002b7	8b 8d e4 f7 ff
	ff		 mov	 ecx, DWORD PTR _x$[ebp]
  002bd	51		 push	 ecx
  002be	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?sockfd@@3IA ; sockfd
  002c4	52		 push	 edx
  002c5	e8 00 00 00 00	 call	 ?lssproto_TK_send@@YAXHHHPADHH@Z ; lssproto_TK_send
  002ca	83 c4 18	 add	 esp, 24			; 00000018H

; 2700 : 	else

  002cd	eb 2e		 jmp	 SHORT $LN1@chatStrSen
$LN14@chatStrSen:

; 2701 : 		old_lssproto_TK_send(sockfd, x, y, m, color, NowMaxVoice );

  002cf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?NowMaxVoice@@3HA ; NowMaxVoice
  002d4	50		 push	 eax
  002d5	8b 4d 0c	 mov	 ecx, DWORD PTR _color$[ebp]
  002d8	51		 push	 ecx
  002d9	8d 95 f0 f7 ff
	ff		 lea	 edx, DWORD PTR _m$[ebp]
  002df	52		 push	 edx
  002e0	8b 85 d8 f7 ff
	ff		 mov	 eax, DWORD PTR _y$[ebp]
  002e6	50		 push	 eax
  002e7	8b 8d e4 f7 ff
	ff		 mov	 ecx, DWORD PTR _x$[ebp]
  002ed	51		 push	 ecx
  002ee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?sockfd@@3IA ; sockfd
  002f4	52		 push	 edx
  002f5	e8 00 00 00 00	 call	 ?old_lssproto_TK_send@@YAXHHHPADHH@Z ; old_lssproto_TK_send
  002fa	83 c4 18	 add	 esp, 24			; 00000018H
$LN1@chatStrSen:

; 2702 : }

  002fd	52		 push	 edx
  002fe	8b cd		 mov	 ecx, ebp
  00300	50		 push	 eax
  00301	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN23@chatStrSen
  00307	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0030c	58		 pop	 eax
  0030d	5a		 pop	 edx
  0030e	5f		 pop	 edi
  0030f	5e		 pop	 esi
  00310	5b		 pop	 ebx
  00311	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00314	33 cd		 xor	 ecx, ebp
  00316	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0031b	81 c4 34 0d 00
	00		 add	 esp, 3380		; 00000d34H
  00321	3b ec		 cmp	 ebp, esp
  00323	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00328	8b e5		 mov	 esp, ebp
  0032a	5d		 pop	 ebp
  0032b	c3		 ret	 0
$LN23@chatStrSen:
  0032c	05 00 00 00	 DD	 5
  00330	00 00 00 00	 DD	 $LN22@chatStrSen
$LN22@chatStrSen:
  00334	f8 fb ff ff	 DD	 -1032			; fffffbf8H
  00338	00 04 00 00	 DD	 1024			; 00000400H
  0033c	00 00 00 00	 DD	 $LN17@chatStrSen
  00340	f0 f7 ff ff	 DD	 -2064			; fffff7f0H
  00344	00 04 00 00	 DD	 1024			; 00000400H
  00348	00 00 00 00	 DD	 $LN18@chatStrSen
  0034c	50 f7 ff ff	 DD	 -2224			; fffff750H
  00350	80 00 00 00	 DD	 128			; 00000080H
  00354	00 00 00 00	 DD	 $LN19@chatStrSen
  00358	c8 f6 ff ff	 DD	 -2360			; fffff6c8H
  0035c	80 00 00 00	 DD	 128			; 00000080H
  00360	00 00 00 00	 DD	 $LN20@chatStrSen
  00364	94 f6 ff ff	 DD	 -2412			; fffff694H
  00368	20 00 00 00	 DD	 32			; 00000020H
  0036c	00 00 00 00	 DD	 $LN21@chatStrSen
$LN21@chatStrSen:
  00370	74		 DB	 116			; 00000074H
  00371	65		 DB	 101			; 00000065H
  00372	6c		 DB	 108			; 0000006cH
  00373	6c		 DB	 108			; 0000006cH
  00374	4e		 DB	 78			; 0000004eH
  00375	61		 DB	 97			; 00000061H
  00376	6d		 DB	 109			; 0000006dH
  00377	65		 DB	 101			; 00000065H
  00378	00		 DB	 0
$LN20@chatStrSen:
  00379	74		 DB	 116			; 00000074H
  0037a	6d		 DB	 109			; 0000006dH
  0037b	70		 DB	 112			; 00000070H
  0037c	31		 DB	 49			; 00000031H
  0037d	00		 DB	 0
$LN19@chatStrSen:
  0037e	74		 DB	 116			; 00000074H
  0037f	6d		 DB	 109			; 0000006dH
  00380	70		 DB	 112			; 00000070H
  00381	4d		 DB	 77			; 0000004dH
  00382	73		 DB	 115			; 00000073H
  00383	67		 DB	 103			; 00000067H
  00384	00		 DB	 0
$LN18@chatStrSen:
  00385	6d		 DB	 109			; 0000006dH
  00386	00		 DB	 0
$LN17@chatStrSen:
  00387	64		 DB	 100			; 00000064H
  00388	65		 DB	 101			; 00000065H
  00389	73		 DB	 115			; 00000073H
  0038a	74		 DB	 116			; 00000074H
  0038b	00		 DB	 0
$LN24@chatStrSen:
  0038c	00 00 00 00	 DD	 $LN4@chatStrSen
  00390	00 00 00 00	 DD	 $LN5@chatStrSen
  00394	00 00 00 00	 DD	 $LN4@chatStrSen
  00398	00 00 00 00	 DD	 $LN9@chatStrSen
  0039c	00 00 00 00	 DD	 $LN10@chatStrSen
  003a0	00 00 00 00	 DD	 $LN11@chatStrSen
  003a4	00 00 00 00	 DD	 $LN12@chatStrSen
  003a8	00 00 00 00	 DD	 $LN13@chatStrSen
?chatStrSendForServer@@YAXPADH@Z ENDP			; chatStrSendForServer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?noChecksumWalkSendForServer@@YAXHHPAD@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_direction$ = 16					; size = 4
?noChecksumWalkSendForServer@@YAXHHPAD@Z PROC		; noChecksumWalkSendForServer, COMDAT

; 2565 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2566 : //#ifdef __NEW_PROTOCOL
; 2567 : 	if (bNewServer)

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bNewServer@@3HA, 0 ; bNewServer
  00025	74 1c		 je	 SHORT $LN2@noChecksum

; 2568 : 		lssproto_W2_send(sockfd , x, y, direction );

  00027	8b 45 10	 mov	 eax, DWORD PTR _direction$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  00032	52		 push	 edx
  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?lssproto_W2_send@@YAXHHHPAD@Z ; lssproto_W2_send
  0003e	83 c4 10	 add	 esp, 16			; 00000010H

; 2569 : 	else

  00041	eb 1a		 jmp	 SHORT $LN1@noChecksum
$LN2@noChecksum:

; 2570 : //#else
; 2571 : 		old_lssproto_w_send(sockfd , x, y, direction );

  00043	8b 45 10	 mov	 eax, DWORD PTR _direction$[ebp]
  00046	50		 push	 eax
  00047	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  0004a	51		 push	 ecx
  0004b	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  0004e	52		 push	 edx
  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?old_lssproto_w_send@@YAXHHHPAD@Z ; old_lssproto_w_send
  0005a	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@noChecksum:

; 2572 : //#endif
; 2573 : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
?noChecksumWalkSendForServer@@YAXHHPAD@Z ENDP		; noChecksumWalkSendForServer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?walkSendForServer@@YAXHHPAD@Z
_TEXT	SEGMENT
_ext$1 = -8						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_direction$ = 16					; size = 4
?walkSendForServer@@YAXHHPAD@Z PROC			; walkSendForServer, COMDAT

; 2535 : void walkSendForServer( int x, int y, char *direction ){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2536 : #ifdef _MIND_ICON
; 2537 : 
; 2538 : 	//JL fix 2017.8.13 切换地图的时候崩溃(可能进了战斗)，此时pc.ptAct = NULL
; 2539 : 	if (pc.ptAct == NULL) return;

  0001e	83 3d ec 50 00
	00 00		 cmp	 DWORD PTR ?pc@@3UPC@@A+20716, 0
  00025	75 05		 jne	 SHORT $LN2@walkSendFo
  00027	e9 c3 00 00 00	 jmp	 $LN1@walkSendFo
$LN2@walkSendFo:

; 2540 : 	if ( (pc.ptAct->sMindIcon == SPR_asleep) ||
; 2541 : 		(pc.ptAct->sMindIcon == SPR_cafe)   ||

  0002c	a1 ec 50 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+20716
  00031	81 b8 c0 01 00
	00 aa 8b 01 00	 cmp	 DWORD PTR [eax+448], 101290 ; 00018baaH
  0003b	74 22		 je	 SHORT $LN4@walkSendFo
  0003d	a1 ec 50 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+20716
  00042	81 b8 c0 01 00
	00 ae 8b 01 00	 cmp	 DWORD PTR [eax+448], 101294 ; 00018baeH
  0004c	74 11		 je	 SHORT $LN4@walkSendFo
  0004e	a1 ec 50 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+20716
  00053	81 b8 c0 01 00
	00 a8 8b 01 00	 cmp	 DWORD PTR [eax+448], 101288 ; 00018ba8H
  0005d	75 51		 jne	 SHORT $LN3@walkSendFo
$LN4@walkSendFo:

; 2542 : 		(pc.ptAct->sMindIcon == SPR_accent) ){
; 2543 : 			CHAREXTRA *ext;
; 2544 : 			ext = (CHAREXTRA *)pc.ptAct->pYobi;

  0005f	a1 ec 50 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+20716
  00064	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00067	89 4d f8	 mov	 DWORD PTR _ext$1[ebp], ecx

; 2545 : 
; 2546 : 			DeathAction( ext->ptMindIcon);

  0006a	8b 45 f8	 mov	 eax, DWORD PTR _ext$1[ebp]
  0006d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00070	51		 push	 ecx
  00071	e8 00 00 00 00	 call	 ?DeathAction@@YAXPAUaction@@@Z ; DeathAction
  00076	83 c4 04	 add	 esp, 4

; 2547 : 			ext->ptMindIcon = NULL;

  00079	8b 45 f8	 mov	 eax, DWORD PTR _ext$1[ebp]
  0007c	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 2548 : 			pc.ptAct->sMindIcon = 0;

  00083	a1 ec 50 00 00	 mov	 eax, DWORD PTR ?pc@@3UPC@@A+20716
  00088	c7 80 c0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+448], 0

; 2549 : 			
; 2550 : 			lssproto_MA_send(sockfd, nowGx, nowGy, 0);

  00092	6a 00		 push	 0
  00094	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nowGy@@3HA ; nowGy
  00099	50		 push	 eax
  0009a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nowGx@@3HA ; nowGx
  000a0	51		 push	 ecx
  000a1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?sockfd@@3IA ; sockfd
  000a7	52		 push	 edx
  000a8	e8 00 00 00 00	 call	 ?lssproto_MA_send@@YAXHHHH@Z ; lssproto_MA_send
  000ad	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@walkSendFo:

; 2551 : 	}
; 2552 : #endif
; 2553 : #ifdef _REMAKE_20
; 2554 : 	if (!ChangedLibrary()) 
; 2555 : 		RestoreLibrary();
; 2556 : #endif
; 2557 : 	if (bNewServer)

  000b0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bNewServer@@3HA, 0 ; bNewServer
  000b7	74 1c		 je	 SHORT $LN5@walkSendFo

; 2558 : 		lssproto_W2_send(sockfd , x, y, direction );

  000b9	8b 45 10	 mov	 eax, DWORD PTR _direction$[ebp]
  000bc	50		 push	 eax
  000bd	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  000c0	51		 push	 ecx
  000c1	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  000c4	52		 push	 edx
  000c5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ?lssproto_W2_send@@YAXHHHPAD@Z ; lssproto_W2_send
  000d0	83 c4 10	 add	 esp, 16			; 00000010H

; 2559 : 	else

  000d3	eb 1a		 jmp	 SHORT $LN1@walkSendFo
$LN5@walkSendFo:

; 2560 : 		old_lssproto_W_send(sockfd , x, y, direction );

  000d5	8b 45 10	 mov	 eax, DWORD PTR _direction$[ebp]
  000d8	50		 push	 eax
  000d9	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  000dc	51		 push	 ecx
  000dd	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  000e0	52		 push	 edx
  000e1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 ?old_lssproto_W_send@@YAXHHHPAD@Z ; old_lssproto_W_send
  000ec	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@walkSendFo:

; 2561 : }

  000ef	5f		 pop	 edi
  000f0	5e		 pop	 esi
  000f1	5b		 pop	 ebx
  000f2	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000f8	3b ec		 cmp	 ebp, esp
  000fa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
?walkSendForServer@@YAXHHPAD@Z ENDP			; walkSendForServer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?charLogoutProc@@YAHXZ
_TEXT	SEGMENT
?charLogoutProc@@YAHXZ PROC				; charLogoutProc, COMDAT

; 839  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 840  : 	if (netproc_sending == NETPROC_RECEIVED)

  0001e	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?netproc_sending@@3HA, 2 ; netproc_sending
  00025	75 26		 jne	 SHORT $LN2@charLogout

; 841  : 	{
; 842  : 		netproc_sending = NETPROC_NOTSEND;

  00027	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 0 ; netproc_sending

; 843  : 		if (charLogoutStatus == 1)

  00031	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?charLogoutStatus@@3FA ; charLogoutStatus
  00038	83 f8 01	 cmp	 eax, 1
  0003b	75 09		 jne	 SHORT $LN3@charLogout

; 844  : 			return 1;

  0003d	b8 01 00 00 00	 mov	 eax, 1
  00042	eb 34		 jmp	 SHORT $LN1@charLogout

; 845  : 		else

  00044	eb 07		 jmp	 SHORT $LN2@charLogout
$LN3@charLogout:

; 846  : 			return -2;

  00046	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0004b	eb 2b		 jmp	 SHORT $LN1@charLogout
$LN2@charLogout:

; 847  :     }
; 848  : 	SETTIMEOUT2(NET_ERRMSG_LOGOUTTIMEOUT);

  0004d	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00052	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?start_time@@3KA ; start_time
  00058	3d c0 27 09 00	 cmp	 eax, 600000		; 000927c0H
  0005d	76 17		 jbe	 SHORT $LN5@charLogout
  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@KHEOLEJA@?T?t?u?s?$DP?W?b?$DP?$DP?l?$KL?S?p?$KB?$KD?$AA@
  00064	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  00069	e8 00 00 00 00	 call	 _sprintf
  0006e	83 c4 08	 add	 esp, 8
  00071	83 c8 ff	 or	 eax, -1
  00074	eb 02		 jmp	 SHORT $LN1@charLogout
$LN5@charLogout:

; 849  : 	return 0;

  00076	33 c0		 xor	 eax, eax
$LN1@charLogout:

; 850  : }

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00081	3b ec		 cmp	 ebp, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?charLogoutProc@@YAHXZ ENDP				; charLogoutProc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?charLogoutStart@@YAXXZ
_TEXT	SEGMENT
?charLogoutStart@@YAXXZ PROC				; charLogoutStart, COMDAT

; 829  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 830  : 	charLogoutStatus = 0;

  0001e	33 c0		 xor	 eax, eax
  00020	66 a3 00 00 00
	00		 mov	 WORD PTR ?charLogoutStatus@@3FA, ax ; charLogoutStatus

; 831  : 	if (bNewServer)

  00026	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bNewServer@@3HA, 0 ; bNewServer
  0002d	74 12		 je	 SHORT $LN2@charLogout

; 832  : 		lssproto_CharLogout_send(sockfd, 1);

  0002f	6a 01		 push	 1
  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?lssproto_CharLogout_send@@YAXHH@Z ; lssproto_CharLogout_send
  0003c	83 c4 08	 add	 esp, 8

; 833  : 	else

  0003f	eb 0e		 jmp	 SHORT $LN3@charLogout
$LN2@charLogout:

; 834  : 		old_lssproto_CharLogout_send(sockfd);

  00041	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ?old_lssproto_CharLogout_send@@YAXH@Z ; old_lssproto_CharLogout_send
  0004c	83 c4 04	 add	 esp, 4
$LN3@charLogout:

; 835  : 	SETSENDING;

  0004f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 1 ; netproc_sending
  00059	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  0005e	a3 00 00 00 00	 mov	 DWORD PTR ?start_time@@3KA, eax ; start_time

; 836  : }

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?charLogoutStart@@YAXXZ ENDP				; charLogoutStart
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?createNewCharProc@@YAHXZ
_TEXT	SEGMENT
?createNewCharProc@@YAHXZ PROC				; createNewCharProc, COMDAT

; 3079 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3080 : 	if ( netproc_sending == NETPROC_RECEIVED )

  0001e	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?netproc_sending@@3HA, 2 ; netproc_sending
  00025	75 26		 jne	 SHORT $LN2@createNewC

; 3081 : 	{
; 3082 : 		netproc_sending = NETPROC_NOTSEND;

  00027	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 0 ; netproc_sending

; 3083 : 		if ( newCharStatus == 1 )

  00031	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?newCharStatus@@3FA ; newCharStatus
  00038	83 f8 01	 cmp	 eax, 1
  0003b	75 09		 jne	 SHORT $LN3@createNewC

; 3084 : 		{
; 3085 : 			return 1;

  0003d	b8 01 00 00 00	 mov	 eax, 1
  00042	eb 34		 jmp	 SHORT $LN1@createNewC

; 3086 : 		}
; 3087 : 		else

  00044	eb 07		 jmp	 SHORT $LN2@createNewC
$LN3@createNewC:

; 3088 : 		{
; 3089 : 			return -2;

  00046	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0004b	eb 2b		 jmp	 SHORT $LN1@createNewC
$LN2@createNewC:

; 3090 : 		}
; 3091 :     }
; 3092 : 
; 3093 : 	SETTIMEOUT2( NET_ERRMSG_CREATECHARTIMEOUT );

  0004d	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00052	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?start_time@@3KA ; start_time
  00058	3d c0 27 09 00	 cmp	 eax, 600000		; 000927c0H
  0005d	76 17		 jbe	 SHORT $LN5@createNewC
  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JFAECEMN@?l?Q?Z?$KK?p?$KE?m?B?$DP?$DP?l?$KL?S?p?$KB?$KD?$AA@
  00064	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  00069	e8 00 00 00 00	 call	 _sprintf
  0006e	83 c4 08	 add	 esp, 8
  00071	83 c8 ff	 or	 eax, -1
  00074	eb 02		 jmp	 SHORT $LN1@createNewC
$LN5@createNewC:

; 3094 : 
; 3095 : 	return 0;

  00076	33 c0		 xor	 eax, eax
$LN1@createNewC:

; 3096 : }

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00081	3b ec		 cmp	 ebp, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?createNewCharProc@@YAHXZ ENDP				; createNewCharProc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?createNewCharStart@@YAXXZ
_TEXT	SEGMENT
?createNewCharStart@@YAXXZ PROC				; createNewCharStart, COMDAT

; 3055 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3056 : 	newCharStatus = 0;

  0001e	33 c0		 xor	 eax, eax
  00020	66 a3 00 00 00
	00		 mov	 WORD PTR ?newCharStatus@@3FA, ax ; newCharStatus

; 3057 : 
; 3058 : 	// ????颌V?t??e???????????
; 3059 : 	if (bNewServer)

  00026	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bNewServer@@3HA, 0 ; bNewServer
  0002d	74 66		 je	 SHORT $LN2@createNewC

; 3060 : 		lssproto_CreateNewChar_send(sockfd, selectPcNo, newCharacterName,

  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?newCharacterHomeTown@@3HA ; newCharacterHomeTown
  00034	50		 push	 eax
  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?newCharacterWind@@3HA ; newCharacterWind
  0003b	51		 push	 ecx
  0003c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?newCharacterFire@@3HA ; newCharacterFire
  00042	52		 push	 edx
  00043	a1 00 00 00 00	 mov	 eax, DWORD PTR ?newCharacterWater@@3HA ; newCharacterWater
  00048	50		 push	 eax
  00049	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?newCharacterEarth@@3HA ; newCharacterEarth
  0004f	51		 push	 ecx
  00050	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?newCharacterDex@@3HA ; newCharacterDex
  00056	52		 push	 edx
  00057	a1 00 00 00 00	 mov	 eax, DWORD PTR ?newCharacterTgh@@3HA ; newCharacterTgh
  0005c	50		 push	 eax
  0005d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?newCharacterStr@@3HA ; newCharacterStr
  00063	51		 push	 ecx
  00064	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?newCharacterVit@@3HA ; newCharacterVit
  0006a	52		 push	 edx
  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?newCharacterFaceGraNo@@3HA ; newCharacterFaceGraNo
  00070	50		 push	 eax
  00071	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?newCharacterGraNo@@3HA ; newCharacterGraNo
  00077	51		 push	 ecx
  00078	68 00 00 00 00	 push	 OFFSET ?newCharacterName@@3PADA ; newCharacterName
  0007d	0f bf 15 00 00
	00 00		 movsx	 edx, WORD PTR ?selectPcNo@@3FA ; selectPcNo
  00084	52		 push	 edx
  00085	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ?lssproto_CreateNewChar_send@@YAXHHPADHHHHHHHHHHH@Z ; lssproto_CreateNewChar_send
  00090	83 c4 38	 add	 esp, 56			; 00000038H

; 3061 : 			newCharacterGraNo, newCharacterFaceGraNo,
; 3062 : 			newCharacterVit, newCharacterStr, newCharacterTgh, newCharacterDex,
; 3063 : 			newCharacterEarth, newCharacterWater, newCharacterFire, newCharacterWind,
; 3064 : 			newCharacterHomeTown );
; 3065 : 	else

  00093	eb 64		 jmp	 SHORT $LN3@createNewC
$LN2@createNewC:

; 3066 : 		old_lssproto_CreateNewChar_send(sockfd, selectPcNo, newCharacterName,

  00095	a1 00 00 00 00	 mov	 eax, DWORD PTR ?newCharacterHomeTown@@3HA ; newCharacterHomeTown
  0009a	50		 push	 eax
  0009b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?newCharacterWind@@3HA ; newCharacterWind
  000a1	51		 push	 ecx
  000a2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?newCharacterFire@@3HA ; newCharacterFire
  000a8	52		 push	 edx
  000a9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?newCharacterWater@@3HA ; newCharacterWater
  000ae	50		 push	 eax
  000af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?newCharacterEarth@@3HA ; newCharacterEarth
  000b5	51		 push	 ecx
  000b6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?newCharacterDex@@3HA ; newCharacterDex
  000bc	52		 push	 edx
  000bd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?newCharacterTgh@@3HA ; newCharacterTgh
  000c2	50		 push	 eax
  000c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?newCharacterStr@@3HA ; newCharacterStr
  000c9	51		 push	 ecx
  000ca	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?newCharacterVit@@3HA ; newCharacterVit
  000d0	52		 push	 edx
  000d1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?newCharacterFaceGraNo@@3HA ; newCharacterFaceGraNo
  000d6	50		 push	 eax
  000d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?newCharacterGraNo@@3HA ; newCharacterGraNo
  000dd	51		 push	 ecx
  000de	68 00 00 00 00	 push	 OFFSET ?newCharacterName@@3PADA ; newCharacterName
  000e3	0f bf 15 00 00
	00 00		 movsx	 edx, WORD PTR ?selectPcNo@@3FA ; selectPcNo
  000ea	52		 push	 edx
  000eb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ?old_lssproto_CreateNewChar_send@@YAXHHPADHHHHHHHHHHH@Z ; old_lssproto_CreateNewChar_send
  000f6	83 c4 38	 add	 esp, 56			; 00000038H
$LN3@createNewC:

; 3067 : 			newCharacterGraNo, newCharacterFaceGraNo,
; 3068 : 			newCharacterVit, newCharacterStr, newCharacterTgh, newCharacterDex,
; 3069 : 			newCharacterEarth, newCharacterWater, newCharacterFire, newCharacterWind,
; 3070 : 			newCharacterHomeTown );
; 3071 : 
; 3072 : 	SETSENDING;

  000f9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 1 ; netproc_sending
  00103	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00108	a3 00 00 00 00	 mov	 DWORD PTR ?start_time@@3KA, eax ; start_time

; 3073 : }

  0010d	5f		 pop	 edi
  0010e	5e		 pop	 esi
  0010f	5b		 pop	 ebx
  00110	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00116	3b ec		 cmp	 ebp, esp
  00118	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011d	8b e5		 mov	 esp, ebp
  0011f	5d		 pop	 ebp
  00120	c3		 ret	 0
?createNewCharStart@@YAXXZ ENDP				; createNewCharStart
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?charLoginProc@@YAHXZ
_TEXT	SEGMENT
?charLoginProc@@YAHXZ PROC				; charLoginProc, COMDAT

; 774  : int charLoginProc(void){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 775  : 	SendCount = 30;

  0001e	c7 05 00 00 00
	00 1e 00 00 00	 mov	 DWORD PTR ?SendCount@@3HA, 30 ; SendCount, 0000001eH

; 776  : 	tradeStatus = 0;

  00028	33 c0		 xor	 eax, eax
  0002a	66 a3 00 00 00
	00		 mov	 WORD PTR ?tradeStatus@@3FA, ax ; tradeStatus

; 777  : 	if (!server_choosed)

  00030	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?server_choosed@@3HA, 0 ; server_choosed
  00037	75 04		 jne	 SHORT $LN2@charLoginP

; 778  : 		return 0;

  00039	33 c0		 xor	 eax, eax
  0003b	eb 6c		 jmp	 SHORT $LN1@charLoginP
$LN2@charLoginP:

; 779  : 	if (netproc_sending == NETPROC_RECEIVED){

  0003d	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?netproc_sending@@3HA, 2 ; netproc_sending
  00044	75 38		 jne	 SHORT $LN3@charLoginP

; 780  : 		netproc_sending = NETPROC_NOTSEND;

  00046	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 0 ; netproc_sending

; 781  : 		if (charLoginStatus == 1)

  00050	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?charLoginStatus@@3FA ; charLoginStatus
  00057	83 f8 01	 cmp	 eax, 1
  0005a	75 09		 jne	 SHORT $LN4@charLoginP

; 782  : 			return 1;

  0005c	b8 01 00 00 00	 mov	 eax, 1
  00061	eb 46		 jmp	 SHORT $LN1@charLoginP

; 783  : 		else

  00063	eb 19		 jmp	 SHORT $LN3@charLoginP
$LN4@charLoginP:

; 784  : #ifdef _NEW_WGS_MSG				// WON ADD WGS的新视窗
; 785  : 			if (ERROR_MESSAGE != 0)

  00065	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ERROR_MESSAGE@@3HA, 0 ; ERROR_MESSAGE
  0006c	74 09		 je	 SHORT $LN6@charLoginP

; 786  : 				return ERROR_MESSAGE;

  0006e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ERROR_MESSAGE@@3HA ; ERROR_MESSAGE
  00073	eb 34		 jmp	 SHORT $LN1@charLoginP

; 787  : 			else

  00075	eb 07		 jmp	 SHORT $LN3@charLoginP
$LN6@charLoginP:

; 788  : #endif
; 789  : 				return -2;

  00077	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0007c	eb 2b		 jmp	 SHORT $LN1@charLoginP
$LN3@charLoginP:

; 790  : 	}
; 791  : 	SETTIMEOUT2(NET_ERRMSG_LOGINTIMEOUT);

  0007e	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00083	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?start_time@@3KA ; start_time
  00089	3d c0 27 09 00	 cmp	 eax, 600000		; 000927c0H
  0008e	76 17		 jbe	 SHORT $LN8@charLoginP
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFEMHLAM@?T?t?l?$PN?$DP?W?b?$DP?$DP?l?$KL?S?p?$KB?$KD?$AA@
  00095	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  0009a	e8 00 00 00 00	 call	 _sprintf
  0009f	83 c4 08	 add	 esp, 8
  000a2	83 c8 ff	 or	 eax, -1
  000a5	eb 02		 jmp	 SHORT $LN1@charLoginP
$LN8@charLoginP:

; 792  : 	return 0;

  000a7	33 c0		 xor	 eax, eax
$LN1@charLoginP:

; 793  : }

  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000b2	3b ec		 cmp	 ebp, esp
  000b4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
?charLoginProc@@YAHXZ ENDP				; charLoginProc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?charLoginStart@@YAXXZ
_TEXT	SEGMENT
?charLoginStart@@YAXXZ PROC				; charLoginStart, COMDAT

; 762  : void charLoginStart(void){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 763  : 	charLoginStatus = 0;

  0001e	33 c0		 xor	 eax, eax
  00020	66 a3 00 00 00
	00		 mov	 WORD PTR ?charLoginStatus@@3FA, ax ; charLoginStatus

; 764  : #ifdef _NEW_WGS_MSG				// WON ADD WGS的新视窗
; 765  : 	ERROR_MESSAGE = 0;

  00026	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ERROR_MESSAGE@@3HA, 0 ; ERROR_MESSAGE

; 766  : #endif
; 767  : 	if (bNewServer)

  00030	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bNewServer@@3HA, 0 ; bNewServer
  00037	74 15		 je	 SHORT $LN2@charLoginS

; 768  : 		lssproto_CharLogin_send(sockfd, gamestate_login_charname);

  00039	68 00 00 00 00	 push	 OFFSET ?gamestate_login_charname@@3PADA ; gamestate_login_charname
  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?lssproto_CharLogin_send@@YAXHPAD@Z ; lssproto_CharLogin_send
  00049	83 c4 08	 add	 esp, 8

; 769  : 	else

  0004c	eb 13		 jmp	 SHORT $LN3@charLoginS
$LN2@charLoginS:

; 770  : 		old_lssproto_CharLogin_send(sockfd, gamestate_login_charname);

  0004e	68 00 00 00 00	 push	 OFFSET ?gamestate_login_charname@@3PADA ; gamestate_login_charname
  00053	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?old_lssproto_CharLogin_send@@YAXHPAD@Z ; old_lssproto_CharLogin_send
  0005e	83 c4 08	 add	 esp, 8
$LN3@charLoginS:

; 771  : 	SETSENDING;

  00061	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 1 ; netproc_sending
  0006b	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00070	a3 00 00 00 00	 mov	 DWORD PTR ?start_time@@3KA, eax ; start_time

; 772  : }

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007e	3b ec		 cmp	 ebp, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?charLoginStart@@YAXXZ ENDP				; charLoginStart
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?charListProc@@YAHXZ
_TEXT	SEGMENT
?charListProc@@YAHXZ PROC				; charListProc, COMDAT

; 674  : int charListProc(void){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 675  : 	if (netproc_sending == NETPROC_RECEIVED){

  0001e	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?netproc_sending@@3HA, 2 ; netproc_sending
  00025	75 65		 jne	 SHORT $LN2@charListPr

; 676  : 		netproc_sending = NETPROC_NOTSEND;

  00027	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 0 ; netproc_sending

; 677  : 		if (charListStatus == 1)

  00031	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?charListStatus@@3FA ; charListStatus
  00038	83 f8 01	 cmp	 eax, 1
  0003b	75 09		 jne	 SHORT $LN3@charListPr

; 678  : 			return 1;

  0003d	b8 01 00 00 00	 mov	 eax, 1
  00042	eb 73		 jmp	 SHORT $LN1@charListPr
  00044	eb 46		 jmp	 SHORT $LN2@charListPr
$LN3@charListPr:

; 679  : 		else if (charListStatus == 2)

  00046	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?charListStatus@@3FA ; charListStatus
  0004d	83 f8 02	 cmp	 eax, 2
  00050	75 09		 jne	 SHORT $LN5@charListPr

; 680  : 			return -3;

  00052	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00057	eb 5e		 jmp	 SHORT $LN1@charListPr
  00059	eb 31		 jmp	 SHORT $LN2@charListPr
$LN5@charListPr:

; 681  : #ifdef _CHANGEGALAXY
; 682  : 		else if (charListStatus == 3)

  0005b	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?charListStatus@@3FA ; charListStatus
  00062	83 f8 03	 cmp	 eax, 3
  00065	75 09		 jne	 SHORT $LN7@charListPr

; 683  : 			return -12;

  00067	b8 f4 ff ff ff	 mov	 eax, -12		; fffffff4H
  0006c	eb 49		 jmp	 SHORT $LN1@charListPr
  0006e	eb 1c		 jmp	 SHORT $LN2@charListPr
$LN7@charListPr:

; 684  : #endif
; 685  : #ifdef _ERROR301
; 686  : 		else if (charListStatus == 4)

  00070	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?charListStatus@@3FA ; charListStatus
  00077	83 f8 04	 cmp	 eax, 4
  0007a	75 09		 jne	 SHORT $LN9@charListPr

; 687  : 			return -13;

  0007c	b8 f3 ff ff ff	 mov	 eax, -13		; fffffff3H
  00081	eb 34		 jmp	 SHORT $LN1@charListPr

; 688  : #endif
; 689  : 		else

  00083	eb 07		 jmp	 SHORT $LN2@charListPr
$LN9@charListPr:

; 690  : 			return -2;

  00085	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0008a	eb 2b		 jmp	 SHORT $LN1@charListPr
$LN2@charListPr:

; 691  : 	}
; 692  : 	SETTIMEOUT2(NET_ERRMSG_CHARLISTTIMEOUT);

  0008c	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00091	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?start_time@@3KA ; start_time
  00097	3d c0 27 09 00	 cmp	 eax, 600000		; 000927c0H
  0009c	76 17		 jbe	 SHORT $LN11@charListPr
  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OCCGLCLB@?$DP?v?$KC?l?Q?Z?$KK?x?z?$DP?$DP?l?$KL?S?p?$KB?$KD?$AA@
  000a3	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  000a8	e8 00 00 00 00	 call	 _sprintf
  000ad	83 c4 08	 add	 esp, 8
  000b0	83 c8 ff	 or	 eax, -1
  000b3	eb 02		 jmp	 SHORT $LN1@charListPr
$LN11@charListPr:

; 693  : 	return 0;

  000b5	33 c0		 xor	 eax, eax
$LN1@charListPr:

; 694  : }

  000b7	5f		 pop	 edi
  000b8	5e		 pop	 esi
  000b9	5b		 pop	 ebx
  000ba	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000c0	3b ec		 cmp	 ebp, esp
  000c2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
?charListProc@@YAHXZ ENDP				; charListProc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?charListStart@@YAXXZ
_TEXT	SEGMENT
_i$ = -8						; size = 4
?charListStart@@YAXXZ PROC				; charListStart, COMDAT

; 660  : void charListStart(void){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 661  : 	int i;
; 662  : 
; 663  : 	for (i = 0; i < MAXCHARACTER; i++)

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00025	eb 09		 jmp	 SHORT $LN4@charListSt
$LN2@charListSt:
  00027	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0002a	83 c0 01	 add	 eax, 1
  0002d	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@charListSt:
  00030	83 7d f8 02	 cmp	 DWORD PTR _i$[ebp], 2
  00034	7d 0e		 jge	 SHORT $LN3@charListSt

; 664  : 		resetCharacterList(i);

  00036	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?resetCharacterList@@YAHH@Z ; resetCharacterList
  0003f	83 c4 04	 add	 esp, 4
  00042	eb e3		 jmp	 SHORT $LN2@charListSt
$LN3@charListSt:

; 665  : 
; 666  : 	charListStatus = 0;

  00044	33 c0		 xor	 eax, eax
  00046	66 a3 00 00 00
	00		 mov	 WORD PTR ?charListStatus@@3FA, ax ; charListStatus

; 667  : 	if (bNewServer)

  0004c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bNewServer@@3HA, 0 ; bNewServer
  00053	74 10		 je	 SHORT $LN5@charListSt

; 668  : 		lssproto_CharList_send(sockfd);

  00055	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 ?lssproto_CharList_send@@YAXH@Z ; lssproto_CharList_send
  00060	83 c4 04	 add	 esp, 4

; 669  : 	else

  00063	eb 0e		 jmp	 SHORT $LN6@charListSt
$LN5@charListSt:

; 670  : 		old_lssproto_CharList_send(sockfd);

  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 ?old_lssproto_CharList_send@@YAXH@Z ; old_lssproto_CharList_send
  00070	83 c4 04	 add	 esp, 4
$LN6@charListSt:

; 671  : 	SETSENDING;

  00073	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 1 ; netproc_sending
  0007d	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00082	a3 00 00 00 00	 mov	 DWORD PTR ?start_time@@3KA, eax ; start_time

; 672  : }

  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00090	3b ec		 cmp	 ebp, esp
  00092	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
?charListStart@@YAXXZ ENDP				; charListStart
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?connectServer@@YAHXZ
_TEXT	SEGMENT
$T1 = -1708						; size = 4
_userPassword$2 = -1120					; size = 32
_userId$3 = -1080					; size = 32
_i_len$4 = -1040					; size = 4
_a$5 = -1028						; size = 4
_tm$6 = -1016						; size = 8
_efds$7 = -1000						; size = 260
_wfds$8 = -732						; size = 260
_rfds$9 = -464						; size = 260
_ret$10 = -196						; size = 4
_flag$11 = -184						; size = 4
_h$12 = -172						; size = 4
_flg$13 = -160						; size = 4
_pt$14 = -148						; size = 2
_hostname$15 = -136					; size = 128
__$ArrayPad$ = -4					; size = 4
?connectServer@@YAHXZ PROC				; connectServer, COMDAT

; 406  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b0 06 00
	00		 sub	 esp, 1712		; 000006b0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 50 f9 ff
	ff		 lea	 edi, DWORD PTR [ebp-1712]
  00012	b9 ac 01 00 00	 mov	 ecx, 428		; 000001acH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 407  : 	if (!init_net)

  00028	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?init_net@@3HA, 0 ; init_net
  0002f	75 07		 jne	 SHORT $LN11@connectSer

; 408  : 		return 0;

  00031	33 c0		 xor	 eax, eax
  00033	e9 e0 08 00 00	 jmp	 $LN55@connectSer
$LN11@connectSer:

; 409  : 	static int count = 0;
; 410  : 
; 411  : 	if (connectServerCounter == 0){

  00038	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?connectServerCounter@@3HA, 0 ; connectServerCounter
  0003f	0f 85 cd 02 00
	00		 jne	 $LN12@connectSer

; 412  : 		char hostname[128];
; 413  : 		short pt;
; 414  : 		unsigned long flg = 1;

  00045	c7 85 60 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _flg$13[ebp], 1

; 415  : 		struct hostent *h;
; 416  : 
; 417  : 		lstrcpy(PersonalKey, _DEFAULT_PKEY);

  0004f	8b f4		 mov	 esi, esp
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LCBBLLOI@www?493sa?4com?$AA@
  00056	68 00 00 00 00	 push	 OFFSET ?PersonalKey@@3PADA ; PersonalKey
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8
  00061	3b f4		 cmp	 esi, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 418  : 		//lstrcpy(PersonalKey, "forever");
; 419  : 		start_time = TimeGetTime();

  00068	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  0006d	a3 00 00 00 00	 mov	 DWORD PTR ?start_time@@3KA, eax ; start_time

; 420  : 		if (getServerInfo(selectServerIndex, hostname, &pt) < 0)

  00072	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR _pt$14[ebp]
  00078	50		 push	 eax
  00079	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _hostname$15[ebp]
  0007f	51		 push	 ecx
  00080	0f bf 15 00 00
	00 00		 movsx	 edx, WORD PTR ?selectServerIndex@@3FA ; selectServerIndex
  00087	52		 push	 edx
  00088	e8 00 00 00 00	 call	 ?getServerInfo@@YAHHPADPAF@Z ; getServerInfo
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00090	85 c0		 test	 eax, eax
  00092	7d 35		 jge	 SHORT $LN14@connectSer

; 421  : 		{
; 422  : 			count = 0;

  00094	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA, 0

; 423  : #ifdef _NB_断线自动重连
; 424  : 			PcLanded.登陆延时时间 = TimeGetTime() + 2000;

  0009e	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  000a3	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  000a8	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax

; 425  : #endif
; 426  : 			sprintf(netprocErrmsg, NET_ERRMSG_BADNAME);

  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KFDLBKA@?$NO?C?$NM?W?P?o?Y?$KD?$DP?$NM?t?o?a?$DP?$KB?$KD?$AA@
  000b2	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  000b7	e8 00 00 00 00	 call	 _sprintf
  000bc	83 c4 08	 add	 esp, 8

; 427  : 			return -2;

  000bf	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000c4	e9 4f 08 00 00	 jmp	 $LN55@connectSer
$LN14@connectSer:

; 428  : 		}
; 429  : 		sockfd = socket(AF_INET, SOCK_STREAM, 0);

  000c9	6a 00		 push	 0
  000cb	6a 01		 push	 1
  000cd	6a 02		 push	 2
  000cf	e8 00 00 00 00	 call	 _socket@12
  000d4	a3 00 00 00 00	 mov	 DWORD PTR ?sockfd@@3IA, eax ; sockfd

; 430  : 		if (sockfd == INVALID_SOCKET)

  000d9	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?sockfd@@3IA, -1 ; sockfd
  000e0	75 35		 jne	 SHORT $LN15@connectSer

; 431  : 		{
; 432  : 			count = 0;

  000e2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA, 0

; 433  : #ifdef _NB_断线自动重连
; 434  : 			PcLanded.登陆延时时间 = TimeGetTime() + 2000;

  000ec	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  000f1	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  000f6	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax

; 435  : #endif
; 436  : 			sprintf(netprocErrmsg, NET_ERRMSG_SOCKETERROR);

  000fb	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@JAKPHLLB@?Y?i?$NL?v?$DP?z?$LMsocket?n?$NMTCP?$KB?$KD?$AA@
  00100	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  00105	e8 00 00 00 00	 call	 _sprintf
  0010a	83 c4 08	 add	 esp, 8

; 437  : 			return -3;

  0010d	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00112	e9 01 08 00 00	 jmp	 $LN55@connectSer
$LN15@connectSer:

; 438  : 		}
; 439  : 		ioctlsocket(sockfd, FIONBIO, &flg);

  00117	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _flg$13[ebp]
  0011d	50		 push	 eax
  0011e	68 7e 66 04 80	 push	 -2147195266		; 8004667eH
  00123	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockfd@@3IA ; sockfd
  00129	51		 push	 ecx
  0012a	e8 00 00 00 00	 call	 _ioctlsocket@12

; 440  : 
; 441  : 		extern BOOL NoDelay;
; 442  : 		if (NoDelay)

  0012f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?NoDelay@@3HA, 0 ; NoDelay
  00136	74 3b		 je	 SHORT $LN16@connectSer

; 443  : 		{
; 444  : 			int flag = 1;

  00138	c7 85 48 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _flag$11[ebp], 1

; 445  : 
; 446  : 			if (setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, (char*)&flag, sizeof(int)) != 0)

  00142	6a 04		 push	 4
  00144	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR _flag$11[ebp]
  0014a	50		 push	 eax
  0014b	6a 01		 push	 1
  0014d	6a 06		 push	 6
  0014f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockfd@@3IA ; sockfd
  00155	51		 push	 ecx
  00156	e8 00 00 00 00	 call	 _setsockopt@20
  0015b	85 c0		 test	 eax, eax
  0015d	74 14		 je	 SHORT $LN16@connectSer

; 447  : 			{
; 448  : 				count = 0;

  0015f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA, 0

; 449  : 				return -100;

  00169	b8 9c ff ff ff	 mov	 eax, -100		; ffffff9cH
  0016e	e9 a5 07 00 00	 jmp	 $LN55@connectSer
$LN16@connectSer:

; 450  : 			}
; 451  : 		}
; 452  : 		ZeroMemory(&sin_server, sizeof(sin_server));

  00173	6a 10		 push	 16			; 00000010H
  00175	6a 00		 push	 0
  00177	68 00 00 00 00	 push	 OFFSET ?sin_server@@3Usockaddr_in@@A ; sin_server
  0017c	e8 00 00 00 00	 call	 _memset
  00181	83 c4 0c	 add	 esp, 12			; 0000000cH

; 453  : 		sin_server.sin_family = AF_INET;

  00184	b8 02 00 00 00	 mov	 eax, 2
  00189	66 a3 00 00 00
	00		 mov	 WORD PTR ?sin_server@@3Usockaddr_in@@A, ax

; 454  : 		sin_server.sin_port = htons(pt);

  0018f	0f b7 85 6c ff
	ff ff		 movzx	 eax, WORD PTR _pt$14[ebp]
  00196	50		 push	 eax
  00197	e8 00 00 00 00	 call	 _htons@4
  0019c	66 a3 02 00 00
	00		 mov	 WORD PTR ?sin_server@@3Usockaddr_in@@A+2, ax

; 455  : 		sin_server.sin_addr.s_addr = inet_addr(hostname);     /* accept only dot notaion  */

  001a2	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _hostname$15[ebp]
  001a8	50		 push	 eax
  001a9	e8 00 00 00 00	 call	 _inet_addr@4
  001ae	a3 04 00 00 00	 mov	 DWORD PTR ?sin_server@@3Usockaddr_in@@A+4, eax

; 456  : 		if (sin_server.sin_addr.s_addr == -1)

  001b3	83 3d 04 00 00
	00 ff		 cmp	 DWORD PTR ?sin_server@@3Usockaddr_in@@A+4, -1
  001ba	0f 85 90 00 00
	00		 jne	 $LN18@connectSer

; 457  : 		{
; 458  : 			h = gethostbyname(hostname);

  001c0	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _hostname$15[ebp]
  001c6	50		 push	 eax
  001c7	e8 00 00 00 00	 call	 _gethostbyname@4
  001cc	89 85 54 ff ff
	ff		 mov	 DWORD PTR _h$12[ebp], eax

; 459  : 			if (h == NULL)

  001d2	83 bd 54 ff ff
	ff 00		 cmp	 DWORD PTR _h$12[ebp], 0
  001d9	75 51		 jne	 SHORT $LN19@connectSer

; 460  : 			{
; 461  : 				count = 0;

  001db	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA, 0

; 462  : #ifdef _NB_断线自动重连
; 463  : 				PcLanded.登陆延时时间 = TimeGetTime() + 2000;

  001e5	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  001ea	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  001ef	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax

; 464  : #endif
; 465  : 				sprintf(netprocErrmsg, NET_ERRMSG_NOTGETADDR, hostname);

  001f4	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _hostname$15[ebp]
  001fa	50		 push	 eax
  001fb	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@BHPEJLIB@?Y?i?$NL?v?$DP?T?p?$NO?C?$NM?W?P?o?n?$NM?$KD?I?$KD?P?j?H?v?G?$KB?$KD?$CI?$CFs?$CJ?$AA@
  00200	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  00205	e8 00 00 00 00	 call	 _sprintf
  0020a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 466  : 				closesocket(sockfd); 

  0020d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  00212	50		 push	 eax
  00213	e8 00 00 00 00	 call	 _closesocket@4

; 467  : 				dwServer = NULL;

  00218	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 0 ; dwServer

; 468  : 				return -4;

  00222	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00227	e9 ec 06 00 00	 jmp	 $LN55@connectSer
$LN19@connectSer:

; 469  : 			}
; 470  : 			memcpy((void*)&sin_server.sin_addr.s_addr, h->h_addr, sizeof(struct in_addr));

  0022c	6a 04		 push	 4
  0022e	b8 04 00 00 00	 mov	 eax, 4
  00233	6b c8 00	 imul	 ecx, eax, 0
  00236	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _h$12[ebp]
  0023c	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0023f	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00242	51		 push	 ecx
  00243	68 04 00 00 00	 push	 OFFSET ?sin_server@@3Usockaddr_in@@A+4
  00248	e8 00 00 00 00	 call	 _memcpy
  0024d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@connectSer:

; 471  : 		}
; 472  : 		// Non blocking Connect
; 473  : 		int ret = connect(sockfd, (struct sockaddr*)&sin_server, sizeof(sin_server));

  00250	6a 10		 push	 16			; 00000010H
  00252	68 00 00 00 00	 push	 OFFSET ?sin_server@@3Usockaddr_in@@A ; sin_server
  00257	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  0025c	50		 push	 eax
  0025d	e8 00 00 00 00	 call	 _connect@12
  00262	89 85 3c ff ff
	ff		 mov	 DWORD PTR _ret$10[ebp], eax

; 474  : 		if (ret == SOCKET_ERROR)

  00268	83 bd 3c ff ff
	ff ff		 cmp	 DWORD PTR _ret$10[ebp], -1
  0026f	0f 85 98 00 00
	00		 jne	 $LN20@connectSer

; 475  : 		{
; 476  : 			if (WSAGetLastError() != WSAEWOULDBLOCK)

  00275	e8 00 00 00 00	 call	 _WSAGetLastError@0
  0027a	3d 33 27 00 00	 cmp	 eax, 10035		; 00002733H
  0027f	74 4a		 je	 SHORT $LN21@connectSer

; 477  : 			{
; 478  : 				count = 0;

  00281	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA, 0

; 479  : 				closesocket(sockfd);

  0028b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  00290	50		 push	 eax
  00291	e8 00 00 00 00	 call	 _closesocket@4

; 480  : 				dwServer = NULL;

  00296	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 0 ; dwServer

; 481  : #ifdef _NB_断线自动重连
; 482  : 				PcLanded.登陆延时时间 = TimeGetTime() + 2000;

  002a0	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  002a5	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  002aa	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax

; 483  : #endif
; 484  : 				sprintf(netprocErrmsg, NET_ERRMSG_NOTCONNECT_S);

  002af	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CKHMFIAG@?Y?i?$NL?v?$DP?c?$LH?$DP?z?$LM?$NO?C?$NM?W?P?o?n?$NM?$DP?o?H?$KB?$KD?$AA@
  002b4	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  002b9	e8 00 00 00 00	 call	 _sprintf
  002be	83 c4 08	 add	 esp, 8

; 485  : 				return -5;

  002c1	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  002c6	e9 4d 06 00 00	 jmp	 $LN55@connectSer
$LN21@connectSer:

; 486  : 			}
; 487  : 			connectServerCounter = 1;

  002cb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, 1 ; connectServerCounter

; 488  : 			c_temp[0] = 0;

  002d5	b8 01 00 00 00	 mov	 eax, 1
  002da	6b c8 00	 imul	 ecx, eax, 0
  002dd	89 8d 54 f9 ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  002e3	81 bd 54 f9 ff
	ff 00 04 00 00	 cmp	 DWORD PTR $T1[ebp], 1024 ; 00000400H
  002ed	73 02		 jae	 SHORT $LN56@connectSer
  002ef	eb 05		 jmp	 SHORT $LN57@connectSer
$LN56@connectSer:
  002f1	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN57@connectSer:
  002f6	8b 95 54 f9 ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  002fc	c6 82 00 00 00
	00 00		 mov	 BYTE PTR ?c_temp@@3PADA[edx], 0

; 489  : 			bNewServer = FALSE;

  00303	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bNewServer@@3HA, 0 ; bNewServer
$LN20@connectSer:

; 490  : 			/*sprintf(netprocErrmsg, NET_ERRMSG_NOTCONNECT);
; 491  : 			closesocket(sockfd);
; 492  : 			dwServer = NULL;
; 493  : 			return -6; */
; 494  : 		}

  0030d	e9 db 05 00 00	 jmp	 $LN13@connectSer
$LN12@connectSer:

; 495  : 	}else if (connectServerCounter >= 1 && connectServerCounter <= 70){

  00312	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?connectServerCounter@@3HA, 1 ; connectServerCounter
  00319	0f 8c 7b 03 00
	00		 jl	 $LN22@connectSer
  0031f	83 3d 00 00 00
	00 46		 cmp	 DWORD PTR ?connectServerCounter@@3HA, 70 ; connectServerCounter, 00000046H
  00326	0f 8f 6e 03 00
	00		 jg	 $LN22@connectSer

; 496  : 		fd_set rfds, wfds, efds;
; 497  : 		struct timeval tm;
; 498  : 
; 499  : 		connectServerCounter++;

  0032c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?connectServerCounter@@3HA ; connectServerCounter
  00331	83 c0 01	 add	 eax, 1
  00334	a3 00 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, eax ; connectServerCounter

; 500  : 		if (connectServerCounter == 70)

  00339	83 3d 00 00 00
	00 46		 cmp	 DWORD PTR ?connectServerCounter@@3HA, 70 ; connectServerCounter, 00000046H
  00340	75 0a		 jne	 SHORT $LN24@connectSer

; 501  : 			connectServerCounter = 69;

  00342	c7 05 00 00 00
	00 45 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, 69 ; connectServerCounter, 00000045H
$LN24@connectSer:

; 502  : 
; 503  : 		tm.tv_sec = 0;

  0034c	c7 85 08 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _tm$6[ebp], 0

; 504  : 		tm.tv_usec = 0;

  00356	c7 85 0c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _tm$6[ebp+4], 0

; 505  : 		FD_ZERO(&rfds);

  00360	c7 85 30 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _rfds$9[ebp], 0

; 506  : 		FD_ZERO(&wfds);

  0036a	c7 85 24 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _wfds$8[ebp], 0

; 507  : 		FD_ZERO(&efds);

  00374	c7 85 18 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _efds$7[ebp], 0
$LN4@connectSer:

; 508  : 		FD_SET(sockfd, &rfds);

  0037e	83 bd 30 fe ff
	ff 40		 cmp	 DWORD PTR _rfds$9[ebp], 64 ; 00000040H
  00385	73 22		 jae	 SHORT $LN2@connectSer
  00387	8b 85 30 fe ff
	ff		 mov	 eax, DWORD PTR _rfds$9[ebp]
  0038d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockfd@@3IA ; sockfd
  00393	89 8c 85 34 fe
	ff ff		 mov	 DWORD PTR _rfds$9[ebp+eax*4+4], ecx
  0039a	8b 95 30 fe ff
	ff		 mov	 edx, DWORD PTR _rfds$9[ebp]
  003a0	83 c2 01	 add	 edx, 1
  003a3	89 95 30 fe ff
	ff		 mov	 DWORD PTR _rfds$9[ebp], edx
$LN2@connectSer:
  003a9	33 c0		 xor	 eax, eax
  003ab	75 d1		 jne	 SHORT $LN4@connectSer
$LN7@connectSer:

; 509  : 		FD_SET(sockfd, &wfds);

  003ad	83 bd 24 fd ff
	ff 40		 cmp	 DWORD PTR _wfds$8[ebp], 64 ; 00000040H
  003b4	73 22		 jae	 SHORT $LN5@connectSer
  003b6	8b 85 24 fd ff
	ff		 mov	 eax, DWORD PTR _wfds$8[ebp]
  003bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockfd@@3IA ; sockfd
  003c2	89 8c 85 28 fd
	ff ff		 mov	 DWORD PTR _wfds$8[ebp+eax*4+4], ecx
  003c9	8b 95 24 fd ff
	ff		 mov	 edx, DWORD PTR _wfds$8[ebp]
  003cf	83 c2 01	 add	 edx, 1
  003d2	89 95 24 fd ff
	ff		 mov	 DWORD PTR _wfds$8[ebp], edx
$LN5@connectSer:
  003d8	33 c0		 xor	 eax, eax
  003da	75 d1		 jne	 SHORT $LN7@connectSer
$LN10@connectSer:

; 510  : 		FD_SET(sockfd, &efds);

  003dc	83 bd 18 fc ff
	ff 40		 cmp	 DWORD PTR _efds$7[ebp], 64 ; 00000040H
  003e3	73 22		 jae	 SHORT $LN8@connectSer
  003e5	8b 85 18 fc ff
	ff		 mov	 eax, DWORD PTR _efds$7[ebp]
  003eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockfd@@3IA ; sockfd
  003f1	89 8c 85 1c fc
	ff ff		 mov	 DWORD PTR _efds$7[ebp+eax*4+4], ecx
  003f8	8b 95 18 fc ff
	ff		 mov	 edx, DWORD PTR _efds$7[ebp]
  003fe	83 c2 01	 add	 edx, 1
  00401	89 95 18 fc ff
	ff		 mov	 DWORD PTR _efds$7[ebp], edx
$LN8@connectSer:
  00407	33 c0		 xor	 eax, eax
  00409	75 d1		 jne	 SHORT $LN10@connectSer

; 511  : 		int a = select(sockfd, &rfds, &wfds, &efds, &tm);

  0040b	8d 85 08 fc ff
	ff		 lea	 eax, DWORD PTR _tm$6[ebp]
  00411	50		 push	 eax
  00412	8d 8d 18 fc ff
	ff		 lea	 ecx, DWORD PTR _efds$7[ebp]
  00418	51		 push	 ecx
  00419	8d 95 24 fd ff
	ff		 lea	 edx, DWORD PTR _wfds$8[ebp]
  0041f	52		 push	 edx
  00420	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR _rfds$9[ebp]
  00426	50		 push	 eax
  00427	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockfd@@3IA ; sockfd
  0042d	51		 push	 ecx
  0042e	e8 00 00 00 00	 call	 _select@20
  00433	89 85 fc fb ff
	ff		 mov	 DWORD PTR _a$5[ebp], eax

; 512  : 		if (a > 0){

  00439	83 bd fc fb ff
	ff 00		 cmp	 DWORD PTR _a$5[ebp], 0
  00440	0f 8e ec 01 00
	00		 jle	 $LN28@connectSer

; 513  : 			if (FD_ISSET(sockfd, &rfds)){

  00446	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR _rfds$9[ebp]
  0044c	50		 push	 eax
  0044d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockfd@@3IA ; sockfd
  00453	51		 push	 ecx
  00454	e8 00 00 00 00	 call	 ___WSAFDIsSet@8
  00459	85 c0		 test	 eax, eax
  0045b	0f 84 6e 01 00
	00		 je	 $LN30@connectSer

; 514  : 				// Nuke start
; 515  : 				int i_len = recv(sockfd, c_temp, sizeof(c_temp) - 1, 0);

  00461	6a 00		 push	 0
  00463	68 ff 03 00 00	 push	 1023			; 000003ffH
  00468	68 00 00 00 00	 push	 OFFSET ?c_temp@@3PADA
  0046d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  00472	50		 push	 eax
  00473	e8 00 00 00 00	 call	 _recv@16
  00478	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _i_len$4[ebp], eax

; 516  : 				if (i_len > 0){

  0047e	83 bd f0 fb ff
	ff 00		 cmp	 DWORD PTR _i_len$4[ebp], 0
  00485	0f 8e fa 00 00
	00		 jle	 $LN31@connectSer

; 517  : 					
; 518  : 					if (c_temp[0] == 'E'){

  0048b	b8 01 00 00 00	 mov	 eax, 1
  00490	6b c8 00	 imul	 ecx, eax, 0
  00493	0f be 91 00 00
	00 00		 movsx	 edx, BYTE PTR ?c_temp@@3PADA[ecx]
  0049a	83 fa 45	 cmp	 edx, 69			; 00000045H
  0049d	75 4f		 jne	 SHORT $LN33@connectSer

; 519  : #ifdef _NB_断线自动重连
; 520  : 						PcLanded.登陆延时时间 = TimeGetTime() + 2000;

  0049f	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  004a4	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  004a9	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax

; 521  : #endif
; 522  : 						count = 0;

  004ae	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA, 0

; 523  : 						sprintf(netprocErrmsg, c_temp + 1);

  004b8	68 01 00 00 00	 push	 OFFSET ?c_temp@@3PADA+1
  004bd	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  004c2	e8 00 00 00 00	 call	 _sprintf
  004c7	83 c4 08	 add	 esp, 8

; 524  : 						closesocket(sockfd);

  004ca	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  004cf	50		 push	 eax
  004d0	e8 00 00 00 00	 call	 _closesocket@4

; 525  : 						dwServer = NULL;

  004d5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 0 ; dwServer

; 526  : 						return -6;

  004df	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  004e4	e9 2f 04 00 00	 jmp	 $LN55@connectSer
  004e9	e9 95 00 00 00	 jmp	 $LN34@connectSer
$LN33@connectSer:

; 527  : 					}else if (c_temp[0] == _SA_VERSION){

  004ee	b8 01 00 00 00	 mov	 eax, 1
  004f3	6b c8 00	 imul	 ecx, eax, 0
  004f6	0f be 91 00 00
	00 00		 movsx	 edx, BYTE PTR ?c_temp@@3PADA[ecx]
  004fd	83 fa 4c	 cmp	 edx, 76			; 0000004cH
  00500	75 37		 jne	 SHORT $LN35@connectSer

; 528  : 						bNewServer = 0xf000000 | 1;

  00502	c7 05 00 00 00
	00 01 00 00 0f	 mov	 DWORD PTR ?bNewServer@@3HA, 251658241 ; bNewServer, 0f000001H

; 529  : 						if (FD_ISSET(sockfd, &wfds)){

  0050c	8d 85 24 fd ff
	ff		 lea	 eax, DWORD PTR _wfds$8[ebp]
  00512	50		 push	 eax
  00513	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockfd@@3IA ; sockfd
  00519	51		 push	 ecx
  0051a	e8 00 00 00 00	 call	 ___WSAFDIsSet@8
  0051f	85 c0		 test	 eax, eax
  00521	74 14		 je	 SHORT $LN37@connectSer

; 530  : 							connectServerCounter = 71;					

  00523	c7 05 00 00 00
	00 47 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, 71 ; connectServerCounter, 00000047H

; 531  : 							server_choosed = 1;

  0052d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?server_choosed@@3HA, 1 ; server_choosed
$LN37@connectSer:

; 532  : 						}
; 533  : 					}else{

  00537	eb 4a		 jmp	 SHORT $LN34@connectSer
$LN35@connectSer:

; 534  : #ifdef _NB_断线自动重连
; 535  : 						PcLanded.登陆延时时间 = TimeGetTime() + 2000;

  00539	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  0053e	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  00543	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax

; 536  : #endif
; 537  : 						count = 0;

  00548	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA, 0

; 538  : 						sprintf(netprocErrmsg, NET_ERRMSG_VERSIONERROR);

  00552	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@NDJIOBBC@?$OA?$LE?P?o?$DP?S?$NL?w?z?$NM?b?$NM?t?T?R?$AA@
  00557	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  0055c	e8 00 00 00 00	 call	 _sprintf
  00561	83 c4 08	 add	 esp, 8

; 539  : 						closesocket(sockfd);

  00564	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  00569	50		 push	 eax
  0056a	e8 00 00 00 00	 call	 _closesocket@4

; 540  : 						dwServer = NULL;

  0056f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 0 ; dwServer

; 541  : 						return -8;

  00579	b8 f8 ff ff ff	 mov	 eax, -8			; fffffff8H
  0057e	e9 95 03 00 00	 jmp	 $LN55@connectSer
$LN34@connectSer:

; 542  : 					}
; 543  : 				}else{

  00583	eb 4a		 jmp	 SHORT $LN30@connectSer
$LN31@connectSer:

; 544  : #ifdef _NB_断线自动重连
; 545  : 					PcLanded.登陆延时时间 = TimeGetTime() + 2000;

  00585	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  0058a	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  0058f	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax

; 546  : #endif
; 547  : 					count = 0;

  00594	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA, 0

; 548  : 					sprintf(netprocErrmsg, NET_ERRMSG_NOTCONNECT);

  0059e	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KEAEOGKH@?$LN?$LK?E?f?$LP?$KB?$MA?L?A?v?5?G?O?$LE?C?$MA?$LK?5?G?v?$MA?g?5?A?$KB?$LA?K?5?A?$NP?$MA?T@
  005a3	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  005a8	e8 00 00 00 00	 call	 _sprintf
  005ad	83 c4 08	 add	 esp, 8

; 549  : 					closesocket(sockfd);

  005b0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  005b5	50		 push	 eax
  005b6	e8 00 00 00 00	 call	 _closesocket@4

; 550  : 					dwServer = NULL;

  005bb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 0 ; dwServer

; 551  : 					return -6; 

  005c5	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  005ca	e9 49 03 00 00	 jmp	 $LN55@connectSer
$LN30@connectSer:

; 552  : 				}
; 553  : 			}
; 554  : 			if (FD_ISSET(sockfd, &efds)){

  005cf	8d 85 18 fc ff
	ff		 lea	 eax, DWORD PTR _efds$7[ebp]
  005d5	50		 push	 eax
  005d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockfd@@3IA ; sockfd
  005dc	51		 push	 ecx
  005dd	e8 00 00 00 00	 call	 ___WSAFDIsSet@8
  005e2	85 c0		 test	 eax, eax
  005e4	74 4a		 je	 SHORT $LN38@connectSer

; 555  : #ifdef _NB_断线自动重连
; 556  : 				PcLanded.登陆延时时间 = TimeGetTime() + 2000;

  005e6	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  005eb	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  005f0	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax

; 557  : #endif
; 558  : 				count = 0;

  005f5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA, 0

; 559  : 				sprintf(netprocErrmsg, NET_ERRMSG_NOTCONNECT);

  005ff	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KEAEOGKH@?$LN?$LK?E?f?$LP?$KB?$MA?L?A?v?5?G?O?$LE?C?$MA?$LK?5?G?v?$MA?g?5?A?$KB?$LA?K?5?A?$NP?$MA?T@
  00604	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  00609	e8 00 00 00 00	 call	 _sprintf
  0060e	83 c4 08	 add	 esp, 8

; 560  : 				closesocket(sockfd);

  00611	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  00616	50		 push	 eax
  00617	e8 00 00 00 00	 call	 _closesocket@4

; 561  : 				dwServer = NULL;

  0061c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 0 ; dwServer

; 562  : 				return -6; 

  00626	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  0062b	e9 e8 02 00 00	 jmp	 $LN55@connectSer
$LN38@connectSer:

; 563  : 			}
; 564  : 		}else{

  00630	eb 63		 jmp	 SHORT $LN29@connectSer
$LN28@connectSer:

; 565  : 			count++;

  00632	a1 00 00 00 00	 mov	 eax, DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA
  00637	83 c0 01	 add	 eax, 1
  0063a	a3 00 00 00 00	 mov	 DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA, eax

; 566  : 			if(count >= 1500){

  0063f	81 3d 00 00 00
	00 dc 05 00 00	 cmp	 DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA, 1500 ; 000005dcH
  00649	7c 4a		 jl	 SHORT $LN29@connectSer

; 567  : #ifdef _NB_断线自动重连
; 568  : 				PcLanded.登陆延时时间 = TimeGetTime() + 2000;

  0064b	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00650	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  00655	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax

; 569  : #endif
; 570  : 				count = 0;

  0065a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA, 0

; 571  : 				sprintf(netprocErrmsg, NET_ERRMSG_NOTCONNECT);

  00664	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KEAEOGKH@?$LN?$LK?E?f?$LP?$KB?$MA?L?A?v?5?G?O?$LE?C?$MA?$LK?5?G?v?$MA?g?5?A?$KB?$LA?K?5?A?$NP?$MA?T@
  00669	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  0066e	e8 00 00 00 00	 call	 _sprintf
  00673	83 c4 08	 add	 esp, 8

; 572  : 				closesocket(sockfd);

  00676	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  0067b	50		 push	 eax
  0067c	e8 00 00 00 00	 call	 _closesocket@4

; 573  : 				dwServer = NULL;

  00681	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 0 ; dwServer

; 574  : 				return -6; 

  0068b	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  00690	e9 83 02 00 00	 jmp	 $LN55@connectSer
$LN29@connectSer:

; 575  : 			}
; 576  : 		}

  00695	e9 53 02 00 00	 jmp	 $LN13@connectSer
$LN22@connectSer:

; 577  : 	}else if (connectServerCounter >= 71 && connectServerCounter <= 80){

  0069a	83 3d 00 00 00
	00 47		 cmp	 DWORD PTR ?connectServerCounter@@3HA, 71 ; connectServerCounter, 00000047H
  006a1	0f 8c 0b 02 00
	00		 jl	 $LN40@connectSer
  006a7	83 3d 00 00 00
	00 50		 cmp	 DWORD PTR ?connectServerCounter@@3HA, 80 ; connectServerCounter, 00000050H
  006ae	0f 8f fe 01 00
	00		 jg	 $LN40@connectSer

; 578  : 		count = 0;

  006b4	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA, 0

; 579  : 		if (connectServerCounter == 71){

  006be	83 3d 00 00 00
	00 47		 cmp	 DWORD PTR ?connectServerCounter@@3HA, 71 ; connectServerCounter, 00000047H
  006c5	0f 85 51 01 00
	00		 jne	 $LN42@connectSer

; 580  : VMProtectBegin("login");

  006cb	8b f4		 mov	 esi, esp
  006cd	68 00 00 00 00	 push	 OFFSET ??_C@_05DAOAAINN@login?$AA@
  006d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VMProtectBegin@4
  006d8	3b f4		 cmp	 esi, esp
  006da	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 581  : 			char userId[32], userPassword[32];
; 582  : 
; 583  : 			clientLoginStatus = 0;

  006df	33 c0		 xor	 eax, eax
  006e1	66 a3 00 00 00
	00		 mov	 WORD PTR ?clientLoginStatus@@3FA, ax ; clientLoginStatus

; 584  : 			CopyMemory(userId, szUser, 32);

  006e7	6a 20		 push	 32			; 00000020H
  006e9	68 00 00 00 00	 push	 OFFSET ?szUser@@3PADA	; szUser
  006ee	8d 85 c8 fb ff
	ff		 lea	 eax, DWORD PTR _userId$3[ebp]
  006f4	50		 push	 eax
  006f5	e8 00 00 00 00	 call	 _memcpy
  006fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 585  : 			ecb_crypt("f;encor1c", userId, 32, DES_DECRYPT);

  006fd	6a 01		 push	 1
  006ff	6a 20		 push	 32			; 00000020H
  00701	8d 85 c8 fb ff
	ff		 lea	 eax, DWORD PTR _userId$3[ebp]
  00707	50		 push	 eax
  00708	68 00 00 00 00	 push	 OFFSET ??_C@_09BACHGGGK@f?$DLencor1c?$AA@
  0070d	e8 00 00 00 00	 call	 ?ecb_crypt@@YAHPAD0II@Z	; ecb_crypt
  00712	83 c4 10	 add	 esp, 16			; 00000010H

; 586  : 			CopyMemory(userPassword, szPassword, 32);

  00715	6a 20		 push	 32			; 00000020H
  00717	68 00 00 00 00	 push	 OFFSET ?szPassword@@3PADA ; szPassword
  0071c	8d 85 a0 fb ff
	ff		 lea	 eax, DWORD PTR _userPassword$2[ebp]
  00722	50		 push	 eax
  00723	e8 00 00 00 00	 call	 _memcpy
  00728	83 c4 0c	 add	 esp, 12			; 0000000cH

; 587  : 			ecb_crypt("f;encor1c", userPassword, 32, DES_DECRYPT);

  0072b	6a 01		 push	 1
  0072d	6a 20		 push	 32			; 00000020H
  0072f	8d 85 a0 fb ff
	ff		 lea	 eax, DWORD PTR _userPassword$2[ebp]
  00735	50		 push	 eax
  00736	68 00 00 00 00	 push	 OFFSET ??_C@_09BACHGGGK@f?$DLencor1c?$AA@
  0073b	e8 00 00 00 00	 call	 ?ecb_crypt@@YAHPAD0II@Z	; ecb_crypt
  00740	83 c4 10	 add	 esp, 16			; 00000010H

; 588  : 
; 589  : 			if (bNewServer)

  00743	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bNewServer@@3HA, 0 ; bNewServer
  0074a	74 1f		 je	 SHORT $LN43@connectSer

; 590  : 				lssproto_ClientLogin_send(sockfd, userId, userPassword);

  0074c	8d 85 a0 fb ff
	ff		 lea	 eax, DWORD PTR _userPassword$2[ebp]
  00752	50		 push	 eax
  00753	8d 8d c8 fb ff
	ff		 lea	 ecx, DWORD PTR _userId$3[ebp]
  00759	51		 push	 ecx
  0075a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?sockfd@@3IA ; sockfd
  00760	52		 push	 edx
  00761	e8 00 00 00 00	 call	 ?lssproto_ClientLogin_send@@YAXHPAD0@Z ; lssproto_ClientLogin_send
  00766	83 c4 0c	 add	 esp, 12			; 0000000cH

; 591  : 			else

  00769	eb 1d		 jmp	 SHORT $LN44@connectSer
$LN43@connectSer:

; 592  : 				old_lssproto_ClientLogin_send(sockfd, userId, userPassword);

  0076b	8d 85 a0 fb ff
	ff		 lea	 eax, DWORD PTR _userPassword$2[ebp]
  00771	50		 push	 eax
  00772	8d 8d c8 fb ff
	ff		 lea	 ecx, DWORD PTR _userId$3[ebp]
  00778	51		 push	 ecx
  00779	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?sockfd@@3IA ; sockfd
  0077f	52		 push	 edx
  00780	e8 00 00 00 00	 call	 ?old_lssproto_ClientLogin_send@@YAXHPAD0@Z ; old_lssproto_ClientLogin_send
  00785	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN44@connectSer:

; 593  : 
; 594  : 			//cary 2001 9 6
; 595  : 			if ((bNewServer & 0xf000000) == 0xf000000){

  00788	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bNewServer@@3HA ; bNewServer
  0078d	25 00 00 00 0f	 and	 eax, 251658240		; 0f000000H
  00792	3d 00 00 00 0f	 cmp	 eax, 251658240		; 0f000000H
  00797	75 36		 jne	 SHORT $LN45@connectSer

; 596  : 				lstrcpy(PersonalKey, userId);

  00799	8b f4		 mov	 esi, esp
  0079b	8d 85 c8 fb ff
	ff		 lea	 eax, DWORD PTR _userId$3[ebp]
  007a1	50		 push	 eax
  007a2	68 00 00 00 00	 push	 OFFSET ?PersonalKey@@3PADA ; PersonalKey
  007a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8
  007ad	3b f4		 cmp	 esi, esp
  007af	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 597  : 				lstrcat(PersonalKey, _RUNNING_KEY);

  007b4	8b f4		 mov	 esi, esp
  007b6	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LCBBLLOI@www?493sa?4com?$AA@
  007bb	68 00 00 00 00	 push	 OFFSET ?PersonalKey@@3PADA ; PersonalKey
  007c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcatA@8
  007c6	3b f4		 cmp	 esi, esp
  007c8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 598  : 			}else{

  007cd	eb 34		 jmp	 SHORT $LN46@connectSer
$LN45@connectSer:

; 599  : 				lstrcpy(PersonalKey, userId);

  007cf	8b f4		 mov	 esi, esp
  007d1	8d 85 c8 fb ff
	ff		 lea	 eax, DWORD PTR _userId$3[ebp]
  007d7	50		 push	 eax
  007d8	68 00 00 00 00	 push	 OFFSET ?PersonalKey@@3PADA ; PersonalKey
  007dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8
  007e3	3b f4		 cmp	 esi, esp
  007e5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 600  : 				lstrcat(PersonalKey, "19761101");

  007ea	8b f4		 mov	 esi, esp
  007ec	68 00 00 00 00	 push	 OFFSET ??_C@_08DDDJOECK@19761101?$AA@
  007f1	68 00 00 00 00	 push	 OFFSET ?PersonalKey@@3PADA ; PersonalKey
  007f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcatA@8
  007fc	3b f4		 cmp	 esi, esp
  007fe	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN46@connectSer:

; 601  : 			}
; 602  : 			netproc_sending = NETPROC_SENDING;

  00803	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 1 ; netproc_sending

; 603  : VMProtectEnd();

  0080d	8b f4		 mov	 esi, esp
  0080f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VMProtectEnd@0
  00815	3b f4		 cmp	 esi, esp
  00817	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN42@connectSer:

; 604  : 		}
; 605  : 		if (netproc_sending == NETPROC_RECEIVED){

  0081c	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?netproc_sending@@3HA, 2 ; netproc_sending
  00823	75 6b		 jne	 SHORT $LN47@connectSer

; 606  : 			if (clientLoginStatus)

  00825	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?clientLoginStatus@@3FA ; clientLoginStatus
  0082c	85 c0		 test	 eax, eax
  0082e	74 0c		 je	 SHORT $LN48@connectSer

; 607  : 				connectServerCounter = 81;

  00830	c7 05 00 00 00
	00 51 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, 81 ; connectServerCounter, 00000051H

; 608  : 			else{

  0083a	eb 54		 jmp	 SHORT $LN47@connectSer
$LN48@connectSer:

; 609  : #ifdef _NB_断线自动重连
; 610  : 				PcLanded.登陆延时时间 = TimeGetTime() + 2000;

  0083c	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00841	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  00846	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax

; 611  : #endif
; 612  : 				count = 0;

  0084b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?count@?1??connectServer@@YAHXZ@4HA, 0

; 613  : 				netproc_sending = NETPROC_NOTSEND;

  00855	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 0 ; netproc_sending

; 614  : #ifdef _NB_登录错误信息提示
; 615  : 				sprintf(netprocErrmsg, 登录错误提示);

  0085f	68 00 00 00 00	 push	 OFFSET ?登录错误提示@@3PADA ; 登录错误提示
  00864	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  00869	e8 00 00 00 00	 call	 _sprintf
  0086e	83 c4 08	 add	 esp, 8

; 616  : #else
; 617  : 				sprintf(netprocErrmsg, NET_ERRMSG_LOGINFAIL);
; 618  : #endif
; 619  : 				closesocket(sockfd);

  00871	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  00876	50		 push	 eax
  00877	e8 00 00 00 00	 call	 _closesocket@4

; 620  : 				dwServer = NULL;

  0087c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 0 ; dwServer

; 621  : 				return -7;

  00886	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  0088b	e9 88 00 00 00	 jmp	 $LN55@connectSer
$LN47@connectSer:

; 622  : 			}
; 623  : 		}
; 624  : 		connectServerCounter++;

  00890	a1 00 00 00 00	 mov	 eax, DWORD PTR ?connectServerCounter@@3HA ; connectServerCounter
  00895	83 c0 01	 add	 eax, 1
  00898	a3 00 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, eax ; connectServerCounter

; 625  : 		if (connectServerCounter == 81)

  0089d	83 3d 00 00 00
	00 51		 cmp	 DWORD PTR ?connectServerCounter@@3HA, 81 ; connectServerCounter, 00000051H
  008a4	75 0a		 jne	 SHORT $LN50@connectSer

; 626  : 			connectServerCounter = 80;

  008a6	c7 05 00 00 00
	00 50 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, 80 ; connectServerCounter, 00000050H
$LN50@connectSer:

; 627  : 	}

  008b0	eb 3b		 jmp	 SHORT $LN13@connectSer
$LN40@connectSer:

; 628  : 	else if (connectServerCounter >= 81 && connectServerCounter <= 98)

  008b2	83 3d 00 00 00
	00 51		 cmp	 DWORD PTR ?connectServerCounter@@3HA, 81 ; connectServerCounter, 00000051H
  008b9	7c 18		 jl	 SHORT $LN51@connectSer
  008bb	83 3d 00 00 00
	00 62		 cmp	 DWORD PTR ?connectServerCounter@@3HA, 98 ; connectServerCounter, 00000062H
  008c2	7f 0f		 jg	 SHORT $LN51@connectSer

; 629  : 		connectServerCounter ++;

  008c4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?connectServerCounter@@3HA ; connectServerCounter
  008c9	83 c0 01	 add	 eax, 1
  008cc	a3 00 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, eax ; connectServerCounter
  008d1	eb 1a		 jmp	 SHORT $LN13@connectSer
$LN51@connectSer:

; 630  : 	else if (connectServerCounter == 99){

  008d3	83 3d 00 00 00
	00 63		 cmp	 DWORD PTR ?connectServerCounter@@3HA, 99 ; connectServerCounter, 00000063H
  008da	75 11		 jne	 SHORT $LN13@connectSer

; 631  : 		netproc_sending = NETPROC_NOTSEND;

  008dc	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?netproc_sending@@3HA, 0 ; netproc_sending

; 632  : 		return 1;

  008e6	b8 01 00 00 00	 mov	 eax, 1
  008eb	eb 2b		 jmp	 SHORT $LN55@connectSer
$LN13@connectSer:

; 633  : 	}
; 634  : 	SETTIMEOUT2(NET_ERRMSG_CONNECTTIMEOUT);

  008ed	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  008f2	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?start_time@@3KA ; start_time
  008f8	3d c0 27 09 00	 cmp	 eax, 600000		; 000927c0H
  008fd	76 17		 jbe	 SHORT $LN54@connectSer
  008ff	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@PMNBOGBM@?$NO?C?$NM?W?P?o?$DP?o?H?$DP?$DP?l?$KL?S?p?$KB?$KD?$AA@
  00904	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  00909	e8 00 00 00 00	 call	 _sprintf
  0090e	83 c4 08	 add	 esp, 8
  00911	83 c8 ff	 or	 eax, -1
  00914	eb 02		 jmp	 SHORT $LN55@connectSer
$LN54@connectSer:

; 635  : 	return 0;

  00916	33 c0		 xor	 eax, eax
$LN55@connectSer:

; 636  : }

  00918	52		 push	 edx
  00919	8b cd		 mov	 ecx, ebp
  0091b	50		 push	 eax
  0091c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN69@connectSer
  00922	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00927	58		 pop	 eax
  00928	5a		 pop	 edx
  00929	5f		 pop	 edi
  0092a	5e		 pop	 esi
  0092b	5b		 pop	 ebx
  0092c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0092f	33 cd		 xor	 ecx, ebp
  00931	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00936	81 c4 b0 06 00
	00		 add	 esp, 1712		; 000006b0H
  0093c	3b ec		 cmp	 ebp, esp
  0093e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00943	8b e5		 mov	 esp, ebp
  00945	5d		 pop	 ebp
  00946	c3		 ret	 0
  00947	90		 npad	 1
$LN69@connectSer:
  00948	0a 00 00 00	 DD	 10			; 0000000aH
  0094c	00 00 00 00	 DD	 $LN68@connectSer
$LN68@connectSer:
  00950	78 ff ff ff	 DD	 -136			; ffffff78H
  00954	80 00 00 00	 DD	 128			; 00000080H
  00958	00 00 00 00	 DD	 $LN58@connectSer
  0095c	6c ff ff ff	 DD	 -148			; ffffff6cH
  00960	02 00 00 00	 DD	 2
  00964	00 00 00 00	 DD	 $LN59@connectSer
  00968	60 ff ff ff	 DD	 -160			; ffffff60H
  0096c	04 00 00 00	 DD	 4
  00970	00 00 00 00	 DD	 $LN60@connectSer
  00974	48 ff ff ff	 DD	 -184			; ffffff48H
  00978	04 00 00 00	 DD	 4
  0097c	00 00 00 00	 DD	 $LN61@connectSer
  00980	30 fe ff ff	 DD	 -464			; fffffe30H
  00984	04 01 00 00	 DD	 260			; 00000104H
  00988	00 00 00 00	 DD	 $LN62@connectSer
  0098c	24 fd ff ff	 DD	 -732			; fffffd24H
  00990	04 01 00 00	 DD	 260			; 00000104H
  00994	00 00 00 00	 DD	 $LN63@connectSer
  00998	18 fc ff ff	 DD	 -1000			; fffffc18H
  0099c	04 01 00 00	 DD	 260			; 00000104H
  009a0	00 00 00 00	 DD	 $LN64@connectSer
  009a4	08 fc ff ff	 DD	 -1016			; fffffc08H
  009a8	08 00 00 00	 DD	 8
  009ac	00 00 00 00	 DD	 $LN65@connectSer
  009b0	c8 fb ff ff	 DD	 -1080			; fffffbc8H
  009b4	20 00 00 00	 DD	 32			; 00000020H
  009b8	00 00 00 00	 DD	 $LN66@connectSer
  009bc	a0 fb ff ff	 DD	 -1120			; fffffba0H
  009c0	20 00 00 00	 DD	 32			; 00000020H
  009c4	00 00 00 00	 DD	 $LN67@connectSer
$LN67@connectSer:
  009c8	75		 DB	 117			; 00000075H
  009c9	73		 DB	 115			; 00000073H
  009ca	65		 DB	 101			; 00000065H
  009cb	72		 DB	 114			; 00000072H
  009cc	50		 DB	 80			; 00000050H
  009cd	61		 DB	 97			; 00000061H
  009ce	73		 DB	 115			; 00000073H
  009cf	73		 DB	 115			; 00000073H
  009d0	77		 DB	 119			; 00000077H
  009d1	6f		 DB	 111			; 0000006fH
  009d2	72		 DB	 114			; 00000072H
  009d3	64		 DB	 100			; 00000064H
  009d4	00		 DB	 0
$LN66@connectSer:
  009d5	75		 DB	 117			; 00000075H
  009d6	73		 DB	 115			; 00000073H
  009d7	65		 DB	 101			; 00000065H
  009d8	72		 DB	 114			; 00000072H
  009d9	49		 DB	 73			; 00000049H
  009da	64		 DB	 100			; 00000064H
  009db	00		 DB	 0
$LN65@connectSer:
  009dc	74		 DB	 116			; 00000074H
  009dd	6d		 DB	 109			; 0000006dH
  009de	00		 DB	 0
$LN64@connectSer:
  009df	65		 DB	 101			; 00000065H
  009e0	66		 DB	 102			; 00000066H
  009e1	64		 DB	 100			; 00000064H
  009e2	73		 DB	 115			; 00000073H
  009e3	00		 DB	 0
$LN63@connectSer:
  009e4	77		 DB	 119			; 00000077H
  009e5	66		 DB	 102			; 00000066H
  009e6	64		 DB	 100			; 00000064H
  009e7	73		 DB	 115			; 00000073H
  009e8	00		 DB	 0
$LN62@connectSer:
  009e9	72		 DB	 114			; 00000072H
  009ea	66		 DB	 102			; 00000066H
  009eb	64		 DB	 100			; 00000064H
  009ec	73		 DB	 115			; 00000073H
  009ed	00		 DB	 0
$LN61@connectSer:
  009ee	66		 DB	 102			; 00000066H
  009ef	6c		 DB	 108			; 0000006cH
  009f0	61		 DB	 97			; 00000061H
  009f1	67		 DB	 103			; 00000067H
  009f2	00		 DB	 0
$LN60@connectSer:
  009f3	66		 DB	 102			; 00000066H
  009f4	6c		 DB	 108			; 0000006cH
  009f5	67		 DB	 103			; 00000067H
  009f6	00		 DB	 0
$LN59@connectSer:
  009f7	70		 DB	 112			; 00000070H
  009f8	74		 DB	 116			; 00000074H
  009f9	00		 DB	 0
$LN58@connectSer:
  009fa	68		 DB	 104			; 00000068H
  009fb	6f		 DB	 111			; 0000006fH
  009fc	73		 DB	 115			; 00000073H
  009fd	74		 DB	 116			; 00000074H
  009fe	6e		 DB	 110			; 0000006eH
  009ff	61		 DB	 97			; 00000061H
  00a00	6d		 DB	 109			; 0000006dH
  00a01	65		 DB	 101			; 00000065H
  00a02	00		 DB	 0
?connectServer@@YAHXZ ENDP				; connectServer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?ConnectWGS@@YAHXZ
_TEXT	SEGMENT
_a$1 = -1808						; size = 4
_tm$2 = -1796						; size = 8
_efds$3 = -1780						; size = 260
_wfds$4 = -1512						; size = 260
_rfds$5 = -1244						; size = 260
_ret$6 = -976						; size = 4
_h$7 = -964						; size = 4
_sin$8 = -952						; size = 16
_flg$9 = -928						; size = 4
_a$10 = -916						; size = 4
_tm$11 = -904						; size = 8
_efds$12 = -888						; size = 260
_wfds$13 = -620						; size = 260
_rfds$14 = -352						; size = 260
_ret$15 = -84						; size = 4
_h$16 = -72						; size = 4
_sin$17 = -60						; size = 16
_flg$18 = -36						; size = 4
_lpstr$19 = -24						; size = 4
_hFileMapping$20 = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
?ConnectWGS@@YAHXZ PROC					; ConnectWGS, COMDAT

; 174  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 0a 00
	00		 sub	 esp, 2580		; 00000a14H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd ec f5 ff
	ff		 lea	 edi, DWORD PTR [ebp-2580]
  00012	b9 85 02 00 00	 mov	 ecx, 645		; 00000285H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 175  : 	if (connectServerCounter == 0)

  00028	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?connectServerCounter@@3HA, 0 ; connectServerCounter
  0002f	0f 85 f8 01 00
	00		 jne	 $LN20@ConnectWGS

; 176  : 	{
; 177  : 		HANDLE hFileMapping = NULL;

  00035	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hFileMapping$20[ebp], 0

; 178  : 		LPSTR lpstr = NULL;

  0003c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _lpstr$19[ebp], 0

; 179  : 
; 180  : 		cleanupNetwork();

  00043	e8 00 00 00 00	 call	 ?cleanupNetwork@@YAXXZ	; cleanupNetwork

; 181  : 		if (initNet())

  00048	e8 00 00 00 00	 call	 ?initNet@@YAHXZ		; initNet
  0004d	85 c0		 test	 eax, eax
  0004f	0f 84 aa 01 00
	00		 je	 $LN22@ConnectWGS

; 182  : 		{
; 183  : 			unsigned long flg = 1;

  00055	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _flg$18[ebp], 1

; 184  : 			struct sockaddr_in sin;
; 185  : 			struct hostent *h;
; 186  : 
; 187  : 			iWGS = 0;

  0005c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?iWGS@@3HA, 0	; iWGS

; 188  : 			iEncrypt = E_INIT;

  00066	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?iEncrypt@@3HA, 0 ; iEncrypt

; 189  : 			start_time = TimeGetTime();

  00070	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00075	a3 00 00 00 00	 mov	 DWORD PTR ?start_time@@3KA, eax ; start_time

; 190  : 			if (INVALID_SOCKET == (sockfd = socket(AF_INET, SOCK_STREAM, 0)))

  0007a	6a 00		 push	 0
  0007c	6a 01		 push	 1
  0007e	6a 02		 push	 2
  00080	e8 00 00 00 00	 call	 _socket@12
  00085	a3 00 00 00 00	 mov	 DWORD PTR ?sockfd@@3IA, eax ; sockfd
  0008a	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?sockfd@@3IA, -1 ; sockfd
  00091	75 2b		 jne	 SHORT $LN24@ConnectWGS

; 191  : 			{
; 192  : #ifdef _NB_断线自动重连
; 193  : 				PcLanded.登陆延时时间 = TimeGetTime() + 2000;

  00093	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00098	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  0009d	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax

; 194  : #endif
; 195  : 				sprintf(netprocErrmsg, NET_ERRMSG_SOCKETERROR);

  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@JAKPHLLB@?Y?i?$NL?v?$DP?z?$LMsocket?n?$NMTCP?$KB?$KD?$AA@
  000a7	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  000ac	e8 00 00 00 00	 call	 _sprintf
  000b1	83 c4 08	 add	 esp, 8

; 196  : 				return -3;

  000b4	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  000b9	e9 95 07 00 00	 jmp	 $LN1@ConnectWGS
$LN24@ConnectWGS:

; 197  : 			}
; 198  : 			ioctlsocket(sockfd, FIONBIO, &flg);

  000be	8d 45 dc	 lea	 eax, DWORD PTR _flg$18[ebp]
  000c1	50		 push	 eax
  000c2	68 7e 66 04 80	 push	 -2147195266		; 8004667eH
  000c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockfd@@3IA ; sockfd
  000cd	51		 push	 ecx
  000ce	e8 00 00 00 00	 call	 _ioctlsocket@12

; 199  : 			sin.sin_family = AF_INET;

  000d3	b8 02 00 00 00	 mov	 eax, 2
  000d8	66 89 45 c4	 mov	 WORD PTR _sin$17[ebp], ax

; 200  : 			sin.sin_port = htons(wWGS);

  000dc	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?wWGS@@3GA ; wWGS
  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 _htons@4
  000e9	66 89 45 c6	 mov	 WORD PTR _sin$17[ebp+2], ax

; 201  : 			sin.sin_addr.s_addr = inet_addr(szWGS);

  000ed	68 00 00 00 00	 push	 OFFSET ?szWGS@@3PADA	; szWGS
  000f2	e8 00 00 00 00	 call	 _inet_addr@4
  000f7	89 45 c8	 mov	 DWORD PTR _sin$17[ebp+4], eax

; 202  : 			if (sin.sin_addr.s_addr == -1)

  000fa	83 7d c8 ff	 cmp	 DWORD PTR _sin$17[ebp+4], -1
  000fe	75 78		 jne	 SHORT $LN25@ConnectWGS

; 203  : 			{
; 204  : 				if (!(h = gethostbyname(szWGS)))

  00100	68 00 00 00 00	 push	 OFFSET ?szWGS@@3PADA	; szWGS
  00105	e8 00 00 00 00	 call	 _gethostbyname@4
  0010a	89 45 b8	 mov	 DWORD PTR _h$16[ebp], eax
  0010d	83 7d b8 00	 cmp	 DWORD PTR _h$16[ebp], 0
  00111	75 45		 jne	 SHORT $LN26@ConnectWGS

; 205  : 				{
; 206  : #ifdef _NB_断线自动重连
; 207  : 					PcLanded.登陆延时时间 = TimeGetTime() + 2000;

  00113	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00118	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  0011d	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax

; 208  : #endif
; 209  : 					sprintf(netprocErrmsg, NET_ERRMSG_NOTGETADDR, "WGS");

  00122	68 00 00 00 00	 push	 OFFSET ??_C@_03GMCCICCK@WGS?$AA@
  00127	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@BHPEJLIB@?Y?i?$NL?v?$DP?T?p?$NO?C?$NM?W?P?o?n?$NM?$KD?I?$KD?P?j?H?v?G?$KB?$KD?$CI?$CFs?$CJ?$AA@
  0012c	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  00131	e8 00 00 00 00	 call	 _sprintf
  00136	83 c4 0c	 add	 esp, 12			; 0000000cH

; 210  : 					closesocket(sockfd);

  00139	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  0013e	50		 push	 eax
  0013f	e8 00 00 00 00	 call	 _closesocket@4

; 211  : 					dwServer = NULL;

  00144	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 0 ; dwServer

; 212  : 					return -4;

  0014e	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00153	e9 fb 06 00 00	 jmp	 $LN1@ConnectWGS
$LN26@ConnectWGS:

; 213  : 				}
; 214  : 				memcpy((void*)&sin.sin_addr.s_addr, h->h_addr, sizeof(struct in_addr));

  00158	6a 04		 push	 4
  0015a	b8 04 00 00 00	 mov	 eax, 4
  0015f	6b c8 00	 imul	 ecx, eax, 0
  00162	8b 55 b8	 mov	 edx, DWORD PTR _h$16[ebp]
  00165	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00168	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0016b	51		 push	 ecx
  0016c	8d 55 c8	 lea	 edx, DWORD PTR _sin$17[ebp+4]
  0016f	52		 push	 edx
  00170	e8 00 00 00 00	 call	 _memcpy
  00175	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN25@ConnectWGS:

; 215  : 			}
; 216  : 			int ret = connect(sockfd, (struct sockaddr*)&sin, sizeof(sin));

  00178	6a 10		 push	 16			; 00000010H
  0017a	8d 45 c4	 lea	 eax, DWORD PTR _sin$17[ebp]
  0017d	50		 push	 eax
  0017e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockfd@@3IA ; sockfd
  00184	51		 push	 ecx
  00185	e8 00 00 00 00	 call	 _connect@12
  0018a	89 45 ac	 mov	 DWORD PTR _ret$15[ebp], eax

; 217  : 			if (ret == SOCKET_ERROR)

  0018d	83 7d ac ff	 cmp	 DWORD PTR _ret$15[ebp], -1
  00191	75 4c		 jne	 SHORT $LN27@ConnectWGS

; 218  : 			{
; 219  : 				if (WSAGetLastError() != WSAEWOULDBLOCK)

  00193	e8 00 00 00 00	 call	 _WSAGetLastError@0
  00198	3d 33 27 00 00	 cmp	 eax, 10035		; 00002733H
  0019d	74 40		 je	 SHORT $LN27@ConnectWGS

; 220  : 				{
; 221  : 					closesocket(sockfd);

  0019f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  001a4	50		 push	 eax
  001a5	e8 00 00 00 00	 call	 _closesocket@4

; 222  : 					dwServer = NULL;

  001aa	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 0 ; dwServer

; 223  : #ifdef _NB_断线自动重连
; 224  : 					PcLanded.登陆延时时间 = TimeGetTime() + 2000;

  001b4	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  001b9	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  001be	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax

; 225  : #endif
; 226  : 					sprintf(netprocErrmsg, NET_ERRMSG_NOTCONNECT_S);

  001c3	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CKHMFIAG@?Y?i?$NL?v?$DP?c?$LH?$DP?z?$LM?$NO?C?$NM?W?P?o?n?$NM?$DP?o?H?$KB?$KD?$AA@
  001c8	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  001cd	e8 00 00 00 00	 call	 _sprintf
  001d2	83 c4 08	 add	 esp, 8

; 227  : 					return -5;

  001d5	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  001da	e9 74 06 00 00	 jmp	 $LN1@ConnectWGS
$LN27@ConnectWGS:

; 228  : 				}
; 229  : 			}
; 230  : 			dwServer = WGS;

  001df	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 1 ; dwServer

; 231  : 			iWGS = 1;

  001e9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?iWGS@@3HA, 1	; iWGS

; 232  : 			connectServerCounter = 1;

  001f3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, 1 ; connectServerCounter

; 233  : 		}
; 234  : 		else

  001fd	eb 29		 jmp	 SHORT $LN23@ConnectWGS
$LN22@ConnectWGS:

; 235  : 		{
; 236  : #ifdef _NB_断线自动重连
; 237  : 			PcLanded.登陆延时时间 = TimeGetTime() + 2000;

  001ff	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00204	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  00209	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax

; 238  : #endif
; 239  : 			strcpy(netprocErrmsg, NET_ERRMSG_SOCKLIBERROR);

  0020e	68 00 00 00 00	 push	 OFFSET ??_C@_0O@KDOBPHMN@?$DP?V?X?$DP?Z?$LB?q?W?$DP?$PL?$LP?$KB?$KD?$AA@
  00213	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  00218	e8 00 00 00 00	 call	 _strcpy
  0021d	83 c4 08	 add	 esp, 8

; 240  : 			return -1;

  00220	83 c8 ff	 or	 eax, -1
  00223	e9 2b 06 00 00	 jmp	 $LN1@ConnectWGS
$LN23@ConnectWGS:

; 241  : 		}

  00228	e9 eb 05 00 00	 jmp	 $LN21@ConnectWGS
$LN20@ConnectWGS:

; 242  : 	}else if (connectServerCounter >= 1 && connectServerCounter <= 70){

  0022d	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?connectServerCounter@@3HA, 1 ; connectServerCounter
  00234	0f 8c 9c 01 00
	00		 jl	 $LN29@ConnectWGS
  0023a	83 3d 00 00 00
	00 46		 cmp	 DWORD PTR ?connectServerCounter@@3HA, 70 ; connectServerCounter, 00000046H
  00241	0f 8f 8f 01 00
	00		 jg	 $LN29@ConnectWGS

; 243  : 		fd_set rfds, wfds, efds;
; 244  : 		struct timeval tm;
; 245  : 
; 246  : 		if (++connectServerCounter == 70)

  00247	a1 00 00 00 00	 mov	 eax, DWORD PTR ?connectServerCounter@@3HA ; connectServerCounter
  0024c	83 c0 01	 add	 eax, 1
  0024f	a3 00 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, eax ; connectServerCounter
  00254	83 3d 00 00 00
	00 46		 cmp	 DWORD PTR ?connectServerCounter@@3HA, 70 ; connectServerCounter, 00000046H
  0025b	75 0a		 jne	 SHORT $LN31@ConnectWGS

; 247  : 			connectServerCounter = 69;

  0025d	c7 05 00 00 00
	00 45 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, 69 ; connectServerCounter, 00000045H
$LN31@ConnectWGS:

; 248  : 		tm.tv_sec = 0;

  00267	c7 85 78 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _tm$11[ebp], 0

; 249  : 		tm.tv_usec = 0;

  00271	c7 85 7c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _tm$11[ebp+4], 0

; 250  : 		FD_ZERO(&rfds);

  0027b	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _rfds$14[ebp], 0

; 251  : 		FD_ZERO(&wfds);

  00285	c7 85 94 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _wfds$13[ebp], 0

; 252  : 		FD_ZERO(&efds);

  0028f	c7 85 88 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _efds$12[ebp], 0
$LN4@ConnectWGS:

; 253  : 		FD_SET(sockfd, &rfds);

  00299	83 bd a0 fe ff
	ff 40		 cmp	 DWORD PTR _rfds$14[ebp], 64 ; 00000040H
  002a0	73 22		 jae	 SHORT $LN2@ConnectWGS
  002a2	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _rfds$14[ebp]
  002a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockfd@@3IA ; sockfd
  002ae	89 8c 85 a4 fe
	ff ff		 mov	 DWORD PTR _rfds$14[ebp+eax*4+4], ecx
  002b5	8b 95 a0 fe ff
	ff		 mov	 edx, DWORD PTR _rfds$14[ebp]
  002bb	83 c2 01	 add	 edx, 1
  002be	89 95 a0 fe ff
	ff		 mov	 DWORD PTR _rfds$14[ebp], edx
$LN2@ConnectWGS:
  002c4	33 c0		 xor	 eax, eax
  002c6	75 d1		 jne	 SHORT $LN4@ConnectWGS
$LN7@ConnectWGS:

; 254  : 		FD_SET(sockfd, &wfds);

  002c8	83 bd 94 fd ff
	ff 40		 cmp	 DWORD PTR _wfds$13[ebp], 64 ; 00000040H
  002cf	73 22		 jae	 SHORT $LN5@ConnectWGS
  002d1	8b 85 94 fd ff
	ff		 mov	 eax, DWORD PTR _wfds$13[ebp]
  002d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockfd@@3IA ; sockfd
  002dd	89 8c 85 98 fd
	ff ff		 mov	 DWORD PTR _wfds$13[ebp+eax*4+4], ecx
  002e4	8b 95 94 fd ff
	ff		 mov	 edx, DWORD PTR _wfds$13[ebp]
  002ea	83 c2 01	 add	 edx, 1
  002ed	89 95 94 fd ff
	ff		 mov	 DWORD PTR _wfds$13[ebp], edx
$LN5@ConnectWGS:
  002f3	33 c0		 xor	 eax, eax
  002f5	75 d1		 jne	 SHORT $LN7@ConnectWGS
$LN10@ConnectWGS:

; 255  : 		FD_SET(sockfd, &efds);

  002f7	83 bd 88 fc ff
	ff 40		 cmp	 DWORD PTR _efds$12[ebp], 64 ; 00000040H
  002fe	73 22		 jae	 SHORT $LN8@ConnectWGS
  00300	8b 85 88 fc ff
	ff		 mov	 eax, DWORD PTR _efds$12[ebp]
  00306	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockfd@@3IA ; sockfd
  0030c	89 8c 85 8c fc
	ff ff		 mov	 DWORD PTR _efds$12[ebp+eax*4+4], ecx
  00313	8b 95 88 fc ff
	ff		 mov	 edx, DWORD PTR _efds$12[ebp]
  00319	83 c2 01	 add	 edx, 1
  0031c	89 95 88 fc ff
	ff		 mov	 DWORD PTR _efds$12[ebp], edx
$LN8@ConnectWGS:
  00322	33 c0		 xor	 eax, eax
  00324	75 d1		 jne	 SHORT $LN10@ConnectWGS

; 256  : 		int a = select(2, &rfds, &wfds, &efds, &tm);

  00326	8d 85 78 fc ff
	ff		 lea	 eax, DWORD PTR _tm$11[ebp]
  0032c	50		 push	 eax
  0032d	8d 8d 88 fc ff
	ff		 lea	 ecx, DWORD PTR _efds$12[ebp]
  00333	51		 push	 ecx
  00334	8d 95 94 fd ff
	ff		 lea	 edx, DWORD PTR _wfds$13[ebp]
  0033a	52		 push	 edx
  0033b	8d 85 a0 fe ff
	ff		 lea	 eax, DWORD PTR _rfds$14[ebp]
  00341	50		 push	 eax
  00342	6a 02		 push	 2
  00344	e8 00 00 00 00	 call	 _select@20
  00349	89 85 6c fc ff
	ff		 mov	 DWORD PTR _a$10[ebp], eax

; 257  : 		if (FD_ISSET(sockfd, &wfds))

  0034f	8d 85 94 fd ff
	ff		 lea	 eax, DWORD PTR _wfds$13[ebp]
  00355	50		 push	 eax
  00356	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockfd@@3IA ; sockfd
  0035c	51		 push	 ecx
  0035d	e8 00 00 00 00	 call	 ___WSAFDIsSet@8
  00362	85 c0		 test	 eax, eax
  00364	74 14		 je	 SHORT $LN35@ConnectWGS

; 258  : 		{
; 259  : 			connectServerCounter = 71;

  00366	c7 05 00 00 00
	00 47 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, 71 ; connectServerCounter, 00000047H

; 260  : 			server_choosed = 100;

  00370	c7 05 00 00 00
	00 64 00 00 00	 mov	 DWORD PTR ?server_choosed@@3HA, 100 ; server_choosed, 00000064H
$LN35@ConnectWGS:

; 261  : 		}
; 262  : #ifdef _OMIT_WGS
; 263  : 		testtest();
; 264  : 		connectServerCounter = 143;   // 暂定
; 265  : 		iWGS = 7;
; 266  : #endif
; 267  : 		if (FD_ISSET(sockfd, &efds))

  0037a	8d 85 88 fc ff
	ff		 lea	 eax, DWORD PTR _efds$12[ebp]
  00380	50		 push	 eax
  00381	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockfd@@3IA ; sockfd
  00387	51		 push	 ecx
  00388	e8 00 00 00 00	 call	 ___WSAFDIsSet@8
  0038d	85 c0		 test	 eax, eax
  0038f	74 40		 je	 SHORT $LN36@ConnectWGS

; 268  : 		{
; 269  : #ifdef _NB_断线自动重连
; 270  : 			PcLanded.登陆延时时间 = TimeGetTime() + 2000;

  00391	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00396	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  0039b	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax

; 271  : #endif
; 272  : 			sprintf(netprocErrmsg, NET_ERRMSG_NOTCONNECT);

  003a0	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KEAEOGKH@?$LN?$LK?E?f?$LP?$KB?$MA?L?A?v?5?G?O?$LE?C?$MA?$LK?5?G?v?$MA?g?5?A?$KB?$LA?K?5?A?$NP?$MA?T@
  003a5	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  003aa	e8 00 00 00 00	 call	 _sprintf
  003af	83 c4 08	 add	 esp, 8

; 273  : 			closesocket(sockfd);

  003b2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  003b7	50		 push	 eax
  003b8	e8 00 00 00 00	 call	 _closesocket@4

; 274  : 			dwServer = NULL;

  003bd	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 0 ; dwServer

; 275  : 			return -6;

  003c7	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  003cc	e9 82 04 00 00	 jmp	 $LN1@ConnectWGS
$LN36@ConnectWGS:

; 276  : 		}
; 277  : 	}

  003d1	e9 42 04 00 00	 jmp	 $LN21@ConnectWGS
$LN29@ConnectWGS:

; 278  : 	else if (connectServerCounter == 71)

  003d6	83 3d 00 00 00
	00 47		 cmp	 DWORD PTR ?connectServerCounter@@3HA, 71 ; connectServerCounter, 00000047H
  003dd	0f 85 dc 01 00
	00		 jne	 $LN37@ConnectWGS

; 279  : 	{
; 280  : 		if (iWGS == 2)

  003e3	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?iWGS@@3HA, 2	; iWGS
  003ea	0f 85 ca 01 00
	00		 jne	 $LN39@ConnectWGS

; 281  : 		{
; 282  : 			unsigned long flg = 1;

  003f0	c7 85 60 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR _flg$9[ebp], 1

; 283  : 			struct sockaddr_in sin;
; 284  : 			struct hostent *h;
; 285  : 
; 286  : 			closesocket(sockfd);

  003fa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  003ff	50		 push	 eax
  00400	e8 00 00 00 00	 call	 _closesocket@4

; 287  : 			dwServer = NULL;

  00405	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 0 ; dwServer

; 288  : 			if (INVALID_SOCKET == (sockfd = socket(AF_INET, SOCK_STREAM, 0)))

  0040f	6a 00		 push	 0
  00411	6a 01		 push	 1
  00413	6a 02		 push	 2
  00415	e8 00 00 00 00	 call	 _socket@12
  0041a	a3 00 00 00 00	 mov	 DWORD PTR ?sockfd@@3IA, eax ; sockfd
  0041f	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?sockfd@@3IA, -1 ; sockfd
  00426	75 2b		 jne	 SHORT $LN40@ConnectWGS

; 289  : 			{
; 290  : #ifdef _NB_断线自动重连
; 291  : 				PcLanded.登陆延时时间 = TimeGetTime() + 2000;

  00428	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  0042d	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  00432	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax

; 292  : #endif
; 293  : 				sprintf(netprocErrmsg, NET_ERRMSG_SOCKETERROR);

  00437	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@JAKPHLLB@?Y?i?$NL?v?$DP?z?$LMsocket?n?$NMTCP?$KB?$KD?$AA@
  0043c	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  00441	e8 00 00 00 00	 call	 _sprintf
  00446	83 c4 08	 add	 esp, 8

; 294  : 				return -3;

  00449	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  0044e	e9 00 04 00 00	 jmp	 $LN1@ConnectWGS
$LN40@ConnectWGS:

; 295  : 			}
; 296  : 			ioctlsocket(sockfd, FIONBIO, &flg);

  00453	8d 85 60 fc ff
	ff		 lea	 eax, DWORD PTR _flg$9[ebp]
  00459	50		 push	 eax
  0045a	68 7e 66 04 80	 push	 -2147195266		; 8004667eH
  0045f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockfd@@3IA ; sockfd
  00465	51		 push	 ecx
  00466	e8 00 00 00 00	 call	 _ioctlsocket@12

; 297  : 			sin.sin_family = AF_INET;

  0046b	b8 02 00 00 00	 mov	 eax, 2
  00470	66 89 85 48 fc
	ff ff		 mov	 WORD PTR _sin$8[ebp], ax

; 298  : 			sin.sin_port = htons(wCS);

  00477	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?wCS@@3GA	; wCS
  0047e	50		 push	 eax
  0047f	e8 00 00 00 00	 call	 _htons@4
  00484	66 89 85 4a fc
	ff ff		 mov	 WORD PTR _sin$8[ebp+2], ax

; 299  : 			sin.sin_addr.s_addr = inet_addr(szCSIP);

  0048b	68 00 00 00 00	 push	 OFFSET ?szCSIP@@3PADA	; szCSIP
  00490	e8 00 00 00 00	 call	 _inet_addr@4
  00495	89 85 4c fc ff
	ff		 mov	 DWORD PTR _sin$8[ebp+4], eax

; 300  : 			if (sin.sin_addr.s_addr == -1)

  0049b	83 bd 4c fc ff
	ff ff		 cmp	 DWORD PTR _sin$8[ebp+4], -1
  004a2	0f 85 84 00 00
	00		 jne	 $LN41@ConnectWGS

; 301  : 			{
; 302  : 				if (!(h = gethostbyname(szCSIP)))

  004a8	68 00 00 00 00	 push	 OFFSET ?szCSIP@@3PADA	; szCSIP
  004ad	e8 00 00 00 00	 call	 _gethostbyname@4
  004b2	89 85 3c fc ff
	ff		 mov	 DWORD PTR _h$7[ebp], eax
  004b8	83 bd 3c fc ff
	ff 00		 cmp	 DWORD PTR _h$7[ebp], 0
  004bf	75 45		 jne	 SHORT $LN42@ConnectWGS

; 303  : 				{
; 304  : #ifdef _NB_断线自动重连
; 305  : 					PcLanded.登陆延时时间 = TimeGetTime() + 2000;

  004c1	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  004c6	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  004cb	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax

; 306  : #endif
; 307  : 					sprintf(netprocErrmsg, NET_ERRMSG_NOTGETADDR, "CS");

  004d0	68 00 00 00 00	 push	 OFFSET ??_C@_02ODPEBLOD@CS?$AA@
  004d5	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@BHPEJLIB@?Y?i?$NL?v?$DP?T?p?$NO?C?$NM?W?P?o?n?$NM?$KD?I?$KD?P?j?H?v?G?$KB?$KD?$CI?$CFs?$CJ?$AA@
  004da	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  004df	e8 00 00 00 00	 call	 _sprintf
  004e4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 308  : 					closesocket(sockfd);

  004e7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  004ec	50		 push	 eax
  004ed	e8 00 00 00 00	 call	 _closesocket@4

; 309  : 					dwServer = NULL;

  004f2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 0 ; dwServer

; 310  : 					return -4;

  004fc	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00501	e9 4d 03 00 00	 jmp	 $LN1@ConnectWGS
$LN42@ConnectWGS:

; 311  : 				}
; 312  : 				memcpy((void*)&sin.sin_addr.s_addr, h->h_addr, sizeof(struct in_addr));

  00506	6a 04		 push	 4
  00508	b8 04 00 00 00	 mov	 eax, 4
  0050d	6b c8 00	 imul	 ecx, eax, 0
  00510	8b 95 3c fc ff
	ff		 mov	 edx, DWORD PTR _h$7[ebp]
  00516	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00519	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0051c	51		 push	 ecx
  0051d	8d 95 4c fc ff
	ff		 lea	 edx, DWORD PTR _sin$8[ebp+4]
  00523	52		 push	 edx
  00524	e8 00 00 00 00	 call	 _memcpy
  00529	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN41@ConnectWGS:

; 313  : 			}
; 314  : 			int ret = connect(sockfd, (struct sockaddr*)&sin, sizeof(sin));

  0052c	6a 10		 push	 16			; 00000010H
  0052e	8d 85 48 fc ff
	ff		 lea	 eax, DWORD PTR _sin$8[ebp]
  00534	50		 push	 eax
  00535	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockfd@@3IA ; sockfd
  0053b	51		 push	 ecx
  0053c	e8 00 00 00 00	 call	 _connect@12
  00541	89 85 30 fc ff
	ff		 mov	 DWORD PTR _ret$6[ebp], eax

; 315  : 			if (ret == SOCKET_ERROR)

  00547	83 bd 30 fc ff
	ff ff		 cmp	 DWORD PTR _ret$6[ebp], -1
  0054e	75 4c		 jne	 SHORT $LN43@ConnectWGS

; 316  : 			{
; 317  : 				if (WSAGetLastError() != WSAEWOULDBLOCK)

  00550	e8 00 00 00 00	 call	 _WSAGetLastError@0
  00555	3d 33 27 00 00	 cmp	 eax, 10035		; 00002733H
  0055a	74 40		 je	 SHORT $LN43@ConnectWGS

; 318  : 				{
; 319  : 					closesocket(sockfd);

  0055c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  00561	50		 push	 eax
  00562	e8 00 00 00 00	 call	 _closesocket@4

; 320  : 					dwServer = NULL;

  00567	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 0 ; dwServer

; 321  : #ifdef _NB_断线自动重连
; 322  : 					PcLanded.登陆延时时间 = TimeGetTime() + 2000;

  00571	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  00576	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  0057b	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax

; 323  : #endif
; 324  : 					sprintf(netprocErrmsg, NET_ERRMSG_NOTCONNECT_S);

  00580	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CKHMFIAG@?Y?i?$NL?v?$DP?c?$LH?$DP?z?$LM?$NO?C?$NM?W?P?o?n?$NM?$DP?o?H?$KB?$KD?$AA@
  00585	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  0058a	e8 00 00 00 00	 call	 _sprintf
  0058f	83 c4 08	 add	 esp, 8

; 325  : 					return -5;

  00592	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  00597	e9 b7 02 00 00	 jmp	 $LN1@ConnectWGS
$LN43@ConnectWGS:

; 326  : 				}
; 327  : 			}
; 328  : 			dwServer = CS;

  0059c	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 2 ; dwServer

; 329  : 			iWGS = 3;

  005a6	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?iWGS@@3HA, 3	; iWGS

; 330  : 			connectServerCounter = 72;

  005b0	c7 05 00 00 00
	00 48 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, 72 ; connectServerCounter, 00000048H
$LN39@ConnectWGS:

; 331  : 		}
; 332  : 	}

  005ba	e9 59 02 00 00	 jmp	 $LN21@ConnectWGS
$LN37@ConnectWGS:

; 333  : 	else if (connectServerCounter >= 72 && connectServerCounter <= 140)

  005bf	83 3d 00 00 00
	00 48		 cmp	 DWORD PTR ?connectServerCounter@@3HA, 72 ; connectServerCounter, 00000048H
  005c6	0f 8c a2 01 00
	00		 jl	 $LN45@ConnectWGS
  005cc	81 3d 00 00 00
	00 8c 00 00 00	 cmp	 DWORD PTR ?connectServerCounter@@3HA, 140 ; connectServerCounter, 0000008cH
  005d6	0f 8f 92 01 00
	00		 jg	 $LN45@ConnectWGS

; 334  : 	{
; 335  : 		fd_set rfds, wfds, efds;
; 336  : 		struct timeval tm;
; 337  : 
; 338  : 		if (++connectServerCounter == 140)

  005dc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?connectServerCounter@@3HA ; connectServerCounter
  005e1	83 c0 01	 add	 eax, 1
  005e4	a3 00 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, eax ; connectServerCounter
  005e9	81 3d 00 00 00
	00 8c 00 00 00	 cmp	 DWORD PTR ?connectServerCounter@@3HA, 140 ; connectServerCounter, 0000008cH
  005f3	75 0a		 jne	 SHORT $LN47@ConnectWGS

; 339  : 			connectServerCounter = 139;

  005f5	c7 05 00 00 00
	00 8b 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, 139 ; connectServerCounter, 0000008bH
$LN47@ConnectWGS:

; 340  : 		tm.tv_sec = 0;

  005ff	c7 85 fc f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR _tm$2[ebp], 0

; 341  : 		tm.tv_usec = 0;

  00609	c7 85 00 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _tm$2[ebp+4], 0

; 342  : 		FD_ZERO(&rfds);

  00613	c7 85 24 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _rfds$5[ebp], 0

; 343  : 		FD_ZERO(&wfds);

  0061d	c7 85 18 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _wfds$4[ebp], 0

; 344  : 		FD_ZERO(&efds);

  00627	c7 85 0c f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _efds$3[ebp], 0
$LN13@ConnectWGS:

; 345  : 		FD_SET(sockfd, &rfds);

  00631	83 bd 24 fb ff
	ff 40		 cmp	 DWORD PTR _rfds$5[ebp], 64 ; 00000040H
  00638	73 22		 jae	 SHORT $LN11@ConnectWGS
  0063a	8b 85 24 fb ff
	ff		 mov	 eax, DWORD PTR _rfds$5[ebp]
  00640	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockfd@@3IA ; sockfd
  00646	89 8c 85 28 fb
	ff ff		 mov	 DWORD PTR _rfds$5[ebp+eax*4+4], ecx
  0064d	8b 95 24 fb ff
	ff		 mov	 edx, DWORD PTR _rfds$5[ebp]
  00653	83 c2 01	 add	 edx, 1
  00656	89 95 24 fb ff
	ff		 mov	 DWORD PTR _rfds$5[ebp], edx
$LN11@ConnectWGS:
  0065c	33 c0		 xor	 eax, eax
  0065e	75 d1		 jne	 SHORT $LN13@ConnectWGS
$LN16@ConnectWGS:

; 346  : 		FD_SET(sockfd, &wfds);

  00660	83 bd 18 fa ff
	ff 40		 cmp	 DWORD PTR _wfds$4[ebp], 64 ; 00000040H
  00667	73 22		 jae	 SHORT $LN14@ConnectWGS
  00669	8b 85 18 fa ff
	ff		 mov	 eax, DWORD PTR _wfds$4[ebp]
  0066f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockfd@@3IA ; sockfd
  00675	89 8c 85 1c fa
	ff ff		 mov	 DWORD PTR _wfds$4[ebp+eax*4+4], ecx
  0067c	8b 95 18 fa ff
	ff		 mov	 edx, DWORD PTR _wfds$4[ebp]
  00682	83 c2 01	 add	 edx, 1
  00685	89 95 18 fa ff
	ff		 mov	 DWORD PTR _wfds$4[ebp], edx
$LN14@ConnectWGS:
  0068b	33 c0		 xor	 eax, eax
  0068d	75 d1		 jne	 SHORT $LN16@ConnectWGS
$LN19@ConnectWGS:

; 347  : 		FD_SET(sockfd, &efds);

  0068f	83 bd 0c f9 ff
	ff 40		 cmp	 DWORD PTR _efds$3[ebp], 64 ; 00000040H
  00696	73 22		 jae	 SHORT $LN17@ConnectWGS
  00698	8b 85 0c f9 ff
	ff		 mov	 eax, DWORD PTR _efds$3[ebp]
  0069e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockfd@@3IA ; sockfd
  006a4	89 8c 85 10 f9
	ff ff		 mov	 DWORD PTR _efds$3[ebp+eax*4+4], ecx
  006ab	8b 95 0c f9 ff
	ff		 mov	 edx, DWORD PTR _efds$3[ebp]
  006b1	83 c2 01	 add	 edx, 1
  006b4	89 95 0c f9 ff
	ff		 mov	 DWORD PTR _efds$3[ebp], edx
$LN17@ConnectWGS:
  006ba	33 c0		 xor	 eax, eax
  006bc	75 d1		 jne	 SHORT $LN19@ConnectWGS

; 348  : 		int a = select(2, &rfds, &wfds, &efds, &tm);

  006be	8d 85 fc f8 ff
	ff		 lea	 eax, DWORD PTR _tm$2[ebp]
  006c4	50		 push	 eax
  006c5	8d 8d 0c f9 ff
	ff		 lea	 ecx, DWORD PTR _efds$3[ebp]
  006cb	51		 push	 ecx
  006cc	8d 95 18 fa ff
	ff		 lea	 edx, DWORD PTR _wfds$4[ebp]
  006d2	52		 push	 edx
  006d3	8d 85 24 fb ff
	ff		 lea	 eax, DWORD PTR _rfds$5[ebp]
  006d9	50		 push	 eax
  006da	6a 02		 push	 2
  006dc	e8 00 00 00 00	 call	 _select@20
  006e1	89 85 f0 f8 ff
	ff		 mov	 DWORD PTR _a$1[ebp], eax

; 349  : 		if (FD_ISSET(sockfd, &wfds))

  006e7	8d 85 18 fa ff
	ff		 lea	 eax, DWORD PTR _wfds$4[ebp]
  006ed	50		 push	 eax
  006ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockfd@@3IA ; sockfd
  006f4	51		 push	 ecx
  006f5	e8 00 00 00 00	 call	 ___WSAFDIsSet@8
  006fa	85 c0		 test	 eax, eax
  006fc	74 14		 je	 SHORT $LN51@ConnectWGS

; 350  : 		{
; 351  : 			connectServerCounter = 141;

  006fe	c7 05 00 00 00
	00 8d 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, 141 ; connectServerCounter, 0000008dH

; 352  : 			server_choosed = 100;

  00708	c7 05 00 00 00
	00 64 00 00 00	 mov	 DWORD PTR ?server_choosed@@3HA, 100 ; server_choosed, 00000064H
$LN51@ConnectWGS:

; 353  : 		}
; 354  : 		if (FD_ISSET(sockfd, &efds))

  00712	8d 85 0c f9 ff
	ff		 lea	 eax, DWORD PTR _efds$3[ebp]
  00718	50		 push	 eax
  00719	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sockfd@@3IA ; sockfd
  0071f	51		 push	 ecx
  00720	e8 00 00 00 00	 call	 ___WSAFDIsSet@8
  00725	85 c0		 test	 eax, eax
  00727	74 40		 je	 SHORT $LN52@ConnectWGS

; 355  : 		{
; 356  : #ifdef _NB_断线自动重连
; 357  : 			PcLanded.登陆延时时间 = TimeGetTime() + 2000;

  00729	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  0072e	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  00733	a3 9c 00 00 00	 mov	 DWORD PTR ?PcLanded@@3ULanded@@A+156, eax

; 358  : #endif
; 359  : 			sprintf(netprocErrmsg, NET_ERRMSG_NOTCONNECT);

  00738	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KEAEOGKH@?$LN?$LK?E?f?$LP?$KB?$MA?L?A?v?5?G?O?$LE?C?$MA?$LK?5?G?v?$MA?g?5?A?$KB?$LA?K?5?A?$NP?$MA?T@
  0073d	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  00742	e8 00 00 00 00	 call	 _sprintf
  00747	83 c4 08	 add	 esp, 8

; 360  : 			closesocket(sockfd);

  0074a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  0074f	50		 push	 eax
  00750	e8 00 00 00 00	 call	 _closesocket@4

; 361  : 			dwServer = NULL;

  00755	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 0 ; dwServer

; 362  : 			return -6;

  0075f	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  00764	e9 ea 00 00 00	 jmp	 $LN1@ConnectWGS
$LN52@ConnectWGS:

; 363  : 		}
; 364  : 	}

  00769	e9 aa 00 00 00	 jmp	 $LN21@ConnectWGS
$LN45@ConnectWGS:

; 365  : 	else if (connectServerCounter == 141)

  0076e	81 3d 00 00 00
	00 8d 00 00 00	 cmp	 DWORD PTR ?connectServerCounter@@3HA, 141 ; connectServerCounter, 0000008dH
  00778	75 24		 jne	 SHORT $LN53@ConnectWGS

; 366  : 	{
; 367  : 		if (iWGS == 4)

  0077a	83 3d 00 00 00
	00 04		 cmp	 DWORD PTR ?iWGS@@3HA, 4	; iWGS
  00781	75 19		 jne	 SHORT $LN55@ConnectWGS

; 368  : 		{
; 369  : 			DoSKey();

  00783	e8 00 00 00 00	 call	 ?DoSKey@@YAXXZ		; DoSKey

; 370  : 			connectServerCounter = 142;

  00788	c7 05 00 00 00
	00 8e 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, 142 ; connectServerCounter, 0000008eH

; 371  : 			iWGS = 5;

  00792	c7 05 00 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?iWGS@@3HA, 5	; iWGS
$LN55@ConnectWGS:

; 372  : 		}
; 373  : 	}

  0079c	eb 7a		 jmp	 SHORT $LN21@ConnectWGS
$LN53@ConnectWGS:

; 374  : 	else if (connectServerCounter == 142)

  0079e	81 3d 00 00 00
	00 8e 00 00 00	 cmp	 DWORD PTR ?connectServerCounter@@3HA, 142 ; connectServerCounter, 0000008eH
  007a8	75 24		 jne	 SHORT $LN56@ConnectWGS

; 375  : 	{
; 376  : 		if (iWGS == 6)

  007aa	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR ?iWGS@@3HA, 6	; iWGS
  007b1	75 19		 jne	 SHORT $LN58@ConnectWGS

; 377  : 		{
; 378  : 			DoHellow();

  007b3	e8 00 00 00 00	 call	 ?DoHellow@@YAXXZ	; DoHellow

; 379  : 			connectServerCounter = 143;

  007b8	c7 05 00 00 00
	00 8f 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, 143 ; connectServerCounter, 0000008fH

; 380  : 			iWGS = 7;

  007c2	c7 05 00 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?iWGS@@3HA, 7	; iWGS
$LN58@ConnectWGS:

; 381  : 		}
; 382  : 	}

  007cc	eb 4a		 jmp	 SHORT $LN21@ConnectWGS
$LN56@ConnectWGS:

; 383  : 	else if (connectServerCounter == 143)

  007ce	81 3d 00 00 00
	00 8f 00 00 00	 cmp	 DWORD PTR ?connectServerCounter@@3HA, 143 ; connectServerCounter, 0000008fH
  007d8	75 3e		 jne	 SHORT $LN21@ConnectWGS

; 384  : 	{
; 385  : 		if (iWGS == 8)

  007da	83 3d 00 00 00
	00 08		 cmp	 DWORD PTR ?iWGS@@3HA, 8	; iWGS
  007e1	75 35		 jne	 SHORT $LN21@ConnectWGS

; 386  : 		{
; 387  : 			cleanupNetwork();

  007e3	e8 00 00 00 00	 call	 ?cleanupNetwork@@YAXXZ	; cleanupNetwork

; 388  : 			disconnectServerFlag = TRUE;

  007e8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?disconnectServerFlag@@3HA, 1 ; disconnectServerFlag

; 389  : 			oldDisconnectServerFlag = TRUE;

  007f2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?oldDisconnectServerFlag@@3HA, 1 ; oldDisconnectServerFlag

; 390  : 			closesocket(sockfd);

  007fc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sockfd@@3IA ; sockfd
  00801	50		 push	 eax
  00802	e8 00 00 00 00	 call	 _closesocket@4

; 391  : 			dwServer = GS;

  00807	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?dwServer@@3KA, 3 ; dwServer

; 392  : 			return 1;

  00811	b8 01 00 00 00	 mov	 eax, 1
  00816	eb 3b		 jmp	 SHORT $LN1@ConnectWGS
$LN21@ConnectWGS:

; 393  : 		}
; 394  : 	}
; 395  : 	if (iWGS == 9)

  00818	83 3d 00 00 00
	00 09		 cmp	 DWORD PTR ?iWGS@@3HA, 9	; iWGS
  0081f	75 07		 jne	 SHORT $LN61@ConnectWGS

; 396  : 		return -7;

  00821	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  00826	eb 2b		 jmp	 SHORT $LN1@ConnectWGS
$LN61@ConnectWGS:

; 397  : 	SETTIMEOUT2(NET_ERRMSG_CONNECTTIMEOUT);

  00828	e8 00 00 00 00	 call	 ?TimeGetTime@@YAIXZ	; TimeGetTime
  0082d	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?start_time@@3KA ; start_time
  00833	3d c0 27 09 00	 cmp	 eax, 600000		; 000927c0H
  00838	76 17		 jbe	 SHORT $LN62@ConnectWGS
  0083a	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@PMNBOGBM@?$NO?C?$NM?W?P?o?$DP?o?H?$DP?$DP?l?$KL?S?p?$KB?$KD?$AA@
  0083f	68 00 00 00 00	 push	 OFFSET ?netprocErrmsg@@3PADA ; netprocErrmsg
  00844	e8 00 00 00 00	 call	 _sprintf
  00849	83 c4 08	 add	 esp, 8
  0084c	83 c8 ff	 or	 eax, -1
  0084f	eb 02		 jmp	 SHORT $LN1@ConnectWGS
$LN62@ConnectWGS:

; 398  : 	return 0;

  00851	33 c0		 xor	 eax, eax
$LN1@ConnectWGS:

; 399  : }

  00853	52		 push	 edx
  00854	8b cd		 mov	 ecx, ebp
  00856	50		 push	 eax
  00857	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN77@ConnectWGS
  0085d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00862	58		 pop	 eax
  00863	5a		 pop	 edx
  00864	5f		 pop	 edi
  00865	5e		 pop	 esi
  00866	5b		 pop	 ebx
  00867	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0086a	33 cd		 xor	 ecx, ebp
  0086c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00871	81 c4 14 0a 00
	00		 add	 esp, 2580		; 00000a14H
  00877	3b ec		 cmp	 ebp, esp
  00879	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0087e	8b e5		 mov	 esp, ebp
  00880	5d		 pop	 ebp
  00881	c3		 ret	 0
  00882	66 90		 npad	 2
$LN77@ConnectWGS:
  00884	0c 00 00 00	 DD	 12			; 0000000cH
  00888	00 00 00 00	 DD	 $LN76@ConnectWGS
$LN76@ConnectWGS:
  0088c	dc ff ff ff	 DD	 -36			; ffffffdcH
  00890	04 00 00 00	 DD	 4
  00894	00 00 00 00	 DD	 $LN64@ConnectWGS
  00898	c4 ff ff ff	 DD	 -60			; ffffffc4H
  0089c	10 00 00 00	 DD	 16			; 00000010H
  008a0	00 00 00 00	 DD	 $LN65@ConnectWGS
  008a4	a0 fe ff ff	 DD	 -352			; fffffea0H
  008a8	04 01 00 00	 DD	 260			; 00000104H
  008ac	00 00 00 00	 DD	 $LN66@ConnectWGS
  008b0	94 fd ff ff	 DD	 -620			; fffffd94H
  008b4	04 01 00 00	 DD	 260			; 00000104H
  008b8	00 00 00 00	 DD	 $LN67@ConnectWGS
  008bc	88 fc ff ff	 DD	 -888			; fffffc88H
  008c0	04 01 00 00	 DD	 260			; 00000104H
  008c4	00 00 00 00	 DD	 $LN68@ConnectWGS
  008c8	78 fc ff ff	 DD	 -904			; fffffc78H
  008cc	08 00 00 00	 DD	 8
  008d0	00 00 00 00	 DD	 $LN69@ConnectWGS
  008d4	60 fc ff ff	 DD	 -928			; fffffc60H
  008d8	04 00 00 00	 DD	 4
  008dc	00 00 00 00	 DD	 $LN70@ConnectWGS
  008e0	48 fc ff ff	 DD	 -952			; fffffc48H
  008e4	10 00 00 00	 DD	 16			; 00000010H
  008e8	00 00 00 00	 DD	 $LN71@ConnectWGS
  008ec	24 fb ff ff	 DD	 -1244			; fffffb24H
  008f0	04 01 00 00	 DD	 260			; 00000104H
  008f4	00 00 00 00	 DD	 $LN72@ConnectWGS
  008f8	18 fa ff ff	 DD	 -1512			; fffffa18H
  008fc	04 01 00 00	 DD	 260			; 00000104H
  00900	00 00 00 00	 DD	 $LN73@ConnectWGS
  00904	0c f9 ff ff	 DD	 -1780			; fffff90cH
  00908	04 01 00 00	 DD	 260			; 00000104H
  0090c	00 00 00 00	 DD	 $LN74@ConnectWGS
  00910	fc f8 ff ff	 DD	 -1796			; fffff8fcH
  00914	08 00 00 00	 DD	 8
  00918	00 00 00 00	 DD	 $LN75@ConnectWGS
$LN75@ConnectWGS:
  0091c	74		 DB	 116			; 00000074H
  0091d	6d		 DB	 109			; 0000006dH
  0091e	00		 DB	 0
$LN74@ConnectWGS:
  0091f	65		 DB	 101			; 00000065H
  00920	66		 DB	 102			; 00000066H
  00921	64		 DB	 100			; 00000064H
  00922	73		 DB	 115			; 00000073H
  00923	00		 DB	 0
$LN73@ConnectWGS:
  00924	77		 DB	 119			; 00000077H
  00925	66		 DB	 102			; 00000066H
  00926	64		 DB	 100			; 00000064H
  00927	73		 DB	 115			; 00000073H
  00928	00		 DB	 0
$LN72@ConnectWGS:
  00929	72		 DB	 114			; 00000072H
  0092a	66		 DB	 102			; 00000066H
  0092b	64		 DB	 100			; 00000064H
  0092c	73		 DB	 115			; 00000073H
  0092d	00		 DB	 0
$LN71@ConnectWGS:
  0092e	73		 DB	 115			; 00000073H
  0092f	69		 DB	 105			; 00000069H
  00930	6e		 DB	 110			; 0000006eH
  00931	00		 DB	 0
$LN70@ConnectWGS:
  00932	66		 DB	 102			; 00000066H
  00933	6c		 DB	 108			; 0000006cH
  00934	67		 DB	 103			; 00000067H
  00935	00		 DB	 0
$LN69@ConnectWGS:
  00936	74		 DB	 116			; 00000074H
  00937	6d		 DB	 109			; 0000006dH
  00938	00		 DB	 0
$LN68@ConnectWGS:
  00939	65		 DB	 101			; 00000065H
  0093a	66		 DB	 102			; 00000066H
  0093b	64		 DB	 100			; 00000064H
  0093c	73		 DB	 115			; 00000073H
  0093d	00		 DB	 0
$LN67@ConnectWGS:
  0093e	77		 DB	 119			; 00000077H
  0093f	66		 DB	 102			; 00000066H
  00940	64		 DB	 100			; 00000064H
  00941	73		 DB	 115			; 00000073H
  00942	00		 DB	 0
$LN66@ConnectWGS:
  00943	72		 DB	 114			; 00000072H
  00944	66		 DB	 102			; 00000066H
  00945	64		 DB	 100			; 00000064H
  00946	73		 DB	 115			; 00000073H
  00947	00		 DB	 0
$LN65@ConnectWGS:
  00948	73		 DB	 115			; 00000073H
  00949	69		 DB	 105			; 00000069H
  0094a	6e		 DB	 110			; 0000006eH
  0094b	00		 DB	 0
$LN64@ConnectWGS:
  0094c	66		 DB	 102			; 00000066H
  0094d	6c		 DB	 108			; 0000006cH
  0094e	67		 DB	 103			; 00000067H
  0094f	00		 DB	 0
?ConnectWGS@@YAHXZ ENDP					; ConnectWGS
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\netproc.cpp
;	COMDAT ?initConnectServer@@YAXXZ
_TEXT	SEGMENT
?initConnectServer@@YAXXZ PROC				; initConnectServer, COMDAT

; 151  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 152  : 	connectServerCounter = 0;

  0001e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?connectServerCounter@@3HA, 0 ; connectServerCounter

; 153  : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?initConnectServer@@YAXXZ ENDP				; initConnectServer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
;	COMDAT _time
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC						; COMDAT

; 534  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 535  :             return _time64(_Time);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  00023	50		 push	 eax
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
  0002a	83 c4 04	 add	 esp, 4
  0002d	3b f4		 cmp	 esi, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 536  :         }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
;	COMDAT _localtime
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_localtime PROC						; COMDAT

; 508  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 509  :             #pragma warning(push)
; 510  :             #pragma warning(disable: 4996)
; 511  :             return _localtime64(_Time);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  00023	50		 push	 eax
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___localtime64
  0002a	83 c4 04	 add	 esp, 4
  0002d	3b f4		 cmp	 esi, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 512  :             #pragma warning(pop)
; 513  :         }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_localtime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
;	COMDAT ?strstr@@YAPADQADQBD@Z
_TEXT	SEGMENT
__String$ = 8						; size = 4
__SubString$ = 12					; size = 4
?strstr@@YAPADQADQBD@Z PROC				; strstr, COMDAT

; 536  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 537  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 0c	 mov	 eax, DWORD PTR __SubString$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR __String$[ebp]
  00027	51		 push	 ecx
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strstr
  0002e	83 c4 08	 add	 esp, 8
  00031	3b f4		 cmp	 esi, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 538  :     }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?strstr@@YAPADQADQBD@Z ENDP				; strstr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sscanf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sscanf	PROC						; COMDAT

; 2261 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2262 :     int _Result;
; 2263 :     va_list _ArgList;
; 2264 :     __crt_va_start(_ArgList, _Format);

  0001e	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
  00023	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00026	89 45 ec	 mov	 DWORD PTR __ArgList$[ebp], eax

; 2265 :     _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00029	8b 45 ec	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0002c	50		 push	 eax
  0002d	6a 00		 push	 0
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 __vsscanf_l
  0003c	83 c4 10	 add	 esp, 16			; 00000010H
  0003f	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 2266 :     __crt_va_end(_ArgList);

  00042	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 2267 :     return _Result;

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 2268 : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsscanf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsscanf_l PROC					; COMDAT

; 2166 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2167 :     return __stdio_common_vsscanf(

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  0002b	52		 push	 edx
  0002c	6a ff		 push	 -1
  0002e	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ___local_stdio_scanf_options
  00037	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003a	51		 push	 ecx
  0003b	8b 10		 mov	 edx, DWORD PTR [eax]
  0003d	52		 push	 edx
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsscanf
  00044	83 c4 1c	 add	 esp, 28			; 0000001cH
  00047	3b f4		 cmp	 esi, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2168 :         _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2169 :         _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2170 : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00057	3b ec		 cmp	 ebp, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
__vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

  0001e	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
  00023	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00026	89 45 ec	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00029	8b 45 ec	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0002c	50		 push	 eax
  0002d	6a 00		 push	 0
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 __vsprintf_l
  0003c	83 c4 10	 add	 esp, 16			; 00000010H
  0003f	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

  00042	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 1788 : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  0001e	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00029	52		 push	 edx
  0002a	6a ff		 push	 -1
  0002c	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 __vsnprintf_l
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -208						; size = 4
__Result$ = -8						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1386 :     int const _Result = __stdio_common_vsprintf(

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  0002f	50		 push	 eax
  00030	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00039	8b 10		 mov	 edx, DWORD PTR [eax]
  0003b	83 ca 01	 or	 edx, 1
  0003e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00041	50		 push	 eax
  00042	52		 push	 edx
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  00049	83 c4 1c	 add	 esp, 28			; 0000001cH
  0004c	3b f4		 cmp	 esi, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00056	83 7d f8 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0005a	7d 0c		 jge	 SHORT $LN3@vsnprintf_
  0005c	c7 85 30 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv74[ebp], -1
  00066	eb 09		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00068	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]
  0006b	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  00071	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv74[ebp]

; 1391 : }

  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00080	3b ec		 cmp	 ebp, esp
  00082	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 950  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

  0001e	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
  00023	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00026	89 45 ec	 mov	 DWORD PTR __ArgList$[ebp], eax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00029	8b 45 ec	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0002c	50		 push	 eax
  0002d	6a 00		 push	 0
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Format$[ebp]
  00032	51		 push	 ecx
  00033	8b f4		 mov	 esi, esp
  00035	6a 01		 push	 1
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0003d	83 c4 04	 add	 esp, 4
  00040	3b f4		 cmp	 esi, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 __vfprintf_l
  0004d	83 c4 10	 add	 esp, 16			; 00000010H
  00050	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 955  :     __crt_va_end(_ArgList);

  00053	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 956  :     return _Result;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 957  : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 144  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 831  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 832  :     int _Result;
; 833  :     va_list _ArgList;
; 834  :     __crt_va_start(_ArgList, _Format);

  0001e	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
  00023	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00026	89 45 ec	 mov	 DWORD PTR __ArgList$[ebp], eax

; 835  :     _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00029	8b 45 ec	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0002c	50		 push	 eax
  0002d	6a 00		 push	 0
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 08	 mov	 edx, DWORD PTR __Stream$[ebp]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 __vfprintf_l
  0003c	83 c4 10	 add	 esp, 16			; 00000010H
  0003f	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 836  :     __crt_va_end(_ArgList);

  00042	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 837  :     return _Result;

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 838  : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 638  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	51		 push	 ecx
  00039	8b 10		 mov	 edx, DWORD PTR [eax]
  0003b	52		 push	 edx
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  00042	83 c4 18	 add	 esp, 24			; 00000018H
  00045	3b f4		 cmp	 esi, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 640  : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT

; 82   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 83   :     static unsigned __int64 _OptionsStorage;
; 84   :     return &_OptionsStorage;

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 85   : }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
