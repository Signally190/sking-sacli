; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Administrator\Desktop\????? ??\????? ??\Client Source Code\system\lssproto_util.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?SendCount@@3HA					; SendCount
PUBLIC	?lssproto_modifymask_first@@3PAY08HA		; lssproto_modifymask_first
PUBLIC	?lssproto_modifymask_second@@3PAY08HA		; lssproto_modifymask_second
PUBLIC	?bitstream_maxbyte@@3HA				; bitstream_maxbyte
PUBLIC	?bitstream_bitaddr@@3HA				; bitstream_bitaddr
PUBLIC	?bitstream_buf@@3PADA				; bitstream_buf
PUBLIC	?lssproto_charset@@3PADA			; lssproto_charset
PUBLIC	?lssproto_reversecharset@@3PADA			; lssproto_reversecharset
PUBLIC	?lssproto@@3Ulssproto_@@A			; lssproto
PUBLIC	?lssproto_stringwrapper@@3PAPADA		; lssproto_stringwrapper
PUBLIC	?lssproto_readlogfilename@@3PADA		; lssproto_readlogfilename
PUBLIC	?lssproto_writelogfilename@@3PADA		; lssproto_writelogfilename
_BSS	SEGMENT
?SendCount@@3HA DD 01H DUP (?)				; SendCount
?bitstream_maxbyte@@3HA DD 01H DUP (?)			; bitstream_maxbyte
?bitstream_bitaddr@@3HA DD 01H DUP (?)			; bitstream_bitaddr
?bitstream_buf@@3PADA DD 01H DUP (?)			; bitstream_buf
?lssproto_stringwrapper@@3PAPADA DD 01H DUP (?)		; lssproto_stringwrapper
?lssproto_readlogfilename@@3PADA DB 0400H DUP (?)	; lssproto_readlogfilename
?lssproto_writelogfilename@@3PADA DB 0400H DUP (?)	; lssproto_writelogfilename
_BSS	ENDS
_DATA	SEGMENT
?lssproto_modifymask_first@@3PAY08HA DD 00H		; lssproto_modifymask_first
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	00H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	0ffH
	DD	00H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	00H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	00H
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	00H
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	00H
	DD	07fH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	00H
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
?lssproto_modifymask_second@@3PAY08HA DD 00H		; lssproto_modifymask_second
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	03H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	03H
	DD	07H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	00H
	DD	00H
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
?lssproto_charset@@3PADA DB 041H			; lssproto_charset
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	047H
	DB	048H
	DB	049H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	04dH
	DB	04eH
	DB	04fH
	DB	050H
	DB	051H
	DB	052H
	DB	053H
	DB	054H
	DB	055H
	DB	056H
	DB	057H
	DB	058H
	DB	059H
	DB	05aH
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	02bH
	DB	02dH
?lssproto_reversecharset@@3PADA DB 00H			; lssproto_reversecharset
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	03eH
	DB	00H
	DB	03fH
	DB	00H
	DB	00H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	03cH
	DB	03dH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	02aH
	DB	02bH
	DB	02cH
	DB	02dH
	DB	02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
?lssproto@@3Ulssproto_@@A DD 00H			; lssproto
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	?lssproto_escapeString@@YAPADPAD@Z		; lssproto_escapeString
PUBLIC	?lssproto_descapeString@@YAPADPAD@Z		; lssproto_descapeString
PUBLIC	?lssproto_splitString@@YAXPAD@Z			; lssproto_splitString
PUBLIC	?lssproto_strcpysafe@@YAXPAD0H@Z		; lssproto_strcpysafe
PUBLIC	?lssproto_strcatsafe@@YAXPAD0H@Z		; lssproto_strcatsafe
PUBLIC	?lssproto_mkstr_int@@YAPADH@Z			; lssproto_mkstr_int
PUBLIC	?lssproto_mkstr_u_int@@YAPADI@Z			; lssproto_mkstr_u_int
PUBLIC	?lssproto_mkstr_long@@YAPADJ@Z			; lssproto_mkstr_long
PUBLIC	?lssproto_mkstr_u_long@@YAPADK@Z		; lssproto_mkstr_u_long
PUBLIC	?lssproto_mkstr_short@@YAPADF@Z			; lssproto_mkstr_short
PUBLIC	?lssproto_mkstr_u_short@@YAPADF@Z		; lssproto_mkstr_u_short
PUBLIC	?lssproto_mkstr_char@@YAPADD@Z			; lssproto_mkstr_char
PUBLIC	?lssproto_mkstr_u_char@@YAPADD@Z		; lssproto_mkstr_u_char
PUBLIC	?lssproto_mkstr_string@@YAPADPAD@Z		; lssproto_mkstr_string
PUBLIC	?lssproto_mkstr_float@@YAPADM@Z			; lssproto_mkstr_float
PUBLIC	?lssproto_mkstr_double@@YAPADN@Z		; lssproto_mkstr_double
PUBLIC	?lssproto_mkstr_int_array@@YAPADHPAH@Z		; lssproto_mkstr_int_array
PUBLIC	?lssproto_mkstr_u_int_array@@YAPADHPAH@Z	; lssproto_mkstr_u_int_array
PUBLIC	?lssproto_mkstr_short_array@@YAPADHPAF@Z	; lssproto_mkstr_short_array
PUBLIC	?lssproto_mkstr_u_short_array@@YAPADHPAF@Z	; lssproto_mkstr_u_short_array
PUBLIC	?lssproto_mkstr_char_array@@YAPADHPAD@Z		; lssproto_mkstr_char_array
PUBLIC	?lssproto_mkstr_u_char_array@@YAPADHPAE@Z	; lssproto_mkstr_u_char_array
PUBLIC	?lssproto_mkstr_float_array@@YAPADHPAM@Z	; lssproto_mkstr_float_array
PUBLIC	?lssproto_mkstr_double_array@@YAPADHPAN@Z	; lssproto_mkstr_double_array
PUBLIC	?lssproto_demkstr_int@@YAHPAD@Z			; lssproto_demkstr_int
PUBLIC	?lssproto_demkstr_u_int@@YAIPAD@Z		; lssproto_demkstr_u_int
PUBLIC	?lssproto_demkstr_long@@YAJPAD@Z		; lssproto_demkstr_long
PUBLIC	?lssproto_demkstr_u_long@@YAKPAD@Z		; lssproto_demkstr_u_long
PUBLIC	?lssproto_demkstr_short@@YAFPAD@Z		; lssproto_demkstr_short
PUBLIC	?lssproto_demkstr_u_short@@YAGPAD@Z		; lssproto_demkstr_u_short
PUBLIC	?lssproto_demkstr_char@@YADPAD@Z		; lssproto_demkstr_char
PUBLIC	?lssproto_demkstr_u_char@@YAEPAD@Z		; lssproto_demkstr_u_char
PUBLIC	?lssproto_demkstr_float@@YAMPAD@Z		; lssproto_demkstr_float
PUBLIC	?lssproto_demkstr_double@@YANPAD@Z		; lssproto_demkstr_double
PUBLIC	?lssproto_demkstr_string@@YAPADPAD@Z		; lssproto_demkstr_string
PUBLIC	?lssproto_demkstr_int_array@@YAPAHPAPADPAHHH@Z	; lssproto_demkstr_int_array
PUBLIC	?lssproto_demkstr_u_int_array@@YAPAHPAPADPAHHH@Z ; lssproto_demkstr_u_int_array
PUBLIC	?lssproto_demkstr_long_array@@YAPAIPAPADPAIHH@Z	; lssproto_demkstr_long_array
PUBLIC	?lssproto_demkstr_u_long_array@@YAPAKPAPADPAKHH@Z ; lssproto_demkstr_u_long_array
PUBLIC	?lssproto_demkstr_short_array@@YAPAFPAPADPAFHH@Z ; lssproto_demkstr_short_array
PUBLIC	?lssproto_demkstr_u_short_array@@YAPAGPAPADPAGHH@Z ; lssproto_demkstr_u_short_array
PUBLIC	?lssproto_demkstr_char_array@@YAPADPAPADPADHH@Z	; lssproto_demkstr_char_array
PUBLIC	?lssproto_demkstr_u_char_array@@YAPAEPAPADPAEHH@Z ; lssproto_demkstr_u_char_array
PUBLIC	?lssproto_demkstr_float_array@@YAPAMPAPADPAMHH@Z ; lssproto_demkstr_float_array
PUBLIC	?lssproto_demkstr_u_double_array@@YAPANPAPADPANHH@Z ; lssproto_demkstr_u_double_array
PUBLIC	?lssproto_wrapStringAddr@@YAPADPADH0@Z		; lssproto_wrapStringAddr
PUBLIC	?lssproto_GetMessageInfo@@YAXPAHPADHPAPAD@Z	; lssproto_GetMessageInfo
PUBLIC	?lssproto_consumeLine@@YAXPADH@Z		; lssproto_consumeLine
PUBLIC	?lssproto_copyLine@@YAXPAD0H@Z			; lssproto_copyLine
PUBLIC	?lssproto_Send@@YAXHPAD@Z			; lssproto_Send
PUBLIC	?lssproto_AllocateCommonWork@@YAHH@Z		; lssproto_AllocateCommonWork
PUBLIC	?lssproto_GetNewMessageID@@YAIXZ		; lssproto_GetNewMessageID
PUBLIC	?lssproto_CreateHeader@@YAXPAD0@Z		; lssproto_CreateHeader
PUBLIC	?lssproto_CreateHeaderID@@YAXPADK0@Z		; lssproto_CreateHeaderID
PUBLIC	?lssproto_default_write_wrap@@YAHHPADH@Z	; lssproto_default_write_wrap
PUBLIC	?lssproto_bzero@@YAXPADH@Z			; lssproto_bzero
PUBLIC	?lssproto_bcopy@@YAXPAD0H@Z			; lssproto_bcopy
PUBLIC	?lssproto_Ltoa@@YAPADJ@Z			; lssproto_Ltoa
PUBLIC	?lssproto_Ultoa@@YAPADK@Z			; lssproto_Ultoa
PUBLIC	?lssproto_DebugSend@@YAXHPAD@Z			; lssproto_DebugSend
PUBLIC	?lssproto_cnv10to62@@YAPADHPADH@Z		; lssproto_cnv10to62
PUBLIC	?lssproto_a62toi@@YAHPAD@Z			; lssproto_a62toi
PUBLIC	?lssproto_ringoCompressor@@YAJPAEJ0J@Z		; lssproto_ringoCompressor
PUBLIC	?lssproto_ringoDecompressor@@YAJPAEJ0J@Z	; lssproto_ringoDecompressor
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	??_C@_03JAIJOMNP@?$CFf?5?$AA@			; `string'
PUBLIC	??_C@_02DPNLHKJD@a?$CL?$AA@			; `string'
PUBLIC	??_C@_0L@INAHAGEI@?b?$KF?S?p?$KD?$LK?7?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_06DBOHCIGL@?$CFu?5?$CFs?5?$AA@		; `string'
PUBLIC	??_C@_02GMHACPFF@?$CFu?$AA@			; `string'
PUBLIC	??_C@_0CF@NBLKNCEA@lsgen?3?5badly?5configured?5work?5buf@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0BH@GCBPDGEH@LSRPC?3?5too?5short?3?$FL?$CFs?$FN?6?$AA@ ; `string'
PUBLIC	??_C@_0DP@CCELEMID@0123456789abcdefghijklmnopqrstuv@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__IsDBCSLeadByte@4:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__exit:PROC
EXTRN	_abs:PROC
EXTRN	__imp__atof:PROC
EXTRN	__imp__strtod:PROC
EXTRN	__imp__strtol:PROC
EXTRN	__imp__strtoul:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__chkstk:PROC
EXTRN	?bNewServer@@3HA:DWORD				; bNewServer
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?bInit@?1??lssproto_AllocateCommonWork@@YAHH@Z@4HA DD 01H DUP (?) ; `lssproto_AllocateCommonWork'::`2'::bInit
?_ltoa_out@?1??lssproto_Ltoa@@YAPADJ@Z@4PADA DB 040H DUP (?) ; `lssproto_Ltoa'::`2'::_ltoa_out
?_ultoa_out@?1??lssproto_Ultoa@@YAPADK@Z@4PADA DB 040H DUP (?) ; `lssproto_Ultoa'::`2'::_ultoa_out
_BSS	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0DP@CCELEMID@0123456789abcdefghijklmnopqrstuv@
CONST	SEGMENT
??_C@_0DP@CCELEMID@0123456789abcdefghijklmnopqrstuv@ DB '0123456789abcdef'
	DB	'ghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GCBPDGEH@LSRPC?3?5too?5short?3?$FL?$CFs?$FN?6?$AA@
CONST	SEGMENT
??_C@_0BH@GCBPDGEH@LSRPC?3?5too?5short?3?$FL?$CFs?$FN?6?$AA@ DB 'LSRPC: t'
	DB	'oo short:[%s]', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NBLKNCEA@lsgen?3?5badly?5configured?5work?5buf@
CONST	SEGMENT
??_C@_0CF@NBLKNCEA@lsgen?3?5badly?5configured?5work?5buf@ DB 'lsgen: badl'
	DB	'y configured work buflen', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMHACPFF@?$CFu?$AA@
CONST	SEGMENT
??_C@_02GMHACPFF@?$CFu?$AA@ DB '%u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DBOHCIGL@?$CFu?5?$CFs?5?$AA@
CONST	SEGMENT
??_C@_06DBOHCIGL@?$CFu?5?$CFs?5?$AA@ DB '%u %s ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@INAHAGEI@?b?$KF?S?p?$KD?$LK?7?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0L@INAHAGEI@?b?$KF?S?p?$KD?$LK?7?$CFs?6?$AA@ DB 0e2H, 0a5H, 0d3H, 0f0H
	DB	0a3H, 0baH, 09H, '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPNLHKJD@a?$CL?$AA@
CONST	SEGMENT
??_C@_02DPNLHKJD@a?$CL?$AA@ DB 'a+', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JAIJOMNP@?$CFf?5?$AA@
CONST	SEGMENT
??_C@_03JAIJOMNP@?$CFf?5?$AA@ DB '%f ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?writeOutputBitStream@@YAHHI@Z
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_bwidth$ = 8						; size = 4
_dat$ = 12						; size = 4
?writeOutputBitStream@@YAHHI@Z PROC			; writeOutputBitStream, COMDAT

; 1278 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1279 :     int ret;
; 1280 :     if( bwidth <= 0){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _bwidth$[ebp], 0
  00022	7f 0d		 jg	 SHORT $LN2@writeOutpu

; 1281 :         return -1;

  00024	83 c8 ff	 or	 eax, -1
  00027	e9 b3 01 00 00	 jmp	 $LN1@writeOutpu
  0002c	e9 ab 01 00 00	 jmp	 $LN3@writeOutpu
$LN2@writeOutpu:

; 1282 :     } else if( bwidth >= 1 && bwidth <= 8 ){

  00031	83 7d 08 01	 cmp	 DWORD PTR _bwidth$[ebp], 1
  00035	7c 2d		 jl	 SHORT $LN4@writeOutpu
  00037	83 7d 08 08	 cmp	 DWORD PTR _bwidth$[ebp], 8
  0003b	7f 27		 jg	 SHORT $LN4@writeOutpu

; 1283 :         if((ret=writeOutputBitStreamBody( bwidth , (unsigned char)dat))<0)return -1;

  0003d	0f b6 45 0c	 movzx	 eax, BYTE PTR _dat$[ebp]
  00041	50		 push	 eax
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _bwidth$[ebp]
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 ?writeOutputBitStreamBody@@YAHHE@Z ; writeOutputBitStreamBody
  0004b	83 c4 08	 add	 esp, 8
  0004e	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
  00051	83 7d f8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00055	7d 08		 jge	 SHORT $LN6@writeOutpu
  00057	83 c8 ff	 or	 eax, -1
  0005a	e9 80 01 00 00	 jmp	 $LN1@writeOutpu
$LN6@writeOutpu:

; 1284 :     } else if( bwidth > 8 && bwidth <= 16 ){

  0005f	e9 78 01 00 00	 jmp	 $LN3@writeOutpu
$LN4@writeOutpu:
  00064	83 7d 08 08	 cmp	 DWORD PTR _bwidth$[ebp], 8
  00068	7e 56		 jle	 SHORT $LN7@writeOutpu
  0006a	83 7d 08 10	 cmp	 DWORD PTR _bwidth$[ebp], 16 ; 00000010H
  0006e	7f 50		 jg	 SHORT $LN7@writeOutpu

; 1285 :         if(writeOutputBitStreamBody( 8 , (unsigned char)(dat&0xff))<0)return -1;

  00070	8b 45 0c	 mov	 eax, DWORD PTR _dat$[ebp]
  00073	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00078	50		 push	 eax
  00079	6a 08		 push	 8
  0007b	e8 00 00 00 00	 call	 ?writeOutputBitStreamBody@@YAHHE@Z ; writeOutputBitStreamBody
  00080	83 c4 08	 add	 esp, 8
  00083	85 c0		 test	 eax, eax
  00085	7d 08		 jge	 SHORT $LN9@writeOutpu
  00087	83 c8 ff	 or	 eax, -1
  0008a	e9 50 01 00 00	 jmp	 $LN1@writeOutpu
$LN9@writeOutpu:

; 1286 :         if((ret=writeOutputBitStreamBody( bwidth - 8 , ( unsigned char)((dat>>8)&0xff)))<0)return -1;

  0008f	8b 45 0c	 mov	 eax, DWORD PTR _dat$[ebp]
  00092	c1 e8 08	 shr	 eax, 8
  00095	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0009a	50		 push	 eax
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR _bwidth$[ebp]
  0009e	83 e9 08	 sub	 ecx, 8
  000a1	51		 push	 ecx
  000a2	e8 00 00 00 00	 call	 ?writeOutputBitStreamBody@@YAHHE@Z ; writeOutputBitStreamBody
  000a7	83 c4 08	 add	 esp, 8
  000aa	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
  000ad	83 7d f8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  000b1	7d 08		 jge	 SHORT $LN10@writeOutpu
  000b3	83 c8 ff	 or	 eax, -1
  000b6	e9 24 01 00 00	 jmp	 $LN1@writeOutpu
$LN10@writeOutpu:

; 1287 :     } else if( bwidth > 16 && bwidth <= 24 ){

  000bb	e9 1c 01 00 00	 jmp	 $LN3@writeOutpu
$LN7@writeOutpu:
  000c0	83 7d 08 10	 cmp	 DWORD PTR _bwidth$[ebp], 16 ; 00000010H
  000c4	7e 78		 jle	 SHORT $LN11@writeOutpu
  000c6	83 7d 08 18	 cmp	 DWORD PTR _bwidth$[ebp], 24 ; 00000018H
  000ca	7f 72		 jg	 SHORT $LN11@writeOutpu

; 1288 :         if(writeOutputBitStreamBody( 8 , (unsigned char)(dat&0xff))<0)return -1;

  000cc	8b 45 0c	 mov	 eax, DWORD PTR _dat$[ebp]
  000cf	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000d4	50		 push	 eax
  000d5	6a 08		 push	 8
  000d7	e8 00 00 00 00	 call	 ?writeOutputBitStreamBody@@YAHHE@Z ; writeOutputBitStreamBody
  000dc	83 c4 08	 add	 esp, 8
  000df	85 c0		 test	 eax, eax
  000e1	7d 08		 jge	 SHORT $LN13@writeOutpu
  000e3	83 c8 ff	 or	 eax, -1
  000e6	e9 f4 00 00 00	 jmp	 $LN1@writeOutpu
$LN13@writeOutpu:

; 1289 :         if(writeOutputBitStreamBody( 8 , (unsigned char)((dat>>8)&0xff))<0)return -1;

  000eb	8b 45 0c	 mov	 eax, DWORD PTR _dat$[ebp]
  000ee	c1 e8 08	 shr	 eax, 8
  000f1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000f6	50		 push	 eax
  000f7	6a 08		 push	 8
  000f9	e8 00 00 00 00	 call	 ?writeOutputBitStreamBody@@YAHHE@Z ; writeOutputBitStreamBody
  000fe	83 c4 08	 add	 esp, 8
  00101	85 c0		 test	 eax, eax
  00103	7d 08		 jge	 SHORT $LN14@writeOutpu
  00105	83 c8 ff	 or	 eax, -1
  00108	e9 d2 00 00 00	 jmp	 $LN1@writeOutpu
$LN14@writeOutpu:

; 1290 :         if((ret=writeOutputBitStreamBody( bwidth-16,(unsigned char)((dat>>16)&0xff)))<0)return -1;

  0010d	8b 45 0c	 mov	 eax, DWORD PTR _dat$[ebp]
  00110	c1 e8 10	 shr	 eax, 16			; 00000010H
  00113	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00118	50		 push	 eax
  00119	8b 4d 08	 mov	 ecx, DWORD PTR _bwidth$[ebp]
  0011c	83 e9 10	 sub	 ecx, 16			; 00000010H
  0011f	51		 push	 ecx
  00120	e8 00 00 00 00	 call	 ?writeOutputBitStreamBody@@YAHHE@Z ; writeOutputBitStreamBody
  00125	83 c4 08	 add	 esp, 8
  00128	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
  0012b	83 7d f8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0012f	7d 08		 jge	 SHORT $LN15@writeOutpu
  00131	83 c8 ff	 or	 eax, -1
  00134	e9 a6 00 00 00	 jmp	 $LN1@writeOutpu
$LN15@writeOutpu:

; 1291 :     } else if( bwidth > 24 && bwidth <= 32 ){

  00139	e9 9e 00 00 00	 jmp	 $LN3@writeOutpu
$LN11@writeOutpu:
  0013e	83 7d 08 18	 cmp	 DWORD PTR _bwidth$[ebp], 24 ; 00000018H
  00142	0f 8e 8f 00 00
	00		 jle	 $LN16@writeOutpu
  00148	83 7d 08 20	 cmp	 DWORD PTR _bwidth$[ebp], 32 ; 00000020H
  0014c	0f 8f 85 00 00
	00		 jg	 $LN16@writeOutpu

; 1292 :         if(writeOutputBitStreamBody( 8 , (unsigned char)(dat&0xff))<0)return -1;

  00152	8b 45 0c	 mov	 eax, DWORD PTR _dat$[ebp]
  00155	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0015a	50		 push	 eax
  0015b	6a 08		 push	 8
  0015d	e8 00 00 00 00	 call	 ?writeOutputBitStreamBody@@YAHHE@Z ; writeOutputBitStreamBody
  00162	83 c4 08	 add	 esp, 8
  00165	85 c0		 test	 eax, eax
  00167	7d 05		 jge	 SHORT $LN18@writeOutpu
  00169	83 c8 ff	 or	 eax, -1
  0016c	eb 71		 jmp	 SHORT $LN1@writeOutpu
$LN18@writeOutpu:

; 1293 :         if(writeOutputBitStreamBody( 8 , (unsigned char)((dat>>8)&0xff))<0)return -1;

  0016e	8b 45 0c	 mov	 eax, DWORD PTR _dat$[ebp]
  00171	c1 e8 08	 shr	 eax, 8
  00174	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00179	50		 push	 eax
  0017a	6a 08		 push	 8
  0017c	e8 00 00 00 00	 call	 ?writeOutputBitStreamBody@@YAHHE@Z ; writeOutputBitStreamBody
  00181	83 c4 08	 add	 esp, 8
  00184	85 c0		 test	 eax, eax
  00186	7d 05		 jge	 SHORT $LN19@writeOutpu
  00188	83 c8 ff	 or	 eax, -1
  0018b	eb 52		 jmp	 SHORT $LN1@writeOutpu
$LN19@writeOutpu:

; 1294 :         if(writeOutputBitStreamBody( 8 , (unsigned char)((dat>>16)&0xff))<0)return -1;

  0018d	8b 45 0c	 mov	 eax, DWORD PTR _dat$[ebp]
  00190	c1 e8 10	 shr	 eax, 16			; 00000010H
  00193	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00198	50		 push	 eax
  00199	6a 08		 push	 8
  0019b	e8 00 00 00 00	 call	 ?writeOutputBitStreamBody@@YAHHE@Z ; writeOutputBitStreamBody
  001a0	83 c4 08	 add	 esp, 8
  001a3	85 c0		 test	 eax, eax
  001a5	7d 05		 jge	 SHORT $LN20@writeOutpu
  001a7	83 c8 ff	 or	 eax, -1
  001aa	eb 33		 jmp	 SHORT $LN1@writeOutpu
$LN20@writeOutpu:

; 1295 :         if((ret=writeOutputBitStreamBody( bwidth-24,(unsigned char)((dat>>24)&0xff)))<0)return -1;

  001ac	8b 45 0c	 mov	 eax, DWORD PTR _dat$[ebp]
  001af	c1 e8 18	 shr	 eax, 24			; 00000018H
  001b2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001b7	50		 push	 eax
  001b8	8b 4d 08	 mov	 ecx, DWORD PTR _bwidth$[ebp]
  001bb	83 e9 18	 sub	 ecx, 24			; 00000018H
  001be	51		 push	 ecx
  001bf	e8 00 00 00 00	 call	 ?writeOutputBitStreamBody@@YAHHE@Z ; writeOutputBitStreamBody
  001c4	83 c4 08	 add	 esp, 8
  001c7	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
  001ca	83 7d f8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  001ce	7d 05		 jge	 SHORT $LN21@writeOutpu
  001d0	83 c8 ff	 or	 eax, -1
  001d3	eb 0a		 jmp	 SHORT $LN1@writeOutpu
$LN21@writeOutpu:

; 1296 :     } else {

  001d5	eb 05		 jmp	 SHORT $LN3@writeOutpu
$LN16@writeOutpu:

; 1297 :         return -1;

  001d7	83 c8 ff	 or	 eax, -1
  001da	eb 03		 jmp	 SHORT $LN1@writeOutpu
$LN3@writeOutpu:

; 1298 :     }
; 1299 :     return ret;

  001dc	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
$LN1@writeOutpu:

; 1300 : }

  001df	5f		 pop	 edi
  001e0	5e		 pop	 esi
  001e1	5b		 pop	 ebx
  001e2	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  001e8	3b ec		 cmp	 ebp, esp
  001ea	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ef	8b e5		 mov	 esp, ebp
  001f1	5d		 pop	 ebp
  001f2	c3		 ret	 0
?writeOutputBitStream@@YAHHI@Z ENDP			; writeOutputBitStream
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?writeOutputBitStreamBody@@YAHHE@Z
_TEXT	SEGMENT
_byteaddr$ = -20					; size = 4
_mod$ = -8						; size = 4
_bwidth$ = 8						; size = 4
_b$ = 12						; size = 1
?writeOutputBitStreamBody@@YAHHE@Z PROC			; writeOutputBitStreamBody, COMDAT

; 1261 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1262 :     int mod = bitstream_bitaddr % 8;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bitstream_bitaddr@@3HA ; bitstream_bitaddr
  00023	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00028	79 05		 jns	 SHORT $LN4@writeOutpu
  0002a	48		 dec	 eax
  0002b	83 c8 f8	 or	 eax, -8			; fffffff8H
  0002e	40		 inc	 eax
$LN4@writeOutpu:
  0002f	89 45 f8	 mov	 DWORD PTR _mod$[ebp], eax

; 1263 :     int byteaddr = bitstream_bitaddr / 8;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bitstream_bitaddr@@3HA ; bitstream_bitaddr
  00037	99		 cdq
  00038	83 e2 07	 and	 edx, 7
  0003b	03 c2		 add	 eax, edx
  0003d	c1 f8 03	 sar	 eax, 3
  00040	89 45 ec	 mov	 DWORD PTR _byteaddr$[ebp], eax

; 1264 :     /* return error if excess */
; 1265 :     if( bitstream_maxbyte <= (byteaddr+1)) return -1;

  00043	8b 45 ec	 mov	 eax, DWORD PTR _byteaddr$[ebp]
  00046	83 c0 01	 add	 eax, 1
  00049	39 05 00 00 00
	00		 cmp	 DWORD PTR ?bitstream_maxbyte@@3HA, eax ; bitstream_maxbyte
  0004f	7f 08		 jg	 SHORT $LN2@writeOutpu
  00051	83 c8 ff	 or	 eax, -1
  00054	e9 c2 00 00 00	 jmp	 $LN1@writeOutpu
$LN2@writeOutpu:

; 1266 :     bitstream_buf[byteaddr] &= lssproto_modifymask_first[mod][bwidth];

  00059	6b 45 f8 24	 imul	 eax, DWORD PTR _mod$[ebp], 36
  0005d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?bitstream_buf@@3PADA ; bitstream_buf
  00063	03 4d ec	 add	 ecx, DWORD PTR _byteaddr$[ebp]
  00066	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00069	8b 4d 08	 mov	 ecx, DWORD PTR _bwidth$[ebp]
  0006c	23 94 88 00 00
	00 00		 and	 edx, DWORD PTR ?lssproto_modifymask_first@@3PAY08HA[eax+ecx*4]
  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bitstream_buf@@3PADA ; bitstream_buf
  00078	03 45 ec	 add	 eax, DWORD PTR _byteaddr$[ebp]
  0007b	88 10		 mov	 BYTE PTR [eax], dl

; 1267 :     bitstream_buf[byteaddr] |= (b << mod) & lssproto_modifymask_first[mod][bwidth];

  0007d	0f b6 45 0c	 movzx	 eax, BYTE PTR _b$[ebp]
  00081	8b 4d f8	 mov	 ecx, DWORD PTR _mod$[ebp]
  00084	d3 e0		 shl	 eax, cl
  00086	6b 4d f8 24	 imul	 ecx, DWORD PTR _mod$[ebp], 36
  0008a	8b 55 08	 mov	 edx, DWORD PTR _bwidth$[ebp]
  0008d	23 84 91 00 00
	00 00		 and	 eax, DWORD PTR ?lssproto_modifymask_first@@3PAY08HA[ecx+edx*4]
  00094	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?bitstream_buf@@3PADA ; bitstream_buf
  0009a	03 4d ec	 add	 ecx, DWORD PTR _byteaddr$[ebp]
  0009d	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000a0	0b d0		 or	 edx, eax
  000a2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bitstream_buf@@3PADA ; bitstream_buf
  000a7	03 45 ec	 add	 eax, DWORD PTR _byteaddr$[ebp]
  000aa	88 10		 mov	 BYTE PTR [eax], dl

; 1268 :     bitstream_buf[byteaddr+1] &= lssproto_modifymask_second[mod][bwidth];

  000ac	6b 45 f8 24	 imul	 eax, DWORD PTR _mod$[ebp], 36
  000b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?bitstream_buf@@3PADA ; bitstream_buf
  000b6	03 4d ec	 add	 ecx, DWORD PTR _byteaddr$[ebp]
  000b9	0f be 51 01	 movsx	 edx, BYTE PTR [ecx+1]
  000bd	8b 4d 08	 mov	 ecx, DWORD PTR _bwidth$[ebp]
  000c0	23 94 88 00 00
	00 00		 and	 edx, DWORD PTR ?lssproto_modifymask_second@@3PAY08HA[eax+ecx*4]
  000c7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bitstream_buf@@3PADA ; bitstream_buf
  000cc	03 45 ec	 add	 eax, DWORD PTR _byteaddr$[ebp]
  000cf	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 1269 :     bitstream_buf[byteaddr+1] |= (b>>(8-mod))& lssproto_modifymask_second[mod][bwidth];

  000d2	0f b6 45 0c	 movzx	 eax, BYTE PTR _b$[ebp]
  000d6	b9 08 00 00 00	 mov	 ecx, 8
  000db	2b 4d f8	 sub	 ecx, DWORD PTR _mod$[ebp]
  000de	d3 f8		 sar	 eax, cl
  000e0	6b 4d f8 24	 imul	 ecx, DWORD PTR _mod$[ebp], 36
  000e4	8b 55 08	 mov	 edx, DWORD PTR _bwidth$[ebp]
  000e7	23 84 91 00 00
	00 00		 and	 eax, DWORD PTR ?lssproto_modifymask_second@@3PAY08HA[ecx+edx*4]
  000ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?bitstream_buf@@3PADA ; bitstream_buf
  000f4	03 4d ec	 add	 ecx, DWORD PTR _byteaddr$[ebp]
  000f7	0f be 51 01	 movsx	 edx, BYTE PTR [ecx+1]
  000fb	0b d0		 or	 edx, eax
  000fd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bitstream_buf@@3PADA ; bitstream_buf
  00102	03 45 ec	 add	 eax, DWORD PTR _byteaddr$[ebp]
  00105	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 1270 :     bitstream_bitaddr += bwidth;

  00108	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bitstream_bitaddr@@3HA ; bitstream_bitaddr
  0010d	03 45 08	 add	 eax, DWORD PTR _bwidth$[ebp]
  00110	a3 00 00 00 00	 mov	 DWORD PTR ?bitstream_bitaddr@@3HA, eax ; bitstream_bitaddr

; 1271 :     return byteaddr+1;

  00115	8b 45 ec	 mov	 eax, DWORD PTR _byteaddr$[ebp]
  00118	83 c0 01	 add	 eax, 1
$LN1@writeOutpu:

; 1272 : }

  0011b	5f		 pop	 edi
  0011c	5e		 pop	 esi
  0011d	5b		 pop	 ebx
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c3		 ret	 0
?writeOutputBitStreamBody@@YAHHE@Z ENDP			; writeOutputBitStreamBody
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?readInputBitStream@@YAIH@Z
_TEXT	SEGMENT
_forth$1 = -104						; size = 4
_third$2 = -92						; size = 4
_second$3 = -80						; size = 4
_first$4 = -68						; size = 4
_third$5 = -56						; size = 4
_second$6 = -44						; size = 4
_first$7 = -32						; size = 4
_second$8 = -20						; size = 4
_first$9 = -8						; size = 4
_bwidth$ = 8						; size = 4
?readInputBitStream@@YAIH@Z PROC			; readInputBitStream, COMDAT

; 1233 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd d4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-300]
  00012	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1234 :     if( bwidth <= 0 ){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _bwidth$[ebp], 0
  00022	7f 0c		 jg	 SHORT $LN2@readInputB

; 1235 :         return 0;

  00024	33 c0		 xor	 eax, eax
  00026	e9 14 01 00 00	 jmp	 $LN1@readInputB
  0002b	e9 0d 01 00 00	 jmp	 $LN3@readInputB
$LN2@readInputB:

; 1236 :     } else if( bwidth >= 1 && bwidth <= 8 ){

  00030	83 7d 08 01	 cmp	 DWORD PTR _bwidth$[ebp], 1
  00034	7c 1c		 jl	 SHORT $LN4@readInputB
  00036	83 7d 08 08	 cmp	 DWORD PTR _bwidth$[ebp], 8
  0003a	7f 16		 jg	 SHORT $LN4@readInputB

; 1237 :         return readInputBitStreamBody( bwidth );

  0003c	8b 45 08	 mov	 eax, DWORD PTR _bwidth$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?readInputBitStreamBody@@YAIH@Z ; readInputBitStreamBody
  00045	83 c4 04	 add	 esp, 4
  00048	e9 f2 00 00 00	 jmp	 $LN1@readInputB
  0004d	e9 eb 00 00 00	 jmp	 $LN3@readInputB
$LN4@readInputB:

; 1238 :     } else if( bwidth >= 9 && bwidth <= 16 ){

  00052	83 7d 08 09	 cmp	 DWORD PTR _bwidth$[ebp], 9
  00056	7c 38		 jl	 SHORT $LN6@readInputB
  00058	83 7d 08 10	 cmp	 DWORD PTR _bwidth$[ebp], 16 ; 00000010H
  0005c	7f 32		 jg	 SHORT $LN6@readInputB

; 1239 :         unsigned int first = readInputBitStreamBody(8);

  0005e	6a 08		 push	 8
  00060	e8 00 00 00 00	 call	 ?readInputBitStreamBody@@YAIH@Z ; readInputBitStreamBody
  00065	83 c4 04	 add	 esp, 4
  00068	89 45 f8	 mov	 DWORD PTR _first$9[ebp], eax

; 1240 :         unsigned int second = readInputBitStreamBody( bwidth-8);

  0006b	8b 45 08	 mov	 eax, DWORD PTR _bwidth$[ebp]
  0006e	83 e8 08	 sub	 eax, 8
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ?readInputBitStreamBody@@YAIH@Z ; readInputBitStreamBody
  00077	83 c4 04	 add	 esp, 4
  0007a	89 45 ec	 mov	 DWORD PTR _second$8[ebp], eax

; 1241 :         return first + (second << 8 );

  0007d	8b 45 ec	 mov	 eax, DWORD PTR _second$8[ebp]
  00080	c1 e0 08	 shl	 eax, 8
  00083	03 45 f8	 add	 eax, DWORD PTR _first$9[ebp]
  00086	e9 b4 00 00 00	 jmp	 $LN1@readInputB
  0008b	e9 ad 00 00 00	 jmp	 $LN3@readInputB
$LN6@readInputB:

; 1242 :     } else if( bwidth >= 17 && bwidth <= 24 ){

  00090	83 7d 08 11	 cmp	 DWORD PTR _bwidth$[ebp], 17 ; 00000011H
  00094	7c 47		 jl	 SHORT $LN8@readInputB
  00096	83 7d 08 18	 cmp	 DWORD PTR _bwidth$[ebp], 24 ; 00000018H
  0009a	7f 41		 jg	 SHORT $LN8@readInputB

; 1243 :         unsigned int first = readInputBitStreamBody(8);

  0009c	6a 08		 push	 8
  0009e	e8 00 00 00 00	 call	 ?readInputBitStreamBody@@YAIH@Z ; readInputBitStreamBody
  000a3	83 c4 04	 add	 esp, 4
  000a6	89 45 e0	 mov	 DWORD PTR _first$7[ebp], eax

; 1244 :         unsigned int second = readInputBitStreamBody(8);

  000a9	6a 08		 push	 8
  000ab	e8 00 00 00 00	 call	 ?readInputBitStreamBody@@YAIH@Z ; readInputBitStreamBody
  000b0	83 c4 04	 add	 esp, 4
  000b3	89 45 d4	 mov	 DWORD PTR _second$6[ebp], eax

; 1245 :         unsigned int third = readInputBitStreamBody(bwidth-8);

  000b6	8b 45 08	 mov	 eax, DWORD PTR _bwidth$[ebp]
  000b9	83 e8 08	 sub	 eax, 8
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 ?readInputBitStreamBody@@YAIH@Z ; readInputBitStreamBody
  000c2	83 c4 04	 add	 esp, 4
  000c5	89 45 c8	 mov	 DWORD PTR _third$5[ebp], eax

; 1246 :         return first + ( second << 8 ) + ( third << 16 );

  000c8	8b 45 d4	 mov	 eax, DWORD PTR _second$6[ebp]
  000cb	c1 e0 08	 shl	 eax, 8
  000ce	03 45 e0	 add	 eax, DWORD PTR _first$7[ebp]
  000d1	8b 4d c8	 mov	 ecx, DWORD PTR _third$5[ebp]
  000d4	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000d7	03 c1		 add	 eax, ecx
  000d9	eb 64		 jmp	 SHORT $LN1@readInputB
  000db	eb 60		 jmp	 SHORT $LN3@readInputB
$LN8@readInputB:

; 1247 :     } else if( bwidth >= 25 && bwidth <= 32 ){

  000dd	83 7d 08 19	 cmp	 DWORD PTR _bwidth$[ebp], 25 ; 00000019H
  000e1	7c 5a		 jl	 SHORT $LN3@readInputB
  000e3	83 7d 08 20	 cmp	 DWORD PTR _bwidth$[ebp], 32 ; 00000020H
  000e7	7f 54		 jg	 SHORT $LN3@readInputB

; 1248 :         unsigned int first = readInputBitStreamBody(8);

  000e9	6a 08		 push	 8
  000eb	e8 00 00 00 00	 call	 ?readInputBitStreamBody@@YAIH@Z ; readInputBitStreamBody
  000f0	83 c4 04	 add	 esp, 4
  000f3	89 45 bc	 mov	 DWORD PTR _first$4[ebp], eax

; 1249 :         unsigned int second = readInputBitStreamBody(8);

  000f6	6a 08		 push	 8
  000f8	e8 00 00 00 00	 call	 ?readInputBitStreamBody@@YAIH@Z ; readInputBitStreamBody
  000fd	83 c4 04	 add	 esp, 4
  00100	89 45 b0	 mov	 DWORD PTR _second$3[ebp], eax

; 1250 :         unsigned int third = readInputBitStreamBody(8);

  00103	6a 08		 push	 8
  00105	e8 00 00 00 00	 call	 ?readInputBitStreamBody@@YAIH@Z ; readInputBitStreamBody
  0010a	83 c4 04	 add	 esp, 4
  0010d	89 45 a4	 mov	 DWORD PTR _third$2[ebp], eax

; 1251 :         unsigned int forth = readInputBitStreamBody(bwidth-8);

  00110	8b 45 08	 mov	 eax, DWORD PTR _bwidth$[ebp]
  00113	83 e8 08	 sub	 eax, 8
  00116	50		 push	 eax
  00117	e8 00 00 00 00	 call	 ?readInputBitStreamBody@@YAIH@Z ; readInputBitStreamBody
  0011c	83 c4 04	 add	 esp, 4
  0011f	89 45 98	 mov	 DWORD PTR _forth$1[ebp], eax

; 1252 :         return first + ( second << 8 ) + ( third << 16 ) + ( forth << 24 );

  00122	8b 45 b0	 mov	 eax, DWORD PTR _second$3[ebp]
  00125	c1 e0 08	 shl	 eax, 8
  00128	03 45 bc	 add	 eax, DWORD PTR _first$4[ebp]
  0012b	8b 4d a4	 mov	 ecx, DWORD PTR _third$2[ebp]
  0012e	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00131	03 c1		 add	 eax, ecx
  00133	8b 55 98	 mov	 edx, DWORD PTR _forth$1[ebp]
  00136	c1 e2 18	 shl	 edx, 24			; 00000018H
  00139	03 c2		 add	 eax, edx
  0013b	eb 02		 jmp	 SHORT $LN1@readInputB
$LN3@readInputB:

; 1253 :     }
; 1254 : 	return 0;

  0013d	33 c0		 xor	 eax, eax
$LN1@readInputB:

; 1255 : }

  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx
  00142	81 c4 2c 01 00
	00		 add	 esp, 300		; 0000012cH
  00148	3b ec		 cmp	 ebp, esp
  0014a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014f	8b e5		 mov	 esp, ebp
  00151	5d		 pop	 ebp
  00152	c3		 ret	 0
?readInputBitStream@@YAIH@Z ENDP			; readInputBitStream
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?readInputBitStreamBody@@YAIH@Z
_TEXT	SEGMENT
_b2$1 = -44						; size = 4
_b1$2 = -32						; size = 4
_byteaddr$ = -20					; size = 4
_mod$ = -8						; size = 4
_bwidth$ = 8						; size = 4
?readInputBitStreamBody@@YAIH@Z PROC			; readInputBitStreamBody, COMDAT

; 1214 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1215 :     int mod = bitstream_bitaddr % 8;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bitstream_bitaddr@@3HA ; bitstream_bitaddr
  00023	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00028	79 05		 jns	 SHORT $LN6@readInputB
  0002a	48		 dec	 eax
  0002b	83 c8 f8	 or	 eax, -8			; fffffff8H
  0002e	40		 inc	 eax
$LN6@readInputB:
  0002f	89 45 f8	 mov	 DWORD PTR _mod$[ebp], eax

; 1216 :     int byteaddr = bitstream_bitaddr / 8;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bitstream_bitaddr@@3HA ; bitstream_bitaddr
  00037	99		 cdq
  00038	83 e2 07	 and	 edx, 7
  0003b	03 c2		 add	 eax, edx
  0003d	c1 f8 03	 sar	 eax, 3
  00040	89 45 ec	 mov	 DWORD PTR _byteaddr$[ebp], eax

; 1217 :     /* return if excess */
; 1218 :     if( byteaddr >= bitstream_maxbyte)return 0;

  00043	8b 45 ec	 mov	 eax, DWORD PTR _byteaddr$[ebp]
  00046	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?bitstream_maxbyte@@3HA ; bitstream_maxbyte
  0004c	7c 04		 jl	 SHORT $LN2@readInputB
  0004e	33 c0		 xor	 eax, eax
  00050	eb 6d		 jmp	 SHORT $LN1@readInputB
$LN2@readInputB:

; 1219 :     if( bwidth >= 1 && bwidth <= 8){

  00052	83 7d 08 01	 cmp	 DWORD PTR _bwidth$[ebp], 1
  00056	7c 65		 jl	 SHORT $LN3@readInputB
  00058	83 7d 08 08	 cmp	 DWORD PTR _bwidth$[ebp], 8
  0005c	7f 5f		 jg	 SHORT $LN3@readInputB

; 1220 :         int b1 = (( bitstream_buf[byteaddr] & lssproto_modifymask_first[mod][bwidth] )>>mod);

  0005e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bitstream_buf@@3PADA ; bitstream_buf
  00063	03 45 ec	 add	 eax, DWORD PTR _byteaddr$[ebp]
  00066	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00069	6b 45 f8 24	 imul	 eax, DWORD PTR _mod$[ebp], 36
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR _bwidth$[ebp]
  00070	23 94 88 00 00
	00 00		 and	 edx, DWORD PTR ?lssproto_modifymask_first@@3PAY08HA[eax+ecx*4]
  00077	8b 4d f8	 mov	 ecx, DWORD PTR _mod$[ebp]
  0007a	d3 fa		 sar	 edx, cl
  0007c	89 55 e0	 mov	 DWORD PTR _b1$2[ebp], edx

; 1221 :         int b2 = (( bitstream_buf[byteaddr+1] & lssproto_modifymask_second[mod][bwidth])<<(8-mod));

  0007f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bitstream_buf@@3PADA ; bitstream_buf
  00084	03 45 ec	 add	 eax, DWORD PTR _byteaddr$[ebp]
  00087	0f be 50 01	 movsx	 edx, BYTE PTR [eax+1]
  0008b	6b 45 f8 24	 imul	 eax, DWORD PTR _mod$[ebp], 36
  0008f	8b 4d 08	 mov	 ecx, DWORD PTR _bwidth$[ebp]
  00092	23 94 88 00 00
	00 00		 and	 edx, DWORD PTR ?lssproto_modifymask_second@@3PAY08HA[eax+ecx*4]
  00099	b9 08 00 00 00	 mov	 ecx, 8
  0009e	2b 4d f8	 sub	 ecx, DWORD PTR _mod$[ebp]
  000a1	d3 e2		 shl	 edx, cl
  000a3	89 55 d4	 mov	 DWORD PTR _b2$1[ebp], edx

; 1222 :         bitstream_bitaddr += bwidth;

  000a6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bitstream_bitaddr@@3HA ; bitstream_bitaddr
  000ab	03 45 08	 add	 eax, DWORD PTR _bwidth$[ebp]
  000ae	a3 00 00 00 00	 mov	 DWORD PTR ?bitstream_bitaddr@@3HA, eax ; bitstream_bitaddr

; 1223 :         return  b1 | b2;

  000b3	8b 45 e0	 mov	 eax, DWORD PTR _b1$2[ebp]
  000b6	0b 45 d4	 or	 eax, DWORD PTR _b2$1[ebp]
  000b9	eb 04		 jmp	 SHORT $LN1@readInputB

; 1224 :     } else {

  000bb	eb 02		 jmp	 SHORT $LN1@readInputB
$LN3@readInputB:

; 1225 :         return 0;

  000bd	33 c0		 xor	 eax, eax
$LN1@readInputB:

; 1226 :     }
; 1227 : }

  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx
  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c3		 ret	 0
?readInputBitStreamBody@@YAIH@Z ENDP			; readInputBitStreamBody
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?initInputBitStream@@YAHPADH@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_buflen$ = 12						; size = 4
?initInputBitStream@@YAHPADH@Z PROC			; initInputBitStream, COMDAT

; 1203 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1204 :     bitstream_bitaddr = 0;

  0001e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bitstream_bitaddr@@3HA, 0 ; bitstream_bitaddr

; 1205 :     bitstream_maxbyte = buflen;

  00028	8b 45 0c	 mov	 eax, DWORD PTR _buflen$[ebp]
  0002b	a3 00 00 00 00	 mov	 DWORD PTR ?bitstream_maxbyte@@3HA, eax ; bitstream_maxbyte

; 1206 :     bitstream_buf = buf;

  00030	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00033	a3 00 00 00 00	 mov	 DWORD PTR ?bitstream_buf@@3PADA, eax ; bitstream_buf

; 1207 :     return 0;

  00038	33 c0		 xor	 eax, eax

; 1208 : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?initInputBitStream@@YAHPADH@Z ENDP			; initInputBitStream
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?initOutputBitStream@@YAHPADH@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_buflen$ = 12						; size = 4
?initOutputBitStream@@YAHPADH@Z PROC			; initOutputBitStream, COMDAT

; 1194 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1195 :     bitstream_bitaddr = 0;

  0001e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bitstream_bitaddr@@3HA, 0 ; bitstream_bitaddr

; 1196 :     bitstream_maxbyte = buflen;

  00028	8b 45 0c	 mov	 eax, DWORD PTR _buflen$[ebp]
  0002b	a3 00 00 00 00	 mov	 DWORD PTR ?bitstream_maxbyte@@3HA, eax ; bitstream_maxbyte

; 1197 :     bitstream_buf = buf;

  00030	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00033	a3 00 00 00 00	 mov	 DWORD PTR ?bitstream_buf@@3PADA, eax ; bitstream_buf

; 1198 :     memset( buf,0, buflen);

  00038	8b 45 0c	 mov	 eax, DWORD PTR _buflen$[ebp]
  0003b	50		 push	 eax
  0003c	6a 00		 push	 0
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 _memset
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1199 :     return 0;

  0004a	33 c0		 xor	 eax, eax

; 1200 : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?initOutputBitStream@@YAHPADH@Z ENDP			; initOutputBitStream
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_jEncode@@YAXPADHH0PAHH@Z
_TEXT	SEGMENT
_i$ = -20						; size = 4
_sum$ = -5						; size = 1
_src$ = 8						; size = 4
_srclen$ = 12						; size = 4
_key$ = 16						; size = 4
_encoded$ = 20						; size = 4
_encodedlen$ = 24					; size = 4
_maxencodedlen$ = 28					; size = 4
?lssproto_jEncode@@YAXPADHH0PAHH@Z PROC			; lssproto_jEncode, COMDAT

; 868  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 869  : 	char sum=0;

  0001e	c6 45 fb 00	 mov	 BYTE PTR _sum$[ebp], 0

; 870  : 	int i;
; 871  : 	if(srclen+1 > maxencodedlen){

  00022	8b 45 0c	 mov	 eax, DWORD PTR _srclen$[ebp]
  00025	83 c0 01	 add	 eax, 1
  00028	3b 45 1c	 cmp	 eax, DWORD PTR _maxencodedlen$[ebp]
  0002b	7e 36		 jle	 SHORT $LN11@lssproto_j

; 872  : 		*encodedlen = maxencodedlen;

  0002d	8b 45 18	 mov	 eax, DWORD PTR _encodedlen$[ebp]
  00030	8b 4d 1c	 mov	 ecx, DWORD PTR _maxencodedlen$[ebp]
  00033	89 08		 mov	 DWORD PTR [eax], ecx

; 873  : 		for(i=0;i<(*encodedlen);i++)encoded[i] = src[i];

  00035	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0003c	eb 09		 jmp	 SHORT $LN4@lssproto_j
$LN2@lssproto_j:
  0003e	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00041	83 c0 01	 add	 eax, 1
  00044	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN4@lssproto_j:
  00047	8b 45 18	 mov	 eax, DWORD PTR _encodedlen$[ebp]
  0004a	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  0004d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0004f	7d 12		 jge	 SHORT $LN11@lssproto_j
  00051	8b 45 14	 mov	 eax, DWORD PTR _encoded$[ebp]
  00054	03 45 ec	 add	 eax, DWORD PTR _i$[ebp]
  00057	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  0005a	03 4d ec	 add	 ecx, DWORD PTR _i$[ebp]
  0005d	8a 11		 mov	 dl, BYTE PTR [ecx]
  0005f	88 10		 mov	 BYTE PTR [eax], dl
  00061	eb db		 jmp	 SHORT $LN2@lssproto_j
$LN11@lssproto_j:

; 874  : 	}
; 875  : 	if(srclen+1 <= maxencodedlen){

  00063	8b 45 0c	 mov	 eax, DWORD PTR _srclen$[ebp]
  00066	83 c0 01	 add	 eax, 1
  00069	3b 45 1c	 cmp	 eax, DWORD PTR _maxencodedlen$[ebp]
  0006c	0f 8f 4d 01 00
	00		 jg	 $LN1@lssproto_j

; 876  : 		*encodedlen=srclen+1;

  00072	8b 45 0c	 mov	 eax, DWORD PTR _srclen$[ebp]
  00075	83 c0 01	 add	 eax, 1
  00078	8b 4d 18	 mov	 ecx, DWORD PTR _encodedlen$[ebp]
  0007b	89 01		 mov	 DWORD PTR [ecx], eax

; 877  : 		for(i=0;i<srclen;i++){

  0007d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00084	eb 09		 jmp	 SHORT $LN7@lssproto_j
$LN5@lssproto_j:
  00086	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00089	83 c0 01	 add	 eax, 1
  0008c	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN7@lssproto_j:
  0008f	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00092	3b 45 0c	 cmp	 eax, DWORD PTR _srclen$[ebp]
  00095	7d 66		 jge	 SHORT $LN6@lssproto_j

; 878  : 			sum = sum + src[i];

  00097	0f be 45 fb	 movsx	 eax, BYTE PTR _sum$[ebp]
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  0009e	03 4d ec	 add	 ecx, DWORD PTR _i$[ebp]
  000a1	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000a4	03 c2		 add	 eax, edx
  000a6	88 45 fb	 mov	 BYTE PTR _sum$[ebp], al

; 879  : 			if(((key%7) == (i%5))||((key%2) == (i%2))) src[i] = ~src[i];

  000a9	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  000ac	99		 cdq
  000ad	b9 07 00 00 00	 mov	 ecx, 7
  000b2	f7 f9		 idiv	 ecx
  000b4	8b ca		 mov	 ecx, edx
  000b6	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000b9	99		 cdq
  000ba	be 05 00 00 00	 mov	 esi, 5
  000bf	f7 fe		 idiv	 esi
  000c1	3b ca		 cmp	 ecx, edx
  000c3	74 23		 je	 SHORT $LN14@lssproto_j
  000c5	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  000c8	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  000cd	79 05		 jns	 SHORT $LN19@lssproto_j
  000cf	48		 dec	 eax
  000d0	83 c8 fe	 or	 eax, -2			; fffffffeH
  000d3	40		 inc	 eax
$LN19@lssproto_j:
  000d4	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  000d7	81 e1 01 00 00
	80		 and	 ecx, -2147483647	; 80000001H
  000dd	79 05		 jns	 SHORT $LN20@lssproto_j
  000df	49		 dec	 ecx
  000e0	83 c9 fe	 or	 ecx, -2			; fffffffeH
  000e3	41		 inc	 ecx
$LN20@lssproto_j:
  000e4	3b c1		 cmp	 eax, ecx
  000e6	75 13		 jne	 SHORT $LN13@lssproto_j
$LN14@lssproto_j:
  000e8	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  000eb	03 45 ec	 add	 eax, DWORD PTR _i$[ebp]
  000ee	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000f1	f7 d1		 not	 ecx
  000f3	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  000f6	03 55 ec	 add	 edx, DWORD PTR _i$[ebp]
  000f9	88 0a		 mov	 BYTE PTR [edx], cl
$LN13@lssproto_j:

; 880  : 		}

  000fb	eb 89		 jmp	 SHORT $LN5@lssproto_j
$LN6@lssproto_j:

; 881  : 		for(i=0;i<(*encodedlen);i++){

  000fd	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00104	eb 09		 jmp	 SHORT $LN10@lssproto_j
$LN8@lssproto_j:
  00106	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00109	83 c0 01	 add	 eax, 1
  0010c	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN10@lssproto_j:
  0010f	8b 45 18	 mov	 eax, DWORD PTR _encodedlen$[ebp]
  00112	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  00115	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00117	0f 8d a2 00 00
	00		 jge	 $LN1@lssproto_j

; 882  : 			if(abs((key%srclen)) > i) encoded[i] = src[i] + sum*((i*i)%3); 

  0011d	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  00120	99		 cdq
  00121	f7 7d 0c	 idiv	 DWORD PTR _srclen$[ebp]
  00124	52		 push	 edx
  00125	e8 00 00 00 00	 call	 _abs
  0012a	83 c4 04	 add	 esp, 4
  0012d	3b 45 ec	 cmp	 eax, DWORD PTR _i$[ebp]
  00130	7e 29		 jle	 SHORT $LN15@lssproto_j
  00132	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00135	03 45 ec	 add	 eax, DWORD PTR _i$[ebp]
  00138	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0013b	0f be 75 fb	 movsx	 esi, BYTE PTR _sum$[ebp]
  0013f	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00142	0f af 45 ec	 imul	 eax, DWORD PTR _i$[ebp]
  00146	99		 cdq
  00147	bf 03 00 00 00	 mov	 edi, 3
  0014c	f7 ff		 idiv	 edi
  0014e	0f af f2	 imul	 esi, edx
  00151	03 ce		 add	 ecx, esi
  00153	8b 55 14	 mov	 edx, DWORD PTR _encoded$[ebp]
  00156	03 55 ec	 add	 edx, DWORD PTR _i$[ebp]
  00159	88 0a		 mov	 BYTE PTR [edx], cl
$LN15@lssproto_j:

; 883  : 			if(abs((key%srclen)) == i) encoded[i] = sum;

  0015b	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  0015e	99		 cdq
  0015f	f7 7d 0c	 idiv	 DWORD PTR _srclen$[ebp]
  00162	52		 push	 edx
  00163	e8 00 00 00 00	 call	 _abs
  00168	83 c4 04	 add	 esp, 4
  0016b	3b 45 ec	 cmp	 eax, DWORD PTR _i$[ebp]
  0016e	75 0b		 jne	 SHORT $LN16@lssproto_j
  00170	8b 45 14	 mov	 eax, DWORD PTR _encoded$[ebp]
  00173	03 45 ec	 add	 eax, DWORD PTR _i$[ebp]
  00176	8a 4d fb	 mov	 cl, BYTE PTR _sum$[ebp]
  00179	88 08		 mov	 BYTE PTR [eax], cl
$LN16@lssproto_j:

; 884  : 			if(abs((key%srclen)) < i) encoded[i] = src[i-1] + sum*((i*i)%7);	

  0017b	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  0017e	99		 cdq
  0017f	f7 7d 0c	 idiv	 DWORD PTR _srclen$[ebp]
  00182	52		 push	 edx
  00183	e8 00 00 00 00	 call	 _abs
  00188	83 c4 04	 add	 esp, 4
  0018b	3b 45 ec	 cmp	 eax, DWORD PTR _i$[ebp]
  0018e	7d 2a		 jge	 SHORT $LN17@lssproto_j
  00190	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00193	03 45 ec	 add	 eax, DWORD PTR _i$[ebp]
  00196	0f be 48 ff	 movsx	 ecx, BYTE PTR [eax-1]
  0019a	0f be 75 fb	 movsx	 esi, BYTE PTR _sum$[ebp]
  0019e	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  001a1	0f af 45 ec	 imul	 eax, DWORD PTR _i$[ebp]
  001a5	99		 cdq
  001a6	bf 07 00 00 00	 mov	 edi, 7
  001ab	f7 ff		 idiv	 edi
  001ad	0f af f2	 imul	 esi, edx
  001b0	03 ce		 add	 ecx, esi
  001b2	8b 55 14	 mov	 edx, DWORD PTR _encoded$[ebp]
  001b5	03 55 ec	 add	 edx, DWORD PTR _i$[ebp]
  001b8	88 0a		 mov	 BYTE PTR [edx], cl
$LN17@lssproto_j:

; 885  : 		}

  001ba	e9 47 ff ff ff	 jmp	 $LN8@lssproto_j
$LN1@lssproto_j:

; 886  : 	}
; 887  : }

  001bf	5f		 pop	 edi
  001c0	5e		 pop	 esi
  001c1	5b		 pop	 ebx
  001c2	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  001c8	3b ec		 cmp	 ebp, esp
  001ca	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001cf	8b e5		 mov	 esp, ebp
  001d1	5d		 pop	 ebp
  001d2	c3		 ret	 0
?lssproto_jEncode@@YAXPADHH0PAHH@Z ENDP			; lssproto_jEncode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_jDecode@@YAXPADHH0PAH@Z
_TEXT	SEGMENT
_i$ = -20						; size = 4
_sum$ = -5						; size = 1
_src$ = 8						; size = 4
_srclen$ = 12						; size = 4
_key$ = 16						; size = 4
_decoded$ = 20						; size = 4
_decodedlen$ = 24					; size = 4
?lssproto_jDecode@@YAXPADHH0PAH@Z PROC			; lssproto_jDecode, COMDAT

; 889  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 890  : 	char sum=0;

  0001e	c6 45 fb 00	 mov	 BYTE PTR _sum$[ebp], 0

; 891  : 	int i;
; 892  : 	*decodedlen=srclen-1;

  00022	8b 45 0c	 mov	 eax, DWORD PTR _srclen$[ebp]
  00025	83 e8 01	 sub	 eax, 1
  00028	8b 4d 18	 mov	 ecx, DWORD PTR _decodedlen$[ebp]
  0002b	89 01		 mov	 DWORD PTR [ecx], eax

; 893  : 	if( *decodedlen == 0 ){

  0002d	8b 45 18	 mov	 eax, DWORD PTR _decodedlen$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	75 05		 jne	 SHORT $LN8@lssproto_j

; 894  : 		return;		/* return error if length is 0 */

  00035	e9 2f 01 00 00	 jmp	 $LN1@lssproto_j
$LN8@lssproto_j:

; 895  : 	}
; 896  : 	sum = src[abs(key%(*decodedlen))];

  0003a	8b 4d 18	 mov	 ecx, DWORD PTR _decodedlen$[ebp]
  0003d	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  00040	99		 cdq
  00041	f7 39		 idiv	 DWORD PTR [ecx]
  00043	52		 push	 edx
  00044	e8 00 00 00 00	 call	 _abs
  00049	83 c4 04	 add	 esp, 4
  0004c	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  0004f	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  00052	88 45 fb	 mov	 BYTE PTR _sum$[ebp], al

; 897  : 	for(i=0;i<srclen;i++){

  00055	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0005c	eb 09		 jmp	 SHORT $LN4@lssproto_j
$LN2@lssproto_j:
  0005e	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00061	83 c0 01	 add	 eax, 1
  00064	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN4@lssproto_j:
  00067	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  0006a	3b 45 0c	 cmp	 eax, DWORD PTR _srclen$[ebp]
  0006d	0f 8d 86 00 00
	00		 jge	 $LN3@lssproto_j

; 898  : 		if(abs((key%(*decodedlen))) > i) decoded[i] = src[i] - sum*((i*i)%3);

  00073	8b 4d 18	 mov	 ecx, DWORD PTR _decodedlen$[ebp]
  00076	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  00079	99		 cdq
  0007a	f7 39		 idiv	 DWORD PTR [ecx]
  0007c	52		 push	 edx
  0007d	e8 00 00 00 00	 call	 _abs
  00082	83 c4 04	 add	 esp, 4
  00085	3b 45 ec	 cmp	 eax, DWORD PTR _i$[ebp]
  00088	7e 29		 jle	 SHORT $LN9@lssproto_j
  0008a	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0008d	03 45 ec	 add	 eax, DWORD PTR _i$[ebp]
  00090	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00093	0f be 75 fb	 movsx	 esi, BYTE PTR _sum$[ebp]
  00097	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  0009a	0f af 45 ec	 imul	 eax, DWORD PTR _i$[ebp]
  0009e	99		 cdq
  0009f	bf 03 00 00 00	 mov	 edi, 3
  000a4	f7 ff		 idiv	 edi
  000a6	0f af f2	 imul	 esi, edx
  000a9	2b ce		 sub	 ecx, esi
  000ab	8b 55 14	 mov	 edx, DWORD PTR _decoded$[ebp]
  000ae	03 55 ec	 add	 edx, DWORD PTR _i$[ebp]
  000b1	88 0a		 mov	 BYTE PTR [edx], cl
$LN9@lssproto_j:

; 899  : 		if(abs((key%(*decodedlen))) < i) decoded[i-1] = src[i] - sum*((i*i)%7);

  000b3	8b 4d 18	 mov	 ecx, DWORD PTR _decodedlen$[ebp]
  000b6	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  000b9	99		 cdq
  000ba	f7 39		 idiv	 DWORD PTR [ecx]
  000bc	52		 push	 edx
  000bd	e8 00 00 00 00	 call	 _abs
  000c2	83 c4 04	 add	 esp, 4
  000c5	3b 45 ec	 cmp	 eax, DWORD PTR _i$[ebp]
  000c8	7d 2a		 jge	 SHORT $LN10@lssproto_j
  000ca	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  000cd	03 45 ec	 add	 eax, DWORD PTR _i$[ebp]
  000d0	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000d3	0f be 75 fb	 movsx	 esi, BYTE PTR _sum$[ebp]
  000d7	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000da	0f af 45 ec	 imul	 eax, DWORD PTR _i$[ebp]
  000de	99		 cdq
  000df	bf 07 00 00 00	 mov	 edi, 7
  000e4	f7 ff		 idiv	 edi
  000e6	0f af f2	 imul	 esi, edx
  000e9	2b ce		 sub	 ecx, esi
  000eb	8b 55 14	 mov	 edx, DWORD PTR _decoded$[ebp]
  000ee	03 55 ec	 add	 edx, DWORD PTR _i$[ebp]
  000f1	88 4a ff	 mov	 BYTE PTR [edx-1], cl
$LN10@lssproto_j:

; 900  : 	}

  000f4	e9 65 ff ff ff	 jmp	 $LN2@lssproto_j
$LN3@lssproto_j:

; 901  : 	for(i=0;i<(*decodedlen);i++){

  000f9	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00100	eb 09		 jmp	 SHORT $LN7@lssproto_j
$LN5@lssproto_j:
  00102	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00105	83 c0 01	 add	 eax, 1
  00108	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN7@lssproto_j:
  0010b	8b 45 18	 mov	 eax, DWORD PTR _decodedlen$[ebp]
  0010e	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  00111	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00113	7d 54		 jge	 SHORT $LN1@lssproto_j

; 902  : 		if(((key%7) == (i%5))||((key%2) == (i%2)))decoded[i] = ~decoded[i];

  00115	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  00118	99		 cdq
  00119	b9 07 00 00 00	 mov	 ecx, 7
  0011e	f7 f9		 idiv	 ecx
  00120	8b ca		 mov	 ecx, edx
  00122	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00125	99		 cdq
  00126	be 05 00 00 00	 mov	 esi, 5
  0012b	f7 fe		 idiv	 esi
  0012d	3b ca		 cmp	 ecx, edx
  0012f	74 23		 je	 SHORT $LN12@lssproto_j
  00131	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  00134	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00139	79 05		 jns	 SHORT $LN14@lssproto_j
  0013b	48		 dec	 eax
  0013c	83 c8 fe	 or	 eax, -2			; fffffffeH
  0013f	40		 inc	 eax
$LN14@lssproto_j:
  00140	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  00143	81 e1 01 00 00
	80		 and	 ecx, -2147483647	; 80000001H
  00149	79 05		 jns	 SHORT $LN15@lssproto_j
  0014b	49		 dec	 ecx
  0014c	83 c9 fe	 or	 ecx, -2			; fffffffeH
  0014f	41		 inc	 ecx
$LN15@lssproto_j:
  00150	3b c1		 cmp	 eax, ecx
  00152	75 13		 jne	 SHORT $LN11@lssproto_j
$LN12@lssproto_j:
  00154	8b 45 14	 mov	 eax, DWORD PTR _decoded$[ebp]
  00157	03 45 ec	 add	 eax, DWORD PTR _i$[ebp]
  0015a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0015d	f7 d1		 not	 ecx
  0015f	8b 55 14	 mov	 edx, DWORD PTR _decoded$[ebp]
  00162	03 55 ec	 add	 edx, DWORD PTR _i$[ebp]
  00165	88 0a		 mov	 BYTE PTR [edx], cl
$LN11@lssproto_j:

; 903  : 	}

  00167	eb 99		 jmp	 SHORT $LN5@lssproto_j
$LN1@lssproto_j:

; 904  : }

  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	5b		 pop	 ebx
  0016c	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00172	3b ec		 cmp	 ebp, esp
  00174	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00179	8b e5		 mov	 esp, ebp
  0017b	5d		 pop	 ebp
  0017c	c3		 ret	 0
?lssproto_jDecode@@YAXPADHH0PAH@Z ENDP			; lssproto_jDecode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_decode64@@YAHPAE0@Z
_TEXT	SEGMENT
_i$ = -116						; size = 4
_address$ = -104					; size = 4
_use_bytes$ = -92					; size = 4
_out3$ = -77						; size = 1
_out2$ = -65						; size = 1
_out1$ = -53						; size = 1
_in4$ = -41						; size = 1
_in3$ = -29						; size = 1
_in2$ = -17						; size = 1
_in1$ = -5						; size = 1
_in$ = 8						; size = 4
_out$ = 12						; size = 4
?lssproto_decode64@@YAHPAE0@Z PROC			; lssproto_decode64, COMDAT

; 818  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 38 01 00
	00		 sub	 esp, 312		; 00000138H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd c8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-312]
  00012	b9 4e 00 00 00	 mov	 ecx, 78			; 0000004eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 819  :     unsigned char in1 , in2 , in3 , in4;
; 820  :     unsigned char out1 , out2 , out3;
; 821  :     int use_bytes;
; 822  :     int address= 0;

  0001e	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _address$[ebp], 0

; 823  :     int i;
; 824  :     for(i=0;;i+=4 ){

  00025	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002c	eb 09		 jmp	 SHORT $LN4@lssproto_d
$LN2@lssproto_d:
  0002e	8b 45 8c	 mov	 eax, DWORD PTR _i$[ebp]
  00031	83 c0 04	 add	 eax, 4
  00034	89 45 8c	 mov	 DWORD PTR _i$[ebp], eax
$LN4@lssproto_d:

; 825  :         if( in[i] == 0 ){

  00037	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  0003a	03 45 8c	 add	 eax, DWORD PTR _i$[ebp]
  0003d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00040	85 c9		 test	 ecx, ecx
  00042	75 0a		 jne	 SHORT $LN5@lssproto_d

; 826  :             break;

  00044	e9 b1 01 00 00	 jmp	 $LN3@lssproto_d
  00049	e9 06 01 00 00	 jmp	 $LN6@lssproto_d
$LN5@lssproto_d:

; 827  :         } else if( in[i+1] == 0 ){   /* the last letter */

  0004e	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  00051	03 45 8c	 add	 eax, DWORD PTR _i$[ebp]
  00054	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00058	85 c9		 test	 ecx, ecx
  0005a	75 0a		 jne	 SHORT $LN7@lssproto_d

; 828  :             break;

  0005c	e9 99 01 00 00	 jmp	 $LN3@lssproto_d
  00061	e9 ee 00 00 00	 jmp	 $LN6@lssproto_d
$LN7@lssproto_d:

; 829  :         } else if( in[i+2] == 0 ){   /* the last 2 letters */

  00066	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  00069	03 45 8c	 add	 eax, DWORD PTR _i$[ebp]
  0006c	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  00070	85 c9		 test	 ecx, ecx
  00072	75 3b		 jne	 SHORT $LN9@lssproto_d

; 830  :             in1 = lssproto_reversecharset[in[i]];

  00074	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  00077	03 45 8c	 add	 eax, DWORD PTR _i$[ebp]
  0007a	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0007d	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR ?lssproto_reversecharset@@3PADA[ecx]
  00083	88 55 fb	 mov	 BYTE PTR _in1$[ebp], dl

; 831  :             in2 = lssproto_reversecharset[in[i+1]];

  00086	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  00089	03 45 8c	 add	 eax, DWORD PTR _i$[ebp]
  0008c	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00090	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR ?lssproto_reversecharset@@3PADA[ecx]
  00096	88 55 ef	 mov	 BYTE PTR _in2$[ebp], dl

; 832  :             in3 = in4 = 0;

  00099	c6 45 d7 00	 mov	 BYTE PTR _in4$[ebp], 0
  0009d	8a 45 d7	 mov	 al, BYTE PTR _in4$[ebp]
  000a0	88 45 e3	 mov	 BYTE PTR _in3$[ebp], al

; 833  :             use_bytes = 1;

  000a3	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _use_bytes$[ebp], 1
  000aa	e9 a5 00 00 00	 jmp	 $LN6@lssproto_d
$LN9@lssproto_d:

; 834  :         } else if( in[i+3] == 0 ){   /* the last  3 letters */

  000af	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  000b2	03 45 8c	 add	 eax, DWORD PTR _i$[ebp]
  000b5	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  000b9	85 c9		 test	 ecx, ecx
  000bb	75 45		 jne	 SHORT $LN11@lssproto_d

; 835  :             in1 = lssproto_reversecharset[in[i]];

  000bd	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  000c0	03 45 8c	 add	 eax, DWORD PTR _i$[ebp]
  000c3	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000c6	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR ?lssproto_reversecharset@@3PADA[ecx]
  000cc	88 55 fb	 mov	 BYTE PTR _in1$[ebp], dl

; 836  :             in2 = lssproto_reversecharset[in[i+1]];

  000cf	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  000d2	03 45 8c	 add	 eax, DWORD PTR _i$[ebp]
  000d5	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  000d9	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR ?lssproto_reversecharset@@3PADA[ecx]
  000df	88 55 ef	 mov	 BYTE PTR _in2$[ebp], dl

; 837  :             in3 = lssproto_reversecharset[in[i+2]];

  000e2	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  000e5	03 45 8c	 add	 eax, DWORD PTR _i$[ebp]
  000e8	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  000ec	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR ?lssproto_reversecharset@@3PADA[ecx]
  000f2	88 55 e3	 mov	 BYTE PTR _in3$[ebp], dl

; 838  :             in4 = 0;

  000f5	c6 45 d7 00	 mov	 BYTE PTR _in4$[ebp], 0

; 839  :             use_bytes = 2;

  000f9	c7 45 a4 02 00
	00 00		 mov	 DWORD PTR _use_bytes$[ebp], 2

; 840  :         } else {   /* process 4 letters */

  00100	eb 52		 jmp	 SHORT $LN6@lssproto_d
$LN11@lssproto_d:

; 841  :             in1 = lssproto_reversecharset[in[i]];

  00102	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  00105	03 45 8c	 add	 eax, DWORD PTR _i$[ebp]
  00108	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0010b	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR ?lssproto_reversecharset@@3PADA[ecx]
  00111	88 55 fb	 mov	 BYTE PTR _in1$[ebp], dl

; 842  :             in2 = lssproto_reversecharset[in[i+1]];

  00114	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  00117	03 45 8c	 add	 eax, DWORD PTR _i$[ebp]
  0011a	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  0011e	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR ?lssproto_reversecharset@@3PADA[ecx]
  00124	88 55 ef	 mov	 BYTE PTR _in2$[ebp], dl

; 843  :             in3 = lssproto_reversecharset[in[i+2]];

  00127	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  0012a	03 45 8c	 add	 eax, DWORD PTR _i$[ebp]
  0012d	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  00131	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR ?lssproto_reversecharset@@3PADA[ecx]
  00137	88 55 e3	 mov	 BYTE PTR _in3$[ebp], dl

; 844  :             in4 = lssproto_reversecharset[in[i+3]];

  0013a	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  0013d	03 45 8c	 add	 eax, DWORD PTR _i$[ebp]
  00140	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00144	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR ?lssproto_reversecharset@@3PADA[ecx]
  0014a	88 55 d7	 mov	 BYTE PTR _in4$[ebp], dl

; 845  :             use_bytes = 3;

  0014d	c7 45 a4 03 00
	00 00		 mov	 DWORD PTR _use_bytes$[ebp], 3
$LN6@lssproto_d:

; 846  :         }
; 847  :         out1 =  (in1<<2) | (((in2 & 0x30)>>4)&0x0f) ;

  00154	0f b6 45 fb	 movzx	 eax, BYTE PTR _in1$[ebp]
  00158	c1 e0 02	 shl	 eax, 2
  0015b	0f b6 4d ef	 movzx	 ecx, BYTE PTR _in2$[ebp]
  0015f	83 e1 30	 and	 ecx, 48			; 00000030H
  00162	c1 f9 04	 sar	 ecx, 4
  00165	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00168	0b c1		 or	 eax, ecx
  0016a	88 45 cb	 mov	 BYTE PTR _out1$[ebp], al

; 848  :         out2 =  ((in2 & 0x0f )<<4) | ((( in3 & 0x3c)>>2)&0x0f);

  0016d	0f b6 45 ef	 movzx	 eax, BYTE PTR _in2$[ebp]
  00171	83 e0 0f	 and	 eax, 15			; 0000000fH
  00174	c1 e0 04	 shl	 eax, 4
  00177	0f b6 4d e3	 movzx	 ecx, BYTE PTR _in3$[ebp]
  0017b	83 e1 3c	 and	 ecx, 60			; 0000003cH
  0017e	c1 f9 02	 sar	 ecx, 2
  00181	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00184	0b c1		 or	 eax, ecx
  00186	88 45 bf	 mov	 BYTE PTR _out2$[ebp], al

; 849  :         out3 =  ( (in3 &0x03)<<6) |  ( in4 & 0x3f );

  00189	0f b6 45 e3	 movzx	 eax, BYTE PTR _in3$[ebp]
  0018d	83 e0 03	 and	 eax, 3
  00190	c1 e0 06	 shl	 eax, 6
  00193	0f b6 4d d7	 movzx	 ecx, BYTE PTR _in4$[ebp]
  00197	83 e1 3f	 and	 ecx, 63			; 0000003fH
  0019a	0b c1		 or	 eax, ecx
  0019c	88 45 b3	 mov	 BYTE PTR _out3$[ebp], al

; 850  :         if( use_bytes >= 1 ){

  0019f	83 7d a4 01	 cmp	 DWORD PTR _use_bytes$[ebp], 1
  001a3	7c 14		 jl	 SHORT $LN13@lssproto_d

; 851  :             out[address++] = out1;

  001a5	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  001a8	03 45 98	 add	 eax, DWORD PTR _address$[ebp]
  001ab	8a 4d cb	 mov	 cl, BYTE PTR _out1$[ebp]
  001ae	88 08		 mov	 BYTE PTR [eax], cl
  001b0	8b 55 98	 mov	 edx, DWORD PTR _address$[ebp]
  001b3	83 c2 01	 add	 edx, 1
  001b6	89 55 98	 mov	 DWORD PTR _address$[ebp], edx
$LN13@lssproto_d:

; 852  :         }
; 853  :         if( use_bytes >= 2 ){

  001b9	83 7d a4 02	 cmp	 DWORD PTR _use_bytes$[ebp], 2
  001bd	7c 14		 jl	 SHORT $LN14@lssproto_d

; 854  :             out[address++] = out2;

  001bf	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  001c2	03 45 98	 add	 eax, DWORD PTR _address$[ebp]
  001c5	8a 4d bf	 mov	 cl, BYTE PTR _out2$[ebp]
  001c8	88 08		 mov	 BYTE PTR [eax], cl
  001ca	8b 55 98	 mov	 edx, DWORD PTR _address$[ebp]
  001cd	83 c2 01	 add	 edx, 1
  001d0	89 55 98	 mov	 DWORD PTR _address$[ebp], edx
$LN14@lssproto_d:

; 855  :         }
; 856  :         if( use_bytes >= 3 ){

  001d3	83 7d a4 03	 cmp	 DWORD PTR _use_bytes$[ebp], 3
  001d7	7c 14		 jl	 SHORT $LN15@lssproto_d

; 857  :             out[address++] = out3;

  001d9	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  001dc	03 45 98	 add	 eax, DWORD PTR _address$[ebp]
  001df	8a 4d b3	 mov	 cl, BYTE PTR _out3$[ebp]
  001e2	88 08		 mov	 BYTE PTR [eax], cl
  001e4	8b 55 98	 mov	 edx, DWORD PTR _address$[ebp]
  001e7	83 c2 01	 add	 edx, 1
  001ea	89 55 98	 mov	 DWORD PTR _address$[ebp], edx
$LN15@lssproto_d:

; 858  :         }
; 859  :         if( use_bytes != 3 ){

  001ed	83 7d a4 03	 cmp	 DWORD PTR _use_bytes$[ebp], 3
  001f1	74 02		 je	 SHORT $LN16@lssproto_d

; 860  :             break;

  001f3	eb 05		 jmp	 SHORT $LN3@lssproto_d
$LN16@lssproto_d:

; 861  :         }
; 862  :     }

  001f5	e9 34 fe ff ff	 jmp	 $LN2@lssproto_d
$LN3@lssproto_d:

; 863  :     return address;

  001fa	8b 45 98	 mov	 eax, DWORD PTR _address$[ebp]

; 864  : }

  001fd	5f		 pop	 edi
  001fe	5e		 pop	 esi
  001ff	5b		 pop	 ebx
  00200	8b e5		 mov	 esp, ebp
  00202	5d		 pop	 ebp
  00203	c3		 ret	 0
?lssproto_decode64@@YAHPAE0@Z ENDP			; lssproto_decode64
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_encode64@@YAXPAEH0@Z
_TEXT	SEGMENT
_out4$1 = -113						; size = 1
_out3$2 = -101						; size = 1
_out2$3 = -89						; size = 1
_out1$4 = -77						; size = 1
_in3$5 = -65						; size = 1
_in2$6 = -53						; size = 1
_in1$7 = -41						; size = 1
_address$ = -32						; size = 4
_use_bytes$ = -20					; size = 4
_i$ = -8						; size = 4
_in$ = 8						; size = 4
_len$ = 12						; size = 4
_out$ = 16						; size = 4
?lssproto_encode64@@YAXPAEH0@Z PROC			; lssproto_encode64, COMDAT

; 765  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 38 01 00
	00		 sub	 esp, 312		; 00000138H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd c8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-312]
  00012	b9 4e 00 00 00	 mov	 ecx, 78			; 0000004eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 766  :     int i;
; 767  :     int use_bytes;
; 768  :     int address = 0;

  0001e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _address$[ebp], 0

; 769  :     out[0] = 0;

  00025	b8 01 00 00 00	 mov	 eax, 1
  0002a	6b c8 00	 imul	 ecx, eax, 0
  0002d	8b 55 10	 mov	 edx, DWORD PTR _out$[ebp]
  00030	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0

; 770  :     for(i=0;;i+=3){

  00034	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0003b	eb 09		 jmp	 SHORT $LN4@lssproto_e
$LN2@lssproto_e:
  0003d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00040	83 c0 03	 add	 eax, 3
  00043	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@lssproto_e:

; 771  :         unsigned char in1 , in2 , in3;
; 772  :         unsigned char out1 ,out2 , out3 , out4;
; 773  :         if( i >= len ) break;

  00046	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00049	3b 45 0c	 cmp	 eax, DWORD PTR _len$[ebp]
  0004c	7c 05		 jl	 SHORT $LN5@lssproto_e
  0004e	e9 a4 01 00 00	 jmp	 $LN1@lssproto_e
$LN5@lssproto_e:

; 774  :         if( i >= (len-1)){   /* the last letter ( to be thrown away ) */

  00053	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00056	83 e8 01	 sub	 eax, 1
  00059	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  0005c	7c 25		 jl	 SHORT $LN6@lssproto_e

; 775  :             in1 = in[i] & 0xff;

  0005e	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  00061	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00064	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00067	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0006d	88 4d d7	 mov	 BYTE PTR _in1$7[ebp], cl

; 776  :             in2 = in3 = 0;

  00070	c6 45 bf 00	 mov	 BYTE PTR _in3$5[ebp], 0
  00074	8a 45 bf	 mov	 al, BYTE PTR _in3$5[ebp]
  00077	88 45 cb	 mov	 BYTE PTR _in2$6[ebp], al

; 777  :             use_bytes = 2;

  0007a	c7 45 ec 02 00
	00 00		 mov	 DWORD PTR _use_bytes$[ebp], 2
  00081	eb 7c		 jmp	 SHORT $LN7@lssproto_e
$LN6@lssproto_e:

; 778  :         } else if( i >= (len-2)){ /* the last 2 letters ( process only 1 byte)*/

  00083	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00086	83 e8 02	 sub	 eax, 2
  00089	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  0008c	7c 32		 jl	 SHORT $LN8@lssproto_e

; 779  :             in1 = in[i] & 0xff;

  0008e	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  00091	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00094	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00097	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0009d	88 4d d7	 mov	 BYTE PTR _in1$7[ebp], cl

; 780  :             in2 = in[i+1] & 0xff;

  000a0	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  000a3	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  000a6	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  000aa	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000b0	88 4d cb	 mov	 BYTE PTR _in2$6[ebp], cl

; 781  :             in3 = 0;

  000b3	c6 45 bf 00	 mov	 BYTE PTR _in3$5[ebp], 0

; 782  :             use_bytes = 3;

  000b7	c7 45 ec 03 00
	00 00		 mov	 DWORD PTR _use_bytes$[ebp], 3

; 783  :         } else {                /* there are more or equal than 3 letters */

  000be	eb 3f		 jmp	 SHORT $LN7@lssproto_e
$LN8@lssproto_e:

; 784  :             in1 = in[i] & 0xff;

  000c0	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  000c3	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  000c6	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000c9	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000cf	88 4d d7	 mov	 BYTE PTR _in1$7[ebp], cl

; 785  :             in2 = in[i+1] & 0xff;

  000d2	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  000d5	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  000d8	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  000dc	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000e2	88 4d cb	 mov	 BYTE PTR _in2$6[ebp], cl

; 786  :             in3 = in[i+2] & 0xff;

  000e5	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  000e8	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  000eb	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  000ef	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000f5	88 4d bf	 mov	 BYTE PTR _in3$5[ebp], cl

; 787  :             use_bytes = 4;

  000f8	c7 45 ec 04 00
	00 00		 mov	 DWORD PTR _use_bytes$[ebp], 4
$LN7@lssproto_e:

; 788  :         }
; 789  :         out1 = ((in1 & 0xfc)>>2) & 0x3f;

  000ff	0f b6 45 d7	 movzx	 eax, BYTE PTR _in1$7[ebp]
  00103	25 fc 00 00 00	 and	 eax, 252		; 000000fcH
  00108	c1 f8 02	 sar	 eax, 2
  0010b	83 e0 3f	 and	 eax, 63			; 0000003fH
  0010e	88 45 b3	 mov	 BYTE PTR _out1$4[ebp], al

; 790  :         out2 = ((in1 & 0x03)<<4) | ((( in2 & 0xf0)>>4)&0x0f);

  00111	0f b6 45 d7	 movzx	 eax, BYTE PTR _in1$7[ebp]
  00115	83 e0 03	 and	 eax, 3
  00118	c1 e0 04	 shl	 eax, 4
  0011b	0f b6 4d cb	 movzx	 ecx, BYTE PTR _in2$6[ebp]
  0011f	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00125	c1 f9 04	 sar	 ecx, 4
  00128	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0012b	0b c1		 or	 eax, ecx
  0012d	88 45 a7	 mov	 BYTE PTR _out2$3[ebp], al

; 791  :         out3 = ((in2 & 0x0f)<<2) | ((( in3 & 0xc0)>>6)&0x03);

  00130	0f b6 45 cb	 movzx	 eax, BYTE PTR _in2$6[ebp]
  00134	83 e0 0f	 and	 eax, 15			; 0000000fH
  00137	c1 e0 02	 shl	 eax, 2
  0013a	0f b6 4d bf	 movzx	 ecx, BYTE PTR _in3$5[ebp]
  0013e	81 e1 c0 00 00
	00		 and	 ecx, 192		; 000000c0H
  00144	c1 f9 06	 sar	 ecx, 6
  00147	83 e1 03	 and	 ecx, 3
  0014a	0b c1		 or	 eax, ecx
  0014c	88 45 9b	 mov	 BYTE PTR _out3$2[ebp], al

; 792  :         out4 = (in3 & 0x3f );

  0014f	0f b6 45 bf	 movzx	 eax, BYTE PTR _in3$5[ebp]
  00153	83 e0 3f	 and	 eax, 63			; 0000003fH
  00156	88 45 8f	 mov	 BYTE PTR _out4$1[ebp], al

; 793  :         if( use_bytes >= 2 ){

  00159	83 7d ec 02	 cmp	 DWORD PTR _use_bytes$[ebp], 2
  0015d	7c 3f		 jl	 SHORT $LN10@lssproto_e

; 794  :             out[address++] = lssproto_charset[out1];

  0015f	0f b6 45 b3	 movzx	 eax, BYTE PTR _out1$4[ebp]
  00163	8b 4d 10	 mov	 ecx, DWORD PTR _out$[ebp]
  00166	03 4d e0	 add	 ecx, DWORD PTR _address$[ebp]
  00169	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR ?lssproto_charset@@3PADA[eax]
  0016f	88 11		 mov	 BYTE PTR [ecx], dl
  00171	8b 45 e0	 mov	 eax, DWORD PTR _address$[ebp]
  00174	83 c0 01	 add	 eax, 1
  00177	89 45 e0	 mov	 DWORD PTR _address$[ebp], eax

; 795  :             out[address++] = lssproto_charset[out2];

  0017a	0f b6 45 a7	 movzx	 eax, BYTE PTR _out2$3[ebp]
  0017e	8b 4d 10	 mov	 ecx, DWORD PTR _out$[ebp]
  00181	03 4d e0	 add	 ecx, DWORD PTR _address$[ebp]
  00184	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR ?lssproto_charset@@3PADA[eax]
  0018a	88 11		 mov	 BYTE PTR [ecx], dl
  0018c	8b 45 e0	 mov	 eax, DWORD PTR _address$[ebp]
  0018f	83 c0 01	 add	 eax, 1
  00192	89 45 e0	 mov	 DWORD PTR _address$[ebp], eax

; 796  :             out[address]=0;

  00195	8b 45 10	 mov	 eax, DWORD PTR _out$[ebp]
  00198	03 45 e0	 add	 eax, DWORD PTR _address$[ebp]
  0019b	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN10@lssproto_e:

; 797  :         }
; 798  :         if( use_bytes >= 3 ){

  0019e	83 7d ec 03	 cmp	 DWORD PTR _use_bytes$[ebp], 3
  001a2	7c 24		 jl	 SHORT $LN11@lssproto_e

; 799  :             out[address++] = lssproto_charset[out3];

  001a4	0f b6 45 9b	 movzx	 eax, BYTE PTR _out3$2[ebp]
  001a8	8b 4d 10	 mov	 ecx, DWORD PTR _out$[ebp]
  001ab	03 4d e0	 add	 ecx, DWORD PTR _address$[ebp]
  001ae	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR ?lssproto_charset@@3PADA[eax]
  001b4	88 11		 mov	 BYTE PTR [ecx], dl
  001b6	8b 45 e0	 mov	 eax, DWORD PTR _address$[ebp]
  001b9	83 c0 01	 add	 eax, 1
  001bc	89 45 e0	 mov	 DWORD PTR _address$[ebp], eax

; 800  :             out[address]=0;

  001bf	8b 45 10	 mov	 eax, DWORD PTR _out$[ebp]
  001c2	03 45 e0	 add	 eax, DWORD PTR _address$[ebp]
  001c5	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN11@lssproto_e:

; 801  :         }
; 802  :         if( use_bytes >= 4 ){

  001c8	83 7d ec 04	 cmp	 DWORD PTR _use_bytes$[ebp], 4
  001cc	7c 24		 jl	 SHORT $LN12@lssproto_e

; 803  :             out[address++] = lssproto_charset[out4];

  001ce	0f b6 45 8f	 movzx	 eax, BYTE PTR _out4$1[ebp]
  001d2	8b 4d 10	 mov	 ecx, DWORD PTR _out$[ebp]
  001d5	03 4d e0	 add	 ecx, DWORD PTR _address$[ebp]
  001d8	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR ?lssproto_charset@@3PADA[eax]
  001de	88 11		 mov	 BYTE PTR [ecx], dl
  001e0	8b 45 e0	 mov	 eax, DWORD PTR _address$[ebp]
  001e3	83 c0 01	 add	 eax, 1
  001e6	89 45 e0	 mov	 DWORD PTR _address$[ebp], eax

; 804  :             out[address]=0;

  001e9	8b 45 10	 mov	 eax, DWORD PTR _out$[ebp]
  001ec	03 45 e0	 add	 eax, DWORD PTR _address$[ebp]
  001ef	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN12@lssproto_e:

; 805  :         }
; 806  :     }

  001f2	e9 46 fe ff ff	 jmp	 $LN2@lssproto_e
$LN1@lssproto_e:

; 807  : }

  001f7	5f		 pop	 edi
  001f8	5e		 pop	 esi
  001f9	5b		 pop	 ebx
  001fa	8b e5		 mov	 esp, ebp
  001fc	5d		 pop	 ebp
  001fd	c3		 ret	 0
?lssproto_encode64@@YAXPAEH0@Z ENDP			; lssproto_encode64
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_encodeString@@YAXPAD0H@Z
_TEXT	SEGMENT
_flag$ = -44						; size = 4
_srclen$ = -32						; size = 4
_compressed_l$ = -20					; size = 4
_jencodedlen$ = -8					; size = 4
_src$ = 8						; size = 4
_out$ = 12						; size = 4
_maxoutlen$ = 16					; size = 4
?lssproto_encodeString@@YAXPAD0H@Z PROC			; lssproto_encodeString, COMDAT

; 654  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 655  :     int jencodedlen=0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _jencodedlen$[ebp], 0

; 656  :     long compressed_l = 0;

  00025	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _compressed_l$[ebp], 0

; 657  : 	int srclen = strlen( src ) + 1;

  0002c	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 _strlen
  00035	83 c4 04	 add	 esp, 4
  00038	83 c0 01	 add	 eax, 1
  0003b	89 45 e0	 mov	 DWORD PTR _srclen$[ebp], eax

; 658  :     int flag=srclen;

  0003e	8b 45 e0	 mov	 eax, DWORD PTR _srclen$[ebp]
  00041	89 45 d4	 mov	 DWORD PTR _flag$[ebp], eax

; 659  : 	if( srclen < 100 ){

  00044	83 7d e0 64	 cmp	 DWORD PTR _srclen$[ebp], 100 ; 00000064H
  00048	0f 8d 98 00 00
	00		 jge	 $LN2@lssproto_e

; 660  : 		if( (int)srclen > (int)( lssproto.workbufsize*3-2) ){

  0004e	6b 05 04 00 00
	00 03		 imul	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4, 3
  00055	83 e8 02	 sub	 eax, 2
  00058	39 45 e0	 cmp	 DWORD PTR _srclen$[ebp], eax
  0005b	7e 33		 jle	 SHORT $LN4@lssproto_e

; 661  : 			fprintf( stderr, "lsgen: badly configured work buflen\n" );

  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NBLKNCEA@lsgen?3?5badly?5configured?5work?5buf@
  00062	8b f4		 mov	 esi, esp
  00064	6a 02		 push	 2
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0006c	83 c4 04	 add	 esp, 4
  0006f	3b f4		 cmp	 esi, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _fprintf
  0007c	83 c4 08	 add	 esp, 8

; 662  : 			exit(1);

  0007f	8b f4		 mov	 esi, esp
  00081	6a 01		 push	 1
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  00089	3b f4		 cmp	 esi, esp
  0008b	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@lssproto_e:

; 663  : 		}
; 664  : 		if( (flag%2) == 1 ) flag ++;

  00090	8b 45 d4	 mov	 eax, DWORD PTR _flag$[ebp]
  00093	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00098	79 05		 jns	 SHORT $LN12@lssproto_e
  0009a	48		 dec	 eax
  0009b	83 c8 fe	 or	 eax, -2			; fffffffeH
  0009e	40		 inc	 eax
$LN12@lssproto_e:
  0009f	83 f8 01	 cmp	 eax, 1
  000a2	75 09		 jne	 SHORT $LN5@lssproto_e
  000a4	8b 45 d4	 mov	 eax, DWORD PTR _flag$[ebp]
  000a7	83 c0 01	 add	 eax, 1
  000aa	89 45 d4	 mov	 DWORD PTR _flag$[ebp], eax
$LN5@lssproto_e:

; 665  : 		lssproto.compresswork[0] = flag;

  000ad	b8 01 00 00 00	 mov	 eax, 1
  000b2	6b c8 00	 imul	 ecx, eax, 0
  000b5	8b 15 28 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+40
  000bb	8a 45 d4	 mov	 al, BYTE PTR _flag$[ebp]
  000be	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 666  : 		memcpy( lssproto.compresswork+1,src,srclen );

  000c1	8b 45 e0	 mov	 eax, DWORD PTR _srclen$[ebp]
  000c4	50		 push	 eax
  000c5	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  000c8	51		 push	 ecx
  000c9	8b 15 28 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+40
  000cf	83 c2 01	 add	 edx, 1
  000d2	52		 push	 edx
  000d3	e8 00 00 00 00	 call	 _memcpy
  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 667  : 		compressed_l = srclen + 1;

  000db	8b 45 e0	 mov	 eax, DWORD PTR _srclen$[ebp]
  000de	83 c0 01	 add	 eax, 1
  000e1	89 45 ec	 mov	 DWORD PTR _compressed_l$[ebp], eax

; 668  : 	} else {

  000e4	eb 63		 jmp	 SHORT $LN3@lssproto_e
$LN2@lssproto_e:

; 669  : 		if((flag%2)==0)flag++;

  000e6	8b 45 d4	 mov	 eax, DWORD PTR _flag$[ebp]
  000e9	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  000ee	79 05		 jns	 SHORT $LN13@lssproto_e
  000f0	48		 dec	 eax
  000f1	83 c8 fe	 or	 eax, -2			; fffffffeH
  000f4	40		 inc	 eax
$LN13@lssproto_e:
  000f5	85 c0		 test	 eax, eax
  000f7	75 09		 jne	 SHORT $LN6@lssproto_e
  000f9	8b 45 d4	 mov	 eax, DWORD PTR _flag$[ebp]
  000fc	83 c0 01	 add	 eax, 1
  000ff	89 45 d4	 mov	 DWORD PTR _flag$[ebp], eax
$LN6@lssproto_e:

; 670  : 		lssproto.compresswork[0] = flag;

  00102	b8 01 00 00 00	 mov	 eax, 1
  00107	6b c8 00	 imul	 ecx, eax, 0
  0010a	8b 15 28 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+40
  00110	8a 45 d4	 mov	 al, BYTE PTR _flag$[ebp]
  00113	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 671  :         compressed_l = lssproto_ringoCompressor(

  00116	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00119	50		 push	 eax
  0011a	e8 00 00 00 00	 call	 _strlen
  0011f	83 c4 04	 add	 esp, 4
  00122	50		 push	 eax
  00123	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  00126	51		 push	 ecx
  00127	6b 15 04 00 00
	00 03		 imul	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+4, 3
  0012e	83 ea 01	 sub	 edx, 1
  00131	52		 push	 edx
  00132	a1 28 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+40
  00137	83 c0 01	 add	 eax, 1
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 ?lssproto_ringoCompressor@@YAJPAEJ0J@Z ; lssproto_ringoCompressor
  00140	83 c4 10	 add	 esp, 16			; 00000010H
  00143	83 c0 01	 add	 eax, 1
  00146	89 45 ec	 mov	 DWORD PTR _compressed_l$[ebp], eax
$LN3@lssproto_e:

; 672  :             (unsigned char*)lssproto.compresswork + 1 ,
; 673  : 		    (long)lssproto.workbufsize*3 - 1,
; 674  :             (unsigned char*)src ,
; 675  :            (long)strlen(src) ) + 1;    /* be careful! */
; 676  : 	}
; 677  : 	/* return empty line if error or buffer excess */
; 678  : 	if( compressed_l <= 0 ){

  00149	83 7d ec 00	 cmp	 DWORD PTR _compressed_l$[ebp], 0
  0014d	7f 17		 jg	 SHORT $LN7@lssproto_e

; 679  : 		lssproto_strcpysafe( out , "\n" , maxoutlen );

  0014f	8b 45 10	 mov	 eax, DWORD PTR _maxoutlen$[ebp]
  00152	50		 push	 eax
  00153	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  00158	8b 4d 0c	 mov	 ecx, DWORD PTR _out$[ebp]
  0015b	51		 push	 ecx
  0015c	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH

; 680  : 		return;

  00164	eb 5f		 jmp	 SHORT $LN8@lssproto_e
$LN7@lssproto_e:

; 681  : 	}
; 682  :     memcpy( lssproto.jencodecopy ,lssproto.compresswork ,compressed_l );

  00166	8b 45 ec	 mov	 eax, DWORD PTR _compressed_l$[ebp]
  00169	50		 push	 eax
  0016a	8b 0d 28 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+40
  00170	51		 push	 ecx
  00171	8b 15 20 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+32
  00177	52		 push	 edx
  00178	e8 00 00 00 00	 call	 _memcpy
  0017d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 683  :     lssproto_jEncode( lssproto.jencodecopy , compressed_l , JENCODE_KEY ,

  00180	6b 05 04 00 00
	00 03		 imul	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4, 3
  00187	83 e8 01	 sub	 eax, 1
  0018a	50		 push	 eax
  0018b	8d 4d f8	 lea	 ecx, DWORD PTR _jencodedlen$[ebp]
  0018e	51		 push	 ecx
  0018f	8b 15 24 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+36
  00195	52		 push	 edx
  00196	68 13 3d 12 03	 push	 51526931		; 03123d13H
  0019b	8b 45 ec	 mov	 eax, DWORD PTR _compressed_l$[ebp]
  0019e	50		 push	 eax
  0019f	8b 0d 20 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+32
  001a5	51		 push	 ecx
  001a6	e8 00 00 00 00	 call	 ?lssproto_jEncode@@YAXPADHH0PAHH@Z ; lssproto_jEncode
  001ab	83 c4 18	 add	 esp, 24			; 00000018H

; 684  : 	    lssproto.jencodeout, &jencodedlen , lssproto.workbufsize*3 -1 );
; 685  :     lssproto_encode64( (unsigned char*)lssproto.jencodeout , jencodedlen,  (unsigned char*)out );

  001ae	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  001b1	50		 push	 eax
  001b2	8b 4d f8	 mov	 ecx, DWORD PTR _jencodedlen$[ebp]
  001b5	51		 push	 ecx
  001b6	8b 15 24 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+36
  001bc	52		 push	 edx
  001bd	e8 00 00 00 00	 call	 ?lssproto_encode64@@YAXPAEH0@Z ; lssproto_encode64
  001c2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@lssproto_e:

; 686  : }

  001c5	52		 push	 edx
  001c6	8b cd		 mov	 ecx, ebp
  001c8	50		 push	 eax
  001c9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@lssproto_e
  001cf	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001d4	58		 pop	 eax
  001d5	5a		 pop	 edx
  001d6	5f		 pop	 edi
  001d7	5e		 pop	 esi
  001d8	5b		 pop	 ebx
  001d9	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  001df	3b ec		 cmp	 ebp, esp
  001e1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001e6	8b e5		 mov	 esp, ebp
  001e8	5d		 pop	 ebp
  001e9	c3		 ret	 0
  001ea	66 90		 npad	 2
$LN11@lssproto_e:
  001ec	01 00 00 00	 DD	 1
  001f0	00 00 00 00	 DD	 $LN10@lssproto_e
$LN10@lssproto_e:
  001f4	f8 ff ff ff	 DD	 -8			; fffffff8H
  001f8	04 00 00 00	 DD	 4
  001fc	00 00 00 00	 DD	 $LN9@lssproto_e
$LN9@lssproto_e:
  00200	6a		 DB	 106			; 0000006aH
  00201	65		 DB	 101			; 00000065H
  00202	6e		 DB	 110			; 0000006eH
  00203	63		 DB	 99			; 00000063H
  00204	6f		 DB	 111			; 0000006fH
  00205	64		 DB	 100			; 00000064H
  00206	65		 DB	 101			; 00000065H
  00207	64		 DB	 100			; 00000064H
  00208	6c		 DB	 108			; 0000006cH
  00209	65		 DB	 101			; 00000065H
  0020a	6e		 DB	 110			; 0000006eH
  0020b	00		 DB	 0
?lssproto_encodeString@@YAXPAD0H@Z ENDP			; lssproto_encodeString
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_decodeString@@YAXPAD0@Z
_TEXT	SEGMENT
_decompressed_l$ = -44					; size = 4
_l$ = -32						; size = 4
_outlen64$ = -20					; size = 4
_compressed_l$ = -8					; size = 4
_src$ = 8						; size = 4
_out$ = 12						; size = 4
?lssproto_decodeString@@YAXPAD0@Z PROC			; lssproto_decodeString, COMDAT

; 689  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 690  :     int compressed_l =0, outlen64;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _compressed_l$[ebp], 0

; 691  :     int l;
; 692  :     long decompressed_l = 0;

  00025	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _decompressed_l$[ebp], 0

; 693  :     /* copy src to copybuffer because jencoder modifies the input buffer */
; 694  :     l = strlen( src );

  0002c	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 _strlen
  00035	83 c4 04	 add	 esp, 4
  00038	89 45 e0	 mov	 DWORD PTR _l$[ebp], eax

; 695  :     if( src[l-1]=='\n' || src[l-1]=='\r' )src[l-1]=0;

  0003b	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0003e	03 45 e0	 add	 eax, DWORD PTR _l$[ebp]
  00041	0f be 48 ff	 movsx	 ecx, BYTE PTR [eax-1]
  00045	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00048	74 0f		 je	 SHORT $LN3@lssproto_d
  0004a	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0004d	03 45 e0	 add	 eax, DWORD PTR _l$[ebp]
  00050	0f be 48 ff	 movsx	 ecx, BYTE PTR [eax-1]
  00054	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  00057	75 0a		 jne	 SHORT $LN2@lssproto_d
$LN3@lssproto_d:
  00059	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0005c	03 45 e0	 add	 eax, DWORD PTR _l$[ebp]
  0005f	c6 40 ff 00	 mov	 BYTE PTR [eax-1], 0
$LN2@lssproto_d:

; 696  :     if( src[l-2]=='\n' || src[l-2]=='\r' )src[l-2]=0;

  00063	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00066	03 45 e0	 add	 eax, DWORD PTR _l$[ebp]
  00069	0f be 48 fe	 movsx	 ecx, BYTE PTR [eax-2]
  0006d	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00070	74 0f		 je	 SHORT $LN5@lssproto_d
  00072	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00075	03 45 e0	 add	 eax, DWORD PTR _l$[ebp]
  00078	0f be 48 fe	 movsx	 ecx, BYTE PTR [eax-2]
  0007c	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  0007f	75 0a		 jne	 SHORT $LN4@lssproto_d
$LN5@lssproto_d:
  00081	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00084	03 45 e0	 add	 eax, DWORD PTR _l$[ebp]
  00087	c6 40 fe 00	 mov	 BYTE PTR [eax-2], 0
$LN4@lssproto_d:

; 697  :     outlen64 = lssproto_decode64( (unsigned char*)src , (unsigned char*)lssproto.jencodecopy );

  0008b	a1 20 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+32
  00090	50		 push	 eax
  00091	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  00094	51		 push	 ecx
  00095	e8 00 00 00 00	 call	 ?lssproto_decode64@@YAHPAE0@Z ; lssproto_decode64
  0009a	83 c4 08	 add	 esp, 8
  0009d	89 45 ec	 mov	 DWORD PTR _outlen64$[ebp], eax

; 698  :     lssproto_jDecode( lssproto.jencodecopy , outlen64 , JENCODE_KEY,

  000a0	8d 45 f8	 lea	 eax, DWORD PTR _compressed_l$[ebp]
  000a3	50		 push	 eax
  000a4	8b 0d 28 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+40
  000aa	51		 push	 ecx
  000ab	68 13 3d 12 03	 push	 51526931		; 03123d13H
  000b0	8b 55 ec	 mov	 edx, DWORD PTR _outlen64$[ebp]
  000b3	52		 push	 edx
  000b4	a1 20 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+32
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 ?lssproto_jDecode@@YAXPADHH0PAH@Z ; lssproto_jDecode
  000bf	83 c4 14	 add	 esp, 20			; 00000014H

; 699  : 			lssproto.compresswork , &compressed_l);
; 700  :     /*out[outlen]=0;  PENDING*/
; 701  :     if( (lssproto.compresswork[0] % 2 ) == 0 ){

  000c2	b8 01 00 00 00	 mov	 eax, 1
  000c7	6b c8 00	 imul	 ecx, eax, 0
  000ca	8b 15 28 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+40
  000d0	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  000d4	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  000d9	79 05		 jns	 SHORT $LN14@lssproto_d
  000db	48		 dec	 eax
  000dc	83 c8 fe	 or	 eax, -2			; fffffffeH
  000df	40		 inc	 eax
$LN14@lssproto_d:
  000e0	85 c0		 test	 eax, eax
  000e2	75 5d		 jne	 SHORT $LN6@lssproto_d

; 702  : 	    if( compressed_l <= 0 ){

  000e4	83 7d f8 00	 cmp	 DWORD PTR _compressed_l$[ebp], 0
  000e8	7f 2f		 jg	 SHORT $LN8@lssproto_d

; 703  : 			decompressed_l = 0;

  000ea	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _decompressed_l$[ebp], 0

; 704  : 			fprintf( stderr, "LSRPC: too short:[%s]\n", src );

  000f1	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  000f4	50		 push	 eax
  000f5	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@GCBPDGEH@LSRPC?3?5too?5short?3?$FL?$CFs?$FN?6?$AA@
  000fa	8b f4		 mov	 esi, esp
  000fc	6a 02		 push	 2
  000fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00104	83 c4 04	 add	 esp, 4
  00107	3b f4		 cmp	 esi, esp
  00109	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 _fprintf
  00114	83 c4 0c	 add	 esp, 12			; 0000000cH

; 705  : 		} else {

  00117	eb 26		 jmp	 SHORT $LN9@lssproto_d
$LN8@lssproto_d:

; 706  : 			memcpy( out, lssproto.compresswork+1, compressed_l -1 );

  00119	8b 45 f8	 mov	 eax, DWORD PTR _compressed_l$[ebp]
  0011c	83 e8 01	 sub	 eax, 1
  0011f	50		 push	 eax
  00120	8b 0d 28 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+40
  00126	83 c1 01	 add	 ecx, 1
  00129	51		 push	 ecx
  0012a	8b 55 0c	 mov	 edx, DWORD PTR _out$[ebp]
  0012d	52		 push	 edx
  0012e	e8 00 00 00 00	 call	 _memcpy
  00133	83 c4 0c	 add	 esp, 12			; 0000000cH

; 707  : 			decompressed_l = compressed_l -1;

  00136	8b 45 f8	 mov	 eax, DWORD PTR _compressed_l$[ebp]
  00139	83 e8 01	 sub	 eax, 1
  0013c	89 45 d4	 mov	 DWORD PTR _decompressed_l$[ebp], eax
$LN9@lssproto_d:

; 708  : 		}
; 709  : 	} else {

  0013f	eb 27		 jmp	 SHORT $LN7@lssproto_d
$LN6@lssproto_d:

; 710  :         decompressed_l =

  00141	8b 45 f8	 mov	 eax, DWORD PTR _compressed_l$[ebp]
  00144	83 e8 01	 sub	 eax, 1
  00147	50		 push	 eax
  00148	8b 0d 28 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+40
  0014e	83 c1 01	 add	 ecx, 1
  00151	51		 push	 ecx
  00152	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00158	52		 push	 edx
  00159	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 ?lssproto_ringoDecompressor@@YAJPAEJ0J@Z ; lssproto_ringoDecompressor
  00162	83 c4 10	 add	 esp, 16			; 00000010H
  00165	89 45 d4	 mov	 DWORD PTR _decompressed_l$[ebp], eax
$LN7@lssproto_d:

; 711  : 			lssproto_ringoDecompressor( (unsigned char*)out ,
; 712  :                   	(long)lssproto.workbufsize ,
; 713  : 					(unsigned char*)lssproto.compresswork+1 ,
; 714  : 					(long)compressed_l -1 );
; 715  : 	}
; 716  :     out[decompressed_l] = 0;

  00168	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  0016b	03 45 d4	 add	 eax, DWORD PTR _decompressed_l$[ebp]
  0016e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 717  : }

  00171	52		 push	 edx
  00172	8b cd		 mov	 ecx, ebp
  00174	50		 push	 eax
  00175	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@lssproto_d
  0017b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00180	58		 pop	 eax
  00181	5a		 pop	 edx
  00182	5f		 pop	 edi
  00183	5e		 pop	 esi
  00184	5b		 pop	 ebx
  00185	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  0018b	3b ec		 cmp	 ebp, esp
  0018d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00192	8b e5		 mov	 esp, ebp
  00194	5d		 pop	 ebp
  00195	c3		 ret	 0
  00196	66 90		 npad	 2
$LN13@lssproto_d:
  00198	01 00 00 00	 DD	 1
  0019c	00 00 00 00	 DD	 $LN12@lssproto_d
$LN12@lssproto_d:
  001a0	f8 ff ff ff	 DD	 -8			; fffffff8H
  001a4	04 00 00 00	 DD	 4
  001a8	00 00 00 00	 DD	 $LN11@lssproto_d
$LN11@lssproto_d:
  001ac	63		 DB	 99			; 00000063H
  001ad	6f		 DB	 111			; 0000006fH
  001ae	6d		 DB	 109			; 0000006dH
  001af	70		 DB	 112			; 00000070H
  001b0	72		 DB	 114			; 00000072H
  001b1	65		 DB	 101			; 00000065H
  001b2	73		 DB	 115			; 00000073H
  001b3	73		 DB	 115			; 00000073H
  001b4	65		 DB	 101			; 00000065H
  001b5	64		 DB	 100			; 00000064H
  001b6	5f		 DB	 95			; 0000005fH
  001b7	6c		 DB	 108			; 0000006cH
  001b8	00		 DB	 0
?lssproto_decodeString@@YAXPAD0@Z ENDP			; lssproto_decodeString
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_ringoDecompressor@@YAJPAEJ0J@Z
_TEXT	SEGMENT
_rv$1 = -10340						; size = 4
_w$ = -10328						; size = 4
_k$ = -10316						; size = 4
_i$ = -10304						; size = 4
_len$ = -10292						; size = 4
_freeNode$ = -10280					; size = 4
_sp$ = -10268						; size = 4
_stack$ = -10256					; size = 2048
_node$ = -8200						; size = 8192
__$ArrayPad$ = -4					; size = 4
_text$ = 8						; size = 4
_textlen$ = 12						; size = 4
_code$ = 16						; size = 4
_codelen$ = 20						; size = 4
?lssproto_ringoDecompressor@@YAJPAEJ0J@Z PROC		; lssproto_ringoDecompressor, COMDAT

; 1378 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 68 2e 00 00	 mov	 eax, 11880		; 00002e68H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8d bd 98 d1 ff
	ff		 lea	 edi, DWORD PTR [ebp-11880]
  00016	b9 9a 0b 00 00	 mov	 ecx, 2970		; 00000b9aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1379 :     NODE node[NODE_SIZE];
; 1380 :     int stack[NODE_SIZE];
; 1381 :     int sp;
; 1382 :     int freeNode;
; 1383 :     int len;
; 1384 :     int i;
; 1385 :     int k = 0;

  0002c	c7 85 b4 d7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _k$[ebp], 0

; 1386 :     int w = 0;

  00036	c7 85 a8 d7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _w$[ebp], 0

; 1387 :     if( codelen <= 0 ) return -1;

  00040	83 7d 14 00	 cmp	 DWORD PTR _codelen$[ebp], 0
  00044	7f 08		 jg	 SHORT $LN11@lssproto_r
  00046	83 c8 ff	 or	 eax, -1
  00049	e9 27 03 00 00	 jmp	 $LN1@lssproto_r
$LN11@lssproto_r:

; 1388 :     initInputBitStream( (char*)code , codelen );

  0004e	8b 45 14	 mov	 eax, DWORD PTR _codelen$[ebp]
  00051	50		 push	 eax
  00052	8b 4d 10	 mov	 ecx, DWORD PTR _code$[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ?initInputBitStream@@YAHPADH@Z ; initInputBitStream
  0005b	83 c4 08	 add	 esp, 8

; 1389 :     for(i=0;i<CHAR_SIZE;i++){

  0005e	c7 85 c0 d7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00068	eb 0f		 jmp	 SHORT $LN4@lssproto_r
$LN2@lssproto_r:
  0006a	8b 85 c0 d7 ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00070	83 c0 01	 add	 eax, 1
  00073	89 85 c0 d7 ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN4@lssproto_r:
  00079	81 bd c0 d7 ff
	ff 00 01 00 00	 cmp	 DWORD PTR _i$[ebp], 256	; 00000100H
  00083	7d 59		 jge	 SHORT $LN3@lssproto_r

; 1390 :         node[i].chr = (unsigned char)i;

  00085	8b 85 c0 d7 ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0008b	c1 e0 04	 shl	 eax, 4
  0008e	8a 8d c0 d7 ff
	ff		 mov	 cl, BYTE PTR _i$[ebp]
  00094	88 8c 05 f8 df
	ff ff		 mov	 BYTE PTR _node$[ebp+eax], cl

; 1391 :         node[i].brother = i+1;

  0009b	8b 85 c0 d7 ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000a1	83 c0 01	 add	 eax, 1
  000a4	8b 8d c0 d7 ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  000aa	c1 e1 04	 shl	 ecx, 4
  000ad	89 84 0d 00 e0
	ff ff		 mov	 DWORD PTR _node$[ebp+ecx+8], eax

; 1392 :         node[i].parent = 0;

  000b4	8b 85 c0 d7 ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000ba	c1 e0 04	 shl	 eax, 4
  000bd	c7 84 05 fc df
	ff ff 00 00 00
	00		 mov	 DWORD PTR _node$[ebp+eax+4], 0

; 1393 :         node[i].child = 0;

  000c8	8b 85 c0 d7 ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000ce	c1 e0 04	 shl	 eax, 4
  000d1	c7 84 05 04 e0
	ff ff 00 00 00
	00		 mov	 DWORD PTR _node$[ebp+eax+12], 0

; 1394 :     }

  000dc	eb 8c		 jmp	 SHORT $LN2@lssproto_r
$LN3@lssproto_r:

; 1395 :     node[CHAR_SIZE].brother = 0;

  000de	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000e3	c1 e0 08	 shl	 eax, 8
  000e6	c7 84 05 00 e0
	ff ff 00 00 00
	00		 mov	 DWORD PTR _node$[ebp+eax+8], 0

; 1396 :     freeNode = CHAR_SIZE + 1;

  000f1	c7 85 d8 d7 ff
	ff 01 01 00 00	 mov	 DWORD PTR _freeNode$[ebp], 257 ; 00000101H

; 1397 :     len=0;  /* index to text buffer */

  000fb	c7 85 cc d7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _len$[ebp], 0

; 1398 :     sp=0;   /* stack pointer */

  00105	c7 85 e4 d7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _sp$[ebp], 0
$LN5@lssproto_r:

; 1399 :     while(1){

  0010f	b8 01 00 00 00	 mov	 eax, 1
  00114	85 c0		 test	 eax, eax
  00116	0f 84 53 02 00
	00		 je	 $LN6@lssproto_r

; 1400 :         int rv = 0;

  0011c	c7 85 9c d7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _rv$1[ebp], 0

; 1401 :         rv = readInputBitStream( BITS_LEN );

  00126	6a 09		 push	 9
  00128	e8 00 00 00 00	 call	 ?readInputBitStream@@YAIH@Z ; readInputBitStream
  0012d	83 c4 04	 add	 esp, 4
  00130	89 85 9c d7 ff
	ff		 mov	 DWORD PTR _rv$1[ebp], eax

; 1402 :         /* return OK if EOF */
; 1403 :         if( rv == CHAR_SIZE ) break;        

  00136	81 bd 9c d7 ff
	ff 00 01 00 00	 cmp	 DWORD PTR _rv$1[ebp], 256 ; 00000100H
  00140	75 05		 jne	 SHORT $LN12@lssproto_r
  00142	e9 28 02 00 00	 jmp	 $LN6@lssproto_r
$LN12@lssproto_r:

; 1404 :         if( rv >= freeNode ){

  00147	8b 85 9c d7 ff
	ff		 mov	 eax, DWORD PTR _rv$1[ebp]
  0014d	3b 85 d8 d7 ff
	ff		 cmp	 eax, DWORD PTR _freeNode$[ebp]
  00153	7c 44		 jl	 SHORT $LN13@lssproto_r

; 1405 :             stack[sp++] = k;            /* exception */

  00155	8b 85 e4 d7 ff
	ff		 mov	 eax, DWORD PTR _sp$[ebp]
  0015b	8b 8d b4 d7 ff
	ff		 mov	 ecx, DWORD PTR _k$[ebp]
  00161	89 8c 85 f0 d7
	ff ff		 mov	 DWORD PTR _stack$[ebp+eax*4], ecx
  00168	8b 95 e4 d7 ff
	ff		 mov	 edx, DWORD PTR _sp$[ebp]
  0016e	83 c2 01	 add	 edx, 1
  00171	89 95 e4 d7 ff
	ff		 mov	 DWORD PTR _sp$[ebp], edx

; 1406 :             if( sp >=( sizeof( stack ) /sizeof(stack[0] )) )return -1;   

  00177	81 bd e4 d7 ff
	ff 00 02 00 00	 cmp	 DWORD PTR _sp$[ebp], 512 ; 00000200H
  00181	72 08		 jb	 SHORT $LN15@lssproto_r
  00183	83 c8 ff	 or	 eax, -1
  00186	e9 ea 01 00 00	 jmp	 $LN1@lssproto_r
$LN15@lssproto_r:

; 1407 :             k = w;

  0018b	8b 85 a8 d7 ff
	ff		 mov	 eax, DWORD PTR _w$[ebp]
  00191	89 85 b4 d7 ff
	ff		 mov	 DWORD PTR _k$[ebp], eax

; 1408 :         } else {

  00197	eb 0c		 jmp	 SHORT $LN7@lssproto_r
$LN13@lssproto_r:

; 1409 :             k = rv;

  00199	8b 85 9c d7 ff
	ff		 mov	 eax, DWORD PTR _rv$1[ebp]
  0019f	89 85 b4 d7 ff
	ff		 mov	 DWORD PTR _k$[ebp], eax
$LN7@lssproto_r:

; 1410 :         }
; 1411 :         while(k> CHAR_SIZE ){

  001a5	81 bd b4 d7 ff
	ff 00 01 00 00	 cmp	 DWORD PTR _k$[ebp], 256	; 00000100H
  001af	7e 6d		 jle	 SHORT $LN8@lssproto_r

; 1412 :             if( k >= (sizeof(node)/sizeof(node[0]))) return -1;

  001b1	81 bd b4 d7 ff
	ff 00 02 00 00	 cmp	 DWORD PTR _k$[ebp], 512	; 00000200H
  001bb	72 08		 jb	 SHORT $LN16@lssproto_r
  001bd	83 c8 ff	 or	 eax, -1
  001c0	e9 b0 01 00 00	 jmp	 $LN1@lssproto_r
$LN16@lssproto_r:

; 1413 :             stack[sp++] = node[k].chr;

  001c5	8b 85 b4 d7 ff
	ff		 mov	 eax, DWORD PTR _k$[ebp]
  001cb	c1 e0 04	 shl	 eax, 4
  001ce	0f b6 8c 05 f8
	df ff ff	 movzx	 ecx, BYTE PTR _node$[ebp+eax]
  001d6	8b 95 e4 d7 ff
	ff		 mov	 edx, DWORD PTR _sp$[ebp]
  001dc	89 8c 95 f0 d7
	ff ff		 mov	 DWORD PTR _stack$[ebp+edx*4], ecx
  001e3	8b 85 e4 d7 ff
	ff		 mov	 eax, DWORD PTR _sp$[ebp]
  001e9	83 c0 01	 add	 eax, 1
  001ec	89 85 e4 d7 ff
	ff		 mov	 DWORD PTR _sp$[ebp], eax

; 1414 :             k = node[k].parent;

  001f2	8b 85 b4 d7 ff
	ff		 mov	 eax, DWORD PTR _k$[ebp]
  001f8	c1 e0 04	 shl	 eax, 4
  001fb	8b 8c 05 fc df
	ff ff		 mov	 ecx, DWORD PTR _node$[ebp+eax+4]
  00202	89 8d b4 d7 ff
	ff		 mov	 DWORD PTR _k$[ebp], ecx

; 1415 :             if( sp >=( sizeof( stack ) /sizeof(stack[0] )) ) return -1;

  00208	81 bd e4 d7 ff
	ff 00 02 00 00	 cmp	 DWORD PTR _sp$[ebp], 512 ; 00000200H
  00212	72 08		 jb	 SHORT $LN17@lssproto_r
  00214	83 c8 ff	 or	 eax, -1
  00217	e9 59 01 00 00	 jmp	 $LN1@lssproto_r
$LN17@lssproto_r:

; 1416 :         }

  0021c	eb 87		 jmp	 SHORT $LN7@lssproto_r
$LN8@lssproto_r:

; 1417 :         stack[sp++] = k;

  0021e	8b 85 e4 d7 ff
	ff		 mov	 eax, DWORD PTR _sp$[ebp]
  00224	8b 8d b4 d7 ff
	ff		 mov	 ecx, DWORD PTR _k$[ebp]
  0022a	89 8c 85 f0 d7
	ff ff		 mov	 DWORD PTR _stack$[ebp+eax*4], ecx
  00231	8b 95 e4 d7 ff
	ff		 mov	 edx, DWORD PTR _sp$[ebp]
  00237	83 c2 01	 add	 edx, 1
  0023a	89 95 e4 d7 ff
	ff		 mov	 DWORD PTR _sp$[ebp], edx

; 1418 :         if( sp >= ( sizeof( stack ) /sizeof(stack[0] )) ) return -1;

  00240	81 bd e4 d7 ff
	ff 00 02 00 00	 cmp	 DWORD PTR _sp$[ebp], 512 ; 00000200H
  0024a	72 08		 jb	 SHORT $LN9@lssproto_r
  0024c	83 c8 ff	 or	 eax, -1
  0024f	e9 21 01 00 00	 jmp	 $LN1@lssproto_r
$LN9@lssproto_r:

; 1419 :         /* output to text buffer from stack.*/
; 1420 :         while(sp){

  00254	83 bd e4 d7 ff
	ff 00		 cmp	 DWORD PTR _sp$[ebp], 0
  0025b	74 4e		 je	 SHORT $LN10@lssproto_r

; 1421 :             if( ++len > textlen ) return -1;

  0025d	8b 85 cc d7 ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
  00263	83 c0 01	 add	 eax, 1
  00266	89 85 cc d7 ff
	ff		 mov	 DWORD PTR _len$[ebp], eax
  0026c	8b 8d cc d7 ff
	ff		 mov	 ecx, DWORD PTR _len$[ebp]
  00272	3b 4d 0c	 cmp	 ecx, DWORD PTR _textlen$[ebp]
  00275	7e 08		 jle	 SHORT $LN19@lssproto_r
  00277	83 c8 ff	 or	 eax, -1
  0027a	e9 f6 00 00 00	 jmp	 $LN1@lssproto_r
$LN19@lssproto_r:

; 1422 :             *text++ = stack[--sp];

  0027f	8b 85 e4 d7 ff
	ff		 mov	 eax, DWORD PTR _sp$[ebp]
  00285	83 e8 01	 sub	 eax, 1
  00288	89 85 e4 d7 ff
	ff		 mov	 DWORD PTR _sp$[ebp], eax
  0028e	8b 4d 08	 mov	 ecx, DWORD PTR _text$[ebp]
  00291	8b 95 e4 d7 ff
	ff		 mov	 edx, DWORD PTR _sp$[ebp]
  00297	8a 84 95 f0 d7
	ff ff		 mov	 al, BYTE PTR _stack$[ebp+edx*4]
  0029e	88 01		 mov	 BYTE PTR [ecx], al
  002a0	8b 4d 08	 mov	 ecx, DWORD PTR _text$[ebp]
  002a3	83 c1 01	 add	 ecx, 1
  002a6	89 4d 08	 mov	 DWORD PTR _text$[ebp], ecx

; 1423 :         }

  002a9	eb a9		 jmp	 SHORT $LN9@lssproto_r
$LN10@lssproto_r:

; 1424 :         /* register the pattern 'wk'*/
; 1425 :         if( len > 1 && freeNode < NODE_SIZE ){

  002ab	83 bd cc d7 ff
	ff 01		 cmp	 DWORD PTR _len$[ebp], 1
  002b2	0f 8e a6 00 00
	00		 jle	 $LN20@lssproto_r
  002b8	81 bd d8 d7 ff
	ff 00 02 00 00	 cmp	 DWORD PTR _freeNode$[ebp], 512 ; 00000200H
  002c2	0f 8d 96 00 00
	00		 jge	 $LN20@lssproto_r

; 1426 :             node[freeNode].parent = w;

  002c8	8b 85 d8 d7 ff
	ff		 mov	 eax, DWORD PTR _freeNode$[ebp]
  002ce	c1 e0 04	 shl	 eax, 4
  002d1	8b 8d a8 d7 ff
	ff		 mov	 ecx, DWORD PTR _w$[ebp]
  002d7	89 8c 05 fc df
	ff ff		 mov	 DWORD PTR _node$[ebp+eax+4], ecx

; 1427 :             node[freeNode].chr = k;

  002de	8b 85 d8 d7 ff
	ff		 mov	 eax, DWORD PTR _freeNode$[ebp]
  002e4	c1 e0 04	 shl	 eax, 4
  002e7	8a 8d b4 d7 ff
	ff		 mov	 cl, BYTE PTR _k$[ebp]
  002ed	88 8c 05 f8 df
	ff ff		 mov	 BYTE PTR _node$[ebp+eax], cl

; 1428 :             if( w >= (sizeof(node)/sizeof(node[0])))return -1;

  002f4	81 bd a8 d7 ff
	ff 00 02 00 00	 cmp	 DWORD PTR _w$[ebp], 512	; 00000200H
  002fe	72 05		 jb	 SHORT $LN21@lssproto_r
  00300	83 c8 ff	 or	 eax, -1
  00303	eb 70		 jmp	 SHORT $LN1@lssproto_r
$LN21@lssproto_r:

; 1429 :             node[freeNode].brother = node[w].child;

  00305	8b 85 a8 d7 ff
	ff		 mov	 eax, DWORD PTR _w$[ebp]
  0030b	c1 e0 04	 shl	 eax, 4
  0030e	8b 8d d8 d7 ff
	ff		 mov	 ecx, DWORD PTR _freeNode$[ebp]
  00314	c1 e1 04	 shl	 ecx, 4
  00317	8b 94 05 04 e0
	ff ff		 mov	 edx, DWORD PTR _node$[ebp+eax+12]
  0031e	89 94 0d 00 e0
	ff ff		 mov	 DWORD PTR _node$[ebp+ecx+8], edx

; 1430 :             node[freeNode].child = 0;

  00325	8b 85 d8 d7 ff
	ff		 mov	 eax, DWORD PTR _freeNode$[ebp]
  0032b	c1 e0 04	 shl	 eax, 4
  0032e	c7 84 05 04 e0
	ff ff 00 00 00
	00		 mov	 DWORD PTR _node$[ebp+eax+12], 0

; 1431 :             node[w].child = freeNode;

  00339	8b 85 a8 d7 ff
	ff		 mov	 eax, DWORD PTR _w$[ebp]
  0033f	c1 e0 04	 shl	 eax, 4
  00342	8b 8d d8 d7 ff
	ff		 mov	 ecx, DWORD PTR _freeNode$[ebp]
  00348	89 8c 05 04 e0
	ff ff		 mov	 DWORD PTR _node$[ebp+eax+12], ecx

; 1432 :             freeNode++;

  0034f	8b 85 d8 d7 ff
	ff		 mov	 eax, DWORD PTR _freeNode$[ebp]
  00355	83 c0 01	 add	 eax, 1
  00358	89 85 d8 d7 ff
	ff		 mov	 DWORD PTR _freeNode$[ebp], eax
$LN20@lssproto_r:

; 1433 :         }
; 1434 :         w = rv;

  0035e	8b 85 9c d7 ff
	ff		 mov	 eax, DWORD PTR _rv$1[ebp]
  00364	89 85 a8 d7 ff
	ff		 mov	 DWORD PTR _w$[ebp], eax

; 1435 :     }

  0036a	e9 a0 fd ff ff	 jmp	 $LN5@lssproto_r
$LN6@lssproto_r:

; 1436 :     return len;

  0036f	8b 85 cc d7 ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
$LN1@lssproto_r:

; 1437 : }

  00375	52		 push	 edx
  00376	8b cd		 mov	 ecx, ebp
  00378	50		 push	 eax
  00379	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN26@lssproto_r
  0037f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00384	58		 pop	 eax
  00385	5a		 pop	 edx
  00386	5f		 pop	 edi
  00387	5e		 pop	 esi
  00388	5b		 pop	 ebx
  00389	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0038c	33 cd		 xor	 ecx, ebp
  0038e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00393	81 c4 68 2e 00
	00		 add	 esp, 11880		; 00002e68H
  00399	3b ec		 cmp	 ebp, esp
  0039b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003a0	8b e5		 mov	 esp, ebp
  003a2	5d		 pop	 ebp
  003a3	c3		 ret	 0
$LN26@lssproto_r:
  003a4	02 00 00 00	 DD	 2
  003a8	00 00 00 00	 DD	 $LN25@lssproto_r
$LN25@lssproto_r:
  003ac	f8 df ff ff	 DD	 -8200			; ffffdff8H
  003b0	00 20 00 00	 DD	 8192			; 00002000H
  003b4	00 00 00 00	 DD	 $LN23@lssproto_r
  003b8	f0 d7 ff ff	 DD	 -10256			; ffffd7f0H
  003bc	00 08 00 00	 DD	 2048			; 00000800H
  003c0	00 00 00 00	 DD	 $LN24@lssproto_r
$LN24@lssproto_r:
  003c4	73		 DB	 115			; 00000073H
  003c5	74		 DB	 116			; 00000074H
  003c6	61		 DB	 97			; 00000061H
  003c7	63		 DB	 99			; 00000063H
  003c8	6b		 DB	 107			; 0000006bH
  003c9	00		 DB	 0
$LN23@lssproto_r:
  003ca	6e		 DB	 110			; 0000006eH
  003cb	6f		 DB	 111			; 0000006fH
  003cc	64		 DB	 100			; 00000064H
  003cd	65		 DB	 101			; 00000065H
  003ce	00		 DB	 0
?lssproto_ringoDecompressor@@YAJPAEJ0J@Z ENDP		; lssproto_ringoDecompressor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_ringoCompressor@@YAJPAEJ0J@Z
_TEXT	SEGMENT
_rv$1 = -8284						; size = 4
_position$ = -8272					; size = 4
_i$ = -8260						; size = 4
_textind$ = -8248					; size = 4
_k$ = -8236						; size = 4
_w$ = -8224						; size = 4
_freeNode$ = -8212					; size = 4
_node$ = -8200						; size = 8192
__$ArrayPad$ = -4					; size = 4
_code$ = 8						; size = 4
_codelen$ = 12						; size = 4
_text$ = 16						; size = 4
_textlen$ = 20						; size = 4
?lssproto_ringoCompressor@@YAJPAEJ0J@Z PROC		; lssproto_ringoCompressor, COMDAT

; 1312 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 60 26 00 00	 mov	 eax, 9824		; 00002660H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8d bd a0 d9 ff
	ff		 lea	 edi, DWORD PTR [ebp-9824]
  00016	b9 98 09 00 00	 mov	 ecx, 2456		; 00000998H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1313 :     NODE node[NODE_SIZE];
; 1314 :     int freeNode;        
; 1315 :     int w,k;        /* used in this algo */
; 1316 :     int textind;    /* index to text buffer */
; 1317 :     int i;
; 1318 :     int position = 0;   /* indicates the last byte of code buffer */

  0002c	c7 85 b0 df ff
	ff 00 00 00 00	 mov	 DWORD PTR _position$[ebp], 0

; 1319 :     if( textlen <= 0 ) return -1;

  00036	83 7d 14 00	 cmp	 DWORD PTR _textlen$[ebp], 0
  0003a	7f 08		 jg	 SHORT $LN9@lssproto_r
  0003c	83 c8 ff	 or	 eax, -1
  0003f	e9 6e 02 00 00	 jmp	 $LN1@lssproto_r
$LN9@lssproto_r:

; 1320 :     initOutputBitStream((char*) code,codelen);

  00044	8b 45 0c	 mov	 eax, DWORD PTR _codelen$[ebp]
  00047	50		 push	 eax
  00048	8b 4d 08	 mov	 ecx, DWORD PTR _code$[ebp]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ?initOutputBitStream@@YAHPADH@Z ; initOutputBitStream
  00051	83 c4 08	 add	 esp, 8

; 1321 :     /* fill characters ( 0 ~ 255 ) in the beggining part of
; 1322 :        Node list */
; 1323 :     for(i=0; i<= CHAR_SIZE; i++){

  00054	c7 85 bc df ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  0005e	eb 0f		 jmp	 SHORT $LN4@lssproto_r
$LN2@lssproto_r:
  00060	8b 85 bc df ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00066	83 c0 01	 add	 eax, 1
  00069	89 85 bc df ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN4@lssproto_r:
  0006f	81 bd bc df ff
	ff 00 01 00 00	 cmp	 DWORD PTR _i$[ebp], 256	; 00000100H
  00079	7f 59		 jg	 SHORT $LN3@lssproto_r

; 1324 :         node[i].chr = (unsigned char)i;

  0007b	8b 85 bc df ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00081	c1 e0 04	 shl	 eax, 4
  00084	8a 8d bc df ff
	ff		 mov	 cl, BYTE PTR _i$[ebp]
  0008a	88 8c 05 f8 df
	ff ff		 mov	 BYTE PTR _node$[ebp+eax], cl

; 1325 :         node[i].brother = i + 1;

  00091	8b 85 bc df ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00097	83 c0 01	 add	 eax, 1
  0009a	8b 8d bc df ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  000a0	c1 e1 04	 shl	 ecx, 4
  000a3	89 84 0d 00 e0
	ff ff		 mov	 DWORD PTR _node$[ebp+ecx+8], eax

; 1326 :         node[i].parent = 0;

  000aa	8b 85 bc df ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000b0	c1 e0 04	 shl	 eax, 4
  000b3	c7 84 05 fc df
	ff ff 00 00 00
	00		 mov	 DWORD PTR _node$[ebp+eax+4], 0

; 1327 :         node[i].child = 0;

  000be	8b 85 bc df ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000c4	c1 e0 04	 shl	 eax, 4
  000c7	c7 84 05 04 e0
	ff ff 00 00 00
	00		 mov	 DWORD PTR _node$[ebp+eax+12], 0

; 1328 :     }

  000d2	eb 8c		 jmp	 SHORT $LN2@lssproto_r
$LN3@lssproto_r:

; 1329 :     node[CHAR_SIZE].brother = 0;

  000d4	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000d9	c1 e0 08	 shl	 eax, 8
  000dc	c7 84 05 00 e0
	ff ff 00 00 00
	00		 mov	 DWORD PTR _node$[ebp+eax+8], 0

; 1330 :     freeNode = CHAR_SIZE + 1;

  000e7	c7 85 ec df ff
	ff 01 01 00 00	 mov	 DWORD PTR _freeNode$[ebp], 257 ; 00000101H

; 1331 :     w = text[0];

  000f1	b8 01 00 00 00	 mov	 eax, 1
  000f6	6b c8 00	 imul	 ecx, eax, 0
  000f9	8b 55 10	 mov	 edx, DWORD PTR _text$[ebp]
  000fc	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00100	89 85 e0 df ff
	ff		 mov	 DWORD PTR _w$[ebp], eax

; 1332 :     textind = 1;

  00106	c7 85 c8 df ff
	ff 01 00 00 00	 mov	 DWORD PTR _textind$[ebp], 1
$LN5@lssproto_r:

; 1333 :     while(1){

  00110	b8 01 00 00 00	 mov	 eax, 1
  00115	85 c0		 test	 eax, eax
  00117	0f 84 8f 01 00
	00		 je	 $LN6@lssproto_r

; 1334 :         int rv;
; 1335 :         if( textind >= textlen ){

  0011d	8b 85 c8 df ff
	ff		 mov	 eax, DWORD PTR _textind$[ebp]
  00123	3b 45 14	 cmp	 eax, DWORD PTR _textlen$[ebp]
  00126	7c 0c		 jl	 SHORT $LN10@lssproto_r

; 1336 :             k = CHAR_SIZE;      /* indicates EOF */

  00128	c7 85 d4 df ff
	ff 00 01 00 00	 mov	 DWORD PTR _k$[ebp], 256	; 00000100H

; 1337 :         } else {

  00132	eb 12		 jmp	 SHORT $LN11@lssproto_r
$LN10@lssproto_r:

; 1338 :             k = text[textind];

  00134	8b 45 10	 mov	 eax, DWORD PTR _text$[ebp]
  00137	03 85 c8 df ff
	ff		 add	 eax, DWORD PTR _textind$[ebp]
  0013d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00140	89 8d d4 df ff
	ff		 mov	 DWORD PTR _k$[ebp], ecx
$LN11@lssproto_r:

; 1339 :         }
; 1340 :         /* search if pattern 'wk' is registered or not. */
; 1341 :         rv = node[w].child;

  00146	8b 85 e0 df ff
	ff		 mov	 eax, DWORD PTR _w$[ebp]
  0014c	c1 e0 04	 shl	 eax, 4
  0014f	8b 8c 05 04 e0
	ff ff		 mov	 ecx, DWORD PTR _node$[ebp+eax+12]
  00156	89 8d a4 df ff
	ff		 mov	 DWORD PTR _rv$1[ebp], ecx
$LN7@lssproto_r:

; 1342 :         while(1){

  0015c	b8 01 00 00 00	 mov	 eax, 1
  00161	85 c0		 test	 eax, eax
  00163	74 3e		 je	 SHORT $LN8@lssproto_r

; 1343 :             if( rv <= 0 ) break;

  00165	83 bd a4 df ff
	ff 00		 cmp	 DWORD PTR _rv$1[ebp], 0
  0016c	7f 02		 jg	 SHORT $LN12@lssproto_r
  0016e	eb 33		 jmp	 SHORT $LN8@lssproto_r
$LN12@lssproto_r:

; 1344 :             if( node[rv].chr == k ) break;

  00170	8b 85 a4 df ff
	ff		 mov	 eax, DWORD PTR _rv$1[ebp]
  00176	c1 e0 04	 shl	 eax, 4
  00179	0f b6 8c 05 f8
	df ff ff	 movzx	 ecx, BYTE PTR _node$[ebp+eax]
  00181	3b 8d d4 df ff
	ff		 cmp	 ecx, DWORD PTR _k$[ebp]
  00187	75 02		 jne	 SHORT $LN13@lssproto_r
  00189	eb 18		 jmp	 SHORT $LN8@lssproto_r
$LN13@lssproto_r:

; 1345 :             rv = node[rv].brother;

  0018b	8b 85 a4 df ff
	ff		 mov	 eax, DWORD PTR _rv$1[ebp]
  00191	c1 e0 04	 shl	 eax, 4
  00194	8b 8c 05 00 e0
	ff ff		 mov	 ecx, DWORD PTR _node$[ebp+eax+8]
  0019b	89 8d a4 df ff
	ff		 mov	 DWORD PTR _rv$1[ebp], ecx

; 1346 :         }

  001a1	eb b9		 jmp	 SHORT $LN7@lssproto_r
$LN8@lssproto_r:

; 1347 :         if( rv > 0 ){

  001a3	83 bd a4 df ff
	ff 00		 cmp	 DWORD PTR _rv$1[ebp], 0
  001aa	7e 11		 jle	 SHORT $LN14@lssproto_r

; 1348 :             /* found it */
; 1349 :             w = rv;

  001ac	8b 85 a4 df ff
	ff		 mov	 eax, DWORD PTR _rv$1[ebp]
  001b2	89 85 e0 df ff
	ff		 mov	 DWORD PTR _w$[ebp], eax

; 1350 :         } else {

  001b8	e9 cb 00 00 00	 jmp	 $LN15@lssproto_r
$LN14@lssproto_r:

; 1351 :             position = writeOutputBitStream( BITS_LEN ,w  );

  001bd	8b 85 e0 df ff
	ff		 mov	 eax, DWORD PTR _w$[ebp]
  001c3	50		 push	 eax
  001c4	6a 09		 push	 9
  001c6	e8 00 00 00 00	 call	 ?writeOutputBitStream@@YAHHI@Z ; writeOutputBitStream
  001cb	83 c4 08	 add	 esp, 8
  001ce	89 85 b0 df ff
	ff		 mov	 DWORD PTR _position$[ebp], eax

; 1352 :             /* return if buffer excession  */
; 1353 :             if( position > codelen ) return -1;

  001d4	8b 85 b0 df ff
	ff		 mov	 eax, DWORD PTR _position$[ebp]
  001da	3b 45 0c	 cmp	 eax, DWORD PTR _codelen$[ebp]
  001dd	7e 08		 jle	 SHORT $LN16@lssproto_r
  001df	83 c8 ff	 or	 eax, -1
  001e2	e9 cb 00 00 00	 jmp	 $LN1@lssproto_r
$LN16@lssproto_r:

; 1354 :             /* register pattern 'wk' in the dictionary */
; 1355 :             if( freeNode < NODE_SIZE ){

  001e7	81 bd ec df ff
	ff 00 02 00 00	 cmp	 DWORD PTR _freeNode$[ebp], 512 ; 00000200H
  001f1	0f 8d 85 00 00
	00		 jge	 $LN17@lssproto_r

; 1356 :                 node[freeNode].parent = w;

  001f7	8b 85 ec df ff
	ff		 mov	 eax, DWORD PTR _freeNode$[ebp]
  001fd	c1 e0 04	 shl	 eax, 4
  00200	8b 8d e0 df ff
	ff		 mov	 ecx, DWORD PTR _w$[ebp]
  00206	89 8c 05 fc df
	ff ff		 mov	 DWORD PTR _node$[ebp+eax+4], ecx

; 1357 :                 node[freeNode].chr = k;

  0020d	8b 85 ec df ff
	ff		 mov	 eax, DWORD PTR _freeNode$[ebp]
  00213	c1 e0 04	 shl	 eax, 4
  00216	8a 8d d4 df ff
	ff		 mov	 cl, BYTE PTR _k$[ebp]
  0021c	88 8c 05 f8 df
	ff ff		 mov	 BYTE PTR _node$[ebp+eax], cl

; 1358 :                 node[freeNode].brother = node[w].child;

  00223	8b 85 e0 df ff
	ff		 mov	 eax, DWORD PTR _w$[ebp]
  00229	c1 e0 04	 shl	 eax, 4
  0022c	8b 8d ec df ff
	ff		 mov	 ecx, DWORD PTR _freeNode$[ebp]
  00232	c1 e1 04	 shl	 ecx, 4
  00235	8b 94 05 04 e0
	ff ff		 mov	 edx, DWORD PTR _node$[ebp+eax+12]
  0023c	89 94 0d 00 e0
	ff ff		 mov	 DWORD PTR _node$[ebp+ecx+8], edx

; 1359 :                 node[freeNode].child = 0;

  00243	8b 85 ec df ff
	ff		 mov	 eax, DWORD PTR _freeNode$[ebp]
  00249	c1 e0 04	 shl	 eax, 4
  0024c	c7 84 05 04 e0
	ff ff 00 00 00
	00		 mov	 DWORD PTR _node$[ebp+eax+12], 0

; 1360 :                 node[w].child = freeNode;

  00257	8b 85 e0 df ff
	ff		 mov	 eax, DWORD PTR _w$[ebp]
  0025d	c1 e0 04	 shl	 eax, 4
  00260	8b 8d ec df ff
	ff		 mov	 ecx, DWORD PTR _freeNode$[ebp]
  00266	89 8c 05 04 e0
	ff ff		 mov	 DWORD PTR _node$[ebp+eax+12], ecx

; 1361 :                 freeNode++;

  0026d	8b 85 ec df ff
	ff		 mov	 eax, DWORD PTR _freeNode$[ebp]
  00273	83 c0 01	 add	 eax, 1
  00276	89 85 ec df ff
	ff		 mov	 DWORD PTR _freeNode$[ebp], eax
$LN17@lssproto_r:

; 1362 :             }
; 1363 :             w = k;

  0027c	8b 85 d4 df ff
	ff		 mov	 eax, DWORD PTR _k$[ebp]
  00282	89 85 e0 df ff
	ff		 mov	 DWORD PTR _w$[ebp], eax
$LN15@lssproto_r:

; 1364 :         }
; 1365 :         if( textind == ( textlen + 1 )  ) break;

  00288	8b 45 14	 mov	 eax, DWORD PTR _textlen$[ebp]
  0028b	83 c0 01	 add	 eax, 1
  0028e	39 85 c8 df ff
	ff		 cmp	 DWORD PTR _textind$[ebp], eax
  00294	75 02		 jne	 SHORT $LN18@lssproto_r
  00296	eb 14		 jmp	 SHORT $LN6@lssproto_r
$LN18@lssproto_r:

; 1366 :         textind++;

  00298	8b 85 c8 df ff
	ff		 mov	 eax, DWORD PTR _textind$[ebp]
  0029e	83 c0 01	 add	 eax, 1
  002a1	89 85 c8 df ff
	ff		 mov	 DWORD PTR _textind$[ebp], eax

; 1367 :     }

  002a7	e9 64 fe ff ff	 jmp	 $LN5@lssproto_r
$LN6@lssproto_r:

; 1368 :     return position;

  002ac	8b 85 b0 df ff
	ff		 mov	 eax, DWORD PTR _position$[ebp]
$LN1@lssproto_r:

; 1369 : }

  002b2	52		 push	 edx
  002b3	8b cd		 mov	 ecx, ebp
  002b5	50		 push	 eax
  002b6	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN22@lssproto_r
  002bc	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002c1	58		 pop	 eax
  002c2	5a		 pop	 edx
  002c3	5f		 pop	 edi
  002c4	5e		 pop	 esi
  002c5	5b		 pop	 ebx
  002c6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c9	33 cd		 xor	 ecx, ebp
  002cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d0	81 c4 60 26 00
	00		 add	 esp, 9824		; 00002660H
  002d6	3b ec		 cmp	 ebp, esp
  002d8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002dd	8b e5		 mov	 esp, ebp
  002df	5d		 pop	 ebp
  002e0	c3		 ret	 0
  002e1	0f 1f 00	 npad	 3
$LN22@lssproto_r:
  002e4	01 00 00 00	 DD	 1
  002e8	00 00 00 00	 DD	 $LN21@lssproto_r
$LN21@lssproto_r:
  002ec	f8 df ff ff	 DD	 -8200			; ffffdff8H
  002f0	00 20 00 00	 DD	 8192			; 00002000H
  002f4	00 00 00 00	 DD	 $LN20@lssproto_r
$LN20@lssproto_r:
  002f8	6e		 DB	 110			; 0000006eH
  002f9	6f		 DB	 111			; 0000006fH
  002fa	64		 DB	 100			; 00000064H
  002fb	65		 DB	 101			; 00000065H
  002fc	00		 DB	 0
?lssproto_ringoCompressor@@YAJPAEJ0J@Z ENDP		; lssproto_ringoCompressor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_a62toi@@YAHPAD@Z
_TEXT	SEGMENT
_minus$ = -20						; size = 4
_ret$ = -8						; size = 4
_a$ = 8							; size = 4
?lssproto_a62toi@@YAHPAD@Z PROC				; lssproto_a62toi, COMDAT

; 1442 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1443 : 	int ret = 0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 1444 : 	int minus ;
; 1445 : 	if( a[0] == '-' ){

  00025	b8 01 00 00 00	 mov	 eax, 1
  0002a	6b c8 00	 imul	 ecx, eax, 0
  0002d	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00030	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00034	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00037	75 12		 jne	 SHORT $LN4@lssproto_a

; 1446 : 		minus = -1;

  00039	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _minus$[ebp], -1

; 1447 :         a++;

  00040	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00043	83 c0 01	 add	 eax, 1
  00046	89 45 08	 mov	 DWORD PTR _a$[ebp], eax

; 1448 : 	} else {

  00049	eb 07		 jmp	 SHORT $LN2@lssproto_a
$LN4@lssproto_a:

; 1449 : 		minus = 1;

  0004b	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _minus$[ebp], 1
$LN2@lssproto_a:

; 1450 : 	}
; 1451 : 	
; 1452 : 	while( *a != '\0' )

  00052	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00055	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00058	85 c9		 test	 ecx, ecx
  0005a	0f 84 91 00 00
	00		 je	 $LN3@lssproto_a

; 1453 : 	{
; 1454 : 		ret *= 62;

  00060	6b 45 f8 3e	 imul	 eax, DWORD PTR _ret$[ebp], 62
  00064	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 1455 : 		if( '0' <= (*a) && (*a) <= '9' )

  00067	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0006a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0006d	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00070	7c 1d		 jl	 SHORT $LN6@lssproto_a
  00072	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00075	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00078	83 f9 39	 cmp	 ecx, 57			; 00000039H
  0007b	7f 12		 jg	 SHORT $LN6@lssproto_a

; 1456 : 			ret += (*a)-'0';

  0007d	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00080	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00083	8b 55 f8	 mov	 edx, DWORD PTR _ret$[ebp]
  00086	8d 44 0a d0	 lea	 eax, DWORD PTR [edx+ecx-48]
  0008a	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 1457 : 		else

  0008d	eb 54		 jmp	 SHORT $LN7@lssproto_a
$LN6@lssproto_a:

; 1458 : 		if( 'a' <= (*a) && (*a) <= 'z' )

  0008f	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00092	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00095	83 f9 61	 cmp	 ecx, 97			; 00000061H
  00098	7c 1d		 jl	 SHORT $LN8@lssproto_a
  0009a	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0009d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000a0	83 f9 7a	 cmp	 ecx, 122		; 0000007aH
  000a3	7f 12		 jg	 SHORT $LN8@lssproto_a

; 1459 : 			ret += (*a)-'a'+10;

  000a5	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000a8	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000ab	8b 55 f8	 mov	 edx, DWORD PTR _ret$[ebp]
  000ae	8d 44 0a a9	 lea	 eax, DWORD PTR [edx+ecx-87]
  000b2	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 1460 : 		else

  000b5	eb 2c		 jmp	 SHORT $LN7@lssproto_a
$LN8@lssproto_a:

; 1461 : 		if( 'A' <= (*a) && (*a) <= 'Z' )

  000b7	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000ba	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000bd	83 f9 41	 cmp	 ecx, 65			; 00000041H
  000c0	7c 1d		 jl	 SHORT $LN10@lssproto_a
  000c2	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000c5	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000c8	83 f9 5a	 cmp	 ecx, 90			; 0000005aH
  000cb	7f 12		 jg	 SHORT $LN10@lssproto_a

; 1462 : 			ret += (*a)-'A'+36;

  000cd	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000d0	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000d3	8b 55 f8	 mov	 edx, DWORD PTR _ret$[ebp]
  000d6	8d 44 0a e3	 lea	 eax, DWORD PTR [edx+ecx-29]
  000da	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 1463 : 		else

  000dd	eb 04		 jmp	 SHORT $LN7@lssproto_a
$LN10@lssproto_a:

; 1464 : 			return 0;

  000df	33 c0		 xor	 eax, eax
  000e1	eb 15		 jmp	 SHORT $LN1@lssproto_a
$LN7@lssproto_a:

; 1465 : 		a++;

  000e3	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000e6	83 c0 01	 add	 eax, 1
  000e9	89 45 08	 mov	 DWORD PTR _a$[ebp], eax

; 1466 : 	}

  000ec	e9 61 ff ff ff	 jmp	 $LN2@lssproto_a
$LN3@lssproto_a:

; 1467 : 	return ret * minus;

  000f1	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  000f4	0f af 45 ec	 imul	 eax, DWORD PTR _minus$[ebp]
$LN1@lssproto_a:

; 1468 : }

  000f8	5f		 pop	 edi
  000f9	5e		 pop	 esi
  000fa	5b		 pop	 ebx
  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c3		 ret	 0
?lssproto_a62toi@@YAHPAD@Z ENDP				; lssproto_a62toi
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_cnv10to62@@YAPADHPADH@Z
_TEXT	SEGMENT
_baselen$ = -396					; size = 4
_minus$ = -384						; size = 4
_src$ = -372						; size = 4
_tmp$ = -360						; size = 256
_base$ = -96						; size = 63
_j$ = -24						; size = 4
_i$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_out$ = 12						; size = 4
_outlen$ = 16						; size = 4
?lssproto_cnv10to62@@YAPADHPADH@Z PROC			; lssproto_cnv10to62, COMDAT

; 1472 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 02 00
	00		 sub	 esp, 592		; 00000250H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd b0 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-592]
  00012	b9 94 00 00 00	 mov	 ecx, 148		; 00000094H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1473 : 	int		i, j;
; 1474 :     char    base[] = { "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"};

  00028	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  0002d	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0DP@CCELEMID@0123456789abcdefghijklmnopqrstuv@
  00032	8d 7d a0	 lea	 edi, DWORD PTR _base$[ebp]
  00035	f3 a5		 rep movsd
  00037	66 a5		 movsw
  00039	a4		 movsb

; 1475 :     int     tmp[64];
; 1476 :     int     src;
; 1477 :     int minus;
; 1478 : 	int baselen = sizeof( base)-1;

  0003a	c7 85 74 fe ff
	ff 3e 00 00 00	 mov	 DWORD PTR _baselen$[ebp], 62 ; 0000003eH

; 1479 :     if( a < 0 ){

  00044	83 7d 08 00	 cmp	 DWORD PTR _a$[ebp], 0
  00048	7d 13		 jge	 SHORT $LN11@lssproto_c

; 1480 : 		minus = 1;

  0004a	c7 85 80 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _minus$[ebp], 1

; 1481 : 		a *= -1;

  00054	6b 45 08 ff	 imul	 eax, DWORD PTR _a$[ebp], -1
  00058	89 45 08	 mov	 DWORD PTR _a$[ebp], eax

; 1482 : 	} else {

  0005b	eb 0a		 jmp	 SHORT $LN12@lssproto_c
$LN11@lssproto_c:

; 1483 : 		minus = 0;

  0005d	c7 85 80 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _minus$[ebp], 0
$LN12@lssproto_c:

; 1484 : 	}
; 1485 :     /* special case */					   
; 1486 :     if( a < baselen) {

  00067	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0006a	3b 85 74 fe ff
	ff		 cmp	 eax, DWORD PTR _baselen$[ebp]
  00070	7d 48		 jge	 SHORT $LN13@lssproto_c

; 1487 : 		if( minus ){

  00072	83 bd 80 fe ff
	ff 00		 cmp	 DWORD PTR _minus$[ebp], 0
  00079	74 24		 je	 SHORT $LN14@lssproto_c

; 1488 : 			*(out) = '-';

  0007b	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  0007e	c6 00 2d	 mov	 BYTE PTR [eax], 45	; 0000002dH

; 1489 : 			*(out+1) = base[a];

  00081	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  00084	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00087	8a 54 0d a0	 mov	 dl, BYTE PTR _base$[ebp+ecx]
  0008b	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 1490 : 			*(out+2) = '\0';

  0008e	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  00091	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0

; 1491 : 			return (out);

  00095	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  00098	e9 47 01 00 00	 jmp	 $LN1@lssproto_c

; 1492 : 		} else {

  0009d	eb 1b		 jmp	 SHORT $LN13@lssproto_c
$LN14@lssproto_c:

; 1493 : 			*out = base[a];

  0009f	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  000a2	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  000a5	8a 54 0d a0	 mov	 dl, BYTE PTR _base$[ebp+ecx]
  000a9	88 10		 mov	 BYTE PTR [eax], dl

; 1494 : 			*(out+1) = '\0';

  000ab	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  000ae	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1495 : 			return( out);

  000b2	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  000b5	e9 2a 01 00 00	 jmp	 $LN1@lssproto_c
$LN13@lssproto_c:

; 1496 : 		}
; 1497 :     }
; 1498 :     src = a;

  000ba	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000bd	89 85 8c fe ff
	ff		 mov	 DWORD PTR _src$[ebp], eax

; 1499 :     for( i = 0; src >= baselen; i ++ ) {

  000c3	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000ca	eb 09		 jmp	 SHORT $LN4@lssproto_c
$LN2@lssproto_c:
  000cc	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000cf	83 c0 01	 add	 eax, 1
  000d2	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@lssproto_c:
  000d5	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR _src$[ebp]
  000db	3b 85 74 fe ff
	ff		 cmp	 eax, DWORD PTR _baselen$[ebp]
  000e1	7c 2c		 jl	 SHORT $LN3@lssproto_c

; 1500 :         tmp[i] = src % baselen;

  000e3	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR _src$[ebp]
  000e9	99		 cdq
  000ea	f7 bd 74 fe ff
	ff		 idiv	 DWORD PTR _baselen$[ebp]
  000f0	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000f3	89 94 85 98 fe
	ff ff		 mov	 DWORD PTR _tmp$[ebp+eax*4], edx

; 1501 :         src /= baselen;

  000fa	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR _src$[ebp]
  00100	99		 cdq
  00101	f7 bd 74 fe ff
	ff		 idiv	 DWORD PTR _baselen$[ebp]
  00107	89 85 8c fe ff
	ff		 mov	 DWORD PTR _src$[ebp], eax

; 1502 :     }

  0010d	eb bd		 jmp	 SHORT $LN2@lssproto_c
$LN3@lssproto_c:

; 1503 :     i--;

  0010f	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00112	83 e8 01	 sub	 eax, 1
  00115	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax

; 1504 :     if( minus ){

  00118	83 bd 80 fe ff
	ff 00		 cmp	 DWORD PTR _minus$[ebp], 0
  0011f	74 60		 je	 SHORT $LN16@lssproto_c

; 1505 : 		*out = '-';

  00121	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  00124	c6 00 2d	 mov	 BYTE PTR [eax], 45	; 0000002dH

; 1506 :      	*(out+1) = base[src];

  00127	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  0012a	8b 8d 8c fe ff
	ff		 mov	 ecx, DWORD PTR _src$[ebp]
  00130	8a 54 0d a0	 mov	 dl, BYTE PTR _base$[ebp+ecx]
  00134	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 1507 : 		for( j = 2; i >= 0; i --, j ++ ) {

  00137	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR _j$[ebp], 2
  0013e	eb 12		 jmp	 SHORT $LN7@lssproto_c
$LN5@lssproto_c:
  00140	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00143	83 e8 01	 sub	 eax, 1
  00146	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
  00149	8b 4d e8	 mov	 ecx, DWORD PTR _j$[ebp]
  0014c	83 c1 01	 add	 ecx, 1
  0014f	89 4d e8	 mov	 DWORD PTR _j$[ebp], ecx
$LN7@lssproto_c:
  00152	83 7d f4 00	 cmp	 DWORD PTR _i$[ebp], 0
  00156	7c 27		 jl	 SHORT $LN6@lssproto_c

; 1508 : 			if( j > outlen - 2 ) return NULL;

  00158	8b 45 10	 mov	 eax, DWORD PTR _outlen$[ebp]
  0015b	83 e8 02	 sub	 eax, 2
  0015e	39 45 e8	 cmp	 DWORD PTR _j$[ebp], eax
  00161	7e 04		 jle	 SHORT $LN18@lssproto_c
  00163	33 c0		 xor	 eax, eax
  00165	eb 7d		 jmp	 SHORT $LN1@lssproto_c
$LN18@lssproto_c:

; 1509 : 			*(out+j) = base[tmp[i]];

  00167	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0016a	8b 8c 85 98 fe
	ff ff		 mov	 ecx, DWORD PTR _tmp$[ebp+eax*4]
  00171	8b 55 0c	 mov	 edx, DWORD PTR _out$[ebp]
  00174	03 55 e8	 add	 edx, DWORD PTR _j$[ebp]
  00177	8a 44 0d a0	 mov	 al, BYTE PTR _base$[ebp+ecx]
  0017b	88 02		 mov	 BYTE PTR [edx], al

; 1510 : 		}		

  0017d	eb c1		 jmp	 SHORT $LN5@lssproto_c
$LN6@lssproto_c:

; 1511 : 	} else {

  0017f	eb 57		 jmp	 SHORT $LN17@lssproto_c
$LN16@lssproto_c:

; 1512 :      	*out = base[src];

  00181	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  00184	8b 8d 8c fe ff
	ff		 mov	 ecx, DWORD PTR _src$[ebp]
  0018a	8a 54 0d a0	 mov	 dl, BYTE PTR _base$[ebp+ecx]
  0018e	88 10		 mov	 BYTE PTR [eax], dl

; 1513 : 		for( j = 1; i >= 0; i --, j ++ ) {

  00190	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _j$[ebp], 1
  00197	eb 12		 jmp	 SHORT $LN10@lssproto_c
$LN8@lssproto_c:
  00199	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0019c	83 e8 01	 sub	 eax, 1
  0019f	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
  001a2	8b 4d e8	 mov	 ecx, DWORD PTR _j$[ebp]
  001a5	83 c1 01	 add	 ecx, 1
  001a8	89 4d e8	 mov	 DWORD PTR _j$[ebp], ecx
$LN10@lssproto_c:
  001ab	83 7d f4 00	 cmp	 DWORD PTR _i$[ebp], 0
  001af	7c 27		 jl	 SHORT $LN17@lssproto_c

; 1514 : 			if( j > outlen - 2 ) return NULL;

  001b1	8b 45 10	 mov	 eax, DWORD PTR _outlen$[ebp]
  001b4	83 e8 02	 sub	 eax, 2
  001b7	39 45 e8	 cmp	 DWORD PTR _j$[ebp], eax
  001ba	7e 04		 jle	 SHORT $LN19@lssproto_c
  001bc	33 c0		 xor	 eax, eax
  001be	eb 24		 jmp	 SHORT $LN1@lssproto_c
$LN19@lssproto_c:

; 1515 : 			*(out+j) = base[tmp[i]];

  001c0	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  001c3	8b 8c 85 98 fe
	ff ff		 mov	 ecx, DWORD PTR _tmp$[ebp+eax*4]
  001ca	8b 55 0c	 mov	 edx, DWORD PTR _out$[ebp]
  001cd	03 55 e8	 add	 edx, DWORD PTR _j$[ebp]
  001d0	8a 44 0d a0	 mov	 al, BYTE PTR _base$[ebp+ecx]
  001d4	88 02		 mov	 BYTE PTR [edx], al

; 1516 : 		}		

  001d6	eb c1		 jmp	 SHORT $LN8@lssproto_c
$LN17@lssproto_c:

; 1517 : 	}
; 1518 : 	*(out+j) = '\0';

  001d8	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  001db	03 45 e8	 add	 eax, DWORD PTR _j$[ebp]
  001de	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1519 :     return( out);

  001e1	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
$LN1@lssproto_c:

; 1520 : }

  001e4	52		 push	 edx
  001e5	8b cd		 mov	 ecx, ebp
  001e7	50		 push	 eax
  001e8	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN24@lssproto_c
  001ee	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001f3	58		 pop	 eax
  001f4	5a		 pop	 edx
  001f5	5f		 pop	 edi
  001f6	5e		 pop	 esi
  001f7	5b		 pop	 ebx
  001f8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001fb	33 cd		 xor	 ecx, ebp
  001fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00202	8b e5		 mov	 esp, ebp
  00204	5d		 pop	 ebp
  00205	c3		 ret	 0
  00206	66 90		 npad	 2
$LN24@lssproto_c:
  00208	02 00 00 00	 DD	 2
  0020c	00 00 00 00	 DD	 $LN23@lssproto_c
$LN23@lssproto_c:
  00210	a0 ff ff ff	 DD	 -96			; ffffffa0H
  00214	3f 00 00 00	 DD	 63			; 0000003fH
  00218	00 00 00 00	 DD	 $LN21@lssproto_c
  0021c	98 fe ff ff	 DD	 -360			; fffffe98H
  00220	00 01 00 00	 DD	 256			; 00000100H
  00224	00 00 00 00	 DD	 $LN22@lssproto_c
$LN22@lssproto_c:
  00228	74		 DB	 116			; 00000074H
  00229	6d		 DB	 109			; 0000006dH
  0022a	70		 DB	 112			; 00000070H
  0022b	00		 DB	 0
$LN21@lssproto_c:
  0022c	62		 DB	 98			; 00000062H
  0022d	61		 DB	 97			; 00000061H
  0022e	73		 DB	 115			; 00000073H
  0022f	65		 DB	 101			; 00000065H
  00230	00		 DB	 0
?lssproto_cnv10to62@@YAPADHPADH@Z ENDP			; lssproto_cnv10to62
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_DebugSend@@YAXHPAD@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_msg$ = 12						; size = 4
?lssproto_DebugSend@@YAXHPAD@Z PROC			; lssproto_DebugSend, COMDAT

; 542  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 543  : 	lssproto_Send( fd, msg );

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _msg$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _fd$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ?lssproto_Send@@YAXHPAD@Z ; lssproto_Send
  0002b	83 c4 08	 add	 esp, 8

; 544  : }

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?lssproto_DebugSend@@YAXHPAD@Z ENDP			; lssproto_DebugSend
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_Ultoa@@YAPADK@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?lssproto_Ultoa@@YAPADK@Z PROC				; lssproto_Ultoa, COMDAT

; 595  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 596  : 	static char _ultoa_out[64];
; 597  : 	sprintf( _ultoa_out , "%u" , (unsigned int)v );

  0001e	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00021	50		 push	 eax
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu?$AA@
  00027	68 00 00 00 00	 push	 OFFSET ?_ultoa_out@?1??lssproto_Ultoa@@YAPADK@Z@4PADA
  0002c	e8 00 00 00 00	 call	 _sprintf
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 598  : 	return _ultoa_out;

  00034	b8 00 00 00 00	 mov	 eax, OFFSET ?_ultoa_out@?1??lssproto_Ultoa@@YAPADK@Z@4PADA

; 599  : }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?lssproto_Ultoa@@YAPADK@Z ENDP				; lssproto_Ultoa
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_Ltoa@@YAPADJ@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?lssproto_Ltoa@@YAPADJ@Z PROC				; lssproto_Ltoa, COMDAT

; 588  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 589  : 	static char _ltoa_out[64];
; 590  : 	lssproto_cnv10to62( (int)v , _ltoa_out , sizeof( _ltoa_out ));

  0001e	6a 40		 push	 64			; 00000040H
  00020	68 00 00 00 00	 push	 OFFSET ?_ltoa_out@?1??lssproto_Ltoa@@YAPADJ@Z@4PADA
  00025	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?lssproto_cnv10to62@@YAPADHPADH@Z ; lssproto_cnv10to62
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 591  : /*	sprintf( _ltoa_out , "%d" , (int)v );*/
; 592  : 	return _ltoa_out;

  00031	b8 00 00 00 00	 mov	 eax, OFFSET ?_ltoa_out@?1??lssproto_Ltoa@@YAPADJ@Z@4PADA

; 593  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
?lssproto_Ltoa@@YAPADJ@Z ENDP				; lssproto_Ltoa
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_bcopy@@YAXPAD0H@Z
_TEXT	SEGMENT
_pd$ = -32						; size = 4
_ps$ = -20						; size = 4
_i$ = -8						; size = 4
_s$ = 8							; size = 4
_d$ = 12						; size = 4
_siz$ = 16						; size = 4
?lssproto_bcopy@@YAXPAD0H@Z PROC			; lssproto_bcopy, COMDAT

; 627  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 628  :     unsigned int i;
; 629  :     int *ps,*pd;
; 630  :     ps = (int*)s;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR _ps$[ebp], eax

; 631  :     pd = (int*)d;

  00024	8b 45 0c	 mov	 eax, DWORD PTR _d$[ebp]
  00027	89 45 e0	 mov	 DWORD PTR _pd$[ebp], eax

; 632  :     for(i=0;i<siz/sizeof(int);i++) {

  0002a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00031	eb 09		 jmp	 SHORT $LN4@lssproto_b
$LN2@lssproto_b:
  00033	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00036	83 c0 01	 add	 eax, 1
  00039	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@lssproto_b:
  0003c	8b 45 10	 mov	 eax, DWORD PTR _siz$[ebp]
  0003f	c1 e8 02	 shr	 eax, 2
  00042	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  00045	73 14		 jae	 SHORT $LN3@lssproto_b

; 633  :         *(pd+i) = *(ps+i);

  00047	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0004a	8b 4d e0	 mov	 ecx, DWORD PTR _pd$[ebp]
  0004d	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00050	8b 75 ec	 mov	 esi, DWORD PTR _ps$[ebp]
  00053	8b 14 96	 mov	 edx, DWORD PTR [esi+edx*4]
  00056	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 634  :     }

  00059	eb d8		 jmp	 SHORT $LN2@lssproto_b
$LN3@lssproto_b:

; 635  :     for(i=0;i<siz%sizeof(int);i++) {

  0005b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00062	eb 09		 jmp	 SHORT $LN7@lssproto_b
$LN5@lssproto_b:
  00064	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00067	83 c0 01	 add	 eax, 1
  0006a	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@lssproto_b:
  0006d	8b 45 10	 mov	 eax, DWORD PTR _siz$[ebp]
  00070	33 d2		 xor	 edx, edx
  00072	b9 04 00 00 00	 mov	 ecx, 4
  00077	f7 f1		 div	 ecx
  00079	39 55 f8	 cmp	 DWORD PTR _i$[ebp], edx
  0007c	73 20		 jae	 SHORT $LN1@lssproto_b

; 636  :         *(d+siz-1-i)=*(s+siz-1-i);

  0007e	8b 45 10	 mov	 eax, DWORD PTR _siz$[ebp]
  00081	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00084	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  00088	2b 55 f8	 sub	 edx, DWORD PTR _i$[ebp]
  0008b	8b 45 10	 mov	 eax, DWORD PTR _siz$[ebp]
  0008e	8b 4d 0c	 mov	 ecx, DWORD PTR _d$[ebp]
  00091	8d 44 01 ff	 lea	 eax, DWORD PTR [ecx+eax-1]
  00095	2b 45 f8	 sub	 eax, DWORD PTR _i$[ebp]
  00098	8a 0a		 mov	 cl, BYTE PTR [edx]
  0009a	88 08		 mov	 BYTE PTR [eax], cl

; 637  :     }

  0009c	eb c6		 jmp	 SHORT $LN5@lssproto_b
$LN1@lssproto_b:

; 638  : }

  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	5b		 pop	 ebx
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
?lssproto_bcopy@@YAXPAD0H@Z ENDP			; lssproto_bcopy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_bzero@@YAXPADH@Z
_TEXT	SEGMENT
_p$ = -20						; size = 4
_i$ = -8						; size = 4
_b$ = 8							; size = 4
_siz$ = 12						; size = 4
?lssproto_bzero@@YAXPADH@Z PROC				; lssproto_bzero, COMDAT

; 612  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 613  : 	unsigned int i;
; 614  : 	int *p;
; 615  : 	p = (int*)b;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _b$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR _p$[ebp], eax

; 616  : 	for(i=0;i<siz/sizeof(int);i++) {

  00024	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002b	eb 09		 jmp	 SHORT $LN4@lssproto_b
$LN2@lssproto_b:
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00030	83 c0 01	 add	 eax, 1
  00033	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@lssproto_b:
  00036	8b 45 0c	 mov	 eax, DWORD PTR _siz$[ebp]
  00039	c1 e8 02	 shr	 eax, 2
  0003c	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  0003f	73 0f		 jae	 SHORT $LN3@lssproto_b

; 617  : 		*(p+i)=0;

  00041	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00044	8b 4d ec	 mov	 ecx, DWORD PTR _p$[ebp]
  00047	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [ecx+eax*4], 0

; 618  : 	}

  0004e	eb dd		 jmp	 SHORT $LN2@lssproto_b
$LN3@lssproto_b:

; 619  : 	for(i=0;i<siz%sizeof(int);i++) {

  00050	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00057	eb 09		 jmp	 SHORT $LN7@lssproto_b
$LN5@lssproto_b:
  00059	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0005c	83 c0 01	 add	 eax, 1
  0005f	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@lssproto_b:
  00062	8b 45 0c	 mov	 eax, DWORD PTR _siz$[ebp]
  00065	33 d2		 xor	 edx, edx
  00067	b9 04 00 00 00	 mov	 ecx, 4
  0006c	f7 f1		 div	 ecx
  0006e	39 55 f8	 cmp	 DWORD PTR _i$[ebp], edx
  00071	73 12		 jae	 SHORT $LN1@lssproto_b

; 620  : 		*(b+siz-1-i)=0;

  00073	8b 45 0c	 mov	 eax, DWORD PTR _siz$[ebp]
  00076	8b 4d 08	 mov	 ecx, DWORD PTR _b$[ebp]
  00079	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  0007d	2b 55 f8	 sub	 edx, DWORD PTR _i$[ebp]
  00080	c6 02 00	 mov	 BYTE PTR [edx], 0

; 621  : 	}

  00083	eb d4		 jmp	 SHORT $LN5@lssproto_b
$LN1@lssproto_b:

; 622  : }

  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?lssproto_bzero@@YAXPADH@Z ENDP				; lssproto_bzero
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_default_write_wrap@@YAHHPADH@Z
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_buf$ = 12						; size = 4
_size$ = 16						; size = 4
?lssproto_default_write_wrap@@YAHHPADH@Z PROC		; lssproto_default_write_wrap, COMDAT

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 496  : #ifndef WIN32
; 497  : 	return write( fd , buf , size );
; 498  : #else
; 499  : 	return 0;

  0001e	33 c0		 xor	 eax, eax

; 500  : #endif
; 501  : }

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?lssproto_default_write_wrap@@YAHHPADH@Z ENDP		; lssproto_default_write_wrap
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_CreateHeaderID@@YAXPADK0@Z
_TEXT	SEGMENT
_out$ = 8						; size = 4
_msgid$ = 12						; size = 4
_fname$ = 16						; size = 4
?lssproto_CreateHeaderID@@YAXPADK0@Z PROC		; lssproto_CreateHeaderID, COMDAT

; 584  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 585  : 	sprintf( out ,"%u %s " , (unsigned int)msgid , fname );

  0001e	8b 45 10	 mov	 eax, DWORD PTR _fname$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _msgid$[ebp]
  00025	51		 push	 ecx
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_06DBOHCIGL@?$CFu?5?$CFs?5?$AA@
  0002b	8b 55 08	 mov	 edx, DWORD PTR _out$[ebp]
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 _sprintf
  00034	83 c4 10	 add	 esp, 16			; 00000010H

; 586  : }

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?lssproto_CreateHeaderID@@YAXPADK0@Z ENDP		; lssproto_CreateHeaderID
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_CreateHeader@@YAXPAD0@Z
_TEXT	SEGMENT
_out$ = 8						; size = 4
_fname$ = 12						; size = 4
?lssproto_CreateHeader@@YAXPAD0@Z PROC			; lssproto_CreateHeader, COMDAT

; 580  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 581  : 	sprintf( out ,"%u %s " , lssproto_GetNewMessageID() , fname );

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _fname$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?lssproto_GetNewMessageID@@YAIXZ ; lssproto_GetNewMessageID
  00027	50		 push	 eax
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_06DBOHCIGL@?$CFu?5?$CFs?5?$AA@
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _out$[ebp]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 _sprintf
  00036	83 c4 10	 add	 esp, 16			; 00000010H

; 582  : }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?lssproto_CreateHeader@@YAXPAD0@Z ENDP			; lssproto_CreateHeader
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_GetNewMessageID@@YAIXZ
_TEXT	SEGMENT
tv65 = -196						; size = 4
?lssproto_GetNewMessageID@@YAIXZ PROC			; lssproto_GetNewMessageID, COMDAT

; 534  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 535  : 	return lssproto.message_id++;

  0001e	a1 30 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+48
  00023	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv65[ebp], eax
  00029	8b 0d 30 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+48
  0002f	83 c1 01	 add	 ecx, 1
  00032	89 0d 30 00 00
	00		 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+48, ecx
  00038	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv65[ebp]

; 536  : }

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?lssproto_GetNewMessageID@@YAIXZ ENDP			; lssproto_GetNewMessageID
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_AllocateCommonWork@@YAHH@Z
_TEXT	SEGMENT
tv200 = -196						; size = 4
tv84 = -196						; size = 4
_bufsiz$ = 8						; size = 4
?lssproto_AllocateCommonWork@@YAHH@Z PROC		; lssproto_AllocateCommonWork, COMDAT

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 28   : // Terry add for functionmemory leak 
; 29   : 	static BOOL bInit;
; 30   : // Terry end
; 31   : 	// Nuke start
; 32   : 	/*int i;
; 33   : 	NJT_dummy=(char *)MALLOC(time(NULL)%bufsiz);
; 34   : 	for (i=0;i<NJT_MAX;i++) {
; 35   : 		NJT[i]=NULL;
; 36   : 		NJT[i]=(char *)MALLOC(bufsiz);
; 37   : 	}
; 38   : 	for (i=0;i<NJT_MAX;i++) if (NJT[i]) break;
; 39   : 	if (i==NJT_MAX) return -1;*/
; 40   : 	// Nuke end
; 41   : // Terry modify markcode
; 42   : 	if(bInit){

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bInit@?1??lssproto_AllocateCommonWork@@YAHH@Z@4HA, 0
  00025	0f 84 53 01 00
	00		 je	 $LN2@lssproto_A

; 43   : 		if(lssproto.work) FREE( lssproto.work);

  0002b	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR ?lssproto@@3Ulssproto_@@A+8, 0
  00032	74 18		 je	 SHORT $LN3@lssproto_A
  00034	8b f4		 mov	 esi, esp
  00036	a1 08 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+8
  0003b	50		 push	 eax
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00042	83 c4 04	 add	 esp, 4
  00045	3b f4		 cmp	 esi, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@lssproto_A:

; 44   : 		if(lssproto.arraywork) FREE( lssproto.arraywork );

  0004c	83 3d 0c 00 00
	00 00		 cmp	 DWORD PTR ?lssproto@@3Ulssproto_@@A+12, 0
  00053	74 18		 je	 SHORT $LN4@lssproto_A
  00055	8b f4		 mov	 esi, esp
  00057	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  0005c	50		 push	 eax
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00063	83 c4 04	 add	 esp, 4
  00066	3b f4		 cmp	 esi, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@lssproto_A:

; 45   : 		if(lssproto.escapework) FREE( lssproto.escapework);

  0006d	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR ?lssproto@@3Ulssproto_@@A+16, 0
  00074	74 18		 je	 SHORT $LN5@lssproto_A
  00076	8b f4		 mov	 esi, esp
  00078	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  0007d	50		 push	 eax
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00084	83 c4 04	 add	 esp, 4
  00087	3b f4		 cmp	 esi, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@lssproto_A:

; 46   : 		if(lssproto.val_str) FREE( lssproto.val_str);

  0008e	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR ?lssproto@@3Ulssproto_@@A+20, 0
  00095	74 18		 je	 SHORT $LN6@lssproto_A
  00097	8b f4		 mov	 esi, esp
  00099	a1 14 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  0009e	50		 push	 eax
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000a5	83 c4 04	 add	 esp, 4
  000a8	3b f4		 cmp	 esi, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@lssproto_A:

; 47   : 		if(lssproto.token_list) FREE( lssproto.token_list);

  000af	83 3d 2c 00 00
	00 00		 cmp	 DWORD PTR ?lssproto@@3Ulssproto_@@A+44, 0
  000b6	74 18		 je	 SHORT $LN7@lssproto_A
  000b8	8b f4		 mov	 esi, esp
  000ba	a1 2c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+44
  000bf	50		 push	 eax
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000c6	83 c4 04	 add	 esp, 4
  000c9	3b f4		 cmp	 esi, esp
  000cb	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN7@lssproto_A:

; 48   : 		if(lssproto.cryptwork) FREE( lssproto.cryptwork );

  000d0	83 3d 1c 00 00
	00 00		 cmp	 DWORD PTR ?lssproto@@3Ulssproto_@@A+28, 0
  000d7	74 18		 je	 SHORT $LN8@lssproto_A
  000d9	8b f4		 mov	 esi, esp
  000db	a1 1c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+28
  000e0	50		 push	 eax
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000e7	83 c4 04	 add	 esp, 4
  000ea	3b f4		 cmp	 esi, esp
  000ec	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN8@lssproto_A:

; 49   : 		if(lssproto.jencodecopy) FREE( lssproto.jencodecopy );

  000f1	83 3d 20 00 00
	00 00		 cmp	 DWORD PTR ?lssproto@@3Ulssproto_@@A+32, 0
  000f8	74 18		 je	 SHORT $LN9@lssproto_A
  000fa	8b f4		 mov	 esi, esp
  000fc	a1 20 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+32
  00101	50		 push	 eax
  00102	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00108	83 c4 04	 add	 esp, 4
  0010b	3b f4		 cmp	 esi, esp
  0010d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN9@lssproto_A:

; 50   : 		if(lssproto.jencodeout) FREE( lssproto.jencodeout );

  00112	83 3d 24 00 00
	00 00		 cmp	 DWORD PTR ?lssproto@@3Ulssproto_@@A+36, 0
  00119	74 18		 je	 SHORT $LN10@lssproto_A
  0011b	8b f4		 mov	 esi, esp
  0011d	a1 24 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+36
  00122	50		 push	 eax
  00123	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00129	83 c4 04	 add	 esp, 4
  0012c	3b f4		 cmp	 esi, esp
  0012e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN10@lssproto_A:

; 51   : 		if(lssproto.compresswork) FREE( lssproto.compresswork );

  00133	83 3d 28 00 00
	00 00		 cmp	 DWORD PTR ?lssproto@@3Ulssproto_@@A+40, 0
  0013a	74 18		 je	 SHORT $LN11@lssproto_A
  0013c	8b f4		 mov	 esi, esp
  0013e	a1 28 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+40
  00143	50		 push	 eax
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0014a	83 c4 04	 add	 esp, 4
  0014d	3b f4		 cmp	 esi, esp
  0014f	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN11@lssproto_A:

; 52   : 		bInit = !bInit;

  00154	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bInit@?1??lssproto_AllocateCommonWork@@YAHH@Z@4HA, 0
  0015b	75 0c		 jne	 SHORT $LN13@lssproto_A
  0015d	c7 85 3c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv84[ebp], 1
  00167	eb 0a		 jmp	 SHORT $LN14@lssproto_A
$LN13@lssproto_A:
  00169	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv84[ebp], 0
$LN14@lssproto_A:
  00173	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv84[ebp]
  00179	a3 00 00 00 00	 mov	 DWORD PTR ?bInit@?1??lssproto_AllocateCommonWork@@YAHH@Z@4HA, eax
$LN2@lssproto_A:

; 53   : 	}
; 54   : // end
; 55   : 	lssproto.workbufsize = bufsiz;

  0017e	8b 45 08	 mov	 eax, DWORD PTR _bufsiz$[ebp]
  00181	a3 04 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+4, eax

; 56   : //	lssproto.work = NJT[i];
; 57   : 	lssproto.arraywork = NULL;

  00186	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+12, 0

; 58   : 	lssproto.escapework = NULL;

  00190	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+16, 0

; 59   : 	lssproto.val_str = NULL;

  0019a	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+20, 0

; 60   : 	lssproto.token_list = NULL;

  001a4	c7 05 2c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+44, 0

; 61   : 	lssproto.cryptwork = NULL;

  001ae	c7 05 1c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+28, 0

; 62   : 	lssproto.jencodecopy = NULL;

  001b8	c7 05 20 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+32, 0

; 63   : 	lssproto.jencodeout = NULL;

  001c2	c7 05 24 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+36, 0

; 64   : 	lssproto.compresswork = NULL;

  001cc	c7 05 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+40, 0

; 65   : 	lssproto.work = (char*)MALLOC( lssproto.workbufsize );

  001d6	8b f4		 mov	 esi, esp
  001d8	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  001dd	50		 push	 eax
  001de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  001e4	83 c4 04	 add	 esp, 4
  001e7	3b f4		 cmp	 esi, esp
  001e9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ee	a3 08 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+8, eax

; 66   : 	lssproto.arraywork = (char*)MALLOC( lssproto.workbufsize );

  001f3	8b f4		 mov	 esi, esp
  001f5	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  001fa	50		 push	 eax
  001fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00201	83 c4 04	 add	 esp, 4
  00204	3b f4		 cmp	 esi, esp
  00206	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0020b	a3 0c 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+12, eax

; 67   : 	lssproto.escapework = (char*)MALLOC( lssproto.workbufsize );

  00210	8b f4		 mov	 esi, esp
  00212	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00217	50		 push	 eax
  00218	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0021e	83 c4 04	 add	 esp, 4
  00221	3b f4		 cmp	 esi, esp
  00223	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00228	a3 10 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+16, eax

; 68   : 	lssproto.val_str = (char*)MALLOC( lssproto.workbufsize );

  0022d	8b f4		 mov	 esi, esp
  0022f	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00234	50		 push	 eax
  00235	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0023b	83 c4 04	 add	 esp, 4
  0023e	3b f4		 cmp	 esi, esp
  00240	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00245	a3 14 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+20, eax

; 69   : 	lssproto.token_list = (char**)MALLOC( lssproto.workbufsize *sizeof( char** ) );

  0024a	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  0024f	c1 e0 02	 shl	 eax, 2
  00252	8b f4		 mov	 esi, esp
  00254	50		 push	 eax
  00255	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0025b	83 c4 04	 add	 esp, 4
  0025e	3b f4		 cmp	 esi, esp
  00260	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00265	a3 2c 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+44, eax

; 70   : 	lssproto.cryptwork = (char*)MALLOC( lssproto.workbufsize * 3 );

  0026a	6b 05 04 00 00
	00 03		 imul	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4, 3
  00271	8b f4		 mov	 esi, esp
  00273	50		 push	 eax
  00274	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0027a	83 c4 04	 add	 esp, 4
  0027d	3b f4		 cmp	 esi, esp
  0027f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00284	a3 1c 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+28, eax

; 71   : 	lssproto.jencodecopy = (char*)MALLOC( lssproto.workbufsize * 3 );

  00289	6b 05 04 00 00
	00 03		 imul	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4, 3
  00290	8b f4		 mov	 esi, esp
  00292	50		 push	 eax
  00293	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00299	83 c4 04	 add	 esp, 4
  0029c	3b f4		 cmp	 esi, esp
  0029e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002a3	a3 20 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+32, eax

; 72   : 	lssproto.jencodeout = (char*)MALLOC( lssproto.workbufsize * 3 );

  002a8	6b 05 04 00 00
	00 03		 imul	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4, 3
  002af	8b f4		 mov	 esi, esp
  002b1	50		 push	 eax
  002b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  002b8	83 c4 04	 add	 esp, 4
  002bb	3b f4		 cmp	 esi, esp
  002bd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002c2	a3 24 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+36, eax

; 73   : 	lssproto.compresswork = (char*)MALLOC( lssproto.workbufsize * 3 );

  002c7	6b 05 04 00 00
	00 03		 imul	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4, 3
  002ce	8b f4		 mov	 esi, esp
  002d0	50		 push	 eax
  002d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  002d7	83 c4 04	 add	 esp, 4
  002da	3b f4		 cmp	 esi, esp
  002dc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002e1	a3 28 00 00 00	 mov	 DWORD PTR ?lssproto@@3Ulssproto_@@A+40, eax

; 74   : 	memset( lssproto.work , 0, lssproto.workbufsize );

  002e6	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  002eb	50		 push	 eax
  002ec	6a 00		 push	 0
  002ee	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+8
  002f4	51		 push	 ecx
  002f5	e8 00 00 00 00	 call	 _memset
  002fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 75   : 	memset( lssproto.arraywork , 0, lssproto.workbufsize );

  002fd	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00302	50		 push	 eax
  00303	6a 00		 push	 0
  00305	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  0030b	51		 push	 ecx
  0030c	e8 00 00 00 00	 call	 _memset
  00311	83 c4 0c	 add	 esp, 12			; 0000000cH

; 76   : 	memset( lssproto.escapework , 0, lssproto.workbufsize );

  00314	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00319	50		 push	 eax
  0031a	6a 00		 push	 0
  0031c	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  00322	51		 push	 ecx
  00323	e8 00 00 00 00	 call	 _memset
  00328	83 c4 0c	 add	 esp, 12			; 0000000cH

; 77   : 	memset( lssproto.val_str , 0, lssproto.workbufsize );

  0032b	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00330	50		 push	 eax
  00331	6a 00		 push	 0
  00333	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00339	51		 push	 ecx
  0033a	e8 00 00 00 00	 call	 _memset
  0033f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 78   : 	memset( (char*)lssproto.token_list ,0,  lssproto.workbufsize*sizeof(char**) );

  00342	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00347	c1 e0 02	 shl	 eax, 2
  0034a	50		 push	 eax
  0034b	6a 00		 push	 0
  0034d	8b 0d 2c 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+44
  00353	51		 push	 ecx
  00354	e8 00 00 00 00	 call	 _memset
  00359	83 c4 0c	 add	 esp, 12			; 0000000cH

; 79   : 	memset( lssproto.cryptwork , 0, lssproto.workbufsize*3 );

  0035c	6b 05 04 00 00
	00 03		 imul	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4, 3
  00363	50		 push	 eax
  00364	6a 00		 push	 0
  00366	8b 0d 1c 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+28
  0036c	51		 push	 ecx
  0036d	e8 00 00 00 00	 call	 _memset
  00372	83 c4 0c	 add	 esp, 12			; 0000000cH

; 80   : 	memset( lssproto.jencodecopy , 0, lssproto.workbufsize*3 );

  00375	6b 05 04 00 00
	00 03		 imul	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4, 3
  0037c	50		 push	 eax
  0037d	6a 00		 push	 0
  0037f	8b 0d 20 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+32
  00385	51		 push	 ecx
  00386	e8 00 00 00 00	 call	 _memset
  0038b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 81   : 	memset( lssproto.jencodeout , 0, lssproto.workbufsize*3 );

  0038e	6b 05 04 00 00
	00 03		 imul	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4, 3
  00395	50		 push	 eax
  00396	6a 00		 push	 0
  00398	8b 0d 24 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+36
  0039e	51		 push	 ecx
  0039f	e8 00 00 00 00	 call	 _memset
  003a4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 82   : 	memset( lssproto.compresswork , 0, lssproto.workbufsize*3 );

  003a7	6b 05 04 00 00
	00 03		 imul	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4, 3
  003ae	50		 push	 eax
  003af	6a 00		 push	 0
  003b1	8b 0d 28 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+40
  003b7	51		 push	 ecx
  003b8	e8 00 00 00 00	 call	 _memset
  003bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 83   : // Terry modify 
; 84   : 	bInit = !bInit;

  003c0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bInit@?1??lssproto_AllocateCommonWork@@YAHH@Z@4HA, 0
  003c7	75 0c		 jne	 SHORT $LN15@lssproto_A
  003c9	c7 85 3c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv200[ebp], 1
  003d3	eb 0a		 jmp	 SHORT $LN16@lssproto_A
$LN15@lssproto_A:
  003d5	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv200[ebp], 0
$LN16@lssproto_A:
  003df	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv200[ebp]
  003e5	a3 00 00 00 00	 mov	 DWORD PTR ?bInit@?1??lssproto_AllocateCommonWork@@YAHH@Z@4HA, eax

; 85   : /*	if( lssproto.work == NULL ||
; 86   : 	   lssproto.arraywork == NULL ||
; 87   : 	   lssproto.escapework == NULL ||
; 88   : 	   lssproto.val_str == NULL ||
; 89   : 	   lssproto.token_list == NULL ||
; 90   : 	   lssproto.cryptwork == NULL ||
; 91   : 	   lssproto.jencodecopy == NULL ||
; 92   : 	   lssproto.jencodeout == NULL ||
; 93   : 	   lssproto.compresswork == NULL ){
; 94   : 	    FREE( lssproto.work);FREE( lssproto.val_str);
; 95   : 	    FREE( lssproto.escapework);FREE( lssproto.arraywork );
; 96   : 	    FREE( lssproto.token_list);FREE( lssproto.cryptwork );
; 97   : 	    FREE( lssproto.jencodecopy);FREE( lssproto.jencodeout );
; 98   : 	    FREE( lssproto.compresswork );
; 99   : 	    return -1;
; 100  : 	}
; 101  : */
; 102  : // Terry end
; 103  : 	return 0;

  003ea	33 c0		 xor	 eax, eax

; 104  : }

  003ec	5f		 pop	 edi
  003ed	5e		 pop	 esi
  003ee	5b		 pop	 ebx
  003ef	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  003f5	3b ec		 cmp	 ebp, esp
  003f7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003fc	8b e5		 mov	 esp, ebp
  003fe	5d		 pop	 ebp
  003ff	c3		 ret	 0
?lssproto_AllocateCommonWork@@YAHH@Z ENDP		; lssproto_AllocateCommonWork
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_Send@@YAXHPAD@Z
_TEXT	SEGMENT
_l$1 = -20						; size = 4
_encoded$ = -8						; size = 4
_fd$ = 8						; size = 4
_msg$ = 12						; size = 4
?lssproto_Send@@YAXHPAD@Z PROC				; lssproto_Send, COMDAT

; 546  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 547  : 	char *encoded;
; 548  : #ifdef lssproto__ENCRYPT
; 549  : 	if( !bNewServer){

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bNewServer@@3HA, 0 ; bNewServer
  00025	75 2a		 jne	 SHORT $LN2@lssproto_S

; 550  : 		encoded = lssproto.cryptwork;

  00027	a1 1c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+28
  0002c	89 45 f8	 mov	 DWORD PTR _encoded$[ebp], eax

; 551  : 
; 552  : 		//JL fix 
; 553  : 		if (encoded == NULL) return;

  0002f	83 7d f8 00	 cmp	 DWORD PTR _encoded$[ebp], 0
  00033	75 02		 jne	 SHORT $LN4@lssproto_S
  00035	eb 75		 jmp	 SHORT $LN1@lssproto_S
$LN4@lssproto_S:

; 554  : 
; 555  : 		lssproto_encodeString( msg , encoded , lssproto.workbufsize*3 );

  00037	6b 05 04 00 00
	00 03		 imul	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4, 3
  0003e	50		 push	 eax
  0003f	8b 4d f8	 mov	 ecx, DWORD PTR _encoded$[ebp]
  00042	51		 push	 ecx
  00043	8b 55 0c	 mov	 edx, DWORD PTR _msg$[ebp]
  00046	52		 push	 edx
  00047	e8 00 00 00 00	 call	 ?lssproto_encodeString@@YAXPAD0H@Z ; lssproto_encodeString
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 556  : 	}else

  0004f	eb 06		 jmp	 SHORT $LN3@lssproto_S
$LN2@lssproto_S:

; 557  : 		encoded = msg;

  00051	8b 45 0c	 mov	 eax, DWORD PTR _msg$[ebp]
  00054	89 45 f8	 mov	 DWORD PTR _encoded$[ebp], eax
$LN3@lssproto_S:

; 558  : #else
; 559  :     encoded = msg;
; 560  : #endif
; 561  : 	{
; 562  : 		/* add a newline character*/
; 563  : 		unsigned int l = strlen( encoded );

  00057	8b 45 f8	 mov	 eax, DWORD PTR _encoded$[ebp]
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 _strlen
  00060	83 c4 04	 add	 esp, 4
  00063	89 45 ec	 mov	 DWORD PTR _l$1[ebp], eax

; 564  : 		if( l < lssproto.workbufsize *3){

  00066	6b 05 04 00 00
	00 03		 imul	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4, 3
  0006d	39 45 ec	 cmp	 DWORD PTR _l$1[ebp], eax
  00070	73 1c		 jae	 SHORT $LN5@lssproto_S

; 565  : //#ifndef __NEW_PROTOCOL
; 566  : 			encoded[l] = '\n';

  00072	8b 45 f8	 mov	 eax, DWORD PTR _encoded$[ebp]
  00075	03 45 ec	 add	 eax, DWORD PTR _l$1[ebp]
  00078	c6 00 0a	 mov	 BYTE PTR [eax], 10	; 0000000aH

; 567  : 			encoded[l+1] = 0;

  0007b	8b 45 f8	 mov	 eax, DWORD PTR _encoded$[ebp]
  0007e	03 45 ec	 add	 eax, DWORD PTR _l$1[ebp]
  00081	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 568  : 			l++;

  00085	8b 45 ec	 mov	 eax, DWORD PTR _l$1[ebp]
  00088	83 c0 01	 add	 eax, 1
  0008b	89 45 ec	 mov	 DWORD PTR _l$1[ebp], eax
$LN5@lssproto_S:

; 569  : //#else
; 570  : //			encoded[l] = 0;
; 571  : //#endif
; 572  : 		}
; 573  : 		lssproto.write_func( fd , encoded , l);

  0008e	8b f4		 mov	 esi, esp
  00090	8b 45 ec	 mov	 eax, DWORD PTR _l$1[ebp]
  00093	50		 push	 eax
  00094	8b 4d f8	 mov	 ecx, DWORD PTR _encoded$[ebp]
  00097	51		 push	 ecx
  00098	8b 55 08	 mov	 edx, DWORD PTR _fd$[ebp]
  0009b	52		 push	 edx
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR ?lssproto@@3Ulssproto_@@A
  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a5	3b f4		 cmp	 esi, esp
  000a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@lssproto_S:

; 574  : 	}
; 575  : }

  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi
  000ae	5b		 pop	 ebx
  000af	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000b5	3b ec		 cmp	 ebp, esp
  000b7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c3		 ret	 0
?lssproto_Send@@YAXHPAD@Z ENDP				; lssproto_Send
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_copyLine@@YAXPAD0H@Z
_TEXT	SEGMENT
_i$ = -8						; size = 4
_src$ = 8						; size = 4
_out$ = 12						; size = 4
_outlen$ = 16						; size = 4
?lssproto_copyLine@@YAXPAD0H@Z PROC			; lssproto_copyLine, COMDAT

; 521  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 522  : 	int i;
; 523  : 	for(i=0;;i++){

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00025	eb 09		 jmp	 SHORT $LN4@lssproto_c
$LN2@lssproto_c:
  00027	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0002a	83 c0 01	 add	 eax, 1
  0002d	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@lssproto_c:

; 524  : 		out[i] = src[i];

  00030	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  00033	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00036	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  00039	03 4d f8	 add	 ecx, DWORD PTR _i$[ebp]
  0003c	8a 11		 mov	 dl, BYTE PTR [ecx]
  0003e	88 10		 mov	 BYTE PTR [eax], dl

; 525  : 		if( src[i] == '\n' ){

  00040	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00043	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00046	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00049	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0004c	75 0c		 jne	 SHORT $LN5@lssproto_c

; 526  : 			out[i+1] = '\0' ;

  0004e	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  00051	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00054	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 527  : 			return;

  00058	eb 26		 jmp	 SHORT $LN1@lssproto_c
$LN5@lssproto_c:

; 528  : 		}
; 529  : 		if( src[i] == '\0' )return;

  0005a	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0005d	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00060	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00063	85 c9		 test	 ecx, ecx
  00065	75 02		 jne	 SHORT $LN6@lssproto_c
  00067	eb 17		 jmp	 SHORT $LN1@lssproto_c
$LN6@lssproto_c:

; 530  : 	}

  00069	eb bc		 jmp	 SHORT $LN2@lssproto_c

; 531  : 	lssproto_strcpysafe( out , "" , outlen );

  0006b	8b 45 10	 mov	 eax, DWORD PTR _outlen$[ebp]
  0006e	50		 push	 eax
  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00074	8b 4d 0c	 mov	 ecx, DWORD PTR _out$[ebp]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe
  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@lssproto_c:

; 532  : }

  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00089	3b ec		 cmp	 ebp, esp
  0008b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
?lssproto_copyLine@@YAXPAD0H@Z ENDP			; lssproto_copyLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_consumeLine@@YAXPADH@Z
_TEXT	SEGMENT
_shift$ = -20						; size = 4
_i$ = -8						; size = 4
_buf$ = 8						; size = 4
_offset$ = 12						; size = 4
?lssproto_consumeLine@@YAXPADH@Z PROC			; lssproto_consumeLine, COMDAT

; 504  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 505  : 	int i;
; 506  : 	int shift=0;

  0001e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _shift$[ebp], 0

; 507  : 	buf+= offset;

  00025	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00028	03 45 0c	 add	 eax, DWORD PTR _offset$[ebp]
  0002b	89 45 08	 mov	 DWORD PTR _buf$[ebp], eax

; 508  : 	for(i=0;;i++){

  0002e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00035	eb 09		 jmp	 SHORT $LN4@lssproto_c
$LN2@lssproto_c:
  00037	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0003a	83 c0 01	 add	 eax, 1
  0003d	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@lssproto_c:

; 509  : 		if( buf[i] == '\n' ){

  00040	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00043	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00046	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00049	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0004c	75 0b		 jne	 SHORT $LN8@lssproto_c

; 510  : 			shift = i + 1;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00051	83 c0 01	 add	 eax, 1
  00054	89 45 ec	 mov	 DWORD PTR _shift$[ebp], eax

; 511  : 			break;

  00057	eb 02		 jmp	 SHORT $LN3@lssproto_c
$LN8@lssproto_c:

; 512  : 		}
; 513  : 	}

  00059	eb dc		 jmp	 SHORT $LN2@lssproto_c
$LN3@lssproto_c:

; 514  :     if( shift == 0 )return;

  0005b	83 7d ec 00	 cmp	 DWORD PTR _shift$[ebp], 0
  0005f	75 02		 jne	 SHORT $LN9@lssproto_c
  00061	eb 36		 jmp	 SHORT $LN1@lssproto_c
$LN9@lssproto_c:

; 515  : 	for(i=shift;;i++){

  00063	8b 45 ec	 mov	 eax, DWORD PTR _shift$[ebp]
  00066	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00069	eb 09		 jmp	 SHORT $LN7@lssproto_c
$LN5@lssproto_c:
  0006b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0006e	83 c0 01	 add	 eax, 1
  00071	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@lssproto_c:

; 516  : 		buf[i - shift] = buf[i];

  00074	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00077	2b 45 ec	 sub	 eax, DWORD PTR _shift$[ebp]
  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  0007d	03 4d f8	 add	 ecx, DWORD PTR _i$[ebp]
  00080	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00083	8a 09		 mov	 cl, BYTE PTR [ecx]
  00085	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 517  : 		if( buf[i] == '\0')break;

  00088	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0008b	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  0008e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00091	85 c9		 test	 ecx, ecx
  00093	75 02		 jne	 SHORT $LN10@lssproto_c
  00095	eb 02		 jmp	 SHORT $LN1@lssproto_c
$LN10@lssproto_c:

; 518  : 	}

  00097	eb d2		 jmp	 SHORT $LN5@lssproto_c
$LN1@lssproto_c:

; 519  : }

  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
?lssproto_consumeLine@@YAXPADH@Z ENDP			; lssproto_consumeLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_GetMessageInfo@@YAXPAHPADHPAPAD@Z
_TEXT	SEGMENT
_id$ = 8						; size = 4
_funcname$ = 12						; size = 4
_len$ = 16						; size = 4
_tk$ = 20						; size = 4
?lssproto_GetMessageInfo@@YAXPAHPADHPAPAD@Z PROC	; lssproto_GetMessageInfo, COMDAT

; 109  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 110  : 	if( tk[0] == NULL || tk[1] == NULL ){

  0001e	b8 04 00 00 00	 mov	 eax, 4
  00023	6b c8 00	 imul	 ecx, eax, 0
  00026	8b 55 14	 mov	 edx, DWORD PTR _tk$[ebp]
  00029	83 3c 0a 00	 cmp	 DWORD PTR [edx+ecx], 0
  0002d	74 11		 je	 SHORT $LN3@lssproto_G
  0002f	b8 04 00 00 00	 mov	 eax, 4
  00034	c1 e0 00	 shl	 eax, 0
  00037	8b 4d 14	 mov	 ecx, DWORD PTR _tk$[ebp]
  0003a	83 3c 01 00	 cmp	 DWORD PTR [ecx+eax], 0
  0003e	75 20		 jne	 SHORT $LN2@lssproto_G
$LN3@lssproto_G:

; 111  : 		*id = 0;

  00040	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  00043	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 112  : 		lssproto_strcpysafe( funcname , "" , len );

  00049	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  0004c	50		 push	 eax
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00052	8b 4d 0c	 mov	 ecx, DWORD PTR _funcname$[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 113  : 		return;

  0005e	eb 49		 jmp	 SHORT $LN1@lssproto_G
$LN2@lssproto_G:

; 114  : 	}
; 115  : 	*id =  strtoul( tk[0] ,NULL,10);

  00060	8b f4		 mov	 esi, esp
  00062	6a 0a		 push	 10			; 0000000aH
  00064	6a 00		 push	 0
  00066	b8 04 00 00 00	 mov	 eax, 4
  0006b	6b c8 00	 imul	 ecx, eax, 0
  0006e	8b 55 14	 mov	 edx, DWORD PTR _tk$[ebp]
  00071	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00074	50		 push	 eax
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtoul
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007e	3b f4		 cmp	 esi, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  00088	89 01		 mov	 DWORD PTR [ecx], eax

; 116  : 	lssproto_strcpysafe( funcname , tk[1] , len );

  0008a	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  0008d	50		 push	 eax
  0008e	b9 04 00 00 00	 mov	 ecx, 4
  00093	c1 e1 00	 shl	 ecx, 0
  00096	8b 55 14	 mov	 edx, DWORD PTR _tk$[ebp]
  00099	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0009c	50		 push	 eax
  0009d	8b 4d 0c	 mov	 ecx, DWORD PTR _funcname$[ebp]
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe
  000a6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@lssproto_G:

; 117  : 	return;
; 118  : }

  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000b2	3b ec		 cmp	 ebp, esp
  000b4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
?lssproto_GetMessageInfo@@YAXPAHPADHPAPAD@Z ENDP	; lssproto_GetMessageInfo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_wrapStringAddr@@YAPADPADH0@Z
_TEXT	SEGMENT
_copy$ = 8						; size = 4
_maxcopylen$ = 12					; size = 4
_src$ = 16						; size = 4
?lssproto_wrapStringAddr@@YAPADPADH0@Z PROC		; lssproto_wrapStringAddr, COMDAT

; 604  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 605  : 	lssproto_strcpysafe( copy , src , maxcopylen );

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _maxcopylen$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 10	 mov	 ecx, DWORD PTR _src$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 08	 mov	 edx, DWORD PTR _copy$[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 606  : 	return copy;

  00032	8b 45 08	 mov	 eax, DWORD PTR _copy$[ebp]

; 607  : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?lssproto_wrapStringAddr@@YAPADPADH0@Z ENDP		; lssproto_wrapStringAddr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_u_double_array@@YAPANPAPADPANHH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_tk$ = 8						; size = 4
_buf$ = 12						; size = 4
_start$ = 16						; size = 4
_size$ = 20						; size = 4
?lssproto_demkstr_u_double_array@@YAPANPAPADPANHH@Z PROC ; lssproto_demkstr_u_double_array, COMDAT

; 374  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 375  : 	DEMKSTR_ARRAYMACRO( lssproto_demkstr_double , (double)0.0);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _start$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
  00024	eb 09		 jmp	 SHORT $LN4@lssproto_d
$LN2@lssproto_d:
  00026	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@lssproto_d:
  0002f	8b 45 10	 mov	 eax, DWORD PTR _start$[ebp]
  00032	03 45 14	 add	 eax, DWORD PTR _size$[ebp]
  00035	39 45 f8	 cmp	 DWORD PTR _i$1[ebp], eax
  00038	7d 3f		 jge	 SHORT $LN3@lssproto_d
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _tk$[ebp]
  00040	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  00044	75 13		 jne	 SHORT $LN5@lssproto_d
  00046	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00049	2b 45 10	 sub	 eax, DWORD PTR _start$[ebp]
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  0004f	0f 57 c0	 xorps	 xmm0, xmm0
  00052	f2 0f 11 04 c1	 movsd	 QWORD PTR [ecx+eax*8], xmm0
  00057	eb 1e		 jmp	 SHORT $LN6@lssproto_d
$LN5@lssproto_d:
  00059	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _tk$[ebp]
  0005f	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00062	52		 push	 edx
  00063	e8 00 00 00 00	 call	 ?lssproto_demkstr_double@@YANPAD@Z ; lssproto_demkstr_double
  00068	83 c4 04	 add	 esp, 4
  0006b	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0006e	2b 45 10	 sub	 eax, DWORD PTR _start$[ebp]
  00071	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  00074	dd 1c c1	 fstp	 QWORD PTR [ecx+eax*8]
$LN6@lssproto_d:
  00077	eb ad		 jmp	 SHORT $LN2@lssproto_d
$LN3@lssproto_d:
  00079	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]

; 376  : }

  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00085	3b ec		 cmp	 ebp, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
?lssproto_demkstr_u_double_array@@YAPANPAPADPANHH@Z ENDP ; lssproto_demkstr_u_double_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_float_array@@YAPAMPAPADPAMHH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_tk$ = 8						; size = 4
_buf$ = 12						; size = 4
_start$ = 16						; size = 4
_size$ = 20						; size = 4
?lssproto_demkstr_float_array@@YAPAMPAPADPAMHH@Z PROC	; lssproto_demkstr_float_array, COMDAT

; 370  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 371  : 	DEMKSTR_ARRAYMACRO( lssproto_demkstr_float , (float)0.0);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _start$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
  00024	eb 09		 jmp	 SHORT $LN4@lssproto_d
$LN2@lssproto_d:
  00026	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@lssproto_d:
  0002f	8b 45 10	 mov	 eax, DWORD PTR _start$[ebp]
  00032	03 45 14	 add	 eax, DWORD PTR _size$[ebp]
  00035	39 45 f8	 cmp	 DWORD PTR _i$1[ebp], eax
  00038	7d 3f		 jge	 SHORT $LN3@lssproto_d
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _tk$[ebp]
  00040	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  00044	75 13		 jne	 SHORT $LN5@lssproto_d
  00046	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00049	2b 45 10	 sub	 eax, DWORD PTR _start$[ebp]
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  0004f	0f 57 c0	 xorps	 xmm0, xmm0
  00052	f3 0f 11 04 81	 movss	 DWORD PTR [ecx+eax*4], xmm0
  00057	eb 1e		 jmp	 SHORT $LN6@lssproto_d
$LN5@lssproto_d:
  00059	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _tk$[ebp]
  0005f	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00062	52		 push	 edx
  00063	e8 00 00 00 00	 call	 ?lssproto_demkstr_float@@YAMPAD@Z ; lssproto_demkstr_float
  00068	83 c4 04	 add	 esp, 4
  0006b	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0006e	2b 45 10	 sub	 eax, DWORD PTR _start$[ebp]
  00071	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  00074	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]
$LN6@lssproto_d:
  00077	eb ad		 jmp	 SHORT $LN2@lssproto_d
$LN3@lssproto_d:
  00079	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]

; 372  : }

  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00085	3b ec		 cmp	 ebp, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
?lssproto_demkstr_float_array@@YAPAMPAPADPAMHH@Z ENDP	; lssproto_demkstr_float_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_u_char_array@@YAPAEPAPADPAEHH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_tk$ = 8						; size = 4
_buf$ = 12						; size = 4
_start$ = 16						; size = 4
_size$ = 20						; size = 4
?lssproto_demkstr_u_char_array@@YAPAEPAPADPAEHH@Z PROC	; lssproto_demkstr_u_char_array, COMDAT

; 366  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 367  : 	DEMKSTR_ARRAYMACRO( lssproto_demkstr_u_char , 0);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _start$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
  00024	eb 09		 jmp	 SHORT $LN4@lssproto_d
$LN2@lssproto_d:
  00026	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@lssproto_d:
  0002f	8b 45 10	 mov	 eax, DWORD PTR _start$[ebp]
  00032	03 45 14	 add	 eax, DWORD PTR _size$[ebp]
  00035	39 45 f8	 cmp	 DWORD PTR _i$1[ebp], eax
  00038	7d 3b		 jge	 SHORT $LN3@lssproto_d
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _tk$[ebp]
  00040	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  00044	75 0f		 jne	 SHORT $LN5@lssproto_d
  00046	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00049	2b 45 10	 sub	 eax, DWORD PTR _start$[ebp]
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  0004f	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0
  00053	eb 1e		 jmp	 SHORT $LN6@lssproto_d
$LN5@lssproto_d:
  00055	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00058	8b 4d 08	 mov	 ecx, DWORD PTR _tk$[ebp]
  0005b	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0005e	52		 push	 edx
  0005f	e8 00 00 00 00	 call	 ?lssproto_demkstr_u_char@@YAEPAD@Z ; lssproto_demkstr_u_char
  00064	83 c4 04	 add	 esp, 4
  00067	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  0006a	2b 4d 10	 sub	 ecx, DWORD PTR _start$[ebp]
  0006d	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00070	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
$LN6@lssproto_d:
  00073	eb b1		 jmp	 SHORT $LN2@lssproto_d
$LN3@lssproto_d:
  00075	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]

; 368  : }

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00081	3b ec		 cmp	 ebp, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?lssproto_demkstr_u_char_array@@YAPAEPAPADPAEHH@Z ENDP	; lssproto_demkstr_u_char_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_char_array@@YAPADPAPADPADHH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_tk$ = 8						; size = 4
_buf$ = 12						; size = 4
_start$ = 16						; size = 4
_size$ = 20						; size = 4
?lssproto_demkstr_char_array@@YAPADPAPADPADHH@Z PROC	; lssproto_demkstr_char_array, COMDAT

; 361  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 362  : 	DEMKSTR_ARRAYMACRO( lssproto_demkstr_u_char , 0);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _start$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
  00024	eb 09		 jmp	 SHORT $LN4@lssproto_d
$LN2@lssproto_d:
  00026	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@lssproto_d:
  0002f	8b 45 10	 mov	 eax, DWORD PTR _start$[ebp]
  00032	03 45 14	 add	 eax, DWORD PTR _size$[ebp]
  00035	39 45 f8	 cmp	 DWORD PTR _i$1[ebp], eax
  00038	7d 3b		 jge	 SHORT $LN3@lssproto_d
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _tk$[ebp]
  00040	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  00044	75 0f		 jne	 SHORT $LN5@lssproto_d
  00046	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00049	2b 45 10	 sub	 eax, DWORD PTR _start$[ebp]
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  0004f	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0
  00053	eb 1e		 jmp	 SHORT $LN6@lssproto_d
$LN5@lssproto_d:
  00055	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00058	8b 4d 08	 mov	 ecx, DWORD PTR _tk$[ebp]
  0005b	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0005e	52		 push	 edx
  0005f	e8 00 00 00 00	 call	 ?lssproto_demkstr_u_char@@YAEPAD@Z ; lssproto_demkstr_u_char
  00064	83 c4 04	 add	 esp, 4
  00067	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  0006a	2b 4d 10	 sub	 ecx, DWORD PTR _start$[ebp]
  0006d	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00070	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
$LN6@lssproto_d:
  00073	eb b1		 jmp	 SHORT $LN2@lssproto_d
$LN3@lssproto_d:
  00075	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]

; 363  : }

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00081	3b ec		 cmp	 ebp, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?lssproto_demkstr_char_array@@YAPADPAPADPADHH@Z ENDP	; lssproto_demkstr_char_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_u_short_array@@YAPAGPAPADPAGHH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_tk$ = 8						; size = 4
_buf$ = 12						; size = 4
_start$ = 16						; size = 4
_size$ = 20						; size = 4
?lssproto_demkstr_u_short_array@@YAPAGPAPADPAGHH@Z PROC	; lssproto_demkstr_u_short_array, COMDAT

; 357  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 358  : 	DEMKSTR_ARRAYMACRO( lssproto_demkstr_u_short , 0);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _start$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
  00024	eb 09		 jmp	 SHORT $LN4@lssproto_d
$LN2@lssproto_d:
  00026	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@lssproto_d:
  0002f	8b 45 10	 mov	 eax, DWORD PTR _start$[ebp]
  00032	03 45 14	 add	 eax, DWORD PTR _size$[ebp]
  00035	39 45 f8	 cmp	 DWORD PTR _i$1[ebp], eax
  00038	7d 3e		 jge	 SHORT $LN3@lssproto_d
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _tk$[ebp]
  00040	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  00044	75 11		 jne	 SHORT $LN5@lssproto_d
  00046	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00049	2b 45 10	 sub	 eax, DWORD PTR _start$[ebp]
  0004c	33 c9		 xor	 ecx, ecx
  0004e	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00051	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  00055	eb 1f		 jmp	 SHORT $LN6@lssproto_d
$LN5@lssproto_d:
  00057	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _tk$[ebp]
  0005d	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ?lssproto_demkstr_u_short@@YAGPAD@Z ; lssproto_demkstr_u_short
  00066	83 c4 04	 add	 esp, 4
  00069	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  0006c	2b 4d 10	 sub	 ecx, DWORD PTR _start$[ebp]
  0006f	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00072	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
$LN6@lssproto_d:
  00076	eb ae		 jmp	 SHORT $LN2@lssproto_d
$LN3@lssproto_d:
  00078	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]

; 359  : }

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00084	3b ec		 cmp	 ebp, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
?lssproto_demkstr_u_short_array@@YAPAGPAPADPAGHH@Z ENDP	; lssproto_demkstr_u_short_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_short_array@@YAPAFPAPADPAFHH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_tk$ = 8						; size = 4
_buf$ = 12						; size = 4
_start$ = 16						; size = 4
_size$ = 20						; size = 4
?lssproto_demkstr_short_array@@YAPAFPAPADPAFHH@Z PROC	; lssproto_demkstr_short_array, COMDAT

; 352  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 353  : 	DEMKSTR_ARRAYMACRO( lssproto_demkstr_short , 0);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _start$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
  00024	eb 09		 jmp	 SHORT $LN4@lssproto_d
$LN2@lssproto_d:
  00026	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@lssproto_d:
  0002f	8b 45 10	 mov	 eax, DWORD PTR _start$[ebp]
  00032	03 45 14	 add	 eax, DWORD PTR _size$[ebp]
  00035	39 45 f8	 cmp	 DWORD PTR _i$1[ebp], eax
  00038	7d 3e		 jge	 SHORT $LN3@lssproto_d
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _tk$[ebp]
  00040	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  00044	75 11		 jne	 SHORT $LN5@lssproto_d
  00046	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00049	2b 45 10	 sub	 eax, DWORD PTR _start$[ebp]
  0004c	33 c9		 xor	 ecx, ecx
  0004e	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00051	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  00055	eb 1f		 jmp	 SHORT $LN6@lssproto_d
$LN5@lssproto_d:
  00057	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _tk$[ebp]
  0005d	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ?lssproto_demkstr_short@@YAFPAD@Z ; lssproto_demkstr_short
  00066	83 c4 04	 add	 esp, 4
  00069	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  0006c	2b 4d 10	 sub	 ecx, DWORD PTR _start$[ebp]
  0006f	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00072	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
$LN6@lssproto_d:
  00076	eb ae		 jmp	 SHORT $LN2@lssproto_d
$LN3@lssproto_d:
  00078	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]

; 354  : }

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00084	3b ec		 cmp	 ebp, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
?lssproto_demkstr_short_array@@YAPAFPAPADPAFHH@Z ENDP	; lssproto_demkstr_short_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_u_long_array@@YAPAKPAPADPAKHH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_tk$ = 8						; size = 4
_buf$ = 12						; size = 4
_start$ = 16						; size = 4
_size$ = 20						; size = 4
?lssproto_demkstr_u_long_array@@YAPAKPAPADPAKHH@Z PROC	; lssproto_demkstr_u_long_array, COMDAT

; 348  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 349  : 	DEMKSTR_ARRAYMACRO( lssproto_demkstr_u_long , 0);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _start$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
  00024	eb 09		 jmp	 SHORT $LN4@lssproto_d
$LN2@lssproto_d:
  00026	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@lssproto_d:
  0002f	8b 45 10	 mov	 eax, DWORD PTR _start$[ebp]
  00032	03 45 14	 add	 eax, DWORD PTR _size$[ebp]
  00035	39 45 f8	 cmp	 DWORD PTR _i$1[ebp], eax
  00038	7d 3e		 jge	 SHORT $LN3@lssproto_d
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _tk$[ebp]
  00040	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  00044	75 12		 jne	 SHORT $LN5@lssproto_d
  00046	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00049	2b 45 10	 sub	 eax, DWORD PTR _start$[ebp]
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  0004f	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [ecx+eax*4], 0
  00056	eb 1e		 jmp	 SHORT $LN6@lssproto_d
$LN5@lssproto_d:
  00058	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _tk$[ebp]
  0005e	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 ?lssproto_demkstr_u_long@@YAKPAD@Z ; lssproto_demkstr_u_long
  00067	83 c4 04	 add	 esp, 4
  0006a	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  0006d	2b 4d 10	 sub	 ecx, DWORD PTR _start$[ebp]
  00070	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00073	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
$LN6@lssproto_d:
  00076	eb ae		 jmp	 SHORT $LN2@lssproto_d
$LN3@lssproto_d:
  00078	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]

; 350  : }

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00084	3b ec		 cmp	 ebp, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
?lssproto_demkstr_u_long_array@@YAPAKPAPADPAKHH@Z ENDP	; lssproto_demkstr_u_long_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_long_array@@YAPAIPAPADPAIHH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_tk$ = 8						; size = 4
_buf$ = 12						; size = 4
_start$ = 16						; size = 4
_size$ = 20						; size = 4
?lssproto_demkstr_long_array@@YAPAIPAPADPAIHH@Z PROC	; lssproto_demkstr_long_array, COMDAT

; 343  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 344  : 	DEMKSTR_ARRAYMACRO( lssproto_demkstr_long  , 0);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _start$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
  00024	eb 09		 jmp	 SHORT $LN4@lssproto_d
$LN2@lssproto_d:
  00026	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@lssproto_d:
  0002f	8b 45 10	 mov	 eax, DWORD PTR _start$[ebp]
  00032	03 45 14	 add	 eax, DWORD PTR _size$[ebp]
  00035	39 45 f8	 cmp	 DWORD PTR _i$1[ebp], eax
  00038	7d 3e		 jge	 SHORT $LN3@lssproto_d
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _tk$[ebp]
  00040	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  00044	75 12		 jne	 SHORT $LN5@lssproto_d
  00046	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00049	2b 45 10	 sub	 eax, DWORD PTR _start$[ebp]
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  0004f	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [ecx+eax*4], 0
  00056	eb 1e		 jmp	 SHORT $LN6@lssproto_d
$LN5@lssproto_d:
  00058	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _tk$[ebp]
  0005e	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 ?lssproto_demkstr_long@@YAJPAD@Z ; lssproto_demkstr_long
  00067	83 c4 04	 add	 esp, 4
  0006a	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  0006d	2b 4d 10	 sub	 ecx, DWORD PTR _start$[ebp]
  00070	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00073	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
$LN6@lssproto_d:
  00076	eb ae		 jmp	 SHORT $LN2@lssproto_d
$LN3@lssproto_d:
  00078	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]

; 345  : }

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00084	3b ec		 cmp	 ebp, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
?lssproto_demkstr_long_array@@YAPAIPAPADPAIHH@Z ENDP	; lssproto_demkstr_long_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_u_int_array@@YAPAHPAPADPAHHH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_tk$ = 8						; size = 4
_buf$ = 12						; size = 4
_start$ = 16						; size = 4
_size$ = 20						; size = 4
?lssproto_demkstr_u_int_array@@YAPAHPAPADPAHHH@Z PROC	; lssproto_demkstr_u_int_array, COMDAT

; 338  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 339  : 	DEMKSTR_ARRAYMACRO( lssproto_demkstr_u_int , 0 );

  0001e	8b 45 10	 mov	 eax, DWORD PTR _start$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
  00024	eb 09		 jmp	 SHORT $LN4@lssproto_d
$LN2@lssproto_d:
  00026	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@lssproto_d:
  0002f	8b 45 10	 mov	 eax, DWORD PTR _start$[ebp]
  00032	03 45 14	 add	 eax, DWORD PTR _size$[ebp]
  00035	39 45 f8	 cmp	 DWORD PTR _i$1[ebp], eax
  00038	7d 3e		 jge	 SHORT $LN3@lssproto_d
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _tk$[ebp]
  00040	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  00044	75 12		 jne	 SHORT $LN5@lssproto_d
  00046	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00049	2b 45 10	 sub	 eax, DWORD PTR _start$[ebp]
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  0004f	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [ecx+eax*4], 0
  00056	eb 1e		 jmp	 SHORT $LN6@lssproto_d
$LN5@lssproto_d:
  00058	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _tk$[ebp]
  0005e	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 ?lssproto_demkstr_u_int@@YAIPAD@Z ; lssproto_demkstr_u_int
  00067	83 c4 04	 add	 esp, 4
  0006a	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  0006d	2b 4d 10	 sub	 ecx, DWORD PTR _start$[ebp]
  00070	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00073	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
$LN6@lssproto_d:
  00076	eb ae		 jmp	 SHORT $LN2@lssproto_d
$LN3@lssproto_d:
  00078	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]

; 340  : }

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00084	3b ec		 cmp	 ebp, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
?lssproto_demkstr_u_int_array@@YAPAHPAPADPAHHH@Z ENDP	; lssproto_demkstr_u_int_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_int_array@@YAPAHPAPADPAHHH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_tk$ = 8						; size = 4
_buf$ = 12						; size = 4
_start$ = 16						; size = 4
_size$ = 20						; size = 4
?lssproto_demkstr_int_array@@YAPAHPAPADPAHHH@Z PROC	; lssproto_demkstr_int_array, COMDAT

; 322  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 323  : #define DEMKSTR_ARRAYMACRO( func, defaultvalue )          \
; 324  :     {\
; 325  :         int i;\
; 326  :         for(i=start;i<(start+size);i++){\
; 327  :             if( tk[i] == NULL ){   \
; 328  : 		        buf[i-start]=defaultvalue ;\
; 329  :             } else {\
; 330  :      	 	    buf[i-start] = func( tk[i] );\
; 331  :             }\
; 332  : 	    }\
; 333  :         return buf;\
; 334  :     }
; 335  :     DEMKSTR_ARRAYMACRO( lssproto_demkstr_int , 0 );

  0001e	8b 45 10	 mov	 eax, DWORD PTR _start$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
  00024	eb 09		 jmp	 SHORT $LN4@lssproto_d
$LN2@lssproto_d:
  00026	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@lssproto_d:
  0002f	8b 45 10	 mov	 eax, DWORD PTR _start$[ebp]
  00032	03 45 14	 add	 eax, DWORD PTR _size$[ebp]
  00035	39 45 f8	 cmp	 DWORD PTR _i$1[ebp], eax
  00038	7d 3e		 jge	 SHORT $LN3@lssproto_d
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _tk$[ebp]
  00040	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  00044	75 12		 jne	 SHORT $LN5@lssproto_d
  00046	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00049	2b 45 10	 sub	 eax, DWORD PTR _start$[ebp]
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  0004f	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [ecx+eax*4], 0
  00056	eb 1e		 jmp	 SHORT $LN6@lssproto_d
$LN5@lssproto_d:
  00058	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _tk$[ebp]
  0005e	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 ?lssproto_demkstr_int@@YAHPAD@Z ; lssproto_demkstr_int
  00067	83 c4 04	 add	 esp, 4
  0006a	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  0006d	2b 4d 10	 sub	 ecx, DWORD PTR _start$[ebp]
  00070	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00073	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
$LN6@lssproto_d:
  00076	eb ae		 jmp	 SHORT $LN2@lssproto_d
$LN3@lssproto_d:
  00078	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]

; 336  : }

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00084	3b ec		 cmp	 ebp, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
?lssproto_demkstr_int_array@@YAPAHPAPADPAHHH@Z ENDP	; lssproto_demkstr_int_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_string@@YAPADPAD@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?lssproto_demkstr_string@@YAPADPAD@Z PROC		; lssproto_demkstr_string, COMDAT

; 314  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 315  : 	if( a == (char*)NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _a$[ebp], 0
  00022	75 21		 jne	 SHORT $LN2@lssproto_d

; 316  : 		lssproto_strcpysafe( lssproto.escapework , "" , lssproto.workbufsize );

  00024	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00029	50		 push	 eax
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0002f	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 317  : 		return lssproto.escapework;

  0003e	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  00043	eb 0c		 jmp	 SHORT $LN1@lssproto_d
$LN2@lssproto_d:

; 318  : 	}
; 319  : 	return lssproto_descapeString( a );

  00045	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 ?lssproto_descapeString@@YAPADPAD@Z ; lssproto_descapeString
  0004e	83 c4 04	 add	 esp, 4
$LN1@lssproto_d:

; 320  : }

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?lssproto_demkstr_string@@YAPADPAD@Z ENDP		; lssproto_demkstr_string
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_double@@YANPAD@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?lssproto_demkstr_double@@YANPAD@Z PROC			; lssproto_demkstr_double, COMDAT

; 309  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 310  : 	if( a == (char*)NULL)return 0.0F;

  0001e	83 7d 08 00	 cmp	 DWORD PTR _a$[ebp], 0
  00022	75 04		 jne	 SHORT $LN2@lssproto_d
  00024	d9 ee		 fldz
  00026	eb 18		 jmp	 SHORT $LN1@lssproto_d
$LN2@lssproto_d:

; 311  : 	return (double) strtod( a , NULL );

  00028	8b f4		 mov	 esi, esp
  0002a	6a 00		 push	 0
  0002c	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0002f	50		 push	 eax
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtod
  00036	83 c4 08	 add	 esp, 8
  00039	3b f4		 cmp	 esi, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@lssproto_d:

; 312  : }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?lssproto_demkstr_double@@YANPAD@Z ENDP			; lssproto_demkstr_double
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_float@@YAMPAD@Z
_TEXT	SEGMENT
tv74 = -196						; size = 4
_a$ = 8							; size = 4
?lssproto_demkstr_float@@YAMPAD@Z PROC			; lssproto_demkstr_float, COMDAT

; 304  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 305  : 	if( a == (char*)NULL)return 0.0F;

  0001e	83 7d 08 00	 cmp	 DWORD PTR _a$[ebp], 0
  00022	75 04		 jne	 SHORT $LN2@lssproto_d
  00024	d9 ee		 fldz
  00026	eb 22		 jmp	 SHORT $LN1@lssproto_d
$LN2@lssproto_d:

; 306  : 	return (float) atof( a);

  00028	8b f4		 mov	 esi, esp
  0002a	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0002d	50		 push	 eax
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  00034	83 c4 04	 add	 esp, 4
  00037	3b f4		 cmp	 esi, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv74[ebp]
  00044	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv74[ebp]
$LN1@lssproto_d:

; 307  : }

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
?lssproto_demkstr_float@@YAMPAD@Z ENDP			; lssproto_demkstr_float
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_u_char@@YAEPAD@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?lssproto_demkstr_u_char@@YAEPAD@Z PROC			; lssproto_demkstr_u_char, COMDAT

; 299  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 300  : 	if( a == (char*)NULL)return 0;

  0001e	83 7d 08 00	 cmp	 DWORD PTR _a$[ebp], 0
  00022	75 04		 jne	 SHORT $LN2@lssproto_d
  00024	32 c0		 xor	 al, al
  00026	eb 1a		 jmp	 SHORT $LN1@lssproto_d
$LN2@lssproto_d:

; 301  : 	return (unsigned char ) strtoul( a,NULL , 10 );

  00028	8b f4		 mov	 esi, esp
  0002a	6a 0a		 push	 10			; 0000000aH
  0002c	6a 00		 push	 0
  0002e	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00031	50		 push	 eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtoul
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	3b f4		 cmp	 esi, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@lssproto_d:

; 302  : }

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?lssproto_demkstr_u_char@@YAEPAD@Z ENDP			; lssproto_demkstr_u_char
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_char@@YADPAD@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?lssproto_demkstr_char@@YADPAD@Z PROC			; lssproto_demkstr_char, COMDAT

; 294  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 295  : 	if( a == (char*)NULL)return 0;

  0001e	83 7d 08 00	 cmp	 DWORD PTR _a$[ebp], 0
  00022	75 04		 jne	 SHORT $LN2@lssproto_d
  00024	32 c0		 xor	 al, al
  00026	eb 1a		 jmp	 SHORT $LN1@lssproto_d
$LN2@lssproto_d:

; 296  : 	return (char) strtol(  a  , NULL , 10 );

  00028	8b f4		 mov	 esi, esp
  0002a	6a 0a		 push	 10			; 0000000aH
  0002c	6a 00		 push	 0
  0002e	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00031	50		 push	 eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtol
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	3b f4		 cmp	 esi, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@lssproto_d:

; 297  : }

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?lssproto_demkstr_char@@YADPAD@Z ENDP			; lssproto_demkstr_char
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_u_short@@YAGPAD@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?lssproto_demkstr_u_short@@YAGPAD@Z PROC		; lssproto_demkstr_u_short, COMDAT

; 289  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 290  : 	if( a == (char*)NULL)return 0;

  0001e	83 7d 08 00	 cmp	 DWORD PTR _a$[ebp], 0
  00022	75 04		 jne	 SHORT $LN2@lssproto_d
  00024	33 c0		 xor	 eax, eax
  00026	eb 1a		 jmp	 SHORT $LN1@lssproto_d
$LN2@lssproto_d:

; 291  : 	return (unsigned short) strtoul( a , NULL , 10 );

  00028	8b f4		 mov	 esi, esp
  0002a	6a 0a		 push	 10			; 0000000aH
  0002c	6a 00		 push	 0
  0002e	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00031	50		 push	 eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtoul
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	3b f4		 cmp	 esi, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@lssproto_d:

; 292  : }

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?lssproto_demkstr_u_short@@YAGPAD@Z ENDP		; lssproto_demkstr_u_short
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_short@@YAFPAD@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?lssproto_demkstr_short@@YAFPAD@Z PROC			; lssproto_demkstr_short, COMDAT

; 284  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 285  : 	if( a == (char*)NULL)return 0;

  0001e	83 7d 08 00	 cmp	 DWORD PTR _a$[ebp], 0
  00022	75 04		 jne	 SHORT $LN2@lssproto_d
  00024	33 c0		 xor	 eax, eax
  00026	eb 1a		 jmp	 SHORT $LN1@lssproto_d
$LN2@lssproto_d:

; 286  : 	return (short) strtol( a , NULL , 10 );

  00028	8b f4		 mov	 esi, esp
  0002a	6a 0a		 push	 10			; 0000000aH
  0002c	6a 00		 push	 0
  0002e	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00031	50		 push	 eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtol
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	3b f4		 cmp	 esi, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@lssproto_d:

; 287  : }

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?lssproto_demkstr_short@@YAFPAD@Z ENDP			; lssproto_demkstr_short
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_u_long@@YAKPAD@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?lssproto_demkstr_u_long@@YAKPAD@Z PROC			; lssproto_demkstr_u_long, COMDAT

; 279  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 280  : 	if( a == (char*)NULL)return 0;

  0001e	83 7d 08 00	 cmp	 DWORD PTR _a$[ebp], 0
  00022	75 04		 jne	 SHORT $LN2@lssproto_d
  00024	33 c0		 xor	 eax, eax
  00026	eb 1a		 jmp	 SHORT $LN1@lssproto_d
$LN2@lssproto_d:

; 281  : 	return (unsigned long ) strtoul( a , NULL , 10 ) ;

  00028	8b f4		 mov	 esi, esp
  0002a	6a 0a		 push	 10			; 0000000aH
  0002c	6a 00		 push	 0
  0002e	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00031	50		 push	 eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtoul
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	3b f4		 cmp	 esi, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@lssproto_d:

; 282  : }

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?lssproto_demkstr_u_long@@YAKPAD@Z ENDP			; lssproto_demkstr_u_long
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_long@@YAJPAD@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?lssproto_demkstr_long@@YAJPAD@Z PROC			; lssproto_demkstr_long, COMDAT

; 274  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 275  : 	if( a == (char*)NULL)return 0;

  0001e	83 7d 08 00	 cmp	 DWORD PTR _a$[ebp], 0
  00022	75 04		 jne	 SHORT $LN2@lssproto_d
  00024	33 c0		 xor	 eax, eax
  00026	eb 1a		 jmp	 SHORT $LN1@lssproto_d
$LN2@lssproto_d:

; 276  : 	return (long)strtol( a , NULL , 10 );

  00028	8b f4		 mov	 esi, esp
  0002a	6a 0a		 push	 10			; 0000000aH
  0002c	6a 00		 push	 0
  0002e	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00031	50		 push	 eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtol
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	3b f4		 cmp	 esi, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@lssproto_d:

; 277  : }

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?lssproto_demkstr_long@@YAJPAD@Z ENDP			; lssproto_demkstr_long
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_u_int@@YAIPAD@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?lssproto_demkstr_u_int@@YAIPAD@Z PROC			; lssproto_demkstr_u_int, COMDAT

; 269  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 270  : 	if( a == (char*)NULL)return 0;

  0001e	83 7d 08 00	 cmp	 DWORD PTR _a$[ebp], 0
  00022	75 04		 jne	 SHORT $LN2@lssproto_d
  00024	33 c0		 xor	 eax, eax
  00026	eb 1a		 jmp	 SHORT $LN1@lssproto_d
$LN2@lssproto_d:

; 271  : 	return (unsigned int ) strtoul( a ,NULL,10);

  00028	8b f4		 mov	 esi, esp
  0002a	6a 0a		 push	 10			; 0000000aH
  0002c	6a 00		 push	 0
  0002e	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00031	50		 push	 eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtoul
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	3b f4		 cmp	 esi, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@lssproto_d:

; 272  : }

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?lssproto_demkstr_u_int@@YAIPAD@Z ENDP			; lssproto_demkstr_u_int
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_demkstr_int@@YAHPAD@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?lssproto_demkstr_int@@YAHPAD@Z PROC			; lssproto_demkstr_int, COMDAT

; 263  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 264  : 	if( a == (char*)NULL)return 0;

  0001e	83 7d 08 00	 cmp	 DWORD PTR _a$[ebp], 0
  00022	75 04		 jne	 SHORT $LN2@lssproto_d
  00024	33 c0		 xor	 eax, eax
  00026	eb 0c		 jmp	 SHORT $LN1@lssproto_d
$LN2@lssproto_d:

; 265  : /*	return (int)strtol( a ,NULL , 10);*/
; 266  : 	return lssproto_a62toi( a );

  00028	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?lssproto_a62toi@@YAHPAD@Z ; lssproto_a62toi
  00031	83 c4 04	 add	 esp, 4
$LN1@lssproto_d:

; 267  : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?lssproto_demkstr_int@@YAHPAD@Z ENDP			; lssproto_demkstr_int
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_double_array@@YAPADHPAN@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_size$ = 8						; size = 4
_array$ = 12						; size = 4
?lssproto_mkstr_double_array@@YAPADHPAN@Z PROC		; lssproto_mkstr_double_array, COMDAT

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 257  : 	MKSTR_ARRAYMACRO( lssproto_mkstr_double );

  0001e	b8 01 00 00 00	 mov	 eax, 1
  00023	6b c8 00	 imul	 ecx, eax, 0
  00026	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  0002c	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0
  00030	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00037	eb 09		 jmp	 SHORT $LN4@lssproto_m
$LN2@lssproto_m:
  00039	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0003c	83 c0 01	 add	 eax, 1
  0003f	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@lssproto_m:
  00042	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00045	3b 45 08	 cmp	 eax, DWORD PTR _size$[ebp]
  00048	7d 32		 jge	 SHORT $LN3@lssproto_m
  0004a	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  0004f	50		 push	 eax
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  00053	8b 55 0c	 mov	 edx, DWORD PTR _array$[ebp]
  00056	83 ec 08	 sub	 esp, 8
  00059	f2 0f 10 04 ca	 movsd	 xmm0, QWORD PTR [edx+ecx*8]
  0005e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00063	e8 00 00 00 00	 call	 ?lssproto_mkstr_double@@YAPADN@Z ; lssproto_mkstr_double
  00068	83 c4 08	 add	 esp, 8
  0006b	50		 push	 eax
  0006c	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007a	eb bd		 jmp	 SHORT $LN2@lssproto_m
$LN3@lssproto_m:
  0007c	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12

; 258  : }

  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx
  00084	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0008a	3b ec		 cmp	 ebp, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
?lssproto_mkstr_double_array@@YAPADHPAN@Z ENDP		; lssproto_mkstr_double_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_float_array@@YAPADHPAM@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_size$ = 8						; size = 4
_array$ = 12						; size = 4
?lssproto_mkstr_float_array@@YAPADHPAM@Z PROC		; lssproto_mkstr_float_array, COMDAT

; 252  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 253  : 	MKSTR_ARRAYMACRO( lssproto_mkstr_float );

  0001e	b8 01 00 00 00	 mov	 eax, 1
  00023	6b c8 00	 imul	 ecx, eax, 0
  00026	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  0002c	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0
  00030	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00037	eb 09		 jmp	 SHORT $LN4@lssproto_m
$LN2@lssproto_m:
  00039	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0003c	83 c0 01	 add	 eax, 1
  0003f	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@lssproto_m:
  00042	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00045	3b 45 08	 cmp	 eax, DWORD PTR _size$[ebp]
  00048	7d 30		 jge	 SHORT $LN3@lssproto_m
  0004a	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  0004f	50		 push	 eax
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  00053	8b 55 0c	 mov	 edx, DWORD PTR _array$[ebp]
  00056	51		 push	 ecx
  00057	f3 0f 10 04 8a	 movss	 xmm0, DWORD PTR [edx+ecx*4]
  0005c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00061	e8 00 00 00 00	 call	 ?lssproto_mkstr_float@@YAPADM@Z ; lssproto_mkstr_float
  00066	83 c4 04	 add	 esp, 4
  00069	50		 push	 eax
  0006a	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH
  00078	eb bf		 jmp	 SHORT $LN2@lssproto_m
$LN3@lssproto_m:
  0007a	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12

; 254  : }

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00088	3b ec		 cmp	 ebp, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
?lssproto_mkstr_float_array@@YAPADHPAM@Z ENDP		; lssproto_mkstr_float_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_u_char_array@@YAPADHPAE@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_size$ = 8						; size = 4
_array$ = 12						; size = 4
?lssproto_mkstr_u_char_array@@YAPADHPAE@Z PROC		; lssproto_mkstr_u_char_array, COMDAT

; 248  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 249  : 	MKSTR_ARRAYMACRO( lssproto_mkstr_u_char );

  0001e	b8 01 00 00 00	 mov	 eax, 1
  00023	6b c8 00	 imul	 ecx, eax, 0
  00026	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  0002c	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0
  00030	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00037	eb 09		 jmp	 SHORT $LN4@lssproto_m
$LN2@lssproto_m:
  00039	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0003c	83 c0 01	 add	 eax, 1
  0003f	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@lssproto_m:
  00042	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00045	3b 45 08	 cmp	 eax, DWORD PTR _size$[ebp]
  00048	7d 29		 jge	 SHORT $LN3@lssproto_m
  0004a	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  0004f	50		 push	 eax
  00050	8b 4d 0c	 mov	 ecx, DWORD PTR _array$[ebp]
  00053	03 4d f8	 add	 ecx, DWORD PTR _i$1[ebp]
  00056	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00059	52		 push	 edx
  0005a	e8 00 00 00 00	 call	 ?lssproto_mkstr_u_char@@YAPADD@Z ; lssproto_mkstr_u_char
  0005f	83 c4 04	 add	 esp, 4
  00062	50		 push	 eax
  00063	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	eb c6		 jmp	 SHORT $LN2@lssproto_m
$LN3@lssproto_m:
  00073	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12

; 250  : }

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00081	3b ec		 cmp	 ebp, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?lssproto_mkstr_u_char_array@@YAPADHPAE@Z ENDP		; lssproto_mkstr_u_char_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_char_array@@YAPADHPAD@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_size$ = 8						; size = 4
_array$ = 12						; size = 4
?lssproto_mkstr_char_array@@YAPADHPAD@Z PROC		; lssproto_mkstr_char_array, COMDAT

; 244  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 245  : 	MKSTR_ARRAYMACRO( lssproto_mkstr_char );

  0001e	b8 01 00 00 00	 mov	 eax, 1
  00023	6b c8 00	 imul	 ecx, eax, 0
  00026	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  0002c	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0
  00030	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00037	eb 09		 jmp	 SHORT $LN4@lssproto_m
$LN2@lssproto_m:
  00039	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0003c	83 c0 01	 add	 eax, 1
  0003f	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@lssproto_m:
  00042	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00045	3b 45 08	 cmp	 eax, DWORD PTR _size$[ebp]
  00048	7d 29		 jge	 SHORT $LN3@lssproto_m
  0004a	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  0004f	50		 push	 eax
  00050	8b 4d 0c	 mov	 ecx, DWORD PTR _array$[ebp]
  00053	03 4d f8	 add	 ecx, DWORD PTR _i$1[ebp]
  00056	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00059	52		 push	 edx
  0005a	e8 00 00 00 00	 call	 ?lssproto_mkstr_char@@YAPADD@Z ; lssproto_mkstr_char
  0005f	83 c4 04	 add	 esp, 4
  00062	50		 push	 eax
  00063	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	eb c6		 jmp	 SHORT $LN2@lssproto_m
$LN3@lssproto_m:
  00073	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12

; 246  : }

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00081	3b ec		 cmp	 ebp, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?lssproto_mkstr_char_array@@YAPADHPAD@Z ENDP		; lssproto_mkstr_char_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_u_short_array@@YAPADHPAF@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_size$ = 8						; size = 4
_array$ = 12						; size = 4
?lssproto_mkstr_u_short_array@@YAPADHPAF@Z PROC		; lssproto_mkstr_u_short_array, COMDAT

; 240  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 241  : 	MKSTR_ARRAYMACRO( lssproto_mkstr_u_short );

  0001e	b8 01 00 00 00	 mov	 eax, 1
  00023	6b c8 00	 imul	 ecx, eax, 0
  00026	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  0002c	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0
  00030	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00037	eb 09		 jmp	 SHORT $LN4@lssproto_m
$LN2@lssproto_m:
  00039	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0003c	83 c0 01	 add	 eax, 1
  0003f	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@lssproto_m:
  00042	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00045	3b 45 08	 cmp	 eax, DWORD PTR _size$[ebp]
  00048	7d 2b		 jge	 SHORT $LN3@lssproto_m
  0004a	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  0004f	50		 push	 eax
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  00053	8b 55 0c	 mov	 edx, DWORD PTR _array$[ebp]
  00056	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 ?lssproto_mkstr_u_short@@YAPADF@Z ; lssproto_mkstr_u_short
  00060	83 c4 04	 add	 esp, 4
  00063	50		 push	 eax
  00064	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  0006a	51		 push	 ecx
  0006b	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH
  00073	eb c4		 jmp	 SHORT $LN2@lssproto_m
$LN3@lssproto_m:
  00075	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12

; 242  : }

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
?lssproto_mkstr_u_short_array@@YAPADHPAF@Z ENDP		; lssproto_mkstr_u_short_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_short_array@@YAPADHPAF@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_size$ = 8						; size = 4
_array$ = 12						; size = 4
?lssproto_mkstr_short_array@@YAPADHPAF@Z PROC		; lssproto_mkstr_short_array, COMDAT

; 236  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 237  : 	MKSTR_ARRAYMACRO( lssproto_mkstr_short );

  0001e	b8 01 00 00 00	 mov	 eax, 1
  00023	6b c8 00	 imul	 ecx, eax, 0
  00026	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  0002c	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0
  00030	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00037	eb 09		 jmp	 SHORT $LN4@lssproto_m
$LN2@lssproto_m:
  00039	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0003c	83 c0 01	 add	 eax, 1
  0003f	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@lssproto_m:
  00042	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00045	3b 45 08	 cmp	 eax, DWORD PTR _size$[ebp]
  00048	7d 2b		 jge	 SHORT $LN3@lssproto_m
  0004a	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  0004f	50		 push	 eax
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  00053	8b 55 0c	 mov	 edx, DWORD PTR _array$[ebp]
  00056	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 ?lssproto_mkstr_short@@YAPADF@Z ; lssproto_mkstr_short
  00060	83 c4 04	 add	 esp, 4
  00063	50		 push	 eax
  00064	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  0006a	51		 push	 ecx
  0006b	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH
  00073	eb c4		 jmp	 SHORT $LN2@lssproto_m
$LN3@lssproto_m:
  00075	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12

; 238  : }

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
?lssproto_mkstr_short_array@@YAPADHPAF@Z ENDP		; lssproto_mkstr_short_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_u_int_array@@YAPADHPAH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_size$ = 8						; size = 4
_array$ = 12						; size = 4
?lssproto_mkstr_u_int_array@@YAPADHPAH@Z PROC		; lssproto_mkstr_u_int_array, COMDAT

; 232  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 233  : 	MKSTR_ARRAYMACRO( lssproto_mkstr_u_int );

  0001e	b8 01 00 00 00	 mov	 eax, 1
  00023	6b c8 00	 imul	 ecx, eax, 0
  00026	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  0002c	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0
  00030	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00037	eb 09		 jmp	 SHORT $LN4@lssproto_m
$LN2@lssproto_m:
  00039	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0003c	83 c0 01	 add	 eax, 1
  0003f	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@lssproto_m:
  00042	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00045	3b 45 08	 cmp	 eax, DWORD PTR _size$[ebp]
  00048	7d 2a		 jge	 SHORT $LN3@lssproto_m
  0004a	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  0004f	50		 push	 eax
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  00053	8b 55 0c	 mov	 edx, DWORD PTR _array$[ebp]
  00056	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ?lssproto_mkstr_u_int@@YAPADI@Z ; lssproto_mkstr_u_int
  0005f	83 c4 04	 add	 esp, 4
  00062	50		 push	 eax
  00063	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00072	eb c5		 jmp	 SHORT $LN2@lssproto_m
$LN3@lssproto_m:
  00074	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12

; 234  : }

  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00082	3b ec		 cmp	 ebp, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
?lssproto_mkstr_u_int_array@@YAPADHPAH@Z ENDP		; lssproto_mkstr_u_int_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_int_array@@YAPADHPAH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_size$ = 8						; size = 4
_array$ = 12						; size = 4
?lssproto_mkstr_int_array@@YAPADHPAH@Z PROC		; lssproto_mkstr_int_array, COMDAT

; 218  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 219  : #define MKSTR_ARRAYMACRO( func) \
; 220  : 	{\
; 221  : 		 int i;\
; 222  :          lssproto.arraywork[0] = '\0';\
; 223  : 		 for(i=0;i<size;i++){   \
; 224  :              lssproto_strcatsafe( lssproto.arraywork , func(array[i]) , lssproto.workbufsize );\
; 225  : 		 }\
; 226  :          return lssproto.arraywork;\
; 227  :     }\
; 228  : 
; 229  : 	MKSTR_ARRAYMACRO( lssproto_mkstr_int );

  0001e	b8 01 00 00 00	 mov	 eax, 1
  00023	6b c8 00	 imul	 ecx, eax, 0
  00026	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  0002c	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0
  00030	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00037	eb 09		 jmp	 SHORT $LN4@lssproto_m
$LN2@lssproto_m:
  00039	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0003c	83 c0 01	 add	 eax, 1
  0003f	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@lssproto_m:
  00042	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00045	3b 45 08	 cmp	 eax, DWORD PTR _size$[ebp]
  00048	7d 2a		 jge	 SHORT $LN3@lssproto_m
  0004a	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  0004f	50		 push	 eax
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  00053	8b 55 0c	 mov	 edx, DWORD PTR _array$[ebp]
  00056	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ?lssproto_mkstr_int@@YAPADH@Z ; lssproto_mkstr_int
  0005f	83 c4 04	 add	 esp, 4
  00062	50		 push	 eax
  00063	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+12
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00072	eb c5		 jmp	 SHORT $LN2@lssproto_m
$LN3@lssproto_m:
  00074	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+12

; 230  : }

  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00082	3b ec		 cmp	 ebp, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
?lssproto_mkstr_int_array@@YAPADHPAH@Z ENDP		; lssproto_mkstr_int_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_double@@YAPADN@Z
_TEXT	SEGMENT
_d$ = 8							; size = 8
?lssproto_mkstr_double@@YAPADN@Z PROC			; lssproto_mkstr_double, COMDAT

; 213  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 214  : 	sprintf( lssproto.val_str , "%f " , d );

  0001e	83 ec 08	 sub	 esp, 8
  00021	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _d$[ebp]
  00026	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_03JAIJOMNP@?$CFf?5?$AA@
  00030	a1 14 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _sprintf
  0003b	83 c4 10	 add	 esp, 16			; 00000010H

; 215  : 	return lssproto.val_str;

  0003e	a1 14 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+20

; 216  : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?lssproto_mkstr_double@@YAPADN@Z ENDP			; lssproto_mkstr_double
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_float@@YAPADM@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
?lssproto_mkstr_float@@YAPADM@Z PROC			; lssproto_mkstr_float, COMDAT

; 208  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 209  : 	sprintf( lssproto.val_str , "%f " , f );

  0001e	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR _f$[ebp]
  00023	83 ec 08	 sub	 esp, 8
  00026	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_03JAIJOMNP@?$CFf?5?$AA@
  00030	a1 14 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _sprintf
  0003b	83 c4 10	 add	 esp, 16			; 00000010H

; 210  : 	return lssproto.val_str;

  0003e	a1 14 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+20

; 211  : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?lssproto_mkstr_float@@YAPADM@Z ENDP			; lssproto_mkstr_float
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_string@@YAPADPAD@Z
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_a$ = 8							; size = 4
?lssproto_mkstr_string@@YAPADPAD@Z PROC			; lssproto_mkstr_string, COMDAT

; 202  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 203  : 	char *ret = lssproto_escapeString( a );

  0001e	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?lssproto_escapeString@@YAPADPAD@Z ; lssproto_escapeString
  00027	83 c4 04	 add	 esp, 4
  0002a	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 204  : 	lssproto_strcatsafe( ret , " ", lssproto.workbufsize );

  0002d	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00032	50		 push	 eax
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  00038	8b 4d f8	 mov	 ecx, DWORD PTR _ret$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 205  : 	return ret;

  00044	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]

; 206  : }

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00050	3b ec		 cmp	 ebp, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?lssproto_mkstr_string@@YAPADPAD@Z ENDP			; lssproto_mkstr_string
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_u_char@@YAPADD@Z
_TEXT	SEGMENT
_c$ = 8							; size = 1
?lssproto_mkstr_u_char@@YAPADD@Z PROC			; lssproto_mkstr_u_char, COMDAT

; 195  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 196  : #define MKSTR_U_CHAR8(v)   lssproto_Ltoa( (long)( ((long)(v)) & 0xff ))
; 197  : 	lssproto_strcpysafe( lssproto.val_str , MKSTR_U_CHAR8(c) , lssproto.workbufsize );

  0001e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00023	50		 push	 eax
  00024	0f be 4d 08	 movsx	 ecx, BYTE PTR _c$[ebp]
  00028	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?lssproto_Ltoa@@YAPADJ@Z ; lssproto_Ltoa
  00034	83 c4 04	 add	 esp, 4
  00037	50		 push	 eax
  00038	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  0003e	52		 push	 edx
  0003f	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH

; 198  : 	lssproto_strcatsafe( lssproto.val_str ," "  , lssproto.workbufsize );

  00047	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  0004c	50		 push	 eax
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  00052	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 199  : 	return lssproto.val_str;

  00061	a1 14 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+20

; 200  : }

  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx
  00069	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0006f	3b ec		 cmp	 ebp, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?lssproto_mkstr_u_char@@YAPADD@Z ENDP			; lssproto_mkstr_u_char
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_char@@YAPADD@Z
_TEXT	SEGMENT
_c$ = 8							; size = 1
?lssproto_mkstr_char@@YAPADD@Z PROC			; lssproto_mkstr_char, COMDAT

; 188  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 189  : #define MKSTR_CHAR8(v)   lssproto_Ltoa( ( long)((int)(v)))
; 190  : 	lssproto_strcpysafe( lssproto.val_str , MKSTR_CHAR8(c) , lssproto.workbufsize );

  0001e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00023	50		 push	 eax
  00024	0f be 4d 08	 movsx	 ecx, BYTE PTR _c$[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 ?lssproto_Ltoa@@YAPADJ@Z ; lssproto_Ltoa
  0002e	83 c4 04	 add	 esp, 4
  00031	50		 push	 eax
  00032	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 191  : 	lssproto_strcatsafe( lssproto.val_str ," ", lssproto.workbufsize );

  00041	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00046	50		 push	 eax
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  0004c	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH

; 192  : 	return lssproto.val_str;	

  0005b	a1 14 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+20

; 193  : }

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?lssproto_mkstr_char@@YAPADD@Z ENDP			; lssproto_mkstr_char
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_u_short@@YAPADF@Z
_TEXT	SEGMENT
_s$ = 8							; size = 2
?lssproto_mkstr_u_short@@YAPADF@Z PROC			; lssproto_mkstr_u_short, COMDAT

; 181  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 182  : #define MKSTR_U_SHORT16(v)   lssproto_Ltoa( (long)(  ((long)(v)) & 0xffff ))
; 183  : 	lssproto_strcpysafe( lssproto.val_str , MKSTR_U_SHORT16(s) , lssproto.workbufsize );

  0001e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00023	50		 push	 eax
  00024	0f bf 4d 08	 movsx	 ecx, WORD PTR _s$[ebp]
  00028	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?lssproto_Ltoa@@YAPADJ@Z ; lssproto_Ltoa
  00034	83 c4 04	 add	 esp, 4
  00037	50		 push	 eax
  00038	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  0003e	52		 push	 edx
  0003f	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH

; 184  : 	lssproto_strcatsafe( lssproto.val_str ," " , lssproto.workbufsize );

  00047	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  0004c	50		 push	 eax
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  00052	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 185  : 	return lssproto.val_str;	

  00061	a1 14 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+20

; 186  : }

  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx
  00069	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0006f	3b ec		 cmp	 ebp, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?lssproto_mkstr_u_short@@YAPADF@Z ENDP			; lssproto_mkstr_u_short
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_short@@YAPADF@Z
_TEXT	SEGMENT
_s$ = 8							; size = 2
?lssproto_mkstr_short@@YAPADF@Z PROC			; lssproto_mkstr_short, COMDAT

; 174  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 175  : #define MKSTR_SHORT16(v)    lssproto_Ltoa( (long)((int)(v) ))
; 176  : 	lssproto_strcpysafe( lssproto.val_str , MKSTR_SHORT16(s) , lssproto.workbufsize );

  0001e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00023	50		 push	 eax
  00024	0f bf 4d 08	 movsx	 ecx, WORD PTR _s$[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 ?lssproto_Ltoa@@YAPADJ@Z ; lssproto_Ltoa
  0002e	83 c4 04	 add	 esp, 4
  00031	50		 push	 eax
  00032	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 177  : 	lssproto_strcatsafe( lssproto.val_str ," " , lssproto.workbufsize );

  00041	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00046	50		 push	 eax
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  0004c	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH

; 178  : 	return lssproto.val_str;	

  0005b	a1 14 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+20

; 179  : }

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?lssproto_mkstr_short@@YAPADF@Z ENDP			; lssproto_mkstr_short
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_u_long@@YAPADK@Z
_TEXT	SEGMENT
_l$ = 8							; size = 4
?lssproto_mkstr_u_long@@YAPADK@Z PROC			; lssproto_mkstr_u_long, COMDAT

; 167  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 168  : #define MKSTR_U_LONG(v) lssproto_Ultoa(v ) 
; 169  : 	lssproto_strcpysafe( lssproto.val_str , MKSTR_U_LONG(l) , lssproto.workbufsize );

  0001e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _l$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 ?lssproto_Ultoa@@YAPADK@Z ; lssproto_Ultoa
  0002d	83 c4 04	 add	 esp, 4
  00030	50		 push	 eax
  00031	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 170  : 	lssproto_strcatsafe( lssproto.val_str ," " , lssproto.workbufsize );

  00040	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  0004b	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH

; 171  : 	return lssproto.val_str;	

  0005a	a1 14 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+20

; 172  : }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00068	3b ec		 cmp	 ebp, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?lssproto_mkstr_u_long@@YAPADK@Z ENDP			; lssproto_mkstr_u_long
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_long@@YAPADJ@Z
_TEXT	SEGMENT
_l$ = 8							; size = 4
?lssproto_mkstr_long@@YAPADJ@Z PROC			; lssproto_mkstr_long, COMDAT

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 161  : #define MKSTR_LONG(v) lssproto_Ltoa( v ) 
; 162  : 	lssproto_strcpysafe( lssproto.val_str , MKSTR_LONG(l) , lssproto.workbufsize );

  0001e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _l$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 ?lssproto_Ltoa@@YAPADJ@Z ; lssproto_Ltoa
  0002d	83 c4 04	 add	 esp, 4
  00030	50		 push	 eax
  00031	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 163  : 	lssproto_strcatsafe( lssproto.val_str ," " , lssproto.workbufsize );

  00040	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  0004b	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH

; 164  : 	return lssproto.val_str;

  0005a	a1 14 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+20

; 165  : }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00068	3b ec		 cmp	 ebp, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?lssproto_mkstr_long@@YAPADJ@Z ENDP			; lssproto_mkstr_long
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_u_int@@YAPADI@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?lssproto_mkstr_u_int@@YAPADI@Z PROC			; lssproto_mkstr_u_int, COMDAT

; 153  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 154  : #define MKSTR_U_INT(v) lssproto_Ultoa( (unsigned long ) (v) )
; 155  : 	lssproto_strcpysafe( lssproto.val_str , MKSTR_U_INT(i) , lssproto.workbufsize );

  0001e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 ?lssproto_Ultoa@@YAPADK@Z ; lssproto_Ultoa
  0002d	83 c4 04	 add	 esp, 4
  00030	50		 push	 eax
  00031	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 156  : 	lssproto_strcatsafe( lssproto.val_str ," " , lssproto.workbufsize );

  00040	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  0004b	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH

; 157  : 	return lssproto.val_str;

  0005a	a1 14 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+20

; 158  : }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00068	3b ec		 cmp	 ebp, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?lssproto_mkstr_u_int@@YAPADI@Z ENDP			; lssproto_mkstr_u_int
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_mkstr_int@@YAPADH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?lssproto_mkstr_int@@YAPADH@Z PROC			; lssproto_mkstr_int, COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 147  : #define MKSTR_INT(v) lssproto_Ltoa( (long)(v)) 
; 148  : 	lssproto_strcpysafe( lssproto.val_str ,  (char*)MKSTR_INT(i) , lssproto.workbufsize );

  0001e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 ?lssproto_Ltoa@@YAPADJ@Z ; lssproto_Ltoa
  0002d	83 c4 04	 add	 esp, 4
  00030	50		 push	 eax
  00031	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 ?lssproto_strcpysafe@@YAXPAD0H@Z ; lssproto_strcpysafe
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 149  : 	lssproto_strcatsafe( lssproto.val_str ," " , lssproto.workbufsize );

  00040	a1 04 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+4
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  0004b	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+20
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 ?lssproto_strcatsafe@@YAXPAD0H@Z ; lssproto_strcatsafe
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH

; 150  : 	return lssproto.val_str;

  0005a	a1 14 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+20

; 151  : }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00068	3b ec		 cmp	 ebp, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?lssproto_mkstr_int@@YAPADH@Z ENDP			; lssproto_mkstr_int
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_strcatsafe@@YAXPAD0H@Z
_TEXT	SEGMENT
_j$ = -20						; size = 4
_i$ = -8						; size = 4
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_maxlen$ = 16						; size = 4
?lssproto_strcatsafe@@YAXPAD0H@Z PROC			; lssproto_strcatsafe, COMDAT

; 132  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 133  : 	int i,j;
; 134  : 	for(i=0;i<maxlen-1;i++){

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00025	eb 09		 jmp	 SHORT $LN4@lssproto_s
$LN2@lssproto_s:
  00027	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0002a	83 c0 01	 add	 eax, 1
  0002d	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@lssproto_s:
  00030	8b 45 10	 mov	 eax, DWORD PTR _maxlen$[ebp]
  00033	83 e8 01	 sub	 eax, 1
  00036	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  00039	7d 5f		 jge	 SHORT $LN1@lssproto_s

; 135  : 		if( dest[i] == 0 ){

  0003b	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0003e	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00041	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00044	85 c9		 test	 ecx, ecx
  00046	75 50		 jne	 SHORT $LN8@lssproto_s

; 136  : 			for(j=i;j<maxlen-1;j++){

  00048	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0004b	89 45 ec	 mov	 DWORD PTR _j$[ebp], eax
  0004e	eb 09		 jmp	 SHORT $LN7@lssproto_s
$LN5@lssproto_s:
  00050	8b 45 ec	 mov	 eax, DWORD PTR _j$[ebp]
  00053	83 c0 01	 add	 eax, 1
  00056	89 45 ec	 mov	 DWORD PTR _j$[ebp], eax
$LN7@lssproto_s:
  00059	8b 45 10	 mov	 eax, DWORD PTR _maxlen$[ebp]
  0005c	83 e8 01	 sub	 eax, 1
  0005f	39 45 ec	 cmp	 DWORD PTR _j$[ebp], eax
  00062	7d 29		 jge	 SHORT $LN6@lssproto_s

; 137  : 				dest[j]= src[j-i];

  00064	8b 45 ec	 mov	 eax, DWORD PTR _j$[ebp]
  00067	2b 45 f8	 sub	 eax, DWORD PTR _i$[ebp]
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  0006d	03 4d ec	 add	 ecx, DWORD PTR _j$[ebp]
  00070	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00073	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  00076	88 01		 mov	 BYTE PTR [ecx], al

; 138  : 				if( src[j-i] == 0 )break;

  00078	8b 45 ec	 mov	 eax, DWORD PTR _j$[ebp]
  0007b	2b 45 f8	 sub	 eax, DWORD PTR _i$[ebp]
  0007e	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00081	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00085	85 d2		 test	 edx, edx
  00087	75 02		 jne	 SHORT $LN9@lssproto_s
  00089	eb 02		 jmp	 SHORT $LN6@lssproto_s
$LN9@lssproto_s:

; 139  : 			}

  0008b	eb c3		 jmp	 SHORT $LN5@lssproto_s
$LN6@lssproto_s:

; 140  : 			dest[j]=0;

  0008d	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00090	03 45 ec	 add	 eax, DWORD PTR _j$[ebp]
  00093	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			break;

  00096	eb 02		 jmp	 SHORT $LN1@lssproto_s
$LN8@lssproto_s:

; 142  : 		}
; 143  : 	}

  00098	eb 8d		 jmp	 SHORT $LN2@lssproto_s
$LN1@lssproto_s:

; 144  : }

  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
?lssproto_strcatsafe@@YAXPAD0H@Z ENDP			; lssproto_strcatsafe
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_strcpysafe@@YAXPAD0H@Z
_TEXT	SEGMENT
_i$ = -8						; size = 4
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_maxlen$ = 16						; size = 4
?lssproto_strcpysafe@@YAXPAD0H@Z PROC			; lssproto_strcpysafe, COMDAT

; 123  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 124  : 	int i;
; 125  : 	for(i=0;i<maxlen-1;i++){

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00025	eb 09		 jmp	 SHORT $LN4@lssproto_s
$LN2@lssproto_s:
  00027	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0002a	83 c0 01	 add	 eax, 1
  0002d	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@lssproto_s:
  00030	8b 45 10	 mov	 eax, DWORD PTR _maxlen$[ebp]
  00033	83 e8 01	 sub	 eax, 1
  00036	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  00039	7d 21		 jge	 SHORT $LN3@lssproto_s

; 126  : 		dest[i] = src[i];

  0003b	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0003e	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00041	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00044	03 4d f8	 add	 ecx, DWORD PTR _i$[ebp]
  00047	8a 11		 mov	 dl, BYTE PTR [ecx]
  00049	88 10		 mov	 BYTE PTR [eax], dl

; 127  : 		if( src[i]==0)break;

  0004b	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0004e	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00051	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00054	85 c9		 test	 ecx, ecx
  00056	75 02		 jne	 SHORT $LN5@lssproto_s
  00058	eb 02		 jmp	 SHORT $LN3@lssproto_s
$LN5@lssproto_s:

; 128  : 	}

  0005a	eb cb		 jmp	 SHORT $LN2@lssproto_s
$LN3@lssproto_s:

; 129  : 	dest[i]=0;

  0005c	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0005f	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00062	c6 00 00	 mov	 BYTE PTR [eax], 0

; 130  : }

  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?lssproto_strcpysafe@@YAXPAD0H@Z ENDP			; lssproto_strcpysafe
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_splitString@@YAXPAD@Z
_TEXT	SEGMENT
_rfp$1 = -44						; size = 4
_decoded$ = -32						; size = 4
_c$ = -20						; size = 4
_i$ = -8						; size = 4
_src$ = 8						; size = 4
?lssproto_splitString@@YAXPAD@Z PROC			; lssproto_splitString, COMDAT

; 458  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 459  : 	int i,c=0;

  0001e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _c$[ebp], 0

; 460  : 	char *decoded;
; 461  : 	
; 462  : #ifdef lssproto__ENCRYPT
; 463  : 	if( !bNewServer){

  00025	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bNewServer@@3HA, 0 ; bNewServer
  0002c	75 1a		 jne	 SHORT $LN7@lssproto_s

; 464  : 		decoded = lssproto.cryptwork;

  0002e	a1 1c 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+28
  00033	89 45 e0	 mov	 DWORD PTR _decoded$[ebp], eax

; 465  : 		lssproto_decodeString( src , decoded );

  00036	8b 45 e0	 mov	 eax, DWORD PTR _decoded$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ?lssproto_decodeString@@YAXPAD0@Z ; lssproto_decodeString
  00043	83 c4 08	 add	 esp, 8

; 466  : 	}else

  00046	eb 06		 jmp	 SHORT $LN8@lssproto_s
$LN7@lssproto_s:

; 467  : 		decoded = src;

  00048	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0004b	89 45 e0	 mov	 DWORD PTR _decoded$[ebp], eax
$LN8@lssproto_s:

; 468  : #else
; 469  : 	decoded = src;
; 470  : #endif
; 471  : 	if( lssproto_readlogfilename[0] != '\0'){

  0004e	b8 01 00 00 00	 mov	 eax, 1
  00053	6b c8 00	 imul	 ecx, eax, 0
  00056	0f be 91 00 00
	00 00		 movsx	 edx, BYTE PTR ?lssproto_readlogfilename@@3PADA[ecx]
  0005d	85 d2		 test	 edx, edx
  0005f	74 50		 je	 SHORT $LN9@lssproto_s

; 472  : 		FILE *rfp;
; 473  : 		rfp = fopen( lssproto_readlogfilename , "a+" );

  00061	8b f4		 mov	 esi, esp
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_02DPNLHKJD@a?$CL?$AA@
  00068	68 00 00 00 00	 push	 OFFSET ?lssproto_readlogfilename@@3PADA ; lssproto_readlogfilename
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00073	83 c4 08	 add	 esp, 8
  00076	3b f4		 cmp	 esi, esp
  00078	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007d	89 45 d4	 mov	 DWORD PTR _rfp$1[ebp], eax

; 474  : 		if(rfp){

  00080	83 7d d4 00	 cmp	 DWORD PTR _rfp$1[ebp], 0
  00084	74 2b		 je	 SHORT $LN9@lssproto_s

; 475  : 			fprintf( rfp, "\t%s\n",decoded );

  00086	8b 45 e0	 mov	 eax, DWORD PTR _decoded$[ebp]
  00089	50		 push	 eax
  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_0L@INAHAGEI@?b?$KF?S?p?$KD?$LK?7?$CFs?6?$AA@
  0008f	8b 4d d4	 mov	 ecx, DWORD PTR _rfp$1[ebp]
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 _fprintf
  00098	83 c4 0c	 add	 esp, 12			; 0000000cH

; 476  : 			fclose(rfp);

  0009b	8b f4		 mov	 esi, esp
  0009d	8b 45 d4	 mov	 eax, DWORD PTR _rfp$1[ebp]
  000a0	50		 push	 eax
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  000a7	83 c4 04	 add	 esp, 4
  000aa	3b f4		 cmp	 esi, esp
  000ac	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN9@lssproto_s:

; 477  : 		}
; 478  : 	}
; 479  : 	for(i = 0 ; ; i++ ){

  000b1	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000b8	eb 09		 jmp	 SHORT $LN4@lssproto_s
$LN2@lssproto_s:
  000ba	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000bd	83 c0 01	 add	 eax, 1
  000c0	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@lssproto_s:

; 480  : 		if( decoded[i] == '\0' ) break;

  000c3	8b 45 e0	 mov	 eax, DWORD PTR _decoded$[ebp]
  000c6	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  000c9	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000cc	85 c9		 test	 ecx, ecx
  000ce	75 02		 jne	 SHORT $LN11@lssproto_s
  000d0	eb 50		 jmp	 SHORT $LN5@lssproto_s
$LN11@lssproto_s:

; 481  : 		if( i==0){

  000d2	83 7d f8 00	 cmp	 DWORD PTR _i$[ebp], 0
  000d6	75 1b		 jne	 SHORT $LN12@lssproto_s

; 482  : 		    lssproto.token_list[c++]=&(decoded[i]);

  000d8	8b 45 e0	 mov	 eax, DWORD PTR _decoded$[ebp]
  000db	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _c$[ebp]
  000e1	8b 15 2c 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+44
  000e7	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
  000ea	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp]
  000ed	83 c0 01	 add	 eax, 1
  000f0	89 45 ec	 mov	 DWORD PTR _c$[ebp], eax
$LN12@lssproto_s:

; 483  : 		}
; 484  : 		if( decoded[i]== ' '){

  000f3	8b 45 e0	 mov	 eax, DWORD PTR _decoded$[ebp]
  000f6	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  000f9	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000fc	83 f9 20	 cmp	 ecx, 32			; 00000020H
  000ff	75 1f		 jne	 SHORT $LN13@lssproto_s

; 485  : 		    lssproto.token_list[c++]=&(decoded[i+1]);

  00101	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00104	8b 4d e0	 mov	 ecx, DWORD PTR _decoded$[ebp]
  00107	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  0010b	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp]
  0010e	8b 0d 2c 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+44
  00114	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
  00117	8b 55 ec	 mov	 edx, DWORD PTR _c$[ebp]
  0011a	83 c2 01	 add	 edx, 1
  0011d	89 55 ec	 mov	 DWORD PTR _c$[ebp], edx
$LN13@lssproto_s:

; 486  : 		}
; 487  : 	}

  00120	eb 98		 jmp	 SHORT $LN2@lssproto_s
$LN5@lssproto_s:

; 488  : 	while( *decoded ){

  00122	8b 45 e0	 mov	 eax, DWORD PTR _decoded$[ebp]
  00125	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00128	85 c9		 test	 ecx, ecx
  0012a	74 32		 je	 SHORT $LN6@lssproto_s

; 489  : 		if( ( *decoded  ) == ' ' || (*decoded ) == '\n' || (*decoded ) == '\r' ) *decoded = '\0';

  0012c	8b 45 e0	 mov	 eax, DWORD PTR _decoded$[ebp]
  0012f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00132	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00135	74 16		 je	 SHORT $LN15@lssproto_s
  00137	8b 45 e0	 mov	 eax, DWORD PTR _decoded$[ebp]
  0013a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0013d	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00140	74 0b		 je	 SHORT $LN15@lssproto_s
  00142	8b 45 e0	 mov	 eax, DWORD PTR _decoded$[ebp]
  00145	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00148	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  0014b	75 06		 jne	 SHORT $LN14@lssproto_s
$LN15@lssproto_s:
  0014d	8b 45 e0	 mov	 eax, DWORD PTR _decoded$[ebp]
  00150	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN14@lssproto_s:

; 490  : 		decoded++;

  00153	8b 45 e0	 mov	 eax, DWORD PTR _decoded$[ebp]
  00156	83 c0 01	 add	 eax, 1
  00159	89 45 e0	 mov	 DWORD PTR _decoded$[ebp], eax

; 491  :  	}

  0015c	eb c4		 jmp	 SHORT $LN5@lssproto_s
$LN6@lssproto_s:

; 492  : 	lssproto.token_list[c] = (char*)NULL;

  0015e	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp]
  00161	8b 0d 2c 00 00
	00		 mov	 ecx, DWORD PTR ?lssproto@@3Ulssproto_@@A+44
  00167	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [ecx+eax*4], 0

; 493  : }

  0016e	5f		 pop	 edi
  0016f	5e		 pop	 esi
  00170	5b		 pop	 ebx
  00171	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00177	3b ec		 cmp	 ebp, esp
  00179	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0017e	8b e5		 mov	 esp, ebp
  00180	5d		 pop	 ebp
  00181	c3		 ret	 0
?lssproto_splitString@@YAXPAD@Z ENDP			; lssproto_splitString
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_descapeString@@YAPADPAD@Z
_TEXT	SEGMENT
_c$1 = -32						; size = 4
_i$2 = -20						; size = 4
_c$ = -8						; size = 4
_a$ = 8							; size = 4
?lssproto_descapeString@@YAPADPAD@Z PROC		; lssproto_descapeString, COMDAT

; 412  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 413  : 	lssproto.escapework[0]='\0';

  0001e	b8 01 00 00 00	 mov	 eax, 1
  00023	6b c8 00	 imul	 ecx, eax, 0
  00026	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  0002c	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0

; 414  : 	int c = 0;

  00030	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _c$[ebp], 0

; 415  : 	for(int i=0,c=0;a[i]!='\0';i++){

  00037	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  0003e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _c$1[ebp], 0
  00045	eb 09		 jmp	 SHORT $LN4@lssproto_d
$LN2@lssproto_d:
  00047	8b 45 ec	 mov	 eax, DWORD PTR _i$2[ebp]
  0004a	83 c0 01	 add	 eax, 1
  0004d	89 45 ec	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@lssproto_d:
  00050	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00053	03 45 ec	 add	 eax, DWORD PTR _i$2[ebp]
  00056	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00059	85 c9		 test	 ecx, ecx
  0005b	0f 84 99 01 00
	00		 je	 $LN3@lssproto_d

; 416  : 		if(IsDBCSLeadByte(a[i])){

  00061	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00064	03 45 ec	 add	 eax, DWORD PTR _i$2[ebp]
  00067	8b f4		 mov	 esi, esp
  00069	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0006c	51		 push	 ecx
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsDBCSLeadByte@4
  00073	3b f4		 cmp	 esi, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	85 c0		 test	 eax, eax
  0007c	74 5f		 je	 SHORT $LN5@lssproto_d

; 417  : 			lssproto.escapework[c++]=a[i++];

  0007e	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  00083	03 45 e0	 add	 eax, DWORD PTR _c$1[ebp]
  00086	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00089	03 4d ec	 add	 ecx, DWORD PTR _i$2[ebp]
  0008c	8a 11		 mov	 dl, BYTE PTR [ecx]
  0008e	88 10		 mov	 BYTE PTR [eax], dl
  00090	8b 45 e0	 mov	 eax, DWORD PTR _c$1[ebp]
  00093	83 c0 01	 add	 eax, 1
  00096	89 45 e0	 mov	 DWORD PTR _c$1[ebp], eax
  00099	8b 4d ec	 mov	 ecx, DWORD PTR _i$2[ebp]
  0009c	83 c1 01	 add	 ecx, 1
  0009f	89 4d ec	 mov	 DWORD PTR _i$2[ebp], ecx

; 418  : 			if(a[i]=='\0'){

  000a2	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000a5	03 45 ec	 add	 eax, DWORD PTR _i$2[ebp]
  000a8	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000ab	85 c9		 test	 ecx, ecx
  000ad	75 0e		 jne	 SHORT $LN7@lssproto_d

; 419  : 				c--;

  000af	8b 45 e0	 mov	 eax, DWORD PTR _c$1[ebp]
  000b2	83 e8 01	 sub	 eax, 1
  000b5	89 45 e0	 mov	 DWORD PTR _c$1[ebp], eax

; 420  : 				break;

  000b8	e9 3d 01 00 00	 jmp	 $LN3@lssproto_d
$LN7@lssproto_d:

; 421  : 			}
; 422  : 			lssproto.escapework[c++]=a[i];

  000bd	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  000c2	03 45 e0	 add	 eax, DWORD PTR _c$1[ebp]
  000c5	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  000c8	03 4d ec	 add	 ecx, DWORD PTR _i$2[ebp]
  000cb	8a 11		 mov	 dl, BYTE PTR [ecx]
  000cd	88 10		 mov	 BYTE PTR [eax], dl
  000cf	8b 45 e0	 mov	 eax, DWORD PTR _c$1[ebp]
  000d2	83 c0 01	 add	 eax, 1
  000d5	89 45 e0	 mov	 DWORD PTR _c$1[ebp], eax
  000d8	e9 18 01 00 00	 jmp	 $LN6@lssproto_d
$LN5@lssproto_d:

; 423  : 		}else if(a[i]=='\\'){

  000dd	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000e0	03 45 ec	 add	 eax, DWORD PTR _i$2[ebp]
  000e3	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000e6	83 f9 5c	 cmp	 ecx, 92			; 0000005cH
  000e9	0f 85 eb 00 00
	00		 jne	 $LN8@lssproto_d

; 424  : 			if(a[i+1]=='\0'){

  000ef	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000f2	03 45 ec	 add	 eax, DWORD PTR _i$2[ebp]
  000f5	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  000f9	85 c9		 test	 ecx, ecx
  000fb	75 20		 jne	 SHORT $LN10@lssproto_d

; 425  : 				lssproto.escapework[c++]=a[i];

  000fd	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  00102	03 45 e0	 add	 eax, DWORD PTR _c$1[ebp]
  00105	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00108	03 4d ec	 add	 ecx, DWORD PTR _i$2[ebp]
  0010b	8a 11		 mov	 dl, BYTE PTR [ecx]
  0010d	88 10		 mov	 BYTE PTR [eax], dl
  0010f	8b 45 e0	 mov	 eax, DWORD PTR _c$1[ebp]
  00112	83 c0 01	 add	 eax, 1
  00115	89 45 e0	 mov	 DWORD PTR _c$1[ebp], eax

; 426  : 				break;

  00118	e9 dd 00 00 00	 jmp	 $LN3@lssproto_d
$LN10@lssproto_d:

; 427  : 			}
; 428  : 			if(a[i+1]=='S')

  0011d	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00120	03 45 ec	 add	 eax, DWORD PTR _i$2[ebp]
  00123	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  00127	83 f9 53	 cmp	 ecx, 83			; 00000053H
  0012a	75 19		 jne	 SHORT $LN11@lssproto_d

; 429  : 				lssproto.escapework[c++]=' ';

  0012c	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  00131	03 45 e0	 add	 eax, DWORD PTR _c$1[ebp]
  00134	c6 00 20	 mov	 BYTE PTR [eax], 32	; 00000020H
  00137	8b 4d e0	 mov	 ecx, DWORD PTR _c$1[ebp]
  0013a	83 c1 01	 add	 ecx, 1
  0013d	89 4d e0	 mov	 DWORD PTR _c$1[ebp], ecx
  00140	e9 8a 00 00 00	 jmp	 $LN12@lssproto_d
$LN11@lssproto_d:

; 430  : 			else if(a[i+1]=='n')

  00145	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00148	03 45 ec	 add	 eax, DWORD PTR _i$2[ebp]
  0014b	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  0014f	83 f9 6e	 cmp	 ecx, 110		; 0000006eH
  00152	75 16		 jne	 SHORT $LN13@lssproto_d

; 431  : 				lssproto.escapework[c++]='\n';

  00154	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  00159	03 45 e0	 add	 eax, DWORD PTR _c$1[ebp]
  0015c	c6 00 0a	 mov	 BYTE PTR [eax], 10	; 0000000aH
  0015f	8b 4d e0	 mov	 ecx, DWORD PTR _c$1[ebp]
  00162	83 c1 01	 add	 ecx, 1
  00165	89 4d e0	 mov	 DWORD PTR _c$1[ebp], ecx
  00168	eb 65		 jmp	 SHORT $LN12@lssproto_d
$LN13@lssproto_d:

; 432  : 			else if( a[i+1] == 'r' )

  0016a	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0016d	03 45 ec	 add	 eax, DWORD PTR _i$2[ebp]
  00170	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  00174	83 f9 72	 cmp	 ecx, 114		; 00000072H
  00177	75 16		 jne	 SHORT $LN15@lssproto_d

; 433  : 				lssproto.escapework[c++]='\r';

  00179	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  0017e	03 45 e0	 add	 eax, DWORD PTR _c$1[ebp]
  00181	c6 00 0d	 mov	 BYTE PTR [eax], 13	; 0000000dH
  00184	8b 4d e0	 mov	 ecx, DWORD PTR _c$1[ebp]
  00187	83 c1 01	 add	 ecx, 1
  0018a	89 4d e0	 mov	 DWORD PTR _c$1[ebp], ecx
  0018d	eb 40		 jmp	 SHORT $LN12@lssproto_d
$LN15@lssproto_d:

; 434  : 			else if( a[i+1] == '\\' )

  0018f	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00192	03 45 ec	 add	 eax, DWORD PTR _i$2[ebp]
  00195	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  00199	83 f9 5c	 cmp	 ecx, 92			; 0000005cH
  0019c	75 16		 jne	 SHORT $LN17@lssproto_d

; 435  : 				lssproto.escapework[c++]='\\';

  0019e	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  001a3	03 45 e0	 add	 eax, DWORD PTR _c$1[ebp]
  001a6	c6 00 5c	 mov	 BYTE PTR [eax], 92	; 0000005cH
  001a9	8b 4d e0	 mov	 ecx, DWORD PTR _c$1[ebp]
  001ac	83 c1 01	 add	 ecx, 1
  001af	89 4d e0	 mov	 DWORD PTR _c$1[ebp], ecx

; 436  : 			else

  001b2	eb 1b		 jmp	 SHORT $LN12@lssproto_d
$LN17@lssproto_d:

; 437  : 				lssproto.escapework[c++]=a[i];

  001b4	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  001b9	03 45 e0	 add	 eax, DWORD PTR _c$1[ebp]
  001bc	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  001bf	03 4d ec	 add	 ecx, DWORD PTR _i$2[ebp]
  001c2	8a 11		 mov	 dl, BYTE PTR [ecx]
  001c4	88 10		 mov	 BYTE PTR [eax], dl
  001c6	8b 45 e0	 mov	 eax, DWORD PTR _c$1[ebp]
  001c9	83 c0 01	 add	 eax, 1
  001cc	89 45 e0	 mov	 DWORD PTR _c$1[ebp], eax
$LN12@lssproto_d:

; 438  : 			i++;           

  001cf	8b 45 ec	 mov	 eax, DWORD PTR _i$2[ebp]
  001d2	83 c0 01	 add	 eax, 1
  001d5	89 45 ec	 mov	 DWORD PTR _i$2[ebp], eax

; 439  : 		}else

  001d8	eb 1b		 jmp	 SHORT $LN6@lssproto_d
$LN8@lssproto_d:

; 440  : 			lssproto.escapework[c++]=a[i];

  001da	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  001df	03 45 e0	 add	 eax, DWORD PTR _c$1[ebp]
  001e2	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  001e5	03 4d ec	 add	 ecx, DWORD PTR _i$2[ebp]
  001e8	8a 11		 mov	 dl, BYTE PTR [ecx]
  001ea	88 10		 mov	 BYTE PTR [eax], dl
  001ec	8b 45 e0	 mov	 eax, DWORD PTR _c$1[ebp]
  001ef	83 c0 01	 add	 eax, 1
  001f2	89 45 e0	 mov	 DWORD PTR _c$1[ebp], eax
$LN6@lssproto_d:

; 441  : 	}

  001f5	e9 4d fe ff ff	 jmp	 $LN2@lssproto_d
$LN3@lssproto_d:

; 442  : 	lssproto.escapework[c]='\0';

  001fa	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  001ff	03 45 f8	 add	 eax, DWORD PTR _c$[ebp]
  00202	c6 00 00	 mov	 BYTE PTR [eax], 0

; 443  : 	return lssproto.escapework;

  00205	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16

; 444  : }

  0020a	5f		 pop	 edi
  0020b	5e		 pop	 esi
  0020c	5b		 pop	 ebx
  0020d	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00213	3b ec		 cmp	 ebp, esp
  00215	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0021a	8b e5		 mov	 esp, ebp
  0021c	5d		 pop	 ebp
  0021d	c3		 ret	 0
?lssproto_descapeString@@YAPADPAD@Z ENDP		; lssproto_descapeString
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\lssproto_util.cpp
;	COMDAT ?lssproto_escapeString@@YAPADPAD@Z
_TEXT	SEGMENT
_c$ = -20						; size = 4
_i$ = -8						; size = 4
_a$ = 8							; size = 4
?lssproto_escapeString@@YAPADPAD@Z PROC			; lssproto_escapeString, COMDAT

; 378  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 379  : 	lssproto.escapework[0]='\0';

  0001e	b8 01 00 00 00	 mov	 eax, 1
  00023	6b c8 00	 imul	 ecx, eax, 0
  00026	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  0002c	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0

; 380  : 	int i, c;
; 381  : 	for(i=0,c=0;a[i]!='\0';i++){

  00030	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00037	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _c$[ebp], 0
  0003e	eb 09		 jmp	 SHORT $LN4@lssproto_e
$LN2@lssproto_e:
  00040	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00043	83 c0 01	 add	 eax, 1
  00046	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@lssproto_e:
  00049	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0004c	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  0004f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00052	85 c9		 test	 ecx, ecx
  00054	0f 84 bd 01 00
	00		 je	 $LN3@lssproto_e

; 382  : 		if(a[i]==-1){

  0005a	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0005d	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00060	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00063	83 f9 ff	 cmp	 ecx, -1
  00066	75 19		 jne	 SHORT $LN5@lssproto_e

; 383  : 			lssproto.escapework[c++]=' ';

  00068	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  0006d	03 45 ec	 add	 eax, DWORD PTR _c$[ebp]
  00070	c6 00 20	 mov	 BYTE PTR [eax], 32	; 00000020H
  00073	8b 4d ec	 mov	 ecx, DWORD PTR _c$[ebp]
  00076	83 c1 01	 add	 ecx, 1
  00079	89 4d ec	 mov	 DWORD PTR _c$[ebp], ecx
  0007c	e9 91 01 00 00	 jmp	 $LN6@lssproto_e
$LN5@lssproto_e:

; 384  : 		}else if(IsDBCSLeadByte(a[i])){

  00081	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00084	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00087	8b f4		 mov	 esi, esp
  00089	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0008c	51		 push	 ecx
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsDBCSLeadByte@4
  00093	3b f4		 cmp	 esi, esp
  00095	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009a	85 c0		 test	 eax, eax
  0009c	74 73		 je	 SHORT $LN7@lssproto_e

; 385  : 			lssproto.escapework[c++]=a[i++];

  0009e	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  000a3	03 45 ec	 add	 eax, DWORD PTR _c$[ebp]
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  000a9	03 4d f8	 add	 ecx, DWORD PTR _i$[ebp]
  000ac	8a 11		 mov	 dl, BYTE PTR [ecx]
  000ae	88 10		 mov	 BYTE PTR [eax], dl
  000b0	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp]
  000b3	83 c0 01	 add	 eax, 1
  000b6	89 45 ec	 mov	 DWORD PTR _c$[ebp], eax
  000b9	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000bc	83 c1 01	 add	 ecx, 1
  000bf	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx

; 386  : 			if(a[i]=='\0'){

  000c2	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000c5	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  000c8	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000cb	85 c9		 test	 ecx, ecx
  000cd	75 22		 jne	 SHORT $LN9@lssproto_e

; 387  : 				c--;

  000cf	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp]
  000d2	83 e8 01	 sub	 eax, 1
  000d5	89 45 ec	 mov	 DWORD PTR _c$[ebp], eax

; 388  : 				lssproto.escapework[c++]=' ';

  000d8	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  000dd	03 45 ec	 add	 eax, DWORD PTR _c$[ebp]
  000e0	c6 00 20	 mov	 BYTE PTR [eax], 32	; 00000020H
  000e3	8b 4d ec	 mov	 ecx, DWORD PTR _c$[ebp]
  000e6	83 c1 01	 add	 ecx, 1
  000e9	89 4d ec	 mov	 DWORD PTR _c$[ebp], ecx

; 389  : 				break;

  000ec	e9 26 01 00 00	 jmp	 $LN3@lssproto_e
$LN9@lssproto_e:

; 390  : 			}
; 391  : 			lssproto.escapework[c++]=a[i];

  000f1	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  000f6	03 45 ec	 add	 eax, DWORD PTR _c$[ebp]
  000f9	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  000fc	03 4d f8	 add	 ecx, DWORD PTR _i$[ebp]
  000ff	8a 11		 mov	 dl, BYTE PTR [ecx]
  00101	88 10		 mov	 BYTE PTR [eax], dl
  00103	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp]
  00106	83 c0 01	 add	 eax, 1
  00109	89 45 ec	 mov	 DWORD PTR _c$[ebp], eax
  0010c	e9 01 01 00 00	 jmp	 $LN6@lssproto_e
$LN7@lssproto_e:

; 392  : 		}else if( a[i] == '\\' ){

  00111	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00114	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00117	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0011a	83 f9 5c	 cmp	 ecx, 92			; 0000005cH
  0011d	75 2d		 jne	 SHORT $LN10@lssproto_e

; 393  : 			lssproto.escapework[c++] = '\\';

  0011f	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  00124	03 45 ec	 add	 eax, DWORD PTR _c$[ebp]
  00127	c6 00 5c	 mov	 BYTE PTR [eax], 92	; 0000005cH
  0012a	8b 4d ec	 mov	 ecx, DWORD PTR _c$[ebp]
  0012d	83 c1 01	 add	 ecx, 1
  00130	89 4d ec	 mov	 DWORD PTR _c$[ebp], ecx

; 394  : 			lssproto.escapework[c++] = 'y';

  00133	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  00138	03 45 ec	 add	 eax, DWORD PTR _c$[ebp]
  0013b	c6 00 79	 mov	 BYTE PTR [eax], 121	; 00000079H
  0013e	8b 4d ec	 mov	 ecx, DWORD PTR _c$[ebp]
  00141	83 c1 01	 add	 ecx, 1
  00144	89 4d ec	 mov	 DWORD PTR _c$[ebp], ecx
  00147	e9 c6 00 00 00	 jmp	 $LN6@lssproto_e
$LN10@lssproto_e:

; 395  : 		}else if( a[i] == ' ' ){

  0014c	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0014f	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00152	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00155	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00158	75 2d		 jne	 SHORT $LN12@lssproto_e

; 396  : 			lssproto.escapework[c++] = '\\';

  0015a	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  0015f	03 45 ec	 add	 eax, DWORD PTR _c$[ebp]
  00162	c6 00 5c	 mov	 BYTE PTR [eax], 92	; 0000005cH
  00165	8b 4d ec	 mov	 ecx, DWORD PTR _c$[ebp]
  00168	83 c1 01	 add	 ecx, 1
  0016b	89 4d ec	 mov	 DWORD PTR _c$[ebp], ecx

; 397  : 			lssproto.escapework[c++] = 'S';

  0016e	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  00173	03 45 ec	 add	 eax, DWORD PTR _c$[ebp]
  00176	c6 00 53	 mov	 BYTE PTR [eax], 83	; 00000053H
  00179	8b 4d ec	 mov	 ecx, DWORD PTR _c$[ebp]
  0017c	83 c1 01	 add	 ecx, 1
  0017f	89 4d ec	 mov	 DWORD PTR _c$[ebp], ecx
  00182	e9 8b 00 00 00	 jmp	 $LN6@lssproto_e
$LN12@lssproto_e:

; 398  : 		}else if( a[i] == '\n' ){

  00187	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0018a	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  0018d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00190	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00193	75 2a		 jne	 SHORT $LN14@lssproto_e

; 399  : 			lssproto.escapework[c++] = '\\';

  00195	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  0019a	03 45 ec	 add	 eax, DWORD PTR _c$[ebp]
  0019d	c6 00 5c	 mov	 BYTE PTR [eax], 92	; 0000005cH
  001a0	8b 4d ec	 mov	 ecx, DWORD PTR _c$[ebp]
  001a3	83 c1 01	 add	 ecx, 1
  001a6	89 4d ec	 mov	 DWORD PTR _c$[ebp], ecx

; 400  : 			lssproto.escapework[c++] = 'n';

  001a9	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  001ae	03 45 ec	 add	 eax, DWORD PTR _c$[ebp]
  001b1	c6 00 6e	 mov	 BYTE PTR [eax], 110	; 0000006eH
  001b4	8b 4d ec	 mov	 ecx, DWORD PTR _c$[ebp]
  001b7	83 c1 01	 add	 ecx, 1
  001ba	89 4d ec	 mov	 DWORD PTR _c$[ebp], ecx
  001bd	eb 53		 jmp	 SHORT $LN6@lssproto_e
$LN14@lssproto_e:

; 401  : 		}else if( a[i] == '\r' ){

  001bf	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  001c2	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  001c5	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001c8	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  001cb	75 2a		 jne	 SHORT $LN16@lssproto_e

; 402  : 			lssproto.escapework[c++] = '\\';

  001cd	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  001d2	03 45 ec	 add	 eax, DWORD PTR _c$[ebp]
  001d5	c6 00 5c	 mov	 BYTE PTR [eax], 92	; 0000005cH
  001d8	8b 4d ec	 mov	 ecx, DWORD PTR _c$[ebp]
  001db	83 c1 01	 add	 ecx, 1
  001de	89 4d ec	 mov	 DWORD PTR _c$[ebp], ecx

; 403  : 			lssproto.escapework[c++] = 'r';

  001e1	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  001e6	03 45 ec	 add	 eax, DWORD PTR _c$[ebp]
  001e9	c6 00 72	 mov	 BYTE PTR [eax], 114	; 00000072H
  001ec	8b 4d ec	 mov	 ecx, DWORD PTR _c$[ebp]
  001ef	83 c1 01	 add	 ecx, 1
  001f2	89 4d ec	 mov	 DWORD PTR _c$[ebp], ecx

; 404  : 		}else

  001f5	eb 1b		 jmp	 SHORT $LN6@lssproto_e
$LN16@lssproto_e:

; 405  : 			lssproto.escapework[c++] = a[i];

  001f7	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  001fc	03 45 ec	 add	 eax, DWORD PTR _c$[ebp]
  001ff	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00202	03 4d f8	 add	 ecx, DWORD PTR _i$[ebp]
  00205	8a 11		 mov	 dl, BYTE PTR [ecx]
  00207	88 10		 mov	 BYTE PTR [eax], dl
  00209	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp]
  0020c	83 c0 01	 add	 eax, 1
  0020f	89 45 ec	 mov	 DWORD PTR _c$[ebp], eax
$LN6@lssproto_e:

; 406  : 	}

  00212	e9 29 fe ff ff	 jmp	 $LN2@lssproto_e
$LN3@lssproto_e:

; 407  : 	lssproto.escapework[c] = '\0';

  00217	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16
  0021c	03 45 ec	 add	 eax, DWORD PTR _c$[ebp]
  0021f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 408  : 	return lssproto.escapework;

  00222	a1 10 00 00 00	 mov	 eax, DWORD PTR ?lssproto@@3Ulssproto_@@A+16

; 409  : }

  00227	5f		 pop	 edi
  00228	5e		 pop	 esi
  00229	5b		 pop	 ebx
  0022a	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00230	3b ec		 cmp	 ebp, esp
  00232	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00237	8b e5		 mov	 esp, ebp
  00239	5d		 pop	 ebp
  0023a	c3		 ret	 0
?lssproto_escapeString@@YAPADPAD@Z ENDP			; lssproto_escapeString
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

  0001e	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
  00023	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00026	89 45 ec	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00029	8b 45 ec	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0002c	50		 push	 eax
  0002d	6a 00		 push	 0
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 __vsprintf_l
  0003c	83 c4 10	 add	 esp, 16			; 00000010H
  0003f	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

  00042	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 1788 : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  0001e	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00029	52		 push	 edx
  0002a	6a ff		 push	 -1
  0002c	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 __vsnprintf_l
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -208						; size = 4
__Result$ = -8						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1386 :     int const _Result = __stdio_common_vsprintf(

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  0002f	50		 push	 eax
  00030	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00039	8b 10		 mov	 edx, DWORD PTR [eax]
  0003b	83 ca 01	 or	 edx, 1
  0003e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00041	50		 push	 eax
  00042	52		 push	 edx
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  00049	83 c4 1c	 add	 esp, 28			; 0000001cH
  0004c	3b f4		 cmp	 esi, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00056	83 7d f8 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0005a	7d 0c		 jge	 SHORT $LN3@vsnprintf_
  0005c	c7 85 30 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv74[ebp], -1
  00066	eb 09		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00068	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]
  0006b	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  00071	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv74[ebp]

; 1391 : }

  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00080	3b ec		 cmp	 ebp, esp
  00082	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 144  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 831  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 832  :     int _Result;
; 833  :     va_list _ArgList;
; 834  :     __crt_va_start(_ArgList, _Format);

  0001e	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
  00023	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00026	89 45 ec	 mov	 DWORD PTR __ArgList$[ebp], eax

; 835  :     _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00029	8b 45 ec	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0002c	50		 push	 eax
  0002d	6a 00		 push	 0
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 08	 mov	 edx, DWORD PTR __Stream$[ebp]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 __vfprintf_l
  0003c	83 c4 10	 add	 esp, 16			; 00000010H
  0003f	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 836  :     __crt_va_end(_ArgList);

  00042	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 837  :     return _Result;

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 838  : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 638  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	51		 push	 ecx
  00039	8b 10		 mov	 edx, DWORD PTR [eax]
  0003b	52		 push	 edx
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  00042	83 c4 18	 add	 esp, 24			; 00000018H
  00045	3b f4		 cmp	 esi, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 640  : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
