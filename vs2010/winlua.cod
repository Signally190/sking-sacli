; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Administrator\Desktop\????? ??\????? ??\Client Source Code\mylua\winlua.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?ptActMenuWinLua@@3PAUaction@@A			; ptActMenuWinLua
PUBLIC	??_C@_03IBJHJIAF@lua?$AA@			; `string'
PUBLIC	?MYLua@@3UtagMYLua@@A				; MYLua
PUBLIC	??_C@_03DEBJKBHO@Win?$AA@			; `string'
PUBLIC	??_C@_08GBGCLPL@lssproto?$AA@			; `string'
PUBLIC	??_C@_02CKOPKKAC@sa?$AA@			; `string'
PUBLIC	??_C@_0L@KPCNOBPE@ServerList?$AA@		; `string'
PUBLIC	??_C@_08MIFFGPAF@ChengHao?$AA@			; `string'
PUBLIC	??_C@_09IOBHABKN@GuangHuan?$AA@			; `string'
PUBLIC	??_C@_04GBLPADGB@PiFu?$AA@			; `string'
PUBLIC	??_C@_04PJOLNDGD@data?$AA@			; `string'
EXTRN	?luaopen_Win@@YAHPAUlua_State@@@Z:PROC		; luaopen_Win
EXTRN	?luaopen_Lssproto@@YAHPAUlua_State@@@Z:PROC	; luaopen_Lssproto
EXTRN	?luaopen_Sa@@YAHPAUlua_State@@@Z:PROC		; luaopen_Sa
EXTRN	?luaopen_ServerList@@YAHPAUlua_State@@@Z:PROC	; luaopen_ServerList
EXTRN	?luaopen_Data@@YAHPAUlua_State@@@Z:PROC		; luaopen_Data
EXTRN	?luaopen_ChenghaoList@@YAHPAUlua_State@@@Z:PROC	; luaopen_ChenghaoList
EXTRN	?luaopen_GuangHuanList@@YAHPAUlua_State@@@Z:PROC ; luaopen_GuangHuanList
EXTRN	?luaopen_PiFuList@@YAHPAUlua_State@@@Z:PROC	; luaopen_PiFuList
_BSS	SEGMENT
?ptActMenuWinLua@@3PAUaction@@A DD 01H DUP (?)		; ptActMenuWinLua
?MYLua@@3UtagMYLua@@A DB 0cH DUP (?)			; MYLua
_BSS	ENDS
;	COMDAT ??_C@_04PJOLNDGD@data?$AA@
CONST	SEGMENT
??_C@_04PJOLNDGD@data?$AA@ DB 'data', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GBLPADGB@PiFu?$AA@
CONST	SEGMENT
??_C@_04GBLPADGB@PiFu?$AA@ DB 'PiFu', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09IOBHABKN@GuangHuan?$AA@
CONST	SEGMENT
??_C@_09IOBHABKN@GuangHuan?$AA@ DB 'GuangHuan', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MIFFGPAF@ChengHao?$AA@
CONST	SEGMENT
??_C@_08MIFFGPAF@ChengHao?$AA@ DB 'ChengHao', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KPCNOBPE@ServerList?$AA@
CONST	SEGMENT
??_C@_0L@KPCNOBPE@ServerList?$AA@ DB 'ServerList', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02CKOPKKAC@sa?$AA@
CONST	SEGMENT
??_C@_02CKOPKKAC@sa?$AA@ DB 'sa', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08GBGCLPL@lssproto?$AA@
CONST	SEGMENT
??_C@_08GBGCLPL@lssproto?$AA@ DB 'lssproto', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03DEBJKBHO@Win?$AA@
CONST	SEGMENT
??_C@_03DEBJKBHO@Win?$AA@ DB 'Win', 00H			; `string'
CONST	ENDS
CONST	SEGMENT
?lualibs@@3QBUluaL_Reg@@B DD FLAT:??_C@_03DEBJKBHO@Win?$AA@ ; lualibs
	DD	FLAT:?luaopen_Win@@YAHPAUlua_State@@@Z
	DD	FLAT:??_C@_08GBGCLPL@lssproto?$AA@
	DD	FLAT:?luaopen_Lssproto@@YAHPAUlua_State@@@Z
	DD	FLAT:??_C@_02CKOPKKAC@sa?$AA@
	DD	FLAT:?luaopen_Sa@@YAHPAUlua_State@@@Z
	DD	FLAT:??_C@_0L@KPCNOBPE@ServerList?$AA@
	DD	FLAT:?luaopen_ServerList@@YAHPAUlua_State@@@Z
	DD	FLAT:??_C@_08MIFFGPAF@ChengHao?$AA@
	DD	FLAT:?luaopen_ChenghaoList@@YAHPAUlua_State@@@Z
	DD	FLAT:??_C@_09IOBHABKN@GuangHuan?$AA@
	DD	FLAT:?luaopen_GuangHuanList@@YAHPAUlua_State@@@Z
	DD	FLAT:??_C@_04GBLPADGB@PiFu?$AA@
	DD	FLAT:?luaopen_PiFuList@@YAHPAUlua_State@@@Z
	DD	FLAT:??_C@_04PJOLNDGD@data?$AA@
	DD	FLAT:?luaopen_Data@@YAHPAUlua_State@@@Z
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ??_C@_03IBJHJIAF@lua?$AA@
CONST	SEGMENT
??_C@_03IBJHJIAF@lua?$AA@ DB 'lua', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
?progname@@3PBDB DD FLAT:??_C@_03IBJHJIAF@lua?$AA@	; progname
_DATA	ENDS
PUBLIC	?strstr@@YAPADQADQBD@Z				; strstr
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_printf
PUBLIC	__vsprintf_s_l
PUBLIC	_vsprintf_s
PUBLIC	?myluaload@@YAHPAD@Z				; myluaload
PUBLIC	?remyluaload@@YAHPAD@Z				; remyluaload
PUBLIC	?LoadStoneAgeLUA@@YAXPAD@Z			; LoadStoneAgeLUA
PUBLIC	?closemyluaload@@YAHXZ				; closemyluaload
PUBLIC	?dofile@@YAHPAUlua_State@@PBD@Z			; dofile
PUBLIC	?docall@@YAHPAUlua_State@@HH@Z			; docall
PUBLIC	?getArrayInt@@YAHPAUlua_State@@H@Z		; getArrayInt
PUBLIC	?luaAB_openlibs@@YAXPAUlua_State@@@Z		; luaAB_openlibs
PUBLIC	?FindLua@@YAPAUlua_State@@PAD@Z			; FindLua
PUBLIC	?FindWinIntLua@@YAPAUlua_State@@HPAD@Z		; FindWinIntLua
PUBLIC	?FreeCreateWinTypeLua@@YAPAUaction@@PAUlua_State@@@Z ; FreeCreateWinTypeLua
PUBLIC	?FreeServerWinTypeLua@@YAPAUaction@@PAUlua_State@@@Z ; FreeServerWinTypeLua
PUBLIC	?ReLoadStoneAgeLUA@@YAXPAD@Z			; ReLoadStoneAgeLUA
PUBLIC	?FreeGetBattleMap@@YAHH@Z			; FreeGetBattleMap
PUBLIC	??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ		; sprintf_s<256>
PUBLIC	?decryptLUA@@YAHPAUlua_State@@PAD@Z		; decryptLUA
PUBLIC	?decryptLUA2@@YAHPAUlua_State@@PAD@Z		; decryptLUA2
PUBLIC	?NewLoadStoneAgeLUA@@YAXPAD@Z			; NewLoadStoneAgeLUA
PUBLIC	??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const *>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_09KBLMODGM@?4?1?1salua1?$AA@		; `string'
PUBLIC	??_C@_0BA@IALLELID@?$CFs?1?1win?1?1?$CFd?4lua?$AA@ ; `string'
PUBLIC	??_C@_0L@MBJJKKFJ@WindowInit?$AA@		; `string'
PUBLIC	??_C@_0O@OFCFMCFI@CreateWinType?$AA@		; `string'
PUBLIC	??_C@_0CJ@EGHDEEMJ@?l?$PN?O?$KC?$KD?$LKFreeCreateWinTypeLua?5?$DP?$DP?$DP?i?$LL@ ; `string'
PUBLIC	??_C@_0BB@ELCOHPIG@ServerWindowType?$AA@	; `string'
PUBLIC	??_C@_0CJ@EEFCGKJC@?l?$PN?O?$KC?$KD?$LKFreeServerWinTypeLua?5?$DP?$DP?$DP?i?$LL@ ; `string'
PUBLIC	??_C@_04PFAOODAA@?$CFs?3?5?$AA@			; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6?$AA@			; `string'
PUBLIC	??_C@_0BP@LIDEPBBI@?$CIerror?5object?5is?5not?5a?5string?$CJ?$AA@ ; `string'
PUBLIC	??_C@_05GFCDIDHO@debug?$AA@			; `string'
PUBLIC	??_C@_09GPFEECNC@traceback?$AA@			; `string'
PUBLIC	??_C@_0BL@FFJEDJPI@?l?$PN?O?$KC?$KD?$LKdocall?5?$DP?$DP?$DP?i?$LL?3?$CFd?$CI?$CFs?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	?__LINE__Var@?0??myluaload@@YAHPAD@Z@4JA	; `myluaload'::`1'::__LINE__Var
PUBLIC	??_C@_0GD@LLKGLPLG@c?3?2users?2administrator?2desktop?2?$LN@ ; `string'
PUBLIC	??_C@_0BN@MOHPFDBB@?Y?$PO?K?l?$KD?$LK?$CFs?5?$DP?$DP?p?$KL?c?F?$KD?$LK?$CFs?5?z?$LM?$DP?$KD?$LK?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_04GHJNJNPO@main?$AA@			; `string'
PUBLIC	??_C@_03ILJCGOLJ@?6?$CFs?$AA@			; `string'
PUBLIC	??_C@_01KMDKNFGN@?1?$AA@			; `string'
PUBLIC	??_C@_03EMIMMIHL@?$CK?4?$CK?$AA@		; `string'
PUBLIC	??_C@_06PDPEOAFG@?$CFs?1?1?$CFs?$AA@		; `string'
PUBLIC	??_C@_04BIAACBGB@?4lua?$AA@			; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_0BH@EIPJDOPB@?$CFs?1?1map?1?1battlemap?4lua?$AA@ ; `string'
PUBLIC	??_C@_0BB@BDENLLEH@FreeGetBattleMap?$AA@	; `string'
PUBLIC	??_C@_0BN@LFGCKIJG@FreeGetBattleMap?5?$DP?$DP?$DP?i?$LL?5?$CI?$CFs?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_0CF@OPCDIGNC@?l?$PN?O?$KC?$KD?$LKFreeGetBattleMap?5?$DP?$DP?$DP?i?$LL?3?$CFd?$CI@ ; `string'
EXTRN	??2@YAPAXIHPBDH@Z:PROC				; operator new
EXTRN	??_U@YAPAXIHPBDH@Z:PROC				; operator new[]
EXTRN	_memset:PROC
EXTRN	__imp__strstr:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__FindClose@4:PROC
EXTRN	__imp__FindFirstFileA@8:PROC
EXTRN	__imp__FindNextFileA@8:PROC
EXTRN	__imp__lstrcpyA@8:PROC
EXTRN	__imp__lstrcatA@8:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fopen_s:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fflush:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp__fseek:PROC
EXTRN	__imp__ftell:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf_s:PROC
EXTRN	_lua_close:PROC
EXTRN	_lua_gettop:PROC
EXTRN	_lua_settop:PROC
EXTRN	_lua_pushvalue:PROC
EXTRN	_lua_remove:PROC
EXTRN	_lua_insert:PROC
EXTRN	_lua_isnumber:PROC
EXTRN	_lua_isstring:PROC
EXTRN	_lua_type:PROC
EXTRN	_lua_tonumber:PROC
EXTRN	_lua_tolstring:PROC
EXTRN	_lua_pushnumber:PROC
EXTRN	_lua_pushinteger:PROC
EXTRN	_lua_pushstring:PROC
EXTRN	_lua_pushcclosure:PROC
EXTRN	_lua_gettable:PROC
EXTRN	_lua_getfield:PROC
EXTRN	_lua_call:PROC
EXTRN	_lua_pcall:PROC
EXTRN	_lua_gc:PROC
EXTRN	_luaL_loadfile:PROC
EXTRN	_luaL_loadstring:PROC
EXTRN	_luaL_newstate:PROC
EXTRN	_luaL_openlibs:PROC
EXTRN	?strcmptail@@YAHPAD0@Z:PROC			; strcmptail
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CF@OPCDIGNC@?l?$PN?O?$KC?$KD?$LKFreeGetBattleMap?5?$DP?$DP?$DP?i?$LL?3?$CFd?$CI@
CONST	SEGMENT
??_C@_0CF@OPCDIGNC@?l?$PN?O?$KC?$KD?$LKFreeGetBattleMap?5?$DP?$DP?$DP?i?$LL?3?$CFd?$CI@ DB 0ecH
	DB	0fdH, 0cfH, 0a2H, 0a3H, 0baH, 'FreeGetBattleMap ???', 0e9H, 0bbH
	DB	':%d(%s)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LFGCKIJG@FreeGetBattleMap?5?$DP?$DP?$DP?i?$LL?5?$CI?$CFs?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BN@LFGCKIJG@FreeGetBattleMap?5?$DP?$DP?$DP?i?$LL?5?$CI?$CFs?$CJ?6?$AA@ DB 'F'
	DB	'reeGetBattleMap ???', 0e9H, 0bbH, ' (%s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BDENLLEH@FreeGetBattleMap?$AA@
CONST	SEGMENT
??_C@_0BB@BDENLLEH@FreeGetBattleMap?$AA@ DB 'FreeGetBattleMap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EIPJDOPB@?$CFs?1?1map?1?1battlemap?4lua?$AA@
CONST	SEGMENT
??_C@_0BH@EIPJDOPB@?$CFs?1?1map?1?1battlemap?4lua?$AA@ DB '%s//map//battl'
	DB	'emap.lua', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BIAACBGB@?4lua?$AA@
CONST	SEGMENT
??_C@_04BIAACBGB@?4lua?$AA@ DB '.lua', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PDPEOAFG@?$CFs?1?1?$CFs?$AA@
CONST	SEGMENT
??_C@_06PDPEOAFG@?$CFs?1?1?$CFs?$AA@ DB '%s//%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03EMIMMIHL@?$CK?4?$CK?$AA@
CONST	SEGMENT
??_C@_03EMIMMIHL@?$CK?4?$CK?$AA@ DB '*.*', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1?$AA@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1?$AA@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ILJCGOLJ@?6?$CFs?$AA@
CONST	SEGMENT
??_C@_03ILJCGOLJ@?6?$CFs?$AA@ DB 0aH, '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GHJNJNPO@main?$AA@
CONST	SEGMENT
??_C@_04GHJNJNPO@main?$AA@ DB 'main', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MOHPFDBB@?Y?$PO?K?l?$KD?$LK?$CFs?5?$DP?$DP?p?$KL?c?F?$KD?$LK?$CFs?5?z?$LM?$DP?$KD?$LK?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BN@MOHPFDBB@?Y?$PO?K?l?$KD?$LK?$CFs?5?$DP?$DP?p?$KL?c?F?$KD?$LK?$CFs?5?z?$LM?$DP?$KD?$LK?$CFd?6?$AA@ DB 0d9H
	DB	0feH, 0cbH, 0ecH, 0a3H, 0baH, '%s ??', 0f0H, 0abH, 0e3H, 0c6H, 0a3H
	DB	0baH, '%s ', 0faH, 0bcH, '?', 0a3H, 0baH, '%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GD@LLKGLPLG@c?3?2users?2administrator?2desktop?2?$LN@
CONST	SEGMENT
??_C@_0GD@LLKGLPLG@c?3?2users?2administrator?2desktop?2?$LN@ DB 'c:\users'
	DB	'\administrator\desktop\', 0bdH, 0baH, 0c5H, 0e6H, 0bfH, 0a1H, 0c0H
	DB	0ccH, 0c1H, 0f6H, ' ', 0c0H, 0daH, 0b7H, 0e1H, '\', 0c5H, 0acH
	DB	0b6H, 0f3H, 0c0H, 0ccH, 0beH, 0f0H, 0c6H, 0aeH, ' ', 0c0H, 0daH
	DB	0b7H, 0e1H, '\client source code\mylua\winlua.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??myluaload@@YAHPAD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??myluaload@@YAHPAD@Z@4JA DD 0f2H	; `myluaload'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FFJEDJPI@?l?$PN?O?$KC?$KD?$LKdocall?5?$DP?$DP?$DP?i?$LL?3?$CFd?$CI?$CFs?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BL@FFJEDJPI@?l?$PN?O?$KC?$KD?$LKdocall?5?$DP?$DP?$DP?i?$LL?3?$CFd?$CI?$CFs?$CJ?6?$AA@ DB 0ecH
	DB	0fdH, 0cfH, 0a2H, 0a3H, 0baH, 'docall ???', 0e9H, 0bbH, ':%d(%'
	DB	's)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09GPFEECNC@traceback?$AA@
CONST	SEGMENT
??_C@_09GPFEECNC@traceback?$AA@ DB 'traceback', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFCDIDHO@debug?$AA@
CONST	SEGMENT
??_C@_05GFCDIDHO@debug?$AA@ DB 'debug', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LIDEPBBI@?$CIerror?5object?5is?5not?5a?5string?$CJ?$AA@
CONST	SEGMENT
??_C@_0BP@LIDEPBBI@?$CIerror?5object?5is?5not?5a?5string?$CJ?$AA@ DB '(er'
	DB	'ror object is not a string)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6?$AA@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PFAOODAA@?$CFs?3?5?$AA@
CONST	SEGMENT
??_C@_04PFAOODAA@?$CFs?3?5?$AA@ DB '%s: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@EEFCGKJC@?l?$PN?O?$KC?$KD?$LKFreeServerWinTypeLua?5?$DP?$DP?$DP?i?$LL@
CONST	SEGMENT
??_C@_0CJ@EEFCGKJC@?l?$PN?O?$KC?$KD?$LKFreeServerWinTypeLua?5?$DP?$DP?$DP?i?$LL@ DB 0ecH
	DB	0fdH, 0cfH, 0a2H, 0a3H, 0baH, 'FreeServerWinTypeLua ???', 0e9H
	DB	0bbH, ':%d(%s)', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ELCOHPIG@ServerWindowType?$AA@
CONST	SEGMENT
??_C@_0BB@ELCOHPIG@ServerWindowType?$AA@ DB 'ServerWindowType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@EGHDEEMJ@?l?$PN?O?$KC?$KD?$LKFreeCreateWinTypeLua?5?$DP?$DP?$DP?i?$LL@
CONST	SEGMENT
??_C@_0CJ@EGHDEEMJ@?l?$PN?O?$KC?$KD?$LKFreeCreateWinTypeLua?5?$DP?$DP?$DP?i?$LL@ DB 0ecH
	DB	0fdH, 0cfH, 0a2H, 0a3H, 0baH, 'FreeCreateWinTypeLua ???', 0e9H
	DB	0bbH, ':%d(%s)', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OFCFMCFI@CreateWinType?$AA@
CONST	SEGMENT
??_C@_0O@OFCFMCFI@CreateWinType?$AA@ DB 'CreateWinType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MBJJKKFJ@WindowInit?$AA@
CONST	SEGMENT
??_C@_0L@MBJJKKFJ@WindowInit?$AA@ DB 'WindowInit', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IALLELID@?$CFs?1?1win?1?1?$CFd?4lua?$AA@
CONST	SEGMENT
??_C@_0BA@IALLELID@?$CFs?1?1win?1?1?$CFd?4lua?$AA@ DB '%s//win//%d.lua', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KBLMODGM@?4?1?1salua1?$AA@
CONST	SEGMENT
??_C@_09KBLMODGM@?4?1?1salua1?$AA@ DB './/salua1', 00H	; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const *>, COMDAT

; 144  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\mylua\winlua.cpp
;	COMDAT ?NewLoadStoneAgeLUA@@YAXPAD@Z
_TEXT	SEGMENT
_token$ = -264						; size = 256
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
?NewLoadStoneAgeLUA@@YAXPAD@Z PROC			; NewLoadStoneAgeLUA, COMDAT

; 370  : void NewLoadStoneAgeLUA(char *filename){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 01 00
	00		 sub	 esp, 460		; 000001ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-460]
  00012	b9 73 00 00 00	 mov	 ecx, 115		; 00000073H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 371  : 	char token[256];
; 372  : 	if(strlen(filename)>0){

  00028	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _strlen
  00031	83 c4 04	 add	 esp, 4
  00034	85 c0		 test	 eax, eax
  00036	76 2e		 jbe	 SHORT $LN2@NewLoadSto

; 373  : 		sprintf_s(token, "%s//%s", _LUA_PATCH_,filename);

  00038	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0003b	50		 push	 eax
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_09KBLMODGM@?4?1?1salua1?$AA@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_06PDPEOAFG@?$CFs?1?1?$CFs?$AA@
  00046	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _token$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ; sprintf_s<256>
  00052	83 c4 10	 add	 esp, 16			; 00000010H

; 374  : 		myluaload(token);

  00055	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _token$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ?myluaload@@YAHPAD@Z	; myluaload
  00061	83 c4 04	 add	 esp, 4

; 375  : 	}else{

  00064	eb 0d		 jmp	 SHORT $LN1@NewLoadSto
$LN2@NewLoadSto:

; 376  : 		LoadStoneAgeLUA(_LUA_PATCH_);

  00066	68 00 00 00 00	 push	 OFFSET ??_C@_09KBLMODGM@?4?1?1salua1?$AA@
  0006b	e8 00 00 00 00	 call	 ?LoadStoneAgeLUA@@YAXPAD@Z ; LoadStoneAgeLUA
  00070	83 c4 04	 add	 esp, 4
$LN1@NewLoadSto:

; 377  : 	}
; 378  : }

  00073	52		 push	 edx
  00074	8b cd		 mov	 ecx, ebp
  00076	50		 push	 eax
  00077	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@NewLoadSto
  0007d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00082	58		 pop	 eax
  00083	5a		 pop	 edx
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008a	33 cd		 xor	 ecx, ebp
  0008c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00091	81 c4 cc 01 00
	00		 add	 esp, 460		; 000001ccH
  00097	3b ec		 cmp	 ebp, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
  000a2	66 90		 npad	 2
$LN7@NewLoadSto:
  000a4	01 00 00 00	 DD	 1
  000a8	00 00 00 00	 DD	 $LN6@NewLoadSto
$LN6@NewLoadSto:
  000ac	f8 fe ff ff	 DD	 -264			; fffffef8H
  000b0	00 01 00 00	 DD	 256			; 00000100H
  000b4	00 00 00 00	 DD	 $LN5@NewLoadSto
$LN5@NewLoadSto:
  000b8	74		 DB	 116			; 00000074H
  000b9	6f		 DB	 111			; 0000006fH
  000ba	6b		 DB	 107			; 0000006bH
  000bb	65		 DB	 101			; 00000065H
  000bc	6e		 DB	 110			; 0000006eH
  000bd	00		 DB	 0
?NewLoadStoneAgeLUA@@YAXPAD@Z ENDP			; NewLoadStoneAgeLUA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\mylua\winlua.cpp
;	COMDAT ?decryptLUA2@@YAHPAUlua_State@@PAD@Z
_TEXT	SEGMENT
tv133 = -512						; size = 4
_status$ = -312						; size = 4
_luabuff$ = -300					; size = 4
_luamaxlen$ = -288					; size = 4
_loadfilename$ = -276					; size = 256
_f$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_L$ = 8							; size = 4
_filename$ = 12						; size = 4
?decryptLUA2@@YAHPAUlua_State@@PAD@Z PROC		; decryptLUA2, COMDAT

; 212  : int decryptLUA2(lua_State *L, char *filename){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 02 00
	00		 sub	 esp, 512		; 00000200H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 00 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-512]
  00012	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 213  : 	FILE *f;
; 214  : 	char loadfilename[256];
; 215  : 	int luamaxlen = 0;

  00028	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _luamaxlen$[ebp], 0

; 216  : 	unsigned char *luabuff;
; 217  : 	strcpy(loadfilename, filename);

  00032	8b 45 0c	 mov	 eax, DWORD PTR _filename$[ebp]
  00035	50		 push	 eax
  00036	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _loadfilename$[ebp]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 _strcpy
  00042	83 c4 08	 add	 esp, 8

; 218  : 	fopen_s(&f,loadfilename,"rb");//打开补丁1

  00045	8b f4		 mov	 esi, esp
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  0004c	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _loadfilename$[ebp]
  00052	50		 push	 eax
  00053	8d 4d f4	 lea	 ecx, DWORD PTR _f$[ebp]
  00056	51		 push	 ecx
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen_s
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00060	3b f4		 cmp	 esi, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 219  : 	if (f!=NULL){

  00067	83 7d f4 00	 cmp	 DWORD PTR _f$[ebp], 0
  0006b	0f 84 bf 00 00
	00		 je	 $LN2@decryptLUA

; 220  : 		fseek(f,0,SEEK_END);

  00071	8b f4		 mov	 esi, esp
  00073	6a 02		 push	 2
  00075	6a 00		 push	 0
  00077	8b 45 f4	 mov	 eax, DWORD PTR _f$[ebp]
  0007a	50		 push	 eax
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH
  00084	3b f4		 cmp	 esi, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 221  : 		luamaxlen = ftell(f);

  0008b	8b f4		 mov	 esi, esp
  0008d	8b 45 f4	 mov	 eax, DWORD PTR _f$[ebp]
  00090	50		 push	 eax
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  00097	83 c4 04	 add	 esp, 4
  0009a	3b f4		 cmp	 esi, esp
  0009c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a1	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _luamaxlen$[ebp], eax

; 222  : 		luabuff = (unsigned char*)malloc(luamaxlen+1);

  000a7	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _luamaxlen$[ebp]
  000ad	83 c0 01	 add	 eax, 1
  000b0	8b f4		 mov	 esi, esp
  000b2	50		 push	 eax
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  000b9	83 c4 04	 add	 esp, 4
  000bc	3b f4		 cmp	 esi, esp
  000be	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c3	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _luabuff$[ebp], eax

; 223  : 		fseek(f,0,SEEK_SET);

  000c9	8b f4		 mov	 esi, esp
  000cb	6a 00		 push	 0
  000cd	6a 00		 push	 0
  000cf	8b 45 f4	 mov	 eax, DWORD PTR _f$[ebp]
  000d2	50		 push	 eax
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  000d9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000dc	3b f4		 cmp	 esi, esp
  000de	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 224  : 		fread(luabuff, 1, luamaxlen, f);

  000e3	8b f4		 mov	 esi, esp
  000e5	8b 45 f4	 mov	 eax, DWORD PTR _f$[ebp]
  000e8	50		 push	 eax
  000e9	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _luamaxlen$[ebp]
  000ef	51		 push	 ecx
  000f0	6a 01		 push	 1
  000f2	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _luabuff$[ebp]
  000f8	52		 push	 edx
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  000ff	83 c4 10	 add	 esp, 16			; 00000010H
  00102	3b f4		 cmp	 esi, esp
  00104	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 225  : 		fclose(f);

  00109	8b f4		 mov	 esi, esp
  0010b	8b 45 f4	 mov	 eax, DWORD PTR _f$[ebp]
  0010e	50		 push	 eax
  0010f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00115	83 c4 04	 add	 esp, 4
  00118	3b f4		 cmp	 esi, esp
  0011a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 226  : 		luabuff[luamaxlen]=0;

  0011f	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _luabuff$[ebp]
  00125	03 85 e0 fe ff
	ff		 add	 eax, DWORD PTR _luamaxlen$[ebp]
  0012b	c6 00 00	 mov	 BYTE PTR [eax], 0

; 227  : 	}else{

  0012e	eb 07		 jmp	 SHORT $LN3@decryptLUA
$LN2@decryptLUA:

; 228  : 		return -100;

  00130	b8 9c ff ff ff	 mov	 eax, -100		; ffffff9cH
  00135	eb 6e		 jmp	 SHORT $LN1@decryptLUA
$LN3@decryptLUA:

; 229  : 	}
; 230  : #ifdef _LUA加密
; 231  : VMProtectBegin("lua");
; 232  : 	TEA解密((long*)luabuff,(luamaxlen/4),(long *)_LUA_KEY_);
; 233  : VMProtectEnd();
; 234  : #endif
; 235  : 	int status = luaL_dostring(L,(const char *)luabuff);

  00137	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _luabuff$[ebp]
  0013d	50		 push	 eax
  0013e	8b 4d 08	 mov	 ecx, DWORD PTR _L$[ebp]
  00141	51		 push	 ecx
  00142	e8 00 00 00 00	 call	 _luaL_loadstring
  00147	83 c4 08	 add	 esp, 8
  0014a	85 c0		 test	 eax, eax
  0014c	75 22		 jne	 SHORT $LN5@decryptLUA
  0014e	6a 00		 push	 0
  00150	6a ff		 push	 -1
  00152	6a 00		 push	 0
  00154	8b 55 08	 mov	 edx, DWORD PTR _L$[ebp]
  00157	52		 push	 edx
  00158	e8 00 00 00 00	 call	 _lua_pcall
  0015d	83 c4 10	 add	 esp, 16			; 00000010H
  00160	85 c0		 test	 eax, eax
  00162	75 0c		 jne	 SHORT $LN5@decryptLUA
  00164	c7 85 00 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv133[ebp], 0
  0016e	eb 0a		 jmp	 SHORT $LN6@decryptLUA
$LN5@decryptLUA:
  00170	c7 85 00 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv133[ebp], 1
$LN6@decryptLUA:
  0017a	8b 85 00 fe ff
	ff		 mov	 eax, DWORD PTR tv133[ebp]
  00180	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _status$[ebp], eax

; 236  : 	free(luabuff);

  00186	8b f4		 mov	 esi, esp
  00188	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _luabuff$[ebp]
  0018e	50		 push	 eax
  0018f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00195	83 c4 04	 add	 esp, 4
  00198	3b f4		 cmp	 esi, esp
  0019a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 237  : 	return status;

  0019f	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _status$[ebp]
$LN1@decryptLUA:

; 238  : }

  001a5	52		 push	 edx
  001a6	8b cd		 mov	 ecx, ebp
  001a8	50		 push	 eax
  001a9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@decryptLUA
  001af	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001b4	58		 pop	 eax
  001b5	5a		 pop	 edx
  001b6	5f		 pop	 edi
  001b7	5e		 pop	 esi
  001b8	5b		 pop	 ebx
  001b9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bc	33 cd		 xor	 ecx, ebp
  001be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c3	81 c4 00 02 00
	00		 add	 esp, 512		; 00000200H
  001c9	3b ec		 cmp	 ebp, esp
  001cb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001d0	8b e5		 mov	 esp, ebp
  001d2	5d		 pop	 ebp
  001d3	c3		 ret	 0
$LN10@decryptLUA:
  001d4	02 00 00 00	 DD	 2
  001d8	00 00 00 00	 DD	 $LN9@decryptLUA
$LN9@decryptLUA:
  001dc	f4 ff ff ff	 DD	 -12			; fffffff4H
  001e0	04 00 00 00	 DD	 4
  001e4	00 00 00 00	 DD	 $LN7@decryptLUA
  001e8	ec fe ff ff	 DD	 -276			; fffffeecH
  001ec	00 01 00 00	 DD	 256			; 00000100H
  001f0	00 00 00 00	 DD	 $LN8@decryptLUA
$LN8@decryptLUA:
  001f4	6c		 DB	 108			; 0000006cH
  001f5	6f		 DB	 111			; 0000006fH
  001f6	61		 DB	 97			; 00000061H
  001f7	64		 DB	 100			; 00000064H
  001f8	66		 DB	 102			; 00000066H
  001f9	69		 DB	 105			; 00000069H
  001fa	6c		 DB	 108			; 0000006cH
  001fb	65		 DB	 101			; 00000065H
  001fc	6e		 DB	 110			; 0000006eH
  001fd	61		 DB	 97			; 00000061H
  001fe	6d		 DB	 109			; 0000006dH
  001ff	65		 DB	 101			; 00000065H
  00200	00		 DB	 0
$LN7@decryptLUA:
  00201	66		 DB	 102			; 00000066H
  00202	00		 DB	 0
?decryptLUA2@@YAHPAUlua_State@@PAD@Z ENDP		; decryptLUA2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\mylua\winlua.cpp
;	COMDAT ?decryptLUA@@YAHPAUlua_State@@PAD@Z
_TEXT	SEGMENT
tv133 = -512						; size = 4
_status$ = -312						; size = 4
_luabuff$ = -300					; size = 4
_luamaxlen$ = -288					; size = 4
_loadfilename$ = -276					; size = 256
_f$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_L$ = 8							; size = 4
_filename$ = 12						; size = 4
?decryptLUA@@YAHPAUlua_State@@PAD@Z PROC		; decryptLUA, COMDAT

; 184  : int decryptLUA(lua_State *L, char *filename){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 02 00
	00		 sub	 esp, 512		; 00000200H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 00 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-512]
  00012	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 185  : 	FILE *f;
; 186  : 	char loadfilename[256];
; 187  : 	int luamaxlen = 0;

  00028	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _luamaxlen$[ebp], 0

; 188  : 	unsigned char *luabuff;
; 189  : 	strcpy(loadfilename, filename);

  00032	8b 45 0c	 mov	 eax, DWORD PTR _filename$[ebp]
  00035	50		 push	 eax
  00036	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _loadfilename$[ebp]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 _strcpy
  00042	83 c4 08	 add	 esp, 8

; 190  : 	fopen_s(&f,loadfilename,"rb");//打开补丁1

  00045	8b f4		 mov	 esi, esp
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  0004c	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _loadfilename$[ebp]
  00052	50		 push	 eax
  00053	8d 4d f4	 lea	 ecx, DWORD PTR _f$[ebp]
  00056	51		 push	 ecx
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen_s
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00060	3b f4		 cmp	 esi, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 191  : 	if (f!=NULL){

  00067	83 7d f4 00	 cmp	 DWORD PTR _f$[ebp], 0
  0006b	0f 84 bf 00 00
	00		 je	 $LN2@decryptLUA

; 192  : 		fseek(f,0,SEEK_END);

  00071	8b f4		 mov	 esi, esp
  00073	6a 02		 push	 2
  00075	6a 00		 push	 0
  00077	8b 45 f4	 mov	 eax, DWORD PTR _f$[ebp]
  0007a	50		 push	 eax
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH
  00084	3b f4		 cmp	 esi, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 193  : 		luamaxlen = ftell(f);

  0008b	8b f4		 mov	 esi, esp
  0008d	8b 45 f4	 mov	 eax, DWORD PTR _f$[ebp]
  00090	50		 push	 eax
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  00097	83 c4 04	 add	 esp, 4
  0009a	3b f4		 cmp	 esi, esp
  0009c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a1	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _luamaxlen$[ebp], eax

; 194  : 		luabuff = (unsigned char*)malloc(luamaxlen+1);

  000a7	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _luamaxlen$[ebp]
  000ad	83 c0 01	 add	 eax, 1
  000b0	8b f4		 mov	 esi, esp
  000b2	50		 push	 eax
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  000b9	83 c4 04	 add	 esp, 4
  000bc	3b f4		 cmp	 esi, esp
  000be	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c3	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _luabuff$[ebp], eax

; 195  : 		fseek(f,0,SEEK_SET);

  000c9	8b f4		 mov	 esi, esp
  000cb	6a 00		 push	 0
  000cd	6a 00		 push	 0
  000cf	8b 45 f4	 mov	 eax, DWORD PTR _f$[ebp]
  000d2	50		 push	 eax
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  000d9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000dc	3b f4		 cmp	 esi, esp
  000de	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 196  : 		fread(luabuff, 1, luamaxlen, f);

  000e3	8b f4		 mov	 esi, esp
  000e5	8b 45 f4	 mov	 eax, DWORD PTR _f$[ebp]
  000e8	50		 push	 eax
  000e9	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _luamaxlen$[ebp]
  000ef	51		 push	 ecx
  000f0	6a 01		 push	 1
  000f2	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _luabuff$[ebp]
  000f8	52		 push	 edx
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  000ff	83 c4 10	 add	 esp, 16			; 00000010H
  00102	3b f4		 cmp	 esi, esp
  00104	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 197  : 		fclose(f);

  00109	8b f4		 mov	 esi, esp
  0010b	8b 45 f4	 mov	 eax, DWORD PTR _f$[ebp]
  0010e	50		 push	 eax
  0010f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00115	83 c4 04	 add	 esp, 4
  00118	3b f4		 cmp	 esi, esp
  0011a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 198  : 		luabuff[luamaxlen]=0;

  0011f	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _luabuff$[ebp]
  00125	03 85 e0 fe ff
	ff		 add	 eax, DWORD PTR _luamaxlen$[ebp]
  0012b	c6 00 00	 mov	 BYTE PTR [eax], 0

; 199  : 	}else{

  0012e	eb 07		 jmp	 SHORT $LN3@decryptLUA
$LN2@decryptLUA:

; 200  : 		return -100;

  00130	b8 9c ff ff ff	 mov	 eax, -100		; ffffff9cH
  00135	eb 6e		 jmp	 SHORT $LN1@decryptLUA
$LN3@decryptLUA:

; 201  : 	}
; 202  : #ifdef _LUA加密
; 203  : VMProtectBegin("lua");
; 204  : 	TEA解密((long*)luabuff,(luamaxlen/4),(long *)VMProtectDecryptStringA(_LUA_KEY_));
; 205  : VMProtectEnd();
; 206  : #endif
; 207  : 	int status = luaL_dostring(L,(const char *)luabuff);

  00137	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _luabuff$[ebp]
  0013d	50		 push	 eax
  0013e	8b 4d 08	 mov	 ecx, DWORD PTR _L$[ebp]
  00141	51		 push	 ecx
  00142	e8 00 00 00 00	 call	 _luaL_loadstring
  00147	83 c4 08	 add	 esp, 8
  0014a	85 c0		 test	 eax, eax
  0014c	75 22		 jne	 SHORT $LN5@decryptLUA
  0014e	6a 00		 push	 0
  00150	6a ff		 push	 -1
  00152	6a 00		 push	 0
  00154	8b 55 08	 mov	 edx, DWORD PTR _L$[ebp]
  00157	52		 push	 edx
  00158	e8 00 00 00 00	 call	 _lua_pcall
  0015d	83 c4 10	 add	 esp, 16			; 00000010H
  00160	85 c0		 test	 eax, eax
  00162	75 0c		 jne	 SHORT $LN5@decryptLUA
  00164	c7 85 00 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv133[ebp], 0
  0016e	eb 0a		 jmp	 SHORT $LN6@decryptLUA
$LN5@decryptLUA:
  00170	c7 85 00 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv133[ebp], 1
$LN6@decryptLUA:
  0017a	8b 85 00 fe ff
	ff		 mov	 eax, DWORD PTR tv133[ebp]
  00180	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _status$[ebp], eax

; 208  : 	free(luabuff);

  00186	8b f4		 mov	 esi, esp
  00188	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _luabuff$[ebp]
  0018e	50		 push	 eax
  0018f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00195	83 c4 04	 add	 esp, 4
  00198	3b f4		 cmp	 esi, esp
  0019a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 209  : 	return status;

  0019f	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _status$[ebp]
$LN1@decryptLUA:

; 210  : }

  001a5	52		 push	 edx
  001a6	8b cd		 mov	 ecx, ebp
  001a8	50		 push	 eax
  001a9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@decryptLUA
  001af	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001b4	58		 pop	 eax
  001b5	5a		 pop	 edx
  001b6	5f		 pop	 edi
  001b7	5e		 pop	 esi
  001b8	5b		 pop	 ebx
  001b9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bc	33 cd		 xor	 ecx, ebp
  001be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c3	81 c4 00 02 00
	00		 add	 esp, 512		; 00000200H
  001c9	3b ec		 cmp	 ebp, esp
  001cb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001d0	8b e5		 mov	 esp, ebp
  001d2	5d		 pop	 ebp
  001d3	c3		 ret	 0
$LN10@decryptLUA:
  001d4	02 00 00 00	 DD	 2
  001d8	00 00 00 00	 DD	 $LN9@decryptLUA
$LN9@decryptLUA:
  001dc	f4 ff ff ff	 DD	 -12			; fffffff4H
  001e0	04 00 00 00	 DD	 4
  001e4	00 00 00 00	 DD	 $LN7@decryptLUA
  001e8	ec fe ff ff	 DD	 -276			; fffffeecH
  001ec	00 01 00 00	 DD	 256			; 00000100H
  001f0	00 00 00 00	 DD	 $LN8@decryptLUA
$LN8@decryptLUA:
  001f4	6c		 DB	 108			; 0000006cH
  001f5	6f		 DB	 111			; 0000006fH
  001f6	61		 DB	 97			; 00000061H
  001f7	64		 DB	 100			; 00000064H
  001f8	66		 DB	 102			; 00000066H
  001f9	69		 DB	 105			; 00000069H
  001fa	6c		 DB	 108			; 0000006cH
  001fb	65		 DB	 101			; 00000065H
  001fc	6e		 DB	 110			; 0000006eH
  001fd	61		 DB	 97			; 00000061H
  001fe	6d		 DB	 109			; 0000006dH
  001ff	65		 DB	 101			; 00000065H
  00200	00		 DB	 0
$LN7@decryptLUA:
  00201	66		 DB	 102			; 00000066H
  00202	00		 DB	 0
?decryptLUA@@YAHPAUlua_State@@PAD@Z ENDP		; decryptLUA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\mylua\winlua.cpp
;	COMDAT ?traceback@@YAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?traceback@@YAHPAUlua_State@@@Z PROC			; traceback, COMDAT

; 142  : static int traceback (lua_State *L) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 143  :   if (!lua_isstring(L, 1))  /* 'message' not a string? */

  0001e	6a 01		 push	 1
  00020	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 _lua_isstring
  00029	83 c4 08	 add	 esp, 8
  0002c	85 c0		 test	 eax, eax
  0002e	75 0a		 jne	 SHORT $LN2@traceback

; 144  :     return 1;  /* keep it intact */

  00030	b8 01 00 00 00	 mov	 eax, 1
  00035	e9 aa 00 00 00	 jmp	 $LN1@traceback
$LN2@traceback:

; 145  :   lua_getfield(L, LUA_GLOBALSINDEX, "debug");

  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_05GFCDIDHO@debug?$AA@
  0003f	68 ee d8 ff ff	 push	 -10002			; ffffd8eeH
  00044	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _lua_getfield
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 146  :   if (!lua_istable(L, -1)) {

  00050	6a ff		 push	 -1
  00052	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 _lua_type
  0005b	83 c4 08	 add	 esp, 8
  0005e	83 f8 05	 cmp	 eax, 5
  00061	74 15		 je	 SHORT $LN3@traceback

; 147  :     lua_pop(L, 1);

  00063	6a fe		 push	 -2			; fffffffeH
  00065	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 _lua_settop
  0006e	83 c4 08	 add	 esp, 8

; 148  :     return 1;

  00071	b8 01 00 00 00	 mov	 eax, 1
  00076	eb 6c		 jmp	 SHORT $LN1@traceback
$LN3@traceback:

; 149  :   }
; 150  :   lua_getfield(L, -1, "traceback");

  00078	68 00 00 00 00	 push	 OFFSET ??_C@_09GPFEECNC@traceback?$AA@
  0007d	6a ff		 push	 -1
  0007f	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 _lua_getfield
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH

; 151  :   if (!lua_isfunction(L, -1)) {

  0008b	6a ff		 push	 -1
  0008d	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 _lua_type
  00096	83 c4 08	 add	 esp, 8
  00099	83 f8 06	 cmp	 eax, 6
  0009c	74 15		 je	 SHORT $LN4@traceback

; 152  :     lua_pop(L, 2);

  0009e	6a fd		 push	 -3			; fffffffdH
  000a0	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 _lua_settop
  000a9	83 c4 08	 add	 esp, 8

; 153  :     return 1;

  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	eb 31		 jmp	 SHORT $LN1@traceback
$LN4@traceback:

; 154  :   }
; 155  :   lua_pushvalue(L, 1);  /* pass error message */

  000b3	6a 01		 push	 1
  000b5	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 _lua_pushvalue
  000be	83 c4 08	 add	 esp, 8

; 156  :   lua_pushinteger(L, 2);  /* skip this function and traceback */

  000c1	6a 02		 push	 2
  000c3	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 _lua_pushinteger
  000cc	83 c4 08	 add	 esp, 8

; 157  :   lua_call(L, 2, 1);  /* call debug.traceback */

  000cf	6a 01		 push	 1
  000d1	6a 02		 push	 2
  000d3	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 _lua_call
  000dc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 158  :   return 1;

  000df	b8 01 00 00 00	 mov	 eax, 1
$LN1@traceback:

; 159  : }

  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx
  000e7	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000ed	3b ec		 cmp	 ebp, esp
  000ef	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
?traceback@@YAHPAUlua_State@@@Z ENDP			; traceback
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\mylua\winlua.cpp
;	COMDAT ?report@@YAHPAUlua_State@@H@Z
_TEXT	SEGMENT
_msg$1 = -8						; size = 4
_L$ = 8							; size = 4
_status$ = 12						; size = 4
?report@@YAHPAUlua_State@@H@Z PROC			; report, COMDAT

; 132  : static int report (lua_State *L, int status) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 133  :   if (status && !lua_isnil(L, -1)) {

  0001e	83 7d 0c 00	 cmp	 DWORD PTR _status$[ebp], 0
  00022	74 53		 je	 SHORT $LN2@report
  00024	6a ff		 push	 -1
  00026	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _lua_type
  0002f	83 c4 08	 add	 esp, 8
  00032	85 c0		 test	 eax, eax
  00034	74 41		 je	 SHORT $LN2@report

; 134  :     const char *msg = lua_tostring(L, -1);

  00036	6a 00		 push	 0
  00038	6a ff		 push	 -1
  0003a	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _lua_tolstring
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	89 45 f8	 mov	 DWORD PTR _msg$1[ebp], eax

; 135  :     if (msg == NULL) msg = "(error object is not a string)";

  00049	83 7d f8 00	 cmp	 DWORD PTR _msg$1[ebp], 0
  0004d	75 07		 jne	 SHORT $LN3@report
  0004f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _msg$1[ebp], OFFSET ??_C@_0BP@LIDEPBBI@?$CIerror?5object?5is?5not?5a?5string?$CJ?$AA@
$LN3@report:

; 136  :     l_message(progname, msg);

  00056	8b 45 f8	 mov	 eax, DWORD PTR _msg$1[ebp]
  00059	50		 push	 eax
  0005a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?progname@@3PBDB
  00060	51		 push	 ecx
  00061	e8 00 00 00 00	 call	 ?l_message@@YAXPBD0@Z	; l_message
  00066	83 c4 08	 add	 esp, 8

; 137  :     lua_pop(L, 1);

  00069	6a fe		 push	 -2			; fffffffeH
  0006b	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _lua_settop
  00074	83 c4 08	 add	 esp, 8
$LN2@report:

; 138  :   }
; 139  :   return status;

  00077	8b 45 0c	 mov	 eax, DWORD PTR _status$[ebp]

; 140  : }

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
?report@@YAHPAUlua_State@@H@Z ENDP			; report
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\mylua\winlua.cpp
;	COMDAT ?l_message@@YAXPBD0@Z
_TEXT	SEGMENT
_pname$ = 8						; size = 4
_msg$ = 12						; size = 4
?l_message@@YAXPBD0@Z PROC				; l_message, COMDAT

; 126  : static void l_message (const char *pname, const char *msg) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 127  :   if (pname) fprintf(stderr, "%s: ", pname);

  0001e	83 7d 08 00	 cmp	 DWORD PTR _pname$[ebp], 0
  00022	74 26		 je	 SHORT $LN2@l_message
  00024	8b 45 08	 mov	 eax, DWORD PTR _pname$[ebp]
  00027	50		 push	 eax
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_04PFAOODAA@?$CFs?3?5?$AA@
  0002d	8b f4		 mov	 esi, esp
  0002f	6a 02		 push	 2
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00037	83 c4 04	 add	 esp, 4
  0003a	3b f4		 cmp	 esi, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _fprintf
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@l_message:

; 128  :   fprintf(stderr, "%s\n", msg);

  0004a	8b 45 0c	 mov	 eax, DWORD PTR _msg$[ebp]
  0004d	50		 push	 eax
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  00053	8b f4		 mov	 esi, esp
  00055	6a 02		 push	 2
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0005d	83 c4 04	 add	 esp, 4
  00060	3b f4		 cmp	 esi, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 _fprintf
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 129  :   fflush(stderr);

  00070	8b f4		 mov	 esi, esp
  00072	6a 02		 push	 2
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0007a	83 c4 04	 add	 esp, 4
  0007d	3b f4		 cmp	 esi, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	8b f4		 mov	 esi, esp
  00086	50		 push	 eax
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush
  0008d	83 c4 04	 add	 esp, 4
  00090	3b f4		 cmp	 esi, esp
  00092	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 130  : }

  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	5b		 pop	 ebx
  0009a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000a0	3b ec		 cmp	 ebp, esp
  000a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
?l_message@@YAXPBD0@Z ENDP				; l_message
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ PROC		; sprintf_s<256>, COMDAT

; 1850 :     )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1846 : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(

  0001e	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const *>
  00023	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00026	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax
  00029	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00030	51		 push	 ecx
  00031	68 00 01 00 00	 push	 256			; 00000100H
  00036	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 _vsprintf_s
  0003f	83 c4 10	 add	 esp, 16			; 00000010H
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ENDP		; sprintf_s<256>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\mylua\winlua.cpp
;	COMDAT ?FreeGetBattleMap@@YAHH@Z
_TEXT	SEGMENT
_ret$ = -300						; size = 4
_TM_Ret$ = -288						; size = 4
_filename$1 = -276					; size = 256
_lua$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_floor$ = 8						; size = 4
?FreeGetBattleMap@@YAHH@Z PROC				; FreeGetBattleMap, COMDAT

; 397  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 01 00
	00		 sub	 esp, 496		; 000001f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-496]
  00012	b9 7c 00 00 00	 mov	 ecx, 124		; 0000007cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 398  : 	lua_State *lua = NULL;

  00028	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _lua$[ebp], 0

; 399  : 	if (lua == NULL){

  0002f	83 7d f4 00	 cmp	 DWORD PTR _lua$[ebp], 0
  00033	75 38		 jne	 SHORT $LN3@FreeGetBat

; 400  : 		char filename[256];
; 401  : #ifdef _LUA加密
; 402  : 		sprintf_s(filename, "%s//map//battlemap.sq",_LUA_PATCH_);
; 403  : #else
; 404  : 		sprintf_s(filename, "%s//map//battlemap.lua",_LUA_PATCH_);

  00035	68 00 00 00 00	 push	 OFFSET ??_C@_09KBLMODGM@?4?1?1salua1?$AA@
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@EIPJDOPB@?$CFs?1?1map?1?1battlemap?4lua?$AA@
  0003f	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _filename$1[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ; sprintf_s<256>
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 405  : #endif
; 406  : 		lua = FindLua(filename);

  0004e	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _filename$1[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?FindLua@@YAPAUlua_State@@PAD@Z ; FindLua
  0005a	83 c4 04	 add	 esp, 4
  0005d	89 45 f4	 mov	 DWORD PTR _lua$[ebp], eax

; 407  : 		if (lua == NULL)return NULL;

  00060	83 7d f4 00	 cmp	 DWORD PTR _lua$[ebp], 0
  00064	75 07		 jne	 SHORT $LN3@FreeGetBat
  00066	33 c0		 xor	 eax, eax
  00068	e9 10 01 00 00	 jmp	 $LN1@FreeGetBat
$LN3@FreeGetBat:

; 408  : 	}
; 409  : 	lua_getglobal(lua, "FreeGetBattleMap");

  0006d	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@BDENLLEH@FreeGetBattleMap?$AA@
  00072	68 ee d8 ff ff	 push	 -10002			; ffffd8eeH
  00077	8b 45 f4	 mov	 eax, DWORD PTR _lua$[ebp]
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _lua_getfield
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH

; 410  : 	if (!lua_isfunction(lua, -1)) {

  00083	6a ff		 push	 -1
  00085	8b 45 f4	 mov	 eax, DWORD PTR _lua$[ebp]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 _lua_type
  0008e	83 c4 08	 add	 esp, 8
  00091	83 f8 06	 cmp	 eax, 6
  00094	74 33		 je	 SHORT $LN4@FreeGetBat

; 411  : 		printf("FreeGetBattleMap 错误内容 (%s)\n", lua_tostring(lua, -1));

  00096	6a 00		 push	 0
  00098	6a ff		 push	 -1
  0009a	8b 45 f4	 mov	 eax, DWORD PTR _lua$[ebp]
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 _lua_tolstring
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a6	50		 push	 eax
  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@LFGCKIJG@FreeGetBattleMap?5?$DP?$DP?$DP?i?$LL?5?$CI?$CFs?$CJ?6?$AA@
  000ac	e8 00 00 00 00	 call	 _printf
  000b1	83 c4 08	 add	 esp, 8

; 412  : 		lua_pop(lua, 1);

  000b4	6a fe		 push	 -2			; fffffffeH
  000b6	8b 45 f4	 mov	 eax, DWORD PTR _lua$[ebp]
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 _lua_settop
  000bf	83 c4 08	 add	 esp, 8

; 413  : 		return NULL;

  000c2	33 c0		 xor	 eax, eax
  000c4	e9 b4 00 00 00	 jmp	 $LN1@FreeGetBat
$LN4@FreeGetBat:

; 414  : 	}
; 415  : 	lua_pushnumber(lua, floor); 

  000c9	f2 0f 2a 45 08	 cvtsi2sd xmm0, DWORD PTR _floor$[ebp]
  000ce	83 ec 08	 sub	 esp, 8
  000d1	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000d6	8b 45 f4	 mov	 eax, DWORD PTR _lua$[ebp]
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 _lua_pushnumber
  000df	83 c4 0c	 add	 esp, 12			; 0000000cH

; 416  : 	int TM_Ret = lua_pcall(lua, 1, 1, 0);

  000e2	6a 00		 push	 0
  000e4	6a 01		 push	 1
  000e6	6a 01		 push	 1
  000e8	8b 45 f4	 mov	 eax, DWORD PTR _lua$[ebp]
  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 _lua_pcall
  000f1	83 c4 10	 add	 esp, 16			; 00000010H
  000f4	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _TM_Ret$[ebp], eax

; 417  : 
; 418  : 	if (TM_Ret != 0){

  000fa	83 bd e0 fe ff
	ff 00		 cmp	 DWORD PTR _TM_Ret$[ebp], 0
  00101	74 37		 je	 SHORT $LN5@FreeGetBat

; 419  : 		printf("入口：FreeGetBattleMap 错误内容:%d(%s)\n", TM_Ret, lua_tostring(lua, -1));

  00103	6a 00		 push	 0
  00105	6a ff		 push	 -1
  00107	8b 45 f4	 mov	 eax, DWORD PTR _lua$[ebp]
  0010a	50		 push	 eax
  0010b	e8 00 00 00 00	 call	 _lua_tolstring
  00110	83 c4 0c	 add	 esp, 12			; 0000000cH
  00113	50		 push	 eax
  00114	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _TM_Ret$[ebp]
  0011a	51		 push	 ecx
  0011b	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@OPCDIGNC@?l?$PN?O?$KC?$KD?$LKFreeGetBattleMap?5?$DP?$DP?$DP?i?$LL?3?$CFd?$CI@
  00120	e8 00 00 00 00	 call	 _printf
  00125	83 c4 0c	 add	 esp, 12			; 0000000cH

; 420  : 		lua_pop(lua, 1);

  00128	6a fe		 push	 -2			; fffffffeH
  0012a	8b 45 f4	 mov	 eax, DWORD PTR _lua$[ebp]
  0012d	50		 push	 eax
  0012e	e8 00 00 00 00	 call	 _lua_settop
  00133	83 c4 08	 add	 esp, 8

; 421  : 		return NULL;

  00136	33 c0		 xor	 eax, eax
  00138	eb 43		 jmp	 SHORT $LN1@FreeGetBat
$LN5@FreeGetBat:

; 422  : 	}
; 423  : 	if (!lua_isnumber(lua, -1))

  0013a	6a ff		 push	 -1
  0013c	8b 45 f4	 mov	 eax, DWORD PTR _lua$[ebp]
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 _lua_isnumber
  00145	83 c4 08	 add	 esp, 8
  00148	85 c0		 test	 eax, eax
  0014a	75 04		 jne	 SHORT $LN6@FreeGetBat

; 424  : 		return NULL;

  0014c	33 c0		 xor	 eax, eax
  0014e	eb 2d		 jmp	 SHORT $LN1@FreeGetBat
$LN6@FreeGetBat:

; 425  : 	int ret = (int)lua_tonumber(lua, -1);

  00150	6a ff		 push	 -1
  00152	8b 45 f4	 mov	 eax, DWORD PTR _lua$[ebp]
  00155	50		 push	 eax
  00156	e8 00 00 00 00	 call	 _lua_tonumber
  0015b	83 c4 08	 add	 esp, 8
  0015e	e8 00 00 00 00	 call	 __ftol2_sse
  00163	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _ret$[ebp], eax

; 426  : 	lua_pop(lua, 1);

  00169	6a fe		 push	 -2			; fffffffeH
  0016b	8b 45 f4	 mov	 eax, DWORD PTR _lua$[ebp]
  0016e	50		 push	 eax
  0016f	e8 00 00 00 00	 call	 _lua_settop
  00174	83 c4 08	 add	 esp, 8

; 427  : 	return ret;

  00177	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _ret$[ebp]
$LN1@FreeGetBat:

; 428  : }

  0017d	52		 push	 edx
  0017e	8b cd		 mov	 ecx, ebp
  00180	50		 push	 eax
  00181	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@FreeGetBat
  00187	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0018c	58		 pop	 eax
  0018d	5a		 pop	 edx
  0018e	5f		 pop	 edi
  0018f	5e		 pop	 esi
  00190	5b		 pop	 ebx
  00191	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00194	33 cd		 xor	 ecx, ebp
  00196	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0019b	81 c4 f0 01 00
	00		 add	 esp, 496		; 000001f0H
  001a1	3b ec		 cmp	 ebp, esp
  001a3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a8	8b e5		 mov	 esp, ebp
  001aa	5d		 pop	 ebp
  001ab	c3		 ret	 0
$LN10@FreeGetBat:
  001ac	01 00 00 00	 DD	 1
  001b0	00 00 00 00	 DD	 $LN9@FreeGetBat
$LN9@FreeGetBat:
  001b4	ec fe ff ff	 DD	 -276			; fffffeecH
  001b8	00 01 00 00	 DD	 256			; 00000100H
  001bc	00 00 00 00	 DD	 $LN8@FreeGetBat
$LN8@FreeGetBat:
  001c0	66		 DB	 102			; 00000066H
  001c1	69		 DB	 105			; 00000069H
  001c2	6c		 DB	 108			; 0000006cH
  001c3	65		 DB	 101			; 00000065H
  001c4	6e		 DB	 110			; 0000006eH
  001c5	61		 DB	 97			; 00000061H
  001c6	6d		 DB	 109			; 0000006dH
  001c7	65		 DB	 101			; 00000065H
  001c8	00		 DB	 0
?FreeGetBattleMap@@YAHH@Z ENDP				; FreeGetBattleMap
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\mylua\winlua.cpp
;	COMDAT ?ReLoadStoneAgeLUA@@YAXPAD@Z
_TEXT	SEGMENT
_filename$ = 8						; size = 4
?ReLoadStoneAgeLUA@@YAXPAD@Z PROC			; ReLoadStoneAgeLUA, COMDAT

; 365  : void ReLoadStoneAgeLUA(char *filename){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 366  : 	//printf("\n%s",filename);
; 367  : 	remyluaload(filename);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?remyluaload@@YAHPAD@Z	; remyluaload
  00027	83 c4 04	 add	 esp, 4

; 368  : }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ReLoadStoneAgeLUA@@YAXPAD@Z ENDP			; ReLoadStoneAgeLUA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\mylua\winlua.cpp
;	COMDAT ?FreeServerWinTypeLua@@YAPAUaction@@PAUlua_State@@@Z
_TEXT	SEGMENT
_ret$ = -20						; size = 4
_TM_Ret$ = -8						; size = 4
_lua$ = 8						; size = 4
?FreeServerWinTypeLua@@YAPAUaction@@PAUlua_State@@@Z PROC ; FreeServerWinTypeLua, COMDAT

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 75   : 	if (lua == NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _lua$[ebp], 0
  00022	75 07		 jne	 SHORT $LN2@FreeServer

; 76   : 		return NULL;

  00024	33 c0		 xor	 eax, eax
  00026	e9 a2 00 00 00	 jmp	 $LN1@FreeServer
$LN2@FreeServer:

; 77   : 	}
; 78   : 	lua_getglobal(lua, "ServerWindowType");

  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@ELCOHPIG@ServerWindowType?$AA@
  00030	68 ee d8 ff ff	 push	 -10002			; ffffd8eeH
  00035	8b 45 08	 mov	 eax, DWORD PTR _lua$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _lua_getfield
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 79   : 	int TM_Ret = lua_pcall(lua, 0, 1, 0);

  00041	6a 00		 push	 0
  00043	6a 01		 push	 1
  00045	6a 00		 push	 0
  00047	8b 45 08	 mov	 eax, DWORD PTR _lua$[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 _lua_pcall
  00050	83 c4 10	 add	 esp, 16			; 00000010H
  00053	89 45 f8	 mov	 DWORD PTR _TM_Ret$[ebp], eax

; 80   : 
; 81   : 	if (TM_Ret != 0){

  00056	83 7d f8 00	 cmp	 DWORD PTR _TM_Ret$[ebp], 0
  0005a	74 34		 je	 SHORT $LN3@FreeServer

; 82   : 		printf("入口：FreeServerWinTypeLua 错误内容:%d(%s)\n", TM_Ret, lua_tostring(lua, -1));

  0005c	6a 00		 push	 0
  0005e	6a ff		 push	 -1
  00060	8b 45 08	 mov	 eax, DWORD PTR _lua$[ebp]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _lua_tolstring
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006c	50		 push	 eax
  0006d	8b 4d f8	 mov	 ecx, DWORD PTR _TM_Ret$[ebp]
  00070	51		 push	 ecx
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@EEFCGKJC@?l?$PN?O?$KC?$KD?$LKFreeServerWinTypeLua?5?$DP?$DP?$DP?i?$LL@
  00076	e8 00 00 00 00	 call	 _printf
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 83   : 		lua_pop(lua, 1);

  0007e	6a fe		 push	 -2			; fffffffeH
  00080	8b 45 08	 mov	 eax, DWORD PTR _lua$[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 _lua_settop
  00089	83 c4 08	 add	 esp, 8

; 84   : 		return NULL;

  0008c	33 c0		 xor	 eax, eax
  0008e	eb 3d		 jmp	 SHORT $LN1@FreeServer
$LN3@FreeServer:

; 85   : 	}
; 86   : 	if (!lua_isnumber(lua, -1))

  00090	6a ff		 push	 -1
  00092	8b 45 08	 mov	 eax, DWORD PTR _lua$[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 _lua_isnumber
  0009b	83 c4 08	 add	 esp, 8
  0009e	85 c0		 test	 eax, eax
  000a0	75 04		 jne	 SHORT $LN4@FreeServer

; 87   : 		return NULL;

  000a2	33 c0		 xor	 eax, eax
  000a4	eb 27		 jmp	 SHORT $LN1@FreeServer
$LN4@FreeServer:

; 88   : 	int ret = (int)lua_tonumber(lua, -1);

  000a6	6a ff		 push	 -1
  000a8	8b 45 08	 mov	 eax, DWORD PTR _lua$[ebp]
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _lua_tonumber
  000b1	83 c4 08	 add	 esp, 8
  000b4	e8 00 00 00 00	 call	 __ftol2_sse
  000b9	89 45 ec	 mov	 DWORD PTR _ret$[ebp], eax

; 89   : 	lua_pop(lua, 1);

  000bc	6a fe		 push	 -2			; fffffffeH
  000be	8b 45 08	 mov	 eax, DWORD PTR _lua$[ebp]
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 _lua_settop
  000c7	83 c4 08	 add	 esp, 8

; 90   : 	return (ACTION *)ret;

  000ca	8b 45 ec	 mov	 eax, DWORD PTR _ret$[ebp]
$LN1@FreeServer:

; 91   : }

  000cd	5f		 pop	 edi
  000ce	5e		 pop	 esi
  000cf	5b		 pop	 ebx
  000d0	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000d6	3b ec		 cmp	 ebp, esp
  000d8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
?FreeServerWinTypeLua@@YAPAUaction@@PAUlua_State@@@Z ENDP ; FreeServerWinTypeLua
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\mylua\winlua.cpp
;	COMDAT ?FreeCreateWinTypeLua@@YAPAUaction@@PAUlua_State@@@Z
_TEXT	SEGMENT
_ret$ = -20						; size = 4
_TM_Ret$ = -8						; size = 4
_lua$ = 8						; size = 4
?FreeCreateWinTypeLua@@YAPAUaction@@PAUlua_State@@@Z PROC ; FreeCreateWinTypeLua, COMDAT

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 46   : 	if (lua == NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _lua$[ebp], 0
  00022	75 07		 jne	 SHORT $LN2@FreeCreate

; 47   : 		return NULL;

  00024	33 c0		 xor	 eax, eax
  00026	e9 ca 00 00 00	 jmp	 $LN1@FreeCreate
$LN2@FreeCreate:

; 48   : 	}
; 49   : 
; 50   : 	lua_getglobal(lua, "CreateWinType");

  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@OFCFMCFI@CreateWinType?$AA@
  00030	68 ee d8 ff ff	 push	 -10002			; ffffd8eeH
  00035	8b 45 08	 mov	 eax, DWORD PTR _lua$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _lua_getfield
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 
; 52   : 	if (!lua_isfunction(lua, -1)) {

  00041	6a ff		 push	 -1
  00043	8b 45 08	 mov	 eax, DWORD PTR _lua$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _lua_type
  0004c	83 c4 08	 add	 esp, 8
  0004f	83 f8 06	 cmp	 eax, 6
  00052	74 15		 je	 SHORT $LN3@FreeCreate

; 53   : 		lua_pop(lua, 1);

  00054	6a fe		 push	 -2			; fffffffeH
  00056	8b 45 08	 mov	 eax, DWORD PTR _lua$[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 _lua_settop
  0005f	83 c4 08	 add	 esp, 8

; 54   : 		return NULL;

  00062	33 c0		 xor	 eax, eax
  00064	e9 8c 00 00 00	 jmp	 $LN1@FreeCreate
$LN3@FreeCreate:

; 55   : 	}
; 56   : 
; 57   : 	int TM_Ret = lua_pcall(lua, 0, 1, 0);

  00069	6a 00		 push	 0
  0006b	6a 01		 push	 1
  0006d	6a 00		 push	 0
  0006f	8b 45 08	 mov	 eax, DWORD PTR _lua$[ebp]
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 _lua_pcall
  00078	83 c4 10	 add	 esp, 16			; 00000010H
  0007b	89 45 f8	 mov	 DWORD PTR _TM_Ret$[ebp], eax

; 58   : 
; 59   : 	if (TM_Ret != 0){

  0007e	83 7d f8 00	 cmp	 DWORD PTR _TM_Ret$[ebp], 0
  00082	74 34		 je	 SHORT $LN4@FreeCreate

; 60   : 		printf("入口：FreeCreateWinTypeLua 错误内容:%d(%s)\n", TM_Ret, lua_tostring(lua, -1));

  00084	6a 00		 push	 0
  00086	6a ff		 push	 -1
  00088	8b 45 08	 mov	 eax, DWORD PTR _lua$[ebp]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _lua_tolstring
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH
  00094	50		 push	 eax
  00095	8b 4d f8	 mov	 ecx, DWORD PTR _TM_Ret$[ebp]
  00098	51		 push	 ecx
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@EGHDEEMJ@?l?$PN?O?$KC?$KD?$LKFreeCreateWinTypeLua?5?$DP?$DP?$DP?i?$LL@
  0009e	e8 00 00 00 00	 call	 _printf
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 61   : 		lua_pop(lua, 1);

  000a6	6a fe		 push	 -2			; fffffffeH
  000a8	8b 45 08	 mov	 eax, DWORD PTR _lua$[ebp]
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _lua_settop
  000b1	83 c4 08	 add	 esp, 8

; 62   : 		return NULL;

  000b4	33 c0		 xor	 eax, eax
  000b6	eb 3d		 jmp	 SHORT $LN1@FreeCreate
$LN4@FreeCreate:

; 63   : 	}
; 64   : 
; 65   : 	if (!lua_isnumber(lua, -1))

  000b8	6a ff		 push	 -1
  000ba	8b 45 08	 mov	 eax, DWORD PTR _lua$[ebp]
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 _lua_isnumber
  000c3	83 c4 08	 add	 esp, 8
  000c6	85 c0		 test	 eax, eax
  000c8	75 04		 jne	 SHORT $LN5@FreeCreate

; 66   : 		return NULL;

  000ca	33 c0		 xor	 eax, eax
  000cc	eb 27		 jmp	 SHORT $LN1@FreeCreate
$LN5@FreeCreate:

; 67   : 
; 68   : 	int ret = (int)lua_tonumber(lua, -1);

  000ce	6a ff		 push	 -1
  000d0	8b 45 08	 mov	 eax, DWORD PTR _lua$[ebp]
  000d3	50		 push	 eax
  000d4	e8 00 00 00 00	 call	 _lua_tonumber
  000d9	83 c4 08	 add	 esp, 8
  000dc	e8 00 00 00 00	 call	 __ftol2_sse
  000e1	89 45 ec	 mov	 DWORD PTR _ret$[ebp], eax

; 69   : 	lua_pop(lua, 1);

  000e4	6a fe		 push	 -2			; fffffffeH
  000e6	8b 45 08	 mov	 eax, DWORD PTR _lua$[ebp]
  000e9	50		 push	 eax
  000ea	e8 00 00 00 00	 call	 _lua_settop
  000ef	83 c4 08	 add	 esp, 8

; 70   : 	return (ACTION *)ret;

  000f2	8b 45 ec	 mov	 eax, DWORD PTR _ret$[ebp]
$LN1@FreeCreate:

; 71   : }

  000f5	5f		 pop	 edi
  000f6	5e		 pop	 esi
  000f7	5b		 pop	 ebx
  000f8	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000fe	3b ec		 cmp	 ebp, esp
  00100	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	c3		 ret	 0
?FreeCreateWinTypeLua@@YAPAUaction@@PAUlua_State@@@Z ENDP ; FreeCreateWinTypeLua
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\mylua\winlua.cpp
;	COMDAT ?FindWinIntLua@@YAPAUlua_State@@HPAD@Z
_TEXT	SEGMENT
_filename$1 = -276					; size = 256
_lua$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_wintype$ = 8						; size = 4
_data$ = 12						; size = 4
?FindWinIntLua@@YAPAUlua_State@@HPAD@Z PROC		; FindWinIntLua, COMDAT

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 01 00
	00		 sub	 esp, 472		; 000001d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-472]
  00012	b9 76 00 00 00	 mov	 ecx, 118		; 00000076H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 23   : 	lua_State *lua = NULL;

  00028	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _lua$[ebp], 0

; 24   : 	if (lua == NULL){

  0002f	83 7d f4 00	 cmp	 DWORD PTR _lua$[ebp], 0
  00033	75 39		 jne	 SHORT $LN2@FindWinInt

; 25   : 		char filename[256];
; 26   : #ifdef _LUA加密
; 27   : 		sprintf_s(filename, "%s//win//%d.sq", _LUA_PATCH_, wintype);
; 28   : #else
; 29   : 		sprintf_s(filename, "%s//win//%d.lua", _LUA_PATCH_, wintype);

  00035	8b 45 08	 mov	 eax, DWORD PTR _wintype$[ebp]
  00038	50		 push	 eax
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_09KBLMODGM@?4?1?1salua1?$AA@
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@IALLELID@?$CFs?1?1win?1?1?$CFd?4lua?$AA@
  00043	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _filename$1[ebp]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ; sprintf_s<256>
  0004f	83 c4 10	 add	 esp, 16			; 00000010H

; 30   : #endif
; 31   : 		lua = FindLua(filename);

  00052	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _filename$1[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?FindLua@@YAPAUlua_State@@PAD@Z ; FindLua
  0005e	83 c4 04	 add	 esp, 4
  00061	89 45 f4	 mov	 DWORD PTR _lua$[ebp], eax

; 32   : 		if (lua == NULL)return NULL;

  00064	83 7d f4 00	 cmp	 DWORD PTR _lua$[ebp], 0
  00068	75 04		 jne	 SHORT $LN2@FindWinInt
  0006a	33 c0		 xor	 eax, eax
  0006c	eb 5e		 jmp	 SHORT $LN1@FindWinInt
$LN2@FindWinInt:

; 33   : 	}
; 34   : 	lua_getglobal(lua, "WindowInit");

  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MBJJKKFJ@WindowInit?$AA@
  00073	68 ee d8 ff ff	 push	 -10002			; ffffd8eeH
  00078	8b 45 f4	 mov	 eax, DWORD PTR _lua$[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 _lua_getfield
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH

; 35   : 	if (!lua_isfunction(lua, -1)){

  00084	6a ff		 push	 -1
  00086	8b 45 f4	 mov	 eax, DWORD PTR _lua$[ebp]
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 _lua_type
  0008f	83 c4 08	 add	 esp, 8
  00092	83 f8 06	 cmp	 eax, 6
  00095	74 12		 je	 SHORT $LN4@FindWinInt

; 36   : 		lua_pop(lua, 1);

  00097	6a fe		 push	 -2			; fffffffeH
  00099	8b 45 f4	 mov	 eax, DWORD PTR _lua$[ebp]
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 _lua_settop
  000a2	83 c4 08	 add	 esp, 8

; 37   : 		return NULL;

  000a5	33 c0		 xor	 eax, eax
  000a7	eb 23		 jmp	 SHORT $LN1@FindWinInt
$LN4@FindWinInt:

; 38   : 	}
; 39   : 	lua_pushstring(lua, data); 

  000a9	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  000ac	50		 push	 eax
  000ad	8b 4d f4	 mov	 ecx, DWORD PTR _lua$[ebp]
  000b0	51		 push	 ecx
  000b1	e8 00 00 00 00	 call	 _lua_pushstring
  000b6	83 c4 08	 add	 esp, 8

; 40   : 	docall(lua, 1, 1);

  000b9	6a 01		 push	 1
  000bb	6a 01		 push	 1
  000bd	8b 45 f4	 mov	 eax, DWORD PTR _lua$[ebp]
  000c0	50		 push	 eax
  000c1	e8 00 00 00 00	 call	 ?docall@@YAHPAUlua_State@@HH@Z ; docall
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 41   : 	return lua;

  000c9	8b 45 f4	 mov	 eax, DWORD PTR _lua$[ebp]
$LN1@FindWinInt:

; 42   : }

  000cc	52		 push	 edx
  000cd	8b cd		 mov	 ecx, ebp
  000cf	50		 push	 eax
  000d0	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@FindWinInt
  000d6	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000db	58		 pop	 eax
  000dc	5a		 pop	 edx
  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx
  000e0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e3	33 cd		 xor	 ecx, ebp
  000e5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ea	81 c4 d8 01 00
	00		 add	 esp, 472		; 000001d8H
  000f0	3b ec		 cmp	 ebp, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
  000fb	90		 npad	 1
$LN8@FindWinInt:
  000fc	01 00 00 00	 DD	 1
  00100	00 00 00 00	 DD	 $LN7@FindWinInt
$LN7@FindWinInt:
  00104	ec fe ff ff	 DD	 -276			; fffffeecH
  00108	00 01 00 00	 DD	 256			; 00000100H
  0010c	00 00 00 00	 DD	 $LN6@FindWinInt
$LN6@FindWinInt:
  00110	66		 DB	 102			; 00000066H
  00111	69		 DB	 105			; 00000069H
  00112	6c		 DB	 108			; 0000006cH
  00113	65		 DB	 101			; 00000065H
  00114	6e		 DB	 110			; 0000006eH
  00115	61		 DB	 97			; 00000061H
  00116	6d		 DB	 109			; 0000006dH
  00117	65		 DB	 101			; 00000065H
  00118	00		 DB	 0
?FindWinIntLua@@YAPAUlua_State@@HPAD@Z ENDP		; FindWinIntLua
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\mylua\winlua.cpp
;	COMDAT ?FindLua@@YAPAUlua_State@@PAD@Z
_TEXT	SEGMENT
_newfilename$ = -276					; size = 256
_salua$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
?FindLua@@YAPAUlua_State@@PAD@Z PROC			; FindLua, COMDAT

; 381  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 01 00
	00		 sub	 esp, 472		; 000001d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-472]
  00012	b9 76 00 00 00	 mov	 ecx, 118		; 00000076H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 382  : 	MY_Lua *salua = &MYLua;

  00028	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _salua$[ebp], OFFSET ?MYLua@@3UtagMYLua@@A ; MYLua

; 383  : 	char newfilename[256];
; 384  : 	sprintf_s(newfilename, "%s", filename);

  0002f	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00032	50		 push	 eax
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00038	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _newfilename$[ebp]
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ; sprintf_s<256>
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@FindLua:

; 385  : 	while(salua->next != NULL){

  00047	8b 45 f4	 mov	 eax, DWORD PTR _salua$[ebp]
  0004a	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0004e	74 2c		 je	 SHORT $LN3@FindLua

; 386  : 		if(strcmp(newfilename, salua->luapath) == 0){

  00050	8b 45 f4	 mov	 eax, DWORD PTR _salua$[ebp]
  00053	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00056	51		 push	 ecx
  00057	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _newfilename$[ebp]
  0005d	52		 push	 edx
  0005e	e8 00 00 00 00	 call	 _strcmp
  00063	83 c4 08	 add	 esp, 8
  00066	85 c0		 test	 eax, eax
  00068	75 07		 jne	 SHORT $LN4@FindLua

; 387  : 			return salua->lua;

  0006a	8b 45 f4	 mov	 eax, DWORD PTR _salua$[ebp]
  0006d	8b 00		 mov	 eax, DWORD PTR [eax]
  0006f	eb 0d		 jmp	 SHORT $LN1@FindLua
$LN4@FindLua:

; 388  : 		}
; 389  : 		salua = salua->next;

  00071	8b 45 f4	 mov	 eax, DWORD PTR _salua$[ebp]
  00074	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00077	89 4d f4	 mov	 DWORD PTR _salua$[ebp], ecx

; 390  : 	}

  0007a	eb cb		 jmp	 SHORT $LN2@FindLua
$LN3@FindLua:

; 391  : 	return NULL;

  0007c	33 c0		 xor	 eax, eax
$LN1@FindLua:

; 392  : }

  0007e	52		 push	 edx
  0007f	8b cd		 mov	 ecx, ebp
  00081	50		 push	 eax
  00082	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@FindLua
  00088	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0008d	58		 pop	 eax
  0008e	5a		 pop	 edx
  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx
  00092	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00095	33 cd		 xor	 ecx, ebp
  00097	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009c	81 c4 d8 01 00
	00		 add	 esp, 472		; 000001d8H
  000a2	3b ec		 cmp	 ebp, esp
  000a4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
  000ad	0f 1f 00	 npad	 3
$LN8@FindLua:
  000b0	01 00 00 00	 DD	 1
  000b4	00 00 00 00	 DD	 $LN7@FindLua
$LN7@FindLua:
  000b8	ec fe ff ff	 DD	 -276			; fffffeecH
  000bc	00 01 00 00	 DD	 256			; 00000100H
  000c0	00 00 00 00	 DD	 $LN6@FindLua
$LN6@FindLua:
  000c4	6e		 DB	 110			; 0000006eH
  000c5	65		 DB	 101			; 00000065H
  000c6	77		 DB	 119			; 00000077H
  000c7	66		 DB	 102			; 00000066H
  000c8	69		 DB	 105			; 00000069H
  000c9	6c		 DB	 108			; 0000006cH
  000ca	65		 DB	 101			; 00000065H
  000cb	6e		 DB	 110			; 0000006eH
  000cc	61		 DB	 97			; 00000061H
  000cd	6d		 DB	 109			; 0000006dH
  000ce	65		 DB	 101			; 00000065H
  000cf	00		 DB	 0
?FindLua@@YAPAUlua_State@@PAD@Z ENDP			; FindLua
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\mylua\winlua.cpp
;	COMDAT ?luaAB_openlibs@@YAXPAUlua_State@@@Z
_TEXT	SEGMENT
_lib$ = -8						; size = 4
_L$ = 8							; size = 4
?luaAB_openlibs@@YAXPAUlua_State@@@Z PROC		; luaAB_openlibs, COMDAT

; 108  : LUALIB_API void luaAB_openlibs (lua_State *L) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 109  : 	const luaL_Reg *lib = lualibs;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _lib$[ebp], OFFSET ?lualibs@@3QBUluaL_Reg@@B

; 110  : 	for (; lib->func; lib++) {

  00025	eb 09		 jmp	 SHORT $LN4@luaAB_open
$LN2@luaAB_open:
  00027	8b 45 f8	 mov	 eax, DWORD PTR _lib$[ebp]
  0002a	83 c0 08	 add	 eax, 8
  0002d	89 45 f8	 mov	 DWORD PTR _lib$[ebp], eax
$LN4@luaAB_open:
  00030	8b 45 f8	 mov	 eax, DWORD PTR _lib$[ebp]
  00033	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00037	74 39		 je	 SHORT $LN1@luaAB_open

; 111  : 		lua_pushcfunction(L, lib->func);

  00039	6a 00		 push	 0
  0003b	8b 45 f8	 mov	 eax, DWORD PTR _lib$[ebp]
  0003e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00041	51		 push	 ecx
  00042	8b 55 08	 mov	 edx, DWORD PTR _L$[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 _lua_pushcclosure
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 112  : 		lua_pushstring(L, lib->name);

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _lib$[ebp]
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	51		 push	 ecx
  00054	8b 55 08	 mov	 edx, DWORD PTR _L$[ebp]
  00057	52		 push	 edx
  00058	e8 00 00 00 00	 call	 _lua_pushstring
  0005d	83 c4 08	 add	 esp, 8

; 113  : 		lua_call(L, 1, 0);

  00060	6a 00		 push	 0
  00062	6a 01		 push	 1
  00064	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 _lua_call
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 114  : 	}

  00070	eb b5		 jmp	 SHORT $LN2@luaAB_open
$LN1@luaAB_open:

; 115  : }

  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx
  00075	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
?luaAB_openlibs@@YAXPAUlua_State@@@Z ENDP		; luaAB_openlibs
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\mylua\winlua.cpp
;	COMDAT ?getArrayInt@@YAHPAUlua_State@@H@Z
_TEXT	SEGMENT
_result$ = -8						; size = 4
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
?getArrayInt@@YAHPAUlua_State@@H@Z PROC			; getArrayInt, COMDAT

; 117  : int getArrayInt(lua_State *L, int idx) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 118  : 	int result = 0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _result$[ebp], 0

; 119  :   lua_pushnumber(L, idx + 1);

  00025	8b 45 0c	 mov	 eax, DWORD PTR _idx$[ebp]
  00028	83 c0 01	 add	 eax, 1
  0002b	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  0002f	83 ec 08	 sub	 esp, 8
  00032	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _L$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 _lua_pushnumber
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH

; 120  :   lua_gettable(L, -2);

  00043	6a fe		 push	 -2			; fffffffeH
  00045	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _lua_gettable
  0004e	83 c4 08	 add	 esp, 8

; 121  :   result = (int)lua_tonumber(L, -1);

  00051	6a ff		 push	 -1
  00053	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _lua_tonumber
  0005c	83 c4 08	 add	 esp, 8
  0005f	e8 00 00 00 00	 call	 __ftol2_sse
  00064	89 45 f8	 mov	 DWORD PTR _result$[ebp], eax

; 122  :   lua_pop(L, 1);

  00067	6a fe		 push	 -2			; fffffffeH
  00069	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 _lua_settop
  00072	83 c4 08	 add	 esp, 8

; 123  :   return result;

  00075	8b 45 f8	 mov	 eax, DWORD PTR _result$[ebp]

; 124  : }

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00081	3b ec		 cmp	 ebp, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?getArrayInt@@YAHPAUlua_State@@H@Z ENDP			; getArrayInt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\mylua\winlua.cpp
;	COMDAT ?docall@@YAHPAUlua_State@@HH@Z
_TEXT	SEGMENT
tv75 = -232						; size = 4
_iTop$1 = -32						; size = 4
_base$ = -20						; size = 4
_status$ = -8						; size = 4
_L$ = 8							; size = 4
_narg$ = 12						; size = 4
_clear$ = 16						; size = 4
?docall@@YAHPAUlua_State@@HH@Z PROC			; docall, COMDAT

; 162  : int docall (lua_State *L, int narg, int clear) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00012	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 163  :   int status;
; 164  :   int base = lua_gettop(L) - narg;  /* function index */

  0001e	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _lua_gettop
  00027	83 c4 04	 add	 esp, 4
  0002a	2b 45 0c	 sub	 eax, DWORD PTR _narg$[ebp]
  0002d	89 45 ec	 mov	 DWORD PTR _base$[ebp], eax

; 165  :   lua_pushcfunction(L, traceback);  /* push traceback function */

  00030	6a 00		 push	 0
  00032	68 00 00 00 00	 push	 OFFSET ?traceback@@YAHPAUlua_State@@@Z ; traceback
  00037	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 _lua_pushcclosure
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH

; 166  :   lua_insert(L, base);  /* put it under chunk and args */

  00043	8b 45 ec	 mov	 eax, DWORD PTR _base$[ebp]
  00046	50		 push	 eax
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _L$[ebp]
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 _lua_insert
  00050	83 c4 08	 add	 esp, 8

; 167  :   status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);

  00053	83 7d 10 00	 cmp	 DWORD PTR _clear$[ebp], 0
  00057	74 0c		 je	 SHORT $LN4@docall
  00059	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv75[ebp], 0
  00063	eb 0a		 jmp	 SHORT $LN5@docall
$LN4@docall:
  00065	c7 85 18 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv75[ebp], -1
$LN5@docall:
  0006f	8b 45 ec	 mov	 eax, DWORD PTR _base$[ebp]
  00072	50		 push	 eax
  00073	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv75[ebp]
  00079	51		 push	 ecx
  0007a	8b 55 0c	 mov	 edx, DWORD PTR _narg$[ebp]
  0007d	52		 push	 edx
  0007e	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 _lua_pcall
  00087	83 c4 10	 add	 esp, 16			; 00000010H
  0008a	89 45 f8	 mov	 DWORD PTR _status$[ebp], eax

; 168  :   lua_remove(L, base);

  0008d	8b 45 ec	 mov	 eax, DWORD PTR _base$[ebp]
  00090	50		 push	 eax
  00091	8b 4d 08	 mov	 ecx, DWORD PTR _L$[ebp]
  00094	51		 push	 ecx
  00095	e8 00 00 00 00	 call	 _lua_remove
  0009a	83 c4 08	 add	 esp, 8

; 169  :   if(status != 0){

  0009d	83 7d f8 00	 cmp	 DWORD PTR _status$[ebp], 0
  000a1	74 56		 je	 SHORT $LN2@docall

; 170  : 	printf("入口：docall 错误内容:%d(%s)\n", status, lua_tostring(L, -1));

  000a3	6a 00		 push	 0
  000a5	6a ff		 push	 -1
  000a7	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 _lua_tolstring
  000b0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b3	50		 push	 eax
  000b4	8b 4d f8	 mov	 ecx, DWORD PTR _status$[ebp]
  000b7	51		 push	 ecx
  000b8	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@FFJEDJPI@?l?$PN?O?$KC?$KD?$LKdocall?5?$DP?$DP?$DP?i?$LL?3?$CFd?$CI?$CFs?$CJ?6?$AA@
  000bd	e8 00 00 00 00	 call	 _printf
  000c2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 171  : 	int iTop = lua_gettop(L);

  000c5	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 _lua_gettop
  000ce	83 c4 04	 add	 esp, 4
  000d1	89 45 e0	 mov	 DWORD PTR _iTop$1[ebp], eax

; 172  : 	lua_pop(L,iTop);

  000d4	8b 45 e0	 mov	 eax, DWORD PTR _iTop$1[ebp]
  000d7	f7 d8		 neg	 eax
  000d9	83 e8 01	 sub	 eax, 1
  000dc	50		 push	 eax
  000dd	8b 4d 08	 mov	 ecx, DWORD PTR _L$[ebp]
  000e0	51		 push	 ecx
  000e1	e8 00 00 00 00	 call	 _lua_settop
  000e6	83 c4 08	 add	 esp, 8

; 173  : 	lua_gc(L, LUA_GCCOLLECT, 0);

  000e9	6a 00		 push	 0
  000eb	6a 02		 push	 2
  000ed	8b 45 08	 mov	 eax, DWORD PTR _L$[ebp]
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 _lua_gc
  000f6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@docall:

; 174  :   }
; 175  : 
; 176  :   return status;

  000f9	8b 45 f8	 mov	 eax, DWORD PTR _status$[ebp]

; 177  : }

  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  00105	3b ec		 cmp	 ebp, esp
  00107	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010c	8b e5		 mov	 esp, ebp
  0010e	5d		 pop	 ebp
  0010f	c3		 ret	 0
?docall@@YAHPAUlua_State@@HH@Z ENDP			; docall
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\mylua\winlua.cpp
;	COMDAT ?dofile@@YAHPAUlua_State@@PBD@Z
_TEXT	SEGMENT
tv73 = -208						; size = 4
_status$ = -8						; size = 4
_L$ = 8							; size = 4
_name$ = 12						; size = 4
?dofile@@YAHPAUlua_State@@PBD@Z PROC			; dofile, COMDAT

; 179  : int dofile (lua_State *L, const char *name) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 180  :   int status = luaL_loadfile(L, name) || docall(L, 0, 1);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _name$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _L$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 _luaL_loadfile
  0002b	83 c4 08	 add	 esp, 8
  0002e	85 c0		 test	 eax, eax
  00030	75 20		 jne	 SHORT $LN3@dofile
  00032	6a 01		 push	 1
  00034	6a 00		 push	 0
  00036	8b 55 08	 mov	 edx, DWORD PTR _L$[ebp]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 ?docall@@YAHPAUlua_State@@HH@Z ; docall
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00042	85 c0		 test	 eax, eax
  00044	75 0c		 jne	 SHORT $LN3@dofile
  00046	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv73[ebp], 0
  00050	eb 0a		 jmp	 SHORT $LN4@dofile
$LN3@dofile:
  00052	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv73[ebp], 1
$LN4@dofile:
  0005c	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv73[ebp]
  00062	89 45 f8	 mov	 DWORD PTR _status$[ebp], eax

; 181  :   return report(L, status);

  00065	8b 45 f8	 mov	 eax, DWORD PTR _status$[ebp]
  00068	50		 push	 eax
  00069	8b 4d 08	 mov	 ecx, DWORD PTR _L$[ebp]
  0006c	51		 push	 ecx
  0006d	e8 00 00 00 00	 call	 ?report@@YAHPAUlua_State@@H@Z ; report
  00072	83 c4 08	 add	 esp, 8

; 182  : }

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0007e	3b ec		 cmp	 ebp, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?dofile@@YAHPAUlua_State@@PBD@Z ENDP			; dofile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\mylua\winlua.cpp
;	COMDAT ?closemyluaload@@YAHXZ
_TEXT	SEGMENT
_salua$ = -8						; size = 4
?closemyluaload@@YAHXZ PROC				; closemyluaload, COMDAT

; 317  : int closemyluaload(){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 318  : 	MY_Lua *salua = &MYLua;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _salua$[ebp], OFFSET ?MYLua@@3UtagMYLua@@A ; MYLua
$LN2@closemylua:

; 319  : 	while(salua->next!=NULL){

  00025	8b 45 f8	 mov	 eax, DWORD PTR _salua$[ebp]
  00028	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0002c	74 29		 je	 SHORT $LN3@closemylua

; 320  : 		lua_pop(salua->lua, 1);

  0002e	6a fe		 push	 -2			; fffffffeH
  00030	8b 45 f8	 mov	 eax, DWORD PTR _salua$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 _lua_settop
  0003b	83 c4 08	 add	 esp, 8

; 321  : 		lua_close(salua->lua);

  0003e	8b 45 f8	 mov	 eax, DWORD PTR _salua$[ebp]
  00041	8b 08		 mov	 ecx, DWORD PTR [eax]
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 _lua_close
  00049	83 c4 04	 add	 esp, 4

; 322  : 		salua = salua->next;

  0004c	8b 45 f8	 mov	 eax, DWORD PTR _salua$[ebp]
  0004f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00052	89 4d f8	 mov	 DWORD PTR _salua$[ebp], ecx

; 323  : 	}

  00055	eb ce		 jmp	 SHORT $LN2@closemylua
$LN3@closemylua:

; 324  : 	
; 325  :   return EXIT_SUCCESS;

  00057	33 c0		 xor	 eax, eax

; 326  : }

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00062	3b ec		 cmp	 ebp, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?closemyluaload@@YAHXZ ENDP				; closemyluaload
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\mylua\winlua.cpp
;	COMDAT ?LoadStoneAgeLUA@@YAXPAD@Z
_TEXT	SEGMENT
_filename$1 = -868					; size = 256
_hFind$ = -604						; size = 4
_wfd$ = -592						; size = 320
_filename$ = -264					; size = 256
__$ArrayPad$ = -4					; size = 4
_path$ = 8						; size = 4
?LoadStoneAgeLUA@@YAXPAD@Z PROC				; LoadStoneAgeLUA, COMDAT

; 328  : void LoadStoneAgeLUA(char *path){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 04 00
	00		 sub	 esp, 1256		; 000004e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 18 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1256]
  00012	b9 3a 01 00 00	 mov	 ecx, 314		; 0000013aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 329  : 	char filename[256];
; 330  : 
; 331  : 	WIN32_FIND_DATA wfd; 
; 332  : 	HANDLE hFind; 
; 333  : 	lstrcpy(filename, path); 

  00028	8b f4		 mov	 esi, esp
  0002a	8b 45 08	 mov	 eax, DWORD PTR _path$[ebp]
  0002d	50		 push	 eax
  0002e	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _filename$[ebp]
  00034	51		 push	 ecx
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8
  0003b	3b f4		 cmp	 esi, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 334  : 	lstrcat(filename, "/"); 

  00042	8b f4		 mov	 esi, esp
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_01KMDKNFGN@?1?$AA@
  00049	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _filename$[ebp]
  0004f	50		 push	 eax
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcatA@8
  00056	3b f4		 cmp	 esi, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 335  : 	lstrcat(filename, "*.*"); // 找所有文件 

  0005d	8b f4		 mov	 esi, esp
  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_03EMIMMIHL@?$CK?4?$CK?$AA@
  00064	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _filename$[ebp]
  0006a	50		 push	 eax
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcatA@8
  00071	3b f4		 cmp	 esi, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 336  : 	
; 337  : 	hFind = FindFirstFile(filename, &wfd); 

  00078	8b f4		 mov	 esi, esp
  0007a	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _wfd$[ebp]
  00080	50		 push	 eax
  00081	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _filename$[ebp]
  00087	51		 push	 ecx
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindFirstFileA@8
  0008e	3b f4		 cmp	 esi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	89 85 a4 fd ff
	ff		 mov	 DWORD PTR _hFind$[ebp], eax

; 338  : 	if (hFind == INVALID_HANDLE_VALUE) // 如果没有找到或查找失败 

  0009b	83 bd a4 fd ff
	ff ff		 cmp	 DWORD PTR _hFind$[ebp], -1
  000a2	75 05		 jne	 SHORT $LN4@LoadStoneA

; 339  : 		return; 

  000a4	e9 ec 00 00 00	 jmp	 $LN1@LoadStoneA
$LN4@LoadStoneA:

; 340  : 	do{
; 341  : 		
; 342  : 		if (wfd.cFileName[0] == '.') 

  000a9	b8 01 00 00 00	 mov	 eax, 1
  000ae	6b c8 00	 imul	 ecx, eax, 0
  000b1	0f be 94 0d dc
	fd ff ff	 movsx	 edx, BYTE PTR _wfd$[ebp+ecx+44]
  000b9	83 fa 2e	 cmp	 edx, 46			; 0000002eH
  000bc	75 05		 jne	 SHORT $LN6@LoadStoneA

; 343  : 			continue; // 过滤这两个目录 

  000be	e9 97 00 00 00	 jmp	 $LN2@LoadStoneA
$LN6@LoadStoneA:

; 344  : 		if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY){ 

  000c3	8b 85 b0 fd ff
	ff		 mov	 eax, DWORD PTR _wfd$[ebp]
  000c9	83 e0 10	 and	 eax, 16			; 00000010H
  000cc	74 30		 je	 SHORT $LN7@LoadStoneA

; 345  : 			sprintf_s(filename, "%s//%s", path, wfd.cFileName);

  000ce	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _wfd$[ebp+44]
  000d4	50		 push	 eax
  000d5	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  000d8	51		 push	 ecx
  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_06PDPEOAFG@?$CFs?1?1?$CFs?$AA@
  000de	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _filename$[ebp]
  000e4	52		 push	 edx
  000e5	e8 00 00 00 00	 call	 ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ; sprintf_s<256>
  000ea	83 c4 10	 add	 esp, 16			; 00000010H

; 346  : 			LoadStoneAgeLUA(filename);

  000ed	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _filename$[ebp]
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 ?LoadStoneAgeLUA@@YAXPAD@Z ; LoadStoneAgeLUA
  000f9	83 c4 04	 add	 esp, 4

; 347  : 		}else{

  000fc	eb 5c		 jmp	 SHORT $LN2@LoadStoneA
$LN7@LoadStoneA:

; 348  : 			extern int strcmptail(char *s1, char *s2);
; 349  : #ifdef _LUA加密
; 350  : 			if( strcmptail( wfd.cFileName, ".sq" ) == 0)
; 351  : #else
; 352  : 			if( strcmptail( wfd.cFileName, ".lua" ) == 0)

  000fe	68 00 00 00 00	 push	 OFFSET ??_C@_04BIAACBGB@?4lua?$AA@
  00103	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _wfd$[ebp+44]
  00109	50		 push	 eax
  0010a	e8 00 00 00 00	 call	 ?strcmptail@@YAHPAD0@Z	; strcmptail
  0010f	83 c4 08	 add	 esp, 8
  00112	85 c0		 test	 eax, eax
  00114	75 44		 jne	 SHORT $LN2@LoadStoneA

; 353  : #endif
; 354  : 			{
; 355  : 				char filename[256];
; 356  : 				memset(filename, 0, 256);

  00116	68 00 01 00 00	 push	 256			; 00000100H
  0011b	6a 00		 push	 0
  0011d	8d 85 9c fc ff
	ff		 lea	 eax, DWORD PTR _filename$1[ebp]
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 _memset
  00129	83 c4 0c	 add	 esp, 12			; 0000000cH

; 357  : 				sprintf_s(filename, "%s//%s", path, wfd.cFileName);

  0012c	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _wfd$[ebp+44]
  00132	50		 push	 eax
  00133	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  00136	51		 push	 ecx
  00137	68 00 00 00 00	 push	 OFFSET ??_C@_06PDPEOAFG@?$CFs?1?1?$CFs?$AA@
  0013c	8d 95 9c fc ff
	ff		 lea	 edx, DWORD PTR _filename$1[ebp]
  00142	52		 push	 edx
  00143	e8 00 00 00 00	 call	 ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ; sprintf_s<256>
  00148	83 c4 10	 add	 esp, 16			; 00000010H

; 358  : 				myluaload(filename);

  0014b	8d 85 9c fc ff
	ff		 lea	 eax, DWORD PTR _filename$1[ebp]
  00151	50		 push	 eax
  00152	e8 00 00 00 00	 call	 ?myluaload@@YAHPAD@Z	; myluaload
  00157	83 c4 04	 add	 esp, 4
$LN2@LoadStoneA:

; 359  : 			}
; 360  : 		}
; 361  : 	}while (FindNextFile(hFind, &wfd)); 

  0015a	8b f4		 mov	 esi, esp
  0015c	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _wfd$[ebp]
  00162	50		 push	 eax
  00163	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR _hFind$[ebp]
  00169	51		 push	 ecx
  0016a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindNextFileA@8
  00170	3b f4		 cmp	 esi, esp
  00172	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00177	85 c0		 test	 eax, eax
  00179	0f 85 2a ff ff
	ff		 jne	 $LN4@LoadStoneA

; 362  : 	FindClose(hFind); // 关闭查找句柄 

  0017f	8b f4		 mov	 esi, esp
  00181	8b 85 a4 fd ff
	ff		 mov	 eax, DWORD PTR _hFind$[ebp]
  00187	50		 push	 eax
  00188	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindClose@4
  0018e	3b f4		 cmp	 esi, esp
  00190	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@LoadStoneA:

; 363  : }

  00195	52		 push	 edx
  00196	8b cd		 mov	 ecx, ebp
  00198	50		 push	 eax
  00199	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@LoadStoneA
  0019f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001a4	58		 pop	 eax
  001a5	5a		 pop	 edx
  001a6	5f		 pop	 edi
  001a7	5e		 pop	 esi
  001a8	5b		 pop	 ebx
  001a9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ac	33 cd		 xor	 ecx, ebp
  001ae	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b3	81 c4 e8 04 00
	00		 add	 esp, 1256		; 000004e8H
  001b9	3b ec		 cmp	 ebp, esp
  001bb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c0	8b e5		 mov	 esp, ebp
  001c2	5d		 pop	 ebp
  001c3	c3		 ret	 0
$LN15@LoadStoneA:
  001c4	03 00 00 00	 DD	 3
  001c8	00 00 00 00	 DD	 $LN14@LoadStoneA
$LN14@LoadStoneA:
  001cc	f8 fe ff ff	 DD	 -264			; fffffef8H
  001d0	00 01 00 00	 DD	 256			; 00000100H
  001d4	00 00 00 00	 DD	 $LN11@LoadStoneA
  001d8	b0 fd ff ff	 DD	 -592			; fffffdb0H
  001dc	40 01 00 00	 DD	 320			; 00000140H
  001e0	00 00 00 00	 DD	 $LN12@LoadStoneA
  001e4	9c fc ff ff	 DD	 -868			; fffffc9cH
  001e8	00 01 00 00	 DD	 256			; 00000100H
  001ec	00 00 00 00	 DD	 $LN13@LoadStoneA
$LN13@LoadStoneA:
  001f0	66		 DB	 102			; 00000066H
  001f1	69		 DB	 105			; 00000069H
  001f2	6c		 DB	 108			; 0000006cH
  001f3	65		 DB	 101			; 00000065H
  001f4	6e		 DB	 110			; 0000006eH
  001f5	61		 DB	 97			; 00000061H
  001f6	6d		 DB	 109			; 0000006dH
  001f7	65		 DB	 101			; 00000065H
  001f8	00		 DB	 0
$LN12@LoadStoneA:
  001f9	77		 DB	 119			; 00000077H
  001fa	66		 DB	 102			; 00000066H
  001fb	64		 DB	 100			; 00000064H
  001fc	00		 DB	 0
$LN11@LoadStoneA:
  001fd	66		 DB	 102			; 00000066H
  001fe	69		 DB	 105			; 00000069H
  001ff	6c		 DB	 108			; 0000006cH
  00200	65		 DB	 101			; 00000065H
  00201	6e		 DB	 110			; 0000006eH
  00202	61		 DB	 97			; 00000061H
  00203	6d		 DB	 109			; 0000006dH
  00204	65		 DB	 101			; 00000065H
  00205	00		 DB	 0
?LoadStoneAgeLUA@@YAXPAD@Z ENDP				; LoadStoneAgeLUA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\mylua\winlua.cpp
;	COMDAT ?remyluaload@@YAHPAD@Z
_TEXT	SEGMENT
_salua$ = -8						; size = 4
_filename$ = 8						; size = 4
?remyluaload@@YAHPAD@Z PROC				; remyluaload, COMDAT

; 290  : int remyluaload (char *filename){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 291  : 	MY_Lua *salua = &MYLua;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _salua$[ebp], OFFSET ?MYLua@@3UtagMYLua@@A ; MYLua
$LN2@remylualoa:

; 292  : 	while(salua->next!=NULL){

  00025	8b 45 f8	 mov	 eax, DWORD PTR _salua$[ebp]
  00028	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0002c	0f 84 ff 00 00
	00		 je	 $LN3@remylualoa

; 293  : 		if(strlen(salua->luapath) > 0){

  00032	8b 45 f8	 mov	 eax, DWORD PTR _salua$[ebp]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 _strlen
  0003e	83 c4 04	 add	 esp, 4
  00041	85 c0		 test	 eax, eax
  00043	0f 86 da 00 00
	00		 jbe	 $LN4@remylualoa

; 294  : 			if(strlen(filename)>0){

  00049	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _strlen
  00052	83 c4 04	 add	 esp, 4
  00055	85 c0		 test	 eax, eax
  00057	76 22		 jbe	 SHORT $LN5@remylualoa

; 295  : 				if(strstr(salua->luapath, filename) == 0){

  00059	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0005c	50		 push	 eax
  0005d	8b 4d f8	 mov	 ecx, DWORD PTR _salua$[ebp]
  00060	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 ?strstr@@YAPADQADQBD@Z	; strstr
  00069	83 c4 08	 add	 esp, 8
  0006c	85 c0		 test	 eax, eax
  0006e	75 0b		 jne	 SHORT $LN5@remylualoa

; 296  : 					salua = salua->next;

  00070	8b 45 f8	 mov	 eax, DWORD PTR _salua$[ebp]
  00073	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00076	89 4d f8	 mov	 DWORD PTR _salua$[ebp], ecx

; 297  : 					continue;

  00079	eb aa		 jmp	 SHORT $LN2@remylualoa
$LN5@remylualoa:

; 298  : 				}
; 299  : 			}
; 300  : 			lua_gc(salua->lua, LUA_GCSTOP, 0); 

  0007b	6a 00		 push	 0
  0007d	6a 00		 push	 0
  0007f	8b 45 f8	 mov	 eax, DWORD PTR _salua$[ebp]
  00082	8b 08		 mov	 ecx, DWORD PTR [eax]
  00084	51		 push	 ecx
  00085	e8 00 00 00 00	 call	 _lua_gc
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 301  : 			luaL_openlibs(salua->lua); 

  0008d	8b 45 f8	 mov	 eax, DWORD PTR _salua$[ebp]
  00090	8b 08		 mov	 ecx, DWORD PTR [eax]
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 _luaL_openlibs
  00098	83 c4 04	 add	 esp, 4

; 302  : 			luaAB_openlibs(salua->lua);

  0009b	8b 45 f8	 mov	 eax, DWORD PTR _salua$[ebp]
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 ?luaAB_openlibs@@YAXPAUlua_State@@@Z ; luaAB_openlibs
  000a6	83 c4 04	 add	 esp, 4

; 303  : 			lua_gc(salua->lua, LUA_GCRESTART, 0);

  000a9	6a 00		 push	 0
  000ab	6a 01		 push	 1
  000ad	8b 45 f8	 mov	 eax, DWORD PTR _salua$[ebp]
  000b0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b2	51		 push	 ecx
  000b3	e8 00 00 00 00	 call	 _lua_gc
  000b8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 304  : 			dofile(salua->lua, salua->luapath);

  000bb	8b 45 f8	 mov	 eax, DWORD PTR _salua$[ebp]
  000be	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c1	51		 push	 ecx
  000c2	8b 55 f8	 mov	 edx, DWORD PTR _salua$[ebp]
  000c5	8b 02		 mov	 eax, DWORD PTR [edx]
  000c7	50		 push	 eax
  000c8	e8 00 00 00 00	 call	 ?dofile@@YAHPAUlua_State@@PBD@Z ; dofile
  000cd	83 c4 08	 add	 esp, 8

; 305  : 			printf("\n%s",salua->luapath);

  000d0	8b 45 f8	 mov	 eax, DWORD PTR _salua$[ebp]
  000d3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d6	51		 push	 ecx
  000d7	68 00 00 00 00	 push	 OFFSET ??_C@_03ILJCGOLJ@?6?$CFs?$AA@
  000dc	e8 00 00 00 00	 call	 _printf
  000e1	83 c4 08	 add	 esp, 8

; 306  : 			lua_getglobal(salua->lua, "data");

  000e4	68 00 00 00 00	 push	 OFFSET ??_C@_04PJOLNDGD@data?$AA@
  000e9	68 ee d8 ff ff	 push	 -10002			; ffffd8eeH
  000ee	8b 45 f8	 mov	 eax, DWORD PTR _salua$[ebp]
  000f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f3	51		 push	 ecx
  000f4	e8 00 00 00 00	 call	 _lua_getfield
  000f9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 307  : 			if (lua_isfunction(salua->lua, -1)){

  000fc	6a ff		 push	 -1
  000fe	8b 45 f8	 mov	 eax, DWORD PTR _salua$[ebp]
  00101	8b 08		 mov	 ecx, DWORD PTR [eax]
  00103	51		 push	 ecx
  00104	e8 00 00 00 00	 call	 _lua_type
  00109	83 c4 08	 add	 esp, 8
  0010c	83 f8 06	 cmp	 eax, 6
  0010f	75 12		 jne	 SHORT $LN4@remylualoa

; 308  : 				docall(salua->lua, 0, 1);

  00111	6a 01		 push	 1
  00113	6a 00		 push	 0
  00115	8b 45 f8	 mov	 eax, DWORD PTR _salua$[ebp]
  00118	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011a	51		 push	 ecx
  0011b	e8 00 00 00 00	 call	 ?docall@@YAHPAUlua_State@@HH@Z ; docall
  00120	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@remylualoa:

; 309  : 			}
; 310  : 		}
; 311  : 		salua = salua->next;

  00123	8b 45 f8	 mov	 eax, DWORD PTR _salua$[ebp]
  00126	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00129	89 4d f8	 mov	 DWORD PTR _salua$[ebp], ecx

; 312  : 	}

  0012c	e9 f4 fe ff ff	 jmp	 $LN2@remylualoa
$LN3@remylualoa:

; 313  :   return EXIT_SUCCESS;

  00131	33 c0		 xor	 eax, eax

; 314  : }

  00133	5f		 pop	 edi
  00134	5e		 pop	 esi
  00135	5b		 pop	 ebx
  00136	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0013c	3b ec		 cmp	 ebp, esp
  0013e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00143	8b e5		 mov	 esp, ebp
  00145	5d		 pop	 ebp
  00146	c3		 ret	 0
?remyluaload@@YAHPAD@Z ENDP				; remyluaload
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\mylua\winlua.cpp
;	COMDAT ?myluaload@@YAHPAD@Z
_TEXT	SEGMENT
$T1 = -348						; size = 4
$T2 = -336						; size = 4
_buf$3 = -132						; size = 100
_re$ = -24						; size = 4
_salua$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
?myluaload@@YAHPAD@Z PROC				; myluaload, COMDAT

; 242  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 60 01 00
	00		 sub	 esp, 352		; 00000160H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd a0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-352]
  00012	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 243  : 	MY_Lua *salua = &MYLua;

  00028	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _salua$[ebp], OFFSET ?MYLua@@3UtagMYLua@@A ; MYLua
$LN2@myluaload:

; 244  : 	while(salua->next!=NULL){

  0002f	8b 45 f4	 mov	 eax, DWORD PTR _salua$[ebp]
  00032	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00036	74 29		 je	 SHORT $LN3@myluaload

; 245  : 		if(strcmp(salua->luapath, filename) == 0){

  00038	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f4	 mov	 ecx, DWORD PTR _salua$[ebp]
  0003f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 _strcmp
  00048	83 c4 08	 add	 esp, 8
  0004b	85 c0		 test	 eax, eax
  0004d	75 07		 jne	 SHORT $LN4@myluaload

; 246  : 			return FALSE;

  0004f	33 c0		 xor	 eax, eax
  00051	e9 d5 01 00 00	 jmp	 $LN1@myluaload
$LN4@myluaload:

; 247  : 		}
; 248  : 		salua = salua->next;

  00056	8b 45 f4	 mov	 eax, DWORD PTR _salua$[ebp]
  00059	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005c	89 4d f4	 mov	 DWORD PTR _salua$[ebp], ecx

; 249  : 	}

  0005f	eb ce		 jmp	 SHORT $LN2@myluaload
$LN3@myluaload:

; 250  : 	salua->luapath = new char[strlen(filename)+1];

  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??myluaload@@YAHPAD@Z@4JA
  00066	83 c0 08	 add	 eax, 8
  00069	50		 push	 eax
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0GD@LLKGLPLG@c?3?2users?2administrator?2desktop?2?$LN@
  0006f	6a 01		 push	 1
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _filename$[ebp]
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 _strlen
  0007a	83 c4 04	 add	 esp, 4
  0007d	83 c0 01	 add	 eax, 1
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 ??_U@YAPAXIHPBDH@Z	; operator new[]
  00086	83 c4 10	 add	 esp, 16			; 00000010H
  00089	89 85 b0 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  0008f	8b 55 f4	 mov	 edx, DWORD PTR _salua$[ebp]
  00092	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  00098	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 251  : 	memset( salua->luapath, 0 , strlen(filename)+1);

  0009b	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 _strlen
  000a4	83 c4 04	 add	 esp, 4
  000a7	83 c0 01	 add	 eax, 1
  000aa	50		 push	 eax
  000ab	6a 00		 push	 0
  000ad	8b 4d f4	 mov	 ecx, DWORD PTR _salua$[ebp]
  000b0	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000b3	52		 push	 edx
  000b4	e8 00 00 00 00	 call	 _memset
  000b9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 252  : 	strcpy(salua->luapath, filename);

  000bc	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  000bf	50		 push	 eax
  000c0	8b 4d f4	 mov	 ecx, DWORD PTR _salua$[ebp]
  000c3	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000c6	52		 push	 edx
  000c7	e8 00 00 00 00	 call	 _strcpy
  000cc	83 c4 08	 add	 esp, 8

; 253  : 	salua->next = (tagMYLua *)new MY_Lua;

  000cf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??myluaload@@YAHPAD@Z@4JA
  000d4	83 c0 0b	 add	 eax, 11			; 0000000bH
  000d7	50		 push	 eax
  000d8	68 00 00 00 00	 push	 OFFSET ??_C@_0GD@LLKGLPLG@c?3?2users?2administrator?2desktop?2?$LN@
  000dd	6a 01		 push	 1
  000df	6a 0c		 push	 12			; 0000000cH
  000e1	e8 00 00 00 00	 call	 ??2@YAPAXIHPBDH@Z	; operator new
  000e6	83 c4 10	 add	 esp, 16			; 00000010H
  000e9	89 85 a4 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  000ef	8b 4d f4	 mov	 ecx, DWORD PTR _salua$[ebp]
  000f2	8b 95 a4 fe ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  000f8	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 254  : 	memset( salua->next, 0 , sizeof(MY_Lua) );

  000fb	6a 0c		 push	 12			; 0000000cH
  000fd	6a 00		 push	 0
  000ff	8b 45 f4	 mov	 eax, DWORD PTR _salua$[ebp]
  00102	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00105	51		 push	 ecx
  00106	e8 00 00 00 00	 call	 _memset
  0010b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 255  : 	if(salua->next == NULL)return EXIT_FAILURE;

  0010e	8b 45 f4	 mov	 eax, DWORD PTR _salua$[ebp]
  00111	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00115	75 0a		 jne	 SHORT $LN5@myluaload
  00117	b8 01 00 00 00	 mov	 eax, 1
  0011c	e9 0a 01 00 00	 jmp	 $LN1@myluaload
$LN5@myluaload:

; 256  : 
; 257  : 	salua->lua = lua_open();

  00121	e8 00 00 00 00	 call	 _luaL_newstate
  00126	8b 4d f4	 mov	 ecx, DWORD PTR _salua$[ebp]
  00129	89 01		 mov	 DWORD PTR [ecx], eax

; 258  : 	if (salua->lua == NULL) {

  0012b	8b 45 f4	 mov	 eax, DWORD PTR _salua$[ebp]
  0012e	83 38 00	 cmp	 DWORD PTR [eax], 0
  00131	75 07		 jne	 SHORT $LN6@myluaload

; 259  : 		return FALSE;

  00133	33 c0		 xor	 eax, eax
  00135	e9 f1 00 00 00	 jmp	 $LN1@myluaload
$LN6@myluaload:

; 260  : 	}
; 261  : 	lua_gc(salua->lua, LUA_GCSTOP, 0);

  0013a	6a 00		 push	 0
  0013c	6a 00		 push	 0
  0013e	8b 45 f4	 mov	 eax, DWORD PTR _salua$[ebp]
  00141	8b 08		 mov	 ecx, DWORD PTR [eax]
  00143	51		 push	 ecx
  00144	e8 00 00 00 00	 call	 _lua_gc
  00149	83 c4 0c	 add	 esp, 12			; 0000000cH

; 262  : 	luaL_openlibs(salua->lua);

  0014c	8b 45 f4	 mov	 eax, DWORD PTR _salua$[ebp]
  0014f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00151	51		 push	 ecx
  00152	e8 00 00 00 00	 call	 _luaL_openlibs
  00157	83 c4 04	 add	 esp, 4

; 263  : 	luaAB_openlibs(salua->lua);

  0015a	8b 45 f4	 mov	 eax, DWORD PTR _salua$[ebp]
  0015d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0015f	51		 push	 ecx
  00160	e8 00 00 00 00	 call	 ?luaAB_openlibs@@YAXPAUlua_State@@@Z ; luaAB_openlibs
  00165	83 c4 04	 add	 esp, 4

; 264  : 	lua_gc(salua->lua, LUA_GCRESTART, 0);

  00168	6a 00		 push	 0
  0016a	6a 01		 push	 1
  0016c	8b 45 f4	 mov	 eax, DWORD PTR _salua$[ebp]
  0016f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00171	51		 push	 ecx
  00172	e8 00 00 00 00	 call	 _lua_gc
  00177	83 c4 0c	 add	 esp, 12			; 0000000cH

; 265  : #ifdef _LUA加密
; 266  : 	int re = decryptLUA(salua->lua, filename);
; 267  : 	if(re != 0){
; 268  : 		if(re==-100) return TRUE;
; 269  : 		printf("文件：%s 错误提示：%s 行数：%d\n",filename,(char *)lua_tostring(salua->lua, -1),re);
; 270  : 		lua_gc(salua->lua, LUA_GCCOLLECT, 0);
; 271  : 		return TRUE;
; 272  : 	}
; 273  : #else
; 274  : 	int re = decryptLUA2(salua->lua, filename);

  0017a	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0017d	50		 push	 eax
  0017e	8b 4d f4	 mov	 ecx, DWORD PTR _salua$[ebp]
  00181	8b 11		 mov	 edx, DWORD PTR [ecx]
  00183	52		 push	 edx
  00184	e8 00 00 00 00	 call	 ?decryptLUA2@@YAHPAUlua_State@@PAD@Z ; decryptLUA2
  00189	83 c4 08	 add	 esp, 8
  0018c	89 45 e8	 mov	 DWORD PTR _re$[ebp], eax

; 275  : 	if(re!=0){

  0018f	83 7d e8 00	 cmp	 DWORD PTR _re$[ebp], 0
  00193	74 52		 je	 SHORT $LN7@myluaload

; 276  : 		char buf[100];
; 277  : 		wsprintfA(buf, "文件：%s 错误提示：%s 行数：%d\n", filename, (char *)lua_tostring(salua->lua, -1), re);

  00195	8b f4		 mov	 esi, esp
  00197	8b 45 e8	 mov	 eax, DWORD PTR _re$[ebp]
  0019a	50		 push	 eax
  0019b	6a 00		 push	 0
  0019d	6a ff		 push	 -1
  0019f	8b 4d f4	 mov	 ecx, DWORD PTR _salua$[ebp]
  001a2	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a4	52		 push	 edx
  001a5	e8 00 00 00 00	 call	 _lua_tolstring
  001aa	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ad	50		 push	 eax
  001ae	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  001b1	50		 push	 eax
  001b2	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@MOHPFDBB@?Y?$PO?K?l?$KD?$LK?$CFs?5?$DP?$DP?p?$KL?c?F?$KD?$LK?$CFs?5?z?$LM?$DP?$KD?$LK?$CFd?6?$AA@
  001b7	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _buf$3[ebp]
  001bd	51		 push	 ecx
  001be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  001c4	83 c4 14	 add	 esp, 20			; 00000014H
  001c7	3b f4		 cmp	 esi, esp
  001c9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 278  : 	//	printf("文件：%s 错误提示：%s 行数：%d\n",filename,(char *)lua_tostring(salua->lua, -1),re);
; 279  : 		lua_gc(salua->lua, LUA_GCCOLLECT, 0);

  001ce	6a 00		 push	 0
  001d0	6a 02		 push	 2
  001d2	8b 45 f4	 mov	 eax, DWORD PTR _salua$[ebp]
  001d5	8b 08		 mov	 ecx, DWORD PTR [eax]
  001d7	51		 push	 ecx
  001d8	e8 00 00 00 00	 call	 _lua_gc
  001dd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 280  : 		return TRUE;	

  001e0	b8 01 00 00 00	 mov	 eax, 1
  001e5	eb 44		 jmp	 SHORT $LN1@myluaload
$LN7@myluaload:

; 281  : 	}
; 282  : #endif
; 283  : 	lua_getglobal(salua->lua, "main");

  001e7	68 00 00 00 00	 push	 OFFSET ??_C@_04GHJNJNPO@main?$AA@
  001ec	68 ee d8 ff ff	 push	 -10002			; ffffd8eeH
  001f1	8b 45 f4	 mov	 eax, DWORD PTR _salua$[ebp]
  001f4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f6	51		 push	 ecx
  001f7	e8 00 00 00 00	 call	 _lua_getfield
  001fc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 284  : 	if (lua_isfunction(salua->lua, -1)) {

  001ff	6a ff		 push	 -1
  00201	8b 45 f4	 mov	 eax, DWORD PTR _salua$[ebp]
  00204	8b 08		 mov	 ecx, DWORD PTR [eax]
  00206	51		 push	 ecx
  00207	e8 00 00 00 00	 call	 _lua_type
  0020c	83 c4 08	 add	 esp, 8
  0020f	83 f8 06	 cmp	 eax, 6
  00212	75 12		 jne	 SHORT $LN8@myluaload

; 285  : 		docall(salua->lua, 0, 1);

  00214	6a 01		 push	 1
  00216	6a 00		 push	 0
  00218	8b 45 f4	 mov	 eax, DWORD PTR _salua$[ebp]
  0021b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0021d	51		 push	 ecx
  0021e	e8 00 00 00 00	 call	 ?docall@@YAHPAUlua_State@@HH@Z ; docall
  00223	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@myluaload:

; 286  : 	}
; 287  : 	return TRUE;

  00226	b8 01 00 00 00	 mov	 eax, 1
$LN1@myluaload:

; 288  : }

  0022b	52		 push	 edx
  0022c	8b cd		 mov	 ecx, ebp
  0022e	50		 push	 eax
  0022f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@myluaload
  00235	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0023a	58		 pop	 eax
  0023b	5a		 pop	 edx
  0023c	5f		 pop	 edi
  0023d	5e		 pop	 esi
  0023e	5b		 pop	 ebx
  0023f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00242	33 cd		 xor	 ecx, ebp
  00244	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00249	81 c4 60 01 00
	00		 add	 esp, 352		; 00000160H
  0024f	3b ec		 cmp	 ebp, esp
  00251	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00256	8b e5		 mov	 esp, ebp
  00258	5d		 pop	 ebp
  00259	c3		 ret	 0
  0025a	66 90		 npad	 2
$LN12@myluaload:
  0025c	01 00 00 00	 DD	 1
  00260	00 00 00 00	 DD	 $LN11@myluaload
$LN11@myluaload:
  00264	7c ff ff ff	 DD	 -132			; ffffff7cH
  00268	64 00 00 00	 DD	 100			; 00000064H
  0026c	00 00 00 00	 DD	 $LN10@myluaload
$LN10@myluaload:
  00270	62		 DB	 98			; 00000062H
  00271	75		 DB	 117			; 00000075H
  00272	66		 DB	 102			; 00000066H
  00273	00		 DB	 0
?myluaload@@YAHPAD@Z ENDP				; myluaload
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsprintf_s
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsprintf_s PROC					; COMDAT

; 1515 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1516 :         return _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  0001e	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00021	50		 push	 eax
  00022	6a 00		 push	 0
  00024	8b 4d 10	 mov	 ecx, DWORD PTR __Format$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 0c	 mov	 edx, DWORD PTR __BufferCount$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 __vsprintf_s_l
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 1517 :     }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_vsprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_s_l
_TEXT	SEGMENT
tv73 = -208						; size = 4
__Result$ = -8						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsprintf_s_l PROC					; COMDAT

; 1493 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1494 :     int const _Result = __stdio_common_vsprintf_s(

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  0002f	50		 push	 eax
  00030	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00039	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003c	52		 push	 edx
  0003d	8b 00		 mov	 eax, DWORD PTR [eax]
  0003f	50		 push	 eax
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf_s
  00046	83 c4 1c	 add	 esp, 28			; 0000001cH
  00049	3b f4		 cmp	 esi, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 1495 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1496 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1497 : 
; 1498 :     return _Result < 0 ? -1 : _Result;

  00053	83 7d f8 00	 cmp	 DWORD PTR __Result$[ebp], 0
  00057	7d 0c		 jge	 SHORT $LN3@vsprintf_s
  00059	c7 85 30 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv73[ebp], -1
  00063	eb 09		 jmp	 SHORT $LN4@vsprintf_s
$LN3@vsprintf_s:
  00065	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]
  00068	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv73[ebp], eax
$LN4@vsprintf_s:
  0006e	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv73[ebp]

; 1499 : }

  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0007d	3b ec		 cmp	 ebp, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
__vsprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 950  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

  0001e	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
  00023	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00026	89 45 ec	 mov	 DWORD PTR __ArgList$[ebp], eax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00029	8b 45 ec	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0002c	50		 push	 eax
  0002d	6a 00		 push	 0
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Format$[ebp]
  00032	51		 push	 ecx
  00033	8b f4		 mov	 esi, esp
  00035	6a 01		 push	 1
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0003d	83 c4 04	 add	 esp, 4
  00040	3b f4		 cmp	 esi, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 __vfprintf_l
  0004d	83 c4 10	 add	 esp, 16			; 00000010H
  00050	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 955  :     __crt_va_end(_ArgList);

  00053	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 956  :     return _Result;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 957  : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 144  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 831  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 832  :     int _Result;
; 833  :     va_list _ArgList;
; 834  :     __crt_va_start(_ArgList, _Format);

  0001e	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
  00023	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00026	89 45 ec	 mov	 DWORD PTR __ArgList$[ebp], eax

; 835  :     _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00029	8b 45 ec	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0002c	50		 push	 eax
  0002d	6a 00		 push	 0
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 08	 mov	 edx, DWORD PTR __Stream$[ebp]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 __vfprintf_l
  0003c	83 c4 10	 add	 esp, 16			; 00000010H
  0003f	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 836  :     __crt_va_end(_ArgList);

  00042	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 837  :     return _Result;

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 838  : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 638  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	51		 push	 ecx
  00039	8b 10		 mov	 edx, DWORD PTR [eax]
  0003b	52		 push	 edx
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  00042	83 c4 18	 add	 esp, 24			; 00000018H
  00045	3b f4		 cmp	 esi, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 640  : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
;	COMDAT ?strstr@@YAPADQADQBD@Z
_TEXT	SEGMENT
__String$ = 8						; size = 4
__SubString$ = 12					; size = 4
?strstr@@YAPADQADQBD@Z PROC				; strstr, COMDAT

; 536  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 537  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 0c	 mov	 eax, DWORD PTR __SubString$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR __String$[ebp]
  00027	51		 push	 ecx
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strstr
  0002e	83 c4 08	 add	 esp, 8
  00031	3b f4		 cmp	 esi, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 538  :     }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?strstr@@YAPADQADQBD@Z ENDP				; strstr
_TEXT	ENDS
END
