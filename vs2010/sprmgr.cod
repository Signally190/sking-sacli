; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Administrator\Desktop\????? ??\????? ??\Client Source Code\system\sprmgr.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?lpBattleSurface@@3PAUIDirectDrawSurface@@A	; lpBattleSurface
PUBLIC	?SurfaceSizeX@@3HA				; SurfaceSizeX
PUBLIC	?SurfaceSizeY@@3HA				; SurfaceSizeY
PUBLIC	?SurfaceDate@@3IA				; SurfaceDate
PUBLIC	?SpriteInfo@@3PAUSPRITE_INFO@@A			; SpriteInfo
PUBLIC	?SurfaceInfo@@3PAUsurfaceInfo@@A		; SurfaceInfo
PUBLIC	?SurfaceCnt@@3HA				; SurfaceCnt
PUBLIC	?VramSurfaceCnt@@3HA				; VramSurfaceCnt
PUBLIC	?SysramSurfaceCnt@@3HA				; SysramSurfaceCnt
PUBLIC	?SurfaceSearchPoint@@3HA			; SurfaceSearchPoint
_BSS	SEGMENT
?lpBattleSurface@@3PAUIDirectDrawSurface@@A DD 01H DUP (?) ; lpBattleSurface
?SurfaceSizeX@@3HA DD 01H DUP (?)			; SurfaceSizeX
?SurfaceSizeY@@3HA DD 01H DUP (?)			; SurfaceSizeY
?SpriteInfo@@3PAUSPRITE_INFO@@A DB 0b71b00H DUP (?)	; SpriteInfo
?SurfaceInfo@@3PAUsurfaceInfo@@A DB 015000H DUP (?)	; SurfaceInfo
?SurfaceCnt@@3HA DD 01H DUP (?)				; SurfaceCnt
?VramSurfaceCnt@@3HA DD 01H DUP (?)			; VramSurfaceCnt
?SysramSurfaceCnt@@3HA DD 01H DUP (?)			; SysramSurfaceCnt
?SurfaceSearchPoint@@3HA DD 01H DUP (?)			; SurfaceSearchPoint
_BSS	ENDS
_DATA	SEGMENT
?SurfaceDate@@3IA DD 03H				; SurfaceDate
?FontPal@@3PAKA DD 0ffffffH				; FontPal
	DD	0ffff00H
	DD	0ff00ffH
	DD	0ff0000H
	DD	0ffffH
	DD	0ff00H
	DD	0ffH
	DD	0a4a0a0H
	DD	0f0caa6H
	DD	0c0dcc0H
	DD	08cffH
	DD	0247fffH
_DATA	ENDS
PUBLIC	?InitOffScreenSurface@@YAHXZ			; InitOffScreenSurface
PUBLIC	?InitSurfaceInfo@@YAXXZ				; InitSurfaceInfo
PUBLIC	?InitSpriteInfo@@YAXXZ				; InitSpriteInfo
PUBLIC	?LoadBmp@@YAHH@Z				; LoadBmp
PUBLIC	?AllocateBmpToSurface@@YAXH@Z			; AllocateBmpToSurface
EXTRN	?ClearSurface@@YAXPAUIDirectDrawSurface@@@Z:PROC ; ClearSurface
EXTRN	?CreateSurface@@YAPAUIDirectDrawSurface@@FFKI@Z:PROC ; CreateSurface
EXTRN	?DrawBitmapToSurface2@@YAXPAUsurfaceInfo@@HHHHPAUtagBITMAPINFO@@@Z:PROC ; DrawBitmapToSurface2
EXTRN	?realGetImage@@YAHHPAPAEPAH1@Z:PROC		; realGetImage
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_UninitUse:PROC
EXTRN	?ResoMode@@3HA:DWORD				; ResoMode
EXTRN	?pRealBinBits@@3PADA:DWORD			; pRealBinBits
EXTRN	?RealBinWidth@@3HA:DWORD			; RealBinWidth
EXTRN	?RealBinHeight@@3HA:DWORD			; RealBinHeight
EXTRN	?NewColor16Flg@@3HA:DWORD			; NewColor16Flg
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\sprmgr.cpp
;	COMDAT ?AllocateBmpToSurface@@YAXH@Z
_TEXT	SEGMENT
$T1 = -389						; size = 1
_lpSurfaceInfo$2 = -188					; size = 4
_prevSurfaceInfo$ = -176				; size = 4
_vramFullFlag$ = -164					; size = 4
_amariSizeY$ = -152					; size = 4
_amariSizeX$ = -140					; size = 4
_SurfaceSearchPointBak$ = -128				; size = 4
_totalSurfaceCnt$ = -116				; size = 4
_totalSurface$ = -104					; size = 4
_surfaceCntY$ = -92					; size = 4
_surfaceCntX$ = -80					; size = 4
_sizeY$ = -68						; size = 4
_sizeX$ = -56						; size = 4
_offsetY$ = -44						; size = 4
_offsetX$ = -32						; size = 4
_bmpHeight$ = -20					; size = 4
_bmpWidth$ = -8						; size = 4
_bmpNo$ = 8						; size = 4
?AllocateBmpToSurface@@YAXH@Z PROC			; AllocateBmpToSurface, COMDAT

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 01 00
	00		 sub	 esp, 396		; 0000018cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 74 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-396]
  00012	b9 63 00 00 00	 mov	 ecx, 99			; 00000063H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	c6 85 7b fe ff
	ff 00		 mov	 BYTE PTR $T1[ebp], 0

; 45   : 	int bmpWidth = RealBinWidth;	// ????????

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ?RealBinWidth@@3HA ; RealBinWidth
  0002a	89 45 f8	 mov	 DWORD PTR _bmpWidth$[ebp], eax

; 46   : 	int bmpHeight = RealBinHeight; 	// ???????

  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?RealBinHeight@@3HA ; RealBinHeight
  00032	89 45 ec	 mov	 DWORD PTR _bmpHeight$[ebp], eax

; 47   : 
; 48   : 	int offsetX, offsetY; 			// ???????????????
; 49   : 	int sizeX, sizeY;				// ??????
; 50   : 	int surfaceCntX;				// ???????????
; 51   : 	int surfaceCntY;				// ???????????
; 52   : 	int totalSurface;				// ??????????
; 53   : 	int totalSurfaceCnt = 0;		// ??????????????? ??????? ?

  00035	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _totalSurfaceCnt$[ebp], 0

; 54   : 	int	SurfaceSearchPointBak = SurfaceSearchPoint; // ???????????????t???

  0003c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SurfaceSearchPoint@@3HA ; SurfaceSearchPoint
  00041	89 45 80	 mov	 DWORD PTR _SurfaceSearchPointBak$[ebp], eax

; 55   : 	int amariSizeX = FALSE;		// ???????????

  00044	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _amariSizeX$[ebp], 0

; 56   : 	int amariSizeY = FALSE;		// ??????????

  0004e	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _amariSizeY$[ebp], 0

; 57   : 	BOOL vramFullFlag = FALSE; 		// VRAM?????????

  00058	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _vramFullFlag$[ebp], 0

; 58   : 	SURFACE_INFO *prevSurfaceInfo; 	// q???????????Bl?????
; 59   : 	offsetX = 0;

  00062	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _offsetX$[ebp], 0

; 60   : #ifdef _READ16BITBMP
; 61   : 	SURFACE_INFO *prevSurfaceInfoSys;
; 62   : 	RECT rect = { 0,0,SurfaceSizeX,SurfaceSizeY };
; 63   : 	if (bmpNo >= OLD_GRAPHICS_START) offsetY = 0;
; 64   : 	else
; 65   : #endif
; 66   : 		offsetY = bmpHeight;

  00069	8b 45 ec	 mov	 eax, DWORD PTR _bmpHeight$[ebp]
  0006c	89 45 d4	 mov	 DWORD PTR _offsetY$[ebp], eax

; 67   : 	surfaceCntX = bmpWidth / SURFACE_WIDTH;

  0006f	8b 45 f8	 mov	 eax, DWORD PTR _bmpWidth$[ebp]
  00072	99		 cdq
  00073	83 e2 3f	 and	 edx, 63			; 0000003fH
  00076	03 c2		 add	 eax, edx
  00078	c1 f8 06	 sar	 eax, 6
  0007b	89 45 b0	 mov	 DWORD PTR _surfaceCntX$[ebp], eax

; 68   : 	if ((amariSizeX = bmpWidth % SURFACE_WIDTH)) {

  0007e	8b 45 f8	 mov	 eax, DWORD PTR _bmpWidth$[ebp]
  00081	25 3f 00 00 80	 and	 eax, -2147483585	; 8000003fH
  00086	79 05		 jns	 SHORT $LN32@AllocateBm
  00088	48		 dec	 eax
  00089	83 c8 c0	 or	 eax, -64		; ffffffc0H
  0008c	40		 inc	 eax
$LN32@AllocateBm:
  0008d	89 85 74 ff ff
	ff		 mov	 DWORD PTR _amariSizeX$[ebp], eax
  00093	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _amariSizeX$[ebp], 0
  0009a	74 09		 je	 SHORT $LN7@AllocateBm

; 69   : 		surfaceCntX++;

  0009c	8b 45 b0	 mov	 eax, DWORD PTR _surfaceCntX$[ebp]
  0009f	83 c0 01	 add	 eax, 1
  000a2	89 45 b0	 mov	 DWORD PTR _surfaceCntX$[ebp], eax
$LN7@AllocateBm:

; 70   : 	}
; 71   : 
; 72   : 	surfaceCntY = bmpHeight / SURFACE_HEIGHT;

  000a5	8b 45 ec	 mov	 eax, DWORD PTR _bmpHeight$[ebp]
  000a8	99		 cdq
  000a9	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  000ae	f7 f9		 idiv	 ecx
  000b0	89 45 a4	 mov	 DWORD PTR _surfaceCntY$[ebp], eax

; 73   : 	if ((amariSizeY = bmpHeight % SURFACE_HEIGHT)) {

  000b3	8b 45 ec	 mov	 eax, DWORD PTR _bmpHeight$[ebp]
  000b6	99		 cdq
  000b7	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  000bc	f7 f9		 idiv	 ecx
  000be	89 95 68 ff ff
	ff		 mov	 DWORD PTR _amariSizeY$[ebp], edx
  000c4	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR _amariSizeY$[ebp], 0
  000cb	74 09		 je	 SHORT $LN8@AllocateBm

; 74   : 		surfaceCntY++;		// ??????

  000cd	8b 45 a4	 mov	 eax, DWORD PTR _surfaceCntY$[ebp]
  000d0	83 c0 01	 add	 eax, 1
  000d3	89 45 a4	 mov	 DWORD PTR _surfaceCntY$[ebp], eax
$LN8@AllocateBm:

; 75   : 	}
; 76   : 	totalSurface = surfaceCntX * surfaceCntY;

  000d6	8b 45 b0	 mov	 eax, DWORD PTR _surfaceCntX$[ebp]
  000d9	0f af 45 a4	 imul	 eax, DWORD PTR _surfaceCntY$[ebp]
  000dd	89 45 98	 mov	 DWORD PTR _totalSurface$[ebp], eax

; 77   : #ifdef _READ16BITBMP
; 78   : 	if (bmpNo < OLD_GRAPHICS_START)
; 79   : #endif
; 80   : 	{
; 81   : 		if ((RealBinWidth & 3)) RealBinWidth += 4 - RealBinWidth & 3;

  000e0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?RealBinWidth@@3HA ; RealBinWidth
  000e5	83 e0 03	 and	 eax, 3
  000e8	74 19		 je	 SHORT $LN2@AllocateBm
  000ea	b8 04 00 00 00	 mov	 eax, 4
  000ef	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?RealBinWidth@@3HA ; RealBinWidth
  000f5	83 e0 03	 and	 eax, 3
  000f8	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?RealBinWidth@@3HA ; RealBinWidth
  000fe	a3 00 00 00 00	 mov	 DWORD PTR ?RealBinWidth@@3HA, eax ; RealBinWidth
$LN2@AllocateBm:

; 82   : 	}
; 83   : 	while (1) {

  00103	b8 01 00 00 00	 mov	 eax, 1
  00108	85 c0		 test	 eax, eax
  0010a	0f 84 b2 02 00
	00		 je	 $LN1@AllocateBm

; 84   : 		if (SurfaceInfo[SurfaceSearchPoint].date < SurfaceDate - SURACE_BMP_DEATH_DATE) {

  00110	6b 05 00 00 00
	00 1c		 imul	 eax, DWORD PTR ?SurfaceSearchPoint@@3HA, 28 ; SurfaceSearchPoint
  00117	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?SurfaceDate@@3IA ; SurfaceDate
  0011d	83 e9 02	 sub	 ecx, 2
  00120	39 88 10 00 00
	00		 cmp	 DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[eax+16], ecx
  00126	0f 83 61 02 00
	00		 jae	 $LN10@AllocateBm

; 85   : #ifdef _STONDEBUG_		
; 86   : 			SurfaceUseCnt++;
; 87   : #endif
; 88   : 			// 已在使用中
; 89   : 			if (SurfaceInfo[SurfaceSearchPoint].bmpNo != -1) {

  0012c	6b 05 00 00 00
	00 1c		 imul	 eax, DWORD PTR ?SurfaceSearchPoint@@3HA, 28 ; SurfaceSearchPoint
  00133	83 b8 0c 00 00
	00 ff		 cmp	 DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[eax+12], -1
  0013a	74 5b		 je	 SHORT $LN11@AllocateBm

; 90   : 				SURFACE_INFO *lpSurfaceInfo;
; 91   : #ifdef _READ16BITBMP
; 92   : 				SURFACE_INFO *lpSurfaceInfoSys;
; 93   : #endif
; 94   : 				lpSurfaceInfo = SpriteInfo[SurfaceInfo[SurfaceSearchPoint].bmpNo].lpSurfaceInfo;

  0013c	6b 05 00 00 00
	00 1c		 imul	 eax, DWORD PTR ?SurfaceSearchPoint@@3HA, 28 ; SurfaceSearchPoint
  00143	6b 88 0c 00 00
	00 0c		 imul	 ecx, DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[eax+12], 12
  0014a	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?SpriteInfo@@3PAUSPRITE_INFO@@A[ecx]
  00150	89 95 44 ff ff
	ff		 mov	 DWORD PTR _lpSurfaceInfo$2[ebp], edx

; 95   : 				SpriteInfo[SurfaceInfo[SurfaceSearchPoint].bmpNo].lpSurfaceInfo = NULL;

  00156	6b 05 00 00 00
	00 1c		 imul	 eax, DWORD PTR ?SurfaceSearchPoint@@3HA, 28 ; SurfaceSearchPoint
  0015d	6b 88 0c 00 00
	00 0c		 imul	 ecx, DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[eax+12], 12
  00164	c7 81 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?SpriteInfo@@3PAUSPRITE_INFO@@A[ecx], 0

; 96   : #ifdef _READ16BITBMP
; 97   : 				if (g_bUseAlpha) {
; 98   : 					lpSurfaceInfoSys = SpriteInfo[SurfaceInfo[SurfaceSearchPoint].bmpNo].lpSurfaceInfoSys;
; 99   : 					SpriteInfo[SurfaceInfo[SurfaceSearchPoint].bmpNo].lpSurfaceInfoSys = NULL;
; 100  : 				}
; 101  : #endif
; 102  : 				for (; lpSurfaceInfo != NULL;

  0016e	eb 0f		 jmp	 SHORT $LN6@AllocateBm
$LN4@AllocateBm:

; 103  : 					lpSurfaceInfo = lpSurfaceInfo->pNext) {

  00170	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _lpSurfaceInfo$2[ebp]
  00176	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00179	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _lpSurfaceInfo$2[ebp], ecx
$LN6@AllocateBm:

; 96   : #ifdef _READ16BITBMP
; 97   : 				if (g_bUseAlpha) {
; 98   : 					lpSurfaceInfoSys = SpriteInfo[SurfaceInfo[SurfaceSearchPoint].bmpNo].lpSurfaceInfoSys;
; 99   : 					SpriteInfo[SurfaceInfo[SurfaceSearchPoint].bmpNo].lpSurfaceInfoSys = NULL;
; 100  : 				}
; 101  : #endif
; 102  : 				for (; lpSurfaceInfo != NULL;

  0017f	83 bd 44 ff ff
	ff 00		 cmp	 DWORD PTR _lpSurfaceInfo$2[ebp], 0
  00186	74 0f		 je	 SHORT $LN11@AllocateBm

; 104  : 					lpSurfaceInfo->bmpNo = -1;

  00188	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _lpSurfaceInfo$2[ebp]
  0018e	c7 40 0c ff ff
	ff ff		 mov	 DWORD PTR [eax+12], -1

; 105  : #ifdef _READ16BITBMP
; 106  : 					if (g_bUseAlpha)	lpSurfaceInfoSys->bmpNo = -1;
; 107  : #endif
; 108  : #ifdef _STONDEBUG_		
; 109  : 					SurfaceUseCnt--;
; 110  : #endif
; 111  : 				}

  00195	eb d9		 jmp	 SHORT $LN4@AllocateBm
$LN11@AllocateBm:

; 112  : 			}
; 113  : 			if (SpriteInfo[bmpNo].lpSurfaceInfo == NULL) {

  00197	6b 45 08 0c	 imul	 eax, DWORD PTR _bmpNo$[ebp], 12
  0019b	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR ?SpriteInfo@@3PAUSPRITE_INFO@@A[eax], 0
  001a2	75 18		 jne	 SHORT $LN12@AllocateBm

; 114  : 				// 第一张图的surfaceinfo
; 115  : 				SpriteInfo[bmpNo].lpSurfaceInfo = &SurfaceInfo[SurfaceSearchPoint];

  001a4	6b 05 00 00 00
	00 1c		 imul	 eax, DWORD PTR ?SurfaceSearchPoint@@3HA, 28 ; SurfaceSearchPoint
  001ab	05 00 00 00 00	 add	 eax, OFFSET ?SurfaceInfo@@3PAUsurfaceInfo@@A ; SurfaceInfo
  001b0	6b 4d 08 0c	 imul	 ecx, DWORD PTR _bmpNo$[ebp], 12
  001b4	89 81 00 00 00
	00		 mov	 DWORD PTR ?SpriteInfo@@3PAUSPRITE_INFO@@A[ecx], eax

; 116  : #ifdef _READ16BITBMP
; 117  : 				if (g_bUseAlpha)	SpriteInfo[bmpNo].lpSurfaceInfoSys = &SurfaceInfoSys[SurfaceSearchPoint];
; 118  : #endif
; 119  : 			}
; 120  : 			else {

  001ba	eb 2b		 jmp	 SHORT $LN13@AllocateBm
$LN12@AllocateBm:

; 121  : 				// 指向下一张surfaceinfo
; 122  : 				prevSurfaceInfo->pNext = &SurfaceInfo[SurfaceSearchPoint];

  001bc	80 bd 7b fe ff
	ff 00		 cmp	 BYTE PTR $T1[ebp], 0
  001c3	75 0d		 jne	 SHORT $LN29@AllocateBm
  001c5	68 00 00 00 00	 push	 OFFSET $LN30@AllocateBm
  001ca	e8 00 00 00 00	 call	 __RTC_UninitUse
  001cf	83 c4 04	 add	 esp, 4
$LN29@AllocateBm:
  001d2	6b 05 00 00 00
	00 1c		 imul	 eax, DWORD PTR ?SurfaceSearchPoint@@3HA, 28 ; SurfaceSearchPoint
  001d9	05 00 00 00 00	 add	 eax, OFFSET ?SurfaceInfo@@3PAUsurfaceInfo@@A ; SurfaceInfo
  001de	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _prevSurfaceInfo$[ebp]
  001e4	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN13@AllocateBm:

; 123  : #ifdef _READ16BITBMP
; 124  : 				if (g_bUseAlpha)	prevSurfaceInfoSys->pNext = &SurfaceInfoSys[SurfaceSearchPoint];
; 125  : #endif
; 126  : 			}
; 127  : 			SurfaceInfo[SurfaceSearchPoint].bmpNo = bmpNo;

  001e7	6b 05 00 00 00
	00 1c		 imul	 eax, DWORD PTR ?SurfaceSearchPoint@@3HA, 28 ; SurfaceSearchPoint
  001ee	8b 4d 08	 mov	 ecx, DWORD PTR _bmpNo$[ebp]
  001f1	89 88 0c 00 00
	00		 mov	 DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[eax+12], ecx

; 128  : #ifdef _READ16BITBMP
; 129  : 			if (g_bUseAlpha) SurfaceInfoSys[SurfaceSearchPoint].bmpNo = bmpNo;
; 130  : #endif
; 131  : 			if (ResoMode == 1) {

  001f7	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?ResoMode@@3HA, 1 ; ResoMode
  001fe	75 31		 jne	 SHORT $LN14@AllocateBm

; 132  : 				SurfaceInfo[SurfaceSearchPoint].offsetX = offsetX / 2;

  00200	8b 45 e0	 mov	 eax, DWORD PTR _offsetX$[ebp]
  00203	99		 cdq
  00204	2b c2		 sub	 eax, edx
  00206	d1 f8		 sar	 eax, 1
  00208	6b 0d 00 00 00
	00 1c		 imul	 ecx, DWORD PTR ?SurfaceSearchPoint@@3HA, 28 ; SurfaceSearchPoint
  0020f	66 89 81 14 00
	00 00		 mov	 WORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[ecx+20], ax

; 133  : #ifdef _READ16BITBMP
; 134  : 				if (g_bUseAlpha) SurfaceInfoSys[SurfaceSearchPoint].offsetX = offsetX / 2;
; 135  : 				if (bmpNo >= OLD_GRAPHICS_START) {
; 136  : 					SurfaceInfo[SurfaceSearchPoint].offsetY = offsetY / 2;
; 137  : 					if (g_bUseAlpha) SurfaceInfoSys[SurfaceSearchPoint].offsetY = offsetY / 2;
; 138  : 				}
; 139  : 				else
; 140  : #endif
; 141  : 				{
; 142  : 					SurfaceInfo[SurfaceSearchPoint].offsetY = (bmpHeight - offsetY) / 2;

  00216	8b 45 ec	 mov	 eax, DWORD PTR _bmpHeight$[ebp]
  00219	2b 45 d4	 sub	 eax, DWORD PTR _offsetY$[ebp]
  0021c	99		 cdq
  0021d	2b c2		 sub	 eax, edx
  0021f	d1 f8		 sar	 eax, 1
  00221	6b 0d 00 00 00
	00 1c		 imul	 ecx, DWORD PTR ?SurfaceSearchPoint@@3HA, 28 ; SurfaceSearchPoint
  00228	66 89 81 16 00
	00 00		 mov	 WORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[ecx+22], ax

; 143  : #ifdef _READ16BITBMP
; 144  : 					if (g_bUseAlpha) SurfaceInfoSys[SurfaceSearchPoint].offsetY = (bmpHeight - offsetY) / 2;
; 145  : #endif
; 146  : 				}
; 147  : 			}
; 148  : 			else {

  0022f	eb 26		 jmp	 SHORT $LN15@AllocateBm
$LN14@AllocateBm:

; 149  : 				SurfaceInfo[SurfaceSearchPoint].offsetX = offsetX;

  00231	6b 05 00 00 00
	00 1c		 imul	 eax, DWORD PTR ?SurfaceSearchPoint@@3HA, 28 ; SurfaceSearchPoint
  00238	66 8b 4d e0	 mov	 cx, WORD PTR _offsetX$[ebp]
  0023c	66 89 88 14 00
	00 00		 mov	 WORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[eax+20], cx

; 150  : #ifdef _READ16BITBMP
; 151  : 				if (g_bUseAlpha) SurfaceInfoSys[SurfaceSearchPoint].offsetX = offsetX;
; 152  : 				if (bmpNo >= OLD_GRAPHICS_START) {
; 153  : 					SurfaceInfo[SurfaceSearchPoint].offsetY = offsetY;
; 154  : 					if (g_bUseAlpha) SurfaceInfoSys[SurfaceSearchPoint].offsetY = offsetY;
; 155  : 				}
; 156  : 				else
; 157  : #endif
; 158  : 				{
; 159  : 					SurfaceInfo[SurfaceSearchPoint].offsetY = bmpHeight - offsetY;

  00243	8b 45 ec	 mov	 eax, DWORD PTR _bmpHeight$[ebp]
  00246	2b 45 d4	 sub	 eax, DWORD PTR _offsetY$[ebp]
  00249	6b 0d 00 00 00
	00 1c		 imul	 ecx, DWORD PTR ?SurfaceSearchPoint@@3HA, 28 ; SurfaceSearchPoint
  00250	66 89 81 16 00
	00 00		 mov	 WORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[ecx+22], ax
$LN15@AllocateBm:

; 160  : #ifdef _READ16BITBMP
; 161  : 					if (g_bUseAlpha)	SurfaceInfoSys[SurfaceSearchPoint].offsetY = bmpHeight - offsetY;
; 162  : #endif
; 163  : 				}
; 164  : 			}
; 165  : 
; 166  : 			if (offsetX >= bmpWidth - SURFACE_WIDTH && amariSizeX) {

  00257	8b 45 f8	 mov	 eax, DWORD PTR _bmpWidth$[ebp]
  0025a	83 e8 40	 sub	 eax, 64			; 00000040H
  0025d	39 45 e0	 cmp	 DWORD PTR _offsetX$[ebp], eax
  00260	7c 2a		 jl	 SHORT $LN16@AllocateBm
  00262	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _amariSizeX$[ebp], 0
  00269	74 21		 je	 SHORT $LN16@AllocateBm

; 167  : 				ClearSurface(SurfaceInfo[SurfaceSearchPoint].lpSurface);

  0026b	6b 05 00 00 00
	00 1c		 imul	 eax, DWORD PTR ?SurfaceSearchPoint@@3HA, 28 ; SurfaceSearchPoint
  00272	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[eax]
  00278	51		 push	 ecx
  00279	e8 00 00 00 00	 call	 ?ClearSurface@@YAXPAUIDirectDrawSurface@@@Z ; ClearSurface
  0027e	83 c4 04	 add	 esp, 4

; 168  : #ifdef _READ16BITBMP
; 169  : 				if (g_bUseAlpha) {
; 170  : 					ClearSurface(SurfaceInfoSys[SurfaceSearchPoint].lpSurface);
; 171  : 					if (SurfaceInfo[SurfaceSearchPoint].lpAlphaData)
; 172  : 						memset(SurfaceInfo[SurfaceSearchPoint].lpAlphaData, 0, SurfaceSizeX*SurfaceSizeY);
; 173  : 				}
; 174  : #endif
; 175  : 				sizeX = amariSizeX;

  00281	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _amariSizeX$[ebp]
  00287	89 45 c8	 mov	 DWORD PTR _sizeX$[ebp], eax
  0028a	eb 07		 jmp	 SHORT $LN17@AllocateBm
$LN16@AllocateBm:

; 176  : 			}
; 177  : 			else sizeX = SURFACE_WIDTH;

  0028c	c7 45 c8 40 00
	00 00		 mov	 DWORD PTR _sizeX$[ebp], 64 ; 00000040H
$LN17@AllocateBm:

; 178  : 
; 179  : #ifdef _READ16BITBMP
; 180  : 			if (bmpNo >= OLD_GRAPHICS_START) {
; 181  : 				if (offsetY >= bmpHeight - SURFACE_HEIGHT && amariSizeY) {
; 182  : 					ClearSurface(SurfaceInfo[SurfaceSearchPoint].lpSurface);
; 183  : 					if (g_bUseAlpha) {
; 184  : 						ClearSurface(SurfaceInfoSys[SurfaceSearchPoint].lpSurface);
; 185  : 						if (SurfaceInfo[SurfaceSearchPoint].lpAlphaData)
; 186  : 							memset(SurfaceInfo[SurfaceSearchPoint].lpAlphaData, 0, SurfaceSizeX*SurfaceSizeY);
; 187  : 					}
; 188  : 					sizeY = amariSizeY;
; 189  : 				}
; 190  : 				else sizeY = SURFACE_HEIGHT;
; 191  : 			}
; 192  : 			else
; 193  : #endif
; 194  : 			{
; 195  : 				if (offsetY - SURFACE_HEIGHT <= 0 && amariSizeY) {

  00293	8b 45 d4	 mov	 eax, DWORD PTR _offsetY$[ebp]
  00296	83 e8 30	 sub	 eax, 48			; 00000030H
  00299	85 c0		 test	 eax, eax
  0029b	7f 35		 jg	 SHORT $LN18@AllocateBm
  0029d	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR _amariSizeY$[ebp], 0
  002a4	74 2c		 je	 SHORT $LN18@AllocateBm

; 196  : 					if (sizeX != amariSizeX) {

  002a6	8b 45 c8	 mov	 eax, DWORD PTR _sizeX$[ebp]
  002a9	3b 85 74 ff ff
	ff		 cmp	 eax, DWORD PTR _amariSizeX$[ebp]
  002af	74 16		 je	 SHORT $LN20@AllocateBm

; 197  : 						ClearSurface(SurfaceInfo[SurfaceSearchPoint].lpSurface);

  002b1	6b 05 00 00 00
	00 1c		 imul	 eax, DWORD PTR ?SurfaceSearchPoint@@3HA, 28 ; SurfaceSearchPoint
  002b8	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[eax]
  002be	51		 push	 ecx
  002bf	e8 00 00 00 00	 call	 ?ClearSurface@@YAXPAUIDirectDrawSurface@@@Z ; ClearSurface
  002c4	83 c4 04	 add	 esp, 4
$LN20@AllocateBm:

; 198  : #ifdef _READ16BITBMP
; 199  : 						if (g_bUseAlpha) ClearSurface(SurfaceInfoSys[SurfaceSearchPoint].lpSurface);
; 200  : #endif
; 201  : 					}
; 202  : 					sizeY = amariSizeY;

  002c7	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _amariSizeY$[ebp]
  002cd	89 45 bc	 mov	 DWORD PTR _sizeY$[ebp], eax
  002d0	eb 07		 jmp	 SHORT $LN19@AllocateBm
$LN18@AllocateBm:

; 203  : 				}
; 204  : 				else sizeY = SURFACE_HEIGHT;

  002d2	c7 45 bc 30 00
	00 00		 mov	 DWORD PTR _sizeY$[ebp], 48 ; 00000030H
$LN19@AllocateBm:

; 205  : 			}
; 206  : 
; 207  : #ifdef _READ16BITBMP
; 208  : 			SurfaceInfo[SurfaceSearchPoint].useAlpha = useAlpha;
; 209  : 			SurfaceInfoSys[SurfaceSearchPoint].useAlpha = useAlpha;
; 210  : 			if (bmpNo >= OLD_GRAPHICS_START) {
; 211  : 				Draw16BitmapToSurface2(&SurfaceInfo[SurfaceSearchPoint],
; 212  : 					SurfaceInfoSys[SurfaceSearchPoint].lpSurface,
; 213  : 					offsetX,
; 214  : 					offsetY,
; 215  : 					sizeX,
; 216  : 					sizeY,
; 217  : 					NULL);
; 218  : 			}
; 219  : 			else {
; 220  : 				if (g_bUseAlpha) {
; 221  : 					DrawBitmapToSurface2(&SurfaceInfo[SurfaceSearchPoint],
; 222  : 						SurfaceInfoSys[SurfaceSearchPoint].lpSurface,
; 223  : 						offsetX,
; 224  : 						offsetY - 1,
; 225  : 						sizeX,
; 226  : 						sizeY,
; 227  : 						NULL);
; 228  : 				}
; 229  : 				else {
; 230  : 					DrawBitmapToSurface2(SurfaceInfo[SurfaceSearchPoint].lpSurface,
; 231  : 						offsetX,
; 232  : 						offsetY - 1,
; 233  : 						sizeX,
; 234  : 						sizeY,
; 235  : 						NULL);
; 236  : 				}
; 237  : 			}
; 238  : #else
; 239  : 			DrawBitmapToSurface2(&SurfaceInfo[SurfaceSearchPoint],

  002d9	6a 00		 push	 0
  002db	8b 45 bc	 mov	 eax, DWORD PTR _sizeY$[ebp]
  002de	50		 push	 eax
  002df	8b 4d c8	 mov	 ecx, DWORD PTR _sizeX$[ebp]
  002e2	51		 push	 ecx
  002e3	8b 55 d4	 mov	 edx, DWORD PTR _offsetY$[ebp]
  002e6	83 ea 01	 sub	 edx, 1
  002e9	52		 push	 edx
  002ea	8b 45 e0	 mov	 eax, DWORD PTR _offsetX$[ebp]
  002ed	50		 push	 eax
  002ee	6b 0d 00 00 00
	00 1c		 imul	 ecx, DWORD PTR ?SurfaceSearchPoint@@3HA, 28 ; SurfaceSearchPoint
  002f5	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?SurfaceInfo@@3PAUsurfaceInfo@@A ; SurfaceInfo
  002fb	51		 push	 ecx
  002fc	e8 00 00 00 00	 call	 ?DrawBitmapToSurface2@@YAXPAUsurfaceInfo@@HHHHPAUtagBITMAPINFO@@@Z ; DrawBitmapToSurface2
  00301	83 c4 18	 add	 esp, 24			; 00000018H

; 240  : 				offsetX,
; 241  : 				offsetY - 1,
; 242  : 				sizeX,
; 243  : 				sizeY,
; 244  : 				NULL);
; 245  : #endif
; 246  : 			totalSurfaceCnt++;

  00304	8b 45 8c	 mov	 eax, DWORD PTR _totalSurfaceCnt$[ebp]
  00307	83 c0 01	 add	 eax, 1
  0030a	89 45 8c	 mov	 DWORD PTR _totalSurfaceCnt$[ebp], eax

; 247  : 			// 所有的图都已存入offscreen
; 248  : 			if (totalSurfaceCnt >= totalSurface) {

  0030d	8b 45 8c	 mov	 eax, DWORD PTR _totalSurfaceCnt$[ebp]
  00310	3b 45 98	 cmp	 eax, DWORD PTR _totalSurface$[ebp]
  00313	7c 39		 jl	 SHORT $LN21@AllocateBm

; 249  : 				SurfaceInfo[SurfaceSearchPoint].pNext = NULL;

  00315	6b 05 00 00 00
	00 1c		 imul	 eax, DWORD PTR ?SurfaceSearchPoint@@3HA, 28 ; SurfaceSearchPoint
  0031c	c7 80 18 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[eax+24], 0

; 250  : #ifdef _READ16BITBMP
; 251  : 				if (g_bUseAlpha)	SurfaceInfoSys[SurfaceSearchPoint].pNext = NULL;
; 252  : #endif
; 253  : 				SurfaceSearchPoint++;

  00326	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SurfaceSearchPoint@@3HA ; SurfaceSearchPoint
  0032b	83 c0 01	 add	 eax, 1
  0032e	a3 00 00 00 00	 mov	 DWORD PTR ?SurfaceSearchPoint@@3HA, eax ; SurfaceSearchPoint

; 254  : 
; 255  : 				if (SurfaceSearchPoint >= SurfaceCnt) SurfaceSearchPoint = 0;

  00333	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SurfaceSearchPoint@@3HA ; SurfaceSearchPoint
  00338	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?SurfaceCnt@@3HA ; SurfaceCnt
  0033e	7c 0a		 jl	 SHORT $LN23@AllocateBm
  00340	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?SurfaceSearchPoint@@3HA, 0 ; SurfaceSearchPoint
$LN23@AllocateBm:

; 256  : 				break;

  0034a	eb 76		 jmp	 SHORT $LN1@AllocateBm

; 257  : 			}
; 258  : 			else {

  0034c	eb 3f		 jmp	 SHORT $LN10@AllocateBm
$LN21@AllocateBm:

; 259  : 				prevSurfaceInfo = &SurfaceInfo[SurfaceSearchPoint];

  0034e	6b 05 00 00 00
	00 1c		 imul	 eax, DWORD PTR ?SurfaceSearchPoint@@3HA, 28 ; SurfaceSearchPoint
  00355	05 00 00 00 00	 add	 eax, OFFSET ?SurfaceInfo@@3PAUsurfaceInfo@@A ; SurfaceInfo
  0035a	c6 85 7b fe ff
	ff 01		 mov	 BYTE PTR $T1[ebp], 1
  00361	89 85 50 ff ff
	ff		 mov	 DWORD PTR _prevSurfaceInfo$[ebp], eax

; 260  : #ifdef _READ16BITBMP
; 261  : 				if (g_bUseAlpha)	prevSurfaceInfoSys = &SurfaceInfoSys[SurfaceSearchPoint];
; 262  : #endif
; 263  : 				if (offsetX >= bmpWidth - SURFACE_WIDTH) {

  00367	8b 45 f8	 mov	 eax, DWORD PTR _bmpWidth$[ebp]
  0036a	83 e8 40	 sub	 eax, 64			; 00000040H
  0036d	39 45 e0	 cmp	 DWORD PTR _offsetX$[ebp], eax
  00370	7c 12		 jl	 SHORT $LN24@AllocateBm

; 264  : 					offsetX = 0;

  00372	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _offsetX$[ebp], 0

; 265  : #ifdef _READ16BITBMP
; 266  : 					if (bmpNo >= OLD_GRAPHICS_START) offsetY += SURFACE_HEIGHT;
; 267  : 					else
; 268  : #endif
; 269  : 						offsetY -= SURFACE_HEIGHT;

  00379	8b 45 d4	 mov	 eax, DWORD PTR _offsetY$[ebp]
  0037c	83 e8 30	 sub	 eax, 48			; 00000030H
  0037f	89 45 d4	 mov	 DWORD PTR _offsetY$[ebp], eax

; 270  : 				}
; 271  : 				else {

  00382	eb 09		 jmp	 SHORT $LN10@AllocateBm
$LN24@AllocateBm:

; 272  : 					offsetX += SURFACE_WIDTH;

  00384	8b 45 e0	 mov	 eax, DWORD PTR _offsetX$[ebp]
  00387	83 c0 40	 add	 eax, 64			; 00000040H
  0038a	89 45 e0	 mov	 DWORD PTR _offsetX$[ebp], eax
$LN10@AllocateBm:

; 273  : 				}
; 274  : 			}
; 275  : 		}
; 276  : 		SurfaceSearchPoint++;

  0038d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SurfaceSearchPoint@@3HA ; SurfaceSearchPoint
  00392	83 c0 01	 add	 eax, 1
  00395	a3 00 00 00 00	 mov	 DWORD PTR ?SurfaceSearchPoint@@3HA, eax ; SurfaceSearchPoint

; 277  : 		if (SurfaceSearchPoint >= SurfaceCnt) SurfaceSearchPoint = 0;

  0039a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SurfaceSearchPoint@@3HA ; SurfaceSearchPoint
  0039f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?SurfaceCnt@@3HA ; SurfaceCnt
  003a5	7c 0a		 jl	 SHORT $LN26@AllocateBm
  003a7	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?SurfaceSearchPoint@@3HA, 0 ; SurfaceSearchPoint
$LN26@AllocateBm:

; 278  : 		if (SurfaceSearchPoint == SurfaceSearchPointBak) break;

  003b1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SurfaceSearchPoint@@3HA ; SurfaceSearchPoint
  003b6	3b 45 80	 cmp	 eax, DWORD PTR _SurfaceSearchPointBak$[ebp]
  003b9	75 02		 jne	 SHORT $LN27@AllocateBm
  003bb	eb 05		 jmp	 SHORT $LN1@AllocateBm
$LN27@AllocateBm:

; 279  : 	}

  003bd	e9 41 fd ff ff	 jmp	 $LN2@AllocateBm
$LN1@AllocateBm:

; 280  : }

  003c2	5f		 pop	 edi
  003c3	5e		 pop	 esi
  003c4	5b		 pop	 ebx
  003c5	81 c4 8c 01 00
	00		 add	 esp, 396		; 0000018cH
  003cb	3b ec		 cmp	 ebp, esp
  003cd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003d2	8b e5		 mov	 esp, ebp
  003d4	5d		 pop	 ebp
  003d5	c3		 ret	 0
$LN31@AllocateBm:
$LN30@AllocateBm:
  003d6	70		 DB	 112			; 00000070H
  003d7	72		 DB	 114			; 00000072H
  003d8	65		 DB	 101			; 00000065H
  003d9	76		 DB	 118			; 00000076H
  003da	53		 DB	 83			; 00000053H
  003db	75		 DB	 117			; 00000075H
  003dc	72		 DB	 114			; 00000072H
  003dd	66		 DB	 102			; 00000066H
  003de	61		 DB	 97			; 00000061H
  003df	63		 DB	 99			; 00000063H
  003e0	65		 DB	 101			; 00000065H
  003e1	49		 DB	 73			; 00000049H
  003e2	6e		 DB	 110			; 0000006eH
  003e3	66		 DB	 102			; 00000066H
  003e4	6f		 DB	 111			; 0000006fH
  003e5	00		 DB	 0
?AllocateBmpToSurface@@YAXH@Z ENDP			; AllocateBmpToSurface
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\sprmgr.cpp
;	COMDAT ?LoadBmp@@YAHH@Z
_TEXT	SEGMENT
_bmpNo$ = 8						; size = 4
?LoadBmp@@YAHH@Z PROC					; LoadBmp, COMDAT

; 380  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 381  : #ifndef _READ16BITBMP
; 382  : 	if ((unsigned)bmpNo > MAX_GRAPHICS) return FALSE;

  0001e	81 7d 08 40 42
	0f 00		 cmp	 DWORD PTR _bmpNo$[ebp], 1000000 ; 000f4240H
  00025	76 07		 jbe	 SHORT $LN2@LoadBmp
  00027	33 c0		 xor	 eax, eax
  00029	e9 8c 00 00 00	 jmp	 $LN1@LoadBmp
$LN2@LoadBmp:

; 383  : 	if (SpriteInfo[bmpNo].lpSurfaceInfo == NULL) {

  0002e	6b 45 08 0c	 imul	 eax, DWORD PTR _bmpNo$[ebp], 12
  00032	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR ?SpriteInfo@@3PAUSPRITE_INFO@@A[eax], 0
  00039	75 7a		 jne	 SHORT $LN3@LoadBmp

; 384  : 		if (realGetImage(bmpNo, (unsigned char **)&pRealBinBits,
; 385  : 			&RealBinWidth, &RealBinHeight) == FALSE) {

  0003b	68 00 00 00 00	 push	 OFFSET ?RealBinHeight@@3HA ; RealBinHeight
  00040	68 00 00 00 00	 push	 OFFSET ?RealBinWidth@@3HA ; RealBinWidth
  00045	68 00 00 00 00	 push	 OFFSET ?pRealBinBits@@3PADA ; pRealBinBits
  0004a	8b 45 08	 mov	 eax, DWORD PTR _bmpNo$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?realGetImage@@YAHHPAPAEPAH1@Z ; realGetImage
  00053	83 c4 10	 add	 esp, 16			; 00000010H
  00056	85 c0		 test	 eax, eax
  00058	75 04		 jne	 SHORT $LN4@LoadBmp

; 386  : 			return FALSE;

  0005a	33 c0		 xor	 eax, eax
  0005c	eb 5c		 jmp	 SHORT $LN1@LoadBmp
$LN4@LoadBmp:

; 387  : 		}
; 388  : 		SpriteInfo[bmpNo].width = RealBinWidth;

  0005e	6b 45 08 0c	 imul	 eax, DWORD PTR _bmpNo$[ebp], 12
  00062	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR ?RealBinWidth@@3HA
  00069	66 89 88 04 00
	00 00		 mov	 WORD PTR ?SpriteInfo@@3PAUSPRITE_INFO@@A[eax+4], cx

; 389  : 		SpriteInfo[bmpNo].height = RealBinHeight;

  00070	6b 45 08 0c	 imul	 eax, DWORD PTR _bmpNo$[ebp], 12
  00074	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR ?RealBinHeight@@3HA
  0007b	66 89 88 06 00
	00 00		 mov	 WORD PTR ?SpriteInfo@@3PAUSPRITE_INFO@@A[eax+6], cx

; 390  : #ifdef _NEW_COLOR_
; 391  : 		if (NewColor16Flg == 2)SpriteInfo[bmpNo].AlphaFlg = TRUE;

  00082	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?NewColor16Flg@@3HA, 2 ; NewColor16Flg
  00089	75 10		 jne	 SHORT $LN5@LoadBmp
  0008b	6b 45 08 0c	 imul	 eax, DWORD PTR _bmpNo$[ebp], 12
  0008f	c7 80 08 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?SpriteInfo@@3PAUSPRITE_INFO@@A[eax+8], 1
  00099	eb 0e		 jmp	 SHORT $LN6@LoadBmp
$LN5@LoadBmp:

; 392  : 		else SpriteInfo[bmpNo].AlphaFlg = FALSE;

  0009b	6b 45 08 0c	 imul	 eax, DWORD PTR _bmpNo$[ebp], 12
  0009f	c7 80 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?SpriteInfo@@3PAUSPRITE_INFO@@A[eax+8], 0
$LN6@LoadBmp:

; 393  : #endif
; 394  : 		AllocateBmpToSurface(bmpNo);

  000a9	8b 45 08	 mov	 eax, DWORD PTR _bmpNo$[ebp]
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 ?AllocateBmpToSurface@@YAXH@Z ; AllocateBmpToSurface
  000b2	83 c4 04	 add	 esp, 4
$LN3@LoadBmp:

; 395  : 	}
; 396  : #ifdef _CACHE_SURFACE_
; 397  : 	else {
; 398  : 		//如果已经缓存，刷新date，以免被释放
; 399  : 		for (SURFACE_INFO* info = SpriteInfo[bmpNo].lpSurfaceInfo; info->pNext != NULL; info = info->pNext)
; 400  : 		{
; 401  : 			info->date = SurfaceDate;
; 402  : 		}
; 403  : 	}
; 404  : #endif
; 405  : 	return TRUE;

  000b5	b8 01 00 00 00	 mov	 eax, 1
$LN1@LoadBmp:

; 406  : #else
; 407  : 	BOOL useAlpha;
; 408  : 
; 409  : 	if ((unsigned)bmpNo >= OLD_GRAPHICS_START) {
; 410  : 		if ((unsigned)bmpNo >= MAX_GRAPHICS) return FALSE;
; 411  : 		if (SpriteInfo[bmpNo].lpSurfaceInfo == NULL) {
; 412  : 			pRealBinAlpha = NULL;
; 413  : 			if (Read16BMP(bmpNo - OLD_GRAPHICS_START, (unsigned char **)&pRealBinBits,
; 414  : 				&RealBinWidth, &RealBinHeight, (unsigned char **)&pRealBinAlpha, &useAlpha) == FALSE) return FALSE;
; 415  : 			SpriteInfo[bmpNo].width = RealBinWidth;
; 416  : 			SpriteInfo[bmpNo].height = RealBinHeight;
; 417  : 			AllocateBmpToSurface(bmpNo, useAlpha);
; 418  : 		}
; 419  : 		return TRUE;
; 420  : 	}
; 421  : 	else {
; 422  : 		if (SpriteInfo[bmpNo].lpSurfaceInfo == NULL) {
; 423  : 			pRealBinAlpha = NULL;
; 424  : 			if (realGetImage(bmpNo, (unsigned char **)&pRealBinBits,
; 425  : 				&RealBinWidth, &RealBinHeight) == FALSE) return FALSE;
; 426  : 
; 427  : 			if (NewColor16Flg == 2) {
; 428  : #define REALGETIMAGEMAXSIZE 1600*1600
; 429  : 				extern BYTE g_realgetimagebuf[REALGETIMAGEMAXSIZE];
; 430  : 				int i = 0;
; 431  : 				int b = RealBinWidth * RealBinHeight;
; 432  : 				memset(g_realgetimagebuf, 0, b);
; 433  : 				pRealBinAlpha = g_realgetimagebuf;
; 434  : 				for (i; i<b; i++) {
; 435  : 					*(pRealBinAlpha + i) = *(BYTE*)(pRealBinBits + 3 + i * 4);
; 436  : 				}
; 437  : 			}
; 438  : 			SpriteInfo[bmpNo].width = RealBinWidth;
; 439  : 			SpriteInfo[bmpNo].height = RealBinHeight;
; 440  : 			AllocateBmpToSurface(bmpNo, FALSE);
; 441  : 		}
; 442  : 		return TRUE;
; 443  : 	}
; 444  : #endif
; 445  : }

  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	5b		 pop	 ebx
  000bd	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000c3	3b ec		 cmp	 ebp, esp
  000c5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
?LoadBmp@@YAHH@Z ENDP					; LoadBmp
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\sprmgr.cpp
;	COMDAT ?InitSpriteInfo@@YAXXZ
_TEXT	SEGMENT
_i$ = -8						; size = 4
?InitSpriteInfo@@YAXXZ PROC				; InitSpriteInfo, COMDAT

; 366  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 367  : 	int i;
; 368  : 	for (i = 0; i < MAX_GRAPHICS; i++) {

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00025	eb 09		 jmp	 SHORT $LN4@InitSprite
$LN2@InitSprite:
  00027	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0002a	83 c0 01	 add	 eax, 1
  0002d	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@InitSprite:
  00030	81 7d f8 40 42
	0f 00		 cmp	 DWORD PTR _i$[ebp], 1000000 ; 000f4240H
  00037	7d 10		 jge	 SHORT $LN1@InitSprite

; 369  : 		SpriteInfo[i].lpSurfaceInfo = NULL;

  00039	6b 45 f8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  0003d	c7 80 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?SpriteInfo@@3PAUSPRITE_INFO@@A[eax], 0

; 370  : #ifdef _READ16BITBMP
; 371  : 		SpriteInfo[i].lpSurfaceInfoSys = NULL;
; 372  : #endif
; 373  : 	}

  00047	eb de		 jmp	 SHORT $LN2@InitSprite
$LN1@InitSprite:

; 374  : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?InitSpriteInfo@@YAXXZ ENDP				; InitSpriteInfo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\sprmgr.cpp
;	COMDAT ?InitSurfaceInfo@@YAXXZ
_TEXT	SEGMENT
_i$ = -8						; size = 4
?InitSurfaceInfo@@YAXXZ PROC				; InitSurfaceInfo, COMDAT

; 345  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 346  : 	int i;
; 347  : #ifdef _STONDEBUG_		
; 348  : 	SurfaceUseCnt = 0;
; 349  : #endif
; 350  : 	SurfaceSearchPoint = 0;

  0001e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?SurfaceSearchPoint@@3HA, 0 ; SurfaceSearchPoint

; 351  : 	for (i = 0; i < SurfaceCnt; i++) {

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002f	eb 09		 jmp	 SHORT $LN4@InitSurfac
$LN2@InitSurfac:
  00031	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00034	83 c0 01	 add	 eax, 1
  00037	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@InitSurfac:
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0003d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?SurfaceCnt@@3HA ; SurfaceCnt
  00043	7d 2c		 jge	 SHORT $LN1@InitSurfac

; 352  : 		SurfaceInfo[i].bmpNo = -1;

  00045	6b 45 f8 1c	 imul	 eax, DWORD PTR _i$[ebp], 28
  00049	c7 80 0c 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[eax+12], -1

; 353  : 		SurfaceInfo[i].date = 0;

  00053	6b 45 f8 1c	 imul	 eax, DWORD PTR _i$[ebp], 28
  00057	c7 80 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[eax+16], 0

; 354  : 		SurfaceInfo[i].pNext = NULL;

  00061	6b 45 f8 1c	 imul	 eax, DWORD PTR _i$[ebp], 28
  00065	c7 80 18 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[eax+24], 0

; 355  : #ifdef _READ16BITBMP
; 356  : 		SurfaceInfo[i].useAlpha = FALSE;
; 357  : 		SurfaceInfoSys[i].bmpNo = -1;
; 358  : 		SurfaceInfoSys[i].date = 0;
; 359  : 		SurfaceInfoSys[i].pNext = NULL;
; 360  : 		SurfaceInfoSys[i].useAlpha = FALSE;
; 361  : #endif
; 362  : 	}

  0006f	eb c0		 jmp	 SHORT $LN2@InitSurfac
$LN1@InitSurfac:

; 363  : }

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
?InitSurfaceInfo@@YAXXZ ENDP				; InitSurfaceInfo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\sprmgr.cpp
;	COMDAT ?InitOffScreenSurface@@YAHXZ
_TEXT	SEGMENT
tv81 = -220						; size = 4
tv70 = -220						; size = 4
_vramFullFlag$ = -20					; size = 4
_i$ = -8						; size = 4
?InitOffScreenSurface@@YAHXZ PROC			; InitOffScreenSurface, COMDAT

; 283  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 284  : 	int i;
; 285  : 	BOOL vramFullFlag = TRUE;

  0001e	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _vramFullFlag$[ebp], 1

; 286  : 	SurfaceCnt = 0;

  00025	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?SurfaceCnt@@3HA, 0 ; SurfaceCnt

; 287  : 	VramSurfaceCnt = 0;

  0002f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?VramSurfaceCnt@@3HA, 0 ; VramSurfaceCnt

; 288  : 	SysramSurfaceCnt = 0;

  00039	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?SysramSurfaceCnt@@3HA, 0 ; SysramSurfaceCnt

; 289  : 	for (i = 0; i < SURACE_INFO_MAX; i++) {

  00043	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0004a	eb 09		 jmp	 SHORT $LN4@InitOffScr
$LN2@InitOffScr:
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0004f	83 c0 01	 add	 eax, 1
  00052	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@InitOffScr:
  00055	81 7d f8 00 0c
	00 00		 cmp	 DWORD PTR _i$[ebp], 3072 ; 00000c00H
  0005c	0f 8d b6 00 00
	00		 jge	 $LN3@InitOffScr

; 290  : 		if (vramFullFlag == FALSE) {

  00062	83 7d ec 00	 cmp	 DWORD PTR _vramFullFlag$[ebp], 0
  00066	75 54		 jne	 SHORT $LN5@InitOffScr

; 291  : 			if ((SurfaceInfo[i].lpSurface = CreateSurface(SurfaceSizeX, SurfaceSizeY, DEF_COLORKEY, /*DDSCAPS_SYSTEMMEMORY*/ DDSCAPS_VIDEOMEMORY)) == NULL) {

  00068	68 00 40 00 00	 push	 16384			; 00004000H
  0006d	6a 00		 push	 0
  0006f	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?SurfaceSizeY@@3HA
  00076	50		 push	 eax
  00077	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?SurfaceSizeX@@3HA
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 ?CreateSurface@@YAPAUIDirectDrawSurface@@FFKI@Z ; CreateSurface
  00084	83 c4 10	 add	 esp, 16			; 00000010H
  00087	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0008d	6b 55 f8 1c	 imul	 edx, DWORD PTR _i$[ebp], 28
  00091	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  00097	89 82 00 00 00
	00		 mov	 DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[edx], eax
  0009d	83 bd 24 ff ff
	ff 00		 cmp	 DWORD PTR tv70[ebp], 0
  000a4	75 09		 jne	 SHORT $LN6@InitOffScr

; 292  : #ifdef _STONDEBUG_
; 293  : 				MessageBoxNew(hWnd, "SurfaceInfo:建立VideoRAM Surface失败！", "??", MB_OK | MB_ICONSTOP);
; 294  : #endif
; 295  : 				vramFullFlag = TRUE;

  000a6	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _vramFullFlag$[ebp], 1

; 296  : 			}
; 297  : 			else {

  000ad	eb 0d		 jmp	 SHORT $LN5@InitOffScr
$LN6@InitOffScr:

; 298  : 				VramSurfaceCnt++;

  000af	a1 00 00 00 00	 mov	 eax, DWORD PTR ?VramSurfaceCnt@@3HA ; VramSurfaceCnt
  000b4	83 c0 01	 add	 eax, 1
  000b7	a3 00 00 00 00	 mov	 DWORD PTR ?VramSurfaceCnt@@3HA, eax ; VramSurfaceCnt
$LN5@InitOffScr:

; 299  : 			}
; 300  : 		}
; 301  : 		if (vramFullFlag == TRUE) {

  000bc	83 7d ec 01	 cmp	 DWORD PTR _vramFullFlag$[ebp], 1
  000c0	75 51		 jne	 SHORT $LN8@InitOffScr

; 302  : 			if ((SurfaceInfo[i].lpSurface = CreateSurface(SurfaceSizeX, SurfaceSizeY, DEF_COLORKEY, DDSCAPS_SYSTEMMEMORY)) == NULL) {

  000c2	68 00 08 00 00	 push	 2048			; 00000800H
  000c7	6a 00		 push	 0
  000c9	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?SurfaceSizeY@@3HA
  000d0	50		 push	 eax
  000d1	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?SurfaceSizeX@@3HA
  000d8	51		 push	 ecx
  000d9	e8 00 00 00 00	 call	 ?CreateSurface@@YAPAUIDirectDrawSurface@@FFKI@Z ; CreateSurface
  000de	83 c4 10	 add	 esp, 16			; 00000010H
  000e1	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv81[ebp], eax
  000e7	6b 55 f8 1c	 imul	 edx, DWORD PTR _i$[ebp], 28
  000eb	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv81[ebp]
  000f1	89 82 00 00 00
	00		 mov	 DWORD PTR ?SurfaceInfo@@3PAUsurfaceInfo@@A[edx], eax
  000f7	83 bd 24 ff ff
	ff 00		 cmp	 DWORD PTR tv81[ebp], 0
  000fe	75 06		 jne	 SHORT $LN9@InitOffScr

; 303  : #ifdef _STONDEBUG_
; 304  : 				MessageBoxNew(hWnd, "建立SysRAM Surface失败！", "??", MB_OK | MB_ICONSTOP);
; 305  : #endif
; 306  : 				return FALSE;

  00100	33 c0		 xor	 eax, eax
  00102	eb 2b		 jmp	 SHORT $LN1@InitOffScr
  00104	eb 0d		 jmp	 SHORT $LN8@InitOffScr
$LN9@InitOffScr:

; 307  : 			}
; 308  : 			else SysramSurfaceCnt++;

  00106	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SysramSurfaceCnt@@3HA ; SysramSurfaceCnt
  0010b	83 c0 01	 add	 eax, 1
  0010e	a3 00 00 00 00	 mov	 DWORD PTR ?SysramSurfaceCnt@@3HA, eax ; SysramSurfaceCnt
$LN8@InitOffScr:

; 309  : 		}
; 310  : #ifdef _READ16BITBMP
; 311  : 		if (g_bUseAlpha) {
; 312  : 			if ((SurfaceInfo[i].lpAlphaData = (BYTE*)MALLOC(SurfaceSizeX*SurfaceSizeY)) == NULL) {
; 313  : #ifdef _STONDEBUG_
; 314  : 				MessageBoxNew(hWnd, "alpha记忆体配置失败！", "??", MB_OK | MB_ICONSTOP);
; 315  : #endif
; 316  : 				return FALSE;
; 317  : 			}
; 318  : 			else {
; 319  : #ifdef _STONDEBUG_
; 320  : 				g_iMallocCount++;
; 321  : #endif
; 322  : 				SysramSurfaceCnt++;
; 323  : 			}
; 324  : 		}
; 325  : #endif
; 326  : #ifdef _READ16BITBMP
; 327  : 		if (g_bUseAlpha) {
; 328  : 			if ((SurfaceInfoSys[i].lpSurface = CreateSurface(SurfaceSizeX, SurfaceSizeY, DEF_COLORKEY, DDSCAPS_SYSTEMMEMORY)) == NULL) {
; 329  : #ifdef _STONDEBUG_
; 330  : 				MessageBoxNew(hWnd, "建立SysRAM Surface(2)失败！", "??", MB_OK | MB_ICONSTOP);
; 331  : #endif
; 332  : 				return FALSE;
; 333  : 			}
; 334  : 			else SysramSurfaceCnt++;
; 335  : 		}
; 336  : #endif
; 337  : 	}

  00113	e9 34 ff ff ff	 jmp	 $LN2@InitOffScr
$LN3@InitOffScr:

; 338  : 	SurfaceCnt = i;

  00118	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0011b	a3 00 00 00 00	 mov	 DWORD PTR ?SurfaceCnt@@3HA, eax ; SurfaceCnt

; 339  : 	InitSurfaceInfo();

  00120	e8 00 00 00 00	 call	 ?InitSurfaceInfo@@YAXXZ	; InitSurfaceInfo

; 340  : 	InitSpriteInfo();

  00125	e8 00 00 00 00	 call	 ?InitSpriteInfo@@YAXXZ	; InitSpriteInfo

; 341  : 	return TRUE;

  0012a	b8 01 00 00 00	 mov	 eax, 1
$LN1@InitOffScr:

; 342  : }

  0012f	5f		 pop	 edi
  00130	5e		 pop	 esi
  00131	5b		 pop	 ebx
  00132	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00138	3b ec		 cmp	 ebp, esp
  0013a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0013f	8b e5		 mov	 esp, ebp
  00141	5d		 pop	 ebp
  00142	c3		 ret	 0
?InitOffScreenSurface@@YAHXZ ENDP			; InitOffScreenSurface
_TEXT	ENDS
END
