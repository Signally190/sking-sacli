; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Administrator\Desktop\????? ??\????? ??\Client Source Code\system\unpack.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?encoder@@YAPAEPAEPAPAEIIPAIH@Z			; encoder
PUBLIC	?decoder@@YAPAEPAEPAPAEPAI22@Z			; decoder
EXTRN	__imp__malloc:PROC
EXTRN	_memset:PROC
EXTRN	_uncompress:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	?NewColor16Flg@@3HA:DWORD			; NewColor16Flg
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\unpack.cpp
;	COMDAT ?decoder@@YAPAEPAEPAPAEPAI22@Z
_TEXT	SEGMENT
_idx$ = -149						; size = 1
_repData$ = -137					; size = 1
_el$ = -128						; size = 4
_l$ = -116						; size = 4
_cnt$ = -104						; size = 4
_height$ = -92						; size = 4
_width$ = -80						; size = 4
_buf1$ = -68						; size = 4
_wBuf1$ = -56						; size = 4
_eBuf$ = -44						; size = 4
_ewBuf$ = -32						; size = 4
_wBuf$ = -20						; size = 4
_header$ = -8						; size = 4
_buf$ = 8						; size = 4
_disBuf$ = 12						; size = 4
_width1$ = 16						; size = 4
_height1$ = 20						; size = 4
_len$ = 24						; size = 4
?decoder@@YAPAEPAEPAPAEPAI22@Z PROC			; decoder, COMDAT

; 257  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 5c 01 00
	00		 sub	 esp, 348		; 0000015cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd a4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-348]
  00012	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 258  : 	RD_HEADER *header;
; 259  : 	unsigned char *wBuf, *ewBuf, *eBuf;
; 260  : 	unsigned char *wBuf1, *buf1;
; 261  : 	unsigned int width, height;
; 262  : 	unsigned int cnt;
; 263  : 	unsigned int l, el;
; 264  : 	unsigned char repData;
; 265  : 	unsigned char idx;
; 266  : 	if (*disBuf == NULL)

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _disBuf$[ebp]
  00021	83 38 00	 cmp	 DWORD PTR [eax], 0
  00024	75 07		 jne	 SHORT $LN10@decoder

; 267  : 		return NULL;

  00026	33 c0		 xor	 eax, eax
  00028	e9 2a 03 00 00	 jmp	 $LN1@decoder
$LN10@decoder:

; 268  : 	wBuf = *disBuf;

  0002d	8b 45 0c	 mov	 eax, DWORD PTR _disBuf$[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	89 4d ec	 mov	 DWORD PTR _wBuf$[ebp], ecx

; 269  : 	header = (RD_HEADER *)buf;

  00035	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00038	89 45 f8	 mov	 DWORD PTR _header$[ebp], eax

; 270  : 	if (header->id[0] != 'R' || header->id[1] != 'D') {

  0003b	b8 01 00 00 00	 mov	 eax, 1
  00040	6b c8 00	 imul	 ecx, eax, 0
  00043	8b 55 f8	 mov	 edx, DWORD PTR _header$[ebp]
  00046	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0004a	83 f8 52	 cmp	 eax, 82			; 00000052H
  0004d	75 14		 jne	 SHORT $LN12@decoder
  0004f	b8 01 00 00 00	 mov	 eax, 1
  00054	c1 e0 00	 shl	 eax, 0
  00057	8b 4d f8	 mov	 ecx, DWORD PTR _header$[ebp]
  0005a	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0005e	83 fa 44	 cmp	 edx, 68			; 00000044H
  00061	74 07		 je	 SHORT $LN11@decoder
$LN12@decoder:

; 271  : 		return NULL;

  00063	33 c0		 xor	 eax, eax
  00065	e9 ed 02 00 00	 jmp	 $LN1@decoder
$LN11@decoder:

; 272  : 	}
; 273  : 	width = header->width;

  0006a	8b 45 f8	 mov	 eax, DWORD PTR _header$[ebp]
  0006d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00070	89 4d b0	 mov	 DWORD PTR _width$[ebp], ecx

; 274  : 	height = header->height;

  00073	8b 45 f8	 mov	 eax, DWORD PTR _header$[ebp]
  00076	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00079	89 4d a4	 mov	 DWORD PTR _height$[ebp], ecx

; 275  : 	if (header->compressFlag == 0) {//√ªº”√‹

  0007c	8b 45 f8	 mov	 eax, DWORD PTR _header$[ebp]
  0007f	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  00083	85 c9		 test	 ecx, ecx
  00085	75 76		 jne	 SHORT $LN13@decoder

; 276  : 		wBuf1 = wBuf;

  00087	8b 45 ec	 mov	 eax, DWORD PTR _wBuf$[ebp]
  0008a	89 45 c8	 mov	 DWORD PTR _wBuf1$[ebp], eax

; 277  : 		buf1 = buf + sizeof(RD_HEADER);

  0008d	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00090	83 c0 10	 add	 eax, 16			; 00000010H
  00093	89 45 bc	 mov	 DWORD PTR _buf1$[ebp], eax

; 278  : 		el = width * height;

  00096	8b 45 b0	 mov	 eax, DWORD PTR _width$[ebp]
  00099	0f af 45 a4	 imul	 eax, DWORD PTR _height$[ebp]
  0009d	89 45 80	 mov	 DWORD PTR _el$[ebp], eax

; 279  : 		for (l = 0; l < el; l++)

  000a0	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _l$[ebp], 0
  000a7	eb 09		 jmp	 SHORT $LN4@decoder
$LN2@decoder:
  000a9	8b 45 8c	 mov	 eax, DWORD PTR _l$[ebp]
  000ac	83 c0 01	 add	 eax, 1
  000af	89 45 8c	 mov	 DWORD PTR _l$[ebp], eax
$LN4@decoder:
  000b2	8b 45 8c	 mov	 eax, DWORD PTR _l$[ebp]
  000b5	3b 45 80	 cmp	 eax, DWORD PTR _el$[ebp]
  000b8	73 1e		 jae	 SHORT $LN3@decoder

; 280  : 			*wBuf1++ = *buf1++;

  000ba	8b 45 c8	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  000bd	8b 4d bc	 mov	 ecx, DWORD PTR _buf1$[ebp]
  000c0	8a 11		 mov	 dl, BYTE PTR [ecx]
  000c2	88 10		 mov	 BYTE PTR [eax], dl
  000c4	8b 45 c8	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  000c7	83 c0 01	 add	 eax, 1
  000ca	89 45 c8	 mov	 DWORD PTR _wBuf1$[ebp], eax
  000cd	8b 4d bc	 mov	 ecx, DWORD PTR _buf1$[ebp]
  000d0	83 c1 01	 add	 ecx, 1
  000d3	89 4d bc	 mov	 DWORD PTR _buf1$[ebp], ecx
  000d6	eb d1		 jmp	 SHORT $LN2@decoder
$LN3@decoder:

; 281  : 
; 282  : 		*len = l;

  000d8	8b 45 18	 mov	 eax, DWORD PTR _len$[ebp]
  000db	8b 4d 8c	 mov	 ecx, DWORD PTR _l$[ebp]
  000de	89 08		 mov	 DWORD PTR [eax], ecx

; 283  : 		*width1 = width;

  000e0	8b 45 10	 mov	 eax, DWORD PTR _width1$[ebp]
  000e3	8b 4d b0	 mov	 ecx, DWORD PTR _width$[ebp]
  000e6	89 08		 mov	 DWORD PTR [eax], ecx

; 284  : 		*height1 = height;

  000e8	8b 45 14	 mov	 eax, DWORD PTR _height1$[ebp]
  000eb	8b 4d a4	 mov	 ecx, DWORD PTR _height$[ebp]
  000ee	89 08		 mov	 DWORD PTR [eax], ecx

; 285  : 		return wBuf;

  000f0	8b 45 ec	 mov	 eax, DWORD PTR _wBuf$[ebp]
  000f3	e9 5f 02 00 00	 jmp	 $LN1@decoder
  000f8	e9 5a 02 00 00	 jmp	 $LN1@decoder
$LN13@decoder:

; 286  : #ifdef _NEW_COLOR_
; 287  : 	}
; 288  : 	else if (header->compressFlag >= 16) {

  000fd	8b 45 f8	 mov	 eax, DWORD PTR _header$[ebp]
  00100	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  00104	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00107	7c 71		 jl	 SHORT $LN15@decoder

; 289  : 		*len = width * height * 4;

  00109	8b 45 b0	 mov	 eax, DWORD PTR _width$[ebp]
  0010c	0f af 45 a4	 imul	 eax, DWORD PTR _height$[ebp]
  00110	c1 e0 02	 shl	 eax, 2
  00113	8b 4d 18	 mov	 ecx, DWORD PTR _len$[ebp]
  00116	89 01		 mov	 DWORD PTR [ecx], eax

; 290  : 		*width1 = width;

  00118	8b 45 10	 mov	 eax, DWORD PTR _width1$[ebp]
  0011b	8b 4d b0	 mov	 ecx, DWORD PTR _width$[ebp]
  0011e	89 08		 mov	 DWORD PTR [eax], ecx

; 291  : 		*height1 = height;

  00120	8b 45 14	 mov	 eax, DWORD PTR _height1$[ebp]
  00123	8b 4d a4	 mov	 ecx, DWORD PTR _height$[ebp]
  00126	89 08		 mov	 DWORD PTR [eax], ecx

; 292  : 		uncompress(*disBuf, (unsigned long *)len, buf + sizeof(RD_HEADER), header->size - sizeof(RD_HEADER));

  00128	8b 45 f8	 mov	 eax, DWORD PTR _header$[ebp]
  0012b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0012e	83 e9 10	 sub	 ecx, 16			; 00000010H
  00131	51		 push	 ecx
  00132	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00135	83 c2 10	 add	 edx, 16			; 00000010H
  00138	52		 push	 edx
  00139	8b 45 18	 mov	 eax, DWORD PTR _len$[ebp]
  0013c	50		 push	 eax
  0013d	8b 4d 0c	 mov	 ecx, DWORD PTR _disBuf$[ebp]
  00140	8b 11		 mov	 edx, DWORD PTR [ecx]
  00142	52		 push	 edx
  00143	e8 00 00 00 00	 call	 _uncompress
  00148	83 c4 10	 add	 esp, 16			; 00000010H

; 293  : 		if (header->compressFlag == 16)

  0014b	8b 45 f8	 mov	 eax, DWORD PTR _header$[ebp]
  0014e	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  00152	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00155	75 0c		 jne	 SHORT $LN17@decoder

; 294  : 			NewColor16Flg = 1;

  00157	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?NewColor16Flg@@3HA, 1 ; NewColor16Flg

; 295  : 		else {

  00161	eb 0a		 jmp	 SHORT $LN18@decoder
$LN17@decoder:

; 296  : 			NewColor16Flg = 2;

  00163	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?NewColor16Flg@@3HA, 2 ; NewColor16Flg
$LN18@decoder:

; 297  : 		}
; 298  : 		return wBuf;

  0016d	8b 45 ec	 mov	 eax, DWORD PTR _wBuf$[ebp]
  00170	e9 e2 01 00 00	 jmp	 $LN1@decoder

; 299  : #endif
; 300  : 	}
; 301  : 	else {//º”√‹

  00175	e9 dd 01 00 00	 jmp	 $LN1@decoder
$LN15@decoder:

; 302  : 		eBuf = buf + header->size;

  0017a	8b 45 f8	 mov	 eax, DWORD PTR _header$[ebp]
  0017d	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00180	03 48 0c	 add	 ecx, DWORD PTR [eax+12]
  00183	89 4d d4	 mov	 DWORD PTR _eBuf$[ebp], ecx

; 303  : 		ewBuf = wBuf + width * height;

  00186	8b 45 b0	 mov	 eax, DWORD PTR _width$[ebp]
  00189	0f af 45 a4	 imul	 eax, DWORD PTR _height$[ebp]
  0018d	03 45 ec	 add	 eax, DWORD PTR _wBuf$[ebp]
  00190	89 45 e0	 mov	 DWORD PTR _ewBuf$[ebp], eax

; 304  : 		wBuf1 = wBuf;

  00193	8b 45 ec	 mov	 eax, DWORD PTR _wBuf$[ebp]
  00196	89 45 c8	 mov	 DWORD PTR _wBuf1$[ebp], eax

; 305  : 		buf1 = buf + sizeof(RD_HEADER);

  00199	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0019c	83 c0 10	 add	 eax, 16			; 00000010H
  0019f	89 45 bc	 mov	 DWORD PTR _buf1$[ebp], eax
$LN5@decoder:

; 306  : 		while (buf1 < eBuf) {

  001a2	8b 45 bc	 mov	 eax, DWORD PTR _buf1$[ebp]
  001a5	3b 45 d4	 cmp	 eax, DWORD PTR _eBuf$[ebp]
  001a8	0f 83 8a 01 00
	00		 jae	 $LN6@decoder

; 307  : 			idx = *buf1++;

  001ae	8b 45 bc	 mov	 eax, DWORD PTR _buf1$[ebp]
  001b1	8a 08		 mov	 cl, BYTE PTR [eax]
  001b3	88 8d 6b ff ff
	ff		 mov	 BYTE PTR _idx$[ebp], cl
  001b9	8b 55 bc	 mov	 edx, DWORD PTR _buf1$[ebp]
  001bc	83 c2 01	 add	 edx, 1
  001bf	89 55 bc	 mov	 DWORD PTR _buf1$[ebp], edx

; 308  : 			if ((idx & BIT_CMP) != 0) {

  001c2	0f b6 85 6b ff
	ff ff		 movzx	 eax, BYTE PTR _idx$[ebp]
  001c9	25 80 00 00 00	 and	 eax, 128		; 00000080H
  001ce	0f 84 da 00 00
	00		 je	 $LN19@decoder

; 309  : 				if ((idx & BIT_ZERO) != 0) {

  001d4	0f b6 85 6b ff
	ff ff		 movzx	 eax, BYTE PTR _idx$[ebp]
  001db	83 e0 40	 and	 eax, 64			; 00000040H
  001de	74 09		 je	 SHORT $LN21@decoder

; 310  : 					repData = 0;

  001e0	c6 85 77 ff ff
	ff 00		 mov	 BYTE PTR _repData$[ebp], 0

; 311  : 				}
; 312  : 				else {

  001e7	eb 14		 jmp	 SHORT $LN22@decoder
$LN21@decoder:

; 313  : 					repData = *buf1++;

  001e9	8b 45 bc	 mov	 eax, DWORD PTR _buf1$[ebp]
  001ec	8a 08		 mov	 cl, BYTE PTR [eax]
  001ee	88 8d 77 ff ff
	ff		 mov	 BYTE PTR _repData$[ebp], cl
  001f4	8b 55 bc	 mov	 edx, DWORD PTR _buf1$[ebp]
  001f7	83 c2 01	 add	 edx, 1
  001fa	89 55 bc	 mov	 DWORD PTR _buf1$[ebp], edx
$LN22@decoder:

; 314  : 				}
; 315  : 				if ((idx & BIT_REP_LARG2) != 0) {

  001fd	0f b6 85 6b ff
	ff ff		 movzx	 eax, BYTE PTR _idx$[ebp]
  00204	83 e0 20	 and	 eax, 32			; 00000020H
  00207	74 3f		 je	 SHORT $LN23@decoder

; 316  : 					cnt = ((idx & 0x0f) << 16);

  00209	0f b6 85 6b ff
	ff ff		 movzx	 eax, BYTE PTR _idx$[ebp]
  00210	83 e0 0f	 and	 eax, 15			; 0000000fH
  00213	c1 e0 10	 shl	 eax, 16			; 00000010H
  00216	89 45 98	 mov	 DWORD PTR _cnt$[ebp], eax

; 317  : 					cnt |= ((*buf1) << 8);

  00219	8b 45 bc	 mov	 eax, DWORD PTR _buf1$[ebp]
  0021c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0021f	c1 e1 08	 shl	 ecx, 8
  00222	0b 4d 98	 or	 ecx, DWORD PTR _cnt$[ebp]
  00225	89 4d 98	 mov	 DWORD PTR _cnt$[ebp], ecx

; 318  : 					buf1++;

  00228	8b 45 bc	 mov	 eax, DWORD PTR _buf1$[ebp]
  0022b	83 c0 01	 add	 eax, 1
  0022e	89 45 bc	 mov	 DWORD PTR _buf1$[ebp], eax

; 319  : 					cnt |= *buf1++;

  00231	8b 45 bc	 mov	 eax, DWORD PTR _buf1$[ebp]
  00234	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00237	0b 4d 98	 or	 ecx, DWORD PTR _cnt$[ebp]
  0023a	89 4d 98	 mov	 DWORD PTR _cnt$[ebp], ecx
  0023d	8b 55 bc	 mov	 edx, DWORD PTR _buf1$[ebp]
  00240	83 c2 01	 add	 edx, 1
  00243	89 55 bc	 mov	 DWORD PTR _buf1$[ebp], edx

; 320  : 				}
; 321  : 				else

  00246	eb 40		 jmp	 SHORT $LN24@decoder
$LN23@decoder:

; 322  : 					if ((idx & BIT_REP_LARG) != 0) {

  00248	0f b6 85 6b ff
	ff ff		 movzx	 eax, BYTE PTR _idx$[ebp]
  0024f	83 e0 10	 and	 eax, 16			; 00000010H
  00252	74 27		 je	 SHORT $LN25@decoder

; 323  : 						cnt = ((idx & 0x0f) << 8);

  00254	0f b6 85 6b ff
	ff ff		 movzx	 eax, BYTE PTR _idx$[ebp]
  0025b	83 e0 0f	 and	 eax, 15			; 0000000fH
  0025e	c1 e0 08	 shl	 eax, 8
  00261	89 45 98	 mov	 DWORD PTR _cnt$[ebp], eax

; 324  : 						cnt |= *buf1++;

  00264	8b 45 bc	 mov	 eax, DWORD PTR _buf1$[ebp]
  00267	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0026a	0b 4d 98	 or	 ecx, DWORD PTR _cnt$[ebp]
  0026d	89 4d 98	 mov	 DWORD PTR _cnt$[ebp], ecx
  00270	8b 55 bc	 mov	 edx, DWORD PTR _buf1$[ebp]
  00273	83 c2 01	 add	 edx, 1
  00276	89 55 bc	 mov	 DWORD PTR _buf1$[ebp], edx

; 325  : 					}
; 326  : 					else {

  00279	eb 0d		 jmp	 SHORT $LN24@decoder
$LN25@decoder:

; 327  : 						cnt = (idx & 0x0f);

  0027b	0f b6 85 6b ff
	ff ff		 movzx	 eax, BYTE PTR _idx$[ebp]
  00282	83 e0 0f	 and	 eax, 15			; 0000000fH
  00285	89 45 98	 mov	 DWORD PTR _cnt$[ebp], eax
$LN24@decoder:

; 328  : 					}
; 329  : 					memset(wBuf1, repData, cnt);

  00288	8b 45 98	 mov	 eax, DWORD PTR _cnt$[ebp]
  0028b	50		 push	 eax
  0028c	0f b6 8d 77 ff
	ff ff		 movzx	 ecx, BYTE PTR _repData$[ebp]
  00293	51		 push	 ecx
  00294	8b 55 c8	 mov	 edx, DWORD PTR _wBuf1$[ebp]
  00297	52		 push	 edx
  00298	e8 00 00 00 00	 call	 _memset
  0029d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 330  : 					wBuf1 += cnt;

  002a0	8b 45 c8	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  002a3	03 45 98	 add	 eax, DWORD PTR _cnt$[ebp]
  002a6	89 45 c8	 mov	 DWORD PTR _wBuf1$[ebp], eax

; 331  : 			}
; 332  : 			else {

  002a9	e9 85 00 00 00	 jmp	 $LN20@decoder
$LN19@decoder:

; 333  : 				if ((idx & BIT_REP_LARG) != 0) {

  002ae	0f b6 85 6b ff
	ff ff		 movzx	 eax, BYTE PTR _idx$[ebp]
  002b5	83 e0 10	 and	 eax, 16			; 00000010H
  002b8	74 27		 je	 SHORT $LN27@decoder

; 334  : 					cnt = ((idx & 0x0f) << 8);

  002ba	0f b6 85 6b ff
	ff ff		 movzx	 eax, BYTE PTR _idx$[ebp]
  002c1	83 e0 0f	 and	 eax, 15			; 0000000fH
  002c4	c1 e0 08	 shl	 eax, 8
  002c7	89 45 98	 mov	 DWORD PTR _cnt$[ebp], eax

; 335  : 					cnt |= *buf1++;

  002ca	8b 45 bc	 mov	 eax, DWORD PTR _buf1$[ebp]
  002cd	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  002d0	0b 4d 98	 or	 ecx, DWORD PTR _cnt$[ebp]
  002d3	89 4d 98	 mov	 DWORD PTR _cnt$[ebp], ecx
  002d6	8b 55 bc	 mov	 edx, DWORD PTR _buf1$[ebp]
  002d9	83 c2 01	 add	 edx, 1
  002dc	89 55 bc	 mov	 DWORD PTR _buf1$[ebp], edx

; 336  : 				}
; 337  : 				else {

  002df	eb 0d		 jmp	 SHORT $LN28@decoder
$LN27@decoder:

; 338  : 					cnt = (idx & 0x0f);

  002e1	0f b6 85 6b ff
	ff ff		 movzx	 eax, BYTE PTR _idx$[ebp]
  002e8	83 e0 0f	 and	 eax, 15			; 0000000fH
  002eb	89 45 98	 mov	 DWORD PTR _cnt$[ebp], eax
$LN28@decoder:

; 339  : 				}
; 340  : 				if (cnt >= 0xfffff) {

  002ee	81 7d 98 ff ff
	0f 00		 cmp	 DWORD PTR _cnt$[ebp], 1048575 ; 000fffffH
  002f5	72 04		 jb	 SHORT $LN29@decoder

; 341  : 					return NULL;

  002f7	33 c0		 xor	 eax, eax
  002f9	eb 5c		 jmp	 SHORT $LN1@decoder
$LN29@decoder:

; 342  : 				}
; 343  : 				for (l = 0; l < cnt; l++)

  002fb	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _l$[ebp], 0
  00302	eb 09		 jmp	 SHORT $LN9@decoder
$LN7@decoder:
  00304	8b 45 8c	 mov	 eax, DWORD PTR _l$[ebp]
  00307	83 c0 01	 add	 eax, 1
  0030a	89 45 8c	 mov	 DWORD PTR _l$[ebp], eax
$LN9@decoder:
  0030d	8b 45 8c	 mov	 eax, DWORD PTR _l$[ebp]
  00310	3b 45 98	 cmp	 eax, DWORD PTR _cnt$[ebp]
  00313	73 1e		 jae	 SHORT $LN20@decoder

; 344  : 					*wBuf1++ = *buf1++;

  00315	8b 45 c8	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  00318	8b 4d bc	 mov	 ecx, DWORD PTR _buf1$[ebp]
  0031b	8a 11		 mov	 dl, BYTE PTR [ecx]
  0031d	88 10		 mov	 BYTE PTR [eax], dl
  0031f	8b 45 c8	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  00322	83 c0 01	 add	 eax, 1
  00325	89 45 c8	 mov	 DWORD PTR _wBuf1$[ebp], eax
  00328	8b 4d bc	 mov	 ecx, DWORD PTR _buf1$[ebp]
  0032b	83 c1 01	 add	 ecx, 1
  0032e	89 4d bc	 mov	 DWORD PTR _buf1$[ebp], ecx
  00331	eb d1		 jmp	 SHORT $LN7@decoder
$LN20@decoder:

; 345  : 			}
; 346  : 		}

  00333	e9 6a fe ff ff	 jmp	 $LN5@decoder
$LN6@decoder:

; 347  : 		*len = width * height;

  00338	8b 45 b0	 mov	 eax, DWORD PTR _width$[ebp]
  0033b	0f af 45 a4	 imul	 eax, DWORD PTR _height$[ebp]
  0033f	8b 4d 18	 mov	 ecx, DWORD PTR _len$[ebp]
  00342	89 01		 mov	 DWORD PTR [ecx], eax

; 348  : 		*width1 = width;

  00344	8b 45 10	 mov	 eax, DWORD PTR _width1$[ebp]
  00347	8b 4d b0	 mov	 ecx, DWORD PTR _width$[ebp]
  0034a	89 08		 mov	 DWORD PTR [eax], ecx

; 349  : 		*height1 = height;

  0034c	8b 45 14	 mov	 eax, DWORD PTR _height1$[ebp]
  0034f	8b 4d a4	 mov	 ecx, DWORD PTR _height$[ebp]
  00352	89 08		 mov	 DWORD PTR [eax], ecx

; 350  : 		return wBuf;

  00354	8b 45 ec	 mov	 eax, DWORD PTR _wBuf$[ebp]
$LN1@decoder:

; 351  : 	}
; 352  : }

  00357	5f		 pop	 edi
  00358	5e		 pop	 esi
  00359	5b		 pop	 ebx
  0035a	81 c4 5c 01 00
	00		 add	 esp, 348		; 0000015cH
  00360	3b ec		 cmp	 ebp, esp
  00362	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00367	8b e5		 mov	 esp, ebp
  00369	5d		 pop	 ebp
  0036a	c3		 ret	 0
?decoder@@YAPAEPAEPAPAEPAI22@Z ENDP			; decoder
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\administrator\desktop\????? ??\????? ??\client source code\system\unpack.cpp
;	COMDAT ?encoder@@YAPAEPAEPAPAEIIPAIH@Z
_TEXT	SEGMENT
_addWBuf$ = -200					; size = 4
_el$ = -188						; size = 4
_l$ = -176						; size = 4
_mode$ = -164						; size = 4
_repData$ = -149					; size = 1
_cnt2$ = -140						; size = 4
_cnt$ = -128						; size = 4
_header$ = -116						; size = 4
_flag$ = -104						; size = 4
_idx$ = -89						; size = 1
_buf2$ = -80						; size = 4
_wBuf2$ = -68						; size = 4
_buf1$ = -56						; size = 4
_wBuf1$ = -44						; size = 4
_eBuf$ = -32						; size = 4
_ewBuf$ = -20						; size = 4
_wBuf$ = -8						; size = 4
_buf$ = 8						; size = 4
_disBuf$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_len$ = 24						; size = 4
_cmpFlag$ = 28						; size = 4
?encoder@@YAPAEPAEPAPAEIIPAIH@Z PROC			; encoder, COMDAT

; 18   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 01 00
	00		 sub	 esp, 396		; 0000018cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 74 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-396]
  00012	b9 63 00 00 00	 mov	 ecx, 99			; 00000063H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 19   : 	unsigned char *wBuf, *ewBuf, *eBuf;
; 20   : 	unsigned char *wBuf1, *buf1;
; 21   : 	unsigned char *wBuf2, *buf2;
; 22   : 	unsigned char idx;
; 23   : 	int flag = 1;

  0001e	c7 45 98 01 00
	00 00		 mov	 DWORD PTR _flag$[ebp], 1

; 24   : 	RD_HEADER *header;
; 25   : 	unsigned int cnt, cnt2;
; 26   : 	unsigned char repData;
; 27   : 	int mode;
; 28   : 	unsigned int l, el;
; 29   : 	int addWBuf;
; 30   : 
; 31   : 	if (*disBuf == NULL) {

  00025	8b 45 0c	 mov	 eax, DWORD PTR _disBuf$[ebp]
  00028	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002b	75 37		 jne	 SHORT $LN16@encoder

; 32   : 		if ((wBuf = (unsigned char *)MALLOC(width * height + sizeof(RD_HEADER))) == NULL)

  0002d	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  00030	0f af 45 14	 imul	 eax, DWORD PTR _height$[ebp]
  00034	83 c0 10	 add	 eax, 16			; 00000010H
  00037	8b f4		 mov	 esi, esp
  00039	50		 push	 eax
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00040	83 c4 04	 add	 esp, 4
  00043	3b f4		 cmp	 esi, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	89 45 f8	 mov	 DWORD PTR _wBuf$[ebp], eax
  0004d	83 7d f8 00	 cmp	 DWORD PTR _wBuf$[ebp], 0
  00051	75 07		 jne	 SHORT $LN18@encoder

; 33   : 		{
; 34   : 			return NULL;

  00053	33 c0		 xor	 eax, eax
  00055	e9 39 07 00 00	 jmp	 $LN1@encoder
$LN18@encoder:

; 35   : 		}
; 36   : #ifdef _STONDEBUG_
; 37   : 		g_iMallocCount++;
; 38   : #endif
; 39   : 		*disBuf = wBuf;

  0005a	8b 45 0c	 mov	 eax, DWORD PTR _disBuf$[ebp]
  0005d	8b 4d f8	 mov	 ecx, DWORD PTR _wBuf$[ebp]
  00060	89 08		 mov	 DWORD PTR [eax], ecx

; 40   : 	}
; 41   : 	else {

  00062	eb 08		 jmp	 SHORT $LN17@encoder
$LN16@encoder:

; 42   : 		wBuf = *disBuf;

  00064	8b 45 0c	 mov	 eax, DWORD PTR _disBuf$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	89 4d f8	 mov	 DWORD PTR _wBuf$[ebp], ecx
$LN17@encoder:

; 43   : 	}
; 44   : 
; 45   : 	if (cmpFlag) {

  0006c	83 7d 1c 00	 cmp	 DWORD PTR _cmpFlag$[ebp], 0
  00070	74 09		 je	 SHORT $LN19@encoder

; 46   : 		flag = 1;

  00072	c7 45 98 01 00
	00 00		 mov	 DWORD PTR _flag$[ebp], 1

; 47   : 	}
; 48   : 	else {

  00079	eb 07		 jmp	 SHORT $LN20@encoder
$LN19@encoder:

; 49   : 		flag = 0;

  0007b	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _flag$[ebp], 0
$LN20@encoder:

; 50   : 	}
; 51   : 	eBuf = buf + width * height;

  00082	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  00085	0f af 45 14	 imul	 eax, DWORD PTR _height$[ebp]
  00089	03 45 08	 add	 eax, DWORD PTR _buf$[ebp]
  0008c	89 45 e0	 mov	 DWORD PTR _eBuf$[ebp], eax

; 52   : 	ewBuf = wBuf + width * height + sizeof(RD_HEADER);

  0008f	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  00092	0f af 45 14	 imul	 eax, DWORD PTR _height$[ebp]
  00096	8b 4d f8	 mov	 ecx, DWORD PTR _wBuf$[ebp]
  00099	8d 54 01 10	 lea	 edx, DWORD PTR [ecx+eax+16]
  0009d	89 55 ec	 mov	 DWORD PTR _ewBuf$[ebp], edx

; 53   : 	wBuf1 = wBuf + sizeof(RD_HEADER);

  000a0	8b 45 f8	 mov	 eax, DWORD PTR _wBuf$[ebp]
  000a3	83 c0 10	 add	 eax, 16			; 00000010H
  000a6	89 45 d4	 mov	 DWORD PTR _wBuf1$[ebp], eax

; 54   : 	buf1 = buf;

  000a9	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000ac	89 45 c8	 mov	 DWORD PTR _buf1$[ebp], eax
$LN2@encoder:

; 55   : 	while (cmpFlag) {

  000af	83 7d 1c 00	 cmp	 DWORD PTR _cmpFlag$[ebp], 0
  000b3	0f 84 df 05 00
	00		 je	 $LN3@encoder

; 56   : 		if (buf1 >= eBuf) {

  000b9	8b 45 c8	 mov	 eax, DWORD PTR _buf1$[ebp]
  000bc	3b 45 e0	 cmp	 eax, DWORD PTR _eBuf$[ebp]
  000bf	72 0c		 jb	 SHORT $LN21@encoder

; 57   : 			flag = 1;

  000c1	c7 45 98 01 00
	00 00		 mov	 DWORD PTR _flag$[ebp], 1

; 58   : 			break;

  000c8	e9 cb 05 00 00	 jmp	 $LN3@encoder
$LN21@encoder:

; 59   : 		}
; 60   : 		if (wBuf1 >= ewBuf) {

  000cd	8b 45 d4	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  000d0	3b 45 ec	 cmp	 eax, DWORD PTR _ewBuf$[ebp]
  000d3	72 0c		 jb	 SHORT $LN22@encoder

; 61   : 			flag = 0;

  000d5	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _flag$[ebp], 0

; 62   : 			break;

  000dc	e9 b7 05 00 00	 jmp	 $LN3@encoder
$LN22@encoder:

; 63   : 		}
; 64   : 
; 65   : 		if (*buf1 == 0 && *(buf1 + 1) == 0) {

  000e1	8b 45 c8	 mov	 eax, DWORD PTR _buf1$[ebp]
  000e4	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000e7	85 c9		 test	 ecx, ecx
  000e9	0f 85 78 01 00
	00		 jne	 $LN23@encoder
  000ef	8b 45 c8	 mov	 eax, DWORD PTR _buf1$[ebp]
  000f2	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  000f6	85 c9		 test	 ecx, ecx
  000f8	0f 85 69 01 00
	00		 jne	 $LN23@encoder

; 66   : 			idx = BIT_CMP | BIT_ZERO;

  000fe	c6 45 a7 c0	 mov	 BYTE PTR _idx$[ebp], 192 ; 000000c0H

; 67   : 			cnt = 2;

  00102	c7 45 80 02 00
	00 00		 mov	 DWORD PTR _cnt$[ebp], 2

; 68   : 			buf1 += 2;

  00109	8b 45 c8	 mov	 eax, DWORD PTR _buf1$[ebp]
  0010c	83 c0 02	 add	 eax, 2
  0010f	89 45 c8	 mov	 DWORD PTR _buf1$[ebp], eax
$LN4@encoder:

; 69   : 			while (buf1 < eBuf && cnt < 0xfffff) {

  00112	8b 45 c8	 mov	 eax, DWORD PTR _buf1$[ebp]
  00115	3b 45 e0	 cmp	 eax, DWORD PTR _eBuf$[ebp]
  00118	73 29		 jae	 SHORT $LN5@encoder
  0011a	81 7d 80 ff ff
	0f 00		 cmp	 DWORD PTR _cnt$[ebp], 1048575 ; 000fffffH
  00121	73 20		 jae	 SHORT $LN5@encoder

; 70   : 				if (*buf1 != 0) {

  00123	8b 45 c8	 mov	 eax, DWORD PTR _buf1$[ebp]
  00126	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00129	85 c9		 test	 ecx, ecx
  0012b	74 02		 je	 SHORT $LN24@encoder

; 71   : 					break;

  0012d	eb 14		 jmp	 SHORT $LN5@encoder
$LN24@encoder:

; 72   : 				}
; 73   : 				buf1++;

  0012f	8b 45 c8	 mov	 eax, DWORD PTR _buf1$[ebp]
  00132	83 c0 01	 add	 eax, 1
  00135	89 45 c8	 mov	 DWORD PTR _buf1$[ebp], eax

; 74   : 				cnt++;

  00138	8b 45 80	 mov	 eax, DWORD PTR _cnt$[ebp]
  0013b	83 c0 01	 add	 eax, 1
  0013e	89 45 80	 mov	 DWORD PTR _cnt$[ebp], eax

; 75   : 			}

  00141	eb cf		 jmp	 SHORT $LN4@encoder
$LN5@encoder:

; 76   : 			if (cnt <= 0xf) {

  00143	83 7d 80 0f	 cmp	 DWORD PTR _cnt$[ebp], 15 ; 0000000fH
  00147	77 0c		 ja	 SHORT $LN25@encoder

; 77   : 				addWBuf = 0;

  00149	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _addWBuf$[ebp], 0

; 78   : 			}
; 79   : 			else

  00153	eb 1f		 jmp	 SHORT $LN26@encoder
$LN25@encoder:

; 80   : 				if (cnt <= 0xfff) {

  00155	81 7d 80 ff 0f
	00 00		 cmp	 DWORD PTR _cnt$[ebp], 4095 ; 00000fffH
  0015c	77 0c		 ja	 SHORT $LN27@encoder

; 81   : 					addWBuf = 1;

  0015e	c7 85 38 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _addWBuf$[ebp], 1

; 82   : 				}
; 83   : 				else {

  00168	eb 0a		 jmp	 SHORT $LN26@encoder
$LN27@encoder:

; 84   : 					addWBuf = 2;

  0016a	c7 85 38 ff ff
	ff 02 00 00 00	 mov	 DWORD PTR _addWBuf$[ebp], 2
$LN26@encoder:

; 85   : 				}
; 86   : 				if (wBuf1 + addWBuf >= ewBuf) {

  00174	8b 45 d4	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  00177	03 85 38 ff ff
	ff		 add	 eax, DWORD PTR _addWBuf$[ebp]
  0017d	3b 45 ec	 cmp	 eax, DWORD PTR _ewBuf$[ebp]
  00180	72 0c		 jb	 SHORT $LN29@encoder

; 87   : 					flag = 0;

  00182	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _flag$[ebp], 0

; 88   : 					break;

  00189	e9 0a 05 00 00	 jmp	 $LN3@encoder
$LN29@encoder:

; 89   : 				}
; 90   : 				if (addWBuf == 0) {

  0018e	83 bd 38 ff ff
	ff 00		 cmp	 DWORD PTR _addWBuf$[ebp], 0
  00195	75 2a		 jne	 SHORT $LN30@encoder

; 91   : 					idx |= (cnt & 0x0f);

  00197	8b 45 80	 mov	 eax, DWORD PTR _cnt$[ebp]
  0019a	83 e0 0f	 and	 eax, 15			; 0000000fH
  0019d	0f b6 4d a7	 movzx	 ecx, BYTE PTR _idx$[ebp]
  001a1	0b c8		 or	 ecx, eax
  001a3	88 4d a7	 mov	 BYTE PTR _idx$[ebp], cl

; 92   : 					*wBuf1++ = idx;

  001a6	8b 45 d4	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  001a9	8a 4d a7	 mov	 cl, BYTE PTR _idx$[ebp]
  001ac	88 08		 mov	 BYTE PTR [eax], cl
  001ae	8b 55 d4	 mov	 edx, DWORD PTR _wBuf1$[ebp]
  001b1	83 c2 01	 add	 edx, 1
  001b4	89 55 d4	 mov	 DWORD PTR _wBuf1$[ebp], edx

; 93   : 					continue;

  001b7	e9 f3 fe ff ff	 jmp	 $LN2@encoder

; 94   : 				}
; 95   : 				else

  001bc	e9 a6 00 00 00	 jmp	 $LN23@encoder
$LN30@encoder:

; 96   : 					if (addWBuf == 1) {

  001c1	83 bd 38 ff ff
	ff 01		 cmp	 DWORD PTR _addWBuf$[ebp], 1
  001c8	75 43		 jne	 SHORT $LN32@encoder

; 97   : 						idx |= (BIT_REP_LARG | ((cnt >> 8) & 0xf));

  001ca	8b 45 80	 mov	 eax, DWORD PTR _cnt$[ebp]
  001cd	c1 e8 08	 shr	 eax, 8
  001d0	83 e0 0f	 and	 eax, 15			; 0000000fH
  001d3	83 c8 10	 or	 eax, 16			; 00000010H
  001d6	0f b6 4d a7	 movzx	 ecx, BYTE PTR _idx$[ebp]
  001da	0b c8		 or	 ecx, eax
  001dc	88 4d a7	 mov	 BYTE PTR _idx$[ebp], cl

; 98   : 						*wBuf1++ = idx;

  001df	8b 45 d4	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  001e2	8a 4d a7	 mov	 cl, BYTE PTR _idx$[ebp]
  001e5	88 08		 mov	 BYTE PTR [eax], cl
  001e7	8b 55 d4	 mov	 edx, DWORD PTR _wBuf1$[ebp]
  001ea	83 c2 01	 add	 edx, 1
  001ed	89 55 d4	 mov	 DWORD PTR _wBuf1$[ebp], edx

; 99   : 						*wBuf1++ = (unsigned char)(cnt & 0xff);

  001f0	8b 45 80	 mov	 eax, DWORD PTR _cnt$[ebp]
  001f3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001f8	8b 4d d4	 mov	 ecx, DWORD PTR _wBuf1$[ebp]
  001fb	88 01		 mov	 BYTE PTR [ecx], al
  001fd	8b 55 d4	 mov	 edx, DWORD PTR _wBuf1$[ebp]
  00200	83 c2 01	 add	 edx, 1
  00203	89 55 d4	 mov	 DWORD PTR _wBuf1$[ebp], edx

; 100  : 						continue;

  00206	e9 a4 fe ff ff	 jmp	 $LN2@encoder

; 101  : 					}
; 102  : 					else {

  0020b	eb 5a		 jmp	 SHORT $LN23@encoder
$LN32@encoder:

; 103  : 						idx |= (BIT_REP_LARG2 | ((cnt >> 16) & 0xf));

  0020d	8b 45 80	 mov	 eax, DWORD PTR _cnt$[ebp]
  00210	c1 e8 10	 shr	 eax, 16			; 00000010H
  00213	83 e0 0f	 and	 eax, 15			; 0000000fH
  00216	83 c8 20	 or	 eax, 32			; 00000020H
  00219	0f b6 4d a7	 movzx	 ecx, BYTE PTR _idx$[ebp]
  0021d	0b c8		 or	 ecx, eax
  0021f	88 4d a7	 mov	 BYTE PTR _idx$[ebp], cl

; 104  : 						*wBuf1++ = idx;

  00222	8b 45 d4	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  00225	8a 4d a7	 mov	 cl, BYTE PTR _idx$[ebp]
  00228	88 08		 mov	 BYTE PTR [eax], cl
  0022a	8b 55 d4	 mov	 edx, DWORD PTR _wBuf1$[ebp]
  0022d	83 c2 01	 add	 edx, 1
  00230	89 55 d4	 mov	 DWORD PTR _wBuf1$[ebp], edx

; 105  : 						*wBuf1++ = (unsigned char)((cnt >> 8) & 0xff);

  00233	8b 45 80	 mov	 eax, DWORD PTR _cnt$[ebp]
  00236	c1 e8 08	 shr	 eax, 8
  00239	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0023e	8b 4d d4	 mov	 ecx, DWORD PTR _wBuf1$[ebp]
  00241	88 01		 mov	 BYTE PTR [ecx], al
  00243	8b 55 d4	 mov	 edx, DWORD PTR _wBuf1$[ebp]
  00246	83 c2 01	 add	 edx, 1
  00249	89 55 d4	 mov	 DWORD PTR _wBuf1$[ebp], edx

; 106  : 						*wBuf1++ = (unsigned char)(cnt & 0xff);

  0024c	8b 45 80	 mov	 eax, DWORD PTR _cnt$[ebp]
  0024f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00254	8b 4d d4	 mov	 ecx, DWORD PTR _wBuf1$[ebp]
  00257	88 01		 mov	 BYTE PTR [ecx], al
  00259	8b 55 d4	 mov	 edx, DWORD PTR _wBuf1$[ebp]
  0025c	83 c2 01	 add	 edx, 1
  0025f	89 55 d4	 mov	 DWORD PTR _wBuf1$[ebp], edx

; 107  : 						continue;

  00262	e9 48 fe ff ff	 jmp	 $LN2@encoder
$LN23@encoder:

; 108  : 					}
; 109  : 		}
; 110  : 		if (*buf1 == *(buf1 + 1) && *buf1 == *(buf1 + 2)) {

  00267	8b 45 c8	 mov	 eax, DWORD PTR _buf1$[ebp]
  0026a	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0026d	8b 55 c8	 mov	 edx, DWORD PTR _buf1$[ebp]
  00270	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  00274	3b c8		 cmp	 ecx, eax
  00276	0f 85 cc 01 00
	00		 jne	 $LN34@encoder
  0027c	8b 45 c8	 mov	 eax, DWORD PTR _buf1$[ebp]
  0027f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00282	8b 55 c8	 mov	 edx, DWORD PTR _buf1$[ebp]
  00285	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  00289	3b c8		 cmp	 ecx, eax
  0028b	0f 85 b7 01 00
	00		 jne	 $LN34@encoder

; 111  : 			repData = *buf1;

  00291	8b 45 c8	 mov	 eax, DWORD PTR _buf1$[ebp]
  00294	8a 08		 mov	 cl, BYTE PTR [eax]
  00296	88 8d 6b ff ff
	ff		 mov	 BYTE PTR _repData$[ebp], cl

; 112  : 			idx = BIT_CMP;

  0029c	c6 45 a7 80	 mov	 BYTE PTR _idx$[ebp], 128 ; 00000080H

; 113  : 			cnt = 3;

  002a0	c7 45 80 03 00
	00 00		 mov	 DWORD PTR _cnt$[ebp], 3

; 114  : 			buf1 += 3;

  002a7	8b 45 c8	 mov	 eax, DWORD PTR _buf1$[ebp]
  002aa	83 c0 03	 add	 eax, 3
  002ad	89 45 c8	 mov	 DWORD PTR _buf1$[ebp], eax
$LN6@encoder:

; 115  : 			while (buf1 < eBuf && cnt < 0xfffff) {

  002b0	8b 45 c8	 mov	 eax, DWORD PTR _buf1$[ebp]
  002b3	3b 45 e0	 cmp	 eax, DWORD PTR _eBuf$[ebp]
  002b6	73 30		 jae	 SHORT $LN7@encoder
  002b8	81 7d 80 ff ff
	0f 00		 cmp	 DWORD PTR _cnt$[ebp], 1048575 ; 000fffffH
  002bf	73 27		 jae	 SHORT $LN7@encoder

; 116  : 				if (*buf1 != repData) {

  002c1	8b 45 c8	 mov	 eax, DWORD PTR _buf1$[ebp]
  002c4	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  002c7	0f b6 95 6b ff
	ff ff		 movzx	 edx, BYTE PTR _repData$[ebp]
  002ce	3b ca		 cmp	 ecx, edx
  002d0	74 02		 je	 SHORT $LN35@encoder

; 117  : 					break;

  002d2	eb 14		 jmp	 SHORT $LN7@encoder
$LN35@encoder:

; 118  : 				}
; 119  : 				buf1++;

  002d4	8b 45 c8	 mov	 eax, DWORD PTR _buf1$[ebp]
  002d7	83 c0 01	 add	 eax, 1
  002da	89 45 c8	 mov	 DWORD PTR _buf1$[ebp], eax

; 120  : 				cnt++;

  002dd	8b 45 80	 mov	 eax, DWORD PTR _cnt$[ebp]
  002e0	83 c0 01	 add	 eax, 1
  002e3	89 45 80	 mov	 DWORD PTR _cnt$[ebp], eax

; 121  : 			}

  002e6	eb c8		 jmp	 SHORT $LN6@encoder
$LN7@encoder:

; 122  : 			if (cnt <= 0xf) {

  002e8	83 7d 80 0f	 cmp	 DWORD PTR _cnt$[ebp], 15 ; 0000000fH
  002ec	77 0c		 ja	 SHORT $LN36@encoder

; 123  : 				addWBuf = 1;

  002ee	c7 85 38 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _addWBuf$[ebp], 1

; 124  : 			}
; 125  : 			else

  002f8	eb 1f		 jmp	 SHORT $LN37@encoder
$LN36@encoder:

; 126  : 				if (cnt <= 0xfff) {

  002fa	81 7d 80 ff 0f
	00 00		 cmp	 DWORD PTR _cnt$[ebp], 4095 ; 00000fffH
  00301	77 0c		 ja	 SHORT $LN38@encoder

; 127  : 					addWBuf = 2;

  00303	c7 85 38 ff ff
	ff 02 00 00 00	 mov	 DWORD PTR _addWBuf$[ebp], 2

; 128  : 				}
; 129  : 				else {

  0030d	eb 0a		 jmp	 SHORT $LN37@encoder
$LN38@encoder:

; 130  : 					addWBuf = 3;

  0030f	c7 85 38 ff ff
	ff 03 00 00 00	 mov	 DWORD PTR _addWBuf$[ebp], 3
$LN37@encoder:

; 131  : 				}
; 132  : 				if (wBuf1 + addWBuf >= ewBuf) {

  00319	8b 45 d4	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  0031c	03 85 38 ff ff
	ff		 add	 eax, DWORD PTR _addWBuf$[ebp]
  00322	3b 45 ec	 cmp	 eax, DWORD PTR _ewBuf$[ebp]
  00325	72 0c		 jb	 SHORT $LN40@encoder

; 133  : 					flag = 0;

  00327	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _flag$[ebp], 0

; 134  : 					break;

  0032e	e9 65 03 00 00	 jmp	 $LN3@encoder
$LN40@encoder:

; 135  : 				}
; 136  : 				if (addWBuf == 1) {

  00333	83 bd 38 ff ff
	ff 01		 cmp	 DWORD PTR _addWBuf$[ebp], 1
  0033a	75 3e		 jne	 SHORT $LN41@encoder

; 137  : 					idx |= (cnt & 0x0f);

  0033c	8b 45 80	 mov	 eax, DWORD PTR _cnt$[ebp]
  0033f	83 e0 0f	 and	 eax, 15			; 0000000fH
  00342	0f b6 4d a7	 movzx	 ecx, BYTE PTR _idx$[ebp]
  00346	0b c8		 or	 ecx, eax
  00348	88 4d a7	 mov	 BYTE PTR _idx$[ebp], cl

; 138  : 					*wBuf1++ = idx;

  0034b	8b 45 d4	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  0034e	8a 4d a7	 mov	 cl, BYTE PTR _idx$[ebp]
  00351	88 08		 mov	 BYTE PTR [eax], cl
  00353	8b 55 d4	 mov	 edx, DWORD PTR _wBuf1$[ebp]
  00356	83 c2 01	 add	 edx, 1
  00359	89 55 d4	 mov	 DWORD PTR _wBuf1$[ebp], edx

; 139  : 					*wBuf1++ = repData;

  0035c	8b 45 d4	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  0035f	8a 8d 6b ff ff
	ff		 mov	 cl, BYTE PTR _repData$[ebp]
  00365	88 08		 mov	 BYTE PTR [eax], cl
  00367	8b 55 d4	 mov	 edx, DWORD PTR _wBuf1$[ebp]
  0036a	83 c2 01	 add	 edx, 1
  0036d	89 55 d4	 mov	 DWORD PTR _wBuf1$[ebp], edx

; 140  : 					continue;

  00370	e9 3a fd ff ff	 jmp	 $LN2@encoder

; 141  : 				}
; 142  : 				else

  00375	e9 ce 00 00 00	 jmp	 $LN34@encoder
$LN41@encoder:

; 143  : 					if (addWBuf == 2) {

  0037a	83 bd 38 ff ff
	ff 02		 cmp	 DWORD PTR _addWBuf$[ebp], 2
  00381	75 57		 jne	 SHORT $LN43@encoder

; 144  : 						idx |= (BIT_REP_LARG | ((cnt >> 8) & 0xf));

  00383	8b 45 80	 mov	 eax, DWORD PTR _cnt$[ebp]
  00386	c1 e8 08	 shr	 eax, 8
  00389	83 e0 0f	 and	 eax, 15			; 0000000fH
  0038c	83 c8 10	 or	 eax, 16			; 00000010H
  0038f	0f b6 4d a7	 movzx	 ecx, BYTE PTR _idx$[ebp]
  00393	0b c8		 or	 ecx, eax
  00395	88 4d a7	 mov	 BYTE PTR _idx$[ebp], cl

; 145  : 						*wBuf1++ = idx;

  00398	8b 45 d4	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  0039b	8a 4d a7	 mov	 cl, BYTE PTR _idx$[ebp]
  0039e	88 08		 mov	 BYTE PTR [eax], cl
  003a0	8b 55 d4	 mov	 edx, DWORD PTR _wBuf1$[ebp]
  003a3	83 c2 01	 add	 edx, 1
  003a6	89 55 d4	 mov	 DWORD PTR _wBuf1$[ebp], edx

; 146  : 						*wBuf1++ = repData;

  003a9	8b 45 d4	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  003ac	8a 8d 6b ff ff
	ff		 mov	 cl, BYTE PTR _repData$[ebp]
  003b2	88 08		 mov	 BYTE PTR [eax], cl
  003b4	8b 55 d4	 mov	 edx, DWORD PTR _wBuf1$[ebp]
  003b7	83 c2 01	 add	 edx, 1
  003ba	89 55 d4	 mov	 DWORD PTR _wBuf1$[ebp], edx

; 147  : 						*wBuf1++ = (unsigned char)(cnt & 0xff);

  003bd	8b 45 80	 mov	 eax, DWORD PTR _cnt$[ebp]
  003c0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003c5	8b 4d d4	 mov	 ecx, DWORD PTR _wBuf1$[ebp]
  003c8	88 01		 mov	 BYTE PTR [ecx], al
  003ca	8b 55 d4	 mov	 edx, DWORD PTR _wBuf1$[ebp]
  003cd	83 c2 01	 add	 edx, 1
  003d0	89 55 d4	 mov	 DWORD PTR _wBuf1$[ebp], edx

; 148  : 						continue;

  003d3	e9 d7 fc ff ff	 jmp	 $LN2@encoder

; 149  : 					}
; 150  : 					else {

  003d8	eb 6e		 jmp	 SHORT $LN34@encoder
$LN43@encoder:

; 151  : 						idx |= (BIT_REP_LARG2 | ((cnt >> 16) & 0xf));

  003da	8b 45 80	 mov	 eax, DWORD PTR _cnt$[ebp]
  003dd	c1 e8 10	 shr	 eax, 16			; 00000010H
  003e0	83 e0 0f	 and	 eax, 15			; 0000000fH
  003e3	83 c8 20	 or	 eax, 32			; 00000020H
  003e6	0f b6 4d a7	 movzx	 ecx, BYTE PTR _idx$[ebp]
  003ea	0b c8		 or	 ecx, eax
  003ec	88 4d a7	 mov	 BYTE PTR _idx$[ebp], cl

; 152  : 						*wBuf1++ = idx;

  003ef	8b 45 d4	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  003f2	8a 4d a7	 mov	 cl, BYTE PTR _idx$[ebp]
  003f5	88 08		 mov	 BYTE PTR [eax], cl
  003f7	8b 55 d4	 mov	 edx, DWORD PTR _wBuf1$[ebp]
  003fa	83 c2 01	 add	 edx, 1
  003fd	89 55 d4	 mov	 DWORD PTR _wBuf1$[ebp], edx

; 153  : 						*wBuf1++ = repData;

  00400	8b 45 d4	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  00403	8a 8d 6b ff ff
	ff		 mov	 cl, BYTE PTR _repData$[ebp]
  00409	88 08		 mov	 BYTE PTR [eax], cl
  0040b	8b 55 d4	 mov	 edx, DWORD PTR _wBuf1$[ebp]
  0040e	83 c2 01	 add	 edx, 1
  00411	89 55 d4	 mov	 DWORD PTR _wBuf1$[ebp], edx

; 154  : 						*wBuf1++ = (unsigned char)((cnt >> 8) & 0xff);

  00414	8b 45 80	 mov	 eax, DWORD PTR _cnt$[ebp]
  00417	c1 e8 08	 shr	 eax, 8
  0041a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0041f	8b 4d d4	 mov	 ecx, DWORD PTR _wBuf1$[ebp]
  00422	88 01		 mov	 BYTE PTR [ecx], al
  00424	8b 55 d4	 mov	 edx, DWORD PTR _wBuf1$[ebp]
  00427	83 c2 01	 add	 edx, 1
  0042a	89 55 d4	 mov	 DWORD PTR _wBuf1$[ebp], edx

; 155  : 						*wBuf1++ = (unsigned char)(cnt & 0xff);

  0042d	8b 45 80	 mov	 eax, DWORD PTR _cnt$[ebp]
  00430	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00435	8b 4d d4	 mov	 ecx, DWORD PTR _wBuf1$[ebp]
  00438	88 01		 mov	 BYTE PTR [ecx], al
  0043a	8b 55 d4	 mov	 edx, DWORD PTR _wBuf1$[ebp]
  0043d	83 c2 01	 add	 edx, 1
  00440	89 55 d4	 mov	 DWORD PTR _wBuf1$[ebp], edx

; 156  : 						continue;

  00443	e9 67 fc ff ff	 jmp	 $LN2@encoder
$LN34@encoder:

; 157  : 					}
; 158  : 		}
; 159  : 		idx = 0;

  00448	c6 45 a7 00	 mov	 BYTE PTR _idx$[ebp], 0

; 160  : 		cnt2 = 0;

  0044c	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _cnt2$[ebp], 0

; 161  : 		buf2 = buf1;

  00456	8b 45 c8	 mov	 eax, DWORD PTR _buf1$[ebp]
  00459	89 45 b0	 mov	 DWORD PTR _buf2$[ebp], eax

; 162  : 		wBuf2 = wBuf1;

  0045c	8b 45 d4	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  0045f	89 45 bc	 mov	 DWORD PTR _wBuf2$[ebp], eax
$LN8@encoder:

; 163  : 		while (1) {

  00462	b8 01 00 00 00	 mov	 eax, 1
  00467	85 c0		 test	 eax, eax
  00469	0f 84 c5 00 00
	00		 je	 $LN9@encoder

; 164  : 			if (buf2 >= eBuf || cnt2 >= 0xfff) {

  0046f	8b 45 b0	 mov	 eax, DWORD PTR _buf2$[ebp]
  00472	3b 45 e0	 cmp	 eax, DWORD PTR _eBuf$[ebp]
  00475	73 0c		 jae	 SHORT $LN46@encoder
  00477	81 bd 74 ff ff
	ff ff 0f 00 00	 cmp	 DWORD PTR _cnt2$[ebp], 4095 ; 00000fffH
  00481	72 0f		 jb	 SHORT $LN45@encoder
$LN46@encoder:

; 165  : 				mode = 0;

  00483	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _mode$[ebp], 0

; 166  : 				break;

  0048d	e9 a2 00 00 00	 jmp	 $LN9@encoder
$LN45@encoder:

; 167  : 			}
; 168  : 			if (wBuf2 >= ewBuf) {

  00492	8b 45 bc	 mov	 eax, DWORD PTR _wBuf2$[ebp]
  00495	3b 45 ec	 cmp	 eax, DWORD PTR _ewBuf$[ebp]
  00498	72 0f		 jb	 SHORT $LN47@encoder

; 169  : 				mode = 1;

  0049a	c7 85 5c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _mode$[ebp], 1

; 170  : 				break;

  004a4	e9 8b 00 00 00	 jmp	 $LN9@encoder
$LN47@encoder:

; 171  : 			}
; 172  : 			if (buf2 + 2 < eBuf) {

  004a9	8b 45 b0	 mov	 eax, DWORD PTR _buf2$[ebp]
  004ac	83 c0 02	 add	 eax, 2
  004af	3b 45 e0	 cmp	 eax, DWORD PTR _eBuf$[ebp]
  004b2	73 5a		 jae	 SHORT $LN48@encoder

; 173  : 				if (*buf2 == 0 && *(buf2 + 1) == 0) {

  004b4	8b 45 b0	 mov	 eax, DWORD PTR _buf2$[ebp]
  004b7	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  004ba	85 c9		 test	 ecx, ecx
  004bc	75 17		 jne	 SHORT $LN49@encoder
  004be	8b 45 b0	 mov	 eax, DWORD PTR _buf2$[ebp]
  004c1	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  004c5	85 c9		 test	 ecx, ecx
  004c7	75 0c		 jne	 SHORT $LN49@encoder

; 174  : 					mode = 0;

  004c9	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _mode$[ebp], 0

; 175  : 					break;

  004d3	eb 5f		 jmp	 SHORT $LN9@encoder
$LN49@encoder:

; 176  : 				}
; 177  : 				if (*buf2 != 0 && *buf2 == *(buf2 + 1) && *(buf2 + 1) == *(buf2 + 2)) {

  004d5	8b 45 b0	 mov	 eax, DWORD PTR _buf2$[ebp]
  004d8	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  004db	85 c9		 test	 ecx, ecx
  004dd	74 2f		 je	 SHORT $LN48@encoder
  004df	8b 45 b0	 mov	 eax, DWORD PTR _buf2$[ebp]
  004e2	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  004e5	8b 55 b0	 mov	 edx, DWORD PTR _buf2$[ebp]
  004e8	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  004ec	3b c8		 cmp	 ecx, eax
  004ee	75 1e		 jne	 SHORT $LN48@encoder
  004f0	8b 45 b0	 mov	 eax, DWORD PTR _buf2$[ebp]
  004f3	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  004f7	8b 55 b0	 mov	 edx, DWORD PTR _buf2$[ebp]
  004fa	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  004fe	3b c8		 cmp	 ecx, eax
  00500	75 0c		 jne	 SHORT $LN48@encoder

; 178  : 					mode = 0;

  00502	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _mode$[ebp], 0

; 179  : 					break;

  0050c	eb 26		 jmp	 SHORT $LN9@encoder
$LN48@encoder:

; 180  : 				}
; 181  : 
; 182  : 			}
; 183  : 			buf2++;

  0050e	8b 45 b0	 mov	 eax, DWORD PTR _buf2$[ebp]
  00511	83 c0 01	 add	 eax, 1
  00514	89 45 b0	 mov	 DWORD PTR _buf2$[ebp], eax

; 184  : 			wBuf2++;

  00517	8b 45 bc	 mov	 eax, DWORD PTR _wBuf2$[ebp]
  0051a	83 c0 01	 add	 eax, 1
  0051d	89 45 bc	 mov	 DWORD PTR _wBuf2$[ebp], eax

; 185  : 			cnt2++;

  00520	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _cnt2$[ebp]
  00526	83 c0 01	 add	 eax, 1
  00529	89 85 74 ff ff
	ff		 mov	 DWORD PTR _cnt2$[ebp], eax

; 186  : 		}

  0052f	e9 2e ff ff ff	 jmp	 $LN8@encoder
$LN9@encoder:

; 187  : 		if (cnt2 <= 0xf) {

  00534	83 bd 74 ff ff
	ff 0f		 cmp	 DWORD PTR _cnt2$[ebp], 15 ; 0000000fH
  0053b	77 0c		 ja	 SHORT $LN51@encoder

; 188  : 			addWBuf = 0;

  0053d	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _addWBuf$[ebp], 0

; 189  : 		}
; 190  : 		else

  00547	eb 22		 jmp	 SHORT $LN52@encoder
$LN51@encoder:

; 191  : 			if (cnt2 <= 0xfff) {

  00549	81 bd 74 ff ff
	ff ff 0f 00 00	 cmp	 DWORD PTR _cnt2$[ebp], 4095 ; 00000fffH
  00553	77 0c		 ja	 SHORT $LN53@encoder

; 192  : 				addWBuf = 1;

  00555	c7 85 38 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _addWBuf$[ebp], 1

; 193  : 			}
; 194  : 			else {

  0055f	eb 0a		 jmp	 SHORT $LN52@encoder
$LN53@encoder:

; 195  : 				addWBuf = 2;

  00561	c7 85 38 ff ff
	ff 02 00 00 00	 mov	 DWORD PTR _addWBuf$[ebp], 2
$LN52@encoder:

; 196  : 			}
; 197  : 
; 198  : 			if (mode == 1 || wBuf2 + addWBuf >= ewBuf) {

  0056b	83 bd 5c ff ff
	ff 01		 cmp	 DWORD PTR _mode$[ebp], 1
  00572	74 0e		 je	 SHORT $LN56@encoder
  00574	8b 45 bc	 mov	 eax, DWORD PTR _wBuf2$[ebp]
  00577	03 85 38 ff ff
	ff		 add	 eax, DWORD PTR _addWBuf$[ebp]
  0057d	3b 45 ec	 cmp	 eax, DWORD PTR _ewBuf$[ebp]
  00580	72 0c		 jb	 SHORT $LN55@encoder
$LN56@encoder:

; 199  : 				flag = 0;

  00582	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _flag$[ebp], 0

; 200  : 				break;

  00589	e9 0a 01 00 00	 jmp	 $LN3@encoder
$LN55@encoder:

; 201  : 			}
; 202  : 			if (addWBuf == 0) {

  0058e	83 bd 38 ff ff
	ff 00		 cmp	 DWORD PTR _addWBuf$[ebp], 0
  00595	75 22		 jne	 SHORT $LN57@encoder

; 203  : 				idx = (cnt2 & 0xf);

  00597	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _cnt2$[ebp]
  0059d	83 e0 0f	 and	 eax, 15			; 0000000fH
  005a0	88 45 a7	 mov	 BYTE PTR _idx$[ebp], al

; 204  : 				*wBuf1++ = idx;

  005a3	8b 45 d4	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  005a6	8a 4d a7	 mov	 cl, BYTE PTR _idx$[ebp]
  005a9	88 08		 mov	 BYTE PTR [eax], cl
  005ab	8b 55 d4	 mov	 edx, DWORD PTR _wBuf1$[ebp]
  005ae	83 c2 01	 add	 edx, 1
  005b1	89 55 d4	 mov	 DWORD PTR _wBuf1$[ebp], edx

; 205  : 			}
; 206  : 			else

  005b4	e9 9f 00 00 00	 jmp	 $LN58@encoder
$LN57@encoder:

; 207  : 				if (addWBuf == 1) {

  005b9	83 bd 38 ff ff
	ff 01		 cmp	 DWORD PTR _addWBuf$[ebp], 1
  005c0	75 3e		 jne	 SHORT $LN59@encoder

; 208  : 					idx = BIT_REP_LARG | ((cnt2 >> 8) & 0xf);

  005c2	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _cnt2$[ebp]
  005c8	c1 e8 08	 shr	 eax, 8
  005cb	83 e0 0f	 and	 eax, 15			; 0000000fH
  005ce	83 c8 10	 or	 eax, 16			; 00000010H
  005d1	88 45 a7	 mov	 BYTE PTR _idx$[ebp], al

; 209  : 					*wBuf1++ = idx;

  005d4	8b 45 d4	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  005d7	8a 4d a7	 mov	 cl, BYTE PTR _idx$[ebp]
  005da	88 08		 mov	 BYTE PTR [eax], cl
  005dc	8b 55 d4	 mov	 edx, DWORD PTR _wBuf1$[ebp]
  005df	83 c2 01	 add	 edx, 1
  005e2	89 55 d4	 mov	 DWORD PTR _wBuf1$[ebp], edx

; 210  : 					*wBuf1++ = (unsigned char)(cnt2 & 0xff);

  005e5	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _cnt2$[ebp]
  005eb	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  005f0	8b 4d d4	 mov	 ecx, DWORD PTR _wBuf1$[ebp]
  005f3	88 01		 mov	 BYTE PTR [ecx], al
  005f5	8b 55 d4	 mov	 edx, DWORD PTR _wBuf1$[ebp]
  005f8	83 c2 01	 add	 edx, 1
  005fb	89 55 d4	 mov	 DWORD PTR _wBuf1$[ebp], edx

; 211  : 				}
; 212  : 				else {

  005fe	eb 58		 jmp	 SHORT $LN58@encoder
$LN59@encoder:

; 213  : 					idx = BIT_REP_LARG2 | ((cnt2 >> 16) & 0xf);

  00600	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _cnt2$[ebp]
  00606	c1 e8 10	 shr	 eax, 16			; 00000010H
  00609	83 e0 0f	 and	 eax, 15			; 0000000fH
  0060c	83 c8 20	 or	 eax, 32			; 00000020H
  0060f	88 45 a7	 mov	 BYTE PTR _idx$[ebp], al

; 214  : 					*wBuf1++ = idx;

  00612	8b 45 d4	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  00615	8a 4d a7	 mov	 cl, BYTE PTR _idx$[ebp]
  00618	88 08		 mov	 BYTE PTR [eax], cl
  0061a	8b 55 d4	 mov	 edx, DWORD PTR _wBuf1$[ebp]
  0061d	83 c2 01	 add	 edx, 1
  00620	89 55 d4	 mov	 DWORD PTR _wBuf1$[ebp], edx

; 215  : 					*wBuf1++ = (unsigned char)((cnt2 >> 8) & 0xff);

  00623	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _cnt2$[ebp]
  00629	c1 e8 08	 shr	 eax, 8
  0062c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00631	8b 4d d4	 mov	 ecx, DWORD PTR _wBuf1$[ebp]
  00634	88 01		 mov	 BYTE PTR [ecx], al
  00636	8b 55 d4	 mov	 edx, DWORD PTR _wBuf1$[ebp]
  00639	83 c2 01	 add	 edx, 1
  0063c	89 55 d4	 mov	 DWORD PTR _wBuf1$[ebp], edx

; 216  : 					*wBuf1++ = (unsigned char)(cnt2 & 0xff);

  0063f	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _cnt2$[ebp]
  00645	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0064a	8b 4d d4	 mov	 ecx, DWORD PTR _wBuf1$[ebp]
  0064d	88 01		 mov	 BYTE PTR [ecx], al
  0064f	8b 55 d4	 mov	 edx, DWORD PTR _wBuf1$[ebp]
  00652	83 c2 01	 add	 edx, 1
  00655	89 55 d4	 mov	 DWORD PTR _wBuf1$[ebp], edx
$LN58@encoder:

; 217  : 				}
; 218  : 				for (cnt = 0; cnt < cnt2; cnt++) {

  00658	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _cnt$[ebp], 0
  0065f	eb 09		 jmp	 SHORT $LN12@encoder
$LN10@encoder:
  00661	8b 45 80	 mov	 eax, DWORD PTR _cnt$[ebp]
  00664	83 c0 01	 add	 eax, 1
  00667	89 45 80	 mov	 DWORD PTR _cnt$[ebp], eax
$LN12@encoder:
  0066a	8b 45 80	 mov	 eax, DWORD PTR _cnt$[ebp]
  0066d	3b 85 74 ff ff
	ff		 cmp	 eax, DWORD PTR _cnt2$[ebp]
  00673	73 1e		 jae	 SHORT $LN11@encoder

; 219  : 					*wBuf1++ = *buf1++;

  00675	8b 45 d4	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  00678	8b 4d c8	 mov	 ecx, DWORD PTR _buf1$[ebp]
  0067b	8a 11		 mov	 dl, BYTE PTR [ecx]
  0067d	88 10		 mov	 BYTE PTR [eax], dl
  0067f	8b 45 d4	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  00682	83 c0 01	 add	 eax, 1
  00685	89 45 d4	 mov	 DWORD PTR _wBuf1$[ebp], eax
  00688	8b 4d c8	 mov	 ecx, DWORD PTR _buf1$[ebp]
  0068b	83 c1 01	 add	 ecx, 1
  0068e	89 4d c8	 mov	 DWORD PTR _buf1$[ebp], ecx

; 220  : 				}

  00691	eb ce		 jmp	 SHORT $LN10@encoder
$LN11@encoder:

; 221  : 	}

  00693	e9 17 fa ff ff	 jmp	 $LN2@encoder
$LN3@encoder:

; 222  : 
; 223  : 
; 224  : 	header = (RD_HEADER *)wBuf;

  00698	8b 45 f8	 mov	 eax, DWORD PTR _wBuf$[ebp]
  0069b	89 45 8c	 mov	 DWORD PTR _header$[ebp], eax

; 225  : 	header->id[0] = 'R';

  0069e	b8 01 00 00 00	 mov	 eax, 1
  006a3	6b c8 00	 imul	 ecx, eax, 0
  006a6	8b 55 8c	 mov	 edx, DWORD PTR _header$[ebp]
  006a9	c6 04 0a 52	 mov	 BYTE PTR [edx+ecx], 82	; 00000052H

; 226  : 	header->id[1] = 'D';

  006ad	b8 01 00 00 00	 mov	 eax, 1
  006b2	c1 e0 00	 shl	 eax, 0
  006b5	8b 4d 8c	 mov	 ecx, DWORD PTR _header$[ebp]
  006b8	c6 04 01 44	 mov	 BYTE PTR [ecx+eax], 68	; 00000044H

; 227  : 	header->width = width;

  006bc	8b 45 8c	 mov	 eax, DWORD PTR _header$[ebp]
  006bf	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  006c2	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 228  : 	header->height = height;

  006c5	8b 45 8c	 mov	 eax, DWORD PTR _header$[ebp]
  006c8	8b 4d 14	 mov	 ecx, DWORD PTR _height$[ebp]
  006cb	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 229  : 
; 230  : 	if (flag == 1)

  006ce	83 7d 98 01	 cmp	 DWORD PTR _flag$[ebp], 1
  006d2	75 24		 jne	 SHORT $LN61@encoder

; 231  : 	{
; 232  : 		header->compressFlag = 1;

  006d4	8b 45 8c	 mov	 eax, DWORD PTR _header$[ebp]
  006d7	c6 40 02 01	 mov	 BYTE PTR [eax+2], 1

; 233  : 		header->size = wBuf1 - wBuf;

  006db	8b 45 d4	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  006de	2b 45 f8	 sub	 eax, DWORD PTR _wBuf$[ebp]
  006e1	8b 4d 8c	 mov	 ecx, DWORD PTR _header$[ebp]
  006e4	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 234  : 		l = header->size;

  006e7	8b 45 8c	 mov	 eax, DWORD PTR _header$[ebp]
  006ea	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  006ed	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _l$[ebp], ecx

; 235  : 	}
; 236  : 	else

  006f3	e9 8d 00 00 00	 jmp	 $LN62@encoder
$LN61@encoder:

; 237  : 		// ?¸Œ??????
; 238  : 	{
; 239  : 		header->compressFlag = 0;

  006f8	8b 45 8c	 mov	 eax, DWORD PTR _header$[ebp]
  006fb	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0

; 240  : 		header->size = (int)wBuf + width * height + sizeof(RD_HEADER);

  006ff	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  00702	0f af 45 14	 imul	 eax, DWORD PTR _height$[ebp]
  00706	8b 4d f8	 mov	 ecx, DWORD PTR _wBuf$[ebp]
  00709	8d 54 01 10	 lea	 edx, DWORD PTR [ecx+eax+16]
  0070d	8b 45 8c	 mov	 eax, DWORD PTR _header$[ebp]
  00710	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 241  : 		wBuf1 = wBuf + sizeof(RD_HEADER);

  00713	8b 45 f8	 mov	 eax, DWORD PTR _wBuf$[ebp]
  00716	83 c0 10	 add	 eax, 16			; 00000010H
  00719	89 45 d4	 mov	 DWORD PTR _wBuf1$[ebp], eax

; 242  : 		buf1 = buf;

  0071c	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0071f	89 45 c8	 mov	 DWORD PTR _buf1$[ebp], eax

; 243  : 		el = width * height;

  00722	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  00725	0f af 45 14	 imul	 eax, DWORD PTR _height$[ebp]
  00729	89 85 44 ff ff
	ff		 mov	 DWORD PTR _el$[ebp], eax

; 244  : 		for (l = 0; l < el; l++)

  0072f	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _l$[ebp], 0
  00739	eb 0f		 jmp	 SHORT $LN15@encoder
$LN13@encoder:
  0073b	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _l$[ebp]
  00741	83 c0 01	 add	 eax, 1
  00744	89 85 50 ff ff
	ff		 mov	 DWORD PTR _l$[ebp], eax
$LN15@encoder:
  0074a	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _l$[ebp]
  00750	3b 85 44 ff ff
	ff		 cmp	 eax, DWORD PTR _el$[ebp]
  00756	73 1e		 jae	 SHORT $LN14@encoder

; 245  : 			*wBuf1++ = *buf1++;

  00758	8b 45 d4	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  0075b	8b 4d c8	 mov	 ecx, DWORD PTR _buf1$[ebp]
  0075e	8a 11		 mov	 dl, BYTE PTR [ecx]
  00760	88 10		 mov	 BYTE PTR [eax], dl
  00762	8b 45 d4	 mov	 eax, DWORD PTR _wBuf1$[ebp]
  00765	83 c0 01	 add	 eax, 1
  00768	89 45 d4	 mov	 DWORD PTR _wBuf1$[ebp], eax
  0076b	8b 4d c8	 mov	 ecx, DWORD PTR _buf1$[ebp]
  0076e	83 c1 01	 add	 ecx, 1
  00771	89 4d c8	 mov	 DWORD PTR _buf1$[ebp], ecx
  00774	eb c5		 jmp	 SHORT $LN13@encoder
$LN14@encoder:

; 246  : 		l += sizeof(RD_HEADER);

  00776	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _l$[ebp]
  0077c	83 c0 10	 add	 eax, 16			; 00000010H
  0077f	89 85 50 ff ff
	ff		 mov	 DWORD PTR _l$[ebp], eax
$LN62@encoder:

; 247  : 	}
; 248  : 
; 249  : 	*len = l;

  00785	8b 45 18	 mov	 eax, DWORD PTR _len$[ebp]
  00788	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _l$[ebp]
  0078e	89 08		 mov	 DWORD PTR [eax], ecx

; 250  : 	return wBuf;

  00790	8b 45 f8	 mov	 eax, DWORD PTR _wBuf$[ebp]
$LN1@encoder:

; 251  : }

  00793	5f		 pop	 edi
  00794	5e		 pop	 esi
  00795	5b		 pop	 ebx
  00796	81 c4 8c 01 00
	00		 add	 esp, 396		; 0000018cH
  0079c	3b ec		 cmp	 ebp, esp
  0079e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  007a3	8b e5		 mov	 esp, ebp
  007a5	5d		 pop	 ebp
  007a6	c3		 ret	 0
?encoder@@YAPAEPAEPAPAEIIPAIH@Z ENDP			; encoder
_TEXT	ENDS
END
